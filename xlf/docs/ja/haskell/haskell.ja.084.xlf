<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; の機能は二つのリストを返すとり &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; のどこ秒以内に、完全に無傷の、含まれている最初のリストIFFを。</target>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; の関数は二つのリストを受け取り、返す &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 最初のリストは、第二の接尾辞である場合に限っ。2番目のリストは有限でなければなりません。</target>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; の組み合わせのような機能の振る舞い &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; の。リストの各要素に関数を適用し、累積パラメーターを左から右に渡し、このアキュムレーターの最終値を新しいリストと共に返します。</target>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; の組み合わせのような機能の振る舞い &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 。リストの各要素に関数を適用し、累積パラメーターを右から左に渡し、新しいリストと共にこのアキュムレーターの最終値を返します。</target>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; の機能は、比較関数とリストを取り、比較関数によってリストの最大の要素を返します。リストは有限で空でない必要があります。</target>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; の機能は、比較機能とリストを受け取り、比較関数によってリストの最低要素を返します。リストは有限で空でない必要があります。</target>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; の機能は、ちょうど同じように動作し &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ではなく、オーバーロードのユーザ供給等価述語使用する以外、 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 機能を。</target>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 関数は、リスト述語を取り、行うと、それぞれの述語を満たさない要素のリストのペアを返します。つまり、</target>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 関数は、引数のすべての順列のリストを返します。</target>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 機能は、数字の有限リストの積を計算します。</target>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 機能は、ソートアルゴリズムの安定を実現しています。これは、プログラマーが独自の比較関数を提供できるようにする &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; の特殊なケースです。</target>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 機能は、非オーバーロードされたバージョンで &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 関数は、引数のすべてのサブシーケンスのリストを返します。</target>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 関数は、数値の有限リストの合計を計算します。</target>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 関数は引数の行と列を転置します。例えば、</target>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 機能はする「`デュアルある &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ：ながら、 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; は要約値にリストを減らし、 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; はシード値からリストを作成します。関数は要素を受け取り、リストの生成が完了した場合は &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返すか &lt;code&gt;(a,b)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; （a、b）を返します。この場合、 &lt;code&gt;a&lt;/code&gt; はリストの先頭に付加され、 &lt;code&gt;b&lt;/code&gt; は再帰呼び出しの次の要素として使用されます。例えば、</target>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 機能は、二つのリストのリストの和集合を返します。例えば、</target>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; の機能は、非オーバーロードされたバージョンである &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 機能はに類似した、トリプルとリターン3つのリストのリストを取り &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 機能はに類似し、四倍とリターン4つのリストのリストを取り &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 機能はに類似し、5タプルとリターン5つのリストのリストを受け取り &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 機能は、6つのタプルのリストを受け取り、に似6つのリスト、返し &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 機能はに類似し、7タプルとリターン7つのリストのリストを受け取り &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 機能は4つのリストを受け取り、に類似した四倍のリスト、返し &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; ファイルを。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 機能は、5つのリストを受け取り、に類似した5つのタプルのリストを返し &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; ファイルを。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 機能は6個のリストを取り、に類似した6つのタプルのリストを返し &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; ファイルを。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 機能は7個のリストを取り、に類似した7つのタプルのリスト、返し &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; ファイルを。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; の機能は3つの要素だけでなく、3つのリストを組み合わせて、に類似し、そのポイントごとの組み合わせのリスト、返す関数取る &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; を。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; の機能は四つの要素だけでなく、4つのリストを結合しに類似し、そのポイントごとの組み合わせのリスト、返す関数取る &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; を。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; の機能は、5つの要素だけでなく、5つのリストを組み合わせ、に類似し、そのポイントごとの組み合わせのリスト、返す関数取る &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; を。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; の機能は、6つの要素だけでなく、6つのリストを組み合わせ、に類似し、そのポイントごとの組み合わせのリスト、返す関数取る &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; を。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; の機能は7つの要素だけでなく、7つのリストを組み合わせ、に類似し、そのポイントごとの組み合わせのリスト、返す関数取る &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; を。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 型と操作。</target>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; の機能は、ある型から別の型のポインタをキャストします。</target>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="translated">基本的なデータ型の &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; クラスとインスタンス。</target>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 関数は、初期ホワイトスペースを破棄、入力から単一の語彙素を読み出し、語彙素を構成する文字を返します。入力文字列に空白のみが含まれている場合、 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; は空の文字列で構成される単一の成功した「語彙素」を返します。（したがって &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）入力文字列の先頭に有効な語彙素がない場合、 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; は失敗します（つまり、 &lt;code&gt;[]&lt;/code&gt; を返します）。</target>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラス、および関連事業。</target>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。</target>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; を検索するために使用できる &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; の機能を使用すると、中にI / Oの計算を実行することができます &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; のモナド。注意：単一の &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 計算内での &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; の呼び出し順序は保証されますが、スプライスが実行される順序は保証されません。</target>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; のタイプ、値 &lt;code&gt;q&lt;/code&gt; は、このタイプの構文で使用することができます &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt; 。実際、便宜上、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; は実際には、異なるスプライスコンテキストで使用される複数の準クォータを定義しています。あなただけの表現に使用するquasiquoterを定義するに興味があるなら、あなたは定義する &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; をだけで &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt; 、およびエラーでアウトスタブ他のフィールドを残して。</target>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; の機能を使用すると、中にI / Oの計算を実行することができます &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; のモナド。注意：単一の &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 計算内での &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; の呼び出し順序は保証されますが、スプライスが実行される順序は保証されません。</target>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; クラスタイプの上限値と下限値に名前を付けるために使用されます。完全に順序付けられていない型には上限と下限がある場合があるため、 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; のスーパークラスではありません。</target>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; クラスは、任意の列挙型に対して導出されてもよいです。 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;data&lt;/code&gt; 宣言にリストされている最初のコンストラクタで、 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; は最後です。 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; は、構成要素の型が &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; にある単一コンストラクターのデータ型に対しても導出できます。</target>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; タイプは、しばしば正しいかエラーのいずれかである値を表すために使用されます。慣例により、 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクターはエラー値を保持するために使用され、 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクターは正しい値を保持するために使用されます（ニーモニック：「右」は「正しい」も意味します）。</target>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; タイプは、二つの可能性と値を表す：種類の値 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; いずれかである &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 又は &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラス定義の等価（ &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）及び式（ &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ）。&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;によってエクスポートされるすべての基本的なデータ型は &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; のインスタンスであり、 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; は、構成要素も &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; のインスタンスである任意のデータ型に対して導出できます。</target>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; タイプは、任意の値をカプセル化します。型の値は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; どちらのタイプの値が含まれている（ように表さ &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; A）、またはそれは（のように表さ空で &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; など、抜本的な対策に頼ることなく、エラーや例外的な場合に対処するための良い方法です &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; タイプもモナドです。これは単純な種類のエラーモナドであり、すべてのエラーは &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; で表されます。 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 型を使用すると、より豊富なエラーモナドを構築できます。</target>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; クラスは、上の基本的な操作を定義&lt;em&gt;モナド&lt;/em&gt;として知られている数学の枝から、コンセプトを&lt;em&gt;カテゴリ理論&lt;/em&gt;。ただし、Haskellプログラマーの観点からは、モナドをアクションの&lt;em&gt;抽象的なデータ型&lt;/em&gt;と考えるのが最善です。Haskellの &lt;code&gt;do&lt;/code&gt; 式は、モナド式を記述するための便利な構文を提供します。</target>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスを使用すると、失敗する可能性のある複数のアクションを連鎖させ、個々のステップのいずれかが失敗した場合は全体的に失敗させることができます。最初に、 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; を解析するか、失敗する関数を作成します。</target>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; クラスは全順序のデータ型に使用されます。</target>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスの &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 値を無視しますが、指定された関数を &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; に含まれる値に適用します：</target>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; の方法は、型に限定 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; の操作は、それが（同様に必要とされるように遅延して読み出された単一の文字列として、すべてのユーザー入力を返す &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 機能は、タイプの機能とる &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 引数として。標準入力デバイスからの入力全体が引数としてこの関数に渡され、結果の文字列が標準出力デバイスに出力されます。</target>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 関数は、初期ホワイトスペースを破棄、入力から単一の語彙素を読み出し、語彙素を構成する文字を返します。入力文字列に空白のみが含まれている場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; は空の文字列で構成される単一の成功した「語彙素」を返します。（したがって &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）入力文字列の先頭に有効な語彙素がない場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; は失敗します（つまり、 &lt;code&gt;[]&lt;/code&gt; を返します）。</target>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 機能は、デフォルト値、機能、およびかかる &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 価値を。場合は &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 価値がある &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 、関数はデフォルト値を返します。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 内の値に関数を適用し、結果を返します。</target>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 機能は、標準出力デバイスに印刷可能な任意のタイプの値を出力します。印刷可能なタイプは、 &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスのインスタンスであるタイプです。 &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 操作を使用して出力用の値を文字列に変換し、改行を追加します。</target>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 機能は、構造体の数との積を計算します。</target>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 機能は、完全に入力処理によって消費されなければならない文字列からの入力を読み取ります。解析が失敗した場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 失敗するため、実際のアプリケーションでの使用はお勧めしません。安全な代替手段として &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 関数は、ファイルを読み込み、ファイルの内容を文字列として返します。 &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; と同様に、ファイルはオンデマンドで遅延読み取りされます。</target>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 関数はに似て &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; それが解析故障信号こと以外 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; はプログラムを終了するのではなく、モナド。</target>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; の機能を兼ね備え &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 関数は、構造体の数の和を計算します。</target>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; の方法は、型に限定 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 機能はに類似した、トリプルとリターン3つのリストのリストを取り &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; の機能は3つの要素だけでなく、3つのリストを組み合わせて、に類似し、そのポイントごとの組み合わせのリスト、返す関数取る &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; を。リストの融合は可能ですが、最初のリスト引数とその結果のリストに制限されます。</target>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の入力機能（例えば &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）自動的にUnicodeに変換されませんので、この機能は、適切なUnicode文字列に指定されたコードページでマルチバイト文字列からの変換を行うために提供されます。コンソールのコードページを取得するには、 &lt;code&gt;getConsoleCP&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1d9c12dfa8f43bbbd8a126756fa99035e9751842" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の入力機能（例えば &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）自動的にUnicodeに変換されませんので、この機能は、適切なUnicode文字列に指定されたコードページでマルチバイト文字列からの変換を行うために提供されます。コンソールのコードページを取得するには、 &lt;code&gt;getConsoleCP&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; モナド変圧器、ユーザーのラインの履歴の状態に直接、低レベルのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; の方法は、「リフト」に（のようなIOアクション管理機能私たちを可能に &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 任意のモナドアクションをラップ機能への）。</target>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; のモノイドは、すべてのパディングと制御シーケンスの出力を離れて抽象化します。残念ながら、そのデータ型をプリティプリンターなどの既存の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ベースのAPI に統合することは困難です。したがって、回避策として、 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; を使用すると、制御シーケンスに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; としてアクセスすることもできます。注意点の1つは、文字列としてパディングされた制御シーケンスにアクセスできないことです。例えば：</target>
        </trans-unit>
        <trans-unit id="aa804a6c1292fd02b3dfa80191cff02ea40114ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; のモノイドは、すべてのパディングと制御シーケンスの出力を離れて抽象化します。残念ながら、そのデータ型をプリティプリンターなどの既存の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ベースのAPIに統合することは困難です。したがって、回避策として、 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; では &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 列として制御シーケンスにアクセスすることもできます。1つの注意点は、埋め込み制御シーケンスに文字列としてアクセスできないことです。例えば：</target>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; の定数は、実装が記録できるCPU時間の最小測定可能な差異であり、ピコ秒の整数として与えられます。</target>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; の種類は、特定の操作は、ファイル/ディレクトリ上許容されるかどうかを記録するために使用されます。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; は、これらの権限をそれぞれ取得および設定します。権限はファイルとディレクトリの両方に適用されます。ディレクトリの場合、実行可能フィールドは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; になり、ファイルの場合、検索可能フィールドは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; になります。パスの一部として使用する許可が与えられているが、ディレクトリの内容を調べることが許可されていない場合、ディレクトリは読み取り可能でなくても検索可能である可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4d69896f050cda9242fbd0b11650fb1d4798c283" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; の種類は、特定の操作は、ファイル/ディレクトリ上許容されるかどうかを記録するために使用されます。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; は、それぞれこれらのアクセス許可を取得および設定します。権限はファイルとディレクトリの両方に適用されます。ディレクトリの場合、実行可能フィールドは &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; になり、ファイルの場合、検索可能フィールドは &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; になります。ディレクトリをパスの一部として使用することは許可されているが、ディレクトリの内容を調べることは許可されていない場合、ディレクトリは読み取り可能でなくても検索できる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; の関数は、リストかかる &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; のを、すべてのリストを返す &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 値を。</target>
        </trans-unit>
        <trans-unit id="6c024b37fca52e47d642918b547e5abf37fb3fa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; の関数は、リストかかる &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; のを、すべてのリストを返す &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 値を。</target>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; の機能は、任意の受信ハンドラ確立 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; で保護されたアクションで育っ &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; を。アン &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 例外処理機能の一つによって確立された最新のハンドラによって捕捉されます。これらのハンドラーは選択的ではありません。すべての &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; がキャッチされます。例外の伝播は、不要な例外を再発生させることにより、ハンドラーで明示的に提供する必要があります。たとえば、</target>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; の機能はデフォルト値として取る &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 価値を。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、デフォルト値を返します。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; に含まれている値を返します。</target>
        </trans-unit>
        <trans-unit id="9769cc1036b71fdb3662c8da0daae0ce7bf97a68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; の機能はデフォルト値として取る &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 価値を。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、デフォルト値を返します。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; に含まれている値を返します。</target>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; の与えられたとき、関数は空のリストを返す &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 与えられたとき、またはシングルトンリストを &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fbaf05deefa3d41622751d07a352a608fb45d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; の与えられたとき、関数は空のリストを返す &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 与えられたとき、またはシングルトンリストを &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; の操作は、それが（同様に必要とされるように遅延して読み出された単一の文字列として、すべてのユーザー入力を返す &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 機能は、タイプの機能とる &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 引数として。標準入力デバイスからの入力全体が引数としてこの関数に渡され、結果の文字列が標準出力デバイスに出力されます。</target>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 機能は、標準出力デバイスに印刷可能な任意のタイプの値を出力します。印刷可能なタイプは、 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスのインスタンスであるタイプです。 &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 操作を使用して出力用の値を文字列に変換し、改行を追加します。</target>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 関数は、ファイルを読み込み、ファイルの内容を文字列として返します。 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; と同様に、ファイルはオンデマンドで遅延読み取りされます。</target>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 関数はに似て &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; それが解析故障信号こと以外 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; はプログラムを終了するのではなく、モナド。</target>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; の機能を兼ね備え &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; の機能は、任意の受信ハンドラ確立 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; で保護されたアクションで育っ &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; を。アン &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 例外処理機能の一つによって確立された最新のハンドラによって捕捉されます。これらのハンドラーは選択的ではありません。すべての &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; がキャッチされます。例外の伝播は、不要な例外を再発生させることにより、ハンドラーで明示的に提供する必要があります。たとえば、</target>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; の機能は、すべての名前と値のペアの環境をクリアします。</target>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 関数の挿入またはリセット現在の環境リスト中の環境変数名。変数 &lt;code&gt;name&lt;/code&gt; がリストに存在しない場合は、指定された値で挿入されます。変数が存在する場合、引数の &lt;code&gt;overwrite&lt;/code&gt; がテストされます。場合は &lt;code&gt;overwrite&lt;/code&gt; ある &lt;code&gt;False&lt;/code&gt; に、変数がリセットされず、それ以外の場合は、指定された値にリセットされます。</target>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 関数は、環境からの変数名のすべてのインスタンスを削除します。</target>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 関数の挿入またはリセット現在の環境リスト中の環境変数名。変数 &lt;code&gt;name&lt;/code&gt; がリストに存在しない場合は、指定された値で挿入されます。変数が存在する場合、引数の &lt;code&gt;overwrite&lt;/code&gt; がテストされます。場合は &lt;code&gt;overwrite&lt;/code&gt; ある &lt;code&gt;False&lt;/code&gt; に、変数がリセットされず、それ以外の場合は、指定された値にリセットされます。</target>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 関数は、環境からの変数名のすべてのインスタンスを削除します。</target>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; の機能は、接続されているファイルディスクリプタのペアを作成します。最初のコンポーネントは読み取り元のfdで、2番目のコンポーネントは書き込み側です。パイプは双方向である可能性がありますが、この動作は移植可能ではなく、プログラマーはこの目的のために2つの別個のパイプを使用する必要があります。これが無効な記述子の場合、例外がスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; の機能は、接続されているファイルディスクリプタのペアを作成します。最初のコンポーネントは読み取り元のfdで、2番目のコンポーネントは書き込み側です。パイプは双方向である可能性がありますが、この動作は移植可能ではなく、プログラマーはこの目的のために2つの別個のパイプを使用する必要があります。これが無効な記述子の場合、例外がスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; のクラスはのための可変引数魔法提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; を。その実装は、このモジュールから意図的に見えません。</target>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; のクラスはのための可変引数魔法提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 。その実装は、このモジュールから意図的に見えません。このクラスのインスタンスではない型の引数を &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; に渡そうとすると、コンパイラーはそれを &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; の欠落したインスタンスとして報告します。</target>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 関数は、初期ホワイトスペースを破棄、入力から単一の語彙素を読み出し、語彙素を構成する文字を返します。入力文字列に空白のみが含まれている場合、 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; は空の文字列で構成される単一の成功した「語彙素」を返します。（したがって &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）入力文字列の先頭に有効な語彙素がない場合、 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; は失敗します（つまり、 &lt;code&gt;[]&lt;/code&gt; を返します）。</target>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 機能は、完全に入力処理によって消費されなければならない文字列からの入力を読み取ります。解析が失敗した場合、 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 失敗するため、実際のアプリケーションでの使用はお勧めしません。安全な代替手段として &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; 引数は、&lt;em&gt;推定素数&lt;/em&gt;を決定するために実行されるテストラウンドの&lt;em&gt;数&lt;/em&gt;を制御します。詳しくは、&lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;`mpz_probab_prime_p（）`のGMPドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;BigNat&lt;/code&gt; のタイプ</target>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Bits&lt;/code&gt; クラスではありません &lt;code&gt;Num&lt;/code&gt; スーパークラスを。したがって、 &lt;code&gt;bit&lt;/code&gt; 、 &lt;code&gt;testBit&lt;/code&gt; 、 &lt;code&gt;popCount&lt;/code&gt; メソッドのデフォルトメソッドはありません。</target>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; タイプと表現</target>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="translated">&lt;code&gt;CApiFFI&lt;/code&gt; の延長はの呼び出し規約ことができます &lt;code&gt;capi&lt;/code&gt; 例えば、外国の宣言に使用されます</target>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; プラグマは、パターンの特定のセットが完了したことをパターンマッチチェックを知らせるために使用され、すべての指定されたパターンに一致する任意の関数は、合計であること。</target>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="translated">&lt;code&gt;CallStack&lt;/code&gt; 単なる例のために、限り種類がそれを許すよう拡張されます</target>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Chan&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="d49e2d29e0d016b816ecb90ca81622c4424ea99a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Coercible&lt;/code&gt; machinery works with unlifted newtypes just like it does with lifted types. In either of the equivalent formulations of &lt;code&gt;A&lt;/code&gt; given above, users would additionally have access to a coercion between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Coercible&lt;/code&gt; 機械がunlifted newtypesちょうどそれが持ち上げたタイプでないようで動作します。上記の &lt;code&gt;A&lt;/code&gt; の同等の定式化のいずれかで、ユーザーはさらに &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;Int#&lt;/code&gt; の間の強制にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="translated">XHTML 1.0 Strict の &lt;code&gt;DOCTYPE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Dynamic&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="translated">&lt;code&gt;ErrorT&lt;/code&gt; モナドの構造は、二つのものの上にパラメータ化されています。</target>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="translated">&lt;code&gt;FOO.hp&lt;/code&gt; のあなたがプログラムのヒーププロファイルを求める際に生成されたファイル &lt;code&gt;FOO&lt;/code&gt; は、特に単純な構造を持つテキストファイルです。以下は、実際のデータの多くを省略した代表的な例です。</target>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="translated">&lt;code&gt;Foo @k a = a&lt;/code&gt; 以下のように式が表されることになります。</target>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Foo_stub.h&lt;/code&gt; のファイルを使用してリダイレクトすることができ &lt;code&gt;-stubdir&lt;/code&gt; オプションを。&lt;a href=&quot;separate_compilation#options-output&quot;&gt;コンパイル出力のリダイレクトを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="translated">&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; の環境変数を次のように設定することができる &lt;code&gt;:&lt;/code&gt; 区切られ（ &lt;code&gt;;&lt;/code&gt; Windows上で区切ら）パッケージデータベースを含むファイルのリスト。GHCとghc-pkgで使用されるこのパッケージデータベースのリストは、パッケージデータベースのスタックを上から下に指定します。この順序は、 &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 環境変数の動作と一致するように選択され、PATHの前のエントリが後のエントリをオーバーライドします。参照&lt;a href=&quot;#package-databases&quot;&gt;パッケージデータベースを&lt;/a&gt;パッケージデータベースのスタックを使用する方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="translated">&lt;code&gt;GenLanguageDef&lt;/code&gt; のタイプは、すべてのパラメータ化機能を含むレコードである&lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Tokenの&lt;/a&gt;モジュールを。モジュール&lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Languageに&lt;/a&gt;は、いくつかのデフォルト定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Generic1&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="translated">&lt;code&gt;Generic&lt;/code&gt; と &lt;code&gt;Generic1&lt;/code&gt; クラスは、ユーザ定義のデータ型との積和としてのそれらの内部表現との間で仲介します。</target>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="translated">&lt;code&gt;HSfoo.o&lt;/code&gt; のファイルが自動的にカバルによって構築されています。使用 &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; 、それを無効にします。手動でビルドするには、次のGNU &lt;code&gt;ld&lt;/code&gt; コマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;INCLUDE&lt;/code&gt; 他のコンパイラとの互換性のために、もはやGHCのために必要とされるが、受け入れ（無視）されるFFIを使用してC.それを介してコンパイル時に含まれるようにヘッダファイルを特定するために必要であるために使用。</target>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;INLINABLE&lt;/code&gt; プラグマもで動作します &lt;code&gt;SPECIALISE&lt;/code&gt; ：あなたは、関数マークした場合 &lt;code&gt;f&lt;/code&gt; として &lt;code&gt;INLINABLE&lt;/code&gt; を、あなたは後ででき &lt;code&gt;SPECIALISE&lt;/code&gt; （参照別のモジュールに&lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZEプラグマを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b36c40931e360e8d5c5cef07a830cd7b25a1fd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ImportQualifiedPost&lt;/code&gt; extension allows &lt;code&gt;qualified&lt;/code&gt; to appear in postpositive position : &lt;code&gt;import M qualified&lt;/code&gt;. With this extension enabled, one can write:</source>
          <target state="translated">&lt;code&gt;ImportQualifiedPost&lt;/code&gt; の延長はできます &lt;code&gt;qualified&lt;/code&gt; postpositive位置に出現し： &lt;code&gt;import M qualified&lt;/code&gt; 。この拡張機能を有効にすると、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="translated">&lt;code&gt;Int&lt;/code&gt; がうまく固定してもよい &lt;code&gt;b&lt;/code&gt; その署名を拒否してはならないので、呼び出しサイトで。さらに、依存関係が隠されている可能性があります。検討する</target>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;IsList&lt;/code&gt; のクラス及びそのメソッドをと組み合わせて使用されることが意図される &lt;code&gt;OverloadedLists&lt;/code&gt; の拡張。</target>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="translated">&lt;code&gt;Ix&lt;/code&gt; クラスと操作</target>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="translated">&lt;code&gt;Just Refl&lt;/code&gt; 中ケース &lt;code&gt;step2&lt;/code&gt; ためにため、アクセスできません &lt;code&gt;checkTEQ&lt;/code&gt; が生成することができるようにする &lt;code&gt;Just&lt;/code&gt; 、 &lt;code&gt;t ~ u&lt;/code&gt; 保持しなければならないが、我々は渡しているので、 &lt;code&gt;Foo1&lt;/code&gt; と &lt;code&gt;Foo2&lt;/code&gt; 、ここで、その次の &lt;code&gt;t ~ Char&lt;/code&gt; 、そして &lt;code&gt;u ~ Int&lt;/code&gt; 、したがって &lt;code&gt;t ~ u&lt;/code&gt; は保持できません。</target>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="translated">&lt;code&gt;LANGUAGE&lt;/code&gt; プラグマは、言語拡張は、ポータブルな方法で有効にすることができます。もちろん、すべての拡張機能がすべてのコンパイラーでサポートされているわけではありませんが、すべてのHaskellコンパイラーが同じ構文で &lt;code&gt;LANGUAGE&lt;/code&gt; プラグマをサポートすることを意図しています。 &lt;code&gt;LANGUAGE&lt;/code&gt; プラグマは、代わりに使用する必要があります &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 可能であれば、。</target>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="translated">&lt;code&gt;MArray&lt;/code&gt; クラスは、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;e&lt;/code&gt; の両方（IArrayの場合と同じように、特定の要素タイプに特化したインスタンスを定義できるように）、およびモナドのタイプ &lt;code&gt;m&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; されます。操作。</target>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; プラグマは方法の組み合わせは、特定のクラスのインスタンスのために必要とされる変更に使用することができます。&lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMALプラグマを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; プラグマは、すべてのインスタンスで実装しなければならないメソッドを指定すなわち、クラス最小の完全な定義を指定するために使用されます。インスタンスが最小の完全な定義を満たさない場合、警告が生成されます。これは、クラスに循環デフォルトのメソッドがある場合に役立ちます。例えば</target>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="translated">&lt;code&gt;Maybe Dec&lt;/code&gt; フィールドが含まれている &lt;code&gt;Just&lt;/code&gt; 、宣言のRHSを含む- -または他の変数を定義した宣言 &lt;code&gt;Nothing&lt;/code&gt; 、RHSは、コンパイラに利用できない場合が。現在、この値は&lt;em&gt;常に&lt;/em&gt; &lt;code&gt;Nothing&lt;/code&gt; です。関心がないため、RHSを返すことはまだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="translated">&lt;code&gt;Maybe String&lt;/code&gt; 引数は、オプションの時間指定を供給することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="translated">&lt;code&gt;ModSummary&lt;/code&gt; は、コンパイルされたモジュールに関する有用なメタ情報が含まれています。 &lt;code&gt;HsParsedModule&lt;/code&gt; は、我々は前に述べた字句と構文情報が含まれています。返す結果は、解析結果を変更します。結果を変更したくない場合は、引数として受け取った &lt;code&gt;HsParsedModule&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Monad&lt;/code&gt; クラスがあり &lt;code&gt;Applicative&lt;/code&gt; のスーパークラスを。GHCおよび &lt;code&gt;Applicative&lt;/code&gt; を定義しないHaskell 2010実装で機能する &lt;code&gt;Monad&lt;/code&gt; インスタンスを作成することはできません。</target>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;NOCLDSTOP&lt;/code&gt; フラグ</target>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="translated">&lt;code&gt;NOINLINE&lt;/code&gt; のプラグマはないインラインにGHCに指示します &lt;code&gt;foo&lt;/code&gt; のフェーズ0時まで。このプロパティは特殊化RULEによって継承され、フェーズ0でのみ発火します。</target>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="translated">&lt;code&gt;NOUNPACK&lt;/code&gt; のプラグマは、コンストラクタフィールドの内容を解凍してはならないことをコンパイラに示します。例：</target>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="translated">&lt;code&gt;Natural&lt;/code&gt; 番号タイプ</target>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="translated">&lt;code&gt;Num&lt;/code&gt; クラスはありません &lt;code&gt;Show&lt;/code&gt; または &lt;code&gt;Eq&lt;/code&gt; スーパークラスを。</target>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; のプラグマは、このソースファイルをコンパイルするとき、コンパイラに与えられる追加のオプションを指定するために使用されます。詳細について&lt;a href=&quot;using#source-file-options&quot;&gt;は、ソースファイルのコマンドラインオプション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="translated">&lt;code&gt;Plugin&lt;/code&gt; タイプは、フィールド有する &lt;code&gt;tcPlugin&lt;/code&gt; タイプの &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt; 、 &lt;code&gt;TcPlugin&lt;/code&gt; のタイプをこのように定義されます。</target>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="translated">&lt;code&gt;PluginRecompile&lt;/code&gt; のデータ・タイプは、プラグインが再コンパイルに影響を与えるべきかを決定する列挙です。</target>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="translated">&lt;code&gt;Pointer&lt;/code&gt; タグはそのことだと言うとき、フィールドが使用されていない &lt;code&gt;Nothing&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;Pointer&lt;/code&gt; は &lt;code&gt;Just&lt;/code&gt; の値を指します。先に述べたように、このタイプはその持ち上げられた分野では怠惰です。したがって、タイプ</target>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; クラス</target>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; クラスには、2つの追加方法、あり &lt;code&gt;readPrec&lt;/code&gt; と &lt;code&gt;readListPrec&lt;/code&gt; 彼らはに依存しているので、Haskellの2010年に発見されていない、 &lt;code&gt;ReadPrec&lt;/code&gt; 必要とするデータの種類、&lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;-XRankNTypes&lt;/code&gt; の&lt;/a&gt;拡張子を。GHCは、 &lt;code&gt;readPrec&lt;/code&gt; 代わりに &lt;code&gt;readsPrec&lt;/code&gt; 実装することによって &lt;code&gt;Read&lt;/code&gt; インスタンスを導出し、 &lt;code&gt;readPrec&lt;/code&gt; の観点から定義されている &lt;code&gt;readsPrec&lt;/code&gt; のデフォルト実装に依存しています。GHCは、 &lt;code&gt;ReadPrec&lt;/code&gt; が &lt;code&gt;ReadS&lt;/code&gt; （ &lt;code&gt;readsPrec&lt;/code&gt; の基礎となる型）よりも効率的であるという理由だけで、これら2つの追加メソッドを追加します。</target>
        </trans-unit>
        <trans-unit id="1bac9e36b9c420f9455517fb66bd240e808467c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; クラスには、2つの追加方法、あり &lt;code&gt;readPrec&lt;/code&gt; と &lt;code&gt;readListPrec&lt;/code&gt; 彼らはに依存しているので、Haskellの2010年に発見されていない、 &lt;code&gt;ReadPrec&lt;/code&gt; 必要とするデータの種類、&lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; の&lt;/a&gt;拡張子を。 GHCはまた、派生 &lt;code&gt;Read&lt;/code&gt; 実装することで、インスタンスを &lt;code&gt;readPrec&lt;/code&gt; 代わりに &lt;code&gt;readsPrec&lt;/code&gt; を、とのデフォルトの実装に依存している &lt;code&gt;readsPrec&lt;/code&gt; で定義されて &lt;code&gt;readPrec&lt;/code&gt; 。 GHCは、 &lt;code&gt;ReadPrec&lt;/code&gt; が &lt;code&gt;ReadS&lt;/code&gt; （ &lt;code&gt;readsPrec&lt;/code&gt; の基になるタイプ）よりも効率的であるという理由だけで、これら2つの追加メソッドを追加します。</target>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ReadP&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;Reader&lt;/code&gt; モナドは（も環境モナドと呼ばれます）。共有環境から値を読み取り、関数から関数に値を渡し、変更された環境でサブ計算を実行できる計算を表します。使用して &lt;code&gt;Reader&lt;/code&gt; ような計算のためのモナドは、使用するよりも、多くの場合、明確かつ容易である &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; モナドを。</target>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="translated">&lt;code&gt;R{..}&lt;/code&gt; に展開 &lt;code&gt;R{a=a}&lt;/code&gt; 省略、 &lt;code&gt;b&lt;/code&gt; レコードのフィールドがスコープ内にないため、と省略 &lt;code&gt;c&lt;/code&gt; 可変するので &lt;code&gt;c&lt;/code&gt; はレコードセレクタの結合から離れた（範囲内にない &lt;code&gt;c&lt;/code&gt; もちろん、 ）。</target>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="translated">&lt;code&gt;SPARKS&lt;/code&gt; 統計はの使用を意味する &lt;code&gt;Control.Parallel.par&lt;/code&gt; プログラムと関連する機能。各スパークは &lt;code&gt;par&lt;/code&gt; への呼び出しを表します。スパークは、並列実行されると「変換」されます。火花は、すでに評価されていることが判明し、ガベージコレクターによってプールから破棄されたときに「剪定」されます。残りのスパークは実行の終了時に破棄されるため、「変換済み」と「剪定」の合計が必ずしも合計に加算されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; モナド</target>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; モナド</target>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="translated">&lt;code&gt;Semigroup&lt;/code&gt; 演算子は、 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; であろう &lt;code&gt;Prelude&lt;/code&gt; 、オペレータのカスタムローカル定義と衝突します、</target>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; のタイプ</target>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="translated">&lt;code&gt;ShortByteString&lt;/code&gt; のタイプと表現</target>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SomeException&lt;/code&gt; のタイプは、例外タイプ階層のルートです。タイプ &lt;code&gt;e&lt;/code&gt; の例外がスローされると、舞台裏で &lt;code&gt;SomeException&lt;/code&gt; にカプセル化されます。</target>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="translated">&lt;code&gt;StablePtr&lt;/code&gt; はによって解放された &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 。これは、そうしないと &lt;code&gt;StablePtr&lt;/code&gt; を確実に解放するように調整することが難しいためです &lt;code&gt;takeMVar&lt;/code&gt; では解放できません。なぜなら、takeMVarが非同期例外によって中断された場合、コールバックは後で発生するからです。Cで解放することはできません。解放するタイミングがわからないため &lt;code&gt;hs_try_putmvar()&lt;/code&gt; がいつ戻るかはわかりません。将来のある時点で &lt;code&gt;StablePtr&lt;/code&gt; を使用する非同期呼び出しだからです）。</target>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型と関連する操作。</target>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;Traversable&lt;/code&gt; のクラス</target>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tree&lt;/code&gt; データ型は、2つのコンストラクタを持っています。個々のコンストラクタの表現は、バイナリ型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; を使用して結合されます。</target>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">「 &lt;code&gt;Type&lt;/code&gt; フィールドには、変数の基礎となるタイプが含まれています。現時点では、これは常にある &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; が、将来の変更は、この微細化を可能にすることができます。</target>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">「 &lt;code&gt;Type&lt;/code&gt; フィールドには、変数の基礎となるタイプが含まれています。現時点では、これは常にある &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; が、将来の変更は、この微細化を可能にすることができます。</target>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="translated">&lt;code&gt;UNPACK&lt;/code&gt; は、それが間接のレベルを除去し、コンストラクタ自体にコンストラクタのフィールドの内容を解凍する必要があることをコンパイラに示しています。例えば：</target>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Version&lt;/code&gt; 種類</target>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; プラグマを使用すると、特定の関数、クラス、または型に任意の警告を添付することができます。</target>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="translated">&lt;code&gt;[2]&lt;/code&gt; 規則は、フェーズ2以降のフェーズでアクティブであることを意味します。逆表記 &lt;code&gt;[~2]&lt;/code&gt; も受け入れられます。つまり、ルールはフェーズ2まではアクティブですが、フェーズ2は含みません。</target>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; パッケージは、それが純粋で、そして高いパフォーマンスの両方のシリアル化を提供することを注目すべきです。</target>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="translated">&lt;code&gt;buildExpressionParser&lt;/code&gt; は表現パーサーの構築に関わるすべての複雑さの世話をします。これは、前置符号、後置インクリメント、および基本的な演算を処理する式パーサーの例です。</target>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 機能</target>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="translated">&lt;code&gt;cr&lt;/code&gt; 現在の行の最初の列にカーソルを移動させる能力。</target>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="translated">&lt;code&gt;deriving( Sizable )&lt;/code&gt; 言うに相当します</target>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 関数は、バッファの要素を変換 &lt;code&gt;from&lt;/code&gt; バッファへ &lt;code&gt;to&lt;/code&gt; 。バッファーのサイズを考慮して、可能な限り多くの要素を変換する必要があります。0 &lt;code&gt;to&lt;/code&gt; 十分なスペースがない場合や、完全なマルチバイトシーケンスが含ま &lt;code&gt;from&lt;/code&gt; いない場合のゼロ要素の変換も含まれます。</target>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="translated">&lt;code&gt;enumFrom&lt;/code&gt; は ...方法は、算術シーケンスのHaskellの翻訳に使用されています。</target>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="translated">Prelude の &lt;code&gt;error&lt;/code&gt; 関数は、通常のエラーメッセージに加えて、エラーの原因となった呼び出しスタックの出力をサポートしています。</target>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;evaluate&lt;/code&gt; 機能</target>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fromInteger&lt;/code&gt; （従っても &lt;code&gt;fromIntegral&lt;/code&gt; はに変換する場合）特殊なケースである &lt;code&gt;Int&lt;/code&gt; 。値 &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; の下位⟨n⟩ビットとることによって与えられる &lt;code&gt;(abs x)&lt;/code&gt; の符号を乗じ、 &lt;code&gt;x&lt;/code&gt; （2の補数⟨n⟩ビット演算で）。この動作は、たとえば &lt;code&gt;0xffffffff :: Int&lt;/code&gt; 書き込むと、結果の &lt;code&gt;Int&lt;/code&gt; にビットパターンが保持されるように選択されました。</target>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="translated">また、 &lt;code&gt;fromIntegral&lt;/code&gt; 関数は、サイズ指定された整数型（ &lt;code&gt;Int8&lt;/code&gt; 、 &lt;code&gt;Int16&lt;/code&gt; 、 &lt;code&gt;Int32&lt;/code&gt; 、 &lt;code&gt;Int64&lt;/code&gt; と符号なしの &lt;code&gt;Word&lt;/code&gt; バリアント）の間で変換するときにビットパターンを保持します。ライブラリのドキュメントのモジュール &lt;code&gt;Data.Int&lt;/code&gt; および &lt;code&gt;Data.Word&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;ghc-pkg&lt;/code&gt; プログラムは、下記の方法で実行することができます。パッケージ名が必要な場合、バージョン番号を含む完全な名前（例： &lt;code&gt;network-1.0&lt;/code&gt; ）またはバージョン番号なしでパッケージに名前を付けることができます。バージョン番号なしでパッケージに名前を付けると、パッケージのすべてのバージョンに一致します。指定されたアクションは、一致するすべてのパッケージに適用されます。パッケージのすべてのバージョンに一致するパッケージ指定子を「 &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt; と記述して、複数のパッケージが一致していることを明確にすることもできます。パッケージ名とバージョンだけでなく、インストール済みのパッケージIDと照合するには、 &lt;code&gt;--ipid&lt;/code&gt; フラグを渡します。</target>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="translated">&lt;code&gt;ghc&lt;/code&gt; ので、パッケージのユーザーに露出する最もGHCのフロントエンドのを、そしてあなたがそのテコにそれをするプログラムを書くことができます。このライブラリは、実際にはGHCの内部フロントエンドコンパイルドライバーで使用されるライブラリと同じであるため、ソースコードをプログラムでコンパイルして検査するツールを作成できます。このような機能は、IDEやリファクタリングツールなどを記述するために役立ちます。簡単な例として、モジュールをコンパイルするプログラムを次に示します。これは、ghc自体がデフォルトで呼び出されたときのように動作します。</target>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="translated">&lt;code&gt;ghci.conf&lt;/code&gt; のファイルは、好きなオプション（例えばオンするための最も有用である &lt;code&gt;:set +s&lt;/code&gt; 、と便利なマクロを定義します）。</target>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;handle&lt;/code&gt; 機能</target>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="translated">&lt;code&gt;hi-boot&lt;/code&gt; コンパイルによって生成された &lt;code&gt;hs-boot&lt;/code&gt; ファイルは、他のGHC-発生インタフェースファイル（例えば、同じ機械で生成されたバイナリ形式である &lt;code&gt;B.hi&lt;/code&gt; ）。その内容は &lt;code&gt;ghc --show-iface&lt;/code&gt; で表示できます。インターフェースファイルのディレクトリ、 &lt;code&gt;-ohidir&lt;/code&gt; フラグを指定すると、 &lt;code&gt;hi-boot&lt;/code&gt; ファイルにも影響します。</target>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="translated">&lt;code&gt;hsc2hs&lt;/code&gt; のコマンドは、CコードにHaskellのバインディングを書き込む処理の一部を自動化するために使用することができます。特殊な構成要素が埋め込まれたほぼHaskellのソースを読み取り、いくつかのCヘッダーから取得した情報に基づいて、これらの構成要素が処理された実際のHaskellファイルを出力します。追加の構文は、HaskellからのCデータへのアクセスを扱います。</target>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="translated">&lt;code&gt;i2d&lt;/code&gt; 機能は、事実上、1つの機械命令です。中間の &lt;code&gt;Rational&lt;/code&gt; を介したデフォルトの変換は、比較すると非常に高価です。</target>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;cost_centres&lt;/code&gt; リストにリストされているコストセンターの &lt;code&gt;id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">モジュール &lt;code&gt;B&lt;/code&gt; の &lt;code&gt;import A hiding( g )&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; をエクスポートしないため&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;、&lt;/a&gt;技術的にはエラー（Haskell Report、5.3.1）です。ただし、GHCでは、下位互換性をサポートするために許可しています。たとえば、新しいバージョンの &lt;code&gt;A&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; をエクスポートする可能性があり、どちらの場合でも &lt;code&gt;B&lt;/code&gt; を機能させたいとします。</target>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 申告（&lt;a href=&quot;#ghci-import-decl&quot;&gt;インポートと範囲にあるものの制御&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; キーワードはオプションです。</target>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lazyIOExample&lt;/code&gt; は、あなたが失敗するより高い可能性を持ってソケットから読み取る必要がある場合は、すべてのアプリケーションに適していないディスクからファイルを、読んで、そして確かにしないように怠惰なI / Oを使用しています。これらのニーズに対処するには、incrementalExampleのような増分入力メソッドを使用し &lt;code&gt;incrementalExample&lt;/code&gt; 。Handleからインクリメンタルに読み取る方法の例については、 &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt; の実装を参照してください。</target>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;mapException&lt;/code&gt; の機能</target>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mask_&lt;/code&gt; 前に非同期の例外を避けるためにある &lt;code&gt;scheduleCallback&lt;/code&gt; のリークが発生しまし呼び出し、 &lt;code&gt;StablePtr&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="translated">&lt;code&gt;mdo&lt;/code&gt; 表記は、明示的な配置の負担削除 &lt;code&gt;rec&lt;/code&gt; コードのブロックを。ステートメントによってバインドされた変数が後のステートメントのスコープ内にのみある通常の &lt;code&gt;do&lt;/code&gt; 式とは異なり、 &lt;code&gt;mdo&lt;/code&gt; 式にバインドされた変数は、式のすべてのステートメントのスコープ内にあります。次に、コンパイラーは、相互に再帰的に依存する最小限のステートメントのセグメントを自動的に識別し、ユーザーがそれらの周りに &lt;code&gt;rec&lt;/code&gt; 修飾子をラップしたかのように扱います。</target>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; パラメータが空でないかもしれません。</target>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="translated">&lt;code&gt;nel&lt;/code&gt; 次の行の最初の列にカーソルを移動させる能力。復帰とそれに続く改行のように動作します。</target>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">&lt;code&gt;nubIntOn&lt;/code&gt; の機能は同じように動作し &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; そうでない元のデータ型に比較が、そのデータ型からユーザ指定の投影を行う点が異なります。たとえば、 &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; を使用して、文字と一般的な数値固定型を効率的にナブすることができます。</target>
        </trans-unit>
        <trans-unit id="238764eaf45a1a62c1753a2837a1022054e829ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">&lt;code&gt;nubIntOn&lt;/code&gt; の機能は同じように動作し &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; そうでない元のデータ型に比較が、そのデータ型からユーザ指定の投影を行う点が異なります。たとえば、 &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; を使用すると、文字や一般的な固定数値タイプを効率的にナブできます。</target>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="translated">&lt;code&gt;nubOrdOn&lt;/code&gt; の機能は同じように動作し &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; そうでない元のデータ型に比較が、そのデータ型からユーザ指定の投影を行う点が異なります。</target>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; の最も一般的なバリアントは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ですが、たとえば &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意の &lt;code&gt;f&lt;/code&gt; に使用できます。</target>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; の最も一般的なバリアントは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ですが、たとえば &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意の &lt;code&gt;f&lt;/code&gt; に使用できます。</target>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; の最も一般的なバリアントは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ですが、たとえば &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意の &lt;code&gt;f&lt;/code&gt; に使用できます。</target>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; の最も一般的なバリアントは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ですが、たとえば &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; はどの &lt;code&gt;f&lt;/code&gt; にも使用できます。</target>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; の最も一般的なバリアントは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ですが、たとえば &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意の &lt;code&gt;f&lt;/code&gt; に使用できます。</target>
        </trans-unit>
        <trans-unit id="50f7df8b96731582ad5998e199bcd7caa6862256" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。最も一般的なの変種 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; が、例のために &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意のために使用することができ &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ef6fce0bb77b22860c0010c07608d5a890578fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。最も一般的なの変種 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; が、例のために &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意のために使用することができ &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bd6ba4c2792acbb3c2aab713f7ac895331441da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。最も一般的なの変種 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; が、例のために &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意のために使用することができ &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="373d721989cc654150bbf0bfb255a4af1891905b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。最も一般的なの変種 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; があり &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; が、例のために &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; いずれかのために使用することができ &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b92d866131bfc652b2f085c78ccedd7098e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; 方法は&lt;em&gt;、所与のマップのキーのサブセット（空）で地図を返さなければなりません&lt;/em&gt;。値は任意に変更できます。最も一般的なの変種 &lt;code&gt;only1&lt;/code&gt; と &lt;code&gt;only2&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; が、例のために &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; は任意のために使用することができ &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="translated">明示的な双方向構築の &lt;code&gt;pat_lhs&lt;/code&gt; はRecord構文を使用できません。（rhs &lt;em&gt;expr&lt;/em&gt;は異なるデータコンストラクターを構築している可能性があるためです。）複数の方程式でガードを使用できます。</target>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="translated">&lt;code&gt;qq&lt;/code&gt; quasiquoterは、の定義を参照することができるであろう &lt;code&gt;f&lt;/code&gt; の定義先行宣言群からではなく、 &lt;code&gt;h&lt;/code&gt; または &lt;code&gt;k&lt;/code&gt; 、または後続の宣言グループから任意の定義。</target>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="translated">&lt;code&gt;recover&lt;/code&gt; 機能が無効または表現不可能配列の存在下で、復号継続するために使用されます。これには、 &lt;code&gt;encode&lt;/code&gt; &lt;code&gt;InvalidSequence&lt;/code&gt; を返すことによって検出されたものと、入力バイトシーケンスが切り捨てられているように見えるために発生したものの両方が含まれます。</target>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 機能は、単純に値を渡し継続を作成します。</target>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="translated">&lt;code&gt;runghc&lt;/code&gt; コマンドライン次のようになります。</target>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">&lt;code&gt;shows&lt;/code&gt; 機能は、出力前に付加機能を返す &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 既存の &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。これにより、関数構成を使用して結果を一定時間連結できます。</target>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">&lt;code&gt;shows&lt;/code&gt; 機能は、出力前に付加機能を返す &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 既存の &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。これにより、関数構成を使用して結果を一定時間連結できます。</target>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="translated">&lt;code&gt;sprint&lt;/code&gt; 機能は、任意の印刷された値の最後に感嘆符を追加します。次のコマンドでGHCiを実行します。</target>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="translated">&lt;code&gt;state hack&lt;/code&gt; 最適化がさえ持つ例外を隠すことが評価の順序で非明らかな変化をもたらすことができ&lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt;（例えば、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;＃7411を発行します&lt;/a&gt;）。例えば、</target>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;template-haskell&lt;/code&gt; ライブラリが提供して &lt;code&gt;Lift&lt;/code&gt; 多くの一般的なデータ型のインスタンスを。さらに、&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;言語拡張を使用して、 &lt;code&gt;Lift&lt;/code&gt; インスタンスを自動的に派生させることができます。詳しくは、&lt;a href=&quot;#deriving-lift&quot;&gt;リフトインスタンスの導出&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; コンビネータは、例えば、識別子と予約語を区別するために使用することができます。予約語と識別子はどちらも一連の文字です。識別子も期待できる特定の予約語が必要な場合は常に、 &lt;code&gt;try&lt;/code&gt; コンビネータを使用する必要があります。次のように書いたとします。</target>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 機能</target>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="translated">&lt;code&gt;type role&lt;/code&gt; （と有効&lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt;）宣言力パラメータ &lt;code&gt;a&lt;/code&gt; が役割具象的ではなく、役割ファントムであることを。次に、GHCはユーザー提供の役割をチェックして、約束を破らないことを確認します。たとえば、ユーザーが &lt;code&gt;BadIdea&lt;/code&gt; のロールを代表的なものにできるとしたら、それは悪いことです。</target>
        </trans-unit>
        <trans-unit id="3ab97fc80353826963fc8f16937897a7d19ff2bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;rsquo;s role be representational.</source>
          <target state="translated">&lt;code&gt;type role&lt;/code&gt; （と有効&lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt;）宣言力パラメータ &lt;code&gt;a&lt;/code&gt; が役割具象的ではなく、役割ファントムであることを。次にGHCは、ユーザーが指定した役割をチェックして、約束に違反していないことを確認します。たとえば、ユーザーが &lt;code&gt;BadIdea&lt;/code&gt; の役割を代表的なものにできるとしたら、それは悪いことです。</target>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{-# SOURCE #-}&lt;/code&gt; プラグマのみで使用されている &lt;code&gt;import&lt;/code&gt; モジュールループを破るために、宣言。&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;相互再帰的なモジュールをコンパイルする方法&lt;/a&gt;で詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;グローバルパッケージデータベース&lt;/em&gt;あなたのGHCのインストールが付属して、例えば、 &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="translated">&lt;em&gt;対話型のオプションは、&lt;/em&gt; GHCiのプロンプトで入力された表現とコマンドを評価するときに適用されます。</target>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="translated">&lt;em&gt;k個&lt;/em&gt;の文字列の残りの部分に続く一致番目、</target>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="translated">&lt;em&gt;ロード・オプションは、&lt;/em&gt;モジュールをロードするときに適用されます</target>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">各ユーザー専用の&lt;em&gt;ユーザーパッケージデータベース&lt;/em&gt;。Unixシステムでは、これは &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt; であり、Windowsでは &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt; ます。 &lt;code&gt;ghc-pkg&lt;/code&gt; ツールは、このファイルが置かれるべき場所を知っている、それが存在しない場合（参照、それを作成する&lt;a href=&quot;#package-management&quot;&gt;パッケージ管理（GHC-pkgコマンドを）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="translated">&lt;strong&gt;GHC-PKGの&lt;/strong&gt;ツールは、パッケージデータベースを照会し、修正するためのものです。使用中のパッケージデータベースを確認するには、 &lt;code&gt;ghc-pkg list&lt;/code&gt; を使用します。データベースのスタック&lt;strong&gt;GHC-PKGの&lt;/strong&gt;程度知っているが使用して変更することができ&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; の&lt;/a&gt;環境変数（参照&lt;a href=&quot;#ghc-package-path&quot;&gt;GHC_PACKAGE_PATH環境変数を&lt;/a&gt;、そして使用して&lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt;のオプション&lt;strong&gt;GHC-PKGの&lt;/strong&gt;コマンドラインを。</target>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="translated">&lt;strong&gt;GV&lt;/strong&gt;と&lt;strong&gt;ghostviewの&lt;/strong&gt;プログラムは、「ウォッチファイル」オプションは、それが実行されると、プログラムの最新のヒーププロファイルを表示するために使用することができますがあります。前のセクションで説明したように、増分ヒーププロファイルを生成するだけです。プロファイルで&lt;strong&gt;gv&lt;/strong&gt;を実行します。</target>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="translated">ASCIIエンコーディングは7ビットエンコーディングです。&lt;em&gt;Char7を&lt;/em&gt;ここで実施エンコーディングは、7ビットのUnicodeコードポイントを切り捨てるリーディング0でそれをプレフィックス、及びシングルバイトとして得られた8ビットを符号化することによって動作します。コードポイント0〜127の場合、これはASCIIエンコーディングに対応します。</target>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="translated">アキュムモナド</target>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="translated">アキュムTモナドトランス</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">任意のタイプの</target>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="translated">バイナリクラス</target>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="translated">ResolvedBCOs のバイナリインスタンス。</target>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="translated">ビルダーのモノイド</target>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="translated">ビルダーの種類</target>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="translated">C呼び出し &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; は、Haskell呼び出し &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt; と同等ですが、</target>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Cコードジェネレーターは、GHCが未登録モード（GHCが新しいプラットフォームへの移植を容易にするために出力として「移植可能な」Cコードを生成するモード）で構築されている場合にのみサポートされます。ただし、このモードでははるかに遅いコードが生成されるため、GHCのバージョンがこの方法でビルドされた可能性は低いです。もしそうなら、ネイティブコードジェネレーターはおそらく利用できません。この情報を確認するには、 &lt;code&gt;ghc --info&lt;/code&gt; を呼び出します（&lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="translated">使用するCコンパイラ（デフォルト： &lt;code&gt;gcc&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e1af0dbad65022684bd70994a6b169612ac3f0f8" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code if the &lt;code&gt;-cpp&lt;/code&gt; option or &lt;code&gt;-XCPP&lt;/code&gt; extension are given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">&lt;code&gt;-cpp&lt;/code&gt; オプションまたは &lt;code&gt;-XCPP&lt;/code&gt; 拡張子が指定されている場合、Cプリプロセッサ&lt;strong&gt;cpp&lt;/strong&gt;はHaskellコード上で実行されます。大量の条件付きコンパイルを使用して大規模なシステムを構築しているのでない限り、実際には必要ありません。</target>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">Cプリプロセッサー&lt;strong&gt;cpp&lt;/strong&gt;は、 &lt;code&gt;-cpp&lt;/code&gt; オプション-cppオプションが指定されている場合にのみ、Haskellコード上で実行されます。大量の条件付きコンパイルを使用して大規模なシステムを構築しているのでない限り、実際には必要ありません。</target>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="translated">Cプログラムは、Haskellコンパイラを使用してコンパイルされます。これにより、Cプログラムに自動的にインクルードされる &lt;code&gt;HsFFI.h&lt;/code&gt; へのインクルードパスが提供されます。</target>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="translated">C側のインターフェース</target>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="translated">GC 自身が使用しているCPU時間</target>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">この章では、実装が &lt;code&gt;unsafe&lt;/code&gt; 呼び出しに対して同じことを行わないようにする必要が&lt;em&gt;ない&lt;/em&gt;ため、厳密にHaskell 2010準拠のプログラムは、ヒープに割り当てられた参照を &lt;code&gt;unsafe&lt;/code&gt; FFI呼び出しに渡すことができません。</target>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="translated">Charの種類とそれに関連する操作。</target>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="translated">バイト文字列へのChar8インターフェイスは、ByteString型のIsStringのインスタンスを提供し、文字列リテラルを使用して、暗黙的にByteStringsにパックすることができます。これを有効にするには、 &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="translated">制約の種類</target>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="translated">コントモナド</target>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="translated">ContTモナドトランス</target>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="translated">Continuationモナドは、継続渡しスタイル（CPS）での計算を表します。継続渡しスタイルでは、関数の結果は返されませんが、代わりに別の関数に渡され、パラメーター（継続）として受け取られます。計算は、ネストされた継続のシーケンスから構築され、最終結果を生成する最終継続（しばしば &lt;code&gt;id&lt;/code&gt; ）で終了します。継続は計算の未来を表す関数であるため、継続関数の操作は、途中での計算の中断、計算の一部の中止、計算の再開、インターリーブなど、計算の未来の複雑な操作を実現できます。計算の実行。継続モナドはCPSをモナドの構造に適合させます。</target>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="translated">カバレッジ条件。各機能の依存関係のため、⟨tvs⟩は&lt;sub&gt;左&lt;/sub&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩ &lt;sub&gt;右&lt;/sub&gt;、クラスの、S（⟨tvs⟩内のすべての型変数&lt;sub&gt;右&lt;/sub&gt;）S（⟨tvs⟩に現れなければならない&lt;sub&gt;左&lt;/sub&gt; Sは、各タイプのマッピング置換です）、クラス宣言の変数をインスタンスヘッドの対応する型に変更します。</target>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="translated">Cygwinツールは、ウィンドウズライブラリの上にUnixスタイルのAPIを提供し、ウィンドウズへのUnixソフトウェアの移植を容易にすることを目的としています。この目的のために、彼らはいくつかのルートディレクトリの下にUnixスタイルのディレクトリ階層を導入します（通常 &lt;code&gt;/&lt;/code&gt; は &lt;code&gt;C:\cygwin\&lt;/code&gt; ）。さらに、Cygwin API（CygwinのGHCでコンパイルされたCygwinツールおよびプログラムを含む）に対して構築されたすべてのものは、 &lt;code&gt;/&lt;/code&gt; をファイルシステムのルートとして認識し、通常のUNIX環境で動作するふりをして、 &lt;code&gt;/bin&lt;/code&gt; や &lt;code&gt;/usr/include&lt;/code&gt; などを見つけます。Windowsシステム上の実際の場所（おそらく &lt;code&gt;C:\cygwin\bin&lt;/code&gt; と &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt; ）を明示的に煩わせずに/ includeします。</target>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="translated">コンストラクタアプリケーションを処理するためのDataクラス</target>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="translated">ダイナミック・インターフェースは、ダイナミック型の基本的なサポートを提供します。</target>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="translated">Either 型とそれに付随する操作。</target>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="translated">エラーモナド(例外モナドとも呼ばれる)。</target>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="translated">ErrorT モナド変換器</target>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="translated">非モナドの場合</target>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="translated">ExceptT モナド変換器</target>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="translated">例外の種類</target>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="translated">このセクションで説明されている FFI 機能は GHC に特有のものです。これらを使用した場合、あなたのコードは他のコンパイラに移植されません。</target>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFIライブラリは、付属のライブラリドキュメントに記載されています。たとえば、&lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="5ed7160bf5541192af12531389c2d242c62248cf" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFIライブラリは、付属のライブラリドキュメントに記載されています。たとえば、&lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;Foreign&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="translated">FFIライブラリには、FFIで使用するメモリを割り当てる方法がいくつかありますが、どの方法が最適であるかが常に明確であるとは限りません。この決定は、特定の種類の割り当てが特定のコンパイラ/プラットフォームでどれほど効率的であるかによって影響を受ける可能性があるため、このセクションでは、GHCでさまざまな種類の割り当てがどのように実行されるかについて説明します。</target>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="translated">FFI仕様では、さまざまな場所にIOモナドを表示する必要がありますが、IOモナドを &lt;code&gt;newtype&lt;/code&gt; でラップすると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="f1df7ad812566b24077279b5c70b3b3b84e28607" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;#13693&lt;/a&gt;.</source>
          <target state="translated">FFI仕様では、 &lt;code&gt;hs_exit()&lt;/code&gt; でシャットダウンした後、それ自体の再初期化をサポートする実装が必要ですが、GHCは現在それをサポートしていません。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;＃13693を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="translated">FFI仕様では、 &lt;code&gt;hs_exit()&lt;/code&gt; でシャットダウンされた後の再初期化をサポートする実装が必要ですが、GHCは現在それをサポートしていません。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;問題＃13693を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="translated">GC同期時間は、他のGCの統計情報と共に、呼び出すことによって入手可能である &lt;code&gt;getRTSStats()&lt;/code&gt; Cから関数、または &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; ハスケルからです。</target>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="translated">GHC APIは、これらのファイルを読み書きするための関数を公開しています。</target>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="translated">GHC RTS は現在、明示的なメモリ制限(RTS フラグで設定された)を超えたことを検出した場合にのみ、ヒープオーバーフローから回復することができます。現在、オペレーティングシステムからのメモリ割り当ての失敗は、プログラムの即時終了をもたらします。</target>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="translated">パッケージを制御するGHCのコマンドラインオプションです。</target>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="translated">GHC開発者はここでたむろします。GHC APIを使用している場合、またはGHCの実装について質問がある場合は、遠慮なくご連絡ください。</target>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="translated">GHCドライバーは、Haskellソースコード（ &lt;code&gt;.hs&lt;/code&gt; または &lt;code&gt;.lhs&lt;/code&gt; ファイル）を処理するときに、いくつかのマクロを事前定義します。</target>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="translated">GHCランタイムは、スタンドアロンの実行可能ファイルが終了するときにブロックされたスレッドを待つ必要を回避するために、プログラムの終了を特別なケースとして扱います。プログラムとそのすべてのスレッドは、コードがメモリから削除されると同時に終了しようとしているため、スレッドが最初に終了したことを確認する必要はありません。この高速でルーズなバージョンの &lt;code&gt;hs_exit()&lt;/code&gt; が必要な場合は、次を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;コマンドは、この形式でパターンタイプを表示します。</target>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="translated">GHCiモナドのリフティングインターフェース。</target>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="translated">GHCiデバッガーは、ソースコードを変更したり再コンパイルしたりせずに、これらのエラーにすばやく光を当てる方法を提供します。 1つの方法は、例外をスローするソースコードの場所にブレークポイントを設定し、&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;を使用してコンテキストを確立することです。ただし、 &lt;code&gt;head&lt;/code&gt; はライブラリにあり、ブレークポイントを直接設定することはできません。このため、GHCiにはフラグ&lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; が&lt;/a&gt;あり、例外がスローされたときにエバリュエーターを停止させ、&lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; &lt;/a&gt;、同様に機能しますが、キャッチされない例外でのみ停止します。例外で停止すると、GHCiはブレークポイントに達したときと同じように動作しますが、ソースコードの場所は表示されません。このため、これらのコマンドは、例外に至るまでの手順をログに記録するために、&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;と組み合わせた場合にのみ非常に役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="translated">モナドの取得と配置</target>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="translated">Get モナド</target>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">ハンドルは、内容が読み込まれた後、または例外が発生した場合に閉じられます。</target>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="translated">Haskell 2010レポートは、 &lt;code&gt;safe&lt;/code&gt; FFI呼び出しが、外部呼び出しが安全にHaskellコードを呼び出すことを許可する必要があることを指定しています。実際には、これは、これらの呼び出しの進行中にガベージコレクターを実行できなければならず、ヒープに割り当てられたHaskell値を任意に移動できることを意味します。</target>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="translated">Haskellの2010定義 &lt;code&gt;Show&lt;/code&gt; レンダリングされた文字列のみを明確に結果を解析するために必要な括弧を含めるべきであると規定しています。歴史的な理由により、レコードの構文は関数の適用よりも強く結合するという事実にもかかわらず、GHCによって導出された &lt;code&gt;Show&lt;/code&gt; インスタンスには、レコードの前後に括弧が含まれます。例えば、</target>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドの例外のHaskell 2010タイプ。入出力操作では、結果を返す代わりに &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; が発生する場合があります。純粋なコードで発生する例外も含め、より一般的なタイプの例外については、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="c0ce36d06fc25e64c6b77302cc8e5115d7e36509" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドの例外用のHaskell2010タイプ。I / O操作は、結果を返す代わりに &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; を発生させる可能性があります。純粋なコードで発生するものも含め、より一般的なタイプの例外については、「 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドの例外のHaskell 2010タイプ。入出力操作では、結果を返す代わりに &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; が発生する場合があります。純粋なコードで発生する例外も含め、より一般的なタイプの例外については、 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドの例外のHaskell 2010タイプ。入出力操作では、結果を返す代わりに &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; が発生する場合があります。純粋なコードで発生する例外も含め、より一般的なタイプの例外については、 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドの例外のHaskell 2010タイプ。入出力操作では、結果を返す代わりに &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; が発生する場合があります。純粋なコードで発生する例外も含め、より一般的なタイプの例外については、 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;isAlpha&lt;/code&gt; のHaskell 98定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="translated">Haskell FFIは、外国のインポートとエクスポートの引数と結果が新しいタイプの場合は自動的にアンラップされることをすでに指定しています（FFI補遺のセクション3.2）。 GHCは、IOモナド自体をラップするすべてのnewtypeを自動的にアンラップすることにより、FFIを拡張します。 FFIの仕様が必要とどこより正確には、 &lt;code&gt;IO&lt;/code&gt; の種類を、GHCは、のいずれかのnewtype-ラッピング受け入れる &lt;code&gt;IO&lt;/code&gt; のタイプを。たとえば、次の宣言は問題ありません。</target>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; の法律を定義していません。ただし、 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; は通常、等価を比較する2つの値が「パブリック」関数では区別できない等価関係を実装することが期待されており、「パブリック」関数は実装の詳細を確認できないものです。たとえば、100を法とする正規化されていない自然数を表す型の場合、「パブリック」関数は1と201の間に違いはありません。次のプロパティがあることが期待されます。</target>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; の法律を定義していません。ただし、 &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; は通常、厳密でない半順序を実装し、次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskellレポートでは、 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; に関する法律は定義されていません。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; は通常、指数フィールドを定義し、次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; の法則を定義していません。ただし、 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; および &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; は通常、リングを定義し、次のプロパティを持っていることが期待されます。</target>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">Haskellレポートでは、 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; の法律は定義されていません。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; と &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; は通常、分割リングを定義し、次のプロパティを持っていると予想されます。</target>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; の法律を定義していません。ただし、 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; インスタンスは通常、ユークリッドドメインを定義し、適切なユークリッド関数 &lt;code&gt;f&lt;/code&gt; および &lt;code&gt;g&lt;/code&gt; が与えられた場合、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; ペアに対して次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskellレポートでは、 &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; に関する法律は定義されていません。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; は通常、指数フィールドを定義し、次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; の法律を定義していません。ただし、 &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; は通常、等価を比較する2つの値が「パブリック」関数では区別できない等価関係を実装することが期待されており、「パブリック」関数は実装の詳細を確認できないものです。たとえば、100を法とする正規化されていない自然数を表す型の場合、「パブリック」関数は1と201の間に違いはありません。次のプロパティがあることが期待されます。</target>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskellレポートでは、 &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; に関する法律は定義されていません。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; は通常、指数フィールドを定義し、次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">Haskellレポートでは、 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; の法律は定義されていません。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; と &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; は通常、分割リングを定義し、次のプロパティを持っていると予想されます。</target>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; の法律を定義していません。ただし、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; インスタンスは通常、ユークリッドドメインを定義し、適切なユークリッド関数 &lt;code&gt;f&lt;/code&gt; および &lt;code&gt;g&lt;/code&gt; が与えられた場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; ペアに対して次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; の法則を定義していません。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; および &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; は通常、リングを定義し、次のプロパティを持っていることが期待されます。</target>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Haskellレポートは &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; の法律を定義していません。ただし、 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; は通常、厳密でない半順序を実装し、次のプロパティを持つことが期待されています。</target>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="translated">Haskellレポートは、中置演算子 &lt;code&gt;%&lt;/code&gt; について、次のIDが保持されることを要求しています。</target>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="translated">Haskellレポートでは、 &lt;code&gt;*&lt;/code&gt; （つづられた &lt;code&gt;Type&lt;/code&gt; で、HaskellのGHC方言で &lt;code&gt;Data.Kind&lt;/code&gt; からインポートされたもの）が &lt;code&gt;Int&lt;/code&gt; などの通常のデータ型の一種であると説明されています。さらに、型コンストラクターは矢印付きの種類を持つことができます。例えば、 &lt;code&gt;Maybe&lt;/code&gt; 種類あり &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。ボックス化されていない型には、ランタイム表現を指定する種類があります。たとえば、タイプ &lt;code&gt;Int#&lt;/code&gt; には種類 &lt;code&gt;TYPE 'IntRep&lt;/code&gt; があり、 &lt;code&gt;Double#&lt;/code&gt; は種類 &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt; ます。これらの種類は、 &lt;code&gt;Int#&lt;/code&gt; のランタイム表現はマシン整数であり、 &lt;code&gt;Double#&lt;/code&gt; のランタイム表現はマシンの倍精度浮動小数点です。対照的に、種類 &lt;code&gt;Type&lt;/code&gt; は、実際には &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 同義語です。 &lt;code&gt;TYPE&lt;/code&gt; メカニズムの詳細については、&lt;a href=&quot;#runtime-rep&quot;&gt;実行時表現の多態性に関するセクションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="translated">Haskellレポートは、 &lt;code&gt;deriving&lt;/code&gt; 条項が合法である場合について正確に曖昧です。例えば：</target>
        </trans-unit>
        <trans-unit id="ac5deab8ae658158332cbfbbabb6e8e4c0757f95" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt; for tuples up to size 15. However, &lt;code&gt;Ix&lt;/code&gt; instances are provided only for tuples up to size 5.</source>
          <target state="translated">Haskellレポートは、サイズ15までのタプルタイプとそれに付随する標準インスタンスを提供するための実装のみを必要とします。GHCはタプルタイプのサイズを62に制限し、サイズ15までのタプルに対して &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Bounded&lt;/code&gt; 、 &lt;code&gt;Read&lt;/code&gt; 、および &lt;code&gt;Show&lt;/code&gt; のインスタンスを提供します。ただし、 &lt;code&gt;Ix&lt;/code&gt; インスタンスは、サイズ5までのタプルに対してのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">Haskellレポートは、バインディングのグループ（最上位、または &lt;code&gt;let&lt;/code&gt; または &lt;code&gt;where&lt;/code&gt; 内）を強く接続されたコンポーネントにソートし、依存関係順に型チェックするように指定しています（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskellレポート、セクション4.5.1&lt;/a&gt;）。各グループは型チェックされるので、明示的な型シグネチャを持つグループのすべてのバインダーは、指定されたポリモーフィック型を使用して型環境に配置され、グループが一般化されるまで他のすべてはモノモーフィックになります（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskellレポート、セクション4.5.2&lt;/a&gt;） 。</target>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="translated">パッケージ内のHaskellコードは、1つ以上のアーカイブライブラリ（ &lt;code&gt;libHSfoo.a&lt;/code&gt; など）、または単一の共有オブジェクト（ &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt; など）に組み込まれている場合があります。単一の共有オブジェクトに対する制限は、パッケージシステムを使用して、共有オブジェクト内呼び出しではなく共有オブジェクト間呼び出しを行う必要がある場合にコンパイラーに通知するためです（共有オブジェクト呼び出しには追加の呼び出しが必要です）間接）。</target>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="translated">プログラムがコンパイルされた、または解釈されているHaskellの実装。</target>
        </trans-unit>
        <trans-unit id="3bcb6ef9eb76436588cc0d8da0bf323ce2da12ae" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest)</source>
          <target state="translated">Haskellのレポートが&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;定義されて&lt;/a&gt; &lt;code&gt;lexp&lt;/code&gt; ので、非終端を（ &lt;code&gt;*&lt;/code&gt; 興味の規則を示します）</target>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="translated">Haskellのレポートが&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;定義されて&lt;/a&gt; &lt;code&gt;lexp&lt;/code&gt; ので、非終端を（ &lt;code&gt;*&lt;/code&gt; 興味の規則を示します）：</target>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="translated">Haskell2010レポートでは、&amp;lt; &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt; &amp;gt;で次のように指定されています。</target>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="translated">IOモナド</target>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="translated">IOArray型</target>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="translated">IOModeタイプ</target>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="translated">IORef型</target>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="translated">ISO / IEC 8859-1エンコーディングは、しばしばLatin-1として知られる8ビットエンコーディングです。&lt;em&gt;Char8を&lt;/em&gt;ここで実装エンコードは、8ビットのUnicodeのコードポイントを切り捨て、シングルバイトとしてそれらを符号化することによって動作します。コードポイント0-255の場合、これはISO / IEC 8859-1エンコーディングに対応します。</target>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1エンコーディングは、しばしばLatin-1として知られる8ビットエンコーディングです。&lt;em&gt;Char8を&lt;/em&gt;ここで実装エンコードは、8ビットのUnicodeのコードポイントを切り捨て、シングルバイトとしてそれらを符号化することによって動作します。コードポイント0-255の場合、これはISO / IEC 8859-1エンコーディングに対応します。 Char8エンコーディングは、Unicodeコードポイント0-127のASCIIエンコーディングと同等であることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; などの関数を使用して、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; をChar8エンコード文字を含む10進数としてエンコードすることもできます。</target>
        </trans-unit>
        <trans-unit id="49fa9b80f4fa24e3bcc0042f7b61d0c844f15e6b" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1エンコーディングは、Latin-1としてよく知られている8ビットエンコーディングです。&lt;em&gt;Char8を&lt;/em&gt;ここで実装エンコードは、8ビットのUnicodeのコードポイントを切り捨て、シングルバイトとしてそれらを符号化することによって動作します。コードポイント0〜255の場合、これはISO / IEC8859-1エンコーディングに対応します。Char8エンコーディングは、Unicodeコードポイント0〜127のASCIIエンコーディングと同等であることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; などの関数を使用して、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; をChar8でエンコードされた文字を使用して10進数としてエンコードすることもできます。</target>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="translated">InputTモナドトランス</target>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1（ISO8859-1）エンコーディング。このエンコーディングは、バイトを最初の256個のUnicodeコードポイントに直接マップするため、完全なUnicodeエンコーディングではありません。 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; エンコーディングを使用して、 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; &lt;code&gt;'\255'&lt;/code&gt; より大きい文字を書き込もうとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1（ISO8859-1）エンコーディング。このエンコーディングは、バイトを最初の256個のUnicodeコードポイントに直接マップするため、完全なUnicodeエンコーディングではありません。 &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; エンコーディングを使用して、 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; &lt;code&gt;'\255'&lt;/code&gt; より大きい文字を書き込もうとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="translated">リストデータ型とその操作</target>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="translated">リストモナド。</target>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="translated">ListT モナド変換器</target>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="translated">ListTのモナド変換器で、整流的でなければならない与えられたモナドにバックトラックを追加します。</target>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="translated">MVar型</target>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="translated">Maybe型とそれに関連する操作。</target>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="translated">MaybeTモナド変換器</target>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="translated">修正ユリウス日は、真夜中のUTから測定した1日の分数を持つ日です。これは、様々なぐらつきを調整した地球の自転によって測定された時間であるUT1を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="translated">修正ユリウス日は、1858年11月17日を0日とする標準的な日数の数え方です。</target>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="translated">MonadException クラス</target>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="translated">MonadWriterクラスです。</target>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">単相性制限が無効になっています（&lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;恐ろしい単相性制限のスイッチオフを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="translated">しかし、NT カーネルでは、Win32 API によるこのパスの前処理をオプトアウトする方法があります。これは、パスの中で希望する名前空間を明示的に使用することで行われます。</target>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="translated">パッケージのバージョン管理ポリシー&lt;strong&gt;は適用されません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="translated">パターソン条件：コンテキスト内の各クラス制約 &lt;code&gt;(C t1 ... tn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="translated">Prelude:標準モジュールです。Preludeは、明示的なインポートステートメントがあるか、NoImplicitPrelude拡張機能が有効になっていない限り、デフォルトですべてのHaskellモジュールにインポートされます。</target>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="translated">プットモナド</target>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="translated">Putモナド。遅延バイト列を効率的に構築するためのモナド。</target>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="translated">プット型</target>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="translated">PutM型です。効率的な Builder モノイドの上にある Writer モナド。</target>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="translated">RTSには、その動作を制御する多くのオプションがあります。たとえば、コンテキストスイッチの間隔、ヒープのデフォルトサイズを変更し、ヒーププロファイリングを有効にすることができます。これらのオプションは、さまざまな方法でランタイムシステムに渡すことができます。次のセクション（&lt;a href=&quot;#setting-rts-options&quot;&gt;RTSオプションの設定&lt;/a&gt;）では、さまざまな方法について説明します。次のセクションでは、RTSオプション自体について説明します。</target>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">並行性に関連するRTSオプションについては、「&lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;同時Haskellの使用&lt;/a&gt;」および「&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;SMP並列処理のRTSオプションの&lt;/a&gt;並列処理に関するオプション」で説明しています。</target>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="translated">RTSはそれ自体のために &lt;code&gt;-H32m -S&lt;/code&gt; を手抜きし、残りの引数 &lt;code&gt;-f -h foo bar&lt;/code&gt; は、プログラムが &lt;code&gt;System.Environment.getArgs&lt;/code&gt; を呼び出した場合にプログラムで使用できます。</target>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="translated">RULESメカニズムは、一般的なリスト関数の融合（森林破壊）を実装するために使用されます。「良い消費者」が「良い生産者」によって作成された中間リストを消費する場合、中間リストは完全に削除されるべきです。</target>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="translated">RWSモナド</target>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="translated">RWSTモナドトランス</target>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="translated">リーダーのモナド</target>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="translated">ReaderTモナド変換器</target>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STMの実装は、無効であることがわかっていて再起動が必要なトランザクションを中止します。これは &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; の途中で発生する可能性があるため、解放が必要なリソースを取得しないようにしてください（トランザクションを中止する場合、例外ハンドラーは無視されます）。たとえば、ハンドルを使用したIOの実行が含まれます。これを誤ると、おそらくランダムなデッドロックが発生します。</target>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STMの実装は、無効であることがわかっていて再起動が必要なトランザクションを中止します。これは &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; の途中で発生する可能性があるため、解放が必要なリソースを取得しないようにしてください（トランザクションを中止する場合、例外ハンドラーは無視されます）。たとえば、ハンドルを使用したIOの実行が含まれます。これを誤ると、おそらくランダムなデッドロックが発生します。</target>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="translated">STMの実装では複数回トランザクションを実行することが多いので、IOに副作用がある場合は覚悟しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="translated">Safe Haskell &lt;em&gt;セーフ言語&lt;/em&gt;（ &lt;code&gt;-XSafe&lt;/code&gt; によって有効化）は、次のプロパティを保証します。</target>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt; &lt;code&gt;-fno-safe-haskell&lt;/code&gt; &lt;/a&gt;フラグを渡すことにより、モジュールのSafe Haskellチェックを無効にすることができます。これは、プラグインの実行時にモジュールを安全でないとマークし、ダウンストリームモジュールが安全性チェックに失敗する可能性があるため、ソースプラグインでコンパイルする場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="translated">セレクトモナド</target>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="translated">SelectTモナドトランス</target>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="translated">信号タイプ</target>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="translated">国家モナド</target>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="translated">StateTモナドトランス</target>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt; によって作成されたTH状態</target>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="translated">Typeable クラス</target>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="translated">UTCタイムゾーン。</target>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-16 Unicode エン コ ーデ ィ ン グ (エンデ ィ ア ン ス を示すためにバ イ ト 順序マー ク を用いる必要があ り ます)。</target>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-16 Unicode エンコーディング (ビッグエンディアン)</target>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-16 Unicode エンコーディング (litte-endian)</target>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-32 Unicode エン コ ーデ ィ ン グ (エンデ ィ ア ン ス を示すにはバ イ ト 順序マー ク を使用す る 必要があ り ます)。</target>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-32 Unicode エンコーディング (ビッグエンディアン)</target>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-32 Unicode エンコーディング(リッテエンディアン)。</target>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="translated">UTF-8 Unicode エンコーディング</target>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">バイトオーダーマーク（BOM;バイトシーケンス0xEF 0xBB 0xBF）付きのUTF-8 Unicodeエンコーディング。このエンコーディングは &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; のように動作しますが、入力ではBOMシーケンスはストリームの先頭で無視され、出力ではBOMシーケンスが先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">バイトオーダーマーク（BOM;バイトシーケンス0xEF 0xBB 0xBF）付きのUTF-8 Unicodeエンコーディング。このエンコーディングは &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; のように動作しますが、入力ではBOMシーケンスはストリームの先頭で無視され、出力ではBOMシーケンスが先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8エンコーディングは、&lt;em&gt;すべての&lt;/em&gt; Unicodeコードポイントをエンコードできます。アプリケーションが実際に別のエンコーディングを必要としない限り、常に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; のエンコーディングに使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ad5a08465846c2ed90f1e4740e5e95b9f0ebef47" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8エンコーディングは、&lt;em&gt;すべての&lt;/em&gt;Unicodeコードポイントをエンコードできます。アプリケーションが本当に別のエンコーディングを必要としない限り、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; のエンコーディングには常に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8エンコーディングは、すべてのUnicodeコードポイントをエンコードできます。これは、Unicodeコードポイント0-127のASCIIエンコーディングと同等です。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; などの関数は、UTF-8エンコードされた文字を含む10進数として &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; をエンコードするためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="51b4cc22b8af376450ca69ff9b57ead5e922d46c" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8エンコーディングは、すべてのUnicodeコードポイントをエンコードできます。これは、Unicodeコードポイント0〜127のASCIIエンコーディングと同等です。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; などの関数を使用して、UTF-8でエンコードされた文字を使用して &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; を10進数としてエンコードすることもできます。</target>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="translated">現在のロケールの Unicode エンコーディング。</target>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="translated">現在のロケールの Unicode エンコーディングですが、復号化できない任意のバイトをラウンドトリップさせることができます。</target>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="translated">現在のロケールのUnicodeエンコーディング。ただし、デコードできないバイトは、最も近い視覚的一致に置き換えられます。&lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.Stringの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; マーシャリング関数に使用されます</target>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">文字のUnicode一般カテゴリ。これは &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスに依存しています。これは、カテゴリがUnicode標準で提示されているのと同じ順序である必要があります。</target>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">文字のUnicode一般カテゴリ。これは &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスに依存しています。これは、カテゴリがUnicode標準で提示されているのと同じ順序である必要があります。</target>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="translated">Windowsディレクトリ</target>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="translated">ライターモナド</target>
        </trans-unit>
        <trans-unit id="0f31095d17e6be1b28728b97a802ce50d67ad701" translate="yes" xml:space="preserve">
          <source>The WriterT monad transformer</source>
          <target state="translated">WriterTモナド変換器</target>
        </trans-unit>
        <trans-unit id="e564641fef849b7748c52b9e3bbf79b098ce5698" translate="yes" xml:space="preserve">
          <source>The ability to &lt;em&gt;inherit&lt;/em&gt; required signatures from packages we depend upon, combining the signatures into a single merged signature which reflects the requirements of any locally defined signature, as well as the requirements of our dependencies.</source>
          <target state="translated">依存するパッケージから必要な署名を&lt;em&gt;継承する&lt;/em&gt;機能。署名を1つのマージされた署名に結合し、ローカルで定義された署名の要件と依存関係の要件を反映します。</target>
        </trans-unit>
        <trans-unit id="7dbeb7f19d92db3db611e99643a65e9afeeb3443" translate="yes" xml:space="preserve">
          <source>The ability to define an &lt;code&gt;hsig&lt;/code&gt; file, containing type definitions and type signature for values which can be used by modules that import the signature, and must be provided by the eventual implementing module, and</source>
          <target state="translated">シグニチャーをインポートするモジュールが使用でき、最終的な実装モジュールが提供する必要がある値のタイプ定義とタイプシグニチャーを含む &lt;code&gt;hsig&lt;/code&gt; ファイルを定義する機能、および</target>
        </trans-unit>
        <trans-unit id="e18a26f623d4b3d5b0afaeca9ff88864b2448314" translate="yes" xml:space="preserve">
          <source>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</source>
          <target state="translated">プログラム内の関数定義や式にブレークポイントを設定する機能。関数が呼び出されたり、式が評価されたりすると、GHCiは実行を中断してプロンプトに戻り、実行を続ける前にローカル変数の値を調べることができます。</target>
        </trans-unit>
        <trans-unit id="310f755673bc29e8cd19bd1e50c2672bd0ba64a5" translate="yes" xml:space="preserve">
          <source>The above code is equivalent to:</source>
          <target state="translated">上記のコードに相当します。</target>
        </trans-unit>
        <trans-unit id="ceb853b961139ea8a430dce957f73b5c77a03245" translate="yes" xml:space="preserve">
          <source>The above declaration (which requires the language pragma &lt;code&gt;DeriveGeneric&lt;/code&gt;) causes the following representation to be generated:</source>
          <target state="translated">上記の宣言（言語プラグマ &lt;code&gt;DeriveGeneric&lt;/code&gt; が必要）により、次の表現が生成されます。</target>
        </trans-unit>
        <trans-unit id="124bdbaef2420b9e89592fec3e57e81f0de35ec8" translate="yes" xml:space="preserve">
          <source>The above declaration causes the following representation to be generated:</source>
          <target state="translated">上記の宣言により、以下の表現が生成されます。</target>
        </trans-unit>
        <trans-unit id="f76366168215856429247956c4826993833306ed" translate="yes" xml:space="preserve">
          <source>The above definition of trust has an issue. Any module can be compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and it will be trusted. To control this, there is an additional definition of package trust (enabled with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag). The point of package trust is to require that the client C explicitly say which packages are allowed to contain trustworthy modules. Trustworthy packages are only trusted if they reside in a package trusted by C.</source>
          <target state="translated">上記の信頼の定義には問題があります。どのモジュールも&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルでき、信頼されます。これを制御するために、パッケージ信頼の追加定義があります（&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグで有効化）。パッケージの信頼のポイントは、クライアントCがどのパッケージに信頼できるモジュールを含めることが許可されるかを明示的に要求することです。信頼できるパッケージは、Cが信頼するパッケージにある場合にのみ信頼されます。</target>
        </trans-unit>
        <trans-unit id="2df7fb2c193365ff646472a721e6b7dbe5bf63ae" translate="yes" xml:space="preserve">
          <source>The above function takes a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; supposed to represent Base64 encoded data and the current decoding state. It writes the decoded bytes as the side-effect of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and returns the new decoding state, if the decoding of all data in the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; was successful. The checking if the strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; represents Base64 encoded data and the actual decoding are fused. This makes the common case, where all data represents Base64 encoded data, more efficient. It also implies that all data must be decoded before the final decoding state can be returned. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are intended for implementing such fused checking and decoding/encoding, which is reflected in their strictness properties.</source>
          <target state="translated">上記の関数は、Base64エンコードされたデータと現在のデコード状態を表すことになっている厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を取ります。デコードされたバイトを &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; の副作用として書き込み、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 内のすべてのデータのデコードが成功した場合は、新しいデコード状態を返します。厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; がBase64でエンコードされたデータを表すかどうかのチェックと実際のデコードは融合されています。これにより、すべてのデータがBase64エンコードデータを表すという一般的なケースがより効率的になります。また、最終的なデコード状態を返す前に、すべてのデータをデコードする必要があることも意味します。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; は、厳密性のプロパティに反映される、このような融合されたチェックとデコード/エンコードを実装することを目的としています。</target>
        </trans-unit>
        <trans-unit id="0308489ed1646a7d427f7b348942d76c9c0d5d69" translate="yes" xml:space="preserve">
          <source>The above informal specification is fine for simple situations, but matters can get complicated. In particular, it needs to be clear exactly when a key dies, so that any weak pointers that refer to it can be finalized. Suppose, for example, the value of one weak pointer refers to the key of another...does that keep the key alive?</source>
          <target state="translated">上記の非公式な仕様は単純な状況では問題ありませんが、問題は複雑になる可能性があります。特に、あるキーがいつ死ぬのかを正確に明確にする必要があり、それを参照している弱いポインターを最終的に確定することができます。例えば、ある弱いポインタの値が別のキーを参照していたとします。</target>
        </trans-unit>
        <trans-unit id="2361448fcf86f9607ed9aa3c2d047337ebd0125c" translate="yes" xml:space="preserve">
          <source>The above laws imply:</source>
          <target state="translated">上記の法律が暗示しています。</target>
        </trans-unit>
        <trans-unit id="6121e60b6f07d4583d6a2f3988fc1fab1e503635" translate="yes" xml:space="preserve">
          <source>The above will parse a string like &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; and return a successful parse result &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt;. Compare against the below which will produce a result of &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; for the same input:</source>
          <target state="translated">上記は &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; のような文字列を解析し、正常な解析結果 &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; を返します。同じ入力に対して &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; 結果を生成する以下と比較してください。</target>
        </trans-unit>
        <trans-unit id="20d7c122429fa587037c0b158d78237d0e61f8fb" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a0dc001d398ba43af02553419233d88958cb5682" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="2860dda2765620cbf0f468a55ba7b993da164fe3" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a16390824d4b63d5b034583c35efee2fa442421d" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="aab9864f2e792b8ac699847b4dbdbb4a77ea80ac" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="bcac48e5c098987927b81058fb32ab48d7f41565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="510da1eb070dd00ee03ec16a47305698f8cacdd9" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="c0cae1d0e9d25bf84bec3f0ea7979ae65c16dd54" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象データ型 &lt;code&gt;ParseError&lt;/code&gt; は、解析エラーを表します。エラーのソース位置（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）とエラーメッセージのリスト（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）を提供します。A &lt;code&gt;ParseError&lt;/code&gt; ですが、関数によって返されることができ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; クラスと &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="de0533afad3f79319b3bf4b1fcb91b9bbdbc0565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">抽象データ型 &lt;code&gt;SourcePos&lt;/code&gt; はソース位置を表します。ソースの名前（ファイル名）、行番号、列番号が含まれています。 &lt;code&gt;SourcePos&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="6a773f64dd31cf8cbcbf716ca186f3f80ceeb204" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">抽象データ型 &lt;code&gt;SourcePos&lt;/code&gt; は、ソースの位置を表します。これには、ソースの名前（つまり、ファイル名）、行番号、および列番号が含まれます。 &lt;code&gt;SourcePos&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; クラスのインスタンスです。</target>
        </trans-unit>
        <trans-unit id="4896de6a97029ad3c503ab35de30ebe552f9de1c" translate="yes" xml:space="preserve">
          <source>The abstract type of documents. A Doc represents a &lt;em&gt;set&lt;/em&gt; of layouts. A Doc with no occurrences of Union or NoDoc represents just one layout.</source>
          <target state="translated">文書の抽象的なタイプ。Docは&lt;em&gt;一連&lt;/em&gt;のレイアウトを表します。UnionまたはNoDocの出現がないDocは、1つのレイアウトのみを表します。</target>
        </trans-unit>
        <trans-unit id="a80b0e5c19c356bd9ef420910831b319cf81af79" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; により、ハンドル &lt;code&gt;hdl&lt;/code&gt; の出力用にバッファリングされたアイテムはすべて、オペレーティングシステムにすぐに送信されます。</target>
        </trans-unit>
        <trans-unit id="ee59ce1aebad5edf7e6e4aaef4677f21c7eefc31" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; flushes all buffered data in &lt;code&gt;hdl&lt;/code&gt;, including any buffered read data. Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read, and hence only works if &lt;code&gt;hdl&lt;/code&gt; is seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; は、バッファリングされた読み取りデータを含め、すべてのバッファリングされたデータを &lt;code&gt;hdl&lt;/code&gt; でフラッシュします。バッファリングされた読み取りデータは、バッファリングされたデータが読み取られる前のポイントにファイル位置をシークしてフラッシュされるため、 &lt;code&gt;hdl&lt;/code&gt; がシーク可能な場合にのみ機能します（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="a371db2521146387741275550e657dffca505303" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; ハンドルのためのテキストエンコーディングに変更 &lt;code&gt;hdl&lt;/code&gt; への &lt;code&gt;encoding&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; が作成されたときのデフォルトのエンコーディングは &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 、つまり現在のロケールのデフォルトのエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="2e5909c7d1c1b470eac7ec2d2a3d5f1c7a3e6b23" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; により、ハンドル &lt;code&gt;hdl&lt;/code&gt; の出力用にバッファリングされたアイテムはすべて、オペレーティングシステムにすぐに送信されます。</target>
        </trans-unit>
        <trans-unit id="30e8a3b807220ec41770ad1fcda8f8906a927d36" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; により、ハンドル &lt;code&gt;hdl&lt;/code&gt; の出力用にバッファリングされたアイテムはすべて、オペレーティングシステムにすぐに送信されます。</target>
        </trans-unit>
        <trans-unit id="9c8d6d26b1ac4ce2c7a317b47737557b2e637055" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">アクション &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; ハンドルのためのテキストエンコーディングに変更 &lt;code&gt;hdl&lt;/code&gt; への &lt;code&gt;encoding&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; が作成されたときのデフォルトのエンコーディングは &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 、つまり現在のロケールのデフォルトのエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="88ecb8776a874cfae1e583d670074ac14b0b3b9f" translate="yes" xml:space="preserve">
          <source>The action can handle the interrupt itself; a new &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; exception will be thrown every time Ctrl-C is pressed.</source>
          <target state="translated">アクションは割り込み自体を処理できます。Ctrl-Cが押されるたびに、新しい &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="7c560f66ad19d0c44deb93f325922bbfa7a14cb7" translate="yes" xml:space="preserve">
          <source>The actions to perform when a signal is received.</source>
          <target state="translated">信号を受信したときに実行する動作。</target>
        </trans-unit>
        <trans-unit id="17c5e604d289acc48a4aeb8ca32b75ead60baded" translate="yes" xml:space="preserve">
          <source>The actual command line arguments (presumably got from &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">実際のコマンドライン引数（おそらく &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; から取得）。</target>
        </trans-unit>
        <trans-unit id="51507a88f0049d4973537c6abea3ce2abf60b884" translate="yes" xml:space="preserve">
          <source>The actual meaning of the various columns in the output is:</source>
          <target state="translated">実際に出力されている様々な列の意味は</target>
        </trans-unit>
        <trans-unit id="8d600203b76ff6ccdd7956053fbe52659d549a35" translate="yes" xml:space="preserve">
          <source>The advantage of smaller stack chunks is that the garbage collector can avoid traversing stack chunks if they are known to be unmodified since the last collection, so reducing the chunk size means that the garbage collector can identify more stack as unmodified, and the GC overhead might be reduced. On the other hand, making stack chunks too small adds some overhead as there will be more overflow/underflow between chunks. The default setting of 32k appears to be a reasonable compromise in most cases.</source>
          <target state="translated">スタックチャンクを小さくする利点は、ガベージコレクタがスタックチャンクが最後のコレクション以降に変更されていないことが知られている場合、スタックチャンクをトラバースするのを避けることができることです。その一方で、スタックチャンクを小さくしすぎると、チャンク間でより多くのオーバーフロー/アンダーフローが発生するので、いくつかのオーバーヘッドが追加されます。32k のデフォルト設定は、ほとんどの場合、妥当な妥協点であるように見えます。</target>
        </trans-unit>
        <trans-unit id="351839425c4046d1ef3e16ab0a651854e611c6da" translate="yes" xml:space="preserve">
          <source>The advantage of this is that the key can be retrieved by &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; in addition to the value.</source>
          <target state="translated">これの利点は、値に加えて &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; によってキーを取得できることです。</target>
        </trans-unit>
        <trans-unit id="51801fd153e97264561ce8060f8815074cf0359c" translate="yes" xml:space="preserve">
          <source>The alarm timer</source>
          <target state="translated">アラームタイマー</target>
        </trans-unit>
        <trans-unit id="e9de65a28b0e1c87c6c42bf35a90ef7382160962" translate="yes" xml:space="preserve">
          <source>The algebraic data types</source>
          <target state="translated">代数データ型</target>
        </trans-unit>
        <trans-unit id="af0e67390188169e10bce1a919bdd538300c70aa" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates definitions for &lt;code&gt;foldMap&lt;/code&gt;, &lt;code&gt;foldr&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;のアルゴリズムはDeriveFunctorアルゴリズムを採用して&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;ますが、 &lt;code&gt;fmap&lt;/code&gt; の代わりに &lt;code&gt;foldMap&lt;/code&gt; 、 &lt;code&gt;foldr&lt;/code&gt; 、および &lt;code&gt;null&lt;/code&gt; の定義を生成します。さらに、&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;は、型が最後の型パラメーターに言及していないRHS式のすべてのコンストラクター引数を除外します。これらの引数は折りたたむ必要がないためです。</target>
        </trans-unit>
        <trans-unit id="606c23fd4a39d6f5da98fdda576dd31c1413daef" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates a definition for &lt;code&gt;traverse&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;のアルゴリズムはDeriveFunctorアルゴリズムを採用して&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;ますが、 &lt;code&gt;fmap&lt;/code&gt; ではなく &lt;code&gt;traverse&lt;/code&gt; の定義を生成します。さらに、&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;は、型が最後の型パラメーターに言及していないRHS式のすべてのコンストラクター引数をフィルターで除外します。これらの引数は、トラバーサルに影響を与えないためです。</target>
        </trans-unit>
        <trans-unit id="76b01a57a6338aab828a7c6e4ed1bf39e383096b" translate="yes" xml:space="preserve">
          <source>The allowed fields, with their types, are:</source>
          <target state="translated">許可されているフィールドとそのタイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="007ff1d2ad1a216037acaa14b7a1f3887c82c2b0" translate="yes" xml:space="preserve">
          <source>The alternative spelling &lt;code&gt;INLINEABLE&lt;/code&gt; is also accepted by GHC.</source>
          <target state="translated">代替スペル &lt;code&gt;INLINEABLE&lt;/code&gt; もGHCで受け入れられます。</target>
        </trans-unit>
        <trans-unit id="305a13d8f5f537b644a0383d8511ddbfd1c351ee" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">償却実行時間は各操作に対して与えられ、&lt;em&gt;n&lt;/em&gt;はマップ内のエントリ数を指し、&lt;em&gt;W&lt;/em&gt;は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （32または64）内のビット数を指します。</target>
        </trans-unit>
        <trans-unit id="4c5c6e2226b125e7f1dbe13dda91ec65df83b59c" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">償却された実行時間は、操作ごとに示されます&lt;em&gt;。n&lt;/em&gt;はマップ内のエントリ数を示し、&lt;em&gt;W&lt;/em&gt;は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （32または64）内のビット数を示します。</target>
        </trans-unit>
        <trans-unit id="43383f5e57411cb28bfae33d1e0cb0912284dd35" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;Int&lt;/code&gt; (32 or 64).</source>
          <target state="translated">償却実行時間は各操作に対して与えられ、&lt;em&gt;n&lt;/em&gt;はマップ内のエントリ数を指し、&lt;em&gt;W&lt;/em&gt;は &lt;code&gt;Int&lt;/code&gt; （32または64）内のビット数を指します。</target>
        </trans-unit>
        <trans-unit id="9a366c01859c8d621928b2208d0c7ed30604c01f" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map.</source>
          <target state="translated">償却実行時間は各操作ごとに示され、&lt;em&gt;n&lt;/em&gt;はマップ内のエントリの数を示します。</target>
        </trans-unit>
        <trans-unit id="a8bc34451c62ea9fef00489d326317052195ef0d" translate="yes" xml:space="preserve">
          <source>The amount of CPU time and elapsed wall clock time while initialising the runtime system (INIT), running the program itself (MUT, the mutator), and garbage collecting (GC).</source>
          <target state="translated">ランタイムシステムの初期化(INIT)、プログラム自体の実行(MUT、ミューテータ)、ガベージコレクション(GC)を行っている間のCPU時間と経過したウォールクロック時間の量。</target>
        </trans-unit>
        <trans-unit id="324b96835c11121147eb9632d3d28270b6cd3cf5" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれません」です 選択は非決定的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチできます。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="fc2d971716bd2fe11fe8e65858d3f263f32451c4" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれません」です 選択は非決定的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチできます。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="6636ed331b405e67e4aa7a8f8c1f88ee4738daae" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれません」です 選択は非決定的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチできます。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="c111ce92793f7c8faf352718e7e5cd09fac00817" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答えは「どちらかを投げるかもしれない」です。選択は非決定論的です。何らかのタイプの例外をキャッチしている場合は、どちらかをキャッチする可能性があります。あなたが呼び出している場合は &lt;code&gt;catch&lt;/code&gt; タイプして &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 、その後ハンドラがで実行されるかもしれません &lt;code&gt;DivideByZero&lt;/code&gt; 引数として、または &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 例外がさらにアップをpropogatedすることができます。もう一度呼び出すと、逆の動作をする可能性があります。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算であるため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="215e7b52176702d87e95e2ce03acf7002f6125af" translate="yes" xml:space="preserve">
          <source>The approximate time when the program finished execution as a UNIX epoch timestamp.</source>
          <target state="translated">プログラムが実行を終了したおおよその時刻をUNIXのエポックタイムスタンプとして指定します。</target>
        </trans-unit>
        <trans-unit id="bba06a7c745bfe3d2d4d032c0a5307f863b5c408" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">任意精度の &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 数型。</target>
        </trans-unit>
        <trans-unit id="77f549adbb8c3243a4f421f1caa3469b06d519cd" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">任意精度の &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 数型。</target>
        </trans-unit>
        <trans-unit id="7e4663001ff64b0062c525758c18f678a0b593f7" translate="yes" xml:space="preserve">
          <source>The argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters.</source>
          <target state="translated">引数は通常、アプリケーションの名前です。これはパスに統合されるので、有効なパス文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f7c4f0dc994aa251501707da51ab6248d1b7b620" translate="yes" xml:space="preserve">
          <source>The argument must be strictly positive, that condition is &lt;em&gt;not&lt;/em&gt; checked.</source>
          <target state="translated">引数は厳密に正でなければなら&lt;em&gt;ず&lt;/em&gt;、その条件はチェックされ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bfd85e788b1a4102dc5506f2821063aaee1859f8" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; に渡される引数は、引数として別の関数を使用する関数であり、マスクされた計算のコンテキスト内で一般的なマスク状態を復元するために使用できます。たとえば、 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用する一般的な方法は、リソースの取得を保護することです。</target>
        </trans-unit>
        <trans-unit id="ec41714558fc08d08da55c62fab2fe097c6c6a18" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; に渡される引数は、引数として別の関数を使用する関数であり、マスクされた計算のコンテキスト内で一般的なマスク状態を復元するために使用できます。たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用する一般的な方法は、リソースの取得を保護することです。</target>
        </trans-unit>
        <trans-unit id="f8b310556e765050dba6b8aa3221dbec61d539ee" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; に渡される引数は、引数として別の関数を使用する関数であり、マスクされた計算のコンテキスト内で一般的なマスク状態を復元するために使用できます。たとえば、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用する一般的な方法は、リソースの取得を保護することです。</target>
        </trans-unit>
        <trans-unit id="3c1e08fffd8f2b265d44f0c771329303cef101fc" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;runGhc&lt;/code&gt; is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by &lt;code&gt;ghc --print-libdir&lt;/code&gt; for the same version of GHC that the program is being compiled with. Above we therefore use the &lt;code&gt;ghc-paths&lt;/code&gt; package which provides this for us.</source>
          <target state="translated">&lt;code&gt;runGhc&lt;/code&gt; への引数は少しトリッキーです。GHCはライブラリを見つけるためにこれを必要とするため、引数は、プログラムがコンパイルされているGHCと同じバージョンの &lt;code&gt;ghc --print-libdir&lt;/code&gt; によって出力されるディレクトリを参照する必要があります。したがって、上記では、これを提供する &lt;code&gt;ghc-paths&lt;/code&gt; パッケージを使用します。</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">引数は</target>
        </trans-unit>
        <trans-unit id="af48f7ebb72df2bb8fd591d8c3756cf037769ab7" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; への引数はこの順序になっているため、部分的に適用することができます。例：</target>
        </trans-unit>
        <trans-unit id="9ab336f12a087d2ee8f1cb00edb943f2a0db5354" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; の引数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a6d74e6182495971a70d15c2958c5a641ef0bc47" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; への引数はこの順序になっているため、部分的に適用することができます。例：</target>
        </trans-unit>
        <trans-unit id="bcf374949da96559812c28916c86dc0dd2c3b398" translate="yes" xml:space="preserve">
          <source>The arity can be specified using explicit binders and inline kind annotations:</source>
          <target state="translated">アリティは明示的なバインダーやインラインの親切アノテーションを使って指定することができます。</target>
        </trans-unit>
        <trans-unit id="ecd5594ea721a5c5b4964510fa025a0ba7161ee7" translate="yes" xml:space="preserve">
          <source>The array is undefined (i.e. bottom) if any index in the list is out of bounds. The Haskell 2010 Report further specifies that if any two associations in the list have the same index, the value at that index is undefined (i.e. bottom). However in GHC's implementation, the value at such an index is the value part of the last association with that index in the list.</source>
          <target state="translated">リスト内のいずれかのインデックスが範囲外の場合、配列は未定義(つまりボトム)になります。Haskell 2010レポートでは、リスト内の2つの関連付けが同じインデックスを持つ場合、そのインデックスの値は未定義(すなわち、ボトム)であることがさらに規定されています。しかし、GHCの実装では、そのようなインデックスの値は、リスト内のそのインデックスを持つ最後のアソシエーションの値の一部となります。</target>
        </trans-unit>
        <trans-unit id="44d43a4b5ab2e55067cf3b1a8adecaad475ca23d" translate="yes" xml:space="preserve">
          <source>The array type</source>
          <target state="translated">配列の型</target>
        </trans-unit>
        <trans-unit id="f14b40d222c3b195d28ca364c99460ad8aae96cd" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="translated">矢印のWebページ（ &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt; &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; &amp;gt; `__）。</target>
        </trans-unit>
        <trans-unit id="5375e79ae4b0bd456d40500fcf8a53d9559263ad" translate="yes" xml:space="preserve">
          <source>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a &lt;code&gt;*&lt;/code&gt; to the module name or filename when using &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, for example</source>
          <target state="translated">エクスポートされていないモジュールのトップレベルの定義は、モジュールが解釈されたときにプロンプ​​トでの式でのみ使用できるため、オブジェクトファイルの自動読み込みは混乱を招く場合があります（&lt;a href=&quot;#ghci-scope&quot;&gt;プロンプトで実際にスコープにあるものを&lt;/a&gt;参照してください）。このため、GHCiにインタープリターを使用してモジュールを強制的にロードさせたい場合があります。これは、たとえば&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;を使用するときに、モジュール名またはファイル名の前に &lt;code&gt;*&lt;/code&gt; を付けることで実行できます。</target>
        </trans-unit>
        <trans-unit id="b8d9c5b3787a7ee0e2557b6cd2dbfe90790c68e2" translate="yes" xml:space="preserve">
          <source>The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt;) should take care of overloaded local and/or unexported functions.</source>
          <target state="translated">オーバーロードされた関数の自動特殊化（ &lt;code&gt;-O&lt;/code&gt; を使用）は、オーバーロードされたローカル関数やエクスポートされていない関数を処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="5b4889f9c5c10822085aef8616f19dbeeab3bf53" translate="yes" xml:space="preserve">
          <source>The available GHCi options are:</source>
          <target state="translated">利用可能なGHCiのオプションは</target>
        </trans-unit>
        <trans-unit id="320cabfd45dc56924b1a16a731023c186da51000" translate="yes" xml:space="preserve">
          <source>The available mode flags are:</source>
          <target state="translated">利用可能なモードフラグは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7d80beedcca979af44b30619e5e06f25ee652ee4" translate="yes" xml:space="preserve">
          <source>The average and maximum &amp;ldquo;residency&amp;rdquo;, which is the amount of live data in bytes. The runtime can only determine the amount of live data during a major GC, which is why the number of samples corresponds to the number of major GCs (and is usually relatively small). To get a better picture of the heap profile of your program, use the &lt;a href=&quot;#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; RTS option (&lt;a href=&quot;#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">平均および最大の「常駐」。これは、バイト単位のライブデータの量です。ランタイムはメジャーGC中のライブデータの量のみを決定できます。そのため、サンプルの数はメジャーGCの数に対応します（通常は比較的少ないです）。プログラムのヒーププロファイルをより正確に把握するには、&lt;a href=&quot;#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; RTSオプション（&lt;a href=&quot;#rts-profiling&quot;&gt;プロファイリングのRTSオプション&lt;/a&gt;）を使用します。</target>
        </trans-unit>
        <trans-unit id="a46eb9d9f0c06124eb5d61df6a1e2c54302d74ae" translate="yes" xml:space="preserve">
          <source>The avoided &amp;ldquo;dangerous&amp;rdquo; optimisations are those that can make runtime or space &lt;em&gt;worse&lt;/em&gt; if you&amp;rsquo;re unlucky. They are normally turned on or off individually.</source>
          <target state="translated">回避された「危険な」最適化とは、運が&lt;em&gt;悪いと&lt;/em&gt;ランタイムやスペースを&lt;em&gt;悪化さ&lt;/em&gt;せる可能性があるものです。通常は個別にオンまたはオフになります。</target>
        </trans-unit>
        <trans-unit id="eecb19b8afe1b4ff965ad37ca33e048b7e8a4fe6" translate="yes" xml:space="preserve">
          <source>The base must be greater than &lt;code&gt;1&lt;/code&gt;, the second argument, the number whose logarithm is sought, shall be positive, otherwise the result is meaningless.</source>
          <target state="translated">底は &lt;code&gt;1&lt;/code&gt; より大きい必要があります。2番目の引数、対数を求める数値は正でなければなりません。そうでない場合、結果は意味がありません。</target>
        </trans-unit>
        <trans-unit id="5bc476ce11547136a2a5b9c892017204522ab1a2" translate="yes" xml:space="preserve">
          <source>The basic algorithm for &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (&lt;code&gt;a&lt;/code&gt; in the above example), then we apply the function &lt;code&gt;f&lt;/code&gt; directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter &lt;em&gt;but does mention&lt;/em&gt; the last type parameter somewhere in it, then a recursive call to &lt;code&gt;fmap&lt;/code&gt; is made. If a type is found which doesn&amp;rsquo;t mention the last type parameter at all, then it is left alone.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;の基本アルゴリズムは、データ型の各コンストラクターの引数をウォークし、各引数の型に応じてマッピング関数を適用します。データ型の最後の型パラメーター（上記の例では &lt;code&gt;a&lt;/code&gt; ）と構文的に等しいプレーン型変数が見つかった場合、関数 &lt;code&gt;f&lt;/code&gt; を直接それに適用します。構文的に最後の型パラメーターと同等ではない&lt;em&gt;が&lt;/em&gt;最後の型パラメーターのどこかに&lt;em&gt;言及して&lt;/em&gt;いる型が検出された場合、 &lt;code&gt;fmap&lt;/code&gt; の再帰呼び出しが行われます。最後の型パラメーターについてまったく言及していない型が見つかった場合、その型はそのままになります。</target>
        </trans-unit>
        <trans-unit id="3880ac769d164951235b5160f553818be744abe1" translate="yes" xml:space="preserve">
          <source>The basic arrow class.</source>
          <target state="translated">基本の矢印クラス。</target>
        </trans-unit>
        <trans-unit id="f8e6230ac47ed9f2f8c9e5c744ea8b38e5723913" translate="yes" xml:space="preserve">
          <source>The basic idea is as follows:</source>
          <target state="translated">基本的な考え方は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ba3b2fdca46ebd4f364c251ed8663faaa8ea67c0" translate="yes" xml:space="preserve">
          <source>The basic idea is you render your structure in the form of this tree, and then use treeHtml to turn it into a Html object with the structure explicit.</source>
          <target state="translated">基本的な考え方は、このツリーの形で構造体をレンダリングし、 treeHtml を使って構造体を明示した Html オブジェクトに変換することです。</target>
        </trans-unit>
        <trans-unit id="1c047de532274bb72034a6627c348b88e9f40677" translate="yes" xml:space="preserve">
          <source>The basic principle is that all variables mentioned on the right hand side &lt;code&gt;&amp;lt;rhs&amp;gt;&lt;/code&gt; must be bound on the left hand side:</source>
          <target state="translated">基本的な原則は、右側の &lt;code&gt;&amp;lt;rhs&amp;gt;&lt;/code&gt; に記載されているすべての変数を左側にバインドする必要があるということです。</target>
        </trans-unit>
        <trans-unit id="ca1a1e0f9e4dd44a7cc3e7b636c0566990b56840" translate="yes" xml:space="preserve">
          <source>The basic syntax is that instead of specifying a package name P to the package flag &lt;code&gt;-package&lt;/code&gt;, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; makes only &lt;code&gt;Data.List&lt;/code&gt; and &lt;code&gt;Data.Bool&lt;/code&gt; visible from package &lt;code&gt;base&lt;/code&gt;. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing &lt;code&gt;OldModName as NewModName&lt;/code&gt;, e.g. &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt;. You can also write &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; to include all of the original bindings (e.g. the renaming is strictly additive). It&amp;rsquo;s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</source>
          <target state="translated">基本的な構文は、パッケージ名Pをパッケージフラグ &lt;code&gt;-package&lt;/code&gt; に指定する代わりに、パッケージ名とインポートするモジュール名の括弧で囲まれたコンマ区切りのリストの両方を指定することです。たとえば、 &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; は、パッケージ &lt;code&gt;base&lt;/code&gt; から &lt;code&gt;Data.List&lt;/code&gt; と &lt;code&gt;Data.Bool&lt;/code&gt; のみを表示します。また、両方のモジュールを同時に参照する必要がある場合に備えて、モジュールの名前の変更もサポートしています。これは、書き込むことによってサポートされて &lt;code&gt;OldModName as NewModName&lt;/code&gt; 、例えば &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt; 。また、書くことができます &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; すべての元のバインディングを含める（たとえば、名前の変更は厳密に追加されます）。シェルがパッケージ名と間引き/名前変更リストを単一の引数としてGHCに渡すように、引用符を指定することが重要です。</target>
        </trans-unit>
        <trans-unit id="e4d64a56087518fa3e2214a7adad0a68d002b762" translate="yes" xml:space="preserve">
          <source>The batch compiler can be used alongside GHCi: compiled modules can be loaded into an interactive session and used in the same way as interpreted code, and in fact when using GHCi most of the library code will be pre-compiled. This means you get the best of both worlds: fast pre-compiled library code, and fast compile turnaround for the parts of your program being actively developed.</source>
          <target state="translated">バッチコンパイラはGHCiと一緒に使用することができます:コンパイルされたモジュールを対話型セッションにロードして、解釈されたコードと同じように使用することができます。これは、コンパイル済みのライブラリコードを高速に処理し、プログラムの開発中の部分を高速にコンパイルすることができるという、両方の利点を得ることができることを意味しています。</target>
        </trans-unit>
        <trans-unit id="8ef12a287f244edad57a058eca9787cf5ada079d" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the given search directories and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この動作は、指定された検索ディレクトリを使用して各ファイルの実行権限をテストする &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; と同等です。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="a37ab05f29aa8d1d66f30bee4471417ca0bbd0f1" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;, returning only the first occurrence. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この動作は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; と同等で、最初の発生のみを返します。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="6c8e66257c1f95cca3356ee64f960b20dcb60818" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">動作は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; と同等です。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="eb1e1a3692688caa279ab0329a4e161ca0e7b861" translate="yes" xml:space="preserve">
          <source>The behaviour is simply this:</source>
          <target state="translated">振る舞いは単純にこれです。</target>
        </trans-unit>
        <trans-unit id="25a0b28ac23419d2d5d4b31eb8e82eaa74968d1a" translate="yes" xml:space="preserve">
          <source>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</source>
          <target state="translated">並列リスト内包の振る舞いは、結果として得られるリストが最短のブランチと同じ長さになるという点で、zipのそれに似ています。</target>
        </trans-unit>
        <trans-unit id="4c2566b6e8b4d963d45c5f213c50828df28117fe" translate="yes" xml:space="preserve">
          <source>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of &lt;code&gt;Collects&lt;/code&gt; with a simple dependency:</source>
          <target state="translated">依存関係情報を含めることの利点は、あいまいさの問題がなく、より正確な型の利点を持つ、より一般的な複数のパラメータークラスを定義できることです。これを説明するために、コレクションクラスの例に戻り、単純な依存関係で &lt;code&gt;Collects&lt;/code&gt; の元の定義に注釈を付けます。</target>
        </trans-unit>
        <trans-unit id="947bc2cb4d922e45d67175db691e9955f759c4f5" translate="yes" xml:space="preserve">
          <source>The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.</source>
          <target state="translated">グラフの連結された構成要素。無向グラフは、いずれかの頂点が削除されると連結されたままになる場合、連結されています。</target>
        </trans-unit>
        <trans-unit id="fbd73ac6d922a5bdced0fb605663eb345d894008" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be at the top level (i.e. no nested binders)</source>
          <target state="translated">注釈されるバインダーは最上位レベルでなければなりません(つまり、入れ子になっていないバインダーでなければなりません)。</target>
        </trans-unit>
        <trans-unit id="63969d96d060c4b503447fa167a99cc5d9a634d8" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be declared in the current module</source>
          <target state="translated">アノテーションされるバインダーは、現在のモジュールで宣言されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="7e1a540e18890acf0212904549c9082483047e09" translate="yes" xml:space="preserve">
          <source>The binding is lazy, but when either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is evaluated by &lt;code&gt;b&lt;/code&gt; the entire pattern is matched, including forcing the evaluation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">バインディングは遅延ですが、 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;y&lt;/code&gt; のいずれかが &lt;code&gt;b&lt;/code&gt; によって評価されると、 &lt;code&gt;x&lt;/code&gt; の評価の強制を含む、パターン全体が一致します。</target>
        </trans-unit>
        <trans-unit id="5313486dfdead25fb97fb53d215625b3a8e92cb9" translate="yes" xml:space="preserve">
          <source>The body &lt;code&gt;e&lt;/code&gt; of a &lt;code&gt;static e&lt;/code&gt; expression must be a closed expression. Where we say an expression is &lt;em&gt;closed&lt;/em&gt; when all of its free (type) variables are closed. And a variable is &lt;em&gt;closed&lt;/em&gt; if it is let-bound to a &lt;em&gt;closed&lt;/em&gt; expression and its type is &lt;em&gt;closed&lt;/em&gt; as well. And a type is &lt;em&gt;closed&lt;/em&gt; if it has no free variables.</source>
          <target state="translated">&lt;code&gt;static e&lt;/code&gt; 式の本体 &lt;code&gt;e&lt;/code&gt; は閉じた式でなければなりません。式は、その自由（タイプ）変数がすべて&lt;em&gt;閉じている&lt;/em&gt;ときに&lt;em&gt;閉じ&lt;/em&gt;ていると言います。そして、変数がされて&lt;em&gt;閉じられ&lt;/em&gt;、それが聞かせて結合されている場合&lt;em&gt;、閉じた&lt;/em&gt;表現とその型がされて&lt;em&gt;閉じて&lt;/em&gt;もよう。そして、自由変数がない場合、型は&lt;em&gt;閉じられ&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="592ada029a062869cce6e9bab58606be6defb777" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;f&lt;/code&gt; requires a &lt;code&gt;Num Int&lt;/code&gt; instance. We could solve this constraint from the context because we have &lt;code&gt;C Int b&lt;/code&gt; and that provides us a solution for &lt;code&gt;Num Int&lt;/code&gt;. However, we can often produce much better code by directly solving for an available &lt;code&gt;Num Int&lt;/code&gt; dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の本体には &lt;code&gt;Num Int&lt;/code&gt; インスタンスが必要です。 &lt;code&gt;C Int b&lt;/code&gt; があり、 &lt;code&gt;Num Int&lt;/code&gt; のソリューションを提供するため、この制約をコンテキストから解決できます。ただし、手元にある利用可能な &lt;code&gt;Num Int&lt;/code&gt; 辞書を直接解決することで、はるかに優れたコードを生成できることがよくあります。これにより、潜在的に多くの間接層が削除され、辞書が静的に認識され、セレクター関数をインライン化できるため、他の最適化を実行できるようになります。</target>
        </trans-unit>
        <trans-unit id="6d145adb9d3d5724f47490428e23e3c43d0c8235" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;h&lt;/code&gt;&lt;em&gt;can&lt;/em&gt; refer to the function &lt;code&gt;k&lt;/code&gt; appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</source>
          <target state="translated">準引用符は宣言グループを分割しないため、 &lt;code&gt;h&lt;/code&gt; の本体は宣言準引用符の反対側にある関数 &lt;code&gt;k&lt;/code&gt; を参照&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8c2a782fcf9cc8cd32d7c6db0f011051b79d7285" translate="yes" xml:space="preserve">
          <source>The bound on the size of sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; によって生成されたバイトシーケンスのサイズの上限。</target>
        </trans-unit>
        <trans-unit id="efcab014d352f2160b0e056ce4481103488be8c8" translate="yes" xml:space="preserve">
          <source>The bounds are specified as a pair of the lowest and highest bounds in the array respectively. For example, a one-origin vector of length 10 has bounds (1,10), and a one-origin 10 by 10 matrix has bounds ((1,1),(10,10)).</source>
          <target state="translated">境界は,配列の中の最低境界と最高境界のペアとしてそれぞれ指定されます.例えば,長さ10の1オリジンベクトルは(1,10)の境界を持ち,10×10の1オリジン行列は((1,1),(10,10))の境界を持ちます.</target>
        </trans-unit>
        <trans-unit id="ba1cb6f6655a10a0c6294b458c9d83470571695d" translate="yes" xml:space="preserve">
          <source>The bounds of an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; の境界。</target>
        </trans-unit>
        <trans-unit id="55a1eeab90b32df97217b33a312a220ee3d8254d" translate="yes" xml:space="preserve">
          <source>The bounds of the array</source>
          <target state="translated">配列の境界</target>
        </trans-unit>
        <trans-unit id="5e0f777f52cc6d21bfe3b719f3991ded42b0a70a" translate="yes" xml:space="preserve">
          <source>The bounds with which an array was constructed.</source>
          <target state="translated">配列が構築された境界線.</target>
        </trans-unit>
        <trans-unit id="606c7ca088c78a3f35afe2ec49468115c18dfed0" translate="yes" xml:space="preserve">
          <source>The buffer is represented by a record, where the record contains the raw buffer and the start/end points of the filled portion. The buffer contents itself is mutable, but the rest of the record is immutable. This is a slightly odd mix, but it turns out to be quite practical: by making all the buffer metadata immutable, we can have operations on buffer metadata outside of the IO monad.</source>
          <target state="translated">バッファはレコードで表現され、レコードには生のバッファと埋められた部分の開始点と終了点が含まれています。バッファの内容自体は変更可能ですが、レコードの残りの部分は不変です。バッファのメタデータをすべて不変にすることで、IOモナドの外でバッファのメタデータを操作することができます。</target>
        </trans-unit>
        <trans-unit id="7e80cbba3a922b5261d972496342488e7c081b28" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">参照：GHCで報告されたが、まだ修正されているバグトラッカーリストのバグ&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHCのTracを&lt;/a&gt;。これらに加えて、GHCには以下の既知のバグまたは欠陥があります。これらのバグはより永続的です。それらのいずれかが短期的に修正される可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="a911bbbc10fa83662b5cd864e984b17a1755dfc0" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues&quot;&gt;GHC issue tracker&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">バグトラッカーには、GHCで報告されているが、まだ修正されていないバグが一覧表示されます&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues&quot;&gt;。GHC問題トラッカーを&lt;/a&gt;参照してください。これらに加えて、GHCには次の既知のバグまたは欠陥もあります。これらのバグはより永続的です。それらのいずれかが短期的に修正される可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="7c15ff27610c2478bb9e4d3ab87096d2c276c0af" translate="yes" xml:space="preserve">
          <source>The byte ordering of the target machine.</source>
          <target state="translated">ターゲットマシンのバイト順。</target>
        </trans-unit>
        <trans-unit id="9d60877c7df977c480a2e8c741eba795e8186655" translate="yes" xml:space="preserve">
          <source>The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes used to identify the encoding of a file.</source>
          <target state="translated">UTF-8ではバイトオーダマークは厳密には不要ですが、ファイルのエンコーディングを識別するために使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="a1ef7711364b299ccecf0740fe399441352dee0d" translate="yes" xml:space="preserve">
          <source>The bytecode interpreter doesn&amp;rsquo;t support most uses of unboxed tuples or sums, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">バイトコードインタープリターは、ボックス化されていないタプルまたは合計のほとんどの使用をサポートしていないため、GHCiは、これらのモジュールとそれらが依存するすべてのモジュールを、バイトコードではなくオブジェクトコードに自動的にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="8e514a824a293915d542219870ba513432dcaf11" translate="yes" xml:space="preserve">
          <source>The bytes read, how many bytes were read.</source>
          <target state="translated">読まれたバイト数、何バイト読まれたか。</target>
        </trans-unit>
        <trans-unit id="b6a0060fcedfd8a68377b3d1eb2b5aba06d7d975" translate="yes" xml:space="preserve">
          <source>The call</source>
          <target state="translated">呼び出し</target>
        </trans-unit>
        <trans-unit id="39398c8eae38902a5e0ff83f99f6b2f202aad4e7" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;inline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; is inlined, regardless of its size. More precisely, the call &lt;code&gt;inline f&lt;/code&gt; rewrites to the right-hand side of &lt;code&gt;f&lt;/code&gt;'s definition. This allows the programmer to control inlining from a particular call site rather than the definition site of the function (c.f. &lt;code&gt;INLINE&lt;/code&gt; pragmas).</source>
          <target state="translated">コール・ &lt;code&gt;inline f&lt;/code&gt; 並べ &lt;code&gt;f&lt;/code&gt; は関係なく、その大きさの、インライン化されます。より正確には、 &lt;code&gt;inline f&lt;/code&gt; の呼び出しは、 &lt;code&gt;f&lt;/code&gt; の定義の右側に書き直されます。これにより、プログラマーは、関数の定義サイトではなく、特定の呼び出しサイトからのインライン化を制御できます（ &lt;code&gt;INLINE&lt;/code&gt; プラグマを参照）。</target>
        </trans-unit>
        <trans-unit id="7b04d6b098bff47077a3361dce7c4b2060070b35" translate="yes" xml:space="preserve">
          <source>The call may block for a long time if a GC is in progress. We can&amp;rsquo;t use this method if the C API we&amp;rsquo;re calling doesn&amp;rsquo;t allow blocking in the callback.</source>
          <target state="translated">GCが進行中の場合、呼び出しが長時間ブロックされることがあります。呼び出しているC APIがコールバックでのブロックを許可していない場合、このメソッドは使用できません。</target>
        </trans-unit>
        <trans-unit id="0f662e8be9b1e8327dfadad6256f93b3102227e4" translate="yes" xml:space="preserve">
          <source>The call stack</source>
          <target state="translated">呼び出しスタック</target>
        </trans-unit>
        <trans-unit id="0b95e6d04b2d9db9df511faee23c172fb043db56" translate="yes" xml:space="preserve">
          <source>The call stack here consists of a single entry, pinpointing the source of the call to &lt;code&gt;error&lt;/code&gt;. However, by annotating several computations with &lt;code&gt;HasCallStack&lt;/code&gt;, figuring out the exact circumstances and sequences of calls that lead to a call to &lt;code&gt;error&lt;/code&gt; becomes a lot easier, as demonstrated with the simple example below.</source>
          <target state="translated">ここでの呼び出しスタックは、 &lt;code&gt;error&lt;/code&gt; への呼び出しのソースを特定する単一のエントリで構成されています。ただし、以下の簡単な例で示すように、 &lt;code&gt;HasCallStack&lt;/code&gt; を使用していくつかの計算に注釈を付けることにより、 &lt;code&gt;error&lt;/code&gt; 呼び出しにつながる正確な状況と呼び出しのシーケンスを理解することが非常に簡単になります。</target>
        </trans-unit>
        <trans-unit id="e65b75e639ba49f45b306162220bcb4b4e376b49" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;hs_init()&lt;/code&gt; initializes GHC&amp;rsquo;s runtime system. Do NOT try to invoke any Haskell functions before calling &lt;code&gt;hs_init()&lt;/code&gt;: bad things will undoubtedly happen.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; の呼び出しは、GHCのランタイムシステムを初期化します。 &lt;code&gt;hs_init()&lt;/code&gt; を呼び出す前にHaskell関数を呼び出そうとしないでください。間違いなく悪いことが起こります。</target>
        </trans-unit>
        <trans-unit id="b0d2f80290077bea927d89a134d957a184f32cc5" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">通話 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 実行時エラーが発生しなければなりません。</target>
        </trans-unit>
        <trans-unit id="319dd86afb1a88f29e7d25a55be6766bfa4bbc86" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">通話 &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 実行時エラーが発生しなければなりません。</target>
        </trans-unit>
        <trans-unit id="82bb223904345033a341142d4c4dc792513b34b0" translate="yes" xml:space="preserve">
          <source>The case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; is rather interesting. Here, we call the final function &lt;code&gt;encode&lt;/code&gt; that we yet have to define, recursively. We will use another type class &lt;code&gt;Encode&lt;/code&gt; for that function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; のケースはかなり興味深いです。ここでは、再帰的に定義する必要がある最終的な関数 &lt;code&gt;encode&lt;/code&gt; を呼び出します。その関数には別の型クラス &lt;code&gt;Encode&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="dbeba971901c44630a87f3ab4af1926015f93dc7" translate="yes" xml:space="preserve">
          <source>The channels are implemented with &lt;code&gt;MVar&lt;/code&gt;s and therefore inherit all the caveats that apply to &lt;code&gt;MVar&lt;/code&gt;s (possibility of races, deadlocks etc). The stm (software transactional memory) library has a more robust implementation of channels called &lt;code&gt;TChan&lt;/code&gt;s.</source>
          <target state="translated">チャネルは、で実装され &lt;code&gt;MVar&lt;/code&gt; Sしたがってに適用されるすべての警告継承 &lt;code&gt;MVar&lt;/code&gt; S（レースの可能性、デッドロックなど）。stm（ソフトウェアトランザクションメモリ）ライブラリには、 &lt;code&gt;TChan&lt;/code&gt; と呼ばれるチャネルのより堅牢な実装があります。</target>
        </trans-unit>
        <trans-unit id="4069bea430852a057890df955f47a154334cab42" translate="yes" xml:space="preserve">
          <source>The character that is used to separate the entries in the $PATH environment variable.</source>
          <target state="translated">環境変数 $PATH のエントリを区切るために使用される文字。</target>
        </trans-unit>
        <trans-unit id="ba11d47bc9956242fbb3ca66e5d4200f63de5f8d" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">ディレクトリを区切る文字。複数の文字が可能な場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; は「理想的な」文字です。</target>
        </trans-unit>
        <trans-unit id="0adbd55b5e31c8dee6ffdd25e981917f83978616" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">ディレクトリを区切る文字。複数の文字が可能な場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; は「理想的な」文字です。</target>
        </trans-unit>
        <trans-unit id="3300c6070d1ff47cc64a9cd4f2a57598bed4fe49" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; は、値がUnicode（または同等のISO / IEC 10646）コードポイントを表す列挙体です（つまり、文字。詳細については、&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http：//www.unicode.org/&lt;/a&gt;を参照してください）。このセットは、ISO 8859-1（Latin-1）文字セット（最初の256文字）を拡張します。これは、それ自体がASCII文字セット（最初の128文字）の拡張です。Haskellの文字リテラルの型は &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a83bfe2a3131f5d1fa9053b377b2dd8ef00abbee" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; は、値がUnicode（または同等のISO / IEC 10646）コードポイントを表す列挙体です（つまり、文字。詳細については、&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http：//www.unicode.org/&lt;/a&gt;を参照してください）。このセットは、ISO 8859-1（Latin-1）文字セット（最初の256文字）を拡張します。これは、それ自体がASCII文字セット（最初の128文字）の拡張です。Haskellの文字リテラルの型は &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e57b1fe87f343495401c4e61909f138148056d67" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; は、値がUnicode（または同等のISO / IEC 10646）コードポイントを表す列挙体です（つまり、文字。詳細については、&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http：//www.unicode.org/&lt;/a&gt;を参照してください）。このセットは、ISO 8859-1（Latin-1）文字セット（最初の256文字）を拡張します。これは、それ自体がASCII文字セット（最初の128文字）の拡張です。Haskellの文字リテラルの型は &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="47f8f2f2dc9e65ebc1b9adf566bdf62f3dc06201" translate="yes" xml:space="preserve">
          <source>The chunk size used for I/O. Currently set to 32k, less the memory management overhead</source>
          <target state="translated">I/Oに使用するチャンクサイズ。現在は32kに設定されています。</target>
        </trans-unit>
        <trans-unit id="c4ebe1e22516dcf7d377102ba02d7a72071fb54c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; クラスを使用すると、タイプの具体的な表現を計算できます。</target>
        </trans-unit>
        <trans-unit id="26ec99c0bc5533ce5fa506bf5dd334d666afbabf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; クラスを使用すると、タイプの具体的な表現を計算できます。</target>
        </trans-unit>
        <trans-unit id="95e5985c3bffdb6706bd6da87ba82bb2b1f9502b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; クラスを使用すると、タイプの具体的な表現を計算できます。</target>
        </trans-unit>
        <trans-unit id="a0793307c198436ef6cbb2b38d12d842f11f5daa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsLabel&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsLabel&lt;/code&gt; クラスは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="da702fa4f893f1ff84ab94ead774536cedcefc5d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; クラスは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="314c44e92114b49583eff2b98f5eb8171a7374ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module &lt;code&gt;Data.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; クラスは、デフォルトではスコープ内にありません。明示的に言及したい場合（たとえば、インスタンスの宣言を与える場合）、モジュール &lt;code&gt;Data.String&lt;/code&gt; からインポートできます。</target>
        </trans-unit>
        <trans-unit id="66741f48f8c9a811c479be37c49092c2f5831600" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt; and &lt;code&gt;TExpQ a&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">クラス &lt;code&gt;Lift&lt;/code&gt; は、他の &lt;code&gt;template-haskell&lt;/code&gt; 可能なクラスとは異なり、 &lt;code&gt;base&lt;/code&gt; ではなくtemplate-haskellに存在します。データ型を &lt;code&gt;Lift&lt;/code&gt; のインスタンスにすると、その値をテンプレートHaskell式（タイプ &lt;code&gt;ExpQ&lt;/code&gt; および &lt;code&gt;TExpQ a&lt;/code&gt; ）にプロモートでき、Haskellソースコードにスプライスできます。</target>
        </trans-unit>
        <trans-unit id="46c25aa9d510e6dfd769a86618af627836e67d95" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">クラス &lt;code&gt;Lift&lt;/code&gt; は、他の &lt;code&gt;template-haskell&lt;/code&gt; クラスとは異なり、 &lt;code&gt;base&lt;/code&gt; ではなくtemplate-haskellにあります。データ型を &lt;code&gt;Lift&lt;/code&gt; のインスタンスにすることで、その値を（型 &lt;code&gt;ExpQ&lt;/code&gt; の）テンプレートHaskell式に昇格させ、Haskellソースコードにスプライスすることができます。</target>
        </trans-unit>
        <trans-unit id="cfedc7f27395d9e14f3b5dcae9116c684144dba3" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Typeable&lt;/code&gt; is very special:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; クラスは非常に特別です。</target>
        </trans-unit>
        <trans-unit id="a352e3bea5c92259e258192deb3bd391cda34543" translate="yes" xml:space="preserve">
          <source>The class instances for sequences are all based very closely on those for lists.</source>
          <target state="translated">シーケンスのクラスインスタンスは、すべてリストのクラスインスタンスと非常に密接に関係しています。</target>
        </trans-unit>
        <trans-unit id="f29fdb13c7afe65c971d977ce119c943fb00e75f" translate="yes" xml:space="preserve">
          <source>The class of contravariant functors.</source>
          <target state="translated">反変ファンクタのクラス。</target>
        </trans-unit>
        <trans-unit id="15b84a81fb0f85cb419535a3a61b9ad1d3da02f7" translate="yes" xml:space="preserve">
          <source>The class of monad transformers.</source>
          <target state="translated">モナド変圧器のクラス。</target>
        </trans-unit>
        <trans-unit id="1aba4d36676a8723cc042f0ef18005b4207f229e" translate="yes" xml:space="preserve">
          <source>The class of monad transformers. Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a monad transformation:</source>
          <target state="translated">モナド変換子のクラス。インスタンスは、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; はモナド変換であるとする次の法律を満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="968994db3d9c45181b57f61fe4736e2627f5c6a6" translate="yes" xml:space="preserve">
          <source>The class of monoids (types with an associative binary operation that has an identity). Instances should satisfy the following:</source>
          <target state="translated">モノイドのクラス(連想二項演算を持つ型で、同一性を持つもの)。インスタンスは以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="80aae29c2b395ab518f6cbf2867e04f61aabbf53" translate="yes" xml:space="preserve">
          <source>The class of semigroups (types with an associative binary operation).</source>
          <target state="translated">半グループ(連想二項演算を持つ型)のクラス。</target>
        </trans-unit>
        <trans-unit id="ef50832e806510cb4bbe9f9aafa22744526d2ab1" translate="yes" xml:space="preserve">
          <source>The class of the instance declaration is not declared in &lt;code&gt;M&lt;/code&gt;, and</source>
          <target state="translated">インスタンス宣言のクラスが &lt;code&gt;M&lt;/code&gt; で宣言されていません。</target>
        </trans-unit>
        <trans-unit id="cc31daa90372a8a474d012704a661ac277d958aa" translate="yes" xml:space="preserve">
          <source>The class of types which can be parsed given a UNIX-style time format string.</source>
          <target state="translated">UNIXスタイルの時刻書式文字列を与えられたときに解析できる型のクラスです。</target>
        </trans-unit>
        <trans-unit id="380a9b6da5c050f1cf3fa8febdb6d2797a540fc9" translate="yes" xml:space="preserve">
          <source>The closure of the superclass relation over these local axioms : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</source>
          <target state="translated">これらのローカル公理上のスーパークラス関係の閉鎖： &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; および &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0848f15a7a4cc86662e9097e3f0cf4b1532d9192" translate="yes" xml:space="preserve">
          <source>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too.</source>
          <target state="translated">インスタンス宣言のメソッドのコードは、期待されるように、インスタンス宣言で与えられた型シグネチャに対して型チェックが行われます。そのため、インスタンスシグネチャが必要以上にポリモーフィックであれば、コードもポリモーフィックでなければなりません。</target>
        </trans-unit>
        <trans-unit id="e5001edd8f78114b36e24d8f0a44754ee90b2f4d" translate="yes" xml:space="preserve">
          <source>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</source>
          <target state="translated">コードジェネレーターは、各アンボックス化された和に対して可能な限りコンパクトなレイアウトを生成しようとします。最良のケースでは、アンボックス化された合計のサイズは、最大の代替品のサイズに1ワード(タグの場合)を加えたものになります。和のタイプのメモリ・レイアウトを生成するアルゴリズムは次のように動作します。</target>
        </trans-unit>
        <trans-unit id="3837898dd791b811ea7932889c5130e161088d94" translate="yes" xml:space="preserve">
          <source>The code of the &quot;dominant&quot; language of the webpage.</source>
          <target state="translated">ウェブページの「支配的な」言語のコード。</target>
        </trans-unit>
        <trans-unit id="a45302a43608cfe9a77b37998c0a415b8fef0ffc" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">コードは、ほとんどの場合自明です。構文が少しぎこちないのは、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のサイズ制限がコンパイル時に計算できるようにコンビネータが記述されているためです。また、固定された文字のタプルをエンコードする &lt;code&gt;fixed2&lt;/code&gt; プリミティブを明示的にインライン化し、バインドされた計算がコンパイル時に行われるようにします。次の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; のリストをエンコードする場合、 &lt;code&gt;renderString&lt;/code&gt; の最適化された実装は2倍速くなります。</target>
        </trans-unit>
        <trans-unit id="93c66ed4ee1310bccd13dda5d5b0820443482dc4" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">コードはほとんど自明である必要があります。少し厄介な構文は、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のサイズ制限がコンパイル時に計算できるようにコンビネータが記述されているためです。また、固定タプルの文字をエンコードする &lt;code&gt;fixed2&lt;/code&gt; プリミティブを明示的にインライン化して、バインドされた計算がコンパイル時に行われるようにします。次の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; のリストをエンコードする場合、 &lt;code&gt;renderString&lt;/code&gt; の最適化された実装は2倍高速です。</target>
        </trans-unit>
        <trans-unit id="4421b2e89d7c073b3eeabb7b626aa07e05c2b134" translate="yes" xml:space="preserve">
          <source>The combinators &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt;, etc are all provided with default definitions in terms of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt;, leaving open the opportunity to provide datatype-specific definitions. (The inclusion of the &lt;code&gt;gmap&lt;/code&gt; combinators as members of class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; allows the programmer or the compiler to derive specialised, and maybe more efficient code per datatype. &lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is more higher-order than the &lt;code&gt;gmap&lt;/code&gt; combinators. This is subject to ongoing benchmarking experiments. It might turn out that the &lt;code&gt;gmap&lt;/code&gt; combinators will be moved out of the class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">コンビネータ &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt; などは、全ての面でデフォルトの定義が設けられている &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; データ型固有の定義を提供する機会を開いたままに、。 （クラス &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; のメンバーとして &lt;code&gt;gmap&lt;/code&gt; コンビネーターを含めることで、プログラマーまたはコンパイラーは、データ型ごとに特殊化された、おそらくより効率的なコードを導出できます。&lt;em&gt;注&lt;/em&gt;： &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;gmap&lt;/code&gt; コンビネーターよりも高次です。これは、継続的なベンチマーク実験の対象です。これは、ことをなるかもしれない &lt;code&gt;gmap&lt;/code&gt; コンビネータは、クラスの外に移動されます &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 。）&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d6f1f7c8a32c8db29cc4151cc5a6c27c5f31776" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the size of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のコンビネータは、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; のサイズをコンパイル時に計算できるように実装されています。</target>
        </trans-unit>
        <trans-unit id="b36fb23ba2c0fd5cf9cc5fbcaa48f3fa3936ed5b" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;size&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="translated">用コンビネータ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; Sは、そのような実装されている &lt;code&gt;size&lt;/code&gt; 得られたの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; は、コンパイル時に計算されます。</target>
        </trans-unit>
        <trans-unit id="2acc0788b34136669ccf2620396da51b7563e2c2" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt; will show a summary of which modules contribute to the top-level scope.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;コマンドは、どのモジュールがトップレベルのスコープに貢献しているかの概要を表示します。</target>
        </trans-unit>
        <trans-unit id="5fdeb122c09642094fcfc48bef6bdcdff89e8605" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step expr&lt;/code&gt;&lt;/a&gt; begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt;&lt;code&gt;:steplocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt;&lt;code&gt;:stepmodule&lt;/code&gt;&lt;/a&gt; commands work similarly.</source>
          <target state="translated">コマンド&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step expr&lt;/code&gt; &lt;/a&gt;は、シングルステップモードで「expr」の評価を開始します。「expr」を省略すると、現在のブレークポイントからシングルステップ実行されます。&lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt; &lt;code&gt;:steplocal&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt; &lt;code&gt;:stepmodule&lt;/code&gt; &lt;/a&gt;コマンドは同様に機能します。</target>
        </trans-unit>
        <trans-unit id="a632ebd88f50b8ac78cacda34b5408a0be9ab51c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:break 2&lt;/code&gt; sets a breakpoint on line 2 of the most recently-loaded module, in this case &lt;code&gt;qsort.hs&lt;/code&gt;. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt;.</source>
          <target state="translated">コマンド &lt;code&gt;:break 2&lt;/code&gt; は、最後にロードされたモジュール、この場合は &lt;code&gt;qsort.hs&lt;/code&gt; の 2行目にブレークポイントを設定します。具体的には、ブレークポイントを設定する行の左端の完全な部分式 &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt; この場合は式（qsort left ++ [a] ++ qsort right））を選択します。</target>
        </trans-unit>
        <trans-unit id="e40dd230e05a9e07fe62ec45624d094d383aa421" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:info!&lt;/code&gt; works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</source>
          <target state="translated">コマンド &lt;code&gt;:info!&lt;/code&gt; 同様の方法で機能しますが、制限（b）を削除し、スコープ内にあるすべてのインスタンスを表示し、「名前」を頭に挙げます。</target>
        </trans-unit>
        <trans-unit id="db3abb134ad672048db99caf88a85888bde3b864" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; finds the end of every complete sample in &lt;code&gt;FOO.hp&lt;/code&gt;, and labels each sample with its ending line number. We then select the line number of the last complete sample using &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut&lt;/strong&gt;. This is used as a parameter to &lt;strong&gt;head&lt;/strong&gt;; the result is as if we deleted the final incomplete sample from &lt;code&gt;FOO.hp&lt;/code&gt;. This results in a properly-formatted .hp file which we feed directly to &lt;strong&gt;hp2ps&lt;/strong&gt;.</source>
          <target state="translated">コマンド &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; 内のすべての完全なサンプルの終わり見つけ &lt;code&gt;FOO.hp&lt;/code&gt; を、そしてその終了行番号で各サンプルにラベルを付けます。次に、&lt;strong&gt;tail&lt;/strong&gt;と&lt;strong&gt;cut&lt;/strong&gt;を使用して、最後の完全なサンプルの行番号を選択します。これは、&lt;strong&gt;headの&lt;/strong&gt;パラメータとして使用されます。結果は、 &lt;code&gt;FOO.hp&lt;/code&gt; から最後の不完全なサンプルを削除した場合と同じです。これにより、適切にフォーマットされた.hpファイルが&lt;strong&gt;生成&lt;/strong&gt;され、&lt;strong&gt;hp2psに&lt;/strong&gt;直接フィードされ&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="270408c21f336615635c1e2a2c6f2941c9ac84d6" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the program</source>
          <target state="translated">プログラムに渡されるコマンドライン引数</target>
        </trans-unit>
        <trans-unit id="e7e794e0f93c2fa925b60afdb7fbdedb64d80c09" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the runtime system</source>
          <target state="translated">ランタイムシステムに渡されるコマンドライン引数</target>
        </trans-unit>
        <trans-unit id="77b364d49a3dfa5e15b2ed62d447248ab845ef6f" translate="yes" xml:space="preserve">
          <source>The command to run, which must be in the $PATH, or an absolute or relative path</source>
          <target state="translated">実行するコマンドは $PATH にあるか、絶対パスか相対パスでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a9eb0075b8efba5d950b353dc2ba8dd18856c0b6" translate="yes" xml:space="preserve">
          <source>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate &lt;code&gt;do&lt;/code&gt;-notation by defining</source>
          <target state="translated">ラムダ抽象化およびアプリケーションのコマンドバージョンは、式バージョンに類似しています。特に、ベータとイータのルールはコマンドの同等性を記述します。これらの3つの機能（演算子、ラムダ抽象化、およびアプリケーション）は、表記法の中核です。他のものはすべてそれらを使用して構築できますが、結果はやや不格好になります。たとえば、次のように定義することにより、 &lt;code&gt;do&lt;/code&gt; 表記をシミュレートできます。</target>
        </trans-unit>
        <trans-unit id="69ed99fc3cead2f4b29389ab07a3549b66be32cf" translate="yes" xml:space="preserve">
          <source>The command-line arguments passed to the program</source>
          <target state="translated">プログラムに渡されるコマンドライン引数</target>
        </trans-unit>
        <trans-unit id="8a1e2c9e679e0ed25e609bb32dccdb1dffa31a77" translate="yes" xml:space="preserve">
          <source>The comparable symbols for other systems are: &lt;code&gt;__HUGS__&lt;/code&gt; for Hugs, &lt;code&gt;__NHC__&lt;/code&gt; for nhc98, and &lt;code&gt;__HBC__&lt;/code&gt; for hbc).</source>
          <target state="translated">他のシステムのための同等の記号は以下のとおりです。 &lt;code&gt;__HUGS__&lt;/code&gt; 抱擁、用 &lt;code&gt;__NHC__&lt;/code&gt; nhc98ため、および &lt;code&gt;__HBC__&lt;/code&gt; HBCのため）。</target>
        </trans-unit>
        <trans-unit id="b172d1caf74bb5840fcb833db8910b15eee4ccf4" translate="yes" xml:space="preserve">
          <source>The compiler does not overwrite an existing &lt;code&gt;.hi&lt;/code&gt; interface file if the new one is the same as the old one; this is friendly to &lt;strong&gt;make&lt;/strong&gt;. When an interface does change, it is often enlightening to be informed. The &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt;&lt;code&gt;-ddump-hi-diffs&lt;/code&gt;&lt;/a&gt; option will make GHC report the differences between the old and new &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">新しいファイルが古いファイルと同じ場合、コンパイラーは既存の &lt;code&gt;.hi&lt;/code&gt; インターフェースファイルを上書きしません。これは&lt;strong&gt;作り&lt;/strong&gt;やすいです。インターフェースが変更されると、多くの場合、通知を受けることが賢明です。&lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt; &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; &lt;/a&gt;オプションでは、GHCは、新旧の間の違いを報告行います &lt;code&gt;.hi&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="b50c4e0495b638bc78f832720f50e287f9de7a05" translate="yes" xml:space="preserve">
          <source>The compiler infers that the field is lazy, so it is tagged with &lt;code&gt;'DecidedLazy&lt;/code&gt;. Bear in mind that what the compiler decides may be quite different from what is written in the source. See &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; for a more detailed explanation.</source>
          <target state="translated">コンパイラーはフィールドが遅延であると推測するため、 &lt;code&gt;'DecidedLazy&lt;/code&gt; タグが付けられています。コンパイラが決定するものは、ソースに書かれているものとはかなり異なる可能性があることに注意してください。詳細については、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="9774a668aa7877058c555311f9fc25aa40959a13" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;-XCPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">コンパイラー・バージョンは、 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPPマクロ（&lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;-XCPP&lt;/code&gt; &lt;/a&gt;が使用されている場合にのみ定義）を使用して、コンパイル済みコード内でテストできます。詳細については、&lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;標準CPPマクロ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d8fd806e873a214570099da2d9771dbac6f16d96" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">コンパイラのバージョンは、 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPPマクロ（&lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; &lt;/a&gt;が使用されている場合にのみ定義）を使用して、コンパイルされたコード内でテストできます。詳細については、&lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;標準CPPマクロ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d31425166e0b9b41d209465f54952b68c26f02ba" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">コンパイラーは、フロートに &lt;code&gt;+&lt;/code&gt; をインライン化することにより、 &lt;code&gt;f1&lt;/code&gt; および &lt;code&gt;f2&lt;/code&gt; の再ボックス化を回避しますが、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;がオンの場合のみです。</target>
        </trans-unit>
        <trans-unit id="a57eab48089d44200f2aa63903639e1a99c72105" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コンパイラはここで、派生句が戦略を指定していないことを警告します。警告が有効になっているが、&lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;が有効になっていない場合、コンパイラーは&lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;拡張機能を有効にすることを提案します。このオプションはデフォルトではオンになっていないため、手動または&lt;a href=&quot;#ghc-flag--Weverything&quot;&gt; &lt;code&gt;-Weverything&lt;/code&gt; &lt;/a&gt;でオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="364015fc14eeca9fb27fa97b755433aec50ba3bb" translate="yes" xml:space="preserve">
          <source>The compiler will warn when none of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; is specified. This option is off by default.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; の&lt;/a&gt;いずれも指定されていない場合、コンパイラは警告を発します。このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="281ed5525515ea0993e70db30ed197e71b26abff" translate="yes" xml:space="preserve">
          <source>The complete user-supplied kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">完全なユーザー指定の種類シグネチャは &lt;code&gt;T&lt;/code&gt; の多態的な種類を指定し、このシグネチャは再帰呼び出しを含む &lt;code&gt;T&lt;/code&gt; のすべての呼び出しに使用されます。特に、 &lt;code&gt;T&lt;/code&gt; の再帰的使用は種類 &lt;code&gt;Type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f2bfd3d94f53069effc94df0d648f9c72f750ccc" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="translated">その脱糖はです。TypeCheckなるときに理解された（で説明したように除いて、です。TypeCheckなければならない&lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;一般化（SQLのような）リスト内包&lt;/a&gt;）「次ににおける &lt;code&gt;f&lt;/code&gt; 」と「使用し、グループ &lt;code&gt;f&lt;/code&gt; は」によって句、「 &lt;code&gt;b&lt;/code&gt; 」修飾子が省略されています引数 &lt;code&gt;f&lt;/code&gt; は多相型でなければなりません。特に、「then &lt;code&gt;Data.List.sort&lt;/code&gt; 」と「then group using &lt;code&gt;Data.List.group&lt;/code&gt; 」は、多態性が不十分です。</target>
        </trans-unit>
        <trans-unit id="e59db8b8873fb6251bff5cd6dfad77bf9b5938cd" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; は同じです &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; それは上でのみ動作することを除いて、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cebda4e55c3afba7a9d7719124e3ada63e52bb27" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列 &lt;code&gt;str&lt;/code&gt; をファイル &lt;code&gt;file&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="46965f614145fd2e0bb961350e8543a37e0dd3ca" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列の書き込み &lt;code&gt;str&lt;/code&gt; ファイルに、 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a4547aaf52f671ee4d0ac2c8d5630bfc87a6e62" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; は、指定されたとおりに &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 文字列を引数として受け取るようにオペレーティングシステムコマンド &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; を実行します。面白いエスケープやシェルメタ構文の拡張はありません。したがって、 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; よりもオペレーティングシステム間での移植性が高くなります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9a90ff37849eb4211f81461b5303f42712fea0c" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; の計算は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; と&lt;em&gt;同じ&lt;/em&gt;です&lt;em&gt;。exitfail&lt;/em&gt;は実装に依存します。</target>
        </trans-unit>
        <trans-unit id="36e8bf647c12299f893bf95551889fc682fcb895" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; の計算は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; と&lt;em&gt;同等&lt;/em&gt;です&lt;em&gt;。exitfail&lt;/em&gt;は実装に依存します。</target>
        </trans-unit>
        <trans-unit id="fc29dbc900c1c24c106776b04df9bca05e5cfe6e" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; の計算は、 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; と&lt;em&gt;同じ&lt;/em&gt;です&lt;em&gt;。exitfail&lt;/em&gt;は実装に依存します。</target>
        </trans-unit>
        <trans-unit id="fb6d36ed658ece003695ded60aa84d344703fa74" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;, It terminates the program successfully.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; は同等です &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; は、それはプログラムを正常に終了します。</target>
        </trans-unit>
        <trans-unit id="a4d04e67ce9ab76c0bbbdea2ad0f01cd7fcbeeb5" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列 &lt;code&gt;str&lt;/code&gt; をファイル &lt;code&gt;file&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="18d116851ac5689419eab11fff58738d4aba225b" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; は同じです &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; それは上でのみ動作することを除いて、 &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46ebfbedadd3b348e49908c00c7a136ae0a3b598" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 関数は、文字列の書き込み &lt;code&gt;str&lt;/code&gt; ファイルに、 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beccc8e7666a74c9241e66c916390d713f7e9a28" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">計算 &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; は、指定されたとおりに &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 文字列を引数として受け取るようにオペレーティングシステムコマンド &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; を実行します。面白いエスケープやシェルメタ構文の拡張はありません。したがって、 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; よりもオペレーティングシステム間での移植性が高くなります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f1a05335883c13dae3be1b4a36833b306a5efd1" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。計算が1回だけ実行されるようにするには、代わりに &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="44b39b2d94fcf4d161bbbadc2ba27b97f45eae93" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。計算が1回だけ実行されるようにするには、代わりに &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="add1c55634d2623f9699ebad8b5515dd2d17e5c6" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。これを防ぐには、代わりに &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="07d17cfabe3f3fcfca85238e3259375c3de9c784" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">計算は、異なるスレッドによって、場合によっては同時に、複数回実行されることがあります。これを防ぐには、代わりに &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="52f9695a125810fcb1729c58e4b509090979268c" translate="yes" xml:space="preserve">
          <source>The computation to run</source>
          <target state="translated">実行する計算</target>
        </trans-unit>
        <trans-unit id="7849b8b63ccfaa0ec4dad86a18080d47939b33fc" translate="yes" xml:space="preserve">
          <source>The concatenation of all the elements of a container of lists.</source>
          <target state="translated">リストのコンテナのすべての要素の連結。</target>
        </trans-unit>
        <trans-unit id="511dfe8f476504df65281a958ed6b2922f8e44b9" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="translated">Haskellの同時実行拡張機能は、&lt;em&gt;Concurrent Haskell&lt;/em&gt;のペーパー&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gzで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="00393330d59cb21f77b62b7a951195b4749b08f5" translate="yes" xml:space="preserve">
          <source>The conjugate of a complex number.</source>
          <target state="translated">複素数の共役。</target>
        </trans-unit>
        <trans-unit id="7e61d83010032d16fcd6d96bc1ee67e74abc2ee7" translate="yes" xml:space="preserve">
          <source>The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.</source>
          <target state="translated">グラフの連結された構成要素。2つの頂点は、それらの間にパスがあり、どちらかの方向にエッジを横断している場合、接続されています。</target>
        </trans-unit>
        <trans-unit id="b5b6ceffe39d0d5eedc736955541b7ffa6430ede" translate="yes" xml:space="preserve">
          <source>The cons constructor (e.g &lt;code&gt;3:4:[]&lt;/code&gt;)</source>
          <target state="translated">短所コンストラクター（例 &lt;code&gt;3:4:[]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8ba3b2a290b55dc2fc0d0d6af5a22e45514ed39e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリロケーションに関連付けられていない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="28d23ff9245e92f331af466af03ff314f5479be2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="9836a72bb97f8856c19c64a657d43deda4d232f2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリロケーションに関連付けられていない &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="f76a0e137f54f18c3f7ac1708ea489f83a12cf45" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="86d0acfb8c600d07e3b3575390f9c70049148847" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="aee9b6f259cc959b36e11590eea5cb4db85f0c33" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="bde3669019f674519abd41b72eceb3038215dc5e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">定数 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; には、有効なメモリ位置に関連付けられていない &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; の識別値が含まれています。</target>
        </trans-unit>
        <trans-unit id="799dc66320c38ca69a9441401db6bffcbf9eb360" translate="yes" xml:space="preserve">
          <source>The constant functor.</source>
          <target state="translated">定数ファンクタ。</target>
        </trans-unit>
        <trans-unit id="15ca88cd220e51ba407b106275a1029cb4b766e9" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">制約 &lt;code&gt;Coercible t1 t2&lt;/code&gt; と同様である &lt;code&gt;t1 ~ t2&lt;/code&gt; 、しかし間表象平等表し &lt;code&gt;t1&lt;/code&gt; と &lt;code&gt;t2&lt;/code&gt; の役割（の意味での&lt;a href=&quot;#roles&quot;&gt;役割&lt;/a&gt;）。これは、ドキュメントも含む&lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;によってエクスポートされます。詳細と議論については、&lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;「Safe Coercions」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cda43f4b9e044bd999f3ffb0d1982eddf1b3ad96" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.14.1.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">制約 &lt;code&gt;Coercible t1 t2&lt;/code&gt; と同様である &lt;code&gt;t1 ~ t2&lt;/code&gt; 、しかし間表象平等表し &lt;code&gt;t1&lt;/code&gt; と &lt;code&gt;t2&lt;/code&gt; の役割（の意味での&lt;a href=&quot;#roles&quot;&gt;役割&lt;/a&gt;）。これは&lt;a href=&quot;../libraries/base-4.14.1.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;によってエクスポートされ、ドキュメントも含まれています。詳細と議論は、論文&lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;「SafeCoercions」にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9b45d0e4831d974f0b76095cef9bc4b87f2ec6bb" translate="yes" xml:space="preserve">
          <source>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</source>
          <target state="translated">制約は、ヘッドよりも少ないコンストラクタと変数(まとめて数え、繰り返しをカウントする)を持ちます。</target>
        </trans-unit>
        <trans-unit id="a50d755f429fad42bcff479620bc13360a0c4b46" translate="yes" xml:space="preserve">
          <source>The constraint mentions at least one type variable. So this is allowed:</source>
          <target state="translated">制約は少なくとも1つの型変数に言及しています。なので、これは許可されています。</target>
        </trans-unit>
        <trans-unit id="ce649c6fe844bb02501d53bdc8fcdcf10a388961" translate="yes" xml:space="preserve">
          <source>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</source>
          <target state="translated">制約は型関数について言及していません。型関数アプリケーションは,原則として,任意のサイズの型に拡張することができます。</target>
        </trans-unit>
        <trans-unit id="e1443e2e18615f60be07422db9598a6ab2679217" translate="yes" xml:space="preserve">
          <source>The constraints: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</source>
          <target state="translated">制約： &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112775bf1168cc3582de7a46d153e201b0ce10f8" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">構成 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; は、計算内で発生し、完全には処理されないIOエラーを公開します。</target>
        </trans-unit>
        <trans-unit id="f2cbf6e1527ac15029debb90371be54661016768" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">構成 &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; は、計算内で発生し、完全には処理されないIOエラーを公開します。</target>
        </trans-unit>
        <trans-unit id="d9cb341bdfdb67d6c8abafd06a4a86c8917f60b5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">コンストラクタ &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 「バニラ」構文（とコンストラクタのもの：大まかに二つのカテゴリーに分けることができる &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ）、及びGADT構文（とコンストラクタのもの &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ）。 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; の追加型変数やクラスのコンテキストを定量化コンストラクタは、コンストラクタのいずれかの様々なを囲むことができます。ただし、数値化される型変数は、使用されるコンストラクター構文によって異なります。</target>
        </trans-unit>
        <trans-unit id="96dfdfe1a048f1f49896be9e99d5931a975888f5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">コンストラクタ &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 「バニラ」構文（とコンストラクタのもの：大まかに二つのカテゴリーに分けることができる &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ）、及びGADT構文（とコンストラクタのもの &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ）。 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; の追加型変数やクラスのコンテキストを定量化コンストラクタは、コンストラクタのいずれかの様々なを囲むことができます。ただし、数値化される型変数は、使用されるコンストラクター構文によって異なります。</target>
        </trans-unit>
        <trans-unit id="d2ef5f16504fcf65ef460021616315706e1e4d2a" translate="yes" xml:space="preserve">
          <source>The constructors have rank-2 types:</source>
          <target state="translated">コンストラクタにはランク2の型があります。</target>
        </trans-unit>
        <trans-unit id="f9e51adba83704f5afe34590e66e2249e5965154" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;OPTIONS_GHC&lt;/code&gt; are appended to the command-line options, so options given in the source file override those given on the command-line.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; の内容はコマンドラインオプションに追加されるため、ソースファイルで指定されたオプションは、コマンドラインで指定されたオプションをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="dff9227ff63668c69518bca492a298e49c135a62" translate="yes" xml:space="preserve">
          <source>The contents of this module is liable to change, or disappear entirely. Please &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;let me know&lt;/a&gt; if you depend on anything here.</source>
          <target state="translated">このモジュールの内容は変更されるか、完全に消える傾向があります。ここで何かに依存し&lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;ている&lt;/a&gt;場合はお知らせください。</target>
        </trans-unit>
        <trans-unit id="8a40246a3e18d1d7e41c15d6857dbf0b4d63fa72" translate="yes" xml:space="preserve">
          <source>The contents of this module may change &lt;strong&gt;in any way whatsoever&lt;/strong&gt; and &lt;strong&gt;without any warning&lt;/strong&gt; between minor versions of this package.</source>
          <target state="translated">このモジュールの内容は、このパッケージのマイナーバージョン間&lt;strong&gt;では、いかなる方法でも&lt;/strong&gt;、&lt;strong&gt;警告なしに&lt;/strong&gt;変更さ&lt;strong&gt;れる&lt;/strong&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf37f21b6a3daad2c6c95d66502066032ad944e9" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">継続モナド変換子。任意の型コンストラクタに継続処理を追加するために使用できます。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスとほとんどの操作では、 &lt;code&gt;m&lt;/code&gt; がモナドである必要はありません。</target>
        </trans-unit>
        <trans-unit id="30545a4e8f9d1b896fc755171a6a74c0b349be13" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">継続モナド変換子。任意の型コンストラクターに継続処理を追加するために使用できます。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスとほとんどの操作では、 &lt;code&gt;m&lt;/code&gt; がモナドである必要はありません。</target>
        </trans-unit>
        <trans-unit id="f75193e312873c254935fbb8e4b2cdc1397df81b" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;makeAbsolute&lt;/code&gt; function can be found in &lt;code&gt;System.Directory&lt;/code&gt;.</source>
          <target state="translated">対応する &lt;code&gt;makeAbsolute&lt;/code&gt; 関数は &lt;code&gt;System.Directory&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="fbffcb96186edf6acc0b855b93198f4a5cdf1151" translate="yes" xml:space="preserve">
          <source>The corresponding translation for an IO-typed &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">IOタイプの &lt;code&gt;e&lt;/code&gt; に対応する変換は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="86d8b09707b93cf768c10a7d141f2453f73455d0" translate="yes" xml:space="preserve">
          <source>The costs of all CAFs in a module are usually attributed to one &amp;ldquo;big&amp;rdquo; CAF cost-centre. With this option, all CAFs get their own cost-centre. An &amp;ldquo;if all else fails&amp;rdquo; option&amp;hellip;</source>
          <target state="translated">モジュール内のすべてのCAFのコストは、通常、1つの「大きな」CAFコストセンターに起因します。このオプションを使用すると、すべてのCAFが独自のコスト中心を取得します。「他のすべてが失敗した場合」オプション&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7cf65e46a7de9baa89f7b3eb6db073c4649dd328" translate="yes" xml:space="preserve">
          <source>The cumulative allocations of the program in bytes.</source>
          <target state="translated">プログラムの累積割り当て量をバイト単位で表示します。</target>
        </trans-unit>
        <trans-unit id="7a3b930a34c98c0e41a7bef5730a3bbf42841f7f" translate="yes" xml:space="preserve">
          <source>The current implementation of the &lt;code&gt;OverloadedLists&lt;/code&gt; extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow &lt;code&gt;IsList&lt;/code&gt; instances to take advantage of the compact representation. Equipped with this capability the &lt;code&gt;OverloadedLists&lt;/code&gt; extension will be in a good position to subsume the &lt;code&gt;OverloadedStrings&lt;/code&gt; extension (currently, as a special case, string literals benefit from statically allocated compact representation).</source>
          <target state="translated">&lt;code&gt;OverloadedLists&lt;/code&gt; 拡張機能の現在の実装は、リテラルのみが設定されたリストを特別な方法で処理することで改善できます。より具体的には、コンパイラーはコンパクトな表現を使用してそのようなリストを静的に割り当て、 &lt;code&gt;IsList&lt;/code&gt; インスタンスがコンパクトな表現を利用できるようにします。この能力が装備 &lt;code&gt;OverloadedLists&lt;/code&gt; 拡張が包摂するための良い位置になり &lt;code&gt;OverloadedStrings&lt;/code&gt; の拡張を（現在、特別な場合として、文字列リテラルは、静的に割り当てられたコンパクトな表現から利益を得ます）。</target>
        </trans-unit>
        <trans-unit id="1ad91c37c3debcd3611b7e9c0f27ffd87d2d02eb" translate="yes" xml:space="preserve">
          <source>The current notion of when two view pattern expressions are &amp;ldquo;the same&amp;rdquo; is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; will not be coalesced.</source>
          <target state="translated">2つのビューパターン式が「同じ」であるという現在の概念は非常に制限されています。完全な構文上の同等性でさえありません。ただし、変数、リテラル、アプリケーション、およびタプルは含まれます。たとえば、 &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; 2つのインスタンス（ &quot;hi&quot;、 &quot;there&quot;）が収集されます。ただし、現在の実装ではアルファ相当までは比較されないため、 &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; 2つのインスタンスは結合されません。</target>
        </trans-unit>
        <trans-unit id="2a1a29ae3433386a16c919320319cfdd85da4c46" translate="yes" xml:space="preserve">
          <source>The current status of a thread</source>
          <target state="translated">スレッドの現在の状態</target>
        </trans-unit>
        <trans-unit id="82c826fe4c2ec0dd5e2b6732f42c3a1009fa7e05" translate="yes" xml:space="preserve">
          <source>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</source>
          <target state="translated">現在のスレッドのスタックが限界を超えました。例外が発生したので、スレッドのスタックは確実に再び限界を下回ることになりますが、プログラマはすぐに改善策をとるべきです。</target>
        </trans-unit>
        <trans-unit id="ed3b026bad78c443d4533994012a8c4a2846cb3c" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;-N&lt;/code&gt; option is available to the Haskell program via &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt;, and it may be changed while the program is running by calling &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-N&lt;/code&gt; オプションの現在の値は、Haskellプログラムで &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt; を介して使用できます。また、プログラムの実行中に &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt; を呼び出すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="9ec8f77a94455e151e4c1a9e7ec7c517542a0b66" translate="yes" xml:space="preserve">
          <source>The cut-down Haskell lexer, used by Text.Read</source>
          <target state="translated">Text.Read で使用されるカットダウンされた Haskell レキサー</target>
        </trans-unit>
        <trans-unit id="00bd3d9662d83ac9ec53f0ae935356d4eabc4566" translate="yes" xml:space="preserve">
          <source>The data family &lt;code&gt;URec&lt;/code&gt; is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</source>
          <target state="translated">データファミリー &lt;code&gt;URec&lt;/code&gt; は、特定のリフトされていない引数を持つデータ型に対する一般的なプログラミングを可能にするために提供されています。一般的なリフトされていないタイプに対応する6つのインスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="7cc312cbbdd186a59028317a6d6a5545651161f0" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</source>
          <target state="translated">関連する型のデータまたは型ファミリのインスタンスは、クラス・パラメータに対応する型インデックスが、インスタンス・ヘッドで指定された型と正確に同じでなければならないというルールに従わなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5c9753438fba7e9bfbfa96374f6632d59b89893a" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;Foo&lt;/code&gt; has two constructors with types:</source>
          <target state="translated">データ型 &lt;code&gt;Foo&lt;/code&gt; には、型を持つ2つのコンストラクタがあります。</target>
        </trans-unit>
        <trans-unit id="e622f9e9a73471a6364b9efb8251bd756d0f5650" translate="yes" xml:space="preserve">
          <source>The data type invariant for lazy &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;: Every &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">遅延 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; のデータ型不変：すべての &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; か、null以外の &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 構成されています。すべての関数はこれを保持する必要があり、QCプロパティはこれをチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="5d0441bbee470c2143c8f36a2d1679d26b7e70ba" translate="yes" xml:space="preserve">
          <source>The data type invariant: Every ByteString is either &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">データ型不変：すべてのByteStringは &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; か、null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のByteStringで構成されます。すべての関数はこれを保持する必要があり、QCプロパティはこれをチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="7d85f04588f07b22aadb87552b730e4cf6174d81" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt;.</source>
          <target state="translated">テンプレートHaskellのデータ型とモナディックコンストラクター関数は、 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; ライブラリにあります。</target>
        </trans-unit>
        <trans-unit id="65cb9fa712c4ef1743587a031048fc3377115bf6" translate="yes" xml:space="preserve">
          <source>The datatype below derives the &lt;code&gt;Eq&lt;/code&gt; typeclass, but doesn&amp;rsquo;t specify a strategy. When &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt;&lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this.</source>
          <target state="translated">以下のデータ型は &lt;code&gt;Eq&lt;/code&gt; タイプクラスを派生させていますが、戦略を指定していません。とき&lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt; &lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt; &lt;/a&gt;有効になっていると、コンパイラはこれについて警告を発します。</target>
        </trans-unit>
        <trans-unit id="09ea5a667a11159497b7db70c8ac2393a6a6a569" translate="yes" xml:space="preserve">
          <source>The day of the epoch of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt;, 1970-01-01</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt; のエポックの日、1970-01-01</target>
        </trans-unit>
        <trans-unit id="425505b50ca94bcb223c9489d59b624f0fd02138" translate="yes" xml:space="preserve">
          <source>The debugger provides the following:</source>
          <target state="translated">デバッガは以下の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="d008597f45a1f7e417f2daa3afa26ed473de0e47" translate="yes" xml:space="preserve">
          <source>The debugging options &lt;code&gt;-Dx&lt;/code&gt; also generate events which are logged using the tracing framework. By default those events are dumped as text to stdout (&lt;code&gt;-Dx&lt;/code&gt; implies &lt;code&gt;-v&lt;/code&gt;), but they may instead be stored in the binary eventlog file by using the &lt;code&gt;-l&lt;/code&gt; option.</source>
          <target state="translated">デバッグオプション &lt;code&gt;-Dx&lt;/code&gt; は、トレースフレームワークを使用してログに記録されるイベントも生成します。デフォルトでは、これらのイベントはテキストとしてstdoutにダンプされます（ &lt;code&gt;-Dx&lt;/code&gt; は &lt;code&gt;-v&lt;/code&gt; を意味します）が、 &lt;code&gt;-l&lt;/code&gt; オプションを使用してバイナリイベントログファイルに保存することもできます。</target>
        </trans-unit>
        <trans-unit id="8dbf33fb940a3d9f2a5b57f121f6732a25396c40" translate="yes" xml:space="preserve">
          <source>The declaration</source>
          <target state="translated">宣言</target>
        </trans-unit>
        <trans-unit id="61598f72e2c92204906e453b4899d9c4f265e7a4" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="translated">中置型演算子 &lt;code&gt;(':)&lt;/code&gt; のため、 &lt;code&gt;HCons&lt;/code&gt; の宣言にはTypeOperatorsも必要&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4404a7232bfc86c4b3054c2503dd6ddca4de51d" translate="yes" xml:space="preserve">
          <source>The declaration group containing &lt;code&gt;D&lt;/code&gt; is terminated by the empty top-level declaration splice &lt;code&gt;$(return [])&lt;/code&gt; (recall, &lt;code&gt;Q&lt;/code&gt; is a Monad, so we may simply &lt;code&gt;return&lt;/code&gt; the empty list of declarations).</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; を含む宣言グループは、空のトップレベルの宣言スプライス &lt;code&gt;$(return [])&lt;/code&gt; で終了します（ &lt;code&gt;Q&lt;/code&gt; はモナドなので、空の宣言リストを &lt;code&gt;return&lt;/code&gt; だけです）。</target>
        </trans-unit>
        <trans-unit id="c3ea4ce42435200f8c7550076521012105fc2dd4" translate="yes" xml:space="preserve">
          <source>The declarations above are accepted. However, if we add &lt;code&gt;MkOther :: T Int&lt;/code&gt;, we get an error that the equality constraint is not satisfied; &lt;code&gt;Int&lt;/code&gt; is not a type literal. Note that explicitly quantifying with &lt;code&gt;forall a&lt;/code&gt; is necessary in order for &lt;code&gt;T&lt;/code&gt; to typecheck (see &lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</source>
          <target state="translated">上記の宣言は受け入れられます。ただし、 &lt;code&gt;MkOther :: T Int&lt;/code&gt; を追加すると、等式制約が満たされていないというエラーが発生します。 &lt;code&gt;Int&lt;/code&gt; は型リテラルではありません。 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;#complete-kind-signatures&quot;&gt;タイプ&lt;/a&gt;チェックを行うには、 &lt;code&gt;forall a&lt;/code&gt; を使用して明示的に定量化する必要があることに注意してください（完全なユーザー指定の種類の署名と多態性の再帰を参照）。</target>
        </trans-unit>
        <trans-unit id="4f3eb1e20a19137970a20b350de0e993090c5f42" translate="yes" xml:space="preserve">
          <source>The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an &lt;code&gt;hsig&lt;/code&gt; file. To refer to any such type, you must declare it yourself:</source>
          <target state="translated">マージされる依存関係のシグネチャからの宣言と型は、 &lt;code&gt;hsig&lt;/code&gt; ファイルの型チェック時にスコープに含まれません。そのような型を参照するには、自分で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="28bc248b719a26880d510c50487bc9904247476f" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デコーダーは使用可能な入力を消費したため、続行するにはさらに多くのものが必要です。提供 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; より多くの入力が可能とされた場合に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; そうでないと、あなたが新しい取得する &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7be60721ea4767c773d4ff5809e621bbad6d744b" translate="yes" xml:space="preserve">
          <source>The decoder has successfully finished. Except for the output value you also get any unused input as well as the number of bytes consumed.</source>
          <target state="translated">デコーダは正常に終了しました。出力値以外に、未使用の入力や消費されたバイト数も取得できます。</target>
        </trans-unit>
        <trans-unit id="c50453020b64e1b5897a128e6a4b8f6fd0ce71b8" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">デコーダでエラーが発生しました。デコーダーが &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; か、入力が不十分でした。未使用の入力と消費されたバイト数が含まれます。</target>
        </trans-unit>
        <trans-unit id="1106af4463a8221ffa09eb5ef1181409ca7b66ab" translate="yes" xml:space="preserve">
          <source>The decoder to isolate</source>
          <target state="translated">分離するためのデコーダ</target>
        </trans-unit>
        <trans-unit id="9109ffd32c6c50a2b3bbde42b4613b2367726367" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt;, which does no translation on Unix systems, but translates &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; and back on Windows.</source>
          <target state="translated">デフォルト &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; ための &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt; Unixシステムには翻訳しません、が、翻訳 &lt;code&gt;'\r\n'&lt;/code&gt; する &lt;code&gt;'\n'&lt;/code&gt; し、Windows上でバック。</target>
        </trans-unit>
        <trans-unit id="e1abf9eda04f648cec0d055b085fe295d921786f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is the same as the default encoding on your system, which is also available as &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">デフォルトの &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は、システムのデフォルトのエンコーディングと同じであり、 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; としても使用できます。（GHC注：Windowsでは、現在2バイトエンコーディングはサポートされていません。コンソールのコードページがサポートされていない場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; になります。）</target>
        </trans-unit>
        <trans-unit id="1f7510baab521b5948629307f9f6f4dc19cd4a03" translate="yes" xml:space="preserve">
          <source>The default backend for GHC. It is a native code generator, compiling Cmm all the way to assembly code. It is the fastest backend and generally produces good performance code. It has the best support for compiling shared libraries. Select it with the &lt;code&gt;-fasm&lt;/code&gt; flag.</source>
          <target state="translated">GHCのデフォルトのバックエンド。これはネイティブコードジェネレーターであり、Cmmをアセンブリコードまでコンパイルします。これは最速のバックエンドであり、一般に優れたパフォーマンスコードを生成します。共有ライブラリのコンパイルに最適です。 &lt;code&gt;-fasm&lt;/code&gt; フラグで選択します。</target>
        </trans-unit>
        <trans-unit id="372a76ca948e47b638039a6cfbc912e969dc50c4" translate="yes" xml:space="preserve">
          <source>The default buffering mode is different in GHCi to GHC.</source>
          <target state="translated">GHCiとGHCではデフォルトのバッファリングモードが異なります。</target>
        </trans-unit>
        <trans-unit id="612f5aad425db1f69a9dbdbaaa3947648f24e8cc" translate="yes" xml:space="preserve">
          <source>The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered.</source>
          <target state="translated">ハンドルが開かれたときのデフォルトのバッファリングモードは、実装に依存しており、そのハンドルにアタッチされているファイルシステムオブジェクトに依存します。ほとんどの実装では、物理ファイルは通常ブロックバッファリングされ、ターミナルは通常ラインバッファリングされます。</target>
        </trans-unit>
        <trans-unit id="0961e4a3376f291925aa422749fabd42ce25f975" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">デフォルトの宣言では、左側の型&lt;em&gt;変数&lt;/em&gt;のみを言及する必要があり、右側は、左側で明示的にバインドされている型変数のみを言及する必要があります。ただし、右側には左側で暗黙的にバインドされている種類の変数に言及することが許可されているため、この制限は&lt;em&gt;種類&lt;/em&gt;変数に対して緩和されています。</target>
        </trans-unit>
        <trans-unit id="c6f838e51c0c9ed9fe723da0d1493d400aae5e3d" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and type variables may not be repeated on the left-hand side. The right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">デフォルトの宣言では、左側の型&lt;em&gt;変数&lt;/em&gt;のみに言及する必要があり、型&lt;em&gt;変数&lt;/em&gt;を左側で繰り返すことはできません。右側には、左側に明示的にバインドされている型変数のみを記載する必要があります。ただし、右側では、左側に暗黙的にバインドされている種類変数について言及できるため、この制限は&lt;em&gt;種類&lt;/em&gt;変数に対して緩和されます。</target>
        </trans-unit>
        <trans-unit id="e629035dab4042ca2e3774c6dd02fa07a19ca5ba" translate="yes" xml:space="preserve">
          <source>The default definition for &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt;, which is suitable for abstract datatypes with no substructures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; のデフォルトの定義は &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; です。これは、部分構造のない抽象データ型に適しています。</target>
        </trans-unit>
        <trans-unit id="b37307a1a8b5c8a76936f7e75a2ac6d6c53b888a" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to an identity datatype constructor, using the isomorphism pair as injection and projection.</source>
          <target state="translated">デフォルトの定義では、注入と射影として同型ペアを使用して、 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; の型の型コンストラクター &lt;code&gt;c&lt;/code&gt; をIDデータ型コンストラクターにインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="0ebc5859a93e62be528328f3201553481af2edf0" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to the monad datatype constructor, defining injection and projection using &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトの定義では、 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; の型の型コンストラクタ &lt;code&gt;c&lt;/code&gt; をモナドデータ型コンストラクタにインスタンス化し、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; を使用して注入と射影を定義します。</target>
        </trans-unit>
        <trans-unit id="4bd4056577869d6ffa3c25c8d2085ea54f8f3b3d" translate="yes" xml:space="preserve">
          <source>The default definition is</source>
          <target state="translated">デフォルトの定義は</target>
        </trans-unit>
        <trans-unit id="0c68a975cf82f38a807abb27f8056b694f43e039" translate="yes" xml:space="preserve">
          <source>The default definition is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, which is appropriate for instances of other forms.</source>
          <target state="translated">デフォルトの定義は &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; で、他の形式のインスタンスに適しています。</target>
        </trans-unit>
        <trans-unit id="aa9945acbeccb98293938a8f8c707927dd353e5f" translate="yes" xml:space="preserve">
          <source>The default definition may be overridden with a more efficient version if desired.</source>
          <target state="translated">デフォルトの定義は、必要に応じてより効率的なバージョンで上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="71589b344fdce3f6d3065162df2b93817e514841" translate="yes" xml:space="preserve">
          <source>The default definition should be sufficient, but this can be overridden for efficiency.</source>
          <target state="translated">デフォルトの定義は十分であるべきですが、効率化のためにオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="b230bf83d4661530a10d60a3a4832bae81967728" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトの定義では &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; を使用します。定義インスタンス &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; はまた、定義する必要があり &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; を通り &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8f0470f58f998c4d12f0e8356a21d2ca7b5de3" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトの定義では &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; を使用します。定義インスタンス &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; はまた、定義する必要があり &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; を通り &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c58343eea6290f399d2ab6ad1cadcd380e922e3" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 関数のデフォルトの定義は、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; に関するものです。</target>
        </trans-unit>
        <trans-unit id="ec66529839a9863362b72c24581910fe9d869109" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 関数のデフォルトの定義は、 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; に関するものです。</target>
        </trans-unit>
        <trans-unit id="491d8a12b5fa1e7b0bec380645e2c6e813fe0eda" translate="yes" xml:space="preserve">
          <source>The default method definitions in the &lt;code&gt;Exception&lt;/code&gt; class do what we need in this case. You can now throw and catch &lt;code&gt;ThisException&lt;/code&gt; and &lt;code&gt;ThatException&lt;/code&gt; as exceptions:</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; クラスのデフォルトのメソッド定義は、この場合に必要なことを行います。 &lt;code&gt;ThisException&lt;/code&gt; と &lt;code&gt;ThatException&lt;/code&gt; を例外としてスローおよびキャッチできるようになりました。</target>
        </trans-unit>
        <trans-unit id="06f71be64b1eace75a4676b9f81b6631fa302e4c" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="translated">次に、シリアル化の一般的な実装に対応する、デフォルトの &lt;code&gt;put&lt;/code&gt; メソッドが使用されます。&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;を使用している場合、 &lt;code&gt;deriving Serialize&lt;/code&gt; インスタンスのSerialize句を &lt;code&gt;UserTree&lt;/code&gt; データ型宣言に添付するだけで、同じインスタンスが生成されます。ジェネリック関数のその他の例については、Hackageの&lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;ジェネリック派生&lt;/a&gt;パッケージを参照してください。</target>
        </trans-unit>
        <trans-unit id="84a8076800f1a94cd466a3ca2cb82ca67bed6590" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">デフォルトの並列GC設定は通常、並列プログラム（つまり、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;を使用するもの、戦略、または複数のスレッドを使用するもの）に適しています。ただし、特にプログラムに大量のヒープデータがあり、GCが実行時間のかなりの部分を占める場合は、シングルスレッドのシーケンシャルプログラムでも並列GCを有効にすると便利な場合があります。逐次プログラムで並列GCを使用するには、適切な &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用して並列ランタイムを有効にします。さらに、-qg1を使用して並列GCを古い世代に制限すると &lt;code&gt;-qg1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8b8f4457b131cbd6a076f86c5f337a8e72b95e39" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">デフォルトの並列GC設定は、通常、並列プログラム（つまり、&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;、Strategies、または複数のスレッドを使用するプログラム）に適しています。ただし、特にプログラムに大量のヒープデータがあり、GCが実行時間のかなりの部分を占める場合は、シングルスレッドシーケンシャルプログラムでも並列GCを有効にすると便利な場合があります。シーケンシャルプログラムで並列GCを使用するには、適切な &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用して並列ランタイムを有効にします。さらに、-qg1を使用して並列GCを旧世代に制限すると &lt;code&gt;-qg1&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1c469f1e0fe0a399e3c8b4ab9c90096159140285" translate="yes" xml:space="preserve">
          <source>The default preferences which may be overwritten in the &lt;code&gt;.haskeline&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;.haskeline&lt;/code&gt; ファイルで上書きされるデフォルトの設定。</target>
        </trans-unit>
        <trans-unit id="2646b613e6eb1c1c85aa64b66ff2f7d3602d210c" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">抽象データ型パラメーターのデフォルトの役割が表現になりました。（抽象データ型は、コンストラクターがリストされていないデータ型です。）別のロールを取得するには、ロール注釈を使用します。（&lt;a href=&quot;glasgow_exts#roles&quot;&gt;役割を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="60620248a38bdba79e7fcf67abe638e2752d6a16" translate="yes" xml:space="preserve">
          <source>The default seems to work well here. If you have plenty of memory, it is usually better to use &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt;) than to increase &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ここではデフォルトがうまく機能するようです。メモリが十分にある場合は、通常、&lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt;を増やすよりも、 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; （-H [⟨size⟩]を参照）を使用することをお&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3395f0bc00fd88ab55e5b4f27b7ed6fe2e944e0a" translate="yes" xml:space="preserve">
          <source>The default style (&lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt;).</source>
          <target state="translated">デフォルトのスタイル（ &lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af2102e497ed3634f45c2fd75b234c6748ca55b8" translate="yes" xml:space="preserve">
          <source>The definition (of a function, variable, struct or typedef) is written to the C file, and its prototype or extern declaration to the C header. Inline functions are handled correctly. struct definitions and typedefs are written to the C program too. The &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;typedef&lt;/code&gt; keyword must come just after &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">（関数、変数、構造体、またはtypedefの）定義はCファイルに書き込まれ、そのプロトタイプまたはextern宣言はCヘッダーに書き込まれます。インライン関数は正しく処理されます。構造体の定義とtypedefもCプログラムに書き込まれます。 &lt;code&gt;inline&lt;/code&gt; 、 &lt;code&gt;struct&lt;/code&gt; または &lt;code&gt;typedef&lt;/code&gt; のキーワードが直後に来なければならない &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c8661345439bef92de6f21733c68492b49b19b5" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;compatible&amp;rdquo; uses a notion of &amp;ldquo;apart&amp;rdquo;, whose definition in turn relies on type family reduction. This condition of &amp;ldquo;apartness&amp;rdquo;, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</source>
          <target state="translated">「互換性のある」の定義では、「apart」の概念を使用しています。その定義は、タイプファミリーの削減に依存しています。述べたように、この「アパート」の状態はチェックすることが不可能であるため、この控えめな近似を使用します。2つのタイプは、潜在的に無限のユニファイアによっても統合できない場合、離れていると見なされます。unifierが無限であることを許可すると、次のインスタンスのペアが許可されなくなります。</target>
        </trans-unit>
        <trans-unit id="70f33fa7b9f96d835ab103c50be5ec10b816d10e" translate="yes" xml:space="preserve">
          <source>The definition is syntactic:</source>
          <target state="translated">定義は構文的なものです。</target>
        </trans-unit>
        <trans-unit id="df390321900febf5a604611d2971ac50e861f17b" translate="yes" xml:space="preserve">
          <source>The definition of &quot;math symbol&quot; may be a little counter-intuitive depending on one's background:</source>
          <target state="translated">数学記号」の定義は、その人のバックグラウンドによっては少し逆効果になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9142eae3b3df142878b925196063f3a19a7bf511" translate="yes" xml:space="preserve">
          <source>The definition of (say) &lt;code&gt;build&lt;/code&gt; in &lt;code&gt;GHC/Base.hs&lt;/code&gt; looks like this:</source>
          <target state="translated">（言う）の定義 &lt;code&gt;build&lt;/code&gt; で &lt;code&gt;GHC/Base.hs&lt;/code&gt; は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="c2ee65e9c75aa9258dca0f16a6b10f4fd9a759a9" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;lsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の定義は、 &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; で &lt;code&gt;id&lt;/code&gt; の型をインスタンス化する必要があるため拒否されますが、これは許可されていません。ポリモーフィック型を使用してポリモーフィック型変数をインスタンス化することを、&lt;em&gt;予測的ポリモーフィズム&lt;/em&gt;といいます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="771404ab6f98868990a30122c2e2669c9b6b0a26" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;rsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; の型を &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; でインスタンス化する必要があるため、 &lt;code&gt;foo&lt;/code&gt; の定義は拒否されますが、これは許可されていません。ポリモーフィック型を使用してポリモーフィック型変数をインスタンス化することは、非&lt;em&gt;叙述的ポリモーフィズム&lt;/em&gt;と呼ばれます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed024c34bd63c1441cb3695b992556af082202b2" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;inst&lt;/code&gt; is unchanged from the Haskell Report (roughly, just a type). The &lt;code&gt;context =&amp;gt;&lt;/code&gt; part is optional. That is the only syntactic change to the language.</source>
          <target state="translated">&lt;code&gt;inst&lt;/code&gt; の定義は、Haskell Reportから変更されていません（大まかに、タイプのみ）。 &lt;code&gt;context =&amp;gt;&lt;/code&gt; の部分はオプションです。これが言語の唯一の構文変更です。</target>
        </trans-unit>
        <trans-unit id="0bfdf9f8e4b0cf4d6ac3380a527908a80562e1fe" translate="yes" xml:space="preserve">
          <source>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using &lt;code&gt;seq&lt;/code&gt; or strictness annotations on data constructor fields.</source>
          <target state="translated">リテーナの定義は、スペースリークの一般的な原因を反映するように設計されています。大きな構造は、評価されていない計算によって保持され、計算が強制されると解放されます。良い例は、有限マップで値を検索することです。この場合、検索がタイムリーに強制されない限り、未評価の検索によってマッピング全体が保持されます。これらの種類のスペースリークは、データコンストラクターフィールドに &lt;code&gt;seq&lt;/code&gt; またはstrictnessアノテーションを使用して、関連する計算を熱心に実行させることにより、解消することができます。</target>
        </trans-unit>
        <trans-unit id="0a4d062a38697a5c692b5c4d00fce9e23429e7b4" translate="yes" xml:space="preserve">
          <source>The delayed RSS update can confuse programmers debugging memory issues, production memory monitoring tools, and end users who may complain about undue memory usage shown in reporting tools, so with this flag it can be turned off.</source>
          <target state="translated">RSSの更新が遅れると、メモリ問題をデバッグしているプログラマや本番のメモリ監視ツール、レポートツールに表示される不当なメモリ使用量に文句を言うエンドユーザを混乱させる可能性があるため、このフラグをオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="f9455c27066e060f9c4ed319a5e6f962fe125ba2" translate="yes" xml:space="preserve">
          <source>The dependency &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; here specifies that the type &lt;code&gt;e&lt;/code&gt; of elements is uniquely determined by the type of the collection &lt;code&gt;ce&lt;/code&gt;. Note that both parameters of Collects are of kind &lt;code&gt;Type&lt;/code&gt;; there are no constructor classes here. Note too that all of the instances of &lt;code&gt;Collects&lt;/code&gt; that we gave earlier can be used together with this new definition.</source>
          <target state="translated">ここで、依存関係 &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; は、要素のタイプ &lt;code&gt;e&lt;/code&gt; がコレクション &lt;code&gt;ce&lt;/code&gt; のタイプによって一意に決定されることを指定します。Collectsのパラメータは両方とも &lt;code&gt;Type&lt;/code&gt; であることに注意してください。ここにはコンストラクタークラスはありません。前述の &lt;code&gt;Collects&lt;/code&gt; のすべてのインスタンスは、この新しい定義と一緒に使用できることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="0ed435c3cbe535cb6b31533a151482c8d2a49765" translate="yes" xml:space="preserve">
          <source>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</source>
          <target state="translated">GHC の依存関係生成フェーズでは、便利なオプションがいくつか追加されています。依存関係の生成に影響を与えるオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b14601aa73f99ec94b5c907467d51ea631241fb4" translate="yes" xml:space="preserve">
          <source>The dependency is based on file content, not a modification time</source>
          <target state="translated">依存関係はファイルの内容に基づいており、修正時間ではありません。</target>
        </trans-unit>
        <trans-unit id="3c358c9fef1903c6b809a8b35e1f6f1eb8d8555a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separately from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">派生メカニズムは、&lt;a href=&quot;#stand-alone-deriving&quot;&gt;スタンドアロンの派生メカニズム&lt;/a&gt;を使用して、データ型宣言とは別に使用できます。</target>
        </trans-unit>
        <trans-unit id="adeb50d906769008b71fc1da461a1b88d5c5394a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separtely from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">派生メカニズムは、&lt;a href=&quot;#stand-alone-deriving&quot;&gt;スタンドアロンの派生メカニズム&lt;/a&gt;を使用して、データ型宣言とは別に使用できます。</target>
        </trans-unit>
        <trans-unit id="b7b9b515a6b382dc8b30446310290e049039607a" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、入力文字列のトークン間に任意のHaskell空白を許可します。余分な括弧も使用できます。</target>
        </trans-unit>
        <trans-unit id="0df45d847dca83db9351f4d864dd9921bcab85be" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、入力文字列のトークン間に任意のHaskell空白を許可します。余分な括弧も使用できます。</target>
        </trans-unit>
        <trans-unit id="827987dc4d21c55f29757d61b2ead342246251b4" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、入力文字列のトークン間に任意のHaskell空白を許可します。余分な括弧も使用できます。</target>
        </trans-unit>
        <trans-unit id="181a26c0ac10388c1c28e3a4a0bb2c744983c69d" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;HasRing&lt;/code&gt; instance would look like</source>
          <target state="translated">派生した &lt;code&gt;HasRing&lt;/code&gt; インスタンスは次のようになります</target>
        </trans-unit>
        <trans-unit id="4744374c6426f29a0ece90c5038f8bb5efa3725d" translate="yes" xml:space="preserve">
          <source>The derived instance in GHC is equivalent to</source>
          <target state="translated">GHCでの派生インスタンスは</target>
        </trans-unit>
        <trans-unit id="2aa9649e650abb1ccfd00ab90d331d7948d62cc4" translate="yes" xml:space="preserve">
          <source>The derived instance is obtained by completing the application of the class to the new type:</source>
          <target state="translated">派生インスタンスは、新しい型へのクラスの適用を完了することで取得されます。</target>
        </trans-unit>
        <trans-unit id="75901f130a621087c5df4e3c7ff2bcd908627e72" translate="yes" xml:space="preserve">
          <source>The design also relies on &lt;code&gt;Danger&lt;/code&gt; not being able to access the &lt;code&gt;UnsafeRIO&lt;/code&gt; constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</source>
          <target state="translated">この設計は、 &lt;code&gt;Danger&lt;/code&gt; が &lt;code&gt;UnsafeRIO&lt;/code&gt; コンストラクターにアクセスできないことにも依存しています。残念ながら、テンプレートハスケルはモジュールの境界を破壊するために使用できるため、このコンストラクタへのアクセスに使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="49cc72101ca9237972311dd03a0fd606151e4195" translate="yes" xml:space="preserve">
          <source>The design attempts to restrict the operations that &lt;code&gt;Danger&lt;/code&gt; can perform by using types, specifically the &lt;code&gt;RIO&lt;/code&gt; type wrapper around &lt;code&gt;IO&lt;/code&gt; . The author of &lt;code&gt;Danger&lt;/code&gt; can subvert this though by simply writing arbitrary &lt;code&gt;IO&lt;/code&gt; actions and using &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; to execute them as pure functions.</source>
          <target state="translated">この設計では、型、特に &lt;code&gt;IO&lt;/code&gt; の &lt;code&gt;RIO&lt;/code&gt; タイプラッパーを使用して、 &lt;code&gt;Danger&lt;/code&gt; が実行できる操作を制限しようとしています。 &lt;code&gt;Danger&lt;/code&gt; の作者は、任意の &lt;code&gt;IO&lt;/code&gt; アクションを作成し、 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; を使用してそれらを純粋な関数として実行することで、これを覆すことができます。</target>
        </trans-unit>
        <trans-unit id="cd2da32dc935177290030f66437b8442e648de85" translate="yes" xml:space="preserve">
          <source>The design follows the following principles</source>
          <target state="translated">設計は以下の原則に従います。</target>
        </trans-unit>
        <trans-unit id="8290c7ce1697900c8e40df8ad0fc8ee4040a8ead" translate="yes" xml:space="preserve">
          <source>The design of Safe Haskell covers the following aspects:</source>
          <target state="translated">Safe Haskellの設計では、以下の点をカバーしています。</target>
        </trans-unit>
        <trans-unit id="db9668c7f3a96172360c5f50287354a3f36ed64a" translate="yes" xml:space="preserve">
          <source>The design of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid is optimized such that</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; モノイドの設計は、</target>
        </trans-unit>
        <trans-unit id="d69ade52bf3d6bc1c9e9d54294cef3da66243040" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">このコンビネータの設計をすることを目的に導かれた &lt;code&gt;timeout n f&lt;/code&gt; 正確に同じように振る舞うべき &lt;code&gt;f&lt;/code&gt; 限りとして、 &lt;code&gt;f&lt;/code&gt; はタイムアウトしません。これは、 &lt;code&gt;f&lt;/code&gt; に、タイムアウトラッパーがない場合と同じ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; があることを意味します。例外 &lt;code&gt;f&lt;/code&gt; がスローされると、タイムアウトがキャンセルされ、さらに上に伝播する場合があります。また、 &lt;code&gt;f&lt;/code&gt; は別のスレッドからスローされた例外を受け取ることもできます。</target>
        </trans-unit>
        <trans-unit id="8a12fd0294a8f0c5a36accd7b8d8d788bbce4f21" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">このコンビネータの設計をすることを目的に導かれた &lt;code&gt;timeout n f&lt;/code&gt; 正確に同じように振る舞うべき &lt;code&gt;f&lt;/code&gt; 限りとして、 &lt;code&gt;f&lt;/code&gt; はタイムアウトしません。これは、 &lt;code&gt;f&lt;/code&gt; がタイムアウトラッパーなしの場合と同じ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; を持っていることを意味します。すべての例外の &lt;code&gt;f&lt;/code&gt; はタイムアウトをキャンセルし、さらにアップを伝播投げるかもしれません。 &lt;code&gt;f&lt;/code&gt; が別のスレッドによってスローされた例外を受け取ることも可能です。</target>
        </trans-unit>
        <trans-unit id="ddf2c08a7e7a13b99ab3673124ddb5f1ed0a8e6e" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">このコンビネータの設計をすることを目的に導かれた &lt;code&gt;timeout n f&lt;/code&gt; 正確に同じように振る舞うべき &lt;code&gt;f&lt;/code&gt; 限りとして、 &lt;code&gt;f&lt;/code&gt; はタイムアウトしません。これは、 &lt;code&gt;f&lt;/code&gt; に、タイムアウトラッパーがない場合と同じ &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; があることを意味します。例外 &lt;code&gt;f&lt;/code&gt; がスローされると、タイムアウトがキャンセルされ、さらに上に伝播する場合があります。また、 &lt;code&gt;f&lt;/code&gt; は別のスレッドからスローされた例外を受け取ることもできます。</target>
        </trans-unit>
        <trans-unit id="069d6b594d5ec9b69dd4d93d8ec6094f3feb0544" translate="yes" xml:space="preserve">
          <source>The details of how to create the process are passed in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; record. To make it easier to construct a &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt;, the functions &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are supplied that fill in the fields with default values which can be overriden as needed.</source>
          <target state="translated">プロセスの作成方法の詳細は、 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; レコードで渡されます。 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; の構築を簡単にするために、必要に応じてオーバーライドできるデフォルト値をフィールドに入力する関数 &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; が提供されています。</target>
        </trans-unit>
        <trans-unit id="4faba3c52f5f6f8ccfc588aad8cbbfccac6eb185" translate="yes" xml:space="preserve">
          <source>The detection of CUSKs is enabled by the &lt;a href=&quot;#extension-CUSKs&quot;&gt;&lt;code&gt;CUSKs&lt;/code&gt;&lt;/a&gt; flag, which is switched on by default. This extension is scheduled for deprecation to be replaced with &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt;&lt;code&gt;StandaloneKindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CUSKの検出は、デフォルトでオンになっている&lt;a href=&quot;#extension-CUSKs&quot;&gt; &lt;code&gt;CUSKs&lt;/code&gt; &lt;/a&gt;フラグによって有効になります。この拡張機能は、非推奨が&lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt; &lt;code&gt;StandaloneKindSignatures&lt;/code&gt; &lt;/a&gt;に置き換えられる予定です。</target>
        </trans-unit>
        <trans-unit id="ed02330a1fbdda98a3ba7bccd58b777f6e21c2c1" translate="yes" xml:space="preserve">
          <source>The developer knows that a monad transformer takes a monad &lt;code&gt;m&lt;/code&gt; into a new monad &lt;code&gt;t m&lt;/code&gt;. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</source>
          <target state="translated">開発者は、モナド変換器がモナド &lt;code&gt;m&lt;/code&gt; を新しいモナド &lt;code&gt;t m&lt;/code&gt; 変換することを知っています。ただし、このプロパティは上記の宣言では正式に指定されていません。この省略は、モナド変換器の構成を定義するときに問題になります。</target>
        </trans-unit>
        <trans-unit id="baaf6bdd8fde5eba43c6847cbbb88e9af95ebd7b" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is that this one determines if a function definition will be inlined &lt;em&gt;at a call site&lt;/em&gt;. The other option determines if a function definition will be kept around at all for potential inlining.</source>
          <target state="translated">これと&lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt;は、関数定義が&lt;em&gt;呼び出しサイトで&lt;/em&gt;インライン化されるかどうかを決定することです。もう1つのオプションは、潜在的なインライン化のために関数定義を保持するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="7ce598ae08dc7d0d31f3dc6c209cf1408d599371" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for recovery is that in &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; the handler is inside an implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (see &quot;Asynchronous Exceptions&quot;) which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; by tail-calling rather than returning from the handler, which is why we recommend using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for ordinary exception recovery.</source>
          <target state="translated">リカバリーに &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; を使用する場合の違いは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ではハンドラーが暗黙の &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; （「非同期例外」を参照）内にあることです。これは非同期例外をキャッチするときに重要ですが、他の種類の例外をキャッチするときは不要です。さらに、ハンドラーから戻るのではなく、末尾呼び出しによって暗黙の &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内に誤って留まる可能性があります。そのため、通常の例外の回復には、 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ではなく &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; の使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="7baf36ea1c4b3f790ba00b9fa8c653d9d8edc0dc" translate="yes" xml:space="preserve">
          <source>The difference involves the placement of the last type parameter, &lt;code&gt;a&lt;/code&gt;. In the &lt;code&gt;Right&lt;/code&gt; case, &lt;code&gt;a&lt;/code&gt; occurs within the type &lt;code&gt;Either Int a&lt;/code&gt;, and moreover, it appears as the last type argument of &lt;code&gt;Either&lt;/code&gt;. In the &lt;code&gt;Wrong&lt;/code&gt; case, however, &lt;code&gt;a&lt;/code&gt; is not the last type argument to &lt;code&gt;Either&lt;/code&gt;; rather, &lt;code&gt;Int&lt;/code&gt; is.</source>
          <target state="translated">違いは、最後の型パラメーター &lt;code&gt;a&lt;/code&gt; の配置です。で &lt;code&gt;Right&lt;/code&gt; 場合、タイプ内で起こる &lt;code&gt;Either Int a&lt;/code&gt; 、しかも、それが最後の型引数として表示されます &lt;code&gt;Either&lt;/code&gt; 。 &lt;code&gt;Wrong&lt;/code&gt; 場合、ただし、最後型引数はない &lt;code&gt;Either&lt;/code&gt; 。むしろ、 &lt;code&gt;Int&lt;/code&gt; です。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b237dd43561a7048051c81d4534c2c8653cc063" translate="yes" xml:space="preserve">
          <source>The directory returned is expected to be writable by the current user, but note that it isn't generally considered good practice to store application-specific data here; use &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">返されるディレクトリは、現在のユーザーが書き込み可能であることが期待されていますが、アプリケーション固有のデータをここに格納することは、一般的には良い方法とは見なされないことに注意してください。代わりに &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="d678522b8fbe1bfba9bfaea6f20349fc6c790192" translate="yes" xml:space="preserve">
          <source>The do-notation of Haskell 98 does not allow &lt;em&gt;recursive bindings&lt;/em&gt;, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</source>
          <target state="translated">Haskell 98のdo表記では、&lt;em&gt;再帰的なバインディング&lt;/em&gt;は許可されていません。つまり、do式にバインドされた変数は、テキストの後に続くコードブロックでのみ表示されます。これを、バインドされた変数がバインディンググループ全体に表示されるlet式と比較してください。</target>
        </trans-unit>
        <trans-unit id="ed0761a6931cceb4a4d7abb1349cfebd091b9cae" translate="yes" xml:space="preserve">
          <source>The document type</source>
          <target state="translated">ドキュメントタイプ</target>
        </trans-unit>
        <trans-unit id="b44ad1035675a222470b757eea4beb20cf50c47b" translate="yes" xml:space="preserve">
          <source>The document.</source>
          <target state="translated">ドキュメントです。</target>
        </trans-unit>
        <trans-unit id="f1cdc66d16588511d035499d8789d0de0a61455f" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">ここのドキュメントは、GHCでのテンプレートHaskellの実現について説明しています。テンプレートHaskellを理解するのに十分詳細ではありません。&lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wikiページを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5d161d8e5801d84e4bc6cb6d1ba3399418931f1f" translate="yes" xml:space="preserve">
          <source>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a &lt;code&gt;deriving&lt;/code&gt; clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</source>
          <target state="translated">欠点は、ボイラープレートコードのタイプチェックに失敗した場合、そのコードに関するエラーメッセージが表示されますが、これはユーザーが作成したものではありません。一方、 &lt;code&gt;deriving&lt;/code&gt; 句を使用すると、サイドコンディションはより保守的になりますが、エラーメッセージはよりわかりやすくなります。</target>
        </trans-unit>
        <trans-unit id="0d40a85296a889e2235c05d3e594413e6271c9b0" translate="yes" xml:space="preserve">
          <source>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the &lt;code&gt;-threaded&lt;/code&gt; option (to link against the multithreaded version of the runtime), a thread making a &lt;code&gt;safe&lt;/code&gt; foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these &lt;em&gt;worker&lt;/em&gt; threads so that multiple Haskell threads can be involved in external calls simultaneously.</source>
          <target state="translated">軽量スレッドの欠点は、一度に1つしか実行できないため、たとえば、あるスレッドが外部呼び出しでブロックされた場合、他のスレッドは続行できないということです。 GHCランタイムは、必要に応じて完全なOSスレッドを利用することにより、この問題を回避します。プログラムが &lt;code&gt;-threaded&lt;/code&gt; オプション（ランタイムのマルチスレッドバージョンに対してリンクする）を使用してビルドされている場合、 &lt;code&gt;safe&lt;/code&gt; 外部呼び出しを行うスレッドは、システム内の他のスレッドをブロックしません。元の呼び出しが戻るまで、別のOSスレッドが実行中のHaskellスレッドを引き継ぎます。ランタイムはこれらの&lt;em&gt;ワーカー&lt;/em&gt;スレッドのプールを維持するため、複数のHaskellスレッドが同時に外部呼び出しに関与できます。</target>
        </trans-unit>
        <trans-unit id="7e1ca2d2eeb59a37201caba0870b3b617ae2b6e7" translate="yes" xml:space="preserve">
          <source>The drag stage, which lasts from the final use until the last reference to the object is dropped.</source>
          <target state="translated">最後に使用してから、オブジェクトへの最後の参照が落とされるまで続くドラッグステージ。</target>
        </trans-unit>
        <trans-unit id="5112337835e0aaa1f4501d77e936abde1e9f5833" translate="yes" xml:space="preserve">
          <source>The dual of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, obtained by swapping the arguments of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; の双対 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の引数を交換することによって取得されます。</target>
        </trans-unit>
        <trans-unit id="7fab6e06621905edcea476fea0795c21d73fe816" translate="yes" xml:space="preserve">
          <source>The dynamic binding constraints are just a new form of predicate in the type class system.</source>
          <target state="translated">動的結合制約は、型クラスシステムにおける新しい形の述語にすぎません。</target>
        </trans-unit>
        <trans-unit id="c9658faad340c4e37684884e4b4de1d55529e10f" translate="yes" xml:space="preserve">
          <source>The easiest way to see what &lt;code&gt;-O&lt;/code&gt; (etc.) &amp;ldquo;really mean&amp;rdquo; is to run with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, then stand back in amazement.</source>
          <target state="translated">&lt;code&gt;-O&lt;/code&gt; （など）が「本当に」意味することを確認する最も簡単な方法は、&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;を指定して実行し、驚いて立ち戻ることです。</target>
        </trans-unit>
        <trans-unit id="9d5eb6a79829c0b2ad6433410a38b38fee844c58" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac8593ee22b444a0803d2615c08c3ad783eddab" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空の &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffb10a0d9ca8c58bdee511053f10bf4fc11e9fd3" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">高さと幅のない空のドキュメント。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; 、hcat、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; などの引数リストの任意の場所です。</target>
        </trans-unit>
        <trans-unit id="c38333a804d1c05d76e22c031e0de30532f2b0b2" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">高さと幅のない空のドキュメント。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; 、hcat、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; などの引数リストの任意の場所です。</target>
        </trans-unit>
        <trans-unit id="57055327e0a4ff0414ff005dc9f2d958097b63a1" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">高さと幅のない空のドキュメント。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; 、hcat、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; などの引数リストの任意の場所です。</target>
        </trans-unit>
        <trans-unit id="322d102fb89074ac997d55fe8155256f83635242" translate="yes" xml:space="preserve">
          <source>The empty stream.</source>
          <target state="translated">空の流れ。</target>
        </trans-unit>
        <trans-unit id="aaade1a4c344a06009213d97ea6d90338497c9b0" translate="yes" xml:space="preserve">
          <source>The entire string prior to the &lt;em&gt;k&lt;/em&gt;th match (i.e. the prefix)</source>
          <target state="translated">&lt;em&gt;k&lt;/em&gt;番目に一致する前の文字列全体（つまり、プレフィックス）</target>
        </trans-unit>
        <trans-unit id="7e6880e4680eabaf9b865ccc3e11f4776c77ad73" translate="yes" xml:space="preserve">
          <source>The environment variable can also be set to the magical values &lt;code&gt;never&lt;/code&gt; or &lt;code&gt;always&lt;/code&gt;, which is equivalent to setting the corresponding &lt;code&gt;-fdiagnostics-color&lt;/code&gt; flag but with lower precedence.</source>
          <target state="translated">環境変数は、魔法の値 &lt;code&gt;never&lt;/code&gt; または &lt;code&gt;always&lt;/code&gt; に設定することもできます。これは、対応する &lt;code&gt;-fdiagnostics-color&lt;/code&gt; フラグを設定することと同等ですが、優先順位は低くなります。</target>
        </trans-unit>
        <trans-unit id="e95be2fe9b83d12508c00e4a3f425f900f860572" translate="yes" xml:space="preserve">
          <source>The environment variable name/value pairs. (TODO: encoding?)</source>
          <target state="translated">環境変数名/値のペア。(TODO:エンコード?)</target>
        </trans-unit>
        <trans-unit id="a78af08f35ea577d78dded305fcc5c4e9509b316" translate="yes" xml:space="preserve">
          <source>The epoch of TAI, which is 1858-11-17 00:00:00 TAI.</source>
          <target state="translated">1858-11-17 00:00:00 TAIのエポック。</target>
        </trans-unit>
        <trans-unit id="81943c20c210a66a07a8f11e6429a84649f3e7b2" translate="yes" xml:space="preserve">
          <source>The equality test in an overloaded numeric pattern uses whatever &lt;code&gt;(==)&lt;/code&gt; is in scope.</source>
          <target state="translated">オーバーロードされた数値パターンの等価テストでは、スコープ内にあるもの &lt;code&gt;(==)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="afd1105a178de8acf9d4f7264289cbff2eca2561" translate="yes" xml:space="preserve">
          <source>The equality types</source>
          <target state="translated">等価タイプ</target>
        </trans-unit>
        <trans-unit id="c36adceaaf4799a94ea7ebf3aee8bed0bb6f61c1" translate="yes" xml:space="preserve">
          <source>The equations are numbered starting from 0, and the comment after each equation refers to all preceding equations it is incompatible with.</source>
          <target state="translated">方程式には0から始まる番号が付けられており、各方程式の後のコメントは、それが互換性のない先行方程式をすべて参照しています。</target>
        </trans-unit>
        <trans-unit id="1199dfc965e5955380e63499fadc65f9cbd20ac3" translate="yes" xml:space="preserve">
          <source>The equivalent REPL example is:</source>
          <target state="translated">これに相当するREPLの例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7d39f7dfb145cb81010fc146adcc072a6753c454" translate="yes" xml:space="preserve">
          <source>The error message contains some clues as to the transformation happening internally.</source>
          <target state="translated">エラーメッセージには、内部で発生している変換に関するいくつかの手がかりが含まれています。</target>
        </trans-unit>
        <trans-unit id="59e467fc1987c039f09f1829c27318997a022a9d" translate="yes" xml:space="preserve">
          <source>The error monad transformer. It can be used to add error handling to other monads.</source>
          <target state="translated">エラーモナドの変換器です。他のモナドにエラー処理を追加するために使用できます。</target>
        </trans-unit>
        <trans-unit id="584676bca032e15cb39d4d01b07dc527b1765a4e" translate="yes" xml:space="preserve">
          <source>The errors that can be deferred are:</source>
          <target state="translated">延期できるエラーは</target>
        </trans-unit>
        <trans-unit id="53caa6a4eadedbc6b469bff64565461d1ccdfebf" translate="yes" xml:space="preserve">
          <source>The event manager state.</source>
          <target state="translated">イベントマネージャー状態。</target>
        </trans-unit>
        <trans-unit id="2743b97e9374251f3952bb86a616a8b6b2d9cbac" translate="yes" xml:space="preserve">
          <source>The event-log stream begins with a header describing the event types present in the file. The header is followed by the event records themselves, each of which consist of a 64-bit timestamp</source>
          <target state="translated">イベントログストリームは、ファイル内に存在するイベントタイプを記述するヘッダで始まる。ヘッダの後にイベントレコードが続き、それぞれのイベントレコードは64ビットのタイムスタンプ</target>
        </trans-unit>
        <trans-unit id="5f9ab52fbe55b01321892b7fd29ab1a98bb7681d" translate="yes" xml:space="preserve">
          <source>The example below shows quasi-quotation in action. The quoter &lt;code&gt;expr&lt;/code&gt; is bound to a value of type &lt;code&gt;QuasiQuoter&lt;/code&gt; defined in module &lt;code&gt;Expr&lt;/code&gt;. The example makes use of an antiquoted variable &lt;code&gt;n&lt;/code&gt;, indicated by the syntax &lt;code&gt;'int:n&lt;/code&gt; (this syntax for anti-quotation was defined by the parser&amp;rsquo;s author, &lt;em&gt;not&lt;/em&gt; by GHC). This binds &lt;code&gt;n&lt;/code&gt; to the integer value argument of the constructor &lt;code&gt;IntExpr&lt;/code&gt; when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type &lt;code&gt;String -&amp;gt; a&lt;/code&gt; to generate both an expression parser that returns a value of type &lt;code&gt;Q Exp&lt;/code&gt; and a pattern parser that returns a value of type &lt;code&gt;Q Pat&lt;/code&gt;.</source>
          <target state="translated">以下の例は、実際の準見積を示しています。クォータ &lt;code&gt;expr&lt;/code&gt; の型の値にバインドされ &lt;code&gt;QuasiQuoter&lt;/code&gt; はモジュールで定義された &lt;code&gt;Expr&lt;/code&gt; に。この例では、引用符で囲まれて&lt;em&gt;いない&lt;/em&gt;変数 &lt;code&gt;n&lt;/code&gt; を使用します。これは、構文 &lt;code&gt;'int:n&lt;/code&gt; （引用符を引用しないこの構文&lt;em&gt;は&lt;/em&gt;、GHC では&lt;em&gt;なく&lt;/em&gt;パーサーの作成者が定義したものです）によって&lt;em&gt;示さ&lt;/em&gt;れます。これは、パターンマッチング時に &lt;code&gt;n&lt;/code&gt; をコンストラクタ &lt;code&gt;IntExpr&lt;/code&gt; の整数値引数にバインドします。引用防止に関する詳細、およびSYBを使用して &lt;code&gt;String -&amp;gt; a&lt;/code&gt; 型の単一のパーサーを利用する手法の説明については、参考文献を参照してください-&amp;gt; aタイプ &lt;code&gt;Q Exp&lt;/code&gt; の値を返す式パーサーとタイプ &lt;code&gt;Q Pat&lt;/code&gt; の値を返すパターンパーサーの両方を生成します。</target>
        </trans-unit>
        <trans-unit id="e130d4a858cd5958b963d63c7fe21940f766b4ef" translate="yes" xml:space="preserve">
          <source>The exception itself is bound to a new variable, &lt;code&gt;_exception&lt;/code&gt;.</source>
          <target state="translated">例外自体は、新しい変数 &lt;code&gt;_exception&lt;/code&gt; にバインドされています。</target>
        </trans-unit>
        <trans-unit id="988d36edf500c18480e248b3ba03ea83da4d2cbf" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">実行されたアクションの例外マスキング状態は継承されます（ &lt;code&gt;forkIO&lt;/code&gt; を参照） &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; も参照してください（&lt;em&gt;以降：2.7.0.0&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc8f732aa9ca323261d4591444f25b148d16268f" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">実行されたアクションの例外マスキング状態は継承されます（ &lt;code&gt;forkIO&lt;/code&gt; を参照） &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; も参照してください（&lt;em&gt;以降：2.7.0.0&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ebf03146e8f23e21eb8275358c982d6013264e4c" translate="yes" xml:space="preserve">
          <source>The exception thrown by &quot;fail&quot; in the GHCiQ monad</source>
          <target state="translated">GHCiQモナドの &quot;fail &quot;でスローされる例外</target>
        </trans-unit>
        <trans-unit id="ceefa01748ad0dcbb4f9adc6b0c343de52816f7c" translate="yes" xml:space="preserve">
          <source>The exception thrown when an infinite cycle is detected in &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; で無限サイクルが検出されたときにスローされる例外。</target>
        </trans-unit>
        <trans-unit id="e73e797f0aaf19c29e3a38b80b61adffd05c8530" translate="yes" xml:space="preserve">
          <source>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</source>
          <target state="translated">この規則の例外は、スタンドアロン導出宣言のコンテキストは、例えば in のように単一のエキストラワイルドカード制約がコンテキストとして使用されている場合に、そのコンテキストを推論することができます。</target>
        </trans-unit>
        <trans-unit id="2a9b0765cdd57857b495fa1668f0cbcf42055c10" translate="yes" xml:space="preserve">
          <source>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</source>
          <target state="translated">以前に停止したポイントで実行が継続され、現在は2回目のブレークポイントで停止しています。</target>
        </trans-unit>
        <trans-unit id="11953fb00b8ad70bb93132200530ed5421e8c22b" translate="yes" xml:space="preserve">
          <source>The exit status of a process</source>
          <target state="translated">プロセスの終了ステータス</target>
        </trans-unit>
        <trans-unit id="927dcdbea9e7b5ba6ac39897b83ff1c61f46b2d3" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</source>
          <target state="translated">展開は純粋に構文的なものなので、展開された右辺の式は、フィールド名と同じスペルの最も近い囲み変数を参照します。</target>
        </trans-unit>
        <trans-unit id="0bb43782d3d91d6c0cfe9ab486e0facf443af806" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</source>
          <target state="translated">展開は純粋に構文的なものなので、レコードのワイルドカード式は、省略されたフィールド名と同じスペルの最も近い囲み変数を参照します。</target>
        </trans-unit>
        <trans-unit id="6fa2123bab4a96fc3dff4e1405c75b76df70f413" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(x `par` y)&lt;/code&gt;&lt;em&gt;sparks&lt;/em&gt; the evaluation of &lt;code&gt;x&lt;/code&gt; (to weak head normal form) and returns &lt;code&gt;y&lt;/code&gt;. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</source>
          <target state="translated">式 &lt;code&gt;(x `par` y)&lt;/code&gt; &lt;em&gt;火花&lt;/em&gt;の評価 &lt;code&gt;x&lt;/code&gt; （弱頭部正規形に）戻ると &lt;code&gt;y&lt;/code&gt; 。スパークはFIFO順に実行するためにキューに入れられますが、すぐには実行されません。ランタイムがアイドルCPUがあることを検出すると、スパークを実際のスレッドに変換し、アイドルCPUで新しいスレッドを実行します。このようにして、利用可能な並列処理が実際のCPUに分散されます。</target>
        </trans-unit>
        <trans-unit id="60035052d2f9f9dbcb2234d0c35b5862aef3671d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; results in the following lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; は、次の遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="5ec7656c8e0e128b3c718fea844b6924e7c9db92" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">式 &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; で構成される新しい順列パーサーを作成します。置換パーサーの最終結果は、 &lt;code&gt;p&lt;/code&gt; の戻り値に適用される関数 &lt;code&gt;f&lt;/code&gt; です。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。</target>
        </trans-unit>
        <trans-unit id="688562a46f3c26c92c14ba3e2ae41abc13cf015e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">式 &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; で構成される新しい順列パーサーを作成します。置換パーサーの最終結果は、 &lt;code&gt;p&lt;/code&gt; の戻り値に適用される関数 &lt;code&gt;f&lt;/code&gt; です。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。</target>
        </trans-unit>
        <trans-unit id="133ce73b1396f38f1c484e835e97b17e44814c41" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead.</source>
          <target state="translated">式 &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; で構成される新しい順列パーサーを作成します。順列パーサーの最終結果は、 &lt;code&gt;p&lt;/code&gt; の戻り値に適用される関数 &lt;code&gt;f&lt;/code&gt; です。パーサー &lt;code&gt;p&lt;/code&gt; はオプションです。適用できない場合は、代わりにデフォルト値 &lt;code&gt;x&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="8fb79b3e4e6a014a406705b86fa9c5b9e188c8b4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">式 &lt;code&gt;makeTokenParser language&lt;/code&gt; は、 &lt;code&gt;language&lt;/code&gt; レコードの定義を使用して定義された字句パーサーを含む &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; レコードを作成します。</target>
        </trans-unit>
        <trans-unit id="d2c369052f3c05736ed3d0aa835e5b9167fa8ef9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">式 &lt;code&gt;makeTokenParser language&lt;/code&gt; は、 &lt;code&gt;language&lt;/code&gt; レコードの定義を使用して定義された字句パーサーを含む &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; レコードを作成します。</target>
        </trans-unit>
        <trans-unit id="8b086207ac432a47ad80161d4b4db423c87b1bcf" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;parseTest p input&lt;/code&gt; applies a parser &lt;code&gt;p&lt;/code&gt; against input &lt;code&gt;input&lt;/code&gt; and prints the result to stdout. Used for testing parsers.</source>
          <target state="translated">式 &lt;code&gt;parseTest p input&lt;/code&gt; パーサ適用 &lt;code&gt;p&lt;/code&gt; 入力に対する &lt;code&gt;input&lt;/code&gt; と標準出力に結果を出力します。パーサーのテストに使用されます。</target>
        </trans-unit>
        <trans-unit id="7d09630aef55bc10a1cc5f993e20aa9d2c8fa633" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead. Returns a new permutation parser that includes the optional parser &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; を置換パーサー &lt;code&gt;perm&lt;/code&gt; に追加します。パーサー &lt;code&gt;p&lt;/code&gt; はオプションです。適用できない場合は、代わりにデフォルト値 &lt;code&gt;x&lt;/code&gt; が使用されます。オプションのパーサー &lt;code&gt;p&lt;/code&gt; を含む新しい順列パーサーを返します。</target>
        </trans-unit>
        <trans-unit id="9774c66620e8ebb6dc4947bd7a30ad32d4083961" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; を置換パーサー &lt;code&gt;perm&lt;/code&gt; に追加します。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。 &lt;code&gt;p&lt;/code&gt; を含む新しい置換パーサーを返します。</target>
        </trans-unit>
        <trans-unit id="c1eff7acfdc904aa55b95ecd8fd5d523b792b889" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; は、パーサー &lt;code&gt;p&lt;/code&gt; を置換パーサー &lt;code&gt;perm&lt;/code&gt; に追加します。パーサー &lt;code&gt;p&lt;/code&gt; は空の入力を受け入れることができません- 代わりにオプションのコンビネーター（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）を使用してください。 &lt;code&gt;p&lt;/code&gt; を含む新しい置換パーサーを返します。</target>
        </trans-unit>
        <trans-unit id="5b91ada54b3ba346f8466cd7a2f1f8bea7674bcd" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;s (t xs)&lt;/code&gt; does not match the rule &lt;code&gt;&quot;map/map&quot;&lt;/code&gt;, but GHC will substitute for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, giving an expression which does match. If &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</source>
          <target state="translated">式 &lt;code&gt;s (t xs)&lt;/code&gt; はルール &lt;code&gt;&quot;map/map&quot;&lt;/code&gt; と一致しませんが、GHCは &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;t&lt;/code&gt; を置き換え、一致する式を提供します。場合は &lt;code&gt;s&lt;/code&gt; または &lt;code&gt;t&lt;/code&gt; （）複数回使用、及び（b）は、大規模または可約式た、それは置換されていない、および規則は火ではないであろう。</target>
        </trans-unit>
        <trans-unit id="efeb52340545b81120b442152fbbc21924dfa6d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;updatePosString pos s&lt;/code&gt; は、 &lt;code&gt;s&lt;/code&gt; のすべての文字で &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、ソース位置 &lt;code&gt;pos&lt;/code&gt; を更新します。 &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46b242264f8f265b934b320d1ad118b5d5d70f9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;updatePosString pos s&lt;/code&gt; は、 &lt;code&gt;s&lt;/code&gt; のすべての文字で &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; を呼び出すことにより、ソース位置 &lt;code&gt;pos&lt;/code&gt; を更新します。 &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5483b1f876b299153ecdf0ce5e6d8239b22dcf61" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;. Its value (literal or negated literal) will be output.</source>
          <target state="translated">式は &lt;code&gt;long&lt;/code&gt; または &lt;code&gt;unsigned long&lt;/code&gt; に変換可能でなければなりません。その値（リテラルまたは否定されたリテラル）が出力されます。</target>
        </trans-unit>
        <trans-unit id="820e3f9e6884aadccb720549e1d4a6de8381de85" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to const char pointer. Its value (string literal) will be output.</source>
          <target state="translated">式は const char ポインタに変換可能でなければなりません。その値(文字列リテラル)が出力されます。</target>
        </trans-unit>
        <trans-unit id="0a5b6e32463e5a84d94f6198a0b148bf41758e64" translate="yes" xml:space="preserve">
          <source>The expression you are annotating with must have a type with &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances</source>
          <target state="translated">注釈を付ける式には、 &lt;code&gt;Typeable&lt;/code&gt; および &lt;code&gt;Data&lt;/code&gt; インスタンスを持つ型が必要です</target>
        </trans-unit>
        <trans-unit id="6a2b1973077b8ad117174952fdf79b72f3549905" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;および（何らかの理由で）&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;によって暗黙的に指定されます。</target>
        </trans-unit>
        <trans-unit id="c2c1dd16b1be083ccd27c6c41c6082833199d042" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;NoMonoLocalBinds&lt;/code&gt;&lt;/a&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;によって暗示されます。&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; を使用&lt;/a&gt;して再度オフにすることができますが、そうすると、型推論の予測が難しくなります。 （論文を読んでください！）</target>
        </trans-unit>
        <trans-unit id="56045ff1bf81ad580973e6c5e5797cb6699258d1" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;によって暗示されています。 &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; を使用して再度オフにすることができますが、そうすると、型の推論の予測が難しくなります。（論文を読んでください！）</target>
        </trans-unit>
        <trans-unit id="6edfbf43884f0659ca2c3eed2dacc284530ca4be" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt;&lt;code&gt;QuantifiedConstraints&lt;/code&gt;&lt;/a&gt; introduces &lt;strong&gt;quantified constraints&lt;/strong&gt;, which give a new level of expressiveness in constraints. For example, consider</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt; &lt;code&gt;QuantifiedConstraints&lt;/code&gt; は、数量化&lt;/a&gt;さ&lt;strong&gt;れた制約を&lt;/strong&gt;導入します。これ&lt;strong&gt;により&lt;/strong&gt;、&lt;strong&gt;制約&lt;/strong&gt;に新しいレベルの表現力が与えられます。たとえば、</target>
        </trans-unit>
        <trans-unit id="5a1fbd6833d7bf7f6b464ba5557bf0f418ef8516" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; also introduces a new keyword &lt;code&gt;rec&lt;/code&gt;, which wraps a mutually-recursive group of monadic statements inside a &lt;code&gt;do&lt;/code&gt; expression, producing a single statement. Similar to a &lt;code&gt;let&lt;/code&gt; statement inside a &lt;code&gt;do&lt;/code&gt;, variables bound in the &lt;code&gt;rec&lt;/code&gt; are visible throughout the &lt;code&gt;rec&lt;/code&gt; group, and below it. For example, compare</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;には、新しいキーワード &lt;code&gt;rec&lt;/code&gt; も導入されています。これは、相互再帰的なモナディックステートメントのグループを &lt;code&gt;do&lt;/code&gt; 式内にラップして、単一のステートメントを生成します。 &lt;code&gt;do&lt;/code&gt; 内の &lt;code&gt;let&lt;/code&gt; ステートメントと同様に、 &lt;code&gt;rec&lt;/code&gt; にバインドされた変数は、 &lt;code&gt;rec&lt;/code&gt; グループ全体とその下に表示されます。たとえば、比較</target>
        </trans-unit>
        <trans-unit id="2340bd5004afb06c66885f9f37fdc1ab908eab6d" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張&lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt;は非推奨になりました。その唯一の効果は、&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;（したがって&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;）と&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; をオンにすること&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5d7aee131ad6d19c93d8e0e5cef004d81b83103a" translate="yes" xml:space="preserve">
          <source>The extension adds a new kind of expression for defining arrows:</source>
          <target state="translated">この拡張機能では、矢印を定義するための新しい種類の式が追加されました。</target>
        </trans-unit>
        <trans-unit id="68fc04e40e72e9a26d6e832da587e68cf89dce71" translate="yes" xml:space="preserve">
          <source>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</source>
          <target state="translated">この拡張機能は関数定義の左側には適用されません。</target>
        </trans-unit>
        <trans-unit id="ad6ad2707106caf932a9bcc6bc55d2c587ffc598" translate="yes" xml:space="preserve">
          <source>The extension is enabled with the extension &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張は、拡張&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; で&lt;/a&gt;有効になります。</target>
        </trans-unit>
        <trans-unit id="592f0075b3be7dea40fca2f7b78b5f78b8bee1db" translate="yes" xml:space="preserve">
          <source>The extension only affects definitions in this module.</source>
          <target state="translated">この拡張機能は、このモジュール内の定義にのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="dbed722a20b0c81708629361d2e36ddb255e740e" translate="yes" xml:space="preserve">
          <source>The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur, rather than when the buffer is translated.</source>
          <target state="translated">できるだけ多くの要素が翻訳されているという事実は、バッファが翻訳されたときではなく、実際に発生した時点で翻訳エラーを報告するために IO ライブラリによって使用されます。</target>
        </trans-unit>
        <trans-unit id="c9688a61970d69ede4ef28783b4cdd7a6fa982ec" translate="yes" xml:space="preserve">
          <source>The field width is a minimum, not a maximum: it will be expanded as needed to avoid mutilating a value.</source>
          <target state="translated">フ ィ ール ド 幅は最小値であ り 、 最大値ではあ り ません。</target>
        </trans-unit>
        <trans-unit id="766dc6dc2e472365cee52e53c97df5ee0cb680d9" translate="yes" xml:space="preserve">
          <source>The fields in &lt;code&gt;Trade&lt;/code&gt; are marked as strict (using &lt;code&gt;!&lt;/code&gt;) since we don't need laziness here. In practise, you would probably consider using the UNPACK pragma as well. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</source>
          <target state="translated">ここでは遅延を必要としないため、 &lt;code&gt;Trade&lt;/code&gt; のフィールドは（ &lt;code&gt;!&lt;/code&gt; を使用して）厳格としてマークされています。実際には、おそらくUNPACKプラグマの使用も検討するでしょう。&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972e4dbbb1da0195c707d37fda525d476ee44e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">分野 &lt;code&gt;ExampleConstructor&lt;/code&gt; は持って &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt; をそれぞれ。</target>
        </trans-unit>
        <trans-unit id="90aff6649fd9e503bb0cd5dab7faab1470bbcfc9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">分野 &lt;code&gt;ExampleConstructor&lt;/code&gt; は持って &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt; をそれぞれ。</target>
        </trans-unit>
        <trans-unit id="867052d71989ead15b5268bf62e49c7c19eae92d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;A.hs-boot&lt;/code&gt; is a programmer-written source file. It must live in the same directory as its parent source file &lt;code&gt;A.hs&lt;/code&gt;. Currently, if you use a literate source file &lt;code&gt;A.lhs&lt;/code&gt; you must also use a literate boot file, &lt;code&gt;A.lhs-boot&lt;/code&gt;; and vice versa.</source>
          <target state="translated">ファイル &lt;code&gt;A.hs-boot&lt;/code&gt; は、プログラマーが作成したソースファイルです。親ソースファイル &lt;code&gt;A.hs&lt;/code&gt; と同じディレクトリに存在する必要があります。現在、 &lt;code&gt;A.lhs&lt;/code&gt; なソースファイルA.lhsを使用する場合は、 &lt;code&gt;A.lhs-boot&lt;/code&gt; なブートファイルA.lhs-bootも使用する必要があります。およびその逆。</target>
        </trans-unit>
        <trans-unit id="9a674c835d28bfb6d72a5275286859913c1e00bf" translate="yes" xml:space="preserve">
          <source>The file contains package IDs and optionally package databases, one directive per line:</source>
          <target state="translated">このファイルには、パッケージ ID と、オプションでパッケージデータベースが含まれており、1 行に 1 つのディレクティブが含まれています。</target>
        </trans-unit>
        <trans-unit id="d3dad592ba2c56d2ff45ef3e10379f2cd7056cb1" translate="yes" xml:space="preserve">
          <source>The file descriptor is ready to accept a write.</source>
          <target state="translated">ファイルディスクリプタは書き込みを受け付ける準備ができています。</target>
        </trans-unit>
        <trans-unit id="0a87aafdf7c80c25cee8605761116960c822dc15" translate="yes" xml:space="preserve">
          <source>The file is created with permissions such that only the current user can read/write it.</source>
          <target state="translated">ファイルは、現在のユーザーのみが読み書きできるようなパーミッションで作成されています。</target>
        </trans-unit>
        <trans-unit id="cfb39651c9d8c9724affb75edf0166a16b2ab2da" translate="yes" xml:space="preserve">
          <source>The file-header pragmas are: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt;, &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt;, and &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt;.</source>
          <target state="translated">ファイルヘッダープラグマは、 &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt; 、 &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt; 、および &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6ce398b5e4e0b12caa271926c6711a527e411174" translate="yes" xml:space="preserve">
          <source>The final build step that returns the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 信号を返す最後のビルドステップ。</target>
        </trans-unit>
        <trans-unit id="87005632e427f20e49e6f8bedc0a39a36ece9f40" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="translated">最後の箇条書き(インスタンスの単一化について)では、重複するインスタンスにコミットすることについてGHCを保守的にしています。例えば</target>
        </trans-unit>
        <trans-unit id="1913f6cc3ff526a515670ed4f1b49aa9b4f8a2bf" translate="yes" xml:space="preserve">
          <source>The final form is just what we want: a simple case expression.</source>
          <target state="translated">最終的な形は、私たちが求めているもの、つまりシンプルな大文字小文字の表現です。</target>
        </trans-unit>
        <trans-unit id="f7d925c1be71fce63599be5c5644561348c21d6e" translate="yes" xml:space="preserve">
          <source>The final layout will be something like</source>
          <target state="translated">最終的なレイアウトは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="509bc33604e7ee8a244ab55cc215005d17244214" translate="yes" xml:space="preserve">
          <source>The finalizer is given the local type environment at the splice point. Thus &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; is able to find the local definitions when executed inside the finalizer.</source>
          <target state="translated">ファイナライザには、スプライスポイントでローカルタイプ環境が与えられます。したがって、ファイナライザ内で実行すると、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; はローカル定義を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="147a1899cc99c9241165663b9d1797441102fedd" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">ファイナライザ、およびキーと値の関係は、プログラムが &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; オブジェクトへの参照を保持するかどうかに関係なく存在します。</target>
        </trans-unit>
        <trans-unit id="d9f13e14cac52cb8d1ac6c69d4a111452644d3b2" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">ファイナライザ、およびキーと値の関係は、プログラムが &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; オブジェクトへの参照を保持するかどうかに関係なく存在します。</target>
        </trans-unit>
        <trans-unit id="deaaee000865e026093bdaeb2c9fc2020dfc3055" translate="yes" xml:space="preserve">
          <source>The fine distinction between different kinds of parse errors allows the system to generate quite good error messages for the user. It also allows error messages that are formatted in different languages. Each kind of message is generated by different combinators:</source>
          <target state="translated">異なる種類のパースエラーを細かく区別することで、システムはユーザーにとって非常に良いエラーメッセージを生成することができます。また、異なる言語でフォーマットされたエラーメッセージを生成することもできます。それぞれの種類のメッセージは、異なるコンビネータによって生成されます。</target>
        </trans-unit>
        <trans-unit id="c672354048c81f22453abece53dcb4410b87ec06" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">最初の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 引数は、カーソルの左側の行の内容を逆にしたものです。2番目の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 引数は、カーソルの右側の行の内容です。</target>
        </trans-unit>
        <trans-unit id="e20d358fcdcc868c8bd11a6755028db0bb2e37f3" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Int32&lt;/code&gt; is for the tag. There are two &lt;code&gt;Float32&lt;/code&gt; fields because floating point types can&amp;rsquo;t overlap with other types, because of limitations of the code generator that we&amp;rsquo;re hoping to overcome in the future. The second alternative needs two &lt;code&gt;Float32&lt;/code&gt; fields: The &lt;code&gt;Word32&lt;/code&gt; field is for the &lt;code&gt;Word32#&lt;/code&gt; in the first alternative. The &lt;code&gt;Pointer&lt;/code&gt; field is shared between &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Maybe Int&lt;/code&gt; values of the alternatives.</source>
          <target state="translated">最初の &lt;code&gt;Int32&lt;/code&gt; はタグ用です。浮動小数点型は他の型と重複できないため、2つの &lt;code&gt;Float32&lt;/code&gt; フィールドがあります。これは、将来克服したいコードジェネレーターの制限のためです。2番目の選択肢には2つの &lt;code&gt;Float32&lt;/code&gt; フィールドが必要です &lt;code&gt;Word32&lt;/code&gt; フィールドは、最初の選択肢の &lt;code&gt;Word32#&lt;/code&gt; 用です。 &lt;code&gt;Pointer&lt;/code&gt; フィールドが間で共有される &lt;code&gt;String&lt;/code&gt; と &lt;code&gt;Maybe Int&lt;/code&gt; 選択肢の値。</target>
        </trans-unit>
        <trans-unit id="349930f2f6ac001a1f1d9bc41ac40db08cbf14ec" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;(l,u)&lt;/code&gt; of each of these operations is a pair specifying the lower and upper bounds of a contiguous subrange of values.</source>
          <target state="translated">これらの各演算の最初の引数 &lt;code&gt;(l,u)&lt;/code&gt; は、値の連続する部分範囲の下限と上限を指定するペアです。</target>
        </trans-unit>
        <trans-unit id="da354ca0b85aa26c68bc2b60c29e2527cd434859" translate="yes" xml:space="preserve">
          <source>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC&amp;rsquo;s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that &lt;code&gt;k&lt;/code&gt; must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</source>
          <target state="translated">最初の箇条書きは、依存関係が適切にスコープされている必要があることを単に意味します。2番目の箇条書きは、依存性を推論するGHCの機能に関係しています。この依存関係を推測することは困難であり、GHCは現在、依存関係を明示的にする必要があります。つまり、 &lt;code&gt;k&lt;/code&gt; は型変数の種類に出現する必要があり、依存関係が意図されていることをGHCに明らかにします。例えば：</target>
        </trans-unit>
        <trans-unit id="5990c2111448ff95032208b84313c09eb4e8e7c7" translate="yes" xml:space="preserve">
          <source>The first clause of &amp;ldquo;compatible&amp;rdquo; is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</source>
          <target state="translated">「互換性」の最初の条項は、より簡単なものです。これは、2つの異なるタイプファミリーインスタンスのパターンは重複できないことを示しています。たとえば、以下は許可されていません。</target>
        </trans-unit>
        <trans-unit id="0d05ff555d4b0984db447de192b3bf9a34809e33" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">第一の成分 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 開区間（に位置するようにスケーリングされ、 &lt;code&gt;-1&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; のいずれか）、 &lt;code&gt;0.0&lt;/code&gt; または絶対値の &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 浮動小数点基数です。動作は、無限または &lt;code&gt;NaN&lt;/code&gt; 値では指定されていません。</target>
        </trans-unit>
        <trans-unit id="f4f7b2948c8c1ae005bcea73d45f0bbfbc9162d6" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">第一の成分 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 開区間（に位置するようにスケーリングされ、 &lt;code&gt;-1&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; のいずれか）、 &lt;code&gt;0.0&lt;/code&gt; または絶対値の &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 浮動小数点基数です。動作は、無限または &lt;code&gt;NaN&lt;/code&gt; 値では指定されていません。</target>
        </trans-unit>
        <trans-unit id="7a78b840c5ec7a8bd0522ac73f6d9db7e7f7c6e2" translate="yes" xml:space="preserve">
          <source>The first constructor consists of a single field, which is the parameter &lt;code&gt;a&lt;/code&gt;. This is represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt;.</source>
          <target state="translated">最初のコンストラクタは、パラメータ &lt;code&gt;a&lt;/code&gt; である単一のフィールドで構成されています。これは &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt; として表されます。</target>
        </trans-unit>
        <trans-unit id="a491a7e0c75f57c1c82c6779842a217b78376985" translate="yes" xml:space="preserve">
          <source>The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; up to and including the last match of &lt;code&gt;needle&lt;/code&gt;. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, following the match.</source>
          <target state="translated">返されるタプルの最初の要素は、 &lt;code&gt;needle&lt;/code&gt; の最後の一致までの &lt;code&gt;haystack&lt;/code&gt; のプレフィックスです。2番目は、マッチに続く &lt;code&gt;haystack&lt;/code&gt; の残りの部分です。</target>
        </trans-unit>
        <trans-unit id="d48cef11152d7e2e71a8b3fb779c57c59642ed57" translate="yes" xml:space="preserve">
          <source>The first example from that paper is set out below (&lt;a href=&quot;#th-example&quot;&gt;A Template Haskell Worked Example&lt;/a&gt;) as a worked example to help get you started.</source>
          <target state="translated">その論文の最初の例は、あなたが始めるのに役立つ&lt;a href=&quot;#th-example&quot;&gt;実用的な例&lt;/a&gt;として以下に示されています（テンプレートHaskellの実用的な例）。</target>
        </trans-unit>
        <trans-unit id="9f5e8571c06e192e03c26745db1bf9e5167e5bff" translate="yes" xml:space="preserve">
          <source>The first example is a parser monad in the style of</source>
          <target state="translated">最初の例は</target>
        </trans-unit>
        <trans-unit id="0db21633e5e7584a4e85ed5e4b67955d4a3ea721" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="00faf7d78a638c92e98de0c4bd577d041551012a" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="7a9264a11b232afb865bd5a70544aaa9c229ee38" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="00088afbc5cbb44faba064e52d1c85ccc7ca138f" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="d99c86cee59c7b0e9addd7c9710d9c1d2d607961" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; それが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="b34efd21f2daa7d49fe1224a63934d829e838b06" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="c46e0719305fcb7afbedd529b28ef7ed1317a3e9" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="2d90a57ad5eaafaf589120d5639047d2ad20009e" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">最初の例では例外 &lt;code&gt;e&lt;/code&gt; が発生しますが、2番目の例では発生しません。実際、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内で使用された場合にのみ例外を発生させます。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; の変異体はに優先して使用する必要があります &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 以内に例外を発生させる &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のそれが他方に対して順序を保証しているためモナド &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; の操作に対し、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; しません。</target>
        </trans-unit>
        <trans-unit id="8377e7f947ca82c2d03b9e96804a9cc74da945a8" translate="yes" xml:space="preserve">
          <source>The first form declares that &lt;code&gt;f&lt;/code&gt; is a (pure) C function that takes no arguments and returns a pointer to a C function with type &lt;code&gt;t&lt;/code&gt;, whereas the second form declares that &lt;code&gt;f&lt;/code&gt; itself is a C function with type &lt;code&gt;t&lt;/code&gt;. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</source>
          <target state="translated">最初の形式は、 &lt;code&gt;f&lt;/code&gt; が引数を取らず、 &lt;code&gt;t&lt;/code&gt; 型のC関数へのポインターを返す（純粋な）C関数であることを宣言し、2番目の形式は、 &lt;code&gt;f&lt;/code&gt; 自体が &lt;code&gt;t&lt;/code&gt; 型のC関数であることを宣言します。最初の宣言は通常は間違いであり、クラッシュを引き起こすためデバッグが難しいため、この警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="b437c04b578dcbe34c5b61a20dafa47889b4aaf9" translate="yes" xml:space="preserve">
          <source>The first four lines (&lt;code&gt;JOB&lt;/code&gt;, &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;SAMPLE_UNIT&lt;/code&gt;, &lt;code&gt;VALUE_UNIT&lt;/code&gt;) form a header. Each block of lines starting with &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; and ending with &lt;code&gt;END_SAMPLE&lt;/code&gt; forms a single sample (you can think of this as a vertical slice of your heap profile). The hp2ps utility should accept any input with a properly-formatted header followed by a series of &lt;em&gt;complete&lt;/em&gt; samples.</source>
          <target state="translated">最初の4行（ &lt;code&gt;JOB&lt;/code&gt; 、 &lt;code&gt;DATE&lt;/code&gt; 、 &lt;code&gt;SAMPLE_UNIT&lt;/code&gt; 、 &lt;code&gt;VALUE_UNIT&lt;/code&gt; ）はヘッダーを形成します。行で始まるの各ブロック &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; で終わる &lt;code&gt;END_SAMPLE&lt;/code&gt; は（あなたがあなたのヒーププロファイルの垂直スライスと考えることができます）単一のサンプルを形成しています。 hp2psユーティリティは、適切にフォーマットされたヘッダーとそれに続く一連の&lt;em&gt;完全な&lt;/em&gt;サンプルを含むすべての入力を受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="c2b82a03029ef67f0b50718409c503eea389a692" translate="yes" xml:space="preserve">
          <source>The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case.</source>
          <target state="translated">入力の最初の文字はタイトルケースに変換され、それ以外の文字の直後に続くすべての文字はタイトルケースに変換されます。他の文字の直後に続く文字はすべて小文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="63efb85344c0aa9c20ebac363da48aba559537ad" translate="yes" xml:space="preserve">
          <source>The first matching axiom we encounter while entailing &lt;code&gt;C a&lt;/code&gt;, is &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;. We have a local axiom &lt;code&gt;B a&lt;/code&gt; available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</source>
          <target state="translated">&lt;code&gt;C a&lt;/code&gt; を伴うときに最初に一致する公理は、 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; です。ローカル公理 &lt;code&gt;B a&lt;/code&gt; があるので、プログラムは突然受け入れられました。インスタンスコンテキストの順序がプログラムを受け入れるかどうかを決定するこの動作は、開発者を混乱させます。</target>
        </trans-unit>
        <trans-unit id="0123b61d2574afe7df7113981a9973c5d86d2592" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="translated">最初の最も一般的な手順は、2つの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を連結することです。内部的には、連結は関数構成に対応します。（ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は、バッファーを埋める関数の差分リストと見なすことができることに注意して&lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;ください。http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlistを&lt;/a&gt;参照してください。）関数構成は高速O（ 1）操作。ただし、制限付きプリミティブを使用して、これらの関数構成の一部を完全に削除できます。これはより効率的です。</target>
        </trans-unit>
        <trans-unit id="2b6aa4f035d3b73aa4ab4041c788e09ed98100cf" translate="yes" xml:space="preserve">
          <source>The first of the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operations, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt;, is a simple action, so we can lift it through &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;InterpM&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; の最初の操作である &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; は単純なアクションなので、 &lt;code&gt;InterpM&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; からInterpMに &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="2faac1fc5843e8344edfa39159393215c540048a" translate="yes" xml:space="preserve">
          <source>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</source>
          <target state="translated">最初のものは明らかに問題ない。2つ目は、明らかではないが、まだ大丈夫です。3つ目はHaskell 98ではなく、インスタンスの終端を失うリスクがあります。</target>
        </trans-unit>
        <trans-unit id="a23c2d18f54a6700ee1bddf4a4ced9e452ae0f90" translate="yes" xml:space="preserve">
          <source>The first option is to compile the program twice:</source>
          <target state="translated">最初のオプションは、プログラムを2回コンパイルすることです。</target>
        </trans-unit>
        <trans-unit id="abf1dca0b44a86f075342cd32443de5cb6266cb1" translate="yes" xml:space="preserve">
          <source>The first parameter (path) must be a file path and not a module name. The type of this path is dependent on how the module was loaded into GHCi: If the module was loaded by name, then the path name calculated by GHCi as described in &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt; must be used. If the module was loaded with an absolute or a relative path, then the same path must be specified.</source>
          <target state="translated">最初のパラメーター（パス）は、モジュール名ではなくファイルパスである必要があります。このパスのタイプは、モジュールがGHCiにロードされた方法によって異なります。モジュールが名前でロードされた場合は、&lt;a href=&quot;#ghci-modules-filenames&quot;&gt;モジュールとファイル名の&lt;/a&gt;説明に従ってGHCiによって計算されたパス名を使用する必要があります。モジュールに絶対パスまたは相対パスがロードされている場合は、同じパスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b7637c081a47d73b9bc11cd583b13a110b93646f" translate="yes" xml:space="preserve">
          <source>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn&amp;rsquo;t the same as the amount of &lt;em&gt;live&lt;/em&gt; memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in &lt;a href=&quot;#prof-heap&quot;&gt;Profiling memory usage&lt;/a&gt;).</source>
          <target state="translated">ファイルの最初の部分は、プログラム名とオプションを与え、合計時間と総メモリの割り当ては、総メモリ割り当ての図は、量と同じではないことをプログラム（ノートの実行中に測定された&lt;em&gt;ライブ&lt;/em&gt;で必要なメモリプログラムはいつでも実行できます。後者はヒーププロファイリングを使用して決定できます。これについては、&lt;a href=&quot;#prof-heap&quot;&gt;メモリ使用量のプロファイリングで&lt;/a&gt;後述します）。</target>
        </trans-unit>
        <trans-unit id="fef3e13957b592e13b7450a30e6df7cd6f143a71" translate="yes" xml:space="preserve">
          <source>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</source>
          <target state="translated">最初に実行されるフェーズは各入力ファイルのサフィックスによって決定され、最後のフェーズはフラグによって決定される。関連するフラグが存在しない場合は、リンクするまでのすべての段階を実行する。この表にまとめます。</target>
        </trans-unit>
        <trans-unit id="145ee321d09d8f6c8d70bccf9d36b9f9aa7af807" translate="yes" xml:space="preserve">
          <source>The first thing we need is generic representations. The &lt;code&gt;GHC.Generics&lt;/code&gt; module defines a couple of primitive types that are used to represent Haskell datatypes:</source>
          <target state="translated">最初に必要なのは、一般的な表現です。 &lt;code&gt;GHC.Generics&lt;/code&gt; のモジュールはHaskellのデータ型を表すために使用されるプリミティブ型のいくつかを定義します。</target>
        </trans-unit>
        <trans-unit id="4a1ecb3ae40da3aae2e8c25cd4cee41373d627e8" translate="yes" xml:space="preserve">
          <source>The fixed point of a monadic computation. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; executes the action &lt;code&gt;f&lt;/code&gt; only once, with the eventual output fed back as the input. Hence &lt;code&gt;f&lt;/code&gt; should not be strict, for then &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; would diverge.</source>
          <target state="translated">モナディック計算の固定小数点。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; はアクション &lt;code&gt;f&lt;/code&gt; を 1回だけ実行し、最終的な出力は入力としてフィードバックされます。したがって &lt;code&gt;f&lt;/code&gt; はその後のために、厳密であるべきではない &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; 発散なります。</target>
        </trans-unit>
        <trans-unit id="3b861bc9465ad5c567e33d3c5ea5e7f4fe10fe04" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="translated">型演算子の固定性は通常の固定性宣言を使用して設定できますが、&lt;a href=&quot;#infix-tycons&quot;&gt;Infix型コンストラクター、クラス、および型変数と&lt;/a&gt;同様に、関数と型コンストラクターは単一の固定性を共有します。</target>
        </trans-unit>
        <trans-unit id="397ad5d952fd5d1bd350537f1bb34e2a9d3464c7" translate="yes" xml:space="preserve">
          <source>The fixity of the constructor</source>
          <target state="translated">コンストラクタの固定性</target>
        </trans-unit>
        <trans-unit id="0127191c720e27284ab5a66b202e3464fd573afd" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;#superclass-rules&quot;&gt;The superclasses of a class declaration&lt;/a&gt;) and instance declarations (&lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="translated">フラグ&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;は、クラス宣言（クラス宣言&lt;a href=&quot;#superclass-rules&quot;&gt;のスーパークラス&lt;/a&gt;）およびインスタンス宣言（&lt;a href=&quot;#instance-rules&quot;&gt;インスタンスコンテキストの緩和ルール）に対する&lt;/a&gt;対応する制限も解除します。</target>
        </trans-unit>
        <trans-unit id="680d808c4989476cdf108f73531ac73891762a24" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt;, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; &lt;/a&gt;は、ラムダ式とパターンバインディングにのみ適用されることを除いて、&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; に&lt;/a&gt;似ています。</target>
        </trans-unit>
        <trans-unit id="0b79e0ee85c7165a369baa04cb9639b641623921" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt; warns about user-written orphan rules or instances.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; は&lt;/a&gt;、ユーザーが作成した孤立ルールまたはインスタンスについて警告します。</target>
        </trans-unit>
        <trans-unit id="6444f39733d8014ca144750cd7ba00423630703d" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--fprint-evld-with-show&quot;&gt;&lt;code&gt;-fprint-evld-with-show&lt;/code&gt;&lt;/a&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--fprint-evld-with-show&quot;&gt; &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; は&lt;/a&gt;、可能な場合に使用可能な &lt;code&gt;Show&lt;/code&gt; インスタンスを再利用するように&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;に指示します。これは、検査対象の変数の内容が完全に評価された場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="47cb0b5fb9b4f5cbc05ae1ed28f5f328bb28aed6" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="translated">フラグ&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;は、型付きと型なしの両方の最上位の宣言スプライスの展開を示します。すべてのダンプフラグと同様に、デフォルトでは、この出力はstdoutに送信されます。重要なプログラムの場合、これを&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;フラグと組み合わせることに興味があるかもしれません（&lt;a href=&quot;debugging#dumping-output&quot;&gt;コンパイラの中間構造のダンプアウトを&lt;/a&gt;参照してください。テンプレートHaskellを使用する各ファイルについて、これは &lt;code&gt;.dump-splices&lt;/code&gt; ファイルに出力を表示します。</target>
        </trans-unit>
        <trans-unit id="4495b2a19abefc172f62863056de3aa383544711" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="translated">フラグ&lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;は、コンパイルされている各モジュール &lt;code&gt;M&lt;/code&gt; のファイル &lt;code&gt;M.th.hs&lt;/code&gt; に、型付きと型なしの両方のすべての最上位TH宣言スプライスの展開をダンプします。他のタイプのスプライス（式、タイプ、およびパターン）は表示されないことに注意してください。アプリケーション開発者はこれをリポジトリにチェックインして、テンプレートHaskellで定義された識別子をgrepできるようにします。これは、&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;と共に使用するのと似ていますが、-ddump-to-fileに結合されるのではなく、常にファイルを生成し&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;。形式も異なります。元のファイルのコードは表示されず、生成されたコードのみが表示され、元のファイルのスプライスの場所に関するコメントが含まれます。</target>
        </trans-unit>
        <trans-unit id="956cfa095b764303bb3df255e599d046113e1e5f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt;&lt;/a&gt; to suppress these warnings.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;は、タイプエラーを実行時に延期するかどうかを制御します。タイプエラーは引き続き警告として出力されますが、コンパイルを妨げることはありません。あなたは使用することができます&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wno-deferred-type-errors&lt;/code&gt; &lt;/a&gt;これらの警告を抑制します。</target>
        </trans-unit>
        <trans-unit id="b93b2c7d1b9eda88e393a8f5e74873331f11d482" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;code&gt;-Wno-type-errors&lt;/code&gt; to suppress these warnings.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;は、型エラーをランタイムに延期するかどうかを制御します。タイプエラーは警告として出力されますが、コンパイルを妨げることはありません。 &lt;code&gt;-Wno-type-errors&lt;/code&gt; を使用して、これらの警告を抑制することができます。</target>
        </trans-unit>
        <trans-unit id="1b3baa03b1de2ae2d10fcb9504c97b6f24d46a7f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;は、GHCiでも機能しますが、1つの例外があります。プロンプトで入力された「裸の」式の場合、タイプエラーは遅延しません。たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="7bc71daa56ee822998e1d64f92a7832d0f7badec" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fglasgow-exts&lt;/code&gt; is equivalent to enabling the following extensions:</source>
          <target state="translated">フラグ &lt;code&gt;-fglasgow-exts&lt;/code&gt; は、以下の拡張機能を有効にすることと同等です。</target>
        </trans-unit>
        <trans-unit id="bfe7b59eddf66920c11dffff433c9395a1cc1d4e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">フラグ &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; は、可能な場合、使用可能な &lt;code&gt;Show&lt;/code&gt; インスタンスを再利用するように&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;に指示します。これは、検査される変数の内容が完全に評価された場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="d43a045f4632b27bf091372de67333d21d36a1ae" translate="yes" xml:space="preserve">
          <source>The flag reference tables (&lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;) lists the status of each flag.</source>
          <target state="translated">フラグリファレンスの表（&lt;a href=&quot;flags#flag-reference&quot;&gt;フラグリファレンス&lt;/a&gt;）には、各フラグのステータスがリストされています。</target>
        </trans-unit>
        <trans-unit id="960b0cead1ab39ce475efd50a401951d0d90317c" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt; control whether the resulting shared object links statically or dynamically to Haskell package libraries given as &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt;は、結果の共有オブジェクトが &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; オプションとして指定されたHaskellパッケージライブラリに静的または動的にリンクするかどうかを制御します。Haccell以外のライブラリは、gccがシステム上で定期的にリンクするようにリンクされます。たとえば、ほとんどのELFシステムでは、リンカは動的ライブラリを検出すると使用します。</target>
        </trans-unit>
        <trans-unit id="7668d5e6fe85390adb7a3ecf19db212413e1eebc" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;と一緒に使用した場合、 &lt;code&gt;main&lt;/code&gt; の定義を変更することで実装されるため、効果がありませんGHCが生成する。参照してください&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;）（あなた自身のメインを使用して&lt;/a&gt;の効果を得る方法については&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;し、&lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt;あなた自身の使用する際 &lt;code&gt;main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">旗は</target>
        </trans-unit>
        <trans-unit id="bcad0a34c93b0b86bbc687fc84b1ffd20b52d6a1" translate="yes" xml:space="preserve">
          <source>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (&lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt;), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</source>
          <target state="translated">浮動小数点環境は、通常のスレッドのコンテキスト切り替えでは保存されません。したがって、1つのスレッドで浮動小数点の状態を変更すると、それらの変更が他のスレッドで表示される可能性があります。さらに、コンテキストスイッチが例外状態を変更する可能性があるため、例外状態のテストは信頼できません。浮動小数点の状態を変更またはテストしてスレッドを使用する必要がある場合は、バインドされたスレッド（ &lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt; ）を使用する必要があります。バインドされたスレッドには独自のOSスレッドがあり、OSスレッドは浮動小数点を保存および復元するためです。状態。</target>
        </trans-unit>
        <trans-unit id="d84e5b1b19c72a9f2f8e38f56f6835541ed5d999" translate="yes" xml:space="preserve">
          <source>The following RTS option(s) affect the behaviour of Concurrent Haskell programs:</source>
          <target state="translated">以下のRTSオプションは、並行Haskellプログラムの動作に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="52952117f68d88486d7181f97f7977ad0131a484" translate="yes" xml:space="preserve">
          <source>The following are QuickCheck specifications of what the combinators do. These can be seen as formal specifications of the behavior of the combinators.</source>
          <target state="translated">以下は、コンビネータが何をするかをクイックチェックする仕様です。これらは、組合せ器の動作の形式的な仕様と見ることができます。</target>
        </trans-unit>
        <trans-unit id="880afa09746074737763ff34c90d8a824dfb1e1a" translate="yes" xml:space="preserve">
          <source>The following are definitions for &quot;merge&quot; for each of the heaps above. Each takes a comparison function which is used to order the elements.</source>
          <target state="translated">上記の各ヒープの &quot;merge &quot;の定義を以下に示します。それぞれのヒープは、要素の順序付けに使用される比較関数を取ります。</target>
        </trans-unit>
        <trans-unit id="9031e690866836bd079eb18cd7f2cf6f4a7c0278" translate="yes" xml:space="preserve">
          <source>The following are definitions for &lt;code&gt;popMin&lt;/code&gt;, a function which constructs a stateful action which pops the smallest element from the queue, where &quot;smallest&quot; is according to the supplied comparison function.</source>
          <target state="translated">以下は、キューから最小の要素をポップするステートフルアクションを構築する関数 &lt;code&gt;popMin&lt;/code&gt; の定義です。ここで、「最小」は、指定された比較関数に従います。</target>
        </trans-unit>
        <trans-unit id="853c1b2416dd00409c8f94cbaaab4d500ad921b0" translate="yes" xml:space="preserve">
          <source>The following are definitions for functions to build queues, given a comparison function.</source>
          <target state="translated">比較関数を与えられたキューを構築する関数の定義を以下に示します。</target>
        </trans-unit>
        <trans-unit id="00e5f1459a91351f85b76ba47f587250af056d92" translate="yes" xml:space="preserve">
          <source>The following are definitions for various specialized pairing heaps.</source>
          <target state="translated">以下に、様々な特殊なペアリングヒープの定義を示します。</target>
        </trans-unit>
        <trans-unit id="bcfac859b1b4efae75f25f72bc0530006c88e6e1" translate="yes" xml:space="preserve">
          <source>The following are good consumers:</source>
          <target state="translated">以下は優良消費者です。</target>
        </trans-unit>
        <trans-unit id="415fb3cf16155d23aebc101af30f40f1175a4761" translate="yes" xml:space="preserve">
          <source>The following are good producers:</source>
          <target state="translated">以下は良い生産者です。</target>
        </trans-unit>
        <trans-unit id="fc2c73f87b7ae21e5d1bff7544c615fae9cb5d03" translate="yes" xml:space="preserve">
          <source>The following behaves as expected:</source>
          <target state="translated">以下は期待通りの動作をします。</target>
        </trans-unit>
        <trans-unit id="0f147698ae3534209b092f6955e20175ff56a36f" translate="yes" xml:space="preserve">
          <source>The following command works to load new packages into a running GHCi:</source>
          <target state="translated">以下のコマンドは、実行中のGHCiに新しいパッケージをロードするために動作します。</target>
        </trans-unit>
        <trans-unit id="e7ad1243df876884047bbd1cfa2abad6fc2f257e" translate="yes" xml:space="preserve">
          <source>The following commands turn the keypad on/off (&lt;code&gt;smkx&lt;/code&gt; and &lt;code&gt;rmkx&lt;/code&gt;). They have no effect if those capabilities are not defined. For portability between terminals, the keypad should be explicitly turned on before accepting user key input.</source>
          <target state="translated">次のコマンドは、キーパッドをオン/オフにします（ &lt;code&gt;smkx&lt;/code&gt; および &lt;code&gt;rmkx&lt;/code&gt; ）。これらの機能が定義されていない場合、効果はありません。端末間の移植性のために、ユーザーのキー入力を受け入れる前に、キーパッドを明示的にオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="25f14bebf678b2e0c7df12fa6531f8bc946288ab" translate="yes" xml:space="preserve">
          <source>The following definition is available to C programs inter-operating with Haskell code when including the header &lt;code&gt;HsFFI.h&lt;/code&gt;.</source>
          <target state="translated">次の定義は、ヘッダー &lt;code&gt;HsFFI.h&lt;/code&gt; をインクルードするときにHaskellコードと相互運用するCプログラムで使用できます。</target>
        </trans-unit>
        <trans-unit id="e6d695a5cf6d19ccd0a26b89aff9c95dd12f497b" translate="yes" xml:space="preserve">
          <source>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</source>
          <target state="translated">機能依存性の動機と使用方法についての以下の説明は、Hugs のユーザーマニュアルから引用したもので、Mark Jones の親切な許可を得てここに転載しています(マイナーチェンジを加えています)。</target>
        </trans-unit>
        <trans-unit id="255eb2a60233998edc485b972b2b920903f06efc" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">次の方程式は、 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; に関連しています。</target>
        </trans-unit>
        <trans-unit id="713d7c0768135036f33a7e1109e709b8e968874e" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">次の方程式は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; に関連しています。</target>
        </trans-unit>
        <trans-unit id="dbc7d38cb4fbd659d01d9a4ef580cbd8a454bdc2" translate="yes" xml:space="preserve">
          <source>The following extra instances are defined:</source>
          <target state="translated">以下の追加インスタンスが定義されています。</target>
        </trans-unit>
        <trans-unit id="219485ecc6b675dce37eba80ce2494e945235236" translate="yes" xml:space="preserve">
          <source>The following flags are simple ways to select standard &amp;ldquo;packages&amp;rdquo; of warnings:</source>
          <target state="translated">次のフラグは、警告の標準的な「パッケージ」を選択する簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="9e8f2bd1d4e584f03bc71486665d6449cff997d8" translate="yes" xml:space="preserve">
          <source>The following flags control the way in which GHC displays types in error messages and in GHCi:</source>
          <target state="translated">以下のフラグは、エラーメッセージやGHCiでの型の表示方法を制御します。</target>
        </trans-unit>
        <trans-unit id="369fd24532366a269db0dd996324b5e45dfd6c9e" translate="yes" xml:space="preserve">
          <source>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</source>
          <target state="translated">以下の関数は、スレッドがクリティカル領域の間に非同期例外の配信を制御することを可能にします。</target>
        </trans-unit>
        <trans-unit id="cf919ec9ecd009bd434b357d75af7e1bf8279715" translate="yes" xml:space="preserve">
          <source>The following functions enable cross-platform output of text that may contain Unicode characters.</source>
          <target state="translated">以下の関数は、Unicode キ ャ ラ ク タ を含む可能性のあ る テ キ ス ト をプ ラ ッ ト フ ォーム間で出力す る こ と を可能に し ます。</target>
        </trans-unit>
        <trans-unit id="38af53e84d563801f65a6120a4900e75bb8e39ff" translate="yes" xml:space="preserve">
          <source>The following functions for cursor movement will combine the more primitive capabilities. For example, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; may use either &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; depending on the parameter and which of &lt;code&gt;cud&lt;/code&gt; and &lt;code&gt;cud1&lt;/code&gt; are defined.</source>
          <target state="translated">次のカーソル移動機能は、より基本的な機能を組み合わせたものです。例えば、 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; のいずれかを使用してもよい &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; 又は &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; をパラメータとするかに応じ &lt;code&gt;cud&lt;/code&gt; と &lt;code&gt;cud1&lt;/code&gt; 定義されます。</target>
        </trans-unit>
        <trans-unit id="0b7bd1ee8d2490e346b323a061ee5d6bf4bd98aa" translate="yes" xml:space="preserve">
          <source>The following functions read one line or character of input from the user.</source>
          <target state="translated">以下の機能は、ユーザから入力された1行または1文字を読み取る機能です。</target>
        </trans-unit>
        <trans-unit id="defeb72fa9fc8defce3095a722d77cd56b0b0897" translate="yes" xml:space="preserve">
          <source>The following holds:</source>
          <target state="translated">以下はホールドしています。</target>
        </trans-unit>
        <trans-unit id="0e843336042b652d443e731d806dae137491a142" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;code&gt;MonadFix&lt;/code&gt; are automatically provided: List, Maybe, IO. Furthermore, the &lt;code&gt;Control.Monad.ST&lt;/code&gt; and &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; modules provide the instances of the &lt;code&gt;MonadFix&lt;/code&gt; class for Haskell&amp;rsquo;s internal state monad (strict and lazy, respectively).</source>
          <target state="translated">&lt;code&gt;MonadFix&lt;/code&gt; の次のインスタンスが自動的に提供されます：リスト、たぶん、IO。さらに、 &lt;code&gt;Control.Monad.ST&lt;/code&gt; および &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; モジュールは、Haskellの内部状態モナド（それぞれ厳密および遅延）の &lt;code&gt;MonadFix&lt;/code&gt; クラスのインスタンスを提供します。</target>
        </trans-unit>
        <trans-unit id="974f2bea79592d4497c7bb6f1878062d29b69e35" translate="yes" xml:space="preserve">
          <source>The following laws ought to hold (for all valid bit indices &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;):</source>
          <target state="translated">以下の法律が成立するはずです（すべての有効なビットインデックス &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; に対して）。</target>
        </trans-unit>
        <trans-unit id="3bc96821c04daf88673e5973fb7e13baaeb66bc4" translate="yes" xml:space="preserve">
          <source>The following operations are guaranteed not to be interruptible:</source>
          <target state="translated">以下の操作は、割り込みができないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="740d5fed1fd466547dd8bedbd7c0b84313346d32" translate="yes" xml:space="preserve">
          <source>The following options affect the way the runtime schedules threads on CPUs:</source>
          <target state="translated">以下のオプションは、ランタイムがCPU上でスレッドをスケジュールする方法に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="2b8d3fdea7e46b30a4c9898c10dbf48da92a4aa0" translate="yes" xml:space="preserve">
          <source>The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</source>
          <target state="translated">以下のオプションは、通常はコンパイル後にGHCが捨ててしまうような中間ファイルを保持する(保持しない)のに便利です。</target>
        </trans-unit>
        <trans-unit id="4b91e9673e3ffcbc96d29b28282cb41f8f1d21ce" translate="yes" xml:space="preserve">
          <source>The following plugins allows users to limit the search for valid hole fits to certain modules, to sort the hole fits by where they originated (in ascending or descending order), as well as allowing users to put a limit on how much time is spent on searching for valid hole fits, after which new searches are aborted.</source>
          <target state="translated">以下のプラグインでは、ユーザーが有効なホールフィットの検索を特定のモジュールに制限したり、ホールフィットを発生場所でソートしたり(昇順または降順)、有効なホールフィットの検索に費やす時間を制限したり、新しい検索を中止したりすることができます。</target>
        </trans-unit>
        <trans-unit id="38c3f1cd516a144b167f804cbad9091a110d7738" translate="yes" xml:space="preserve">
          <source>The following property holds</source>
          <target state="translated">以下のプロパティを保持しています。</target>
        </trans-unit>
        <trans-unit id="c4d20004308e57029d6af08f5d4d162927106726" translate="yes" xml:space="preserve">
          <source>The following relationships hold:</source>
          <target state="translated">以下のような関係が続いています。</target>
        </trans-unit>
        <trans-unit id="78400d597f1cd2c8bbeafc9eb8299b783cc0473e" translate="yes" xml:space="preserve">
          <source>The following sections also give some hints and tips on the use of the foreign function interface in GHC.</source>
          <target state="translated">また、以下のセクションでは、GHCの外部関数インタフェースを使用する際のヒントやヒントも紹介しています。</target>
        </trans-unit>
        <trans-unit id="f17c609e8f1c6b37d3130d2dff0e1652b3175021" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;'1'&lt;/code&gt; と &lt;code&gt;'2'&lt;/code&gt; はどちらも &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; として解析できるため、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="1f604ae57c21e961a4347d16a255de560a7918fb" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;'1'&lt;/code&gt; と &lt;code&gt;'2'&lt;/code&gt; はどちらも &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; として解析できるため、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="f68ed3cdb6c1e1e040a389af1a8ea7b8ca3ea19d" translate="yes" xml:space="preserve">
          <source>The following syntax is stolen:</source>
          <target state="translated">以下の構文が盗まれています。</target>
        </trans-unit>
        <trans-unit id="f24a325a1df690e88417cf55ef160f4f9b155bda" translate="yes" xml:space="preserve">
          <source>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, &lt;code&gt;StablePtr# a&lt;/code&gt;, &lt;code&gt;MutableByteArray#&lt;/code&gt;, &lt;code&gt;ForeignObj#&lt;/code&gt;, and &lt;code&gt;ByteArray#&lt;/code&gt;.</source>
          <target state="translated">次のボックス化されていない型は、基本的な外部型として使用できます（FFIの章、セクション8.6を参照）： &lt;code&gt;Int#&lt;/code&gt; 、 &lt;code&gt;Word#&lt;/code&gt; 、 &lt;code&gt;Char#&lt;/code&gt; 、 &lt;code&gt;Float#&lt;/code&gt; 、 &lt;code&gt;Double#&lt;/code&gt; 、 &lt;code&gt;Addr#&lt;/code&gt; 、 &lt;code&gt;StablePtr# a&lt;/code&gt; 、 &lt;code&gt;MutableByteArray#&lt;/code&gt; 、 &lt;code&gt;ForeignObj#&lt;/code&gt; 、および &lt;code&gt;ByteArray#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a390fae09d9d59559fad6e009bd1023970f06a76" translate="yes" xml:space="preserve">
          <source>The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt; foreign calls: &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, and &lt;code&gt;StablePtr# a&lt;/code&gt;. Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</source>
          <target state="translated">The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;unsafe&lt;/code&gt; foreign calls: &lt;code&gt;Int#&lt;/code&gt; , &lt;code&gt;Word#&lt;/code&gt; , &lt;code&gt;Char#&lt;/code&gt; , &lt;code&gt;Float#&lt;/code&gt; , &lt;code&gt;Double#&lt;/code&gt; , &lt;code&gt;Addr#&lt;/code&gt; , and &lt;code&gt;StablePtr# a&lt;/code&gt; . Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</target>
        </trans-unit>
        <trans-unit id="bc89363b3d736091da072542a570e3138b391d30" translate="yes" xml:space="preserve">
          <source>The following uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; の次の使用は機能するはずです（つまり、誤ったコンパイル時または実行時のクラッシュにつながりません）。</target>
        </trans-unit>
        <trans-unit id="1c72fa99c47cb70fcbd686ee80df427b2899a75e" translate="yes" xml:space="preserve">
          <source>The following will fail with an &amp;ldquo;Illegal unboxed tuple&amp;rdquo; error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</source>
          <target state="translated">コンパイラーによって生成された派生インスタンスはボックス化されていないタプル構文を使用するため、以下は「無効なボックス化されていないタプル」エラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="bbe044a46ef1c2c19252cc897f6025061c027f6f" translate="yes" xml:space="preserve">
          <source>The followup discussion that changed the behavior of &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is archived here: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Proposal: Allow gunfold for Data.Map, ...&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の動作を変更したフォローアップディスカッションはここにアーカイブされています：&lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;提案：Data.Mapのガンフォールドを許可...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cee1c36106928daf538418e53cc5b65ec5381bc2" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt; and all its methods &lt;em&gt;and associated types&lt;/em&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;C(..)&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; はクラス、名前のクラスである &lt;code&gt;C&lt;/code&gt; およびそのすべての方法&lt;em&gt;および関連するタイプ&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="16df0b26ad83c27523378eaf1216ddacafe4cfa5" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt;, and the specified methods &lt;code&gt;mi&lt;/code&gt; and associated types &lt;code&gt;Tj&lt;/code&gt;. The types need a keyword &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to distinguish them from data constructors.</source>
          <target state="translated">フォーム &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt; 、ここで &lt;code&gt;C&lt;/code&gt; はクラスであり、クラス &lt;code&gt;C&lt;/code&gt; に名前を付け、指定されたメソッド &lt;code&gt;mi&lt;/code&gt; および関連する型 &lt;code&gt;Tj&lt;/code&gt; に名前を付けます。タイプには、データコンストラクターと区別するためのキーワード「 &lt;code&gt;type&lt;/code&gt; 」が必要です。</target>
        </trans-unit>
        <trans-unit id="54deed429c05521fb5fa3d0bb8ceb609130a547f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names the family &lt;code&gt;T&lt;/code&gt; and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">フォーム &lt;code&gt;T(..)&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; はデータファミリー名ファミリーである &lt;code&gt;T&lt;/code&gt; とのデータのインスタンスであるすべてのスコープ内のコンストラクタ（範囲における修飾または非修飾するかどうか） &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784438eaf0aa44838a323a050c855ee268899421" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names &lt;code&gt;T&lt;/code&gt; and the specified constructors &lt;code&gt;ci&lt;/code&gt; and fields &lt;code&gt;fj&lt;/code&gt; as usual. The constructors and field names must belong to some data instance of &lt;code&gt;T&lt;/code&gt;, but are not required to belong to the &lt;em&gt;same&lt;/em&gt; instance.</source>
          <target state="translated">&lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt; の形式で、 &lt;code&gt;T&lt;/code&gt; はデータファミリーであり、通常どおり &lt;code&gt;T&lt;/code&gt; に名前を付け、指定したコンストラクター &lt;code&gt;ci&lt;/code&gt; およびフィールド &lt;code&gt;fj&lt;/code&gt; に名前を付けます。コンストラクターとフィールド名は &lt;code&gt;T&lt;/code&gt; のデータインスタンスに属している必要がありますが、&lt;em&gt;同じ&lt;/em&gt;インスタンスに属している必要はありません。</target>
        </trans-unit>
        <trans-unit id="e19f785765e870b264c7a6f5303ec2d2e122f27d" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">&lt;a href=&quot;#gadt&quot;&gt;一般化代数データ型（GADT）&lt;/a&gt;で説明されている一般化代数データ型はこのフォームを使用してのみ宣言できるため、このフォームは「GADTスタイル宣言」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ccb8198ff02595b7c5252294cca08712b727694b" translate="yes" xml:space="preserve">
          <source>The form with a type variable at the head allows this:</source>
          <target state="translated">先頭に型変数を持つフォームではこれが可能です。</target>
        </trans-unit>
        <trans-unit id="33fa9d40a30aa7e6dce906a9649768430ce7ca3a" translate="yes" xml:space="preserve">
          <source>The format character &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; was invoked with. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; should fail unless this character matches the type. It is normal to handle many different format characters for a single type.</source>
          <target state="translated">フォーマット文字 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; が呼び出されました。この文字がタイプと一致しない限り、 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; は失敗するはずです。単一のタイプに対して多くの異なるフォーマット文字を処理するのは通常のことです。</target>
        </trans-unit>
        <trans-unit id="3b0d06acd5997423d85afc8f840323a4c6b86ed5" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;#16233&lt;/a&gt; for more.</source>
          <target state="translated">The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;#16233&lt;/a&gt; for more.</target>
        </trans-unit>
        <trans-unit id="2d9a19d4aec50fa6639cb12bdd8357cf823eed22" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;Issue #16233&lt;/a&gt; for more.</source>
          <target state="translated">GHCが型チェックされたASTを現在格納している形式では、一部の式ノードの型を収集するのにコストがかかります。パフォーマンスのために、GHCは現在これらをスキップすることを選択しているため、すべての式ノードが型情報を持っているとは限りません。詳しくは、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;問題＃16233&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="77eb958799ae389fcdbbcf943703d169a775084b" translate="yes" xml:space="preserve">
          <source>The format is endian-independent: all values are represented in big-endian order.</source>
          <target state="translated">フォーマットはエンディアンに依存しません:すべての値はビッグエンディアン順で表されます。</target>
        </trans-unit>
        <trans-unit id="52265627b3cdf75e5930faf68e8602be59d016e4" translate="yes" xml:space="preserve">
          <source>The format is extensible:</source>
          <target state="translated">フォーマットは拡張可能です。</target>
        </trans-unit>
        <trans-unit id="8d12d8f748fe76f6f798cf8384f400dd6e25b26a" translate="yes" xml:space="preserve">
          <source>The format of the log file is described by the header &lt;code&gt;EventLogFormat.h&lt;/code&gt; that comes with GHC, and it can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">ログファイルの形式は、GHCに付属するヘッダー &lt;code&gt;EventLogFormat.h&lt;/code&gt; によって記述され、&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;ライブラリを使用してHaskellで解析できます。 &lt;code&gt;.eventlog&lt;/code&gt; ファイルの内容をテキストとしてダンプするには、&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;パッケージに付属の &lt;code&gt;ghc-events show&lt;/code&gt; ツールを使用します。</target>
        </trans-unit>
        <trans-unit id="5a21a934d4a700fb3b992b87fb1cc1e6e5af3937" translate="yes" xml:space="preserve">
          <source>The format of the log file is described in this users guide in &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog encodings&lt;/a&gt; It can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">The format of the log file is described in this users guide in &lt;a href=&quot;eventlog-formats#eventlog-encodings&quot;&gt;Eventlog encodings&lt;/a&gt; It can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</target>
        </trans-unit>
        <trans-unit id="be4698f989f63506bf7e347d2e60a53dbb0e6400" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary characters and &lt;em&gt;conversion specifications&lt;/em&gt;, which specify how to format one of the arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; in the output string. A format specification is introduced by the &lt;code&gt;%&lt;/code&gt; character; this character can be self-escaped into the format string using &lt;code&gt;%%&lt;/code&gt;. A format specification ends with a &lt;em&gt;format character&lt;/em&gt; that provides the primary information about how to format the value. The rest of the conversion specification is optional. In order, one may have flag characters, a width specifier, a precision specifier, and type-specific modifier characters.</source>
          <target state="translated">フォーマット文字列は、通常の文字と&lt;em&gt;変換指定&lt;/em&gt;で構成され、出力文字列で &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; の引数の1つをフォーマットする方法を指定します。フォーマット指定は &lt;code&gt;%&lt;/code&gt; 文字によって導入されます。この文字は、 &lt;code&gt;%%&lt;/code&gt; を使用してフォーマット文字列に自己エスケープできます。フォーマット指定は、値のフォーマット方法に関する主要な情報を提供する&lt;em&gt;フォーマット文字&lt;/em&gt;で終わります。残りの変換指定はオプションです。順番に、フラグ文字、幅指定子、精度指定子、およびタイプ固有の修飾子文字を含めることができます。</target>
        </trans-unit>
        <trans-unit id="25e09c7cb4393ecfca8f299ffa2b0d2ecb753a77" translate="yes" xml:space="preserve">
          <source>The former will result in far better code.</source>
          <target state="translated">前者の方がはるかに良いコードになります。</target>
        </trans-unit>
        <trans-unit id="64194ba26d3825d046086abae5391759fabeb498" translate="yes" xml:space="preserve">
          <source>The full Haskell import syntax is supported, including &lt;code&gt;hiding&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; clauses. The prompt shows the modules that are currently imported, but it omits details about &lt;code&gt;hiding&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and so on. To see the full story, use &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">非表示や &lt;code&gt;as&lt;/code&gt; 句など、Haskellの完全なインポート構文がサポートされ &lt;code&gt;hiding&lt;/code&gt; ます。プロンプトを示し、現在インポートされたモジュールが、それは詳細について省略 &lt;code&gt;hiding&lt;/code&gt; 、 &lt;code&gt;as&lt;/code&gt; などを。ストーリー全体を表示するには、&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="6d2ba0a02591100122d7720b515c37aa08242448" translate="yes" xml:space="preserve">
          <source>The full set of warning options is described below. To turn off any warning, simply give the corresponding &lt;code&gt;-Wno-...&lt;/code&gt; option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with &lt;code&gt;-f(no-)warn-*&lt;/code&gt; instead of &lt;code&gt;-W(no-)*&lt;/code&gt;.</source>
          <target state="translated">警告オプションの完全なセットを以下に説明します。警告をオフにするには、コマンドラインで対応する &lt;code&gt;-Wno-...&lt;/code&gt; オプションを指定します。8.0より前のGHCバージョンとの下位互換性のために、これらすべての警告は、 &lt;code&gt;-W(no-)*&lt;/code&gt; ではなく &lt;code&gt;-f(no-)warn-*&lt;/code&gt; で引き続き制御できます。</target>
        </trans-unit>
        <trans-unit id="dc028589c7596178a298d55a5adc62737995f4c1" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of the module where the type is declared</source>
          <target state="translated">型が宣言されているモジュールの完全修飾名</target>
        </trans-unit>
        <trans-unit id="a1840c040d0f137dff3d86a1c41a473b6f4799b8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, but it takes an extra argument which is an &lt;em&gt;exception predicate&lt;/em&gt;, a function which selects which type of exceptions we're interested in.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; に似ていますが、&lt;em&gt;例外の述語&lt;/em&gt;である追加の引数を受け取ります。これは、対象となる&lt;em&gt;例外の&lt;/em&gt;タイプを選択する関数です。</target>
        </trans-unit>
        <trans-unit id="6c24fa3787eba0e6f28035b825969cadbe339326" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;; if the magnitude is zero, then so is the phase.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; は複素数を取り、（大きさ、位相）のペアを正準形式で返します：大きさは負ではなく、範囲 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; の位相です。大きさがゼロの場合、位相も同様です。</target>
        </trans-unit>
        <trans-unit id="d424b407dc86bdf0a0767c07efa10515030815a2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実数の浮動小数点数に適用された関数 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; および適切にスケーリングされた指数（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）として表現された仮数を返します。 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; が &lt;code&gt;(m,n)&lt;/code&gt; 生成する場合、 &lt;code&gt;x&lt;/code&gt; の値は &lt;code&gt;m*b^^n&lt;/code&gt; に等しく、 &lt;code&gt;b&lt;/code&gt; は浮動小数点の基数であり、さらに、 &lt;code&gt;m&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; の両方がゼロか、 &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; 、ここで &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; の値です。特に、 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。タイプに負のゼロが含まれている場合は、 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; も返します。 &lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;または&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; xの&lt;em&gt;いずれか&lt;/em&gt;&lt;em&gt;が&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;場合&lt;/em&gt;&lt;em&gt;、&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;の結果&lt;/em&gt;&lt;em&gt;は不定です&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe262135e4b1d91cb57eb1b81744970db71313a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; は、実数の小数 &lt;code&gt;x&lt;/code&gt; を取り、 &lt;code&gt;x = n+f&lt;/code&gt; ようなペア &lt;code&gt;(n,f)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="afbc2bb6bd9e243f694f4d3b3dece0b75ced87dd" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実数の浮動小数点数に適用された関数 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; および適切にスケーリングされた指数（ &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）として表現された仮数を返します。場合 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; 収率 &lt;code&gt;(m,n)&lt;/code&gt; 、次に &lt;code&gt;x&lt;/code&gt; に値が等しい &lt;code&gt;m*b^^n&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 浮動小数点基数であり、さらに、いずれかの &lt;code&gt;m&lt;/code&gt; 及び &lt;code&gt;n&lt;/code&gt; 、ゼロあるいはその両方である &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; 、ここで &lt;code&gt;d&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; の値です。特に、 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。タイプに負のゼロが含まれている場合は、 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; も返します。 &lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;または&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; xの&lt;em&gt;いずれか&lt;/em&gt;&lt;em&gt;が&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;場合&lt;/em&gt;&lt;em&gt;、&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; &lt;em&gt;の結果&lt;/em&gt;&lt;em&gt;は不定です&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="079629951658e63a1aceb4ed5c824cc91a0b5d86" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; は、実数の小数 &lt;code&gt;x&lt;/code&gt; を取り、 &lt;code&gt;x = n+f&lt;/code&gt; ようなペア &lt;code&gt;(n,f)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="88f909330278d9f82a3312e25ef59ec6d2186b36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coerce&lt;/code&gt; allows you to safely convert between values of types that have the same representation with no run-time overhead. In the simplest case you can use it instead of a newtype constructor, to go from the newtype's concrete type to the abstract type. But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types.</source>
          <target state="translated">関数 &lt;code&gt;coerce&lt;/code&gt; を使用すると、ランタイムオーバーヘッドのない同じ表現を持つ型の値間で安全に変換できます。最も単純なケースでは、newtypeコンストラクタの代わりにそれを使用して、newtypeの具象型から抽象型に移動できます。しかし、それはより複雑な設定でも機能します。例えば、newtypesのリストを具象型のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="a9426870a71de06c1f556cf879bcdaf0553394f4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f3&lt;/code&gt; has a rank-3 type; it has rank-2 types on the left of a function arrow.</source>
          <target state="translated">関数 &lt;code&gt;f3&lt;/code&gt; には、ランク3タイプがあります。関数矢印の左側にランク2タイプがあります。</target>
        </trans-unit>
        <trans-unit id="4bebe5f1a75a0eddf8839f635c3decbffc5557dc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">以下の関数 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Bar&lt;/code&gt; に適用すると失敗するため、&lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt; &lt;code&gt;-Wincomplete-record-updates&lt;/code&gt; &lt;/a&gt;が有効になっている場合、コンパイラーはこれについて警告を発します。</target>
        </trans-unit>
        <trans-unit id="782d3d59f72773f7952ce1ebae2822b75b04a8b7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; from the previous section has a more accurate type:</source>
          <target state="translated">前のセクションの関数 &lt;code&gt;f&lt;/code&gt; には、より正確なタイプがあります。</target>
        </trans-unit>
        <trans-unit id="7ec7041ec2658984f17f499a66ced25885c4a3a1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromList&lt;/code&gt; constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;fromList&lt;/code&gt; は、与えられた &lt;code&gt;Item l&lt;/code&gt; のリストから構造 &lt;code&gt;l&lt;/code&gt; を構築します。</target>
        </trans-unit>
        <trans-unit id="53dd445850b902910cfbc7105e43df3c60dfa18d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromListN&lt;/code&gt; takes the input list&amp;rsquo;s length as a hint. Its behaviour should be equivalent to &lt;code&gt;fromList&lt;/code&gt;. The hint can be used for more efficient construction of the structure &lt;code&gt;l&lt;/code&gt; compared to &lt;code&gt;fromList&lt;/code&gt;. If the given hint is not equal to the input list&amp;rsquo;s length the behaviour of &lt;code&gt;fromListN&lt;/code&gt; is not specified.</source>
          <target state="translated">関数 &lt;code&gt;fromListN&lt;/code&gt; は、入力リストの長さをヒントとして受け取ります。その動作は &lt;code&gt;fromList&lt;/code&gt; と同等でなければなりません。ヒントは、構造体 &lt;code&gt;l&lt;/code&gt; を &lt;code&gt;fromList&lt;/code&gt; と比較してより効率的に構築するために使用できます。指定されたヒントが入力リストの長さに等しくない場合、 &lt;code&gt;fromListN&lt;/code&gt; の動作は指定されません。</target>
        </trans-unit>
        <trans-unit id="b2c51e1ae6a25019f5b8dcb68c7e1cc6360380a0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g&lt;/code&gt; from the previous section is now rejected with a type error as we would hope because the type of &lt;code&gt;f&lt;/code&gt; does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the &lt;code&gt;Collects&lt;/code&gt; class is nowhere near as general as the original class seemed to be: only one of the four instances for &lt;code&gt;Collects&lt;/code&gt; given above can be used with this version of Collects because only one of them&amp;mdash;the instance for lists&amp;mdash;has a collection type that can be written in the form &lt;code&gt;c
e&lt;/code&gt;, for some type constructor &lt;code&gt;c&lt;/code&gt;, and element type &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">前のセクションの関数 &lt;code&gt;g&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の型では2つの引数に異なる型を指定できないため、期待どおりに型エラーで拒否されます。これは、実際にはあいまいさの問題がなく、実際には非常にうまく機能する複数のパラメータークラスの例です。ただし、落とし穴があります。このバージョンの &lt;code&gt;Collects&lt;/code&gt; クラスは、元のクラスのように一般的ではありません。上記の &lt;code&gt;Collects&lt;/code&gt; の4つのインスタンスのうち1つだけがこのバージョンのCollectsで使用できます。型コンストラクター &lt;code&gt;c&lt;/code&gt; の &lt;code&gt;c e&lt;/code&gt; の形式で記述できるコレクション型、および要素型 &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1caf69d4b138be614d3615769e3ef6ea6617e4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;toList&lt;/code&gt; should be the inverse of &lt;code&gt;fromList&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;toList&lt;/code&gt; の逆でなければなりません &lt;code&gt;fromList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f8ca21e6067d938666eb5fad69ffc6307e5c9d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;unsafeCoerce#&lt;/code&gt; allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed.</source>
          <target state="translated">関数 &lt;code&gt;unsafeCoerce#&lt;/code&gt; を使用すると、タイプチェッカーを完全に回避できます。つまり、任意のタイプを他のタイプに強制変換できます。この関数を使用する場合は、正しく設定することをお勧めします。そうしないと、セグメンテーション違反が発生します。よく型付けされていることがわかっているプログラムを作成したいが、Haskellの型システムが十分に型付けされていることを証明するのに十分な表現力がない場合に、一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="4078d840830c2b32e85bca92ef57e0c6f82bd822" translate="yes" xml:space="preserve">
          <source>The function also returns two new handles: * an I/O Completion Port handle on which events will be signaled. * a Job handle which can be used to kill all running processes.</source>
          <target state="translated">この関数は、2つの新しいハンドルも返します。*イベントがシグナルされるI/O完了ポートハンドル。*実行中のプロセスをすべて終了させるために使用できるジョブハンドル。</target>
        </trans-unit>
        <trans-unit id="f6e72213f9f513b34bc27c803b9c687fb47fd6c8" translate="yes" xml:space="preserve">
          <source>The function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; is &lt;code&gt;infixr&lt;/code&gt; with fixity -1.</source>
          <target state="translated">関数 &lt;code&gt;infixr&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; は、固定度-1のinfixrです。</target>
        </trans-unit>
        <trans-unit id="54424bef429db403f4735db658be9ddb164137b0" translate="yes" xml:space="preserve">
          <source>The function creates a temporary file in ReadWrite mode. The created file isn't deleted automatically, so you need to delete it manually.</source>
          <target state="translated">この関数は、ReadWrite モードで一時ファイルを作成します。作成されたファイルは自動的には削除されないので、手動で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d31db636076141a2d374629e18c022c852ebef1" translate="yes" xml:space="preserve">
          <source>The function doesn't verify whether the path exists.</source>
          <target state="translated">この関数はパスが存在するかどうかを検証しません。</target>
        </trans-unit>
        <trans-unit id="add6d8a8d14a017a7abdc22d6a499ce254500df6" translate="yes" xml:space="preserve">
          <source>The function is assumed to define a total ordering.</source>
          <target state="translated">この関数は、全体の順序を定義することを前提としています。</target>
        </trans-unit>
        <trans-unit id="8c87908085624472ff4238bfb948223b787875d2" translate="yes" xml:space="preserve">
          <source>The function that applies a parser must now unwrap each of the monad transformers in turn:</source>
          <target state="translated">パーサを適用する関数は、モナド変換器を順番にアンラップしていく必要があります。</target>
        </trans-unit>
        <trans-unit id="83dbb4039dba1fe07aa4bcd8c6ba58bf457a2ec1" translate="yes" xml:space="preserve">
          <source>The function to modify the environment.</source>
          <target state="translated">環境を修正する機能です。</target>
        </trans-unit>
        <trans-unit id="1ccbf33c88dc57758ba1b802fb4f53d665b9edec" translate="yes" xml:space="preserve">
          <source>The function type constructor.</source>
          <target state="translated">関数型のコンストラクタです。</target>
        </trans-unit>
        <trans-unit id="f0f44ae6963080cf76e0ebf83f004dc8df761919" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">この関数は、対応する値を返します &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; キーがマップにない場合。</target>
        </trans-unit>
        <trans-unit id="2928b1b30db8e1f8656b8116560fcb94973556a2" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</target>
        </trans-unit>
        <trans-unit id="ce3cf6b1fb41916c15598ef7c7a2316d0affe736" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to a comparison function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は比較関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="57722a7fa81914229dcd7f438a467425fc2444d4" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to an equality function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は平等関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="a2f33e33f25cc5b116bd53d1e8871c737f431f0f" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to comparison functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常比較関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれらを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="4fea0a18b8df51f28201953f3c7f75703eb47939" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to equality functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">この関数は通常は等値関数に適用されますが、より一般的な型は、実装が第1のコンテナの要素と第2のコンテナの要素を比較するためにそれらを使用することを保証します。</target>
        </trans-unit>
        <trans-unit id="6b6bc4aeee7f2323c64ee51bd60f90b62c365dcb" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;g2&lt;/code&gt; have rank-2 types; the &lt;code&gt;forall&lt;/code&gt; is on the left of a function arrow. As &lt;code&gt;g2&lt;/code&gt; shows, the polymorphic type on the left of the function arrow can be overloaded.</source>
          <target state="translated">関数 &lt;code&gt;f2&lt;/code&gt; および &lt;code&gt;g2&lt;/code&gt; には、ランク2タイプがあります。 &lt;code&gt;forall&lt;/code&gt; 、関数矢印の左側にあります。 &lt;code&gt;g2&lt;/code&gt; に示すように、関数矢印の左側の多型のタイプは、オーバーロードすることができます。</target>
        </trans-unit>
        <trans-unit id="436e2ff4e3f10ce06692935420d28156ccb98ad6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; have the same body, but only &lt;code&gt;f&lt;/code&gt; is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function&amp;rsquo;s type.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; の本体は同じですが、型シグネチャが与えられるのは &lt;code&gt;f&lt;/code&gt; だけです。GHCが可視型アプリケーションの処理方法を理解するとき、インスタンス化する変数を知っている必要があります。したがって、関数の型の型変数に順序を提供できる必要があります。</target>
        </trans-unit>
        <trans-unit id="709a35f15e3b44bedbeb0d4b4dddb4664dc2f475" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;g5&lt;/code&gt; and &lt;code&gt;g6&lt;/code&gt; mean exactly the same thing. But &lt;code&gt;g7&lt;/code&gt; evaluates &lt;code&gt;(f x)&lt;/code&gt;, binds &lt;code&gt;y&lt;/code&gt; to the result, and then evaluates &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;g5&lt;/code&gt; と &lt;code&gt;g6&lt;/code&gt; はまったく同じ意味です。しかし、 &lt;code&gt;g7&lt;/code&gt; は &lt;code&gt;(f x)&lt;/code&gt; 評価し、 &lt;code&gt;y&lt;/code&gt; を結果にバインドしてから、 &lt;code&gt;body&lt;/code&gt; を評価します。</target>
        </trans-unit>
        <trans-unit id="0b19b31f5cbfb6277d7255768c1a9509164d5a55" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; are careful to force values before installing them in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">関数&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strictは&lt;/a&gt;、それらをインストールする前に値を強制的に注意を払っている &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 。これは通常、怠惰が必須ではない場合により効率的です。このモジュールの関数はそうしません。</target>
        </trans-unit>
        <trans-unit id="670d1298e5cb7a4e8403b208919c4f9aa9e19f28" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; are careful to force values before installing them in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt;の関数は、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; にインストールする前に値を強制するように注意しています。これは通常、怠惰が必須ではない場合により効率的です。このモジュールの関数はそうしません。</target>
        </trans-unit>
        <trans-unit id="d7ac968071ec3d6db992b2e9189f08e304a943fb" translate="yes" xml:space="preserve">
          <source>The functions in this library use the following naming conventions:</source>
          <target state="translated">このライブラリの関数は、以下の命名規則を使用しています。</target>
        </trans-unit>
        <trans-unit id="4d771bd73e07b4943d9ccd53e1231da21d4a47f0" translate="yes" xml:space="preserve">
          <source>The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings.</source>
          <target state="translated">このモジュールの関数は、ランタイムシステムのロケール、文字セットのエンコーディング、行末変換の設定に従います。</target>
        </trans-unit>
        <trans-unit id="d0245bbfde5cb4645880f74fa8998ab54478221f" translate="yes" xml:space="preserve">
          <source>The general form is &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; are optional.</source>
          <target state="translated">一般的な形式は &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt; です。ここで、 &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="d87f5dd37c519e3511a8db8b010d4f7ff96c2337" translate="yes" xml:space="preserve">
          <source>The general interface</source>
          <target state="translated">一般的なインターフェイス</target>
        </trans-unit>
        <trans-unit id="ec767503aee97b2532b6ed4020896fc0a3c857b5" translate="yes" xml:space="preserve">
          <source>The general principle is this:</source>
          <target state="translated">一般的な原則はこれです。</target>
        </trans-unit>
        <trans-unit id="63fa8f01398fe9d9b6a5c91481c5c9f9c693d55d" translate="yes" xml:space="preserve">
          <source>The general rendering interface, supporting annotations. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">アノテーションをサポートする一般的なレンダリングインターフェイス。レンダリングモード、線の長さ、リボンの説明については、 &lt;code&gt;Style&lt;/code&gt; と &lt;code&gt;Mode&lt;/code&gt; タイプを参照してください。</target>
        </trans-unit>
        <trans-unit id="443a3115347a69de80f7eab2e438bb5e78262ac7" translate="yes" xml:space="preserve">
          <source>The general rendering interface. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">一般的なレンダリングインターフェイス。レンダリングモード、線の長さ、リボンの説明については、 &lt;code&gt;Style&lt;/code&gt; と &lt;code&gt;Mode&lt;/code&gt; タイプを参照してください。</target>
        </trans-unit>
        <trans-unit id="2c8107939525836136417ba263c01627df220ab0" translate="yes" xml:space="preserve">
          <source>The generated code for the &lt;code&gt;Functor Wrong&lt;/code&gt; instance would look exactly the same, except with &lt;code&gt;Wrong&lt;/code&gt; replacing every occurrence of &lt;code&gt;Right&lt;/code&gt;. The problem is now that &lt;code&gt;fmap&lt;/code&gt; is being applied recursively to a value of type &lt;code&gt;Either a Int&lt;/code&gt;. This cannot possibly produce a value of type &lt;code&gt;Either b Int&lt;/code&gt;, as &lt;code&gt;fmap&lt;/code&gt; can only change the last type parameter! This causes the generated code to be ill-typed.</source>
          <target state="translated">以下のために生成されたコード &lt;code&gt;Functor Wrong&lt;/code&gt; インスタンスはして除き、まったく同じになります &lt;code&gt;Wrong&lt;/code&gt; のすべての出現置き換える &lt;code&gt;Right&lt;/code&gt; 。問題は、 &lt;code&gt;fmap&lt;/code&gt; が &lt;code&gt;Either a Int&lt;/code&gt; 型の値に再帰的に適用されていることです。これは、おそらく型の値を生成することができない &lt;code&gt;Either b Int&lt;/code&gt; 通り、 &lt;code&gt;fmap&lt;/code&gt; のみ最後の型パラメータを変更することができます！これにより、生成されたコードの型が不適切になります。</target>
        </trans-unit>
        <trans-unit id="32903708d002dac9c0ac078342e2e27cabf0d2dd" translate="yes" xml:space="preserve">
          <source>The generation number of this GC</source>
          <target state="translated">このGCの世代番号</target>
        </trans-unit>
        <trans-unit id="878b032694848adb77a2b859c02bd1b95a7bae5c" translate="yes" xml:space="preserve">
          <source>The goal here is to &lt;code&gt;lift&lt;/code&gt; from monad &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;t2 m&lt;/code&gt; and then &lt;code&gt;lift&lt;/code&gt; this again into &lt;code&gt;t1 (t2 m)&lt;/code&gt;. However, this second &lt;code&gt;lift&lt;/code&gt; can only be accepted when &lt;code&gt;(t2 m)&lt;/code&gt; is a monad and there is no way of establishing that this fact universally holds.</source>
          <target state="translated">ここでの目標は、である &lt;code&gt;lift&lt;/code&gt; モナドから &lt;code&gt;m&lt;/code&gt; まで &lt;code&gt;t2 m&lt;/code&gt; 、その後、 &lt;code&gt;lift&lt;/code&gt; に再びこれを &lt;code&gt;t1 (t2 m)&lt;/code&gt; 。ただし、この2番目の &lt;code&gt;lift&lt;/code&gt; は、 &lt;code&gt;(t2 m)&lt;/code&gt; がモナドである場合にのみ受け入れることができ、この事実が普遍的に当てはまることを確立する方法はありません。</target>
        </trans-unit>
        <trans-unit id="cbfa1f88a3966514e5f590037e0742d3e33e28f3" translate="yes" xml:space="preserve">
          <source>The goal is to preserve the meaning of paths better than &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">目標は、 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt; よりもパスの意味を維持することです。</target>
        </trans-unit>
        <trans-unit id="4e6155b86f48a01b347dfb545d9546dfe24b006f" translate="yes" xml:space="preserve">
          <source>The goal of the roles system is to track when two types have the same underlying representation. In the example above, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation. But, the corresponding instances of &lt;code&gt;BadIdea&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; have the same representation, because the types of the implementations of &lt;code&gt;bad&lt;/code&gt; would be different.</source>
          <target state="translated">役割システムの目標は、2つのタイプの基礎となる表現が同じである場合を追跡することです。上記の例では、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; は同じ表現を持っています。ただし、 &lt;code&gt;bad&lt;/code&gt; の実装のタイプが異なるため、 &lt;code&gt;BadIdea&lt;/code&gt; の対応するインスタンスは同じ表現にはなり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5a7fa8ebdfcbe0b2302748233617b3ca55c26a" translate="yes" xml:space="preserve">
          <source>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</source>
          <target state="translated">型付き穴の目的は、型システムを変更することではなく、Haskellのコードを書くのを助けることです。型付き穴は、型チェッカーから余分な情報を得るために使用することができます。通常、GHCiを使うと、ユーザはすべてのトップレベルバインディングの(推測される)型シグネチャを検査することができます。しかし、この方法はトップレベルで定義されていない用語や複雑な式の内部ではあまり便利ではありません。穴を使うと、ユーザーはこれから書こうとしている用語の型をチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="0cbbcd933189820e27a73038da6c88d11c5e0b90" translate="yes" xml:space="preserve">
          <source>The gory details:</source>
          <target state="translated">ゴリゴリのディテール。</target>
        </trans-unit>
        <trans-unit id="19256158b7bc99497456b028690add2697259def" translate="yes" xml:space="preserve">
          <source>The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.</source>
          <target state="translated">文法はラムダ抽象、let式、条件式の範囲に関して曖昧です。この曖昧さは、これらの構文のそれぞれが可能な限り右に伸びるというメタルールによって解決されています。</target>
        </trans-unit>
        <trans-unit id="13bcdca0f47d6db8faa9273bbcc3a3514eb3a812" translate="yes" xml:space="preserve">
          <source>The graph obtained by reversing all edges.</source>
          <target state="translated">すべての辺を反転させて得られるグラフ。</target>
        </trans-unit>
        <trans-unit id="84d579939cacc525ddd770c640be60c5f760cbb9" translate="yes" xml:space="preserve">
          <source>The graph: a list of nodes uniquely identified by keys, with a list of keys of nodes this node has edges to. The out-list may contain keys that don't correspond to nodes of the graph; such edges are ignored.</source>
          <target state="translated">グラフ:キーによって一意に識別されるノードのリスト.アウトリストには,グラフのノードに対応しないキーが含まれている場合があり,そのようなエッジは無視されます.</target>
        </trans-unit>
        <trans-unit id="19a77ba5e8a6424783c2bacf9d044768e5056e5e" translate="yes" xml:space="preserve">
          <source>The group database</source>
          <target state="translated">グループデータベース</target>
        </trans-unit>
        <trans-unit id="f37dce2ec9ac848392eba760bfa9b2a8e001c3e2" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">ハッシュ記号はセマンティクスをまったく変更しません。ボックス化されていない値または型（たとえば &lt;code&gt;Int#&lt;/code&gt; ）には、「＃」で終わる変数名を使用する傾向がありますが、そうする必要はありません。それらは単なる普通の変数です。また、&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;拡張機能は何も対象外とします。たとえば、 &lt;code&gt;Int#&lt;/code&gt; をスコープに &lt;code&gt;GHC.Prim&lt;/code&gt; インポートする必要があります（&lt;a href=&quot;#primitives&quot;&gt;ボックス&lt;/a&gt;化されていない型とプリミティブ操作を参照）。&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; の&lt;/a&gt;拡張子は、あなたがすることができます&lt;em&gt;参照してください&lt;/em&gt;に &lt;code&gt;Int#&lt;/code&gt; スコープになりました。このオプションを使用すると、 &lt;code&gt;x#y = 0&lt;/code&gt; 意味が変更されることに注意してください。単一の引数を取る関数 &lt;code&gt;x#&lt;/code&gt; を定義します。 &lt;code&gt;y&lt;/code&gt; ; 演算子 &lt;code&gt;#&lt;/code&gt; を定義するには、スペースを入れます： &lt;code&gt;x # y = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5774d0c554fe343baa60ffa9eae14d57f8ade00" translate="yes" xml:space="preserve">
          <source>The header describes each event type and its length. Tools that don&amp;rsquo;t recognise a particular event type can skip those events.</source>
          <target state="translated">The header describes each event type and its length. Tools that don&amp;rsquo;t recognise a particular event type can skip those events.</target>
        </trans-unit>
        <trans-unit id="2210882c0ad0919709f59e7db6b4f28dc98cefd9" translate="yes" xml:space="preserve">
          <source>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</source>
          <target state="translated">ヘッダー行の後には、(引用符で囲まれた)文字列リテラルとしてエンコードされた1つの補完候補を含む⟨l⟩行が続きます。ここでは、様々なケースを示すいくつかの呼び出し例を示します。</target>
        </trans-unit>
        <trans-unit id="de913877c8fa30a91fa438399fb16f39f34a7e00" translate="yes" xml:space="preserve">
          <source>The header of a signature is &lt;code&gt;signature A where ...&lt;/code&gt; (instead of the usual &lt;code&gt;module A where ...&lt;/code&gt;).</source>
          <target state="translated">署名のヘッダーは、署名 &lt;code&gt;signature A where ...&lt;/code&gt; （通常の &lt;code&gt;module A where ...&lt;/code&gt; 代わり）です。</target>
        </trans-unit>
        <trans-unit id="78e62bbf377912fb128bb2f1870fb9fa408d92d9" translate="yes" xml:space="preserve">
          <source>The heap profiler can produce output to GHC&amp;rsquo;s event log, allowing samples to be correlated with other event log events over the program&amp;rsquo;s lifecycle.</source>
          <target state="translated">ヒーププロファイラーは、GHCのイベントログに出力を生成できるため、プログラムのライフサイクル全体でサンプルを他のイベントログイベントと関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="5cd522d72de3dbc3a1ac632468d70b83c0446184" translate="yes" xml:space="preserve">
          <source>The heap-overflow message.</source>
          <target state="translated">ヒープオーバーフローメッセージ。</target>
        </trans-unit>
        <trans-unit id="baec639ab942341375f18c11aa4da668c27baef2" translate="yes" xml:space="preserve">
          <source>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</source>
          <target state="translated">浮動小数点リテラルの16進数表記は、浮動小数点定数を正確に指定する必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0542015ab0e10f3b338b694e109bbc36d0e1ca73" translate="yes" xml:space="preserve">
          <source>The history is only available when using &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</source>
          <target state="translated">履歴は&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; を&lt;/a&gt;使用している場合にのみ利用できます。これは、履歴の各ブレークポイントをログに記録すると、パフォーマンスが2倍以上低下することがわかったためです。</target>
        </trans-unit>
        <trans-unit id="8e8742e7091ac952b2100b44f6fcab38011c36c7" translate="yes" xml:space="preserve">
          <source>The hpc command has several sub-commands:</source>
          <target state="translated">hpcコマンドにはいくつかのサブコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="cd85d2b986388d0386fde70a80e9bce5adc09ca4" translate="yes" xml:space="preserve">
          <source>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the &lt;code&gt;.tix&lt;/code&gt; file is in the same top-level directory. You can use the flag &lt;code&gt;--srcdir&lt;/code&gt; to use &lt;code&gt;hpc&lt;/code&gt; for any other directory, and use &lt;code&gt;--srcdir&lt;/code&gt; multiple times to analyse programs compiled from difference locations, as is typical for packages.</source>
          <target state="translated">hpcツールは、アプリケーションをビルドした場所の最上位ディレクトリにいること、および &lt;code&gt;.tix&lt;/code&gt; ファイルが同じ最上位ディレクトリにあることを前提としています。フラグ &lt;code&gt;--srcdir&lt;/code&gt; を使用して、他のディレクトリに &lt;code&gt;hpc&lt;/code&gt; を使用し、 &lt;code&gt;--srcdir&lt;/code&gt; 複数回使用して、パッケージの典型的なように、異なる場所からコンパイルされたプログラムを分析できます。</target>
        </trans-unit>
        <trans-unit id="ae95e293d652aa6b2e442077a87caf492f54c808" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;a&lt;/code&gt; should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an &lt;code&gt;Int&lt;/code&gt; really is representationally the same as a pointer to a &lt;code&gt;Bool&lt;/code&gt;. But, that&amp;rsquo;s not at all how we want to use &lt;code&gt;Ptr&lt;/code&gt;s! So, we want to be able to say</source>
          <target state="translated">考えは、 &lt;code&gt;a&lt;/code&gt; は実際には表現パラメータであるべきだということですが、役割の推論はそれをファントムに割り当てます。これは感覚のいくつかのレベルを行いますへのポインタ &lt;code&gt;Int&lt;/code&gt; 本当にrepresentationallyへのポインタと同じである &lt;code&gt;Bool&lt;/code&gt; 。しかし、それは &lt;code&gt;Ptr&lt;/code&gt; をどのように使用したいかではありません！だから、私たちは言うことができるようにしたいです</target>
        </trans-unit>
        <trans-unit id="e9b8ad3e3c7027edac335bae313b7046d76ae478" translate="yes" xml:space="preserve">
          <source>The idea is that we can then use &lt;code&gt;Point&lt;/code&gt; just as if we had defined a new datatype &lt;code&gt;MyPoint&lt;/code&gt; with two fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">これで、2つのフィールド &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; で新しいデータ型 &lt;code&gt;MyPoint&lt;/code&gt; を定義した場合と同じように、 &lt;code&gt;Point&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b5577da026d4ae923963655859a7950c0d959c92" translate="yes" xml:space="preserve">
          <source>The idea is that we have a new fundamental type constant &lt;code&gt;TYPE&lt;/code&gt;, which is parameterised by a &lt;code&gt;RuntimeRep&lt;/code&gt;. We thus get &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt;. Anything with a type of the form &lt;code&gt;TYPE x&lt;/code&gt; can appear to either side of a function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;. We can thus say that &lt;code&gt;-&amp;gt;&lt;/code&gt; has type &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt;. The result is always lifted because all functions are lifted in GHC.</source>
          <target state="translated">これは、 &lt;code&gt;RuntimeRep&lt;/code&gt; によってパラメーター化される新しい基本型定数 &lt;code&gt;TYPE&lt;/code&gt; があるという考え方です。したがって、 &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; および &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt; ます。 &lt;code&gt;TYPE x&lt;/code&gt; の形式のタイプを持つものはすべて、関数矢印 &lt;code&gt;-&amp;gt;&lt;/code&gt; のどちらの側にも表示できます。したがって、 &lt;code&gt;-&amp;gt;&lt;/code&gt; の型は &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt; ます。GHCではすべての機能が解除されるため、結果は常に解除されます。</target>
        </trans-unit>
        <trans-unit id="fa2009e07206ad049abebf85b239bfe1d707aee1" translate="yes" xml:space="preserve">
          <source>The idea is there can be no legal calls to &lt;code&gt;f&lt;/code&gt; because every call will give rise to an ambiguous constraint. Indeed, the &lt;em&gt;only&lt;/em&gt; purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt;&lt;code&gt;AllowAmbiguousTypes&lt;/code&gt;&lt;/a&gt; switches off the ambiguity check.</source>
          <target state="translated">すべての呼び出しはあいまいな制約を引き起こすため、 &lt;code&gt;f&lt;/code&gt; への正当な呼び出しはあり得ないという考えです。実際、あいまいさチェックの&lt;em&gt;唯一の&lt;/em&gt;目的は、呼び出すことができない可能性のある関数を報告することです。型のシグネチャのあいまいさチェックを完全に省略することができますが、呼び出しサイトへのあいまいさエラーを遅らせます。実際、言語拡張&lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt; &lt;code&gt;AllowAmbiguousTypes&lt;/code&gt; &lt;/a&gt;は、あいまいさチェックをオフにします。</target>
        </trans-unit>
        <trans-unit id="9edc673edb982c2282b649a46c26961301e8081f" translate="yes" xml:space="preserve">
          <source>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, &lt;em&gt;The Implementation of Practical Functional Programming Languages&lt;/em&gt;, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (&lt;em&gt;Polymorphic type inference and abstract data types&lt;/em&gt;, TOPLAS, 16(5), pp. 1411-1430, 1994). It&amp;rsquo;s been in Lennart Augustsson&amp;rsquo;s &lt;code&gt;hbc&lt;/code&gt; Haskell compiler for several years, and proved very useful. Here&amp;rsquo;s the idea. Consider the declaration:</source>
          <target state="translated">データ型宣言で実存定量化を使用するアイデアは、Perryによって提案され、Hope +で実装されました（Nigel Perry、&lt;em&gt;実践的な関数型プログラミング言語の実装&lt;/em&gt;、博士論文、ロンドン大学、1991）。それは後にLauferとOdersky によって形式化されました（&lt;em&gt;ポリモーフィック型推論と抽象データ型&lt;/em&gt;、TOPLAS、16（5）、pp。1411-1430、1994）。これは数年前からLennart Augustssonの &lt;code&gt;hbc&lt;/code&gt; Haskellコンパイラにあり、非常に有用であることが証明されています。これがアイデアです。宣言を検討してください：</target>
        </trans-unit>
        <trans-unit id="f61001cad70bbaad44a625a79404312846844b51" translate="yes" xml:space="preserve">
          <source>The identity arrow, which plays the role of &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in arrow notation.</source>
          <target state="translated">矢印の表記法で &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; の役割を果たすアイデンティティー矢印。</target>
        </trans-unit>
        <trans-unit id="d797741d4a3ad156d7b9784f618a05a1d311a057" translate="yes" xml:space="preserve">
          <source>The identity functor and monad.</source>
          <target state="translated">アイデンティティファンクタとモナド。</target>
        </trans-unit>
        <trans-unit id="7c8b0e59b588b67f3edbe61854791ee47cfe12bb" translate="yes" xml:space="preserve">
          <source>The identity monad transformer</source>
          <target state="translated">アイデンティティモナド変換器</target>
        </trans-unit>
        <trans-unit id="54f9712c13de60b181bae26ad1f4c1f7a1f328db" translate="yes" xml:space="preserve">
          <source>The identity monad transformer.</source>
          <target state="translated">アイデンティティモナド変換器。</target>
        </trans-unit>
        <trans-unit id="bf1cafdec594d8369ed303bb1c662b40aaf0daff" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="a4ceda1c87510537b203d25ca80c04c39b54cdf6" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; のアイデンティティ。また、方程式を満たしている必要があります</target>
        </trans-unit>
        <trans-unit id="deee9983cee920e92095b678fac9a903e0f11845" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="034960daf8bea9c51407ed94a1c25464ed2788bc" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; のアイデンティティ。また、方程式を満たしている必要があります</target>
        </trans-unit>
        <trans-unit id="5dbaaef3597110434c54ae1a2138fb5629731bbb" translate="yes" xml:space="preserve">
          <source>The implementation does not support system calls.</source>
          <target state="translated">実装はシステムコールをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="7512c5f22af2e468e091d738afee317bd6f3ab0c" translate="yes" xml:space="preserve">
          <source>The implementation is based on</source>
          <target state="translated">に基づいて実装されています。</target>
        </trans-unit>
        <trans-unit id="4406a52eaac6bbe886c15f95aa7c9a4f4887ba65" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズ&lt;a href=&quot;data-map&quot;&gt;調整&lt;/a&gt;されたマップ実装と比較した場合、挿入と削除が（はるかに）高速であることも示しています（Data.Mapを参照）。</target>
        </trans-unit>
        <trans-unit id="42cee383ad635f6c8d6a1715e198b017fcd560b8" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズ&lt;a href=&quot;data-map&quot;&gt;調整&lt;/a&gt;されたマップ実装と比較した場合、挿入と削除が（はるかに）高速であることも示しています（Data.Mapを参照）。</target>
        </trans-unit>
        <trans-unit id="5899bda78d1b99406df43306b7f1534696819133" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。さらに、ベンチマークは、一般的なサイズ&lt;a href=&quot;data-map&quot;&gt;調整&lt;/a&gt;されたマップ実装と比較した場合、挿入と削除が（はるかに）高速であることも示しています（Data.Mapを参照）。</target>
        </trans-unit>
        <trans-unit id="78d8c8ee898c5c545e70528f4e14f986552f2ded" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたマップ実装と比較した場合（&lt;a href=&quot;data-map&quot;&gt;Data.Mapを&lt;/a&gt;参照）、挿入と削除が（はるかに）速いことを示しています。</target>
        </trans-unit>
        <trans-unit id="24c8616bf917dc1c69eac297bc08b786fe0c06a6" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたセットの実装（&lt;a href=&quot;data-set&quot;&gt;Data.Setを&lt;/a&gt;参照）と比較すると、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="55fccc3b15937a9358c0161b537d1afd44dfe908" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">実装は&lt;em&gt;ビッグエンディアンパトリシアツリーに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt;。このデータ構造は、 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; のようなバイナリ演算で特によく機能します。ただし、私のベンチマークは、一般的なサイズのバランスのとれたセットの実装（&lt;a href=&quot;data-set&quot;&gt;Data.Setを&lt;/a&gt;参照）と比較すると、挿入と削除が（はるかに）高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="178e58b7fb96bd95fd580401e99f441f886cc770" translate="yes" xml:space="preserve">
          <source>The implementation is based on the traditional purely-functional queue representation that uses two lists to obtain amortised O(1) enqueue and dequeue operations.</source>
          <target state="translated">実装は、償却されたO(1)のenqueueとdequeue操作を得るために2つのリストを使用する伝統的な純粋に機能的なキュー表現に基づいています。</target>
        </trans-unit>
        <trans-unit id="4463036bd69024477097c960a434a6af09c8061f" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, the memory writes that created that value must have occurred from the point of view of the current thread.</source>
          <target state="translated">実装は、メモリ操作の並べ替えによってタイプが正しいコードが正しく実行されないようにするために必要です。特に、 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; から読み取られた値を検査する場合、その値を作成したメモリへの書き込みは、現在のスレッドの観点から発生している必要があります。</target>
        </trans-unit>
        <trans-unit id="fb8ec445b14ea757e9282327414d673b0305ee28" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">実装 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; に渡された関数がその引数を検査する場合、結果のアクションは &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="10f5d1702e3170c14a64676532aebf2fd23b667a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f3594b695ff2e4cfc4a3fffda3940bb5f4b15f6c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f3ded865df489185e9f39c1a5890fb3ac2d0d16a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; の実装は、以下で説明するように、&lt;em&gt;サイズがバランスのとれた&lt;/em&gt;バイナリツリー（または&lt;em&gt;有界バランスの&lt;/em&gt;ツリー）に基づいてい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2eb1e65a073f89d353d1b82491d0d335135d9d69" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; メッセージの実装</target>
        </trans-unit>
        <trans-unit id="0444f9d8082237d5b98f84df587436a9614cf1ab" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; message: create a new IORef QState, and return a RemoteRef to it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; メッセージの実装：新しいIORef QStateを作成し、それにRemoteRefを返します。</target>
        </trans-unit>
        <trans-unit id="6bc3fa0b81755563203b0ca242878725420112c8" translate="yes" xml:space="preserve">
          <source>The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of</source>
          <target state="translated">の 4.2 節で説明されているように、実装ではサイズでアノテーションされた 2-3 本のフィンガーツリーを使用しています。</target>
        </trans-unit>
        <trans-unit id="a87c4ceafe0cd86c1c0f98a96d0e26cff7b08cc5" translate="yes" xml:space="preserve">
          <source>The implementation uses the call-stack simulation maintained by the profiler, so it only works if the program was compiled with &lt;code&gt;-prof&lt;/code&gt; and contains suitable SCC annotations (e.g. by using &lt;code&gt;-fprof-auto&lt;/code&gt;). Otherwise, the list returned is likely to be empty or uninformative.</source>
          <target state="translated">実装はプロファイラによって維持されるコールスタックシミュレーションを使用するため、プログラムが &lt;code&gt;-prof&lt;/code&gt; でコンパイルされ、適切なSCC注釈が含まれている場合にのみ機能します（たとえば、 &lt;code&gt;-fprof-auto&lt;/code&gt; を使用して）。そうでない場合、返されるリストは空であるか、情報がない可能性があります。</target>
        </trans-unit>
        <trans-unit id="b6788a58c1982f00220dd59a9ac7e8fe15617f19" translate="yes" xml:space="preserve">
          <source>The incoming &lt;code&gt;x&lt;/code&gt; is converted using &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt;, then we dispatch to the generic instances using &lt;code&gt;encode'&lt;/code&gt;. We use this as a default definition for &lt;code&gt;encode&lt;/code&gt;. We need the &lt;code&gt;default encode&lt;/code&gt; signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.</source>
          <target state="translated">入力 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; を使用して変換され、次に &lt;code&gt;encode'&lt;/code&gt; を使用して汎用インスタンスにディスパッチします。これを &lt;code&gt;encode&lt;/code&gt; のデフォルト定義として使用します。通常のHaskellのデフォルトメソッドでは追加のクラス制約を導入してはならないため、 &lt;code&gt;default encode&lt;/code&gt; シグネチャが必要ですが、一般的なデフォルトではそれを導入しています。</target>
        </trans-unit>
        <trans-unit id="2cdd8c06c5214198e849b6d05981aab3d32d8114" translate="yes" xml:space="preserve">
          <source>The incremental input interface</source>
          <target state="translated">インクリメンタル入力インターフェース</target>
        </trans-unit>
        <trans-unit id="982c0c54fd891b5bd49cff179145ac54d3aa5b07" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">インクリメンタルインターフェイスは、厳密な &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を一度に消費します。それぞれが入力の合計量の一部です。デコーダーが終了するためにより多くの入力を必要とする場合は、継続を伴う &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; を返します。これ以上入力がない場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を指定してください。</target>
        </trans-unit>
        <trans-unit id="b3146e319b6642665d719ade7d912bb954ff2d63" translate="yes" xml:space="preserve">
          <source>The incremental interface gives you more control over how input is provided during parsing. This lets you e.g. interleave parsing and I/O.</source>
          <target state="translated">インクリメンタルインターフェースを使用すると、解析中に入力がどのように提供されるかをより制御することができます。これにより、例えばパースやI/Oをインターリーブすることができます。</target>
        </trans-unit>
        <trans-unit id="a6d79c63965b8db6183932a4864f6bc6a68ec9ed" translate="yes" xml:space="preserve">
          <source>The indicated thread has been been woken up on another capability.</source>
          <target state="translated">表示されたスレッドは別の能力で起動されています。</target>
        </trans-unit>
        <trans-unit id="3fe6927713a0d567bb5595e1921afdf920aea86e" translate="yes" xml:space="preserve">
          <source>The indicated thread has been given a label (e.g. with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel&lt;/a&gt;).</source>
          <target state="translated">The indicated thread has been given a label (e.g. with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setThreadLabel&quot;&gt;Control.Concurrent.setThreadLabel&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d766deb37652756438446d85435fb842af7f7ec5" translate="yes" xml:space="preserve">
          <source>The indicated thread has been migrated to a new capability.</source>
          <target state="translated">表示されているスレッドは新しい機能に移行されました。</target>
        </trans-unit>
        <trans-unit id="3ee679cea0bd8e5594a77998bcffe40595e2bc90" translate="yes" xml:space="preserve">
          <source>The indicated thread has started running.</source>
          <target state="translated">表示されているスレッドが動き出しました。</target>
        </trans-unit>
        <trans-unit id="01836651ef18a2e66ee3afe13febce95aa0f2625" translate="yes" xml:space="preserve">
          <source>The indicated thread has stopped running for the reason given by &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">The indicated thread has stopped running for the reason given by &lt;code&gt;status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c157bc7e4dea489c9b0115c1f05cad2ef0e188e" translate="yes" xml:space="preserve">
          <source>The indicated thread is has been marked as ready to run.</source>
          <target state="translated">表示されているスレッドは、実行準備ができているとマークされています。</target>
        </trans-unit>
        <trans-unit id="5e10db54e6f002a3c2b9a12ba3b2e1c228bc85a6" translate="yes" xml:space="preserve">
          <source>The inferred status is volatile: if an unsafe import is added to the module &lt;code&gt;B&lt;/code&gt;, it will cause compilation error of &lt;code&gt;A&lt;/code&gt;. When &lt;a href=&quot;#ghc-flag--Winferred-safe-imports&quot;&gt;&lt;code&gt;-Winferred-safe-imports&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this. This option is off by default.</source>
          <target state="translated">The inferred status is volatile: if an unsafe import is added to the module &lt;code&gt;B&lt;/code&gt; , it will cause compilation error of &lt;code&gt;A&lt;/code&gt; . When &lt;a href=&quot;#ghc-flag--Winferred-safe-imports&quot;&gt; &lt;code&gt;-Winferred-safe-imports&lt;/code&gt; &lt;/a&gt; is enabled, the compiler will emit a warning about this. This option is off by default.</target>
        </trans-unit>
        <trans-unit id="c051b888dc5371d4c7a1728cceef03c9f9b40699" translate="yes" xml:space="preserve">
          <source>The information is formatted such that it can be read as a of type &lt;code&gt;[(String, String)]&lt;/code&gt;. Currently the following fields are present:</source>
          <target state="translated">情報は、タイプ &lt;code&gt;[(String, String)]&lt;/code&gt; として読み取ることができるようにフォーマットされます。現在、次のフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="5a76a6fe1392f713b6ebeea929ebb56029f377be" translate="yes" xml:space="preserve">
          <source>The initial counter value can be negative which denotes a resource &quot;debt&quot; that requires a respective amount of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; operations to counter-balance.</source>
          <target state="translated">カウンターの初期値は、カウンターバランスするためにそれぞれの量の &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; 操作を必要とするリソースの「負債」を示す負の値にすることができます。</target>
        </trans-unit>
        <trans-unit id="2dec26d2e77fa146664e92628931f0bd402a7a5d" translate="yes" xml:space="preserve">
          <source>The initial value left and right of the cursor</source>
          <target state="translated">カーソルの左右の初期値</target>
        </trans-unit>
        <trans-unit id="c7b64e8e48e54908c3b727b4c3f0042b5289f865" translate="yes" xml:space="preserve">
          <source>The initialisation routine, &lt;code&gt;mylib_init&lt;/code&gt;, calls &lt;code&gt;hs_init()&lt;/code&gt; as normal to initialise the Haskell runtime, and the corresponding deinitialisation function &lt;code&gt;mylib_end()&lt;/code&gt; calls &lt;code&gt;hs_exit()&lt;/code&gt; to shut down the runtime.</source>
          <target state="translated">初期化ルーチン &lt;code&gt;mylib_init&lt;/code&gt; は通常どおり &lt;code&gt;hs_init()&lt;/code&gt; を呼び出してHaskellランタイムを初期化し、対応する非初期化関数 &lt;code&gt;mylib_end()&lt;/code&gt; は &lt;code&gt;hs_exit()&lt;/code&gt; を呼び出してランタイムをシャットダウンします。</target>
        </trans-unit>
        <trans-unit id="77a4bde453187e4123c0b62e7f8a1460d7c946e4" translate="yes" xml:space="preserve">
          <source>The injectivity annotation is added after the type family head and consists of two parts:</source>
          <target state="translated">インジェクションアノテーションは、タイプ・ファミリー・ヘッドの後に追加され、2つの部分から構成されています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
