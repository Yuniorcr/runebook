<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="268db2ac8f4f524b89d42b5ab6cac600af62f822" translate="yes" xml:space="preserve">
          <source>IORefs</source>
          <target state="translated">IORefs</target>
        </trans-unit>
        <trans-unit id="4c3aab79c94196e8852e03490d73a55b7f5049e7" translate="yes" xml:space="preserve">
          <source>IOUArray</source>
          <target state="translated">IOUArray</target>
        </trans-unit>
        <trans-unit id="e10a87d05825ac01e14764ed94abba63697418fb" translate="yes" xml:space="preserve">
          <source>IQList</source>
          <target state="translated">IQList</target>
        </trans-unit>
        <trans-unit id="820a25194dff0d9c02f82ba8b6ba428cf8fc6422" translate="yes" xml:space="preserve">
          <source>IQNil</source>
          <target state="translated">IQNil</target>
        </trans-unit>
        <trans-unit id="7567d31e648220ce233abc256ecdab6241e5ddca" translate="yes" xml:space="preserve">
          <source>ISO 8601 Ordinal Date format</source>
          <target state="translated">ISO 8601 序数日付形式</target>
        </trans-unit>
        <trans-unit id="f822119fe2f0a8362181618c06cbbe9eb1102060" translate="yes" xml:space="preserve">
          <source>ISO 8601 Week Date format</source>
          <target state="translated">ISO 8601 週の日付のフォーマット</target>
        </trans-unit>
        <trans-unit id="ce553dbefd4b35500c8adfaf562f347bd1cffaf1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.3. Omit hyphens and colons. &quot;The basic format should be avoided in plain text.&quot;</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.3.ハイフン及びコロンを省略する。&quot;平文では基本的な書式は避けることが望ましい&quot;</target>
        </trans-unit>
        <trans-unit id="5b73e3fe248bf6961ea567329e7f53034196b781" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.4. Use hyphens and colons.</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.4.ハイフンとコロンを使用する。</target>
        </trans-unit>
        <trans-unit id="ea6af556d4876a2b89f040fff7abb59f4dd0f4c1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.2</target>
        </trans-unit>
        <trans-unit id="65fa90d60515a8ea4b8b6bba5111ddac2a89a577" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(a)</target>
        </trans-unit>
        <trans-unit id="b8e6c45635e6a6c7b99751a00199842c95a39f56" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(b)</target>
        </trans-unit>
        <trans-unit id="9b6b8fd39d751d5c0fc381e79557a67b538bd22a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(c)</target>
        </trans-unit>
        <trans-unit id="c7d58b1b77840944ae450aa457ab0e6e3c750344" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(a)</target>
        </trans-unit>
        <trans-unit id="50049f60c0a8e8cd5b1d15d9787aba4c4ae639f0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(b)</target>
        </trans-unit>
        <trans-unit id="d06f9cca67b57ce453f249d30d73e9c7f581681a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(c)</target>
        </trans-unit>
        <trans-unit id="813aaac22f2045f777c991dc639bff2d89abd533" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(d)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(d)</target>
        </trans-unit>
        <trans-unit id="72acd19bfc93f68e206e6c0d34917114a1fccd3e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.3.2</target>
        </trans-unit>
        <trans-unit id="3f13144d5ece5d74d8b6f96aa24edc61eeacd8ad" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.3.3</target>
        </trans-unit>
        <trans-unit id="9b6b94afc9edd9404ea266217015cf416121eae0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.4.2</target>
        </trans-unit>
        <trans-unit id="a87736cb0c925b16cdeae6f6fe9b3e015c30590f" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.4.3</target>
        </trans-unit>
        <trans-unit id="bbcf342f586bebce46006d4c12d16ad8863024f4" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.2, 4.2.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2,4.2.2.4(a)</target>
        </trans-unit>
        <trans-unit id="b6b37624da200ed73cebb71eb0a89339f3a4fba3" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(a), 4.2.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2.3(a)、4.2.2.2.4(b)</target>
        </trans-unit>
        <trans-unit id="c55ad86d1327285d355a307898cd0bcedc64b2e7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(b), 4.2.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2.3(b)、4.2.2.2.4(c)</target>
        </trans-unit>
        <trans-unit id="8f67d771cf395b85785ef48de67f6dffa701c036" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.5</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.5</target>
        </trans-unit>
        <trans-unit id="07b435b23d42540df0b1bc985f1fa5204e769f0b" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.4</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.4</target>
        </trans-unit>
        <trans-unit id="4fcc52df4b38af082287f6513b315a63598a3982" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.1</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.5.1</target>
        </trans-unit>
        <trans-unit id="5787fbc9eed85c23b6ba6c14fc91c92443851aa7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.5.2</target>
        </trans-unit>
        <trans-unit id="12305998507260debe9c8d6034797acfcba06193" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.3.2</target>
        </trans-unit>
        <trans-unit id="c5f903f7dfa61fd47c40e96852ca4df55e2a3b30" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.3.3</target>
        </trans-unit>
        <trans-unit id="9bfa7627b1b505b0fc50fefcc1d485389c084e49" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.3.2</target>
        </trans-unit>
        <trans-unit id="2f0c4ca61d383b42003623a59e3a979e5caa4b98" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.3.3</target>
        </trans-unit>
        <trans-unit id="fafc36b5bb91f4fa0ee5d27ebce4e786ca51d48d" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.4.1</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.4.1</target>
        </trans-unit>
        <trans-unit id="bbb017422d2f8d4d41f4efb11d499f43cec2368e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.5</source>
          <target state="translated">ISO 8601:2004(E)sec.4.5</target>
        </trans-unit>
        <trans-unit id="0844a2bf2289652fa3443d5285683e93680df727" translate="yes" xml:space="preserve">
          <source>ISO/IEC 8859-1 (Char8)</source>
          <target state="translated">ISO/IEC 8859-1 (Char8)</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="c9cf1dd8147dc5d22c7365bdaa07b0903f6de420" translate="yes" xml:space="preserve">
          <source>ITQList</source>
          <target state="translated">ITQList</target>
        </trans-unit>
        <trans-unit id="45da9c6dee9536772c435a75e794212cc011b4e4" translate="yes" xml:space="preserve">
          <source>ITQNil</source>
          <target state="translated">ITQNil</target>
        </trans-unit>
        <trans-unit id="9a1703cf287a1d482c0b2abbe3bb64675ffdbe02" translate="yes" xml:space="preserve">
          <source>Ideally, this type would not exist at all and we would just fix the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">理想的には、このタイプはまったく存在せず、 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; インスタンスを修正するだけです。 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; のです。</target>
        </trans-unit>
        <trans-unit id="ce1ef819f32725331a936d8af228a9ef343e2ecc" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt;, except that the return value does not include the function which maps keys to vertices. This version of &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; is for backwards compatibility.</source>
          <target state="translated">戻り値にキーを頂点にマップする関数が含まれていないことを除いて、 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; と同じです。このバージョンの &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; は、下位互換性のためのものです。</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">アイデンティティ機能。</target>
        </trans-unit>
        <trans-unit id="45ddee8d84b61e8e7c17a3d7431270c5b54e7630" translate="yes" xml:space="preserve">
          <source>Identity functor and monad. (a non-strict monad)</source>
          <target state="translated">同一ファンクタとモナド。(非厳格なモナド)</target>
        </trans-unit>
        <trans-unit id="d40415a7e74878f91a4dde01d55fe29e70b542f1" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="d7ecdcc9a073254188d013838ea2cd05cfb232fd" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; のアイデンティティ</target>
        </trans-unit>
        <trans-unit id="ff5736ff9442788a1bd6a07a6f1942f21ee0e0ff" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="7460eb65d03a49632f7e5ea228f3d10021c309c4" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="036d1bdfa0b3334e329d5335dac94c3cade01124" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="e9a8044f8b5708bc7d69f87f32e2d6115a58e170" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; の ID</target>
        </trans-unit>
        <trans-unit id="de31daa9296519446ec20ea71e05cfd2b2ffa509" translate="yes" xml:space="preserve">
          <source>IdentityT</source>
          <target state="translated">IdentityT</target>
        </trans-unit>
        <trans-unit id="d55cb59cae5c6bdaf9dd412febcf10b5197dca0f" translate="yes" xml:space="preserve">
          <source>Ids with special behaviour</source>
          <target state="translated">特殊な動作を持つID</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7165d0bd8b8d1acf3a7959ac10d5a5fbeb953852" translate="yes" xml:space="preserve">
          <source>If (D) did not exist then (A) and (C) would still be matched, but neither is most specific. In that case, the program would be rejected, unless &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; is enabled, in which case it would be accepted and (A) or (C) would be chosen arbitrarily.</source>
          <target state="translated">（D）が存在しなかった場合でも、（A）と（C）は一致しますが、どちらも最も具体的ではありません。その場合、&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;が有効になっていない限り、プログラムは拒否されます。その場合、プログラムは受け入れられ、（A）または（C）が任意に選択されます。</target>
        </trans-unit>
        <trans-unit id="ddb8e98916bf04f77cda2ecb54ffffb8aeaffeca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type/kind variables can also be explicitly bound. For example:</source>
          <target state="translated">もし &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効な、タイプ/種類の変数も明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="da9178d1cdaa41cf10a914fbfe9e3f1cc2e99f91" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; is enabled, overloaded labels will be desugared using whatever &lt;code&gt;fromLabel&lt;/code&gt; function is in scope, rather than always using &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;が有効になっている場合、オーバーロードされたラベルは、fromLabelを使用して &lt;code&gt;fromLabel&lt;/code&gt; は、常に &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt; を使用するのではなく、スコープ内の関数を使用してdesugaredされます。</target>
        </trans-unit>
        <trans-unit id="e7f41696d0e1b366335f05f546f0074d2d8f5534" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt;&lt;code&gt;-fprint-bind-result&lt;/code&gt;&lt;/a&gt; is set then GHCi will print the result of a statement if and only if:</source>
          <target state="translated">もし &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt; &lt;code&gt;-fprint-bind-result&lt;/code&gt; &lt;/a&gt;設定されている場合に限り、その後、GHCiのは、文の結果を出力します：</target>
        </trans-unit>
        <trans-unit id="a12298741a44a56544916fcc3d1eeb39ec79ce67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">もし &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; それは（つまり、正規のでなければならない定義されている &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="37d0b772579ed80acd95d06e7921caed2a9f0731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</source>
          <target state="translated">&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; が指定されている場合、オブジェクトのファイル名は⟨dir⟩/⟨mod⟩.⟨osuf⟩です。ここで、「mod」は、ドットがスラッシュに置き換えられたモジュール名です。GHCは、「dir」の下に必要なディレクトリ構造が存在しない場合、それをサイレントに作成します。</target>
        </trans-unit>
        <trans-unit id="6bec439461a8c0d2127d1c99af2a5820ee3a9cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;getInputLine&lt;/code&gt; によって返される空白以外の各行が自動的に履歴に追加されます。</target>
        </trans-unit>
        <trans-unit id="943034c7cd530b459599c490f89ba2a24c2508e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;getInputLine&lt;/code&gt; によって返される空白以外の各行が自動的に履歴に追加されます。</target>
        </trans-unit>
        <trans-unit id="d72c7fde1442e5a18545f8980ce1eaec5905c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; are both &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then so is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; 両方とも &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 、その後そうです &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e94e59d7cf4d9cb8563c18691722ce11c38c079d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is uninhabited then any &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; that holds only values of type &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is holding no values.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; その後、任意の無人のさ &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 型の値のみを保持 &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; 何の値を保持されません。</target>
        </trans-unit>
        <trans-unit id="326c4fe588e95cc1235b78af1086ddc7bd85c512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; were not lazy, &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; would look strict in &lt;code&gt;y&lt;/code&gt; which would defeat the whole purpose of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 怠け者ではなかった、 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; に厳密になり &lt;code&gt;y&lt;/code&gt; の全体の目的台無しにしてしまう &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610f1b238432a44cf8ce8bbb88c3bf824a5dd237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is used wrongly, then it may be that computations whose result that would otherwise be shared are re-evaluated every time they are used. Otherwise, the use of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is safe.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; が誤って使用された場合、他の方法では共有されるはずの計算結果が使用されるたびに再評価される可能性があります。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; の使用は安全です。</target>
        </trans-unit>
        <trans-unit id="7c58158c9223c0688808fab7017305ac888c0083" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; の場合が行の読み取り中に他のポイントでファイルの終わりに遭遇した、それは行ターミネーターとして扱われ、（部分的な）行が返されます。</target>
        </trans-unit>
        <trans-unit id="21b4b2460fe3194b5c1e8e3d5532ed22dd7586f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; の場合が行の読み取り中に他のポイントでファイルの終わりに遭遇した、それは行ターミネーターとして扱われ、（部分的な）行が返されます。</target>
        </trans-unit>
        <trans-unit id="e320f20c42c7605270530cbc8962daed664fbb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;Trueの&lt;/a&gt;場合とライン入力（すなわち、すべてのスペースではない）空白でないで、それは自動的に履歴に追加されます。</target>
        </trans-unit>
        <trans-unit id="5ac3fafeec1fd0dd202334e96cfd767b49a7133c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; とライン入力（すなわち、すべてのスペースではない）空白でないで、それは自動的に履歴に追加されます。</target>
        </trans-unit>
        <trans-unit id="ef2cf8b46ce5b4adfb311cafcd49d769949e020c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; の場合が行の読み取り中に他のポイントでファイルの終わりに遭遇した、それは行ターミネーターとして扱われ、（部分的な）行が返されます。</target>
        </trans-unit>
        <trans-unit id="54c8bbd7c753a8e36c3603f2de4d4cd2a62cd77c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; is a power of 2, the result will be exact. In other cases (e.g. for &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt;), the result &lt;em&gt;may&lt;/em&gt; be 1 digit too large sometimes.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; が2の累乗である場合、結果は正確になります。その他の場合（例： &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt; ）、結果&lt;em&gt;は&lt;/em&gt; 1桁が大きすぎる場合があります。</target>
        </trans-unit>
        <trans-unit id="8a13e850c195084652095c4cca81184cca1bc111" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; imports multiple modules, then there will be multiple lines with &lt;code&gt;M.o&lt;/code&gt; as the target.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; が複数のモジュールをインポートする場合、 &lt;code&gt;M.o&lt;/code&gt; で複数の行が存在しますをターゲット。</target>
        </trans-unit>
        <trans-unit id="c1c19c1db68e46617d35c0326dd5168514a0df2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then read its contents without modifying the MVar, without possibility of intervention from other threads.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; の場合が空のは、満杯になるまでブロックします。次に、MVarを変更せずに、他のスレッドからの介入の可能性なしに、その内容を読み取ります。</target>
        </trans-unit>
        <trans-unit id="83f91e64cabad1b57cc078065479e2f730107802" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then remove and return its contents, and set it empty.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; が空の場合は、満杯になるまでブロックします。次に、その内容を削除して返し、空に設定します。</target>
        </trans-unit>
        <trans-unit id="00f25de3697afd87eb6d27164088e4e76d5903b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;, and set &lt;code&gt;MVar#&lt;/code&gt; empty.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; が空の場合、整数0と値undefinedですぐに戻ります。それ以外の場合は、整数1と &lt;code&gt;MVar#&lt;/code&gt; の内容で戻り、 &lt;code&gt;MVar#&lt;/code&gt; を空に設定します。</target>
        </trans-unit>
        <trans-unit id="ebfef89b340df038e270ba036f34b0519cbc0ac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; が空の場合、整数0と値undefinedですぐに戻ります。それ以外の場合は、整数1と &lt;code&gt;MVar#&lt;/code&gt; の内容を返します。ます。</target>
        </trans-unit>
        <trans-unit id="de738ce23865dd45047c99b18298df90a9c1de7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, block until it becomes empty. Then store value arg as its new contents.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; の場合がいっぱいのは、空になるまでブロックします。次に、値argを新しいコンテンツとして格納します。</target>
        </trans-unit>
        <trans-unit id="f0ea9c86d00bfb75f1a61c6b64453776a80bc752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, immediately return with integer 0. Otherwise, store value arg as &lt;code&gt;MVar#&lt;/code&gt;'s new contents, and return with integer 1.</source>
          <target state="translated">&lt;code&gt;MVar#&lt;/code&gt; がいっぱいの場合は、すぐに整数0を返します。それ以外の場合は、値の引数を &lt;code&gt;MVar#&lt;/code&gt; として保存します。の新しいコンテンツし、整数1を返します。</target>
        </trans-unit>
        <trans-unit id="2b9bf43f23f5bb273c3cc1f6ac0c3d420ae5cb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RTLD_DEFAULT&lt;/code&gt; がプラットフォームで定義されていない場合、 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; に減少します。</target>
        </trans-unit>
        <trans-unit id="06453765ecd11a2317b668a85556dad5d95cee4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; は、ご使用のプラットフォーム上で定義されていない、 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; に減少し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c87e13d090df879361d15dfa79e405cd9085828" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RTLD_DEFAULT&lt;/code&gt; がプラットフォームで定義されていない場合、 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; に減少します。</target>
        </trans-unit>
        <trans-unit id="206bdce74c7401df8dd34a4eb0c73875661f2142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; は、ご使用のプラットフォーム上で定義されていない、 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; に減少し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3c2aadabafad2cf8c71f374eecfaa7c9542d06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RTLD_DEFAULT&lt;/code&gt; がプラットフォームで定義されていない場合、 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; に減少します。</target>
        </trans-unit>
        <trans-unit id="83d5752a7d1aceda6754825ba636c32044c8b3bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; は、ご使用のプラットフォーム上で定義されていない、 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; に減少し &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5275bc4d51e6899e6fad22c83eb521ad2006efe4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">場合は &lt;code&gt;blk&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;WNOHANG&lt;/code&gt; がするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。場合は &lt;code&gt;stopped&lt;/code&gt; ている &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 、その後、 &lt;code&gt;WUNTRACED&lt;/code&gt; をするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。</target>
        </trans-unit>
        <trans-unit id="947ea7c1dfd7ce4b41e18914f4032b10928d1f59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">場合は &lt;code&gt;blk&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;WNOHANG&lt;/code&gt; がするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。場合は &lt;code&gt;stopped&lt;/code&gt; ている &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 、その後、 &lt;code&gt;WUNTRACED&lt;/code&gt; をするためのオプションに設定されている &lt;code&gt;waitpid&lt;/code&gt; をそれ以外の場合は、ありません。</target>
        </trans-unit>
        <trans-unit id="6758a6a073866dc9171f52474c81b5f8e56d7a52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; both throw an error, the error thrown by &lt;code&gt;fg&lt;/code&gt; depends on which errors we're talking about. In a monad transformer stack, the deeper layers override the effects of the inner layers; for example, &lt;code&gt;ExceptT e1 (Except
 e2) a&lt;/code&gt; represents a value of type &lt;code&gt;Either e2 (Either e1 a)&lt;/code&gt;, so throwing both an &lt;code&gt;e1&lt;/code&gt; and an &lt;code&gt;e2&lt;/code&gt; will result in &lt;code&gt;Left e2&lt;/code&gt;. If &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; both throw an error from the same layer, instances should ensure that the error from &lt;code&gt;g&lt;/code&gt; wins.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; と &lt;code&gt;g&lt;/code&gt; の両方がエラーをスローする場合、 &lt;code&gt;fg&lt;/code&gt; によってスローされるエラーは、話しているエラーによって異なります。モナド変換子スタックでは、より深い層が内側の層の効果を無効にします。例えば、 &lt;code&gt;ExceptT e1 (Except e2) a&lt;/code&gt; 型の値を表し &lt;code&gt;Either e2 (Either e1 a)&lt;/code&gt; 両投げ、 &lt;code&gt;e1&lt;/code&gt; 及び &lt;code&gt;e2&lt;/code&gt; につながる &lt;code&gt;Left e2&lt;/code&gt; 。場合 &lt;code&gt;f&lt;/code&gt; 及び &lt;code&gt;g&lt;/code&gt; の両方は、同じ層からエラーをスロー、インスタンスからのエラーことを確認する必要があり &lt;code&gt;g&lt;/code&gt; 勝ちます。</target>
        </trans-unit>
        <trans-unit id="a08b722470ddafe8fb8c09c93deed2c332b705cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; がまたある &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 、それが満たすべき</target>
        </trans-unit>
        <trans-unit id="c98343bbca185d60c1ee11e55600855a284be984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; がまたある &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 、それが満たすべき</target>
        </trans-unit>
        <trans-unit id="a539250d2be5c33120a88a56e298e7c403b47812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; がまたある &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 、それが満たすべき</target>
        </trans-unit>
        <trans-unit id="5eac9f125314dfa3f7885b5b45714df2e1cf5559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is both &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; then by the time you factor in the laws of each of those classes, it can't actually use its argument in any meaningful capacity.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; の両方である場合、これらの各クラスの法則を考慮に入れるまでに、意味のある容量でその引数を実際に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="6f7d12845339fe8cd3cb3ac36c2fb96a946b74fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOn fよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="931888dcad242b41a99c52e3454ca1021c558949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; よりも高速になります。</target>
        </trans-unit>
        <trans-unit id="906096b1295440d05beb1594c0fb7469bf723e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOn fよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="805ac8206a6b088f57d9c958aae524c515330e81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安価な場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; よりも高速になります。</target>
        </trans-unit>
        <trans-unit id="5b40996ba5b36b066518d58ee4318ccc60ee6eaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安い場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOnfよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="bdd33339e864a1994b487c054b99bec9522d7f84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; は（例えばレコードセレクタ、または非常に安価である &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; より速くよりなり &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb76c568526f84f6e23c00ea7ec6b9359af0d64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が非常に安い場合（たとえば、レコードセレクターや &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; と比較）はsortOnfよりも高速になります。</target>
        </trans-unit>
        <trans-unit id="f2f6815c2e1b653f81af4e4ff845f99b11b6b06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;f&lt;/code&gt; は（例えばレコードセレクタ、または非常に安価である &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ）、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; より速くよりなり &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9adf0f8908e10c9f90956ffd3ed4fc92f31eb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; が定義されている場合、それは標準的でなければなりません（つまり、 &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15cf615fdb6b04b2196b63a29a9332d038e92d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">場合 &lt;code&gt;hdl&lt;/code&gt; ブロック-またはラインバッファリングされ、その後、現在のバッファにない位置までシークする最初のデバイスに書き込まれる、出力バッファ内の任意のアイテム原因、及び、入力バッファが破棄されます。一部のハンドルはシークできない（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; を参照）か、可能な位置決め操作のサブセットのみをサポートする場合があります（たとえば、テープの最後まで、または最初または現在の位置からの正のオフセットまでしかシークできない場合があります） ）。負のI / O位置、または物理ファイルの場合、現在のファイルの終わりを超えるI / O位置を設定することはできません。</target>
        </trans-unit>
        <trans-unit id="5c8a6eee3327c93a8398e06086b0787394abd668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">場合 &lt;code&gt;hdl&lt;/code&gt; ブロック-またはラインバッファリングされ、その後、現在のバッファにない位置までシークする最初のデバイスに書き込まれる、出力バッファ内の任意のアイテム原因、及び、入力バッファが破棄されます。一部のハンドルはシークできない（ &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; を参照）か、可能な位置決め操作のサブセットのみをサポートする場合があります（たとえば、テープの最後まで、または最初または現在の位置からの正のオフセットまでしかシークできない場合があります） ）。負のI / O位置、または物理ファイルの場合、現在のファイルの終わりを超えるI / O位置を設定することはできません。</target>
        </trans-unit>
        <trans-unit id="6ef3f214074b587d958bb04dc92f38b70020c8f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;./.ghci&lt;/code&gt; files will be ignored (sourcing untrusted local scripts is a security risk). The default is &lt;code&gt;source&lt;/code&gt;. Set this directive in your user &lt;code&gt;.ghci&lt;/code&gt; script, i.e. before the local script would be sourced.</source>
          <target state="translated">場合は &lt;code&gt;ignore&lt;/code&gt; 、 &lt;code&gt;./.ghci&lt;/code&gt; ファイルは無視されます（信頼できないローカルスクリプトを調達することは、セキュリティ上のリスクです）。デフォルトは &lt;code&gt;source&lt;/code&gt; です。このディレクティブは、ユーザーの &lt;code&gt;.ghci&lt;/code&gt; スクリプトで、つまりローカルスクリプトがソースされる前に設定します。</target>
        </trans-unit>
        <trans-unit id="0345953305b2b9f4ea94ff39c9fed5b790ac50f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mappend&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;mappend&lt;/code&gt; が定義されている場合、それは正準である必要があります（すなわち &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fb896d3d56035749898d473a3ff0398ee85a2441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; をサロゲートペアの内側で開始する場合、サフィックスの先頭は、その有効性を維持するために1つの追加の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 単位だけ進められます。</target>
        </trans-unit>
        <trans-unit id="fe2c46cf66a082e4d0025733f2818c10b98e0729" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">場合 &lt;code&gt;n&lt;/code&gt; は原因となる &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; サロゲートペアの内側に始めるために、接尾辞の始まりは一つの追加によって進められる &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; のその有効性を維持するためにユニット。</target>
        </trans-unit>
        <trans-unit id="860162bde8907826a2c5a3fcdedbfb920738c4b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; をサロゲートペアの内部で終了させる場合、プレフィックスの末尾は、その有効性を維持するために1つの追加の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 単位だけ進められます。</target>
        </trans-unit>
        <trans-unit id="17afa2299162ab79a425fea68c5dbb9386ed1c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">場合 &lt;code&gt;n&lt;/code&gt; は原因となる &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; サロゲートペア内の最後に、接頭語の終わりには、一つの追加によって進められる &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; のその有効性を維持するためにユニット。</target>
        </trans-unit>
        <trans-unit id="226e4123ccd5bdaffb4ec80558af633a764b0837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nel&lt;/code&gt; is not defined, this may be built out of other capabilities.</source>
          <target state="translated">&lt;code&gt;nel&lt;/code&gt; が定義されていない場合、これは他の機能から構築されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="64d4d1d892b2f78b4eac4a90be4fe3562658fe6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; 失敗し、いくつかの入力を消費し、そう &lt;code&gt;lookAhead&lt;/code&gt; 。これが望ましくない場合は、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="3537d71db5bdf66b5e84e584bddb563361f13d18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">場合は &lt;code&gt;p&lt;/code&gt; 失敗し、いくつかの入力を消費し、そう &lt;code&gt;lookAhead&lt;/code&gt; 。これが望ましくない場合は、 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; と組み合わせてください。</target>
        </trans-unit>
        <trans-unit id="13ee3fdf69deef0295af859365ce7e178691bbfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;return = pure&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; が定義されている場合、それは標準的である必要があります（つまり &lt;code&gt;return = pure&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df692bac65da2783906b8b3e140d687e86cb3e84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sn1 :: StableName&lt;/code&gt; and &lt;code&gt;sn2 :: StableName&lt;/code&gt; and &lt;code&gt;sn1 == sn2&lt;/code&gt; then &lt;code&gt;sn1&lt;/code&gt; and &lt;code&gt;sn2&lt;/code&gt; were created by calls to &lt;code&gt;makeStableName&lt;/code&gt; on the same object.</source>
          <target state="translated">場合 &lt;code&gt;sn1 :: StableName&lt;/code&gt; と &lt;code&gt;sn2 :: StableName&lt;/code&gt; と &lt;code&gt;sn1 == sn2&lt;/code&gt; その後、 &lt;code&gt;sn1&lt;/code&gt; と &lt;code&gt;sn2&lt;/code&gt; への呼び出しによって作成された &lt;code&gt;makeStableName&lt;/code&gt; 同じオブジェクト上。</target>
        </trans-unit>
        <trans-unit id="e2ad7372f58041f5b2d3a204387a830ce9ae4dd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; is less than zero, then &lt;code&gt;hWaitForInput&lt;/code&gt; waits indefinitely.</source>
          <target state="translated">場合 &lt;code&gt;t&lt;/code&gt; がゼロ未満である場合、 &lt;code&gt;hWaitForInput&lt;/code&gt; は無期限に待ちます。</target>
        </trans-unit>
        <trans-unit id="6557dd6d42d307abdecff79045e463256f2df340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uid&lt;/code&gt; or &lt;code&gt;gid&lt;/code&gt; is specified as -1, then that ID is not changed.</source>
          <target state="translated">場合は &lt;code&gt;uid&lt;/code&gt; または &lt;code&gt;gid&lt;/code&gt; -1として指定され、その後、IDは変更されないこと。</target>
        </trans-unit>
        <trans-unit id="8c23a4167afefd24de1f72d0b1f0f0c9e3f11603" translate="yes" xml:space="preserve">
          <source>If Ctrl-C is pressed during the given action, throw an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">指定されたアクション中にCtrl-Cが押された場合、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; タイプの例外をスローします。例えば：</target>
        </trans-unit>
        <trans-unit id="821902f7f945f9df9b4c26649b68c4f807408798" translate="yes" xml:space="preserve">
          <source>If GHC didn&amp;rsquo;t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC&amp;rsquo;s code generator. Consider</source>
          <target state="translated">GHCが現実の世界で実行されるプログラムをコンパイルする必要がなければ、話はこれで終わりです。しかし、表現ポリモーフィズムはGHCのコードジェネレーターにかなりのトラブルを引き起こす可能性があります。検討する</target>
        </trans-unit>
        <trans-unit id="20ef5d466c86ecef8e8961310c403330cf2b508d" translate="yes" xml:space="preserve">
          <source>If GHC persists in being a bad memory citizen, please report it as a bug.</source>
          <target state="translated">GHCが記憶力の悪い市民であることが続く場合は、バグとして報告してください。</target>
        </trans-unit>
        <trans-unit id="220d5b83850f635db8c322690e19f967385f577b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; references a file descriptor, attempt to lock contents of the underlying file in appropriate mode. If the file is already locked in incompatible mode, this function blocks until the lock is established. The lock is automatically released upon closing a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; がファイル記述子を参照する場合は、適切なモードで基本となるファイルの内容をロックしてみてください。ファイルが互換性のないモードですでにロックされている場合、この関数はロックが確立されるまでブロックします。 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; を閉じると、ロックは自動的に解除されます。</target>
        </trans-unit>
        <trans-unit id="378447cdb747f861c2af8b9d9aa5411c32ef8aca" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; が GADT構文を持つコンストラクタを取り囲み、そして &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます&lt;em&gt;すべて&lt;/em&gt;コンストラクタで使用される型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="fc4cc18d4c1e7b851b50db0a714da14e3509176a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; はバニラの構文を使用してコンストラクタを取り囲み、そして &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は唯一の定量化します&lt;em&gt;実存&lt;/em&gt;型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="044539454a09356f28e0ae13ed4c626569d75f51" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; が GADT構文を持つコンストラクタを取り囲み、そして &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます&lt;em&gt;、すべての&lt;/em&gt;コンストラクタで使用される型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="722ab6109c5e8f9f7714e4e2a9d91f17d7a90602" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">場合 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; はバニラの構文を使用してコンストラクタを包囲し、その後、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 意志だけ定量化&lt;em&gt;実存&lt;/em&gt;型変数を。例えば：</target>
        </trans-unit>
        <trans-unit id="b34d5c83b4ecf116da3871cc1a290a189d5d74ad" translate="yes" xml:space="preserve">
          <source>If a C function prototype has &lt;code&gt;t&lt;/code&gt; as an argument or result type, the use of &lt;code&gt;CT&lt;/code&gt; in the corresponding position in a foreign declaration permits the Haskell program to access the full range of values encoded by the C type; and conversely, any Haskell value for &lt;code&gt;CT&lt;/code&gt; has a valid representation in C.</source>
          <target state="translated">C関数プロトタイプに引数または結果の型として &lt;code&gt;t&lt;/code&gt; がある場合、外部宣言の対応する位置で &lt;code&gt;CT&lt;/code&gt; を使用すると、HaskellプログラムはC型によってエンコードされた値の全範囲にアクセスできます。逆に、 &lt;code&gt;CT&lt;/code&gt; の Haskell値、Cで有効な表現を持っています。</target>
        </trans-unit>
        <trans-unit id="f2c29459b71d15ab93a1c9fd6e056294e61bdf3d" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family.</source>
          <target state="translated">injectiveと宣言されているLHS型変数がRHSのinjective positionに言及されていない場合、GHCは型ファミリがinjectiveではないことを報告します。注入位置とは、型コンストラクタへの引数、または型ファミリへの注入位置のいずれかを意味します。</target>
        </trans-unit>
        <trans-unit id="b02289337799e172c6434a2959c4692b153f59ab" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. Type inference can potentially loop when looking under injective type families in the RHS, so this requires &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt;; GHC suggests enabling the flag when it is necessary.</source>
          <target state="translated">単射として宣言されたLHSタイプ変数が、RHS GHCの単射位置に記載されていない場合、タイプファミリーは単射ではないと報告されます。単射位置とは、型コンストラクターへの引数または型族への単射引数のいずれかを意味します。RHSで単射型族を調べると、型推論がループする可能性があるため、これには&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;が必要です。GHCは、必要に応じてフラグを有効にすることを提案しています。</target>
        </trans-unit>
        <trans-unit id="df1c26c5e5d7b0e6a433e2ce679bce2faf2ee71c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective.</source>
          <target state="translated">型族方程式のRHSが裸の型変数である場合、すべてのLHS変数(暗黙の型変数を含む)も裸であることを要求します。言い換えれば、これはその型族の唯一の方程式であり、すべての可能なパターンをカバーしていなければなりません。パターンがカバーされていない場合、GHCはその型ファミリーが注入的ではないことを報告します。</target>
        </trans-unit>
        <trans-unit id="aae1bcb9b1cecea16f3e3634cf7f4ebbfdfb031c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective.</source>
          <target state="translated">タイプファミリ式のRHSがタイプファミリ応用の場合、GHCはタイプファミリが注入されていないことを報告する。</target>
        </trans-unit>
        <trans-unit id="db25b8f3188747af958388f20acf6bd09afc1781" translate="yes" xml:space="preserve">
          <source>If a call is annotated as &lt;code&gt;interruptible&lt;/code&gt; and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See &lt;a href=&quot;#ffi-interruptible&quot;&gt;Interruptible foreign calls&lt;/a&gt; for more details.</source>
          <target state="translated">呼び出しに &lt;code&gt;interruptible&lt;/code&gt; 注釈が付けられていて、プログラムがマルチスレッド化されている場合、Haskellスレッドが例外を受け取った場合、呼び出しは中断される可能性があります。割り込みが発生するメカニズムはプラットフォームに依存しますが、ブロックされたシステムコールが割り込みエラーコードですぐに戻るようにすることを目的としています。基盤となるオペレーティングシステムスレッドは破棄されません。詳細については、&lt;a href=&quot;#ffi-interruptible&quot;&gt;割り込み可能な外部呼び出し&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1c05c3def7562a739048b872d41b6d6eb05d7a90" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; の呼び出しが位置 &lt;code&gt;p&lt;/code&gt; を返す場合、計算 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;hdl&lt;/code&gt; の位置を &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; の呼び出し時に保持していた位置に設定します。</target>
        </trans-unit>
        <trans-unit id="ba018d0d62ee53ce6b9db280035b85aedadefa2f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; の呼び出しが位置 &lt;code&gt;p&lt;/code&gt; を返す場合、計算 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;hdl&lt;/code&gt; の位置を &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; の呼び出し時に保持していた位置に設定します。</target>
        </trans-unit>
        <trans-unit id="b6f98223cfb0eee3633d62b814584044de61b78c" translate="yes" xml:space="preserve">
          <source>If a constructor has no arguments, then &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; is used as its representation. For example the representation of &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; is</source>
          <target state="translated">コンストラクターに引数がない場合、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; がその表現として使用されます。たとえば &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; の表現は</target>
        </trans-unit>
        <trans-unit id="a9f3d133e06321809c86bac4a4d58b06416b36bf" translate="yes" xml:space="preserve">
          <source>If a declaration occurs in multiple inherited signatures, they will be &lt;em&gt;merged&lt;/em&gt; together. For values, we require that the types from both signatures match exactly; however, other declarations may merge in more interesting ways. The merging operation in these cases has the effect of textually replacing all occurrences of the old name with a reference to the new, merged declaration. For example, if we have the following two signatures:</source>
          <target state="translated">宣言が継承された複数の署名で発生した場合、それらは&lt;em&gt;マージ&lt;/em&gt;されます&lt;em&gt;&lt;/em&gt;一緒されます。値については、両方のシグネチャの型が完全に一致する必要があります。ただし、他の宣言はより興味深い方法でマージされる場合があります。これらの場合のマージ操作には、古い名前のすべての出現箇所を、新しくマージされた宣言への参照にテキストで置き換える効果があります。たとえば、次の2つの署名があるとします。</target>
        </trans-unit>
        <trans-unit id="8cb4f4cbaa3cf83a5c5f2e268c4fafffea33710e" translate="yes" xml:space="preserve">
          <source>If a field has a higher-rank or existential type, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved automatically (as described above), but in the interests of simplicity we do not permit users to define their own instances either. If a field is not in scope, the corresponding instance is still prohibited, to avoid conflicts in downstream modules.</source>
          <target state="translated">フィールドのランクが上位または存在する場合、対応する &lt;code&gt;HasField&lt;/code&gt; 制約は（上記のように）自動的に解決されませんが、簡単にするために、ユーザーが独自のインスタンスを定義することを許可していません。フィールドがスコープ内にない場合、ダウンストリームモジュールでの競合を回避するために、対応するインスタンスは引き続き禁止されます。</target>
        </trans-unit>
        <trans-unit id="a8eaf7aebcd40fba7a5385d613e9ae5cec1a85c4" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="translated">ファイナライザが例外をスローした場合、その後に実行するためにキューに入れられていた後続のファイナライザは実行されません。この動作は、将来のリリースで変更される可能性があります。課題トラッカーの課題&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt;を参照してください。例外をスローするファイナライザを作成することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="1ba0a898d0039a2f3ea2fb9c837e62a8bdc242f7" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="translated">ファイナライザーが例外をスローした場合、それ以降に実行するためにキューに入れられていた後続のファイナライザーは実行されません。この動作は、将来のリリースで変更される可能性があります。課題トラッカーの課題&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13167&quot;&gt;13167&lt;/a&gt;を参照してください。例外をスローするファイナライザーを作成することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="e1b752cff9e74d6e08fc8898cd07eefb082da1bf" translate="yes" xml:space="preserve">
          <source>If a module was then to import &lt;code&gt;MyNum&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt;, it would also import the pattern synonym &lt;code&gt;Zero&lt;/code&gt;.</source>
          <target state="translated">モジュールが &lt;code&gt;Example&lt;/code&gt; から &lt;code&gt;MyNum&lt;/code&gt; をインポートする場合、パターンの同義語 &lt;code&gt;Zero&lt;/code&gt; もインポートします。</target>
        </trans-unit>
        <trans-unit id="893611b3da8b13dca82bbde8d7e30b09c03ec327" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit (although GHCi will still emit a message to say the breakpoint was hit). What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">コマンドの前に数値が指定されている場合、指定されたブレークポイント（のみ）に到達するとコマンドが実行されます。これは非常に便利です。たとえば、 &lt;code&gt;:set stop 1 :continue&lt;/code&gt; は、ヒットするたびに&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; を&lt;/a&gt;実行することにより、ブレークポイント1を効果的に無効にします（ただし、GHCiはブレークポイントがヒットしたことを示すメッセージを引き続き出力します）。さらに、&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; の巧妙&lt;/a&gt;な使用により、&lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt;を使用して条件付きブレークポイントを実装できます。</target>
        </trans-unit>
        <trans-unit id="d7c3aca378dedbdc91ecccb72c921e9d9ef55af4" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit In this case GHCi will still emit a message to say the breakpoint was hit. If you don&amp;rsquo;t want such a message, you can use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command. What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">コマンドの前に番号が指定されている場合、指定されたブレークポイント（のみ）がヒットしたときにコマンドが実行されます。これは非常に便利です。たとえば、 &lt;code&gt;:set stop 1 :continue&lt;/code&gt; は、ブレークポイント1がヒットするたびに&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; を&lt;/a&gt;実行することにより、ブレークポイント1を効果的に無効にします。この場合、GHCiはブレークポイントがヒットしたことを示すメッセージを出力します。このようなメッセージが必要ない場合は、&lt;a href=&quot;#ghci-cmd-:disable&quot;&gt; &lt;code&gt;:disable&lt;/code&gt; &lt;/a&gt;コマンドを使用できます。使用を狡猾で、より多くの何&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; を&lt;/a&gt;使用できる&lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt;条件付きブレークポイントを実装します：</target>
        </trans-unit>
        <trans-unit id="1469d9b993c79ed9fd15d1a5a0d6060aaa153a72" translate="yes" xml:space="preserve">
          <source>If a record field does not have a selector function because its type would allow an existential variable to escape, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved. For example,</source>
          <target state="translated">レコードフィールドにセレクター関数がない場合、そのタイプによって実存変数をエスケープできるため、対応する &lt;code&gt;HasField&lt;/code&gt; 制約は解決されません。例えば、</target>
        </trans-unit>
        <trans-unit id="164c3702f74e30bae3bcb4e2249a8dd0868593c2" translate="yes" xml:space="preserve">
          <source>If a record field has a polymorphic type (and hence the selector function is higher-rank), the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved, because doing so would violate the functional dependency on &lt;code&gt;HasField&lt;/code&gt; and/or require impredicativity. For example,</source>
          <target state="translated">レコードフィールドにポリモーフィックタイプがある（したがって、セレクター関数のランクが高い）場合、対応する &lt;code&gt;HasField&lt;/code&gt; 制約は解決されません。これを行うと、 &lt;code&gt;HasField&lt;/code&gt; への機能依存性に違反したり、予測性が要求されたりするためです。例えば、</target>
        </trans-unit>
        <trans-unit id="afc8e267ccbb00ce682890bda99554fbfc2f7a86" translate="yes" xml:space="preserve">
          <source>If a record type has an old-fashioned datatype context, the &lt;code&gt;HasField&lt;/code&gt; constraint will be reduced to solving the constraints from the context. For example,</source>
          <target state="translated">レコード型に旧式のデータ型コンテキストがある場合、 &lt;code&gt;HasField&lt;/code&gt; 制約はコンテキストからの制約の解決に削減されます。例えば、</target>
        </trans-unit>
        <trans-unit id="608bb4b5a475db6a4953e34347efc01b12ab3dbd" translate="yes" xml:space="preserve">
          <source>If a thread makes a foreign call (and the call is not marked &lt;code&gt;unsafe&lt;/code&gt;), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, &lt;code&gt;foreign export&lt;/code&gt;ed Haskell functions may be called from multiple OS threads simultaneously. See &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;.</source>
          <target state="translated">スレッドが外部呼び出しを行った場合（その呼び出しが &lt;code&gt;unsafe&lt;/code&gt; とマークされていない場合）、プログラム内の他のHaskellスレッドは、外部呼び出しの進行中も引き続き実行されます。さらに、 &lt;code&gt;foreign export&lt;/code&gt; Haskell関数は、複数のOSスレッドから同時に呼び出すことができます。&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;マルチスレッドとFFIを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9afb526f4bf8bfbbfbd29f142d6a0d74ef8a8864" translate="yes" xml:space="preserve">
          <source>If a type variable &lt;code&gt;a&lt;/code&gt; in a datatype, class, or type family declaration depends on another such variable &lt;code&gt;k&lt;/code&gt; in the same declaration, two properties must hold:</source>
          <target state="translated">データ型、クラス、または型ファミリー宣言の型変数 &lt;code&gt;a&lt;/code&gt; が、同じ宣言の別のそのような変数 &lt;code&gt;k&lt;/code&gt; に依存している場合、2つのプロパティが保持されている必要があります。</target>
        </trans-unit>
        <trans-unit id="1fa7a794644c3b1936544c749803bfa930ad77e9" translate="yes" xml:space="preserve">
          <source>If a user does not provide a manual implementation for &lt;code&gt;sPpr&lt;/code&gt;, then it will default to &lt;code&gt;show&lt;/code&gt;. Now we can leverage the &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extension to easily implement a &lt;code&gt;SPretty&lt;/code&gt; instance for a new data type:</source>
          <target state="translated">ユーザーが &lt;code&gt;sPpr&lt;/code&gt; の手動実装を提供しない場合、デフォルトで &lt;code&gt;show&lt;/code&gt; ます。これで、&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;拡張機能を利用して、新しいデータ型の &lt;code&gt;SPretty&lt;/code&gt; インスタンスを簡単に実装できます。</target>
        </trans-unit>
        <trans-unit id="ae7120c3db21432a6f1b3610362bef769bc13113" translate="yes" xml:space="preserve">
          <source>If a weak pointer (object) refers to an &lt;em&gt;unreachable&lt;/em&gt; key, it may be finalized.</source>
          <target state="translated">ウィークポインタ（オブジェクト）が&lt;em&gt;到達できない&lt;/em&gt;キーを参照している場合、それはファイナライズされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="102c2b7d4713d61cdf925ffde90969e0cf8621ec" translate="yes" xml:space="preserve">
          <source>If a worker has that many arguments, none will be unpacked anymore.</source>
          <target state="translated">ワーカーがそれだけ多くの引数を持っている場合、どれももうアンパックされません。</target>
        </trans-unit>
        <trans-unit id="b93932446c468ada97c37e6d1c9ba23f662e6eb7" translate="yes" xml:space="preserve">
          <source>If all else fails, then you need to resort to &lt;code&gt;Foreign.malloc&lt;/code&gt; and &lt;code&gt;Foreign.free&lt;/code&gt;. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform&amp;rsquo;s C library. We usually find &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; to be significantly slower than the other forms of allocation above.</source>
          <target state="translated">他のすべてが失敗した場合は、 &lt;code&gt;Foreign.malloc&lt;/code&gt; および &lt;code&gt;Foreign.free&lt;/code&gt; に頼る必要があります。これらは同じ名前のC関数のラッパーにすぎず、その効率は最終的にはプラットフォームのCライブラリでのこれらの関数の実装に依存します。通常、 &lt;code&gt;malloc&lt;/code&gt; と &lt;code&gt;free&lt;/code&gt; は、上記の他の形式の割り当てよりもかなり遅いことがわかります。</target>
        </trans-unit>
        <trans-unit id="58a9c3c0b52a8eea92099f68faa2621ba66a2174" translate="yes" xml:space="preserve">
          <source>If all the matches against the &lt;code&gt;pi&lt;/code&gt; succeed, the match succeeds, binding the variables bound by the &lt;code&gt;pi&lt;/code&gt; . (The &lt;code&gt;xi&lt;/code&gt; are not bound; they remain local to the pattern synonym declaration.)</source>
          <target state="translated">&lt;code&gt;pi&lt;/code&gt; に対するすべての一致が成功すると、一致が成功し、 &lt;code&gt;pi&lt;/code&gt; によってバインドされた変数がバインドされます。（ &lt;code&gt;xi&lt;/code&gt; はバインドされていません。パターン同義語宣言に対してローカルのままです。）</target>
        </trans-unit>
        <trans-unit id="eed9f549e1682b63a8806713ee685fb3c9adfb3a" translate="yes" xml:space="preserve">
          <source>If all the remaining candidates are incoherent, the search suceeds, returning an arbitrary surviving candidate.</source>
          <target state="translated">残ったすべての候補が支離滅裂な場合、検索は成功し、任意の生存候補を返します。</target>
        </trans-unit>
        <trans-unit id="bb88aceb390c3de7d3ec513d599b8826a7a3104e" translate="yes" xml:space="preserve">
          <source>If all values stored in all maps in the arguments are in WHNF, then all values stored in all maps in the results will be in WHNF once those maps are evaluated.</source>
          <target state="translated">引数にあるすべてのマップに格納されているすべての値がWHNFにある場合、結果にあるすべてのマップに格納されているすべての値は、それらのマップが評価されるとWHNFになります。</target>
        </trans-unit>
        <trans-unit id="e9f53d1f0ff24c6a37e378e5ebd89c1567f62d05" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callCommand&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callCommand&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;callCommand&lt;/code&gt; を実行しているスレッドに非同期例外がスローされると、フォークされたプロセスは終了し、 &lt;code&gt;callCommand&lt;/code&gt; はプロセスが終了するまで待機（ブロック）します。</target>
        </trans-unit>
        <trans-unit id="fa75dc761964532aaa328fd35153a5453bcd7b2e" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;callProcess&lt;/code&gt; を実行しているスレッドに非同期例外がスローされると、フォークされたプロセスは終了し、プロセスが終了するまで &lt;code&gt;callProcess&lt;/code&gt; は待機（ブロック）します。</target>
        </trans-unit>
        <trans-unit id="d1293622c4845776f0f7f46e69be43df4b5fb632" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;readProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;readProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">&lt;code&gt;readProcess&lt;/code&gt; を実行しているスレッドに非同期例外がスローされると、フォークされたプロセスが終了し、プロセスが終了するまで &lt;code&gt;readProcess&lt;/code&gt; は待機（ブロック）します。</target>
        </trans-unit>
        <trans-unit id="ac09f8306bc4c40a9a80bb592e856f9697dfc58b" translate="yes" xml:space="preserve">
          <source>If an entry within the directory vanishes while &lt;code&gt;removePathForcibly&lt;/code&gt; is running, it is silently ignored.</source>
          <target state="translated">&lt;code&gt;removePathForcibly&lt;/code&gt; の実行中にディレクトリ内のエントリが消失した場合、それは通知なく無視されます。</target>
        </trans-unit>
        <trans-unit id="1f47696dc0606508335264b40a8a2bc81264cf0b" translate="yes" xml:space="preserve">
          <source>If an environment entry does not contain an &lt;code&gt;'='&lt;/code&gt; character, the &lt;code&gt;key&lt;/code&gt; is the whole entry and the &lt;code&gt;value&lt;/code&gt; is the empty string.</source>
          <target state="translated">環境エントリに &lt;code&gt;'='&lt;/code&gt; 文字が含まれていない場合、 &lt;code&gt;key&lt;/code&gt; はエントリ全体であり、 &lt;code&gt;value&lt;/code&gt; は空の文字列です。</target>
        </trans-unit>
        <trans-unit id="846fa208a465c46cbb71d52b1a9edd5d7d4d8f8d" translate="yes" xml:space="preserve">
          <source>If an error is thrown during the use, the release still happens before the error is rethrown.</source>
          <target state="translated">使用中にエラーがスローされた場合、エラーが再スローされる前にリリースが行われます。</target>
        </trans-unit>
        <trans-unit id="588c20098b5c4c736fc7038d90ea284118f71b07" translate="yes" xml:space="preserve">
          <source>If an exception occurs while removing an entry, &lt;code&gt;removePathForcibly&lt;/code&gt; will still try to remove as many entries as it can before failing with an exception. The first exception that it encountered is re-thrown.</source>
          <target state="translated">エントリの削除中に例外が発生した場合でも、 &lt;code&gt;removePathForcibly&lt;/code&gt; は、例外で失敗する前に、できるだけ多くのエントリを削除しようとします。発生した最初の例外は再スローされます。</target>
        </trans-unit>
        <trans-unit id="6f43e9ffc752b9a35ea582ecc7ec760456f3ea2c" translate="yes" xml:space="preserve">
          <source>If an explicit deriving strategy is not given, multiple strategies may apply. In that case, GHC chooses the strategy as follows:</source>
          <target state="translated">明示的な導出戦略が与えられていない場合、複数の戦略が適用される可能性がある。その場合、GHCは以下のように戦略を選択します。</target>
        </trans-unit>
        <trans-unit id="ff8ac1961b2d3e86583dd04eda895ba3b29064e6" translate="yes" xml:space="preserve">
          <source>If an identifier&amp;rsquo;s type has a &lt;code&gt;forall&lt;/code&gt;, then the order of type variables as written in the &lt;code&gt;forall&lt;/code&gt; is retained.</source>
          <target state="translated">識別子のタイプがある場合は &lt;code&gt;forall&lt;/code&gt; 、その後に書かれたようなタイプの変数の順序 &lt;code&gt;forall&lt;/code&gt; 保持されます。</target>
        </trans-unit>
        <trans-unit id="6f039989be66fcac53da059edc720fe7f2a41936" translate="yes" xml:space="preserve">
          <source>If an optional package identifier ⟨P⟩ is given, then only packages matching that identifier are shown.</source>
          <target state="translated">オプションのパッケージ識別子 ⟨P⟩ が指定された場合、その識別子に一致するパッケージのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="9480ee90d261f8569a157de91547e584915aaf32" translate="yes" xml:space="preserve">
          <source>If any of the allocation functions fails, an exception is thrown. In some cases, memory exhaustion may mean the process is terminated. If &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is applied to a memory area that has been allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, the behaviour is undefined. Any further access to memory areas allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, after the computation that was passed to the allocation function has terminated, leads to undefined behaviour. Any further access to the memory area referenced by a pointer passed to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; entails undefined behaviour.</source>
          <target state="translated">割り当て関数のいずれかが失敗すると、例外がスローされます。場合によっては、メモリ不足が原因でプロセスが終了することがあります。場合は &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; がで割り当てられたメモリ領域に適用される &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; 、動作は未定義です。割り当て関数に渡された計算が終了した後、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; で割り当てられたメモリ領域にさらにアクセスすると、未定義の動作が発生します。任意の更なるに渡されたポインタが参照するメモリ領域へのアクセス &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 伴う動作は未定義。</target>
        </trans-unit>
        <trans-unit id="0e7fd42d0300203e3af493856477c90e7ae13199" translate="yes" xml:space="preserve">
          <source>If any of the quantified type variables has a kind that mentions a kind variable, e.g.</source>
          <target state="translated">量化された型変数のいずれかが kind 変数を言及する kind を持っている場合、例えば</target>
        </trans-unit>
        <trans-unit id="73e0a573c5bd37919b95c361fc7a30bc02d831c3" translate="yes" xml:space="preserve">
          <source>If any of the variables depend on other variables (that is, if some of the variables are &lt;em&gt;kind&lt;/em&gt; variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</source>
          <target state="translated">変数のいずれかが他の変数に依存している場合（つまり、一部の変数が&lt;em&gt;種類&lt;/em&gt;変数である場合）、変数は並べ替えられて、種類変数の前に種類変数が配置され、可能な限り左から右への順序が維持されます。つまり、GHCは変数に対して安定したトポロジカルソートを実行します。例：</target>
        </trans-unit>
        <trans-unit id="f0557de3fe76952756c65625bbfb3066796d428b" translate="yes" xml:space="preserve">
          <source>If both of these conditions are met, GHC will generate this instance:</source>
          <target state="translated">これらの条件の両方が満たされた場合、GHCはこのインスタンスを生成します。</target>
        </trans-unit>
        <trans-unit id="7ce69b4f84d82a5182cf85076110c0eb025eac55" translate="yes" xml:space="preserve">
          <source>If both rules apply to a deriving clause, then &lt;code&gt;anyclass&lt;/code&gt; is used and the user is warned about the ambiguity. The warning can be avoided by explicitly stating the desired deriving strategy.</source>
          <target state="translated">両方のルールが派生句に適用される場合、 &lt;code&gt;anyclass&lt;/code&gt; が使用され、あいまいさについてユーザーに警告されます。警告は、必要な派生戦略を明示的に示すことで回避できます。</target>
        </trans-unit>
        <trans-unit id="1fa898721e2cf3e2c6fc02511763040c586b29a5" translate="yes" xml:space="preserve">
          <source>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; is required, the presence of the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; macro needs to be ensured before it is called, e.g.:</source>
          <target state="translated">&lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; を定義していないHaskellコンパイラ（バージョン7.10.1より前のGHCを含む）との互換性が必要な場合は、 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; マクロの存在を確認してから、それを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="08f60c7543719f4b0441de2debed7ccff9b057ee" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the access time.</source>
          <target state="translated">&lt;code&gt;2.7.0.0&lt;/code&gt; より前のバージョンの &lt;code&gt;unix&lt;/code&gt; に対してコンパイルした場合、この関数は1 秒未満の解像度でタイムスタンプを設定できません。この場合、アクセス時間の精度も失われます。</target>
        </trans-unit>
        <trans-unit id="2ca0ce3ddba01a79e74af5c98436169275d83f0d" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the modification time.</source>
          <target state="translated">&lt;code&gt;2.7.0.0&lt;/code&gt; より前のバージョンの &lt;code&gt;unix&lt;/code&gt; に対してコンパイルした場合、この関数は1 秒未満の解像度でタイムスタンプを設定できません。この場合、修正時間の精度も失われます。</target>
        </trans-unit>
        <trans-unit id="76a5f02902c36d5e634fb160347312d3187dcbaf" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-O2&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;-O2&lt;/code&gt; を有効にしてコンパイルした場合、フィールドにはそれぞれ &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="36b6e9b0f077c5045ff320f1e46e64bdc9093838" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-XStrictData&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;-XStrictData&lt;/code&gt; を有効にしてコンパイルした場合、フィールドにはそれぞれ &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="894b0f94836181331c4facb44019c7354d1c68db" translate="yes" xml:space="preserve">
          <source>If compiled without optimization or other language extensions, then the fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">最適化または他の言語拡張なしでコンパイルした場合、フィールドの &lt;code&gt;ExampleConstructor&lt;/code&gt; があります &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; をそれぞれ。</target>
        </trans-unit>
        <trans-unit id="94f0a56741935b56d9657b26b078c93129516f82" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">定義されている場合、 &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; が方程式の最小解になるはずです。</target>
        </trans-unit>
        <trans-unit id="702c4c7f59fbddacdb90bd27f31c03920aeed35e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">定義されている場合、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; が方程式の最小解になるはずです。</target>
        </trans-unit>
        <trans-unit id="13447cdcf1a935f05011fe0f50982abf26334ad9" translate="yes" xml:space="preserve">
          <source>If divisor is zero, &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; is returned</source>
          <target state="translated">除数がゼロの場合、 &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; が返されます</target>
        </trans-unit>
        <trans-unit id="079e039a9d9a2492d984ad6955aa2d617c670ae6" translate="yes" xml:space="preserve">
          <source>If given an explicit &amp;lt;mask&amp;gt;, the &amp;lt;mask&amp;gt; is interpreted as a bitmap that indicates the NUMA nodes on which to run the program. For example, &lt;code&gt;--numa=3&lt;/code&gt; would run the program on NUMA nodes 0 and 1.</source>
          <target state="translated">明示的な&amp;lt;mask&amp;gt;が指定されている場合、&amp;lt;mask&amp;gt;は、プログラムを実行するNUMAノードを示すビットマップとして解釈されます。たとえば、 &lt;code&gt;--numa=3&lt;/code&gt; は、NUMAノード0および1でプログラムを実行します。</target>
        </trans-unit>
        <trans-unit id="5fc002cc69c30cbd42ee3fdd97604037215dd998" translate="yes" xml:space="preserve">
          <source>If given invalid input, an exception will be thrown by the function or continuation where it is encountered.</source>
          <target state="translated">無効な入力が与えられた場合は、それに遭遇した関数または継続によって例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="560a8ee2e174396c52afe392206d8b4e1b326878" translate="yes" xml:space="preserve">
          <source>If given, uses &lt;code&gt;MADV_DONTNEED&lt;/code&gt; instead of &lt;code&gt;MADV_FREE&lt;/code&gt; on platforms where this results in more accurate resident memory usage of the program as shown in memory usage reporting tools (e.g. the &lt;code&gt;RSS&lt;/code&gt; column in &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;htop&lt;/code&gt;).</source>
          <target state="translated">与えられた場合には、用途は &lt;code&gt;MADV_DONTNEED&lt;/code&gt; 代わりに &lt;code&gt;MADV_FREE&lt;/code&gt; プログラムのより正確な常駐メモリ使用量のこの結果は、メモリ使用量のレポートツールに示すように、プラットフォーム上で（例えば &lt;code&gt;RSS&lt;/code&gt; の中欄 &lt;code&gt;top&lt;/code&gt; と &lt;code&gt;htop&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b94f294f89264115630dd884435117d7704777a" translate="yes" xml:space="preserve">
          <source>If hs-boot files are considered distinct from their parent source files, and if a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command &lt;code&gt;ghc -M&lt;/code&gt; will report an error if a cycle is found.</source>
          <target state="translated">hs-bootファイルがそれらの親ソースファイルとは異なると見なされ、 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; インポートがhs-bootファイルを参照すると見なされる場合、モジュールインポートグラフにサイクルがあってはなりません。 &lt;code&gt;ghc -M&lt;/code&gt; コマンドは、サイクルが見つかった場合にエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="cd1bdd645b7861dcf3835e2124b49ce612dfa503" translate="yes" xml:space="preserve">
          <source>If in doubt, don't use this function.</source>
          <target state="translated">疑わしい場合は、この機能を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="d098bda271cdeda0c89226b1f9334177dda1ff17" translate="yes" xml:space="preserve">
          <source>If in doubt, return non-zero, but do make an effort to create the correct answer for small args, since otherwise the performance of &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; will be poor.</source>
          <target state="translated">疑わしい場合はゼロ以外を返しますが、小さい引数の場合は正しい答えを作成するようにしてください。そうしないと、 &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; のパフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="901bbb7f5d809f3c6e6b017688b99e54b9c8c79f" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザーの端末を開けない場合は、ファイル形式の操作を使用して、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; から入力を読み取ります。</target>
        </trans-unit>
        <trans-unit id="2a52cb7490871b7e82db4561834327588e40b349" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザーの端末を開くことができない場合は、ファイル形式の対話を使用して、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; から入力を読み取ります。</target>
        </trans-unit>
        <trans-unit id="49674ddcca37568931ac6e297642bf137c06f0fb" translate="yes" xml:space="preserve">
          <source>If it is heavily used on lists with &lt;code&gt;Widget&lt;/code&gt; keys, you could specialise it as follows:</source>
          <target state="translated">&lt;code&gt;Widget&lt;/code&gt; キーのリストで頻繁に使用される場合は、次のように特殊化できます。</target>
        </trans-unit>
        <trans-unit id="f0edddfba80ac6a09b6665c39b1ef9f0ebf6fbab" translate="yes" xml:space="preserve">
          <source>If it says you&amp;rsquo;re using more than 20% of total time in garbage collecting, then more memory might help: use the &lt;code&gt;-H⟨size⟩&lt;/code&gt; (see &lt;code&gt;-H [⟨size⟩]&lt;/code&gt;) option. Increasing the default allocation area size used by the compiler&amp;rsquo;s RTS might also help: use the &lt;code&gt;+RTS -A⟨size⟩
-RTS&lt;/code&gt; option (see &lt;code&gt;-A ⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">総時間の20％以上をガベージコレクションで使用していると &lt;code&gt;-H⟨size⟩&lt;/code&gt; 場合は、メモリを増やすとよいでしょう。-H⟨size⟩（ &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; 参照）オプションを使用します。コンパイラのRTSで使用されるデフォルトの割り当て領域サイズを増やすと、 &lt;code&gt;+RTS -A⟨size⟩ -RTS&lt;/code&gt; オプションを使用することもできます（ &lt;code&gt;-A ⟨size⟩&lt;/code&gt; 参照）。</target>
        </trans-unit>
        <trans-unit id="205fa22c0cf21d40cd9db8045e7c70a4db4f3ae2" translate="yes" xml:space="preserve">
          <source>If it uses terminal-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; will be read from the user's &lt;code&gt;~/.haskeline&lt;/code&gt; file (if present). If it uses file-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; are not relevant and will not be read.</source>
          <target state="translated">それは、端末スタイルの相互作用を使用している場合、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 、ユーザーのから読み込まれます &lt;code&gt;~/.haskeline&lt;/code&gt; ファイル（存在する場合）。それはファイル形式の相互作用を使用している場合、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; 関係ありませんと読まれることはありません。</target>
        </trans-unit>
        <trans-unit id="48a69ac0f3095acb072ddfcfb9a6bdffd564f050" translate="yes" xml:space="preserve">
          <source>If more than one non-incoherent candidate remains, the search fails.</source>
          <target state="translated">非一貫性のある候補が複数残っている場合は、検索に失敗します。</target>
        </trans-unit>
        <trans-unit id="092903c3946d9ebf1026389c3dca1af41e4be180" translate="yes" xml:space="preserve">
          <source>If more than one rule matches a call, GHC will choose one arbitrarily to apply.</source>
          <target state="translated">複数のルールが呼にマッチした場合、GHCは任意に1つのルールを選択して適用します。</target>
        </trans-unit>
        <trans-unit id="46c551abf7dfa66ea7e6819fd50f9537ead8ac62" translate="yes" xml:space="preserve">
          <source>If multiple CodingProgress returns are possible, OutputUnderflow must be preferred to InvalidSequence. This allows GHC's IO library to assume that if we observe InvalidSequence there is at least a single element available in the output buffer.</source>
          <target state="translated">複数の CodingProgress が返される可能性がある場合、OutputUnderflow は InvalidSequence よりも優先されなければなりません。これにより、GHC の IO ライブラリは、もし InvalidSequence を観測した場合、出力バッファには少なくとも 1 つの要素が利用可能であると仮定することができます。</target>
        </trans-unit>
        <trans-unit id="7c993cec0b4151ad1b0f5562c270a5895e49c59e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for datatypes where each constructor has just zero or one field, in particular for enumeration types.</source>
          <target state="translated">いいえの場合 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 列挙型のための特定の各コンストラクタは単に、ゼロまたは1つのフィールドを持つデータ型、のインスタンスが指定されていない、機能があり、まだ仕事。</target>
        </trans-unit>
        <trans-unit id="777411d8c4bf9b9216adcc59bd1260d805fb12f9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for empty datatypes or datatypes that have a single constructor, but will fail on datatypes with more than one constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合、関数は空のデータ型または単一のコンストラクターを持つデータ型に対して機能しますが、複数のコンストラクターを持つデータ型では失敗します。</target>
        </trans-unit>
        <trans-unit id="076b26677e1e9d94d1e31f006635bd3641fcc733" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for enumeration types, where no constructor has any fields.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合でも、コンストラクターがフィールドを持たない列挙型に対して関数は機能します。</target>
        </trans-unit>
        <trans-unit id="db076b7e62e1c825a47aaaf3a5ab3a6b5fbdafa9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype where each constructor has at least one field.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合でも、関数は、各コンストラクターに少なくとも1つのフィールドがある任意のデータ型で機能します。</target>
        </trans-unit>
        <trans-unit id="1606eb80e1c8dfc4c88130f2d2acd1efbbfc995e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype that is not empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; インスタンスが指定されていない場合、関数は空でないデータ型に対して機能する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c4b3a7948164a4bece210a1698cfedabc51fc766" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;MINIMAL&lt;/code&gt; pragma is given in the class declaration, it is just as if a pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; was given, where the &lt;code&gt;opi&lt;/code&gt; are the methods that lack a default method in the class declaration (c.f. &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wmissing-methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">クラス宣言で &lt;code&gt;MINIMAL&lt;/code&gt; プラグマが指定されていない場合、それはプラグマ &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; が指定された場合と同じです。ここで、 &lt;code&gt;opi&lt;/code&gt; は、クラス宣言（&lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wmissing-methods&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告および&lt;/a&gt;正常性チェックを参照）。</target>
        </trans-unit>
        <trans-unit id="6558b92d136aeb7b89c5f372133e67b42639edb6" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;default&lt;/code&gt; declaration is given, then it is just as if the module contained the declaration &lt;code&gt;default( Integer, Double, String)&lt;/code&gt;.</source>
          <target state="translated">いいえの場合 &lt;code&gt;default&lt;/code&gt; 宣言が指定されていない、それはモジュールが宣言含まれているかのようである &lt;code&gt;default( Integer, Double, String)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="784b5f99e839f7b12ec2093256b70c6cad4b74c2" translate="yes" xml:space="preserve">
          <source>If no candidates remain, the search failes</source>
          <target state="translated">候補者が残っていない場合、検索は失敗します。</target>
        </trans-unit>
        <trans-unit id="9192657645342fee69fd524510551ad47221178f" translate="yes" xml:space="preserve">
          <source>If no export list is provided for a signature, the exports of a signature are all of its defined entities merged with the exports of all inherited signatures.</source>
          <target state="translated">署名のエクスポートリストが提供されていない場合、署名のエクスポートは、定義されているすべてのエンティティを、継承されているすべての署名のエクスポートとマージしたものになります。</target>
        </trans-unit>
        <trans-unit id="e6ff16fc0e935cafc45afe04c519a876483f5dcb" translate="yes" xml:space="preserve">
          <source>If no inlining takes place, the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; function expands to the identity function in Phase zero, so its use imposes no overhead.</source>
          <target state="translated">何のインライン化が行われない場合は、 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; 関数は、オーバーヘッドその使用課して、フェーズ0のID機能に展開されていません。</target>
        </trans-unit>
        <trans-unit id="09340baa4f1fe5048c9542d16a391d2e3eb6f959" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">モードフラグが存在しない場合、コマンドラインで指定されたHaskellソースファイルがある場合、GHCは&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モードに入り（&lt;a href=&quot;#make-mode&quot;&gt;ghc &amp;ndash;makeを使用&lt;/a&gt;）、そうでない場合、コマンドラインで指定されたオブジェクトをリンクして実行可能ファイルを生成します。 。</target>
        </trans-unit>
        <trans-unit id="2c70bd69294b761a98eab2c97c782c7a594740e3" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">モードフラグが存在しない場合、コマンドラインで指定されたHaskellソースファイルがある場合、GHCは&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モード（&lt;a href=&quot;#make-mode&quot;&gt;ghc --makeを使用&lt;/a&gt;）に入ります。そうでない場合は、コマンドラインで指定されたオブジェクトをリンクして、実行可能。</target>
        </trans-unit>
        <trans-unit id="545b39aee7ff9dd8868144c774e3a1c54c9f14dd" translate="yes" xml:space="preserve">
          <source>If no quantified constraints match, look up in the global instances, as described in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt; and &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;.</source>
          <target state="translated">定量化された制約が一致しない場合は、&lt;a href=&quot;#instance-resolution&quot;&gt;インスタンスの解決&lt;/a&gt;と&lt;a href=&quot;#instance-overlap&quot;&gt;インスタンスの重複で&lt;/a&gt;説明されているように、グローバルインスタンスを検索します。</target>
        </trans-unit>
        <trans-unit id="8910a1e7567042e5831890a8c1459a75e51e378b" translate="yes" xml:space="preserve">
          <source>If not, look at all the available given quantified constraints; if exactly one one matches &lt;code&gt;C t&lt;/code&gt;, choose it; if more than one matches, report an error.</source>
          <target state="translated">そうでない場合は、利用可能なすべての定量化された制約を調べます。1つだけが &lt;code&gt;C t&lt;/code&gt; と一致する場合は、それを選択します。一致するものが複数ある場合は、エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="0c47246abbeffab64ebd4d936953fd4c7c077f74" translate="yes" xml:space="preserve">
          <source>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</source>
          <target state="translated">省略した場合、⟨n⟩ および ⟨m⟩ は、それぞれ最初または最後に利用可能な完了候補にデフォルトで設定されます。範囲引数で要求された数よりも少ない候補がある場合、⟨n⟩と⟨m⟩は、利用可能な補完候補の数に暗黙的に上限が設定されます。</target>
        </trans-unit>
        <trans-unit id="43110c483674fe00877c4157e9200eb8ff216c7b" translate="yes" xml:space="preserve">
          <source>If one input list is short, excess elements of the longer list are discarded:</source>
          <target state="translated">1つの入力リストが短い場合、長い方のリストの余分な要素は破棄されます。</target>
        </trans-unit>
        <trans-unit id="bae8b4e0fe43800691134bf9658ff55ae4812650" translate="yes" xml:space="preserve">
          <source>If one were to attempt to derive a Generic instance for a datatype with an unlifted argument (for example, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;), one might expect the occurrence of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; argument to be marked with &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;. This won't work, though, since &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; is of an unlifted kind, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; expects a type of kind &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">リフトされていない引数（たとえば、 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; ）を使用してデータ型のGenericインスタンスを導出しようとした場合、 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 引数の発生が &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; でマークされることが予想されます。ただし、 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; は持ち上げられていない種類であり、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; は種類 &lt;code&gt;*&lt;/code&gt; の種類を想定しているため、これは機能しません。</target>
        </trans-unit>
        <trans-unit id="ff1ad15ce25abb2710fa65ecce3a62a8bb2f9029" translate="yes" xml:space="preserve">
          <source>If platform does not provide &lt;code&gt;posix_fadvise(2)&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; becomes a no-op.</source>
          <target state="translated">プラットフォームが提供されていない場合は &lt;code&gt;posix_fadvise(2)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; は無操作になりません。</target>
        </trans-unit>
        <trans-unit id="3e3eb88d6d752aea988ad952a71154c1d162a5df" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="translated">可能であれば、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; は直接使用されます（つまり、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; を新しく割り当てられたものに複製&lt;em&gt;せずに&lt;/em&gt;共有されます）</target>
        </trans-unit>
        <trans-unit id="e2fd0fc4ca5ca1f4279bebce52029854ce0a49ff" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="translated">可能な場合は &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; が直接使用されます（つまり、新しく割り当てられた &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; にByteArray＃を複製&lt;em&gt;せずに&lt;/em&gt;共有されます）</target>
        </trans-unit>
        <trans-unit id="a02a08bcb120a182f93778d549b78999be975134" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, &amp;hellip;</source>
          <target state="translated">プロファイリングが特定の機能に指を向けている場合は、それらのコアコードを確認してください。 &lt;code&gt;lets&lt;/code&gt; 悪いです、 &lt;code&gt;cases&lt;/code&gt; 良い、辞書（ある &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; ）か何かの過負荷っぽい]悪いです、ネストされたラムダが悪い、明示的なデータコンストラクタは良いですが、基本操作（例えば、 &lt;code&gt;eqInt#&lt;/code&gt; ）です良い、 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="52cc4cf0d03d5edea947b7488d65fce86a4331f7" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, ...</source>
          <target state="translated">プロファイリングによって特定の関数が特定された場合は、それらのコアコードを確認してください。 &lt;code&gt;lets&lt;/code&gt; 、悪い &lt;code&gt;cases&lt;/code&gt; 良い、辞書（ある &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; 悪い、ネストされたラムダが悪いです）か何かの過負荷っぽい]、明示的なデータ構成子は良い、基本操作（例えば、ある &lt;code&gt;eqInt#&lt;/code&gt; です）良い、 ...</target>
        </trans-unit>
        <trans-unit id="a9f317cd94e7a84b9481c4cd3410991be028a616" translate="yes" xml:space="preserve">
          <source>If recursive bindings are required for a monad, then that monad must be declared an instance of the &lt;code&gt;MonadFix&lt;/code&gt; class.</source>
          <target state="translated">モナドに再帰的バインディングが必要な場合、そのモナドは &lt;code&gt;MonadFix&lt;/code&gt; クラスのインスタンスとして宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="65bff50aaf133e46c4c389202fbe2fead3ced4d7" translate="yes" xml:space="preserve">
          <source>If right-to-left evaluation is required, the input list should be reversed.</source>
          <target state="translated">右から左への評価が必要な場合は、入力リストを逆にする必要があります。</target>
        </trans-unit>
        <trans-unit id="edfe3ca7d56d7c40b077f20b07320acbb2603c62" translate="yes" xml:space="preserve">
          <source>If some of the rows are shorter than the following rows, their elements are skipped:</source>
          <target state="translated">一部の行が次の行より短い場合、その要素はスキップされます。</target>
        </trans-unit>
        <trans-unit id="a471137408c37fe4b26bd411d1c9b91c60232b56" translate="yes" xml:space="preserve">
          <source>If such a package environment is found, it is equivalent to passing these command line arguments to &lt;code&gt;ghc&lt;/code&gt;:</source>
          <target state="translated">そのようなパッケージ環境が見つかった場合、これらのコマンドライン引数を &lt;code&gt;ghc&lt;/code&gt; に渡すことと同じです。</target>
        </trans-unit>
        <trans-unit id="100bc4626b0efab2c2dfa95a3d57f85130c6e4b0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;a href=&quot;#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">&lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;イベントログ&lt;/a&gt;が有効になっている場合（&lt;a href=&quot;#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt;ランタイムシステムフラグを使用）、ヒープサンプルがGHCイベントログに追加で&lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;出力さ&lt;/a&gt;れます（イベント形式の詳細については、ヒーププロファイラーのイベントログ出力を参照してください）。</target>
        </trans-unit>
        <trans-unit id="4364a4035c9b8cd510cf366346a071ecc7512c6e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">&lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;イベントログ&lt;/a&gt;が有効になっている場合（ &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; ランタイムシステムフラグを使用）、ヒープサンプルがGHCイベントログに追加で発行されます（イベント形式の詳細については、&lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;ヒーププロファイラーイベントログの出力&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="984396ef6b346f6f5a141f1b3cc9c98c57b40449" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt;&lt;code&gt;-Wunused-foralls&lt;/code&gt;&lt;/a&gt; flag is enabled, a warning will be emitted when you write a type variable in an explicit &lt;code&gt;forall&lt;/code&gt; statement that is otherwise unused. For instance:</source>
          <target state="translated">場合&lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt; &lt;code&gt;-Wunused-foralls&lt;/code&gt; の&lt;/a&gt;フラグが有効になっているあなたは、明示的に型変数を記述する際に、警告が発せられることになる &lt;code&gt;forall&lt;/code&gt; はそうでない場合は未使用である声明。例えば：</target>
        </trans-unit>
        <trans-unit id="67067af8a67e4c0ac00744d32ff51787c4c23ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;*&lt;/code&gt; symbol is placed before the module name, then &lt;em&gt;all&lt;/em&gt; the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 記号がモジュール名の前に配置されている場合は、「エクスポート」ではなく、「モジュール」のスコープ内の&lt;em&gt;すべて&lt;/em&gt;の識別子が表示されます。</target>
        </trans-unit>
        <trans-unit id="6c7426ed03e0cc31e14922c9ce2a60b1c4a4d18a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-rtsopts&lt;/code&gt; flag is set to something other than &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;ignoreAll&lt;/code&gt; when linking, RTS options are also taken from the environment variable &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt;. For example, to set the maximum heap size to 2G for all GHC-compiled programs (using an &lt;code&gt;sh&lt;/code&gt;-like shell):</source>
          <target state="translated">場合 &lt;code&gt;-rtsopts&lt;/code&gt; フラグが以外に設定されて &lt;code&gt;none&lt;/code&gt; か &lt;code&gt;ignoreAll&lt;/code&gt; リンクする際に、RTSオプションも環境変数から取得され&lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt;。たとえば、GHでコンパイルされたすべてのプログラムの最大ヒープサイズを2Gに設定するには（ &lt;code&gt;sh&lt;/code&gt; のようなシェルを使用）：</target>
        </trans-unit>
        <trans-unit id="ee47e204ad25ad75b90f894519d743cd373d5ec1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; is not found returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; が見つからない場合は &lt;code&gt;Nothing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1eecdf1765fe1b5c7a149e43f46aee92b76c9e9d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is a relative path, then for every search directory &lt;code&gt;dir&lt;/code&gt;, the function checks whether &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; exists and satisfies the predicate. If so, &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; is returned as one of the results. In other words, the returned paths can be either relative or absolute depending on the search directories were used. If there are no search directories, no results are ever returned.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; が相対パスの場合、すべての検索ディレクトリ &lt;code&gt;dir&lt;/code&gt; について、関数は &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; が存在するかどうかをチェックし、述語を満たします。その場合、結果の1つとして &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; が返されます。つまり、返されたパスは、使用された検索ディレクトリに応じて、相対パスまたは絶対パスになります。検索ディレクトリがない場合、結果は返されません。</target>
        </trans-unit>
        <trans-unit id="7e66c7a66ac7c32b8ef7f9ce828408309a2951cf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is an absolute path, then the function will return a single result if the file exists and satisfies the predicate and no results otherwise. This is irrespective of what search directories were given.</source>
          <target state="translated">場合 &lt;code&gt;name&lt;/code&gt; 絶対パスであるファイルが他の述語とない結果が存在すると満たしている場合、この関数は、単一の結果を返します。これは、指定された検索ディレクトリとは無関係です。</target>
        </trans-unit>
        <trans-unit id="95e84cba36edfb057e05285c58d1b651c2f290d8" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; にラップされたI / O計算が副作用を実行する場合、それらの副作用が発生する相対的な順序（メインI / Oトランク、または &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; への他の呼び出しに対して）は不確定です。さらに、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用して副作用を引き起こす場合は、次の予防策を講じて、副作用が期待どおりの回数だけ実行されるようにする必要があります。これらの予防策はGHCに必要ですが、十分ではない場合があり、他のコンパイラーは異なる予防策を必要とする場合があることに注意してください：</target>
        </trans-unit>
        <trans-unit id="95557e9796ad5018f234723793eebbd659062bdd" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; にラップされたI / O計算が副作用を実行する場合、それらの副作用が発生する相対的な順序（メインI / Oトランク、または &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; への他の呼び出しに対して）は不確定です。さらに、 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用して副作用を引き起こす場合は、次の予防策を講じて、副作用が期待どおりの回数だけ実行されるようにする必要があります。これらの予防策はGHCに必要ですが、十分ではない場合があり、他のコンパイラーは異なる予防策を必要とする場合があることに注意してください：</target>
        </trans-unit>
        <trans-unit id="f37fb4ee444bede274c669b4d448a3acdb65fb55" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; にラップされたI / O計算が副作用を実行する場合、それらの副作用が発生する相対的な順序（メインI / Oトランク、または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; への他の呼び出しに対して）は不確定です。さらに、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用して副作用を引き起こす場合は、次の予防策を講じて、副作用が期待どおりの回数だけ実行されるようにする必要があります。これらの予防策はGHCに必要ですが、十分ではない場合があり、他のコンパイラーは異なる予防策を必要とする場合があることに注意してください：</target>
        </trans-unit>
        <trans-unit id="916aaf70159a57842ced3963dcd6e37575d65a6b" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; の引数が &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="c74b7c9262440ab8eb34e0a6d3d1e23753614271" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">バッファモードから変更された場合 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; 、その後、</target>
        </trans-unit>
        <trans-unit id="eb44311b2b43303ecd2e4401810f83b01105af2e" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">バッファモードから変更された場合 &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; 、その後、</target>
        </trans-unit>
        <trans-unit id="340506b1fc7cfecd1cc706b1ed0b444cb860cf41" translate="yes" xml:space="preserve">
          <source>If the computation is to modify the stored information, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">格納された情報を変更するための計算の場合は、代わりに&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="4c240367cda084253143432ddcf60bf0b03fa3e5" translate="yes" xml:space="preserve">
          <source>If the constraint solver encounters a constraint &lt;code&gt;HasField x r a&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is a concrete datatype with a field &lt;code&gt;x&lt;/code&gt; in scope, it will automatically solve the constraint using the field selector as the dictionary, unifying &lt;code&gt;a&lt;/code&gt; with the type of the field if necessary. This happens irrespective of which extensions are enabled.</source>
          <target state="translated">制約ソルバ遭遇A制約場合 &lt;code&gt;HasField x r a&lt;/code&gt; ここで &lt;code&gt;r&lt;/code&gt; はフィールドコンクリートデータ型である &lt;code&gt;x&lt;/code&gt; の範囲で、それは自動的に統一、辞書としてフィールドセレクタを使用して、制約を解決する必要に応じてフィールドのタイプと。これは、有効になっている拡張機能に関係なく発生します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac5d0fe1d7acda30fb0ec5a56697651c36a28ef" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; はコンストラクタの中置アプリケーションを生成します。</target>
        </trans-unit>
        <trans-unit id="bc73951c5c10ca78ae5366f259e7017f69544b8f" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; はコンストラクタの中置アプリケーションを生成します。</target>
        </trans-unit>
        <trans-unit id="9a11dfd9c83245d6ba417f9310e69a934f255b67" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; はコンストラクタの中置アプリケーションを生成します。</target>
        </trans-unit>
        <trans-unit id="7340551eb65b17d80f26730fb4f3289da8692a48" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、コンストラクタの中置アプリケーションのみを解析します（プレフィックス形式ではありません）。</target>
        </trans-unit>
        <trans-unit id="a7834f177091806c3787fe742b48954a28d269ce" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、コンストラクタの中置アプリケーションのみを解析します（プレフィックス形式ではありません）。</target>
        </trans-unit>
        <trans-unit id="fff881ab5c74b90094d3fe1033075847bf7fe644" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">コンストラクタが中置演算子として定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、コンストラクタの中置アプリケーションのみを解析します（プレフィックス形式ではありません）。</target>
        </trans-unit>
        <trans-unit id="a24a3dfbd521f865d8c41e8577fde1211e1662ee" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">コンストラクタがレコード構文を使用して定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; はレコード構文形式のみを解析し、さらに、フィールドは元の宣言と同じ順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d9cae460cd107a842e94f70119834c39ecbdb71b" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">コンストラクタがレコード構文を使用して定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; はレコード構文形式のみを解析し、さらに、フィールドは元の宣言と同じ順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b45481ebece8ce7cdca4efa8d7e24867db92404c" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">コンストラクタがレコード構文を使用して定義されている場合、派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; はレコード構文形式のみを解析し、さらに、フィールドは元の宣言と同じ順序で指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="7dfb1a85a710e73bec4ed69a3c877abb78023f39" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">コンストラクターがレコード構文を使用して定義されている場合、 &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; はフィールドが元の宣言と同じ順序で指定されたレコード構文形式を生成します。</target>
        </trans-unit>
        <trans-unit id="b1a05487843b471ffa877f4ad69c2c7e4d703688" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">コンストラクターがレコード構文を使用して定義されている場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; はフィールドが元の宣言と同じ順序で指定されたレコード構文形式を生成します。</target>
        </trans-unit>
        <trans-unit id="0b96127742ffe03893d0e4f936b677e699812df7" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">コンストラクターがレコード構文を使用して定義されている場合、 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; はフィールドが元の宣言と同じ順序で指定されたレコード構文形式を生成します。</target>
        </trans-unit>
        <trans-unit id="915369447c441596818ea47cd1848a5ce0c1bbc6" translate="yes" xml:space="preserve">
          <source>If the derived instance were allowed, what would the type of its method &lt;code&gt;bad&lt;/code&gt; be? It would seem to be &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt;, which is equivalent to &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt;, according to the type family &lt;code&gt;Inspect&lt;/code&gt;. Yet, if we simply adapt the implementation from the instance for &lt;code&gt;Int&lt;/code&gt;, the implementation for &lt;code&gt;bad&lt;/code&gt; produces a &lt;code&gt;Bool&lt;/code&gt;, and we have trouble.</source>
          <target state="translated">派生したインスタンスが許可された場合は、そのメソッドの種類何を考え &lt;code&gt;bad&lt;/code&gt; こと？それはあるように見えるでしょう &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt; に相当し、 &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt; 、種類に応じて家族 &lt;code&gt;Inspect&lt;/code&gt; 。しかし、 &lt;code&gt;Int&lt;/code&gt; のインスタンスの実装を単純に適合させると、 &lt;code&gt;bad&lt;/code&gt; の実装は &lt;code&gt;Bool&lt;/code&gt; を生成し、問題が発生します。</target>
        </trans-unit>
        <trans-unit id="99dd79a68e6ace7bc36818530a36dff1b61996fd" translate="yes" xml:space="preserve">
          <source>If the elements are ordered, a linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要素が順序付けられている場合は、線形時間の実装が使用され、パフォーマンスは &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="7ffe9c900b23c1f743c980afb39a54b09a15873e" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is set, and its value does not end in a separator (&lt;code&gt;:&lt;/code&gt; on Unix, &lt;code&gt;;&lt;/code&gt; on Windows), then the last database is considered to be the global database, and will be modified by default by &lt;code&gt;ghc-pkg&lt;/code&gt;. The intention here is that &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; can be used to create a virtual package environment into which Cabal packages can be installed without setting anything other than &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;.</source>
          <target state="translated">環境変数の場合は&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; が&lt;/a&gt;設定され、その値は、セパレータには終わらない（ &lt;code&gt;:&lt;/code&gt; Unix上で、 &lt;code&gt;;&lt;/code&gt; Windowsの場合）、そして最後のデータベースは、グローバル・データベースであると考えられ、およびにより、デフォルトでは変更される &lt;code&gt;ghc-pkg&lt;/code&gt; 。ここでの意図は、 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; を使用して、 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 以外を設定せずにCabalパッケージをインストールできる仮想パッケージ環境を作成できることです。</target>
        </trans-unit>
        <trans-unit id="55d64c16a458e52bfe82101c17b8bb95dd2a0fb1" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">例外が &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の内部でキャッチされない場合、例外は &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; によって再スローされ、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 全体がロールバックされます。</target>
        </trans-unit>
        <trans-unit id="0f96e8b63db707eb0457ade29de32d3c2df84734" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">例外が &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の内部でキャッチされない場合、例外は &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; によって再スローされ、 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 全体がロールバックされます。</target>
        </trans-unit>
        <trans-unit id="c2dff9269612b6f615c400bd3a6c96cd41d71ec5" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">例外が &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; の内部でキャッチされない場合、例外は &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; によって再スローされ、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 全体がロールバックされます。</target>
        </trans-unit>
        <trans-unit id="1b31e706b20ca1dd226c814726e8413042889a0f" translate="yes" xml:space="preserve">
          <source>If the expression was instead of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;it&lt;/code&gt; will be bound to the result of the &lt;code&gt;IO&lt;/code&gt; computation, which is of type &lt;code&gt;a&lt;/code&gt;. eg.:</source>
          <target state="translated">表現ではなくタイプであった場合は &lt;code&gt;IO a&lt;/code&gt; いくつかのために &lt;code&gt;a&lt;/code&gt; 、そして &lt;code&gt;it&lt;/code&gt; 結果にバインドされる &lt;code&gt;IO&lt;/code&gt; のタイプのものであり、計算、 &lt;code&gt;a&lt;/code&gt; 。例えば。：</target>
        </trans-unit>
        <trans-unit id="557b536a62aea491508b3f277f7c66ebafe8f737" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">ファイルが存在せず、出力用に開かれている場合は、新しいファイルとして作成する必要があります。場合 &lt;code&gt;mode&lt;/code&gt; あり &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 、ファイルがすでに存在している、それはゼロの長さに切り詰めする必要があります。一部のオペレーティング・システムでは、ので、ファイルには、以下の存在するという保証はありません、空のファイルを削除する &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; それが無事に書き込まれていない限りは。 &lt;code&gt;mode&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; の場合、ハンドルはファイルの末尾に配置されます。それ以外の場合、先頭に配置されます（この場合、内部位置は0です）。初期バッファモードは実装に依存します。</target>
        </trans-unit>
        <trans-unit id="8bdafef8b919def741e21f11e5c61515c31e3d40" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">ファイルが存在せず、出力用に開かれている場合は、新しいファイルとして作成する必要があります。場合 &lt;code&gt;mode&lt;/code&gt; あり &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; 、ファイルがすでに存在している、それはゼロの長さに切り詰めする必要があります。一部のオペレーティング・システムでは、ので、ファイルには、以下の存在するという保証はありません、空のファイルを削除する &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; それが無事に書き込まれていない限りは。 &lt;code&gt;mode&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; の場合、ハンドルはファイルの末尾に配置されます。それ以外の場合、先頭に配置されます（この場合、内部位置は0です）。初期バッファモードは実装に依存します。</target>
        </trans-unit>
        <trans-unit id="8848ff01b8a32afcddff36cec08d4b6728717d85" translate="yes" xml:space="preserve">
          <source>If the final statement is not of one of these forms, GHC falls back to standard &lt;code&gt;do&lt;/code&gt; desugaring, and the expression will require a &lt;code&gt;Monad&lt;/code&gt; constraint.</source>
          <target state="translated">最後の文は、これらのいずれかの形式でない場合は、GHCはバック標準にフォール &lt;code&gt;do&lt;/code&gt; 脱糖、および式が必要になります &lt;code&gt;Monad&lt;/code&gt; 制約を。</target>
        </trans-unit>
        <trans-unit id="99750cf8581988661447b877b8a2ef2af75d98f8" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">最初のアクションが再試行なしで完了すると、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; の結果が形成されます。そうでない場合、最初のアクションが再試行すると、代わりに2番目のアクションが試行されます。両方のアクションが再試行する場合、 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; は全体として再試行します。</target>
        </trans-unit>
        <trans-unit id="c3b9d8e821fceed6649d1fb75df70e0b3ecb6ca6" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">最初のアクションが再試行なしで完了すると、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; の結果が形成されます。そうでない場合、最初のアクションが再試行すると、代わりに2番目のアクションが試行されます。両方のアクションが再試行する場合、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; は全体として再試行します。</target>
        </trans-unit>
        <trans-unit id="29e53de7a23bc55e53e1793d6fcc64937e975381" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">最初のアクションが再試行なしで完了すると、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; の結果が形成されます。そうでない場合、最初のアクションが再試行すると、代わりに2番目のアクションが試行されます。両方のアクションが再試行する場合、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; は全体として再試行します。</target>
        </trans-unit>
        <trans-unit id="0a17c36982066985bf53c44ca7e61aeacd02ae41" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最初の引数が &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; に評価される場合、結果は2番目の引数になります。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; 例外が発生し、ソースファイルと &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; を呼び出す行番号を含む &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="feb4f24ce87f487be05ef1c288b600a60dcbf5bb" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最初の引数が &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; に評価される場合、結果は2番目の引数になります。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; 例外が発生し、ソースファイルと &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; を呼び出す行番号を含む &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="d0054b769e95e245513b766b41dc0a78a5fa0e67" translate="yes" xml:space="preserve">
          <source>If the first completer produces no suggestions, fallback to the second completer's output.</source>
          <target state="translated">最初のコンプリタが提案を生成しない場合は、2 番目のコンプリタの出力にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="7d227d6371173673bc113bcadb48246870a816fc" translate="yes" xml:space="preserve">
          <source>If the first list contains duplicates, so will the result.</source>
          <target state="translated">最初のリストに重複が含まれている場合は、その結果も同様になります。</target>
        </trans-unit>
        <trans-unit id="8f303f44f15d67e9e20a0ff01c05b8e471995e19" translate="yes" xml:space="preserve">
          <source>If the first list is not finite, the result is the first list.</source>
          <target state="translated">最初のリストが有限でない場合、結果は最初のリストになります。</target>
        </trans-unit>
        <trans-unit id="fabb69bed587314beb9edec19efed156d82f6d0c" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; が複数のパラメーターをとる場合、型変数 &lt;code&gt;b&lt;/code&gt; は、（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターへの追加パーサー &lt;code&gt;p&lt;/code&gt; とうまく結合する関数型にインスタンス化されます。これにより、置換パーサーが結合関数 &lt;code&gt;f&lt;/code&gt; で始まり、その後にパーサーが続く、様式化されたコードが生成されます。関数 &lt;code&gt;f&lt;/code&gt; は、パーサーが指定された順序でパラメーターを取得しますが、実際の入力は任意の順序にすることができます。</target>
        </trans-unit>
        <trans-unit id="5eb94185e7818eb4718538187db5c7b4cbfd254a" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; が複数のパラメーターをとる場合、型変数 &lt;code&gt;b&lt;/code&gt; は、（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターへの追加パーサー &lt;code&gt;p&lt;/code&gt; とうまく結合する関数型にインスタンス化されます。これにより、置換パーサーが結合関数 &lt;code&gt;f&lt;/code&gt; で始まり、その後にパーサーが続く、様式化されたコードが生成されます。関数 &lt;code&gt;f&lt;/code&gt; は、パーサーが指定された順序でパラメーターを取得しますが、実際の入力は任意の順序にすることができます。</target>
        </trans-unit>
        <trans-unit id="c0bf34eec193f2a121ba6f174b48d6e08e32c420" translate="yes" xml:space="preserve">
          <source>If the function isn&amp;rsquo;t exported, just compile with the extra flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;; next to the signature for any binder, it will print the self-same pragmatic information as would be put in an interface file. (Besides, Core syntax is fun to look at!)</source>
          <target state="translated">関数がエクスポートされない場合は、追加のフラグ&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; を使用&lt;/a&gt;してコンパイルしてください。バインダーの署名の横に、インターフェースファイルに入力されるのと同じ実用的な情報が出力されます。（さらに、コア構文は見るのが楽しいです！）</target>
        </trans-unit>
        <trans-unit id="79369b89e6cd5dd14719075c040fa3bcd79b2c7d" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="96d21b1729033749751e04b2041b55e92dac94b3" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="733eefc07bf9e51bd55cbb49b0874fcb5f17d31b" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="75a38fbd33678c8e1ac4ad25b0d95cd894290536" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="eb6e0e76a190f2043a8bd3777daebaebf1def2ab" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="ac14468e0ab875750716201383acedb0f1aa59a2" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="4758d777c012362f6479362e01995e935a7b09ed" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="43a808de4e438b2cac191975ec1178b82376b0eb" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="695c3d916d62f2ea55cdb779edc67a44a1f3c788" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="c9752d59da062f75442fd0c45b415851963415b0" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="c2f82e3a8d0be8d48a4f40713cb2d9fb06f2e221" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">ハンドルがパイプまたはソケットであり、書き込み側が閉じている場合、 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; はEOFに到達したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="2eb52b41e41c616d22190f5e23f9b5d53c5c8fa6" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="translated">ハンドラーが &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; でラップされた値を返す場合、その値は無効な入力の代わりとして出力で使用されます。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返す場合、出力では値は使用されません。</target>
        </trans-unit>
        <trans-unit id="143a66f1c372e18e95e27d43959e9296bc2e9da0" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="translated">ハンドラーが &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; でラップされた値を返す場合、その値は無効な入力の代わりとして出力で使用されます。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返す場合、出力で値は使用されません。</target>
        </trans-unit>
        <trans-unit id="fe922e3d119fe0f1cc74a44c92d349bcf461e892" translate="yes" xml:space="preserve">
          <source>If the initial buffer is too small to hold all data, subsequent buffers will be the default buffer size.</source>
          <target state="translated">初期バッファが小さすぎてすべてのデータを保持できない場合、それ以降のバッファはデフォルトのバッファサイズになります。</target>
        </trans-unit>
        <trans-unit id="1a8e4480bef91d631c461344a2de2236d4cfee75" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown (either by this function or a continuation) that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なUTF-8データが含まれている場合、純粋なコードではキャッチできない例外が（この関数または継続によって）スローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bd132895bcb29067d5281e312732641ade69617a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なUTF-8データが含まれている場合、純粋なコードでキャッチできない例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f6f85b42e97d38521695bc5719fab602af715f74" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なUTF-8データが含まれている場合、純粋なコードでキャッチできない例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="09b23031b09a6ace4ba4f6ac224b740e40f02c57" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, the relevant exception will be returned, otherwise the decoded text.</source>
          <target state="translated">入力に無効な UTF-8 データが含まれている場合は、該当する例外が返され、そうでない場合は復号化されたテキストが返されます。</target>
        </trans-unit>
        <trans-unit id="754415b1a59c2ab620f6ecdfc36468a832eed47d" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="24a4190d0c5a617251a227f4e4ffc0dc4c3ec80e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a938f8cb41602c2e37ba21b2b1d159bacbe79e60" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="e0a0fd29f327678893fbe7d2c540d1bfc2f81f6e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なビッグエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をさらに制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="64bf7ac928bb9d8d34aaf3441fc5265800b5a9d5" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="de1b7df55ab6d8158aa8cf994eaac1e0b9224b7e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-16データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="70c2f670f171baeb0231536712051cb1c8aaf33a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c26edc2ab81f9a20a2fa34e0b70f9dd71e74d9ab" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力に無効なリトルエンディアンUTF-32データが含まれている場合、例外がスローされます。無効なデータの処理をより詳細に制御するには、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="5d43fcf632f6993095dae2aeab0f213b43767b8e" translate="yes" xml:space="preserve">
          <source>If the key exists in the map, this function is lazy in &lt;code&gt;value&lt;/code&gt; but strict in the result of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">キーがマップに存在する場合、この関数の &lt;code&gt;value&lt;/code&gt; は遅延しますが、 &lt;code&gt;f&lt;/code&gt; の結果は厳密です。</target>
        </trans-unit>
        <trans-unit id="625b4beded575a88ac5daec835ba706a687d2bcb" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リストのキーが順序付けられている場合、線形時間の実装が使用され、パフォーマンスは &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="b1448f4c78b74e05628456296d2ae49ddecc501e" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リストのキーが順序付けられている場合、線形時間の実装が使用され、パフォーマンスは &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="749dbe9f6d5460db51b381f2ed3cc45b62922708" translate="yes" xml:space="preserve">
          <source>If the linker complains about not finding &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt;, then something is inconsistent: you probably didn&amp;rsquo;t compile modules in the proper dependency order.</source>
          <target state="translated">リンカが &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt; を見つけられないと不平を言った場合、何かが一貫していません。おそらく、適切な依存関係の順序でモジュールをコンパイルしていません。</target>
        </trans-unit>
        <trans-unit id="17ce2aaa6f885fafff129a1f5c7f288b0246cde9" translate="yes" xml:space="preserve">
          <source>If the module is omitted, then the most recently-loaded module is used.</source>
          <target state="translated">モジュールが省略された場合は、最も最近ロードされたモジュールが使用されます。</target>
        </trans-unit>
        <trans-unit id="06465b1683dc6997624e8cf98f88a5ffebfed678" translate="yes" xml:space="preserve">
          <source>If the object becomes unreachable right before the program exits, then GC may not be performed. Finalizers run during GC, so finalizers associated with the object do not run if GC does not happen.</source>
          <target state="translated">プログラムが終了する直前にオブジェクトが到達不可能になった場合、GC が実行されないことがあります。ファイナライザは GC 2011 の間に実行されるので、GC 2011 が起こらない場合、オブジェクトに関連付けられたファイナライザは実行されません。</target>
        </trans-unit>
        <trans-unit id="1118a0190298be9b79dcb8130235e2ed75e7ad6d" translate="yes" xml:space="preserve">
          <source>If the operations needed are available in &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;, it's recommended to avoid importing this module and use &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; instead for now.</source>
          <target state="translated">必要な操作が&lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;で利用できる場合は、このモジュールのインポートを回避し、代わりに今の&lt;a href=&quot;ghc-list&quot;&gt;ところGHC.List&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d002b03429965487a13f5d84e867b7a6ca60210f" translate="yes" xml:space="preserve">
          <source>If the option &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</source>
          <target state="translated">オプション&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;がコンパイラーに渡される場合、上記の制限は適用されず、型推論中に型ファミリーの正規化を確実に終了するのはプログラマーの責任です。</target>
        </trans-unit>
        <trans-unit id="a071a26aa48a39d43d14f16a87c253716cb792f4" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--simple-output&lt;/code&gt; is given, then the packages are listed on a single line separated by spaces, and the database names are not included. This is intended to make it easier to parse the output of &lt;code&gt;ghc-pkg list&lt;/code&gt; using a script.</source>
          <target state="translated">オプション &lt;code&gt;--simple-output&lt;/code&gt; が指定されている場合、パッケージはスペースで区切られた1行でリストされ、データベース名は含まれません。これは、スクリプトを使用して &lt;code&gt;ghc-pkg list&lt;/code&gt; 出力を簡単に解析できるようにすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="a2972ccb36c0dde44e00d9bbf8a450ab2fdf58ed" translate="yes" xml:space="preserve">
          <source>If the package contains profiling libraries, then the interface files for those library modules should have the suffix &lt;code&gt;.p_hi&lt;/code&gt;. So the package can contain both normal and profiling versions of the same library without conflict (see also &lt;code&gt;library_dirs&lt;/code&gt; below).</source>
          <target state="translated">パッケージにプロファイリングライブラリが含まれている場合、それらのライブラリモジュールのインターフェイスファイルには、サフィックス &lt;code&gt;.p_hi&lt;/code&gt; が必要です。したがって、パッケージには、同じライブラリの通常バージョンとプロファイリングバージョンの両方を競合なしで含めることができます（以下の &lt;code&gt;library_dirs&lt;/code&gt; も参照）。</target>
        </trans-unit>
        <trans-unit id="8ccd8f5434504821c2b94076a11f8715fe0b84ba" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;a&lt;/code&gt; appears underneath a composition of other type constructors, then the representation involves composition, too:</source>
          <target state="translated">パラメータ &lt;code&gt;a&lt;/code&gt; が他の型コンストラクタの構成の下にある場合、表現にも構成が含まれます。</target>
        </trans-unit>
        <trans-unit id="32cab9cb10b6c38303476943187addc7db896eb0" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">パスがすでに絶対パスである場合、操作が失敗することはありません。それ以外の場合、操作は &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; と同じ例外で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="00b17cb9d8e7bb5e296d3da780f46cf2d367124c" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may throw exceptions.</source>
          <target state="translated">パスがすでに絶対パスである場合、操作が失敗することはありません。それ以外の場合は例外が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2cd818a895dd0680e5558fe6703f03edd2d2230d" translate="yes" xml:space="preserve">
          <source>If the path points to an existing file or directory, then the output path shall also point to the same file or directory, subject to the condition that the relevant parts of the file system do not change while the function is still running. In other words, the function is definitively not atomic. The results can be utterly wrong if the portions of the path change while this function is running.</source>
          <target state="translated">パスが既存のファイルやディレクトリを指している場合,関数の実行中にファイルシステムの関連部分が変更されないことを条件に,出力パスも同じファイルやディレクトリを指しているものとする。言い換えれば,この関数は決定的にアトミックではありません.この関数の実行中にパスの一部が変更された場合,結果は全く間違ったものになる可能性がある。</target>
        </trans-unit>
        <trans-unit id="17dcdf1f1aa0a2191303abce0bb5187d7f7a9885" translate="yes" xml:space="preserve">
          <source>If the pattern is a constructor pattern &lt;code&gt;(P p1 ... pn)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern synonym defined by &lt;code&gt;P x1 ... xn = p&lt;/code&gt; or &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt;, then:</source>
          <target state="translated">パターンがコンストラクターパターン &lt;code&gt;(P p1 ... pn)&lt;/code&gt; である場合、 &lt;code&gt;P&lt;/code&gt; は &lt;code&gt;P x1 ... xn = p&lt;/code&gt; または &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt; -pによって定義されるパターン同義語であり、次のようになります。</target>
        </trans-unit>
        <trans-unit id="3ba484df09e44ad6151f620767b5567f42c57031" translate="yes" xml:space="preserve">
          <source>If the pattern matches multiple packages, the description for each package is emitted, separated by the string &lt;code&gt;---&lt;/code&gt; on a line by itself.</source>
          <target state="translated">パターンが複数のパッケージに一致する場合、各パッケージの説明が文字列 &lt;code&gt;---&lt;/code&gt; で区切られて、1行に出力されます。</target>
        </trans-unit>
        <trans-unit id="eddedbc84892409431bb5cd9dff6d864c792acc8" translate="yes" xml:space="preserve">
          <source>If the plugin cannot make any progress, it should return &lt;code&gt;TcPluginOk [] []&lt;/code&gt;. Otherwise, if there were any new constraints, the main constraint solver will be re-invoked to simplify them, then the plugin will be invoked again. The plugin is responsible for making sure that this process eventually terminates.</source>
          <target state="translated">プラグインが何も進行できない場合は、 &lt;code&gt;TcPluginOk [] []&lt;/code&gt; 返す必要があります。そうでない場合、新しい制約があった場合、それらを簡略化するためにメインの制約ソルバーが再度呼び出され、プラグインが再度呼び出されます。プラグインは、このプロセスが最終的に終了することを確認する責任があります。</target>
        </trans-unit>
        <trans-unit id="f4dd01b74a08371cbefaa339741c2f2bf732cc33" translate="yes" xml:space="preserve">
          <source>If the pointer argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;. If the requested size is 0, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ポインタ引数場合 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; がある &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; のように振る舞う &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 。要求されたサイズが0の場合、 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; のように動作します。</target>
        </trans-unit>
        <trans-unit id="94a8bff9ac670099a84c99ae99166a8b13917470" translate="yes" xml:space="preserve">
          <source>If the program needs to be linked with additional objects (say, some auxiliary C code), then the object files can be given on the command line and GHC will include them when linking the executable.</source>
          <target state="translated">プログラムを追加のオブジェクト(例えば、補助的なCコード)とリンクする必要がある場合は、コマンドラインでオブジェクトファイルを指定することができ、実行ファイルをリンクする際にGHCがそれらを含めます。</target>
        </trans-unit>
        <trans-unit id="cf0e55f0ed3aeca48a639cdc97cfce430926d732" translate="yes" xml:space="preserve">
          <source>If the program&amp;rsquo;s heap exceeds the value set by &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;, the RTS throws an exception to the program, and the program gets an additional quota of allocation before the exception is raised again, the idea being so that the program can execute its exception handlers. &lt;code&gt;-Mgrace=&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">プログラムのヒープが&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;によって設定された値を超えると、RTSはプログラムに例外をスローし、プログラムは例外が再度発生する前に割り当ての追加割り当てを取得します。例外ハンドラ。 &lt;code&gt;-Mgrace=&lt;/code&gt; は、この追加のクォータのサイズを制御します。</target>
        </trans-unit>
        <trans-unit id="a05bad59c9ffd07726909b6b71df24cb1faeae56" translate="yes" xml:space="preserve">
          <source>If the quotes are left off in the above command, &lt;code&gt;ghci&lt;/code&gt; will interpret the filename as two, &lt;code&gt;c:\\\\Program&lt;/code&gt; and &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt;.</source>
          <target state="translated">上記のコマンドで引用符が &lt;code&gt;ghci&lt;/code&gt; されている場合、ghciはファイル名を &lt;code&gt;c:\\\\Program&lt;/code&gt; および &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt; 2つとして解釈します。</target>
        </trans-unit>
        <trans-unit id="2999a971417548d37995328ba747557f94ced1e4" translate="yes" xml:space="preserve">
          <source>If the specifics of the data format is not important to you, for example, you are more interested in serializing and deserializing values than in which format will be used, it is possible to derive &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; instances using the generic support. See &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">データ形式の詳細が重要ではない場合、たとえば、使用される形式よりも値のシリアル化と逆シリアル化に関心がある場合は、汎用サポートを使用して &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; インスタンスを派生させることができます。 &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3bff18fc6fb06d1186c47eea05dc08be6efd2b10" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字列に共通の接頭辞がないか、どちらかが空の場合、この関数は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5e60628a5625f3d573cd912472e867f90d066185" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字列に共通のプレフィックスがない場合、またはいずれかが空の場合、この関数は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a96483a865258b93f60fbe9c7b1b6209ab588de4" translate="yes" xml:space="preserve">
          <source>If the system call is successfully interrupted, it will return to Haskell whereupon the exception can be raised. Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; that the caller of the foreign function is prepared to deal with the consequences of the call being interrupted; on Unix it is good practice to check for &lt;code&gt;EINTR&lt;/code&gt; always, but on Windows it is not typically necessary to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">システムコールが正常に中断された場合、Haskellに戻り、例外が発生します。 &lt;code&gt;interruptible&lt;/code&gt; を使用する場合は、外部関数の呼び出し元が、中断された呼び出しの結果に対処する準備ができていることに特に注意してください。 Unixでは常に &lt;code&gt;EINTR&lt;/code&gt; をチェックすることをお &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; しますが、Windowsでは通常、ERROR_OPERATION_ABORTEDを処理する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b0ea0825d60f59ed95619566d152ac3af5d1dc48" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="ef565fe58fa8cc5e2adb616fefe14b2fe53e3eb9" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="29ed533e57740cc52561c9e0778a3939079b1869" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="3b5423771ba3f07d0d121d4047b87be07039385d" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; のターゲットが呼び出し側のスレッドである場合、例外が非同期例外としてスローされることを除いて、動作は &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と同じです。つまり、現在のIO操作が &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; の内部にある場合など、囲んでいる純粋な計算がある場合、その計算は例外によって永続的に置き換えられるのではなく、非同期例外を受け取ったかのように中断されます。</target>
        </trans-unit>
        <trans-unit id="f4adad1fbffea0d664503ae0f3cb5c909898c750" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は返されません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。ただし、GHCでは、外部呼び出しに &lt;code&gt;interruptible&lt;/code&gt; 可能として注釈を付けることができます。その場合、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; により、RTSは呼び出しを戻そうとします。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f635604a794f0509d229ca0450224e3801f13960" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cb32a1414cef013e5d3c55de2b52fcec36dfcc67" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="908085ccb223dbac0a5f30208596777c0973aa2a" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は返されません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。ただし、GHCでは、外部呼び出しに &lt;code&gt;interruptible&lt;/code&gt; 可能として注釈を付けることができます。その場合、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; により、RTSは呼び出しを戻そうとします。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="410b774382afae43c015c978d6a4c05a23286a81" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c611187645855aef0a0e483dbd3cd6ec25f33b44" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は返されません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。ただし、GHCでは、外部呼び出しに &lt;code&gt;interruptible&lt;/code&gt; 可能として注釈を付けることができます。その場合、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; により、RTSは呼び出しを戻そうとします。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6aae4a4891882f9616442e3ab4e703d074ae744f" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">ターゲットスレッドが現在外部呼び出しを行っている場合、呼び出しが完了するまで例外は発生しません（したがって、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は戻りません）。これは、呼び出しが &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内にあるかどうかに関係なく当てはまります。しかし、GHCで外国呼び出しは次のように注釈を付けることができる &lt;code&gt;interruptible&lt;/code&gt; 、その場合には、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は RTSが復帰への呼び出しを引き起こすことを試みることになります。詳細については、GHCのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0efe330fe5a7f319c74a83698c2016b7024d2870" translate="yes" xml:space="preserve">
          <source>If the tick-count expires, GHC summarises what simplifier steps it has done; you can use &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; to generate a much more detailed list. Usually that identifies the loop quite accurately, because some numbers are very large.</source>
          <target state="translated">ティックカウントが期限切れになると、GHCはそれが行った単純化ステップを要約します。 &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; を使用して、より詳細なリストを生成できます。一部の数値が非常に大きいため、通常はループを非常に正確に識別します。</target>
        </trans-unit>
        <trans-unit id="f834f3278901f9fdfc11689ba5008e3d53a52f10" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy:</source>
          <target state="translated">型が &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; インスタンスでもある場合、次の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="27c720209a65937fe0295731a0ddd0e77cf4c007" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">タイプが &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスでもある場合、それは満たす必要があります</target>
        </trans-unit>
        <trans-unit id="c31cbe33b88501dc1cab64cc221110f7cc955564" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">タイプが &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスでもある場合、それは満たす必要があります</target>
        </trans-unit>
        <trans-unit id="b1a3cb38f79f019c8eefd564552c10ef09d46fb9" translate="yes" xml:space="preserve">
          <source>If the type signature includes any kind annotations (either on variable binders or as annotations on types), any variables used in kind annotations come before any variables never used in kind annotations. This rule is not recursive: if there is an annotation within an annotation, then the variables used therein are on equal footing. Examples:</source>
          <target state="translated">タイプシグネチャに何らかの種類の注釈が含まれている場合(変数のバインダー上または型の注釈として)、種類の注釈で使用される変数は、種類の注釈では使用されない変数の前に置かれます。このルールは再帰的ではありません:もしアノテーションの中にアノテーションがある場合、その中で使われる変数は等しくなります。例を示します。</target>
        </trans-unit>
        <trans-unit id="8c4ea0e44780d77e1880898106ce1bbf9df2c555" translate="yes" xml:space="preserve">
          <source>If the types of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; と &lt;code&gt;q&lt;/code&gt; のタイプがボックス化されていない場合、結果のバインディングは他のHaskellパターンバインディングと同様に遅延になります。上記の例は、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="b6f18250f43f2740e1195441a25da60c594f32dd" translate="yes" xml:space="preserve">
          <source>If the underlying encoding is not itself roundtrippable, this mechanism can fail. Roundtrippable encodings are those which have an injective mapping into Unicode. Almost all encodings meet this criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain several different encodings of the same Unicode codepoint.</source>
          <target state="translated">基礎となるエンコーディングがそれ自体がラウンドトリップ可能でない場合、このメカニズムは失敗する可能性があります。ラウンドトリップ可能なエンコーディングとは、 Unicode へのマッピングが有効なエンコーディングのことです。ほとんどすべてのエンコーディングはこの基準を満たしていますが、中には満たしていないものもあります。特筆すべきは、Shift-JIS (CP932)と Big5 には、同じ Unicode コードポイントの複数の異なるエンコーディングが含まれていることです。</target>
        </trans-unit>
        <trans-unit id="f18d7f0b53d60c67a0f0044ea31055a7a2c5370e" translate="yes" xml:space="preserve">
          <source>If the user has supplied a type signature, as in &lt;code&gt;f&lt;/code&gt;, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in &lt;code&gt;f&lt;/code&gt; will be &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ユーザーが &lt;code&gt;f&lt;/code&gt; のように型シグネチャを指定した場合、これは簡単です。型シグネチャの順序を左から右に取り、最初に出現する変数を使用して順序内での位置を選択するだけです。このように、の変数 &lt;code&gt;f&lt;/code&gt; がされます &lt;code&gt;b&lt;/code&gt; は、それから。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="153127ffa367d83e2cf43ec8214e9672b8320af2" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">ユーザーが「字句」を書き込むと、パーサーは次のエラーで失敗します。 &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; です。実際、（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネータは、最初の代替が入力を消費していない場合にのみ代替を試行するため、 &lt;code&gt;identifier&lt;/code&gt; パーサーは試行されません（ &lt;code&gt;string &quot;let&quot;&lt;/code&gt; パーサーのプレフィックス &quot;le&quot; がすでに消費されているため）。正しい動作は、 &lt;code&gt;try&lt;/code&gt; コンビネーターを追加することで取得できます。</target>
        </trans-unit>
        <trans-unit id="077149390f83f66f25123eacbd59fbfc008ad8c0" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">ユーザーが「字句」を書き込むと、パーサーは次のエラーで失敗します。 &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; です。実際、（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネータは、最初の代替が入力を消費していない場合にのみ代替を試行するため、 &lt;code&gt;identifier&lt;/code&gt; パーサーは試行されません（ &lt;code&gt;string &quot;let&quot;&lt;/code&gt; パーサーのプレフィックス &quot;le&quot; がすでに消費されているため）。正しい動作は、 &lt;code&gt;try&lt;/code&gt; コンビネーターを追加することで取得できます。</target>
        </trans-unit>
        <trans-unit id="627396045def6a2b30cfb67918ea7b827134e0dc" translate="yes" xml:space="preserve">
          <source>If the value of the error is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">エラーの値が不要な場合は、代わりに&lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt;のバリアントを使用できます。</target>
        </trans-unit>
        <trans-unit id="9cbcf45c8589b25e6b77fbe3fd739a89f107ae36" translate="yes" xml:space="preserve">
          <source>If the value of the exception is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">例外の値が不要な場合は、代わりに&lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt;のバリアントを使用できます。</target>
        </trans-unit>
        <trans-unit id="9596c4f417cd0a2eeda3532c57a9759b3148d2e2" translate="yes" xml:space="preserve">
          <source>If there are multiple exposed versions of a package, GHC will prefer the latest one. Additionally, some packages may be broken: that is, they are missing from the package database, or one of their dependencies are broken; in this case; these packages are excluded from the default set of packages.</source>
          <target state="translated">パッケージの複数のバージョンが公開されている場合、GHC は最新のものを優先します。さらに、いくつかのパッケージが壊れているかもしれません:パッケージデータベースから消えていたり、依存関係が壊れていたりしています;この場合、これらのパッケージはデフォルトのパッケージセットから除外されます。</target>
        </trans-unit>
        <trans-unit id="2744f509c20d0d226472161d7c5e0d680881c742" translate="yes" xml:space="preserve">
          <source>If there are no other threads to run, the runtime system will check for runnable finalizers before declaring the system to be deadlocked.</source>
          <target state="translated">他に実行するスレッドがない場合、ランタイムシステムはデッドロックを宣言する前に実行可能なファイナライザをチェックします。</target>
        </trans-unit>
        <trans-unit id="2754d33a517265ae953ce70490f5a33b97494617" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がある場合、つまり、囲んでいる関数に &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約がある場合、GHCは既存の &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に新しい呼び出しサイトを追加します。</target>
        </trans-unit>
        <trans-unit id="f4b72501bc991c36ff4bffdeb5e90240c549826c" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がある場合、つまり、囲んでいる関数に &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約がある場合、GHCは既存の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に新しい呼び出しサイトを追加します。</target>
        </trans-unit>
        <trans-unit id="786b9b7efbfcf460816260b5fc3891ba66319ff4" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がある場合、つまり、囲んでいる関数に &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約がある場合、GHCは既存の &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に新しい呼び出しサイトを追加します。</target>
        </trans-unit>
        <trans-unit id="fdb2173b7203347d640f077ccdf8f741ab650cd9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;CallStack&lt;/code&gt; in scope &amp;ndash; i.e. the enclosing definition has a &lt;code&gt;HasCallStack&lt;/code&gt; constraint &amp;ndash; GHC will push the new call-site onto the existing &lt;code&gt;CallStack&lt;/code&gt;.</source>
          <target state="translated">スコープに &lt;code&gt;CallStack&lt;/code&gt; がある場合、つまり、包含定義に &lt;code&gt;HasCallStack&lt;/code&gt; 制約がある場合、GHCは新しい呼び出しサイトを既存の &lt;code&gt;CallStack&lt;/code&gt; にプッシュします。</target>
        </trans-unit>
        <trans-unit id="9751e595298ec0b63212d3d3e3da71e206e9047f" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;-odir&lt;/code&gt; option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</source>
          <target state="translated">&lt;code&gt;-odir&lt;/code&gt; オプションがない場合（デフォルト）、オブジェクトのファイル名は、サフィックスを「osuf」で置き換えることにより、ソースファイル名（モジュール名は無視）から派生します。</target>
        </trans-unit>
        <trans-unit id="0459b16b546d66c267a51da320d328d26755c8cb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がない場合（上記のGHCiセッションなど）、外側の定義に明示的な型シグネチャがない場合、GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 定義のHasCallStack制約を推測します（単相性の制限に従います）。</target>
        </trans-unit>
        <trans-unit id="51b3dd98e9cfee97be33be76a5f1ce7dc9f8f5e6" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がなく、それを含む定義に明示的な型シグニチャーがある場合、GHCは現在の呼び出しサイトのみを含むシングルトン &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約を解決します。</target>
        </trans-unit>
        <trans-unit id="1471f8828c2379e165ca2717ec8725b325f74acd" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がない場合（上記のGHCiセッションなど）、外側の定義に明示的な型シグネチャがない場合、GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 定義のHasCallStack制約を推測します（単相性の制限に従います）。</target>
        </trans-unit>
        <trans-unit id="af5dadc898713c4d1ac69f3e2c4c1c3cd662c85a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がなく、それを含む定義に明示的な型シグニチャーがある場合、GHCは現在の呼び出しサイトのみを含むシングルトン &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約を解決します。</target>
        </trans-unit>
        <trans-unit id="c0a2154090a11c56205c916716db23e3aaf5e97a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がない場合（上記のGHCiセッションなど）、外側の定義に明示的な型シグネチャがない場合、GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 定義のHasCallStack制約を推測します（単相性の制限に従います）。</target>
        </trans-unit>
        <trans-unit id="ebb76c92af062244a4e188e2b7f8ad3c706df8fb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">スコープに &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; がなく、それを含む定義に明示的な型シグニチャーがある場合、GHCは現在の呼び出しサイトのみを含むシングルトン &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 制約を解決します。</target>
        </trans-unit>
        <trans-unit id="c41b4ceb40ee7df7d2779d08c19440a00fd4dee9" translate="yes" xml:space="preserve">
          <source>If these instances can be defined, defining instances of the base classes is mechanical:</source>
          <target state="translated">これらのインスタンスを定義できるのであれば、基底クラスのインスタンスを定義することは機械的である。</target>
        </trans-unit>
        <trans-unit id="7a9d1a25b60758f4043441274ee9783e99a3d47e" translate="yes" xml:space="preserve">
          <source>If this flag is on, call-pattern specialisation will specialise a call &lt;code&gt;(f (Just x))&lt;/code&gt; with an explicit constructor argument, even if the argument is not scrutinised in the body of the function. This is sometimes beneficial; e.g. the argument might be given to some other function that can itself be specialised.</source>
          <target state="translated">このフラグがオンの場合、呼び出しパターン特殊化は、明示的なコンストラクター引数を使用して呼び出し &lt;code&gt;(f (Just x))&lt;/code&gt; を特殊化します（引数が関数の本体で精査されていない場合でも）。これは時々有益です。たとえば、引数はそれ自体が特殊化できる他の関数に与えられるかもしれません。</target>
        </trans-unit>
        <trans-unit id="615c1d104b752d5fbf04f2f7bfaa64a63695c34b" translate="yes" xml:space="preserve">
          <source>If true, create the semaphore if it does not yet exist.</source>
          <target state="translated">真の場合、まだ存在しない場合はセマフォを作成します。</target>
        </trans-unit>
        <trans-unit id="5726894dc0e940e30aa84621008b693bdc032ec8" translate="yes" xml:space="preserve">
          <source>If true, create the shm object if it does not exist.</source>
          <target state="translated">true の場合、存在しない場合は shm オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="61a6257ede23921542c050cc42cf5a60299cc751" translate="yes" xml:space="preserve">
          <source>If true, open the shm object read-write rather than read-only.</source>
          <target state="translated">trueの場合、shmオブジェクトをリードオンリーではなくリードライトで開きます。</target>
        </trans-unit>
        <trans-unit id="4c1c0f18f18624f27614c4ffe42965205a397757" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the semaphore already exists.</source>
          <target state="translated">true の場合、セマフォが既に存在する場合は例外をスローします。</target>
        </trans-unit>
        <trans-unit id="fa803c6c609db6b79b17d1491838007497e1d827" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the shm object already exists.</source>
          <target state="translated">true の場合、shm オブジェクトが既に存在する場合に例外をスローします。</target>
        </trans-unit>
        <trans-unit id="ed093df6f14d931fa3c4c256a6b87b3891dc67ba" translate="yes" xml:space="preserve">
          <source>If true, wipe the contents of the shm object after opening it.</source>
          <target state="translated">true の場合、shm オブジェクトを開いた後に内容をワイプします。</target>
        </trans-unit>
        <trans-unit id="aa3d7aa2ca27566724560024376f27197b54c353" translate="yes" xml:space="preserve">
          <source>If used in conjunction with &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;, writes dump output from main C-- pipeline stages to files (each stage per file).</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​すると、メインのC--パイプラインステージからのダンプ出力をファイルに書き込みます（ファイルごとの各ステージ）。</target>
        </trans-unit>
        <trans-unit id="b399c89393340f06d26617e02a5d2db971dcd55d" translate="yes" xml:space="preserve">
          <source>If variable &lt;code&gt;v&lt;/code&gt; at the cursor is depended on by any earlier variable &lt;code&gt;w&lt;/code&gt;, move &lt;code&gt;v&lt;/code&gt; immediately before the leftmost such &lt;code&gt;w&lt;/code&gt;.</source>
          <target state="translated">カーソル位置の変数 &lt;code&gt;v&lt;/code&gt; が以前の変数 &lt;code&gt;w&lt;/code&gt; に依存している場合は、そのような左端の &lt;code&gt;w&lt;/code&gt; の直前に &lt;code&gt;v&lt;/code&gt; を移動します。</target>
        </trans-unit>
        <trans-unit id="05f59d5d88acf30508b2934ebb596d83dcf81d86" translate="yes" xml:space="preserve">
          <source>If we aren&amp;rsquo;t concerned about preserving the evaluatedness of a variable, we can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; command behaves exactly like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, except that it forces the evaluation of any thunks it encounters:</source>
          <target state="translated">変数の評価を保持する必要がない場合は、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; の&lt;/a&gt;代わりに：&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;を使用できます。&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;コマンドは正確に同じように動作し&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;それが遭遇するあらゆるサンクの評価を強制することを除いて、：</target>
        </trans-unit>
        <trans-unit id="46aacca2dc2b515359c3629f8b545b4072e9cb10" translate="yes" xml:space="preserve">
          <source>If we expanded the superclasses of &lt;code&gt;C Id&lt;/code&gt; we&amp;rsquo;d get first &lt;code&gt;Id (C Id)&lt;/code&gt; and thence &lt;code&gt;C Id&lt;/code&gt; again.</source>
          <target state="translated">私たちはスーパーの拡大場合は &lt;code&gt;C Id&lt;/code&gt; 我々は最初取得したい &lt;code&gt;Id (C Id)&lt;/code&gt; 、そこから &lt;code&gt;C Id&lt;/code&gt; もう一度。</target>
        </trans-unit>
        <trans-unit id="ab06f8bed3c50d147e0f34ef14e2a2bfe485f229" translate="yes" xml:space="preserve">
          <source>If we map the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; constructor, the entire list should be returned:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; コンストラクターをマップすると、リスト全体が返されます。</target>
        </trans-unit>
        <trans-unit id="f7cadd59d96946a92a3e4e327a5bdc6e946f758a" translate="yes" xml:space="preserve">
          <source>If we need to combine multiple values we can use the &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; function to do so. We need to ensure however that we have at least one value to operate on, since otherwise our result would be undefined. It is for this reason that &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; uses &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; - a list that can never be empty:</source>
          <target state="translated">複数の値を組み合わせる必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; 関数を使用してこれを行うことができます。ただし、操作する値が少なくとも1つあることを確認する必要があります。そうしないと、結果が未定義になるためです。 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; が&lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty-&lt;/a&gt;決して空にできないリストを使用するのはこのためです：</target>
        </trans-unit>
        <trans-unit id="3467969828fd41de06ba2ada1d51483a9746f64f" translate="yes" xml:space="preserve">
          <source>If we now load a file into GHCi, the prompt will change:</source>
          <target state="translated">今、GHCiにファイルを読み込むとプロンプトが変わります。</target>
        </trans-unit>
        <trans-unit id="63f9b336b3695cb29c6493fac4402515a8e4d030" translate="yes" xml:space="preserve">
          <source>If we now modify the source of &lt;code&gt;D&lt;/code&gt; (or pretend to: using the Unix command &lt;code&gt;touch&lt;/code&gt; on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</source>
          <target state="translated">ここで &lt;code&gt;D&lt;/code&gt; のソースを変更すると（またはそのふりをすると、ソースファイルでUnixコマンド &lt;code&gt;touch&lt;/code&gt; を使用すると便利です）、オブジェクトファイルが古くなっている可能性があるため、コンパイラーはオブジェクトファイルを使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="56aef672862bfcd7939d7f244a055f2611b773c3" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like</source>
          <target state="translated">yes(デフォルト)の場合、RTSは以下のようなものをキャッチするためのシグナルハンドラをインストールします。</target>
        </trans-unit>
        <trans-unit id="b556699afcea8a3861c7bd49d57539e01604beee" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like &lt;code&gt;Ctrl-C&lt;/code&gt;. This option is primarily useful for when you are using the Haskell code as a DLL, and want to set your own signal handlers.</source>
          <target state="translated">はい（デフォルト）の場合、RTSは &lt;code&gt;Ctrl-C&lt;/code&gt; などをキャッチするシグナルハンドラーをインストールします。このオプションは、HaskellコードをDLLとして使用していて、独自のシグナルハンドラーを設定する場合に主に役立ちます。</target>
        </trans-unit>
        <trans-unit id="1824a09e94a9e0974a32536579d942e06a534b49" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on errors such as segfaults.</source>
          <target state="translated">はい（デフォルト）の場合、WindowsのRTSは例外ハンドラーをインストールして、Windowsの例外処理メカニズムを使用して未処理の例外をキャッチします。このオプションは主に、HaskellコードをDLLとして使用していて、RTSがセグメンテーション違反などのエラーでアプリケーションを正常に終了させたくない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f47cebe51b03f623c16d891f461a3756b2773fce" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on erros such as segfaults.</source>
          <target state="translated">はい（デフォルト）の場合、WindowsのRTSは例外ハンドラーをインストールして、Windows例外処理メカニズムを使用して未処理の例外をキャッチします。このオプションは主に、HaskellコードをDLLとして使用していて、RTSがsegfaultsなどのエラーでアプリケーションを異常終了させたくない場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="862def3a23c265087b17b9a922955600a2924ede" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">はい（デフォルト）の場合、WindowsのRTSは、クラッシュ時にコアダンプを生成します。これらのダンプは、WinDBGなどのデバッガーを使用して検査できます。ダンプには、クラッシュ時のすべてのコード、レジスタ、およびスレッド情報が記録されます。これは &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt; を意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e635d9c8063789e49ab24dcfcbdf9f3659eb237" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">はい（デフォルト）の場合、Windows上のRTSはクラッシュ時にコアダンプを生成します。これらのダンプは、WinDBGなどのデバッガーを使用して検査できます。ダンプは、クラッシュ時のすべてのコード、レジスタ、およびスレッド情報を記録します。これは &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt; を意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="babf43c52d9b937cdcace43cdc2f276acdb87956" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a stack trace on crashes if exception handling are enabled. In order to get more information in compiled executables, C code or DLLs symbols need to be available.</source>
          <target state="translated">はい(デフォルト)に設定すると、例外処理が有効になっている場合、Windows の RTS はクラッシュ時にスタックトレースを生成します。コンパイルされた実行ファイルでより多くの情報を得るためには、C コードや DLL のシンボルが利用可能である必要があります。</target>
        </trans-unit>
        <trans-unit id="75dc4a8f44681567411c7cc8c3553fb7e90b3d1c" translate="yes" xml:space="preserve">
          <source>If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a &lt;code&gt;--RTS&lt;/code&gt;.</source>
          <target state="translated">コマンドラインの残りのすべてのオプションを（RTSではなく）プログラムに確実に移動させたい場合は、--RTSを使用し &lt;code&gt;--RTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5eb60052601f4a3531e65c7d5067016decf78928" translate="yes" xml:space="preserve">
          <source>If you also use &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;, you can write an unboxed tuple in a type synonym:</source>
          <target state="translated">&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;も使用する場合は、ボックス化されていないタプルを型の同義語で記述できます。</target>
        </trans-unit>
        <trans-unit id="705b934efdf6451c14bd14b83d658533f8914cf9" translate="yes" xml:space="preserve">
          <source>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it&amp;rsquo;s important that the program it compiles produces results whose representations are identical to those of the compiler itself.</source>
          <target state="translated">ソースからGHCをビルドする場合、テンプレートHaskellスプライスと準引用符を実行するには、少なくともステージ2のブートストラップコンパイラが必要です。ステージ1コンパイラは、Haskellの通常の引用のみを受け入れます。理由：THスプライスと準引用符がプログラムをコンパイルして実行し、その結果を調べます。したがって、コンパイルするプログラムが、コンパイラ自体の表現と同じ表現を持つ結果を生成することが重要です。</target>
        </trans-unit>
        <trans-unit id="969473549eb7eda775de0bbd5b7e1c35fe2a3fe0" translate="yes" xml:space="preserve">
          <source>If you are down to your last-compile-before-a-bug-report, we would recommend that you add a &lt;code&gt;-dcore-lint&lt;/code&gt; option (for extra checking) to your compilation options.</source>
          <target state="translated">last-compile-before-a-bug-reportに &lt;code&gt;-dcore-lint&lt;/code&gt; ている場合は、コンパイルオプションに-dcore-lintオプション（追加のチェック用）を追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8db781218acb5f2994b23e09a56675a86f2ceeb8" translate="yes" xml:space="preserve">
          <source>If you are hit by this, you may want to compile the affected module with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fno-omit-yields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;). This flag ensures that yield points are inserted at every function entrypoint (at the expense of a bit of performance).</source>
          <target state="translated">これに遭遇した場合は、影響を受けるモジュールを&lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fno-omit-yields&lt;/code&gt; &lt;/a&gt;でコンパイルすることができます（&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：プラットフォームに依存しないフラグを&lt;/a&gt;参照）。このフラグにより​​、すべての関数エントリポイントに降伏点が確実に挿入されます（少しパフォーマンスが低下します）。</target>
        </trans-unit>
        <trans-unit id="ee2cd5fd786322ce97e57aaf58e15a0f10e358b1" translate="yes" xml:space="preserve">
          <source>If you are making foreign calls from multiple Haskell threads and using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;The relationship between Haskell threads and OS threads&lt;/a&gt;).</source>
          <target state="translated">複数のHaskellスレッドから外部呼び出しを&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;、-threadedを使用する場合は、呼び出す外部コードがスレッドセーフであることを確認してください。特に、一部のGUIライブラリはスレッドセーフではなく、呼び出し側が単一のスレッドからのみGUIメソッドを呼び出す必要があります。この場合、GUI操作を単一のHaskellスレッドに制限し、バインドされたスレッドも使用する必要がある場合があります（&lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;HaskellスレッドとOSスレッドの関係を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a3cb86bb37d550f99fb107d358e09f2ff4997d45" translate="yes" xml:space="preserve">
          <source>If you are setting language options in your &lt;code&gt;.ghci&lt;/code&gt; file, it is good practice to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, unless you really do want them to apply to all modules you load in GHCi.</source>
          <target state="translated">&lt;code&gt;.ghci&lt;/code&gt; ファイルで言語オプションを設定する場合は、GHCiにロードするすべてのモジュールに適用したい場合を除いて、&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2780984904c2d880871374ff9ccab143b480b0b2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合、&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;を使用するほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="b97f8aaadda196835b4af2ea1886f79e9ad8ac0e" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合、&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;を使用するほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="3f1f508d47e724e488b898fb6b5424ab4c2ea295" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合は、&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;を使用したほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="f14f369071627bc2e08352734351733171bc0451" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; キーを使用している場合は、&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;を使用したほとんどの操作でパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="f294dc39561bb7510ab182cdc6070d0d208bd977" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;make&lt;/code&gt;, GHC can automatically generate the dependencies required in order to make sure that every module &lt;em&gt;is&lt;/em&gt; up-to-date with respect to its imported interfaces. Please see &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; を使用している場合、GHCはすべてのモジュール&lt;em&gt;が&lt;/em&gt;インポートされたインターフェースに関して最新であることを確認するために必要な依存関係を自動的に生成できます。&lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;依存関係の生成を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="64df0960b34991e4d85de84eb1668ccd834d0e6f" translate="yes" xml:space="preserve">
          <source>If you are using a Haskell &amp;ldquo;package&amp;rdquo; (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;), don&amp;rsquo;t forget to add the relevant &lt;code&gt;-package&lt;/code&gt; option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the &lt;code&gt;-package&lt;/code&gt; option will likely result in several pages of link errors.</source>
          <target state="translated">あなたはHaskellの「パッケージ」（参照を使用している場合は&lt;a href=&quot;packages#packages&quot;&gt;パッケージ&lt;/a&gt;）、関連する追加することを忘れないでください &lt;code&gt;-package&lt;/code&gt; あまりにもプログラムをリンクオプションを：それは適切なライブラリがプログラムとリンクされるようになります。 &lt;code&gt;-package&lt;/code&gt; オプションを忘れると、数ページのリンクエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="7b7cc346da82320cb12d47cf0a63adf255287f4d" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkdtemp glibc function (supported in glibc &amp;gt; 2.1.91) then this function uses mktemp and so shouldn't be considered safe.</source>
          <target state="translated">mkdtemp glibc関数（glibc&amp;gt; 2.1.91でサポート）をサポートしないシステムとして使用している場合、この関数はmktempを使用するため、安全とは見なされません。</target>
        </trans-unit>
        <trans-unit id="755c446ad00dee715ae6a725a7e54ef9a2b3bb98" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkstemps glibc function (supported in glibc &amp;gt; 2.11) then this function simply throws an error.</source>
          <target state="translated">mkstemps glibc関数（glibc&amp;gt; 2.11でサポート）をサポートしないシステムとして使用している場合、この関数は単にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="40ce0801a711815e8a0985a07d3d4a08fee712a7" translate="yes" xml:space="preserve">
          <source>If you are using external packages with &lt;strong&gt;cabal&lt;/strong&gt;, you may need to reinstall these packages with profiling support; typically this is done with &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;cabal&lt;/strong&gt;で外部パッケージを使用している場合、これらのパッケージをプロファイリングサポートとともに再インストールする必要がある場合があります。通常、これは &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt; で行われます。</target>
        </trans-unit>
        <trans-unit id="449e0cceb9882f742ae4ba71b581c42c65c1bc09" translate="yes" xml:space="preserve">
          <source>If you aren't using GHC or Hugs then this function simply wraps mktemp and so shouldn't be considered safe.</source>
          <target state="translated">GHC や Hugs を使っていない場合は、この関数は単に mktemp をラップしているだけなので、安全とは考えられません。</target>
        </trans-unit>
        <trans-unit id="c57e71626bccca627c9de3e0d23513402fbfad64" translate="yes" xml:space="preserve">
          <source>If you can't be bothered with the above, then you can build simple tables with simpleTable. Just provide the attributes for the whole table, attributes for the cells (same for every cell), and a list of lists of cell contents, and this function will build the table for you. It does presume that all the lists are non-empty, and there is at least one list.</source>
          <target state="translated">上記のようなことに煩わされないのであれば、simpleTableを使ってシンプルなテーブルを作成することができます。テーブル全体の属性、セルの属性(セルごとに同じ)、セル内容のリストを指定するだけで、この関数が代わりにテーブルを作成してくれます。この関数は、すべてのリストが空ではなく、少なくとも1つのリストがあることを前提としています。</target>
        </trans-unit>
        <trans-unit id="7c1274d2d2a7e0ba4a2c783c4ef67e9c677accd2" translate="yes" xml:space="preserve">
          <source>If you do not have an explicit export list in a module, GHC must assume that everything in that module will be exported. This has various pessimising effects. For example, if a bit of code is actually &lt;em&gt;unused&lt;/em&gt; (perhaps because of unfolding effects), GHC will not be able to throw it away, because it is exported and some other module may be relying on its existence.</source>
          <target state="translated">モジュールに明示的なエクスポートリストがない場合、GHCはそのモジュールのすべてがエクスポートされると想定する必要があります。これにはさまざまな悲観的な効果があります。たとえば、コードの一部が実際に&lt;em&gt;使用されていない場合&lt;/em&gt;（おそらく展開の影響のため）、GHCはそれを破棄できません。これは、コードがエクスポートされ、他のモジュールがその存在に依存している可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="7a1ecd7c0b5ed67d9ee213cf7d0666e703994546" translate="yes" xml:space="preserve">
          <source>If you do not need the offset parameter then you do should be using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">offsetパラメータが必要ない場合は、代わりに &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dacf0556d43b3d2afe433d11b8b9c360f1380a6b" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind annotation (&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt;), to tell GHC the kind of the type variable, if it is not &amp;ldquo;*&amp;rdquo;. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</source>
          <target state="translated">コンストラクターを&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;書き出さ&lt;/a&gt;ない場合は、種類の注釈（明示的な種類の数量化）を指定して、型変数の種類が「*」でない場合にGHCに通知する必要があります。（ソースファイルでは、これはコンストラクターで型変数が使用される方法から算出されます。）例：</target>
        </trans-unit>
        <trans-unit id="4308cfa9bfacb8d98d2c6bb15e1dd09df45e6181" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind to tell GHC what the kinds of the type variables are, if they are not the default &lt;code&gt;*&lt;/code&gt;. Unlike regular data type declarations, the return kind of an abstract data declaration can be anything (in which case it probably will be implemented using a type synonym.) This can be used to allow compile-time representation polymorphism (as opposed to &lt;a href=&quot;#runtime-rep&quot;&gt;run-time representation polymorphism&lt;/a&gt;), as in this example:</source>
          <target state="translated">コンストラクターを書き出さない場合、タイプ変数の種類がデフォルトの &lt;code&gt;*&lt;/code&gt; ではない場合、GHCにタイプ変数の種類を伝えるために種類を指定する必要がある場合があります。通常のデータ型宣言とは異なり、抽象データ宣言の戻り値の種類は何でもかまいません（この場合、型の同義語を使用して実装される可能性があります）。これは、（&lt;a href=&quot;#runtime-rep&quot;&gt;実行&lt;/a&gt;時ではなく）コンパイル時の表現の多態性を可能にするために使用できます。この例のように、表現ポリモーフィズム）：</target>
        </trans-unit>
        <trans-unit id="00d8e4e35d4f313452afad0626c5a13b4457d20a" translate="yes" xml:space="preserve">
          <source>If you do want custom history behavior, you may need to disable the above default setting(s).</source>
          <target state="translated">カスタム履歴の動作を希望する場合は、上記のデフォルト設定を無効にする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c92f00276e7b4844202319651693a66141bcfc09" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it&amp;hellip; unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">&lt;code&gt;cygpath&lt;/code&gt; がない場合は、おそらくcygwinがないので、問題はありません&amp;hellip;複数のプラットフォーム用に1つのビルドプロセスを作成する場合を除きます。繰り返しになりますが、相対パスは友だちですが、絶対パスを使用する必要があり、異なるプラットフォームで異なるツールを使用したくない場合は、短いHaskellプログラムを記述して、現在のディレクトリを出力できます（George Russellに感謝します）。アイデア）：GHCでコンパイルすると、GHCが依存するファイルシステムのビューが表示されます（GHCがcygwinのgccまたはmingwのgccでコンパイルされているか、実際のUnixシステムでコンパイルされているかによって異なります）-その小さなプログラムパス内の &lt;code&gt;\\&lt;/code&gt; のエスケープも処理できます。バナーと起動時間とは別に、次のようなこともできます。</target>
        </trans-unit>
        <trans-unit id="dbfd1c6f422cd2cb2dbbb7fda57624d1324776cf" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it... unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">&lt;code&gt;cygpath&lt;/code&gt; がない場合は、おそらくcygwinがないので問題はありません...複数のプラットフォーム用に1つのビルドプロセスを作成する場合を除きます。繰り返しになりますが、相対パスはあなたの友人ですが、絶対パスを使用する必要があり、異なるプラットフォームで異なるツールを使用したくない場合は、現在のディレクトリを印刷する短いHaskellプログラムを作成するだけです（これについてはGeorge Russellに感謝します） idea）：GHCでコンパイルすると、GHCが依存するファイルシステムのビューが表示されます（これは、GHCがcygwinのgccまたはmingwのgccでコンパイルされているか、実際のUnixシステムでコンパイルされているかによって異なります。）-その小さなプログラムパス内の &lt;code&gt;\\&lt;/code&gt; のエスケープも処理できます。バナーと起動時間は別として、次のようなこともできます。</target>
        </trans-unit>
        <trans-unit id="a6ca8436639b62f991d1a8bca7a44877f0eba7f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know what virtual memory, thrashing, and page faults are, or you don&amp;rsquo;t know the memory configuration of your machine, &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; try to be clever about memory use: you&amp;rsquo;ll just make your life a misery (and for other people, too, probably).</source>
          <target state="translated">仮想メモリ、スラッシング、ページフォールトがわからない場合、またはマシンのメモリ構成が&lt;em&gt;わからない&lt;/em&gt;場合は、メモリの使用について賢く&lt;em&gt;考えないで&lt;/em&gt;ください。人生を悲惨なものにするだけです。 （そしておそらく他の人々にとっても）。</target>
        </trans-unit>
        <trans-unit id="fa78b2c4ba732d90be891c20923a016c2ca06a59" translate="yes" xml:space="preserve">
          <source>If you don't care about leap seconds, use &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NominalDiffTime&lt;/code&gt; for your clock calculations, and you'll be fine.</source>
          <target state="translated">うるう秒が気にならない場合は、時計の計算に &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;NominalDiffTime&lt;/code&gt; を使用すれば大丈夫です。</target>
        </trans-unit>
        <trans-unit id="91fa5b3759632ec86596531c30715d1630f054a4" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider use &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">順序を気にしない場合は、代わりに&lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt;パッケージの &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="919994a6ad24d536810a2f90a16851626c53afe9" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider using &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">順序を気にしない場合は、代わりに&lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt;パッケージの &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="fbad3655a306b0eed532c2a8565759cd003f86c6" translate="yes" xml:space="preserve">
          <source>If you don't use the &lt;code&gt;-threaded&lt;/code&gt; option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-threaded&lt;/code&gt; オプションを使用しない場合、ランタイムは複数のOSスレッドを使用しません。外部呼び出しは、呼び出しが戻るまで、実行中の他のすべてのHaskellスレッドをブロックします。&lt;a href=&quot;system-io&quot;&gt;System.IOの&lt;/a&gt;ライブラリーは、まだそれほどI / Oを行っている複数のスレッドがあることができ、多重ず、これは使用してランタイムによって内部的に処理される &lt;code&gt;select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="798faf56167bc1eadc054491085974ccd1b8e71f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">フラグが未定義であるにもかかわらず、テストに失敗して使用すると、 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; はエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="88f18162bea62ea91e089db538307585a73e927f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">フラグが未定義であるにもかかわらず、テストに失敗して使用すると、 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; はエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="181e16d814261217260a59c6eebf52bfe99f472f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">フラグが未定義であるにもかかわらず、テストに失敗して使用すると、 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; はエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="ead50587e0a0cdc543693c999e66d196c802d0fa" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">これらの制限のいずれも面倒すぎると強く感じた場合は&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;、GHCチームに一言お願いします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57825a77683045fd11cf61c7e2280d83f489c5c5" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">これらの制限のいずれかが面倒すぎると強く感じた場合は&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;、GHCチームに一言お願いします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e72fd7c3e56cd41e50c2977a39a79818e565356" translate="yes" xml:space="preserve">
          <source>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</source>
          <target state="translated">もしあなたのコードがこれらの設定を変更する必要があると感じた場合は、ソースコードのデフォルト値とドキュメントを参照してください。しかし、私はこれには反対することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="12b8dd6cc517c8e6f32241fd0c8da26f585dc4a7" translate="yes" xml:space="preserve">
          <source>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</source>
          <target state="translated">明らかに悪いコードレイアウトにまでさかのぼることができるような、パフォーマンスの著しい回帰を見つけた場合は、チケットを開いてください。</target>
        </trans-unit>
        <trans-unit id="eddd7a1b6ed2ec9f8ddbaa4b9719044314989fa0" translate="yes" xml:space="preserve">
          <source>If you forget the &lt;code&gt;-watch&lt;/code&gt; flag you can still select &amp;ldquo;Watch file&amp;rdquo; from the &amp;ldquo;State&amp;rdquo; menu. Now each time you generate a new profile &lt;code&gt;FOO.ps&lt;/code&gt; the view will update automatically.</source>
          <target state="translated">&lt;code&gt;-watch&lt;/code&gt; フラグを忘れた場合でも、[状態]メニューから[ウォッチファイル]を選択できます。これで、新しいプロファイル &lt;code&gt;FOO.ps&lt;/code&gt; を生成するたびに、ビューが自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="3b468bbdec19642d76f696af7811d40687e4a9c8" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt; enabled, tuple sections will also be available for them, like so</source>
          <target state="translated">&lt;a href=&quot;#unboxed-tuples&quot;&gt;ボックス化され&lt;/a&gt;ていないタプルを有効にしている場合は、タプルセクションも利用できます。</target>
        </trans-unit>
        <trans-unit id="f4a2a18f9fd122d9f155cead5fb45d6a3af3ea4b" translate="yes" xml:space="preserve">
          <source>If you have specific requirements about the encoding format, you can use the encoding and decoding primitives directly, see the modules &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; and &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;.</source>
          <target state="translated">エンコード形式について特定の要件がある場合は、エンコードおよびデコードプリミティブを直接使用できます&lt;a href=&quot;data-binary-get&quot;&gt;。Data.Binary.Get&lt;/a&gt;および&lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="fedbc3661026d144c58745e2aaa481b83a3bdcbc" translate="yes" xml:space="preserve">
          <source>If you have to use absolute paths (beware of the innocent-looking &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; in makefile hierarchies or configure scripts), Cygwin provides a tool called &lt;code&gt;cygpath&lt;/code&gt; that can convert Cygwin&amp;rsquo;s Unix-style paths to their actual Windows-style counterparts. Many Cygwin tools actually accept absolute Windows-style paths (remember, though, that you either need to escape &lt;code&gt;\\&lt;/code&gt; or convert &lt;code&gt;\\&lt;/code&gt; to &lt;code&gt;/&lt;/code&gt;), so you should be fine just using those everywhere. If you need to use tools that do some kind of path-mangling that depends on unix-style paths (one fun example is trying to interpret &lt;code&gt;:&lt;/code&gt; as a separator in path lists), you can still try to convert paths using &lt;code&gt;cygpath&lt;/code&gt; just before they are passed to GHC and friends.</source>
          <target state="translated">絶対パスを使用する必要がある場合 &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; makefile階層または構成スクリプトで無害に見えるROOT = $（pwd）に注意）、Cygwinは &lt;code&gt;cygpath&lt;/code&gt; と呼ばれるツールを提供し、CygwinのUnixスタイルのパスを実際のWindowsスタイルのパスに変換できます。多くのCygwinツールは、実際には絶対的なWindowsスタイルのパスを受け入れます（ただし、 &lt;code&gt;\\&lt;/code&gt; をエスケープするか、 &lt;code&gt;\\&lt;/code&gt; を &lt;code&gt;/&lt;/code&gt; に変換する必要があることを忘れないでください）。あなたは、UNIX形式のパスに依存パス・マングリング（1つの楽しい例を解釈しようとしているのいくつかの種類を行うツールを使用する必要がある場合 &lt;code&gt;:&lt;/code&gt; パスリストの区切り文字として）、あなたはまだ使用して変換パスに試すことができます &lt;code&gt;cygpath&lt;/code&gt; 彼らがGHCと友人に渡される直前。</target>
        </trans-unit>
        <trans-unit id="4762767c31f000dd608b9d320e6a27ecd6749f85" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="translated">&lt;code&gt;/tmp&lt;/code&gt; のスペースが&lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;なくなったために（または、インストールで一時ファイルの移動先と思われる場所で）問題が発生した場合は、-tmpdir⟨dir⟩オプションオプションを使用して代替ディレクトリを指定できます。たとえば、 &lt;code&gt;-tmpdir .&lt;/code&gt; 現在の作業ディレクトリに一時ファイルを置くように言います。</target>
        </trans-unit>
        <trans-unit id="a0263efca84aff634e475d876d93d1d53987bcc2" translate="yes" xml:space="preserve">
          <source>If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module.</source>
          <target state="translated">特定のエンコーディング(例:UTF-8)を持つデータを扱うことが事前に分かっていて、アプリケーションのパフォーマンスが非常に敏感な場合、このモジュールの関数を使うよりも、バイト文字列を使ってI/Oを実行したり、自分でエンコードしたりデコードしたりした方が高速であることが分かるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9980c81f41f8848255c9b3c4f5b6f35d26a2660e" translate="yes" xml:space="preserve">
          <source>If you locally define a signature which specifies &lt;code&gt;type Elem = Char&lt;/code&gt;, you can now use &lt;code&gt;head&lt;/code&gt; from the inherited signature as if it returned a &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type Elem = Char&lt;/code&gt; を指定するシグニチャーをローカルで定義する場合、継承されたシグニチャーの &lt;code&gt;head&lt;/code&gt; を &lt;code&gt;Char&lt;/code&gt; を返すかのように使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="99a2b1931884bf135bea0a3fa27795d553e75cd2" translate="yes" xml:space="preserve">
          <source>If you make some changes to the source code and want GHCi to recompile the program, give the &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven&amp;rsquo;t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;).</source>
          <target state="translated">ソースコードに変更を加え、GHCiにプログラムを再コンパイルさせたい場合は、&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;コマンドを指定します。プログラムは必要に応じて再コンパイルされますが、GHCiは、モジュールの外部依存関係が変更されていない場合は実際にモジュールを再コンパイルしないように最善を尽くします。これは、バッチコンパイル設定でモジュールの再コンパイルを回避するために使用するメカニズムと同じです（&lt;a href=&quot;separate_compilation#recomp&quot;&gt;再コンパイルチェッカーを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8d9454e1d6cb0edc697a136b26feb4f14fca0245" translate="yes" xml:space="preserve">
          <source>If you must use a non-UTF-8 locale on an older version of GHC, you will have to perform the transcoding yourself, e.g. as follows:</source>
          <target state="translated">古いバージョンのGHCでUTF-8以外のロケールを使用する必要がある場合は、以下のように自分でトランスコードを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="c0177890eaf8c9853290382c679f931e99463619" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">文字列を部分文字列で繰り返し &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; する必要がある場合（たとえば、部分文字列のすべてのインスタンスで分割したい場合）は、起動オーバーヘッドが少ないため、代わりにbreakOnAllを使用します。</target>
        </trans-unit>
        <trans-unit id="ba1d6d4a81148f3b4501f77ab4535df2eb1411a3" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">文字列を部分文字列で繰り返し &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; する必要がある場合（たとえば、部分文字列のすべてのインスタンスで分割したい場合）は、起動オーバーヘッドが少ないため、代わりにbreakOnAllを使用します。</target>
        </trans-unit>
        <trans-unit id="60305b59f145cbe3c8640c6266d72f000c109cde" translate="yes" xml:space="preserve">
          <source>If you need to unmask asynchronous exceptions again in the exception handler, &lt;code&gt;restore&lt;/code&gt; can be used there too.</source>
          <target state="translated">例外ハンドラーで非同期例外を再度マスク解除する必要がある場合は、 &lt;code&gt;restore&lt;/code&gt; もそこで使用できます。</target>
        </trans-unit>
        <trans-unit id="4591e0c74e5d8610c0f46b0b70574c886adac838" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all saftey belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="translated">独自のビルダープリミティブを作成する必要がある場合は、&lt;em&gt;すべての安全ベルトをオフにし&lt;/em&gt;てコードを作成していることに注意してください。つまり、*これはアプリケーションをバッファオーバーフロー攻撃に対して脆弱にする可能性があるコードです！* &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt;モジュールは、エンコーディングを完全にテストするためのユーティリティを提供します。</target>
        </trans-unit>
        <trans-unit id="85034b2140ed46e219a17c0fb6a82d6555ea6a0b" translate="yes" xml:space="preserve">
          <source>If you redirect the interface file somewhere that GHC can&amp;rsquo;t find it, then the recompilation checker may get confused (at the least, you won&amp;rsquo;t get any recompilation avoidance). We recommend using a combination of &lt;code&gt;-hidir&lt;/code&gt; and &lt;code&gt;-hisuf&lt;/code&gt; options instead, if possible.</source>
          <target state="translated">GHCが見つけられない場所にインターフェースファイルをリダイレクトすると、再コンパイルチェッカーが混乱する可能性があります（少なくとも、再コンパイルを回避することはできません）。 &lt;code&gt;-hidir&lt;/code&gt; 、代わりに &lt;code&gt;-hisuf&lt;/code&gt; オプションと-hisufオプションを組み合わせて使用​​することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7c56d9c704da4ef4488b84c4ca979cb6f42ee172" translate="yes" xml:space="preserve">
          <source>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour is adversely affected. In one of these environments you should use the &lt;code&gt;ghcii.sh&lt;/code&gt; script to start GHCi, otherwise when you hit Control-C you&amp;rsquo;ll be returned to the shell prompt but the GHCi process will still be running. However, even using the &lt;code&gt;ghcii.sh&lt;/code&gt; script, if you hit Control-C then the GHCi process will be killed immediately, rather than letting you interrupt a running program inside GHCi as it should. This problem is caused by the fact that the Cygwin and MSYS shell environments don&amp;rsquo;t pass Control-C events to non-Cygwin child processes, because in order to do that there needs to be a Windows console.</source>
          <target state="translated">CygwinまたはMSYSシェルでGHCiを実行すると、Control-Cの動作が悪影響を受けます。これらの環境の1 &lt;code&gt;ghcii.sh&lt;/code&gt; 、ghcii.shスクリプトを使用してGHCiを起動する必要があります。そうしないと、Control-Cを押すとシェルプロンプトに戻りますが、GHCiプロセスは引き続き実行されます。ただし、 &lt;code&gt;ghcii.sh&lt;/code&gt; スクリプトを使用していても、Control-Cを押すと、GHCi内の実行中のプログラムを中断するのではなく、GHCiプロセスがすぐに強制終了されます。この問題は、CygwinおよびMSYSシェル環境がControl-Cイベントを非Cygwin子プロセスに渡さないために発生します。これを行うには、Windowsコンソールが必要だからです。</target>
        </trans-unit>
        <trans-unit id="baf4b7d8b90c0aee801d209afdb87b81f931a2c9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">あなたが設定されている場合 &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; フラグを（参照リンクする際に、適切に&lt;a href=&quot;phases#options-linker&quot;&gt;オプションリンクに影響する&lt;/a&gt;）プログラムを実行しているとき、あなたはRTSに、コマンドライン上のオプションを与えることができます。</target>
        </trans-unit>
        <trans-unit id="499bbb66890db92d2aef64ba55e59fe5e3a4a579" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">あなたが設定されている場合 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; フラグを（参照リンクする際に、適切に&lt;a href=&quot;phases#options-linker&quot;&gt;オプションリンクに影響する&lt;/a&gt;）プログラムを実行しているとき、あなたはRTSに、コマンドライン上のオプションを与えることができます。</target>
        </trans-unit>
        <trans-unit id="779ae353821cb3c36339c8fffc8e4e1da51bc948" translate="yes" xml:space="preserve">
          <source>If you specify the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo;, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</source>
          <target state="translated">オプションの「 &lt;code&gt;!&lt;/code&gt; 」、GHCはさらに、型の同義語を拡張して型関数アプリケーションを評価することにより型を正規化し、正規化した結果を表示します。</target>
        </trans-unit>
        <trans-unit id="17573b39128b09ddb274fe402c07a3712fa0b038" translate="yes" xml:space="preserve">
          <source>If you started up GHCi from the command line then GHCi&amp;rsquo;s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the &amp;ldquo;Start&amp;rdquo; menu in Windows, then the current directory is probably something like &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt;.</source>
          <target state="translated">コマンドラインからGHCiを起動した場合、GHCiの現在のディレクトリは、起動元のシェルの現在のディレクトリと同じです。Windowsの[スタート]メニューからGHCiを起動した場合、現在のディレクトリはおそらく &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt; ようなものです。</target>
        </trans-unit>
        <trans-unit id="ba902f4235b03731027db2ba203807d60051b0f0" translate="yes" xml:space="preserve">
          <source>If you still have a problem after consulting this section, then you may have found a &lt;em&gt;bug&lt;/em&gt;&amp;mdash;please report it! See &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt; for details on how to report a bug and a list of things we&amp;rsquo;d like to know about your bug. If in doubt, send a report &amp;mdash; we love mail from irate users :-!</source>
          <target state="translated">このセクションを参照しても問題が解決しない場合は、&lt;em&gt;バグ&lt;/em&gt;を発見した可能性があります&amp;mdash; 報告してください！参照してください&lt;a href=&quot;intro#bug-reporting&quot;&gt;GHCのバグを報告する&lt;/a&gt;バグ、私たちはあなたのバグについて知りたいことのリストを報告する方法の詳細については。疑わしい場合は、レポートを送信してください&amp;mdash;私たちは怒り狂ったユーザーからのメールが大好きです：-！</target>
        </trans-unit>
        <trans-unit id="bb6e307b2815d284d219246f3cc396f72341fb96" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt;, you should ensure that:</source>
          <target state="translated">ユーザーが指定した場合 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 、あなたのことを確認してください。</target>
        </trans-unit>
        <trans-unit id="f9036a091eb31d7e1d179225efb47ed576aaf8c2" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;, ensure:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; を指定する場合は、以下を確認してください。</target>
        </trans-unit>
        <trans-unit id="43deefe8a45aff4b957628597a98f2d9c624d164" translate="yes" xml:space="preserve">
          <source>If you supply both, you should also ensure:</source>
          <target state="translated">両方を供給する場合は、それも確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="e7ad27dbd268005c25e921cdbe065308694238cd" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値の配列（そうではない）と考えると、非効率的なコードを作成するリスクがあります。</target>
        </trans-unit>
        <trans-unit id="a276602bd275721caf00a235378e2576e4782424" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値の配列（そうではない）と考えると、非効率的なコードを書くリスクがあります。</target>
        </trans-unit>
        <trans-unit id="3de2aa2ed3ef394e6e0d1016569003785b8ad818" translate="yes" xml:space="preserve">
          <source>If you think that GHC could have produced a better error message, please report it as a bug.</source>
          <target state="translated">GHCがもっと良いエラーメッセージを出しても良かったのではないかと思われる方は、バグとして報告してください。</target>
        </trans-unit>
        <trans-unit id="c7f6f86d2972b585d04fe43fdaef1e7b40cc4531" translate="yes" xml:space="preserve">
          <source>If you turn on the &lt;code&gt;+t&lt;/code&gt; option, GHCi will show the type of each variable bound by a statement. For example:</source>
          <target state="translated">&lt;code&gt;+t&lt;/code&gt; オプションをオンにすると、GHCiはステートメントによってバインドされた各変数のタイプを表示します。例えば：</target>
        </trans-unit>
        <trans-unit id="5833a6633f41ece1646113439cfc7147d21b2d27" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;ghc --make&lt;/code&gt; and you don&amp;rsquo;t use the &lt;code&gt;-o&lt;/code&gt;, the name GHC will choose for the executable will be based on the name of the file containing the module &lt;code&gt;Main&lt;/code&gt;. Note that with GHC the &lt;code&gt;Main&lt;/code&gt; module doesn&amp;rsquo;t have to be put in file &lt;code&gt;Main.hs&lt;/code&gt;. Thus both</source>
          <target state="translated">あなたが使用している場合は &lt;code&gt;ghc --make&lt;/code&gt; 、あなたが使用していない &lt;code&gt;-o&lt;/code&gt; を、GHCが実行のために選択する名前は、モジュール含むファイルの名前に基づいています &lt;code&gt;Main&lt;/code&gt; 。GHCでは、 &lt;code&gt;Main&lt;/code&gt; モジュールをファイル &lt;code&gt;Main.hs&lt;/code&gt; に置く必要がないことに注意してください。したがって、両方</target>
        </trans-unit>
        <trans-unit id="b8fe07ab672e6ec151ea93a6073a6731a1a39a86" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt; flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt;フラグを使用すると、GHCは多態的なローカルバインディングについて警告します。警告の一部として、GHCは推定された型も報告します。このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="d28c5895543f69e7126cf50a6926f46b942709ca" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; フラグを使用する場合は、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;を使用して統計にアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="b229e3d5ff9a118b7d23643c61f72dbd7947f474" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-T&lt;/code&gt; フラグを使用する場合は、&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;を使用して統計にアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="bd5a15f9c3c8b55e5de03f7f69c8dd111c9672ec" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-s&lt;/code&gt; flag then, when your program finishes, you will see something like this (the exact details will vary depending on what sort of RTS you have, e.g. you will only see profiling data if your RTS is compiled for profiling):</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; フラグを使用すると、プログラムが終了すると、次のようなものが表示されます（正確な詳細は、RTSの種類によって異なります。たとえば、RTSがプロファイリング用にコンパイルされている場合にのみ、プロファイリングデータが表示されます）。 ：</target>
        </trans-unit>
        <trans-unit id="b228a004af7cc3ea3defaec36492a49b21092145" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-t&lt;/code&gt; flag then, when your program finishes, you will see something like this:</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; フラグを使用すると、プログラムが終了すると、次のようなものが表示されます。</target>
        </trans-unit>
        <trans-unit id="42843f480d669d0dd71c1f456d85a83006a59f62" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt;を使用すると、孤立モジュールを作成している場合、GHCは警告を出します。すべての警告と同じように、あなたが警告をオフに切り替えることができます&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; は&lt;/a&gt;警告が発行された場合、コンパイルが失敗になります。</target>
        </trans-unit>
        <trans-unit id="5c0d6aaecc809c7a412ba9777573bc108e4291b9" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt;を使用すると、孤立したモジュールを作成している場合、GHCは警告を表示します。他の警告と同様に、&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; を使用&lt;/a&gt;して警告をオフに切り替えることができます。警告が発行されると、&lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;によってコンパイルが失敗します。</target>
        </trans-unit>
        <trans-unit id="3539d052ca8f3d12bdfa6a2cf6c42e142aedfd6e" translate="yes" xml:space="preserve">
          <source>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</source>
          <target state="translated">オーバーロードされたクラスのメソッドに本当に適用されるruleが欲しい場合は、こんな感じでしかありません。</target>
        </trans-unit>
        <trans-unit id="cc687a75092e5bd8f51f4c5f01b8880c77b9787b" translate="yes" xml:space="preserve">
          <source>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The &lt;code&gt;id runST&lt;/code&gt; example can be written using this workaround like this:</source>
          <target state="translated">命令型のポリモーフィズムが必要な場合、主な回避策はnewtypeラッパーを使用することです。 &lt;code&gt;id runST&lt;/code&gt; 例は次のようにこの回避策を使用して書くことができます。</target>
        </trans-unit>
        <trans-unit id="51a0b4a5af5e77d81a82bb08f150b3da8ce734c3" translate="yes" xml:space="preserve">
          <source>If you want line-buffered behaviour, as in GHC, you can start your program thus:</source>
          <target state="translated">GHC のようにラインバッファで動作させたい場合は、次のようにプログラムを開始することができます。</target>
        </trans-unit>
        <trans-unit id="8ca971e710dc0dea81074a50ffdb031c934cf7b8" translate="yes" xml:space="preserve">
          <source>If you want the latter type, you can write your &lt;code&gt;forall&lt;/code&gt;s explicitly. Indeed, doing so is strongly advised for rank-2 types.</source>
          <target state="translated">後者のタイプが必要な場合は、 &lt;code&gt;forall&lt;/code&gt; を明示的に記述できます。実際、ランク2タイプではそうすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="549a9b63d55271a3b9df4de32eb523229040185b" translate="yes" xml:space="preserve">
          <source>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; when it completes, and have the main thread wait on all the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s before exiting:</source>
          <target state="translated">終了する前に子スレッドの終了をプログラムに待機させる場合は、これを自分でプログラミングする必要があります。単純なメカニズムは、各子スレッドが完了時に &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; に書き込み、メインスレッドがすべての &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を待機してから終了することです。</target>
        </trans-unit>
        <trans-unit id="0f9571a9dcbff8738c6a55f4c7676d668b8f5fc0" translate="yes" xml:space="preserve">
          <source>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example.</source>
          <target state="translated">C のコールバックから Haskell にデータを戻したい場合は、上の例で行ったように、Haskell でデータを受け取るためのメモリを確保し、アドレスを C に渡すのがベストです。</target>
        </trans-unit>
        <trans-unit id="f34429256ffca9baa1e5bbc692ae867402400276" translate="yes" xml:space="preserve">
          <source>If you want to create hard link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Windowsでハードリンクを作成する場合は、代わりに &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="791c272c3172b5ca90ccf11219abe251062c8501" translate="yes" xml:space="preserve">
          <source>If you want to create symbolic link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Windowsでシンボリックリンクを作成する場合は、代わりに &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="e3df7bf8a33fccc5739143bc2735696e4c097cb3" translate="yes" xml:space="preserve">
          <source>If you want to do some cleanup in the event that an exception is raised, use &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例外が発生した場合にクリーンアップを行う場合は、 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="3c4838ba039983c15a539bfb6ca822e21c42138c" translate="yes" xml:space="preserve">
          <source>If you want to do the steps manually or are writing your own build system then there are certain conventions that must be followed. Building a shared library that exports Haskell code, to be used by other Haskell code is a bit more complicated than it is for one that exports a C API and will be used by C code. If you get it wrong you will usually end up with linker errors.</source>
          <target state="translated">手順を手動で行いたい場合や、独自のビルドシステムを作成している場合は、従わなければならない規則があります。Haskell コードをエクスポートして他の Haskell コードで使用される共有ライブラリをビルドするのは、C API をエクスポートして C コードで使用されるライブラリよりも少し複雑です。間違えてしまうと、通常はリンカエラーが発生してしまいます。</target>
        </trans-unit>
        <trans-unit id="f0fb26a20e253d10479d39da2a4fcad468dce057" translate="yes" xml:space="preserve">
          <source>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</source>
          <target state="translated">コストセンターに関数名とは異なる名前をつけたい場合は、アノテーションに文字列を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="7c4f1ffc646261bf14798c8c4f8089e635cc58af" translate="yes" xml:space="preserve">
          <source>If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</source>
          <target state="translated">標準の Haskell コードでアサーションを利用したい場合は、以下のような関数を定義することができます。</target>
        </trans-unit>
        <trans-unit id="6f423384a233b13b91f89809f16b0b043668524f" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">プログラムのプリミティブデータタイプまたは操作について言及したい場合は、最初に &lt;code&gt;GHC.Prim&lt;/code&gt; をインポートしてそれらをスコープに含める必要があります。それらの多くは &lt;code&gt;#&lt;/code&gt; で終わる名前があり、そのような名前について言及するには、&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;拡張機能が必要です。</target>
        </trans-unit>
        <trans-unit id="61014e31e4e9b046a9ef2fe3074becc72ef93381" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just expliticly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="translated">すべての前処理をオプトアウトするには、パスで名前空間を明示的に使用します。この変更により、RAWデバイス（COMポートなど）を開く必要がある場合は、デバイスの名前空間を明示的に使用する必要があります。（例 &lt;code&gt;\\.\COM1&lt;/code&gt; ）。GHCおよびHaskellプログラムは、一般に、レガシー形式でデバイスを開くことをサポートしなくなりました。</target>
        </trans-unit>
        <trans-unit id="6ebcdc956ed871c44f4c6bca024bf09987c0e4ea" translate="yes" xml:space="preserve">
          <source>If you want to reexport an entity from a signature, you must also include a &lt;code&gt;module SigName&lt;/code&gt; export, so that all of the entities defined in the signature are exported. For example, the following module exports both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;:</source>
          <target state="translated">署名からエンティティを再エクスポートする場合は、 &lt;code&gt;module SigName&lt;/code&gt; エクスポートも含める必要があります。これにより、署名で定義されたすべてのエンティティがエクスポートされます。たとえば、次のモジュールは &lt;code&gt;Prelude&lt;/code&gt; から &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; の両方をエクスポートします。</target>
        </trans-unit>
        <trans-unit id="0a5bd52fcd4928ca0545145bd2a955f15998cd35" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">後で使用する場合は、ポインタが最後に使用された後に &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; を確実にタッチして、配列が早く解放されないようにしてください。</target>
        </trans-unit>
        <trans-unit id="2bf3e986051a32ecf5c1ec7e4a43659b77ba4029" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">後で使用する場合は、ポインタが最後に使用された後に &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; を確実にタッチして、配列が早く解放されないようにしてください。</target>
        </trans-unit>
        <trans-unit id="f60cbafbc7fa66b6dc79d12e60e2984d79a1c2f8" translate="yes" xml:space="preserve">
          <source>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</source>
          <target state="translated">自分で良い消費者や生産者を書きたい場合は、上記の機能のプレリュードの定義を見て、その方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cc3353ab3b67d47aa44c20e1d16cbe4a8241b654" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; option. This option takes precedence over &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">エクスポートされたすべてのトップレベルの関数/値に型シグネチャがあることをGHCで確認し、エクスポートされていない値は確認しない場合は、&lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt;オプションを使用します。このオプションは&lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt;よりも優先されます。警告の一部として、GHCは推定された型も報告します。このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="fb30d07648b8cbbd10ad61170b84d1c688b54b88" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every pattern synonym has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt;&lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt;&lt;/a&gt; option. If this option is used in conjunction with &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</source>
          <target state="translated">すべてのパターンシノニムにタイプシグネチャがあることをGHCに確認させる場合は、&lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt; &lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt; &lt;/a&gt;オプションを使用します。このオプションを&lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​する場合、エクスポートされたパターンシノニムのみが型シグネチャを持つ必要があります。GHCは推定された型も報告します。このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="640d34ea6f4536c99e1408cd399b64374ccf19de" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every top-level function/value has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt; option. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">すべてのトップレベルの関数/値に型シグネチャがあることをGHCに確認させるには、&lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt;オプションを使用します。警告の一部として、GHCは推定された型も報告します。このオプションはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="922fe94f618cace70dccf3e7c465abb01606e0ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re feeling really paranoid, the &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt;&lt;code&gt;-dcore-lint&lt;/code&gt;&lt;/a&gt; option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">本当に偏執的だと感じている場合は、&lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt; &lt;code&gt;-dcore-lint&lt;/code&gt; &lt;/a&gt;オプションが適しています。GHC内のヘビー級のパス内の健全性チェックをオンにします。（それはあなたのものではなくGHCの健全性をチェックします。）</target>
        </trans-unit>
        <trans-unit id="2a661b6665d9019ecdcc937c98f6c881af1386b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;Complex&lt;/code&gt;, definitely use &lt;code&gt;Complex Double&lt;/code&gt; rather than &lt;code&gt;Complex Float&lt;/code&gt; (the former is specialised heavily, but the latter isn&amp;rsquo;t).</source>
          <target state="translated">&lt;code&gt;Complex&lt;/code&gt; を使用している場合は、 &lt;code&gt;Complex Float&lt;/code&gt; ではなく &lt;code&gt;Complex Double&lt;/code&gt; を必ず使用してください（前者は専門性が高く、後者は専門性が高くありません）。</target>
        </trans-unit>
        <trans-unit id="6ea05e3cdd60f132f915750383a0d35497a9912f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your &lt;code&gt;.cabal&lt;/code&gt; specification. The exposed/hidden status of packages is only relevant when using &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; directly.</source>
          <target state="translated">Cabalを使用している場合、パッケージの公開または非表示のステータスは関係ありません。代わりに、使用可能なパッケージは、 &lt;code&gt;.cabal&lt;/code&gt; 仕様にリストされている依存関係によって決定されます。パッケージの公開/非表示ステータスは、 &lt;code&gt;ghc&lt;/code&gt; または &lt;code&gt;ghci&lt;/code&gt; を直接使用する場合にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="d0881127c805c94fe0b7925eea21f4274da0ef78" translate="yes" xml:space="preserve">
          <source>If you'd like to be able to set environment variables to blank strings, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">環境変数を空の文字列に設定できるようにするには、 &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="99dd4325947ff2bc013e316ae08d0a505ef5df45" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="translated">&lt;code&gt;GHC.Generics&lt;/code&gt; を使用している場合は、多くの便利な汎用関数が含まれている&lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt;パッケージの使用を検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf81c24bf66e4ccd3de419acbb16c71960559688" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">あなたの場合は &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; もある &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; の、人気の定義があります</target>
        </trans-unit>
        <trans-unit id="9b9d738102f8d206b5388e75296045ea1b95c56d" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">あなたの場合は &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; もある &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; の、人気の定義があります</target>
        </trans-unit>
        <trans-unit id="94332bc18cf68bdf173c4385ef20100acbd02982" translate="yes" xml:space="preserve">
          <source>If your datatype has a single constructor with a single field, use a &lt;code&gt;newtype&lt;/code&gt; declaration instead of a &lt;code&gt;data&lt;/code&gt; declaration. The &lt;code&gt;newtype&lt;/code&gt; will be optimised away in most cases.</source>
          <target state="translated">あなたのデータ型は、単一のフィールドを持つ単一のコンストラクタを持っている場合は、使用 &lt;code&gt;newtype&lt;/code&gt; 宣言の代わりに、 &lt;code&gt;data&lt;/code&gt; 宣言を。 &lt;code&gt;newtype&lt;/code&gt; のは、ほとんどの場合、離れて最適化されます。</target>
        </trans-unit>
        <trans-unit id="1c1b5c441eca4c4d33097e3b6efbf4299541fa8b" translate="yes" xml:space="preserve">
          <source>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the &lt;code&gt;Main&lt;/code&gt; module, and GHC will examine the &lt;code&gt;import&lt;/code&gt; declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the &lt;code&gt;Main&lt;/code&gt; module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module &lt;code&gt;Data.Person&lt;/code&gt; would be in the file &lt;code&gt;Data/Person.hs&lt;/code&gt; on Unix/Linux/Mac, or &lt;code&gt;Data\Person.hs&lt;/code&gt; on Windows.</source>
          <target state="translated">プログラムに複数のモジュールが含まれている場合は、 &lt;code&gt;Main&lt;/code&gt; モジュールを含むソースファイルの名前をGHCに通知するだけでよく、GHCは &lt;code&gt;import&lt;/code&gt; 宣言を調べて、プログラムを構成する他のモジュールを見つけ、ソースファイルを見つけます。つまり、 &lt;code&gt;Main&lt;/code&gt; モジュールを除いて、すべてのソースファイルには、含まれているモジュール名に基づいて名前を付ける必要があります（ドットはディレクトリセパレーターで置き換えます）。例えば、モジュール &lt;code&gt;Data.Person&lt;/code&gt; は、ファイルにあるであろう &lt;code&gt;Data/Person.hs&lt;/code&gt; のUnix / Linuxの/ Macの、または上の &lt;code&gt;Data\Person.hs&lt;/code&gt; Windows上。</target>
        </trans-unit>
        <trans-unit id="12c51f85806fd47c9dd60cc6181af38ca30de15c" translate="yes" xml:space="preserve">
          <source>If your program has no foreign calls in it, and no calls to known-unsafe functions (such as &lt;code&gt;unsafePerformIO&lt;/code&gt;) then a crash is always a BUG in the GHC system, except in one case: If your program is made of several modules, each module must have been compiled after any modules on which it depends (unless you use &lt;code&gt;.hi-boot&lt;/code&gt; files, in which case these &lt;em&gt;must&lt;/em&gt; be correct with respect to the module source).</source>
          <target state="translated">プログラムに外部呼び出しがなく、既知の安全でない関数（ &lt;code&gt;unsafePerformIO&lt;/code&gt; など）への呼び出しがない場合、クラッシュは常にGHCシステムのバグです。 moduleは、依存するモジュールの後にコンパイルされている必要があります（ &lt;code&gt;.hi-boot&lt;/code&gt; ファイルを使用する場合を除きます。この場合、これらはモジュールソースに関して正しい&lt;em&gt;必要&lt;/em&gt;があります）。</target>
        </trans-unit>
        <trans-unit id="6d6ef9a1cfc5c74eeeabcdcb897c3ce978bdc728" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; or &lt;code&gt;-A ⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">プログラムのGC統計（ &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTSオプション）が大量のガベージコレクション（実行時間の20％以上など）を実行していることを示している場合は、 &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; または &lt;code&gt;-A ⟨size⟩&lt;/code&gt; オプション（&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;ガベージコレクターを制御するには、RTSオプションを&lt;/a&gt;参照してください）。経験則として、 &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; をプロセスで消費できるメモリの量に設定するか、引数なしで &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; を渡してGHCに値を計算させてみてください。ライブデータの量に基づいています。</target>
        </trans-unit>
        <trans-unit id="f24caa1726f2cf05e2f221b7c2e73786d79f53d8" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H⟨size⟩&lt;/code&gt; or &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H ⟨size⟩&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H ⟨size⟩&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">プログラムのGC統計（ &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTSオプション）が大量のガベージコレクション（たとえば、実行時間の20％以上）を実行していることを &lt;code&gt;-H⟨size⟩&lt;/code&gt; 場合、-H⟨size⟩または &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTSオプション（&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;ガベージコレクターを制御するRTSオプションを&lt;/a&gt;参照）。経験則として、 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; をプロセスで消費できるメモリ量に設定するか、引数なしで &lt;code&gt;-H ⟨size⟩&lt;/code&gt; を渡してGHCに量に基づいた値を計算させてくださいライブデータの。</target>
        </trans-unit>
        <trans-unit id="5d51b512922ef864f145abd749faf72a2827c750" translate="yes" xml:space="preserve">
          <source>If your shared library exports a Haskell API then you cannot directly link it into another Haskell program and use that Haskell API. You will get linker errors. You must instead make it into a package as described in the section above.</source>
          <target state="translated">共有ライブラリがHaskell APIをエクスポートしている場合、それを別のHaskellプログラムに直接リンクしてそのHaskell APIを使用することはできません。リンカエラーが発生します。代わりに、上のセクションで説明したようにパッケージにする必要があります。</target>
        </trans-unit>
        <trans-unit id="d789f4ed9268a1d21783901d260313592caf0cd5" translate="yes" xml:space="preserve">
          <source>If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">⟨n⟩を省略した場合は、レベル2とします。</target>
        </trans-unit>
        <trans-unit id="02e8f60e1dacd712159be5f50380ce32b92d474d" translate="yes" xml:space="preserve">
          <source>If ⟨prompt⟩ starts with &lt;code&gt;&quot;&lt;/code&gt; then it is parsed as a Haskell String; otherwise it is treated as a literal string.</source>
          <target state="translated">「プロンプト &lt;code&gt;&quot;&lt;/code&gt; 始まる場合は、Haskell文字列として解析されます。それ以外の場合は、リテラル文字列として扱われます。</target>
        </trans-unit>
        <trans-unit id="f40887e4a14555fe188999a20b1ed14821cfa667" translate="yes" xml:space="preserve">
          <source>If ⟨size⟩ is omitted, then the garbage collector will take the size of the heap at the previous GC as the ⟨size⟩. This has the effect of allowing for a larger &lt;code&gt;-A&lt;/code&gt; value but without increasing the overall memory requirements of the program. It can be useful when the default small &lt;code&gt;-A&lt;/code&gt; value is suboptimal, as it can be in programs that create large amounts of long-lived data.</source>
          <target state="translated">「サイズ」を省略した場合、ガベージコレクターは前のGCでのヒープのサイズを「サイズ」として取得します。これにより、 &lt;code&gt;-A&lt;/code&gt; の値を大きくすることができますが、プログラムの全体的なメモリ要件は増加しません。これは、デフォルトのsmall &lt;code&gt;-A&lt;/code&gt; 値が最適ではない場合に役立ちます。これは、長期間有効なデータを大量に作成するプログラムで発生する可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="c3cbf12867cec0a1cfdbab9049d695f31f35ad31" translate="yes" xml:space="preserve">
          <source>If, as a library author of a type constructor like &lt;code&gt;Set a&lt;/code&gt;, you want to prevent a user of your module to write &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt;, you need to set the role of &lt;code&gt;Set&lt;/code&gt;'s type parameter to &lt;code&gt;nominal&lt;/code&gt;, by writing</source>
          <target state="translated">&lt;code&gt;Set a&lt;/code&gt; のようなタイプコンストラクターのライブラリ作成者として、モジュールのユーザーが &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt; に書き込みを行わないようにする場合：Set T-&amp;gt; Set NT、 &lt;code&gt;Set&lt;/code&gt; のタイプパラメーターの役割を &lt;code&gt;nominal&lt;/code&gt; に設定する必要があります。書いて</target>
        </trans-unit>
        <trans-unit id="2ae8e5b9dd31d643002083a67d731779f470355f" translate="yes" xml:space="preserve">
          <source>If, however, you enable the extension &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</source>
          <target state="translated">ただし、（D）を含むモジュールをコンパイルするときに拡張機能&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;を有効にすると、GHCは代わりに（C）を選択し、その後のインスタンス化の問題について文句を言うことはありません。</target>
        </trans-unit>
        <trans-unit id="6b618f909fc1ba5b25f3ecf49daabdeb00466da8" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">いずれかの次元で、下限が上限より大きい場合、配列は有効ですが空です。空の配列にインデックスを付けると、常に配列境界エラーが発生しますが、 &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 依然として、配列が構築された境界を生成します。</target>
        </trans-unit>
        <trans-unit id="581c6edcefcd8eed3b3ae0f7ff0449e91b4a1964" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">いずれかの次元で、下限が上限より大きい場合、配列は有効ですが空です。空の配列にインデックスを付けると、常に配列境界エラーが発生しますが、 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 依然として、配列が構築された境界を生成します。</target>
        </trans-unit>
        <trans-unit id="f0312c7db6cdd96c1e4afe75b973aea9e68784cd" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">いずれかの次元で、下限が上限より大きい場合、配列は有効ですが空です。空の配列にインデックスを付けると、常に配列境界エラーが発生しますが、 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 依然として、配列が構築された境界を生成します。</target>
        </trans-unit>
        <trans-unit id="7f3727d8d991f15f746dc285dd2ca3bc1e889211" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく、\（O（n \ log n）\）評価が与えられます。</target>
        </trans-unit>
        <trans-unit id="2bb6b96d1379082a5862430606e077e4951c8b2d" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく\（O（n \ log n）\）の評価が与えられます。</target>
        </trans-unit>
        <trans-unit id="a437f0ed534e2c46aa15fd000c2c49a678255cee" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく\（O（n \ log n）\）評価が与えられます。</target>
        </trans-unit>
        <trans-unit id="a830bfeca5ac45c0e56970fbc2cc9313f12b8526" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく\（O（n \ log n）\）が評価されます。</target>
        </trans-unit>
        <trans-unit id="85f1c19a944153820e63548e8f204d611cc0ec11" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく、\（O（n \ log n）\）評価が与えられます。</target>
        </trans-unit>
        <trans-unit id="b49b973971f72b90b88232bbeeb66a8215462172" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく\（O（n \ log n）\）の評価が与えられます。</target>
        </trans-unit>
        <trans-unit id="79ddcd1aa495c4907a6fe0bad7ff4515b81505d0" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく\（O（n \ log n）\）評価が与えられます。</target>
        </trans-unit>
        <trans-unit id="98de0ed556230c1fbd1808a2934adcaaa69ac02e" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">代わりに、 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; が使用された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; はすべての比較で評価され、\（O（n）\）ではなく\（O（n \ log n）\）が評価されます。</target>
        </trans-unit>
        <trans-unit id="98f55db57c8ed898dbaabddea8af88630b3b7caf" translate="yes" xml:space="preserve">
          <source>Ignore</source>
          <target state="translated">Ignore</target>
        </trans-unit>
        <trans-unit id="6ced7795214ecfa08f172052b124c985d4dc2867" translate="yes" xml:space="preserve">
          <source>Ignore an invalid input, substituting nothing in the output.</source>
          <target state="translated">無効な入力を無視して、出力に何も入れません。</target>
        </trans-unit>
        <trans-unit id="8de491836ac03baa0a19777da9dff92193700b2f" translate="yes" xml:space="preserve">
          <source>Ignore assertions in the source. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ソースのアサーションを無視します。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="796ae3faa0a04e8aa497303246f1859cfbe98a2a" translate="yes" xml:space="preserve">
          <source>Ignore cfg weights for code layout.</source>
          <target state="translated">コードレイアウトのために cfg の重みを無視します。</target>
        </trans-unit>
        <trans-unit id="282a96dffe5fa4b96c3595d453205018d521d4f8" translate="yes" xml:space="preserve">
          <source>Ignore marks.</source>
          <target state="translated">マークは無視してください。</target>
        </trans-unit>
        <trans-unit id="619d7d17ba8aa59dc524ffcd3b64d16b188b1a3c" translate="yes" xml:space="preserve">
          <source>Ignore package ⟨pkg⟩</source>
          <target state="translated">パッケージを無視する ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="591f0c15c8a037cd490c5cb494c2d82d49da6604" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt; only.</source>
          <target state="translated">インターフェイスファイルのプラグマを無視します。&lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt;によってのみ暗黙指定されます。</target>
        </trans-unit>
        <trans-unit id="cf4ec85769b7a4182ac16f4a75bfe188c6947b6d" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;code&gt;-O0&lt;/code&gt; only.</source>
          <target state="translated">インターフェイスファイルのプラグマは無視してください。 &lt;code&gt;-O0&lt;/code&gt; によってのみ暗示されます。</target>
        </trans-unit>
        <trans-unit id="58001447e7c0f2060ba0e27ea5f58c03c12170c4" translate="yes" xml:space="preserve">
          <source>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">インストール済みパッケージの公開フラグを無視し、デフォルトでそれらをすべて非表示にします。このフラグを使用する場合、必要なパッケージ（ &lt;code&gt;base&lt;/code&gt; を含む）は、&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;オプションを使用して明示的に公開する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f1acc423ed92fdcade39f871d86c0a091be2b4d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">インストール済みパッケージの信頼フラグを無視し、デフォルトでそれらを信頼しない。このフラグとSafe Haskellを使用する場合、信頼する必要があるパッケージ（ &lt;code&gt;base&lt;/code&gt; を含む）は、 &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; オプションを使用して明示的に信頼する必要があります。このオプションは、パッケージの公開/非表示ステータスを変更しないため、システム上のすべてのパッケージに &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; を適用することと同じではありません。（&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskellを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="d1a80c4097f230ea51440815b595a3404f62d484" translate="yes" xml:space="preserve">
          <source>IgnoreBreak</source>
          <target state="translated">IgnoreBreak</target>
        </trans-unit>
        <trans-unit id="4bc3560f87c85dba51d0aa8d52c5b4fea219fa0e" translate="yes" xml:space="preserve">
          <source>IgnoreCR</source>
          <target state="translated">IgnoreCR</target>
        </trans-unit>
        <trans-unit id="5cc74aacba3116f5c95cef183a2a38286abfa5de" translate="yes" xml:space="preserve">
          <source>IgnoreCodingFailure</source>
          <target state="translated">IgnoreCodingFailure</target>
        </trans-unit>
        <trans-unit id="fe3f599d5da3fc2eaa2412ebe7eba8e9f6ce8049" translate="yes" xml:space="preserve">
          <source>IgnoreParityErrors</source>
          <target state="translated">IgnoreParityErrors</target>
        </trans-unit>
        <trans-unit id="7045891c278655482762e70dd83a0b56759287f9" translate="yes" xml:space="preserve">
          <source>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</source>
          <target state="translated">指定された反復回数のブレークポイントを無視することも、同様の手法を用いて可能です。</target>
        </trans-unit>
        <trans-unit id="2575568b1dcfc64c91f1f0fba9eba34462ba8283" translate="yes" xml:space="preserve">
          <source>IllegalOperation</source>
          <target state="translated">IllegalOperation</target>
        </trans-unit>
        <trans-unit id="21b60a9549daf6edf60beed5d20bc1d15c3b1b25" translate="yes" xml:space="preserve">
          <source>Immediately</source>
          <target state="translated">Immediately</target>
        </trans-unit>
        <trans-unit id="06ecb0ede3eff0f856805c208c7b6f7685988a9a" translate="yes" xml:space="preserve">
          <source>Immutable array type.</source>
          <target state="translated">不変の配列型。</target>
        </trans-unit>
        <trans-unit id="f741bf79c240632317d4b768abc8b5c1a34b775c" translate="yes" xml:space="preserve">
          <source>Immutable arrays, with an overloaded interface. For array types which can be used with this interface, see the &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; type exported by this module and the &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; module. Other packages, such as diffarray, also provide arrays using this interface.</source>
          <target state="translated">インターフェースがオーバーロードされた不変の配列。このインターフェイスで使用できる配列型については、このモジュールによってエクスポートされる &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 型と&lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt;モジュールを参照してください。diffarrayなどの他のパッケージも、このインターフェイスを使用して配列を提供します。</target>
        </trans-unit>
        <trans-unit id="2439111ed8a6dd1e9e35ac3526ebfdf6f8659f07" translate="yes" xml:space="preserve">
          <source>Immutable non-strict (boxed) arrays</source>
          <target state="translated">不変の非厳格(箱型)配列</target>
        </trans-unit>
        <trans-unit id="f0150626bdfa29e3185274acde3b82736d872c8f" translate="yes" xml:space="preserve">
          <source>Immutable non-strict arrays</source>
          <target state="translated">不変の非厳密配列</target>
        </trans-unit>
        <trans-unit id="ad6434427f6f7e2bf4d2041f12cd8285fbd475e3" translate="yes" xml:space="preserve">
          <source>ImplBidir</source>
          <target state="translated">ImplBidir</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3c9c8e530dca9330d05d5aa3109b2b8286699aca" translate="yes" xml:space="preserve">
          <source>Implementation Internals</source>
          <target state="translated">実装内部</target>
        </trans-unit>
        <trans-unit id="f225c7ab898261af0638456301826901232d3d11" translate="yes" xml:space="preserve">
          <source>Implementation details aside, the function names in the stack should hopefully give you enough clues to track down the bug.</source>
          <target state="translated">実装の詳細はさておき、スタック内の関数名を見れば、うまくいけばバグを突き止めるのに十分な手がかりが得られるはずです。</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">実施上の注意事項</target>
        </trans-unit>
        <trans-unit id="04f0e36fb0e54bb9f6609b935523e843d65a2659" translate="yes" xml:space="preserve">
          <source>Implementations for the character predicates (isLower, isUpper, etc.) and the conversions (toUpper, toLower). The implementation uses libunicode on Unix systems if that is available.</source>
          <target state="translated">文字述語(isLower,isUpperなど)と変換(toUpper,toLower)のための実装。この実装では、Unixシステム上で利用可能であればlibunicodeを使用します。</target>
        </trans-unit>
        <trans-unit id="4803faa28409cecc36571d8ab8726f7adec639ce" translate="yes" xml:space="preserve">
          <source>Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files. That is, &lt;em&gt;there may either be many handles on the same file which manage input, or just one handle on the file which manages output&lt;/em&gt;. If any open or semi-closed handle is managing a file for output, no new handle can be allocated for that file. If any open or semi-closed handle is managing a file for input, new handles can only be allocated if they do not manage output. Whether two files are the same is implementation-dependent, but they should normally be the same if they have the same absolute path name and neither has been renamed, for example.</source>
          <target state="translated">実装は、可能な限り、少なくともHaskellプロセスに対してローカルに、ファイルに対する複数リーダーの単一ライターロックを実施する必要があります。つまり&lt;em&gt;、同じファイルに入力を管理するハンドルが多数ある場合&lt;/em&gt;と、&lt;em&gt;出力を管理するファイルにハンドルが1つしかない場合があります&lt;/em&gt;。オープンまたはセミクローズハンドルが出力用にファイルを管理している場合、そのファイルに新しいハンドルを割り当てることはできません。オープンまたはセミクローズハンドルが入力用にファイルを管理している場合、新しいハンドルは、出力を管理していない場合にのみ割り当てることができます。2つのファイルが同じかどうかは実装に依存しますが、たとえば、絶対パス名が同じで、どちらも名前が変更されていない場合、それらは通常同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="95b15fdd44b258375ec9508491e65e9614ff63d6" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="ee9605b9875596b2f9957b69963d14d19dbd98a4" translate="yes" xml:space="preserve">
          <source>Implemented using an algorithm adapted from /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design&lt;em&gt;, by Chris Okasaki, &lt;/em&gt;ICFP'00/.</source>
          <target state="translated">/ Breadth-First Numbering：Lessons from a Small Exercise in Algorithm Design &lt;em&gt;、Chris&lt;/em&gt; OkasakiによるICFP'00 / からのアルゴリズムを使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="ce44457603020d3e393a5770d9319edff0c59393" translate="yes" xml:space="preserve">
          <source>Implicit call stacks</source>
          <target state="translated">暗黙のコールスタック</target>
        </trans-unit>
        <trans-unit id="e4767a7af64b718f0f087f2f77c45daac0f221c4" translate="yes" xml:space="preserve">
          <source>Implicit parameter binding declaration. Can only be used in let and where clauses which consist entirely of implicit bindings.</source>
          <target state="translated">暗黙のパラメータバインディング宣言。暗黙のバインディングのみで構成される let 句や where 句でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8e5e6bdeb8195ae9a56250fa5a11abb1b4c4ca76" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="translated">暗黙のパラメータ（参照&lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;暗黙のパラメータは&lt;/a&gt;、明示的な型シグネチャがある場合）、ブレークポイントの範囲でのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="96344ea55749ca67fb2833fb9d1ea7587feab87a" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">暗黙的なパラメータは、&lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]で&lt;/a&gt;説明されているように実装され、オプション&lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; で&lt;/a&gt;有効になります。（以下のほとんどのドキュメントはまだ不完全ですが、Jeff Lewisによるものです。）</target>
        </trans-unit>
        <trans-unit id="f3e48b33a4890da92cd70584a377ecd462ba1a72" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">暗黙のパラメータは&lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]で&lt;/a&gt;説明されているように実装され、オプション&lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; で&lt;/a&gt;有効になります。（以下のほとんどの、まだかなり不完全なドキュメントは、Jeff Lewisによるものです。）</target>
        </trans-unit>
        <trans-unit id="d896817ab0c9fc745a6846e04e6e0b797e133fb2" translate="yes" xml:space="preserve">
          <source>Implicit-parameter constraints do not cause ambiguity. For example, consider:</source>
          <target state="translated">暗黙のパラメータ制約は、曖昧さの原因にはなりません。例えば、考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e96fdb8318fd32f2e2e39a2a6d18b9f85a8f84b4" translate="yes" xml:space="preserve">
          <source>ImplicitParams</source>
          <target state="translated">ImplicitParams</target>
        </trans-unit>
        <trans-unit id="2b2233be7646337ec9333a40a93e6817457da678" translate="yes" xml:space="preserve">
          <source>ImplicitPrelude</source>
          <target state="translated">ImplicitPrelude</target>
        </trans-unit>
        <trans-unit id="218aafacdf8f46f838b7332039de5c3dbbc7cc14" translate="yes" xml:space="preserve">
          <source>Implied by</source>
          <target state="translated">によって暗示される</target>
        </trans-unit>
        <trans-unit id="f91e7074a90e49338f31c7b8d7563d1849b2d089" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt;によって示され、それ以外の場合はオフになります。</target>
        </trans-unit>
        <trans-unit id="9084c82dfec5377f9fc397a036577c18a18be8e1" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt;によって暗示され、それ以外の場合はオフです。</target>
        </trans-unit>
        <trans-unit id="b621c4b935c566b23caad050661b44248a2aea06" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;によって暗示されます。&lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="f431cb19e87fba9b86d9726b255a020698520002" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wtyped-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;によって暗示されます。&lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wtyped-holes&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="3cb21b29dd0fa6b86f91cfc36f481aa089a2398e" translate="yes" xml:space="preserve">
          <source>Implied by:</source>
          <target state="translated">によって暗示されています。</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="6242df79ef25a40efdb6b02069e963ee6c75ae36" translate="yes" xml:space="preserve">
          <source>Implies:</source>
          <target state="translated">Implies:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="1de625c46836a8d690ceb58d45293b81c48c397e" translate="yes" xml:space="preserve">
          <source>Import a module by &lt;code&gt;hs-boot&lt;/code&gt; file to break a module loop.</source>
          <target state="translated">&lt;code&gt;hs-boot&lt;/code&gt; ファイルでモジュールをインポートして、モジュールループを解除します。</target>
        </trans-unit>
        <trans-unit id="15a02ed60dd913a32866007cb8b0f286d068920a" translate="yes" xml:space="preserve">
          <source>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">インポート文とスコーピングルールはHaskellと全く同じです。プレリュード以外の型やクラスを指定するには、それをインポートしなければなりません。</target>
        </trans-unit>
        <trans-unit id="ccaf39f584206e7c3969db9d359129399c8be167" translate="yes" xml:space="preserve">
          <source>Import the patterns:</source>
          <target state="translated">パターンをインポートします。</target>
        </trans-unit>
        <trans-unit id="0ace903aa74341e5d1ccb710b3fdc2bed74b4565" translate="yes" xml:space="preserve">
          <source>Import/export functions</source>
          <target state="translated">輸出入機能</target>
        </trans-unit>
        <trans-unit id="e85d03f122b04b2822839cff39f7f7456f25be2f" translate="yes" xml:space="preserve">
          <source>ImportQualifiedPost</source>
          <target state="translated">ImportQualifiedPost</target>
        </trans-unit>
        <trans-unit id="5df41abfd75ae06055cd5c44bb9065e3454ceee7" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要な注意： &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; の動作は、ペーパー「Haskellでの非同期例外」（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）で説明されている動作とは異なります。この論文では、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は非ブロッキングです。ただし、ライブラリの実装では、ターゲットスレッドが例外を受け取るまで &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; が返らない、より同期的な設計を採用しています。トレードオフについては、論文のセクション9で説明します。したがって、他のブロッキング操作と同様に、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は割り込み可能です（論文のセクション5.3を参照）。ただし、他の割り込み可能な操作とは異なり、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、実際にブロックされていなくても、&lt;em&gt;常に&lt;/em&gt;割り込み可能です。</target>
        </trans-unit>
        <trans-unit id="179fcf640a3d899c14d346ac25778d5710538175" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要な注意： &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; の動作は、ペーパー「Haskellでの非同期例外」（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）で説明されている動作とは異なります。この論文では、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は非ブロッキングです。ただし、ライブラリの実装では、ターゲットスレッドが例外を受け取るまで &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; が返らない、より同期的な設計を採用しています。トレードオフについては、論文のセクション9で説明します。したがって、他のブロッキング操作と同様に、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は割り込み可能です（論文のセクション5.3を参照）。ただし、他の割り込み可能な操作とは異なり、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、実際にブロックされていなくても、&lt;em&gt;常に&lt;/em&gt;割り込み可能です。</target>
        </trans-unit>
        <trans-unit id="95c64cf2f235ca7554567f7534fe0b43d5677eea" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要な注意： &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; の動作は、ペーパー「Haskellでの非同期例外」（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）で説明されている動作とは異なります。この論文では、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は非ブロッキングです。ただし、ライブラリの実装では、ターゲットスレッドが例外を受け取るまで &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; が返らない、より同期的な設計を採用しています。トレードオフについては、論文のセクション9で説明します。したがって、他のブロッキング操作と同様に、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は割り込み可能です（論文のセクション5.3を参照）。ただし、他の割り込み可能な操作とは異なり、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、実際にブロックされていなくても、&lt;em&gt;常に&lt;/em&gt;割り込み可能です。</target>
        </trans-unit>
        <trans-unit id="4589bf4e9a6ce37b31d36f0a6e150b4292fb9be8" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要な注意： &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; の動作は、ペーパー「Haskellでの非同期例外」（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）で説明されている動作とは異なります。この論文では、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は非ブロッキングです。ただし、ライブラリの実装では、ターゲットスレッドが例外を受け取るまで &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; が返らない、より同期的な設計を採用しています。トレードオフについては、論文のセクション9で説明します。したがって、他のブロッキング操作と同様に、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は割り込み可能です（論文のセクション5.3を参照）。ただし、他の割り込み可能な操作とは異なり、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; は、実際にブロックされていなくても、&lt;em&gt;常に&lt;/em&gt;割り込み可能です。</target>
        </trans-unit>
        <trans-unit id="c537cf521e62d230fcbda7200d4c65bb85bb9950" translate="yes" xml:space="preserve">
          <source>Importantly, GHC will &lt;strong&gt;never&lt;/strong&gt; infer a &lt;code&gt;HasCallStack&lt;/code&gt; constraint, you must request it explicitly.</source>
          <target state="translated">重要なのは、GHCが &lt;code&gt;HasCallStack&lt;/code&gt; 制約を推測する&lt;strong&gt;こと&lt;/strong&gt;は&lt;strong&gt;ない&lt;/strong&gt;ため、明示的に要求する必要があることです。</target>
        </trans-unit>
        <trans-unit id="209a185dcdc64df7c89fd6b4a06c378dd59a523b" translate="yes" xml:space="preserve">
          <source>Imports can be &lt;em&gt;removed&lt;/em&gt; from the context, using the syntax &lt;code&gt;:module -M&lt;/code&gt;. The &lt;code&gt;import&lt;/code&gt; syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</source>
          <target state="translated">構文は &lt;code&gt;:module -M&lt;/code&gt; を使用して、コンテキストからインポートを&lt;em&gt;削除&lt;/em&gt;できます。 &lt;code&gt;import&lt;/code&gt; 構文は（Haskellのモジュールのように）累積され、これは範囲から減算するための唯一の方法です。</target>
        </trans-unit>
        <trans-unit id="04d8d8c71e07fcca11b70e8d6722717ba5c7bbd1" translate="yes" xml:space="preserve">
          <source>ImpredicativeTypes</source>
          <target state="translated">ImpredicativeTypes</target>
        </trans-unit>
        <trans-unit id="ada1b47a54b4c0472b230f71a39fa22ace4b62eb" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this algorithm's complexity degrades towards O(n*m).</source>
          <target state="translated">(ありそうもない)悪いケースでは、このアルゴリズムの複雑さはO(n*m)に向かって劣化します。</target>
        </trans-unit>
        <trans-unit id="c9b4f236af14825a1f87646152c7ae5ae54d6f1b" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this function's time complexity degrades towards O(n*m).</source>
          <target state="translated">(ありそうもない)悪いケースでは、この関数の時間的複雑さはO(n*m)に向かって低下します。</target>
        </trans-unit>
        <trans-unit id="10cba8ae40b482d6815c0aed2cb5cad28971bc60" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode and &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; mode (see &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn&amp;rsquo;t available, and explicit &lt;code&gt;-package&lt;/code&gt; options must be given when linking. The one other time you might need to use &lt;code&gt;-package&lt;/code&gt; to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</source>
          <target state="translated">で&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モードと&lt;a href=&quot;using#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt;モード（参照&lt;a href=&quot;using#modes&quot;&gt;操作のモードを&lt;/a&gt;）、コンパイラは通常、パッケージが現在のHaskellのモジュール、およびリンクのみによって必要とされるかを決定します。ただし、バッチモードでは、依存関係情報は利用できず、リンク時に明示的な &lt;code&gt;-package&lt;/code&gt; オプションを指定する必要があります。 &lt;code&gt;-package&lt;/code&gt; を使用してパッケージを強制的にリンクする必要があるもう1つの場合は、パッケージにHaskellモジュールが含まれていない場合（たとえば、Cライブラリのみが含まれている場合）です。その場合、GHCはその依存関係を決して発見しないため、明示的に言及する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e9c1cc6f5410615b774e4fbc397355fcbc8c4fd" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt;, the LHS is not an application; in &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt;, the LHS has a pattern variable in the head. In &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt;, the LHS consists of a &lt;em&gt;constructor&lt;/em&gt;, rather than a &lt;em&gt;variable&lt;/em&gt;, applied to an argument.</source>
          <target state="translated">では &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt; 、LHSはアプリケーションではありません。で &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt; 、LHSは、頭の中でパターン変数があります。 &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt; 、LHSは、から成る&lt;em&gt;コンストラクタ&lt;/em&gt;はなく、&lt;em&gt;変数&lt;/em&gt;、引数に適用されます。</target>
        </trans-unit>
        <trans-unit id="2cba9c2c873dc3a1842eba8795586b3cad1e7927" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt;, the kind variable &lt;code&gt;a&lt;/code&gt; is implicitly bound by the kind signature of the LHS type pattern &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;('[] :: [Maybe a])&lt;/code&gt; 、種類変数 &lt;code&gt;a&lt;/code&gt; が暗黙LHS型パターンの種類署名によって結合されている &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd722d9619f7131d53a6e0696cd49a366c57cba6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;...rhs...&lt;/code&gt; there is, in effect a local instance for &lt;code&gt;Eq (f a)&lt;/code&gt; for any &lt;code&gt;a&lt;/code&gt;. But at a call site for &lt;code&gt;f&lt;/code&gt; the compiler itself produces evidence to pass to &lt;code&gt;f&lt;/code&gt;. For example, if we called &lt;code&gt;f Nothing&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Maybe&lt;/code&gt; and the compiler must prove (at the call site) that &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; holds. It can do this easily, by appealing to the existing instance declaration for &lt;code&gt;Eq (Maybe a)&lt;/code&gt;.</source>
          <target state="translated">内 &lt;code&gt;...rhs...&lt;/code&gt; 実際には、のローカルインスタンスが存在する &lt;code&gt;Eq (f a)&lt;/code&gt; いずれについても &lt;code&gt;a&lt;/code&gt; 。しかし、 &lt;code&gt;f&lt;/code&gt; の呼び出しサイトでは、コンパイラー自体が &lt;code&gt;f&lt;/code&gt; に渡す証拠を生成します。たとえば、 &lt;code&gt;f Nothing&lt;/code&gt; を呼び出した場合、 &lt;code&gt;f&lt;/code&gt; は「 &lt;code&gt;Maybe&lt;/code&gt; あり、コンパイラは（呼び出しサイトで）その &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; 証明する必要があります。Eq a =&amp;gt; Eq（たぶんa）が成り立つ。 &lt;code&gt;Eq (Maybe a)&lt;/code&gt; 既存のインスタンス宣言にアピールすることで、これを簡単に行うことができます。</target>
        </trans-unit>
        <trans-unit id="68a829120c1a8cf6dc40005b5743e07320e4e76d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances of the form</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; フォームのインスタンス</target>
        </trans-unit>
        <trans-unit id="948361792703e617253f8a40efc29e2464a33346" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt;, the parameter &lt;code&gt;p&lt;/code&gt; is used for the first time, whereas &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simply wraps an application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 、パラメータ &lt;code&gt;p&lt;/code&gt; が、一方、最初に使用される &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 単にのアプリケーションラップ &lt;code&gt;f&lt;/code&gt; に &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a4440f56e4e4c2cfc9de276b7ac8c2dd211dcc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; 、親クラスまたはタイプの名前</target>
        </trans-unit>
        <trans-unit id="845d36fb6d42c5c12db137868f32d7eab65dd2b2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 、型コンストラクタのアリティ</target>
        </trans-unit>
        <trans-unit id="b6d9284ef85a16cb7684b74958aee144b991c17a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 、型コンストラクタunliftedのですか？</target>
        </trans-unit>
        <trans-unit id="c8e7141714d539cd7c869ec1a2a44cb47eefb8e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 、数は、特定のデータコンストラクタに関連付けられました。 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; はインデックスが1つあり、対応する &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; の値を超えてはなりません。例えば：</target>
        </trans-unit>
        <trans-unit id="8baeebee8820ef8d8750b87cc615ff6f0298f331" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; の総数 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; S。たとえば、 &lt;code&gt;(#|#)&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; は2です。</target>
        </trans-unit>
        <trans-unit id="d196e0b1f2acfe7fd37b1d4013ccf57a2a366c38" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; 、親クラスまたはタイプの名前</target>
        </trans-unit>
        <trans-unit id="b499ce2ba87784f2de26193d6919b4f01a32b507" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 、型コンストラクタのアリティ</target>
        </trans-unit>
        <trans-unit id="1d657fa5f332487c2a8bc2384b505cdd8da898c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 、型コンストラクタunliftedのですか？</target>
        </trans-unit>
        <trans-unit id="267623324428073bc541eebd4aad8f68ba67c469" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 、数は、特定のデータコンストラクタに関連付けられました。 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; はインデックスが1つあり、対応する &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; の値を超えてはなりません。例えば：</target>
        </trans-unit>
        <trans-unit id="8ef1f15923838f9b858d723d5c8a4bfd38ff8b06" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; の総数 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; S。たとえば、 &lt;code&gt;(#|#)&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; は2です。</target>
        </trans-unit>
        <trans-unit id="9e5468a181d7acdf72891e57c5df9af13b9a16ef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaCons n f s&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the constructor's name, &lt;code&gt;f&lt;/code&gt; is its fixity, and &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the constructor contains record selectors.</source>
          <target state="translated">で &lt;code&gt;MetaCons n f s&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; はコンストラクタの名前であり、 &lt;code&gt;f&lt;/code&gt; はその固定性であり、 &lt;code&gt;s&lt;/code&gt; がある &lt;code&gt;'True&lt;/code&gt; コンストラクタは、レコードセレクタが含まれている場合。</target>
        </trans-unit>
        <trans-unit id="bdcb03ae6fc4038ed5d8f740a99f5a3faec1e49a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaData n m p nt&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the datatype's name, &lt;code&gt;m&lt;/code&gt; is the module in which the datatype is defined, &lt;code&gt;p&lt;/code&gt; is the package in which the datatype is defined, and &lt;code&gt;nt&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the datatype is a &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MetaData n m p nt&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; は、データ型の名前であり、 &lt;code&gt;m&lt;/code&gt; は、データ型が定義されているモジュールであり、 &lt;code&gt;p&lt;/code&gt; はデータ型が定義されているパッケージであり、 &lt;code&gt;nt&lt;/code&gt; である &lt;code&gt;'True&lt;/code&gt; のデータ型である場合 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e83eee84186dc4d831c882f80bd99d4e5968d965" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt;, if the field uses record syntax, then &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the record name. Otherwise, &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;su&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; are the field's unpackedness and strictness annotations, and &lt;code&gt;ds&lt;/code&gt; is the strictness that GHC infers for the field.</source>
          <target state="translated">で &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt; フィールドがレコード構文を使用している場合は、その後、 &lt;code&gt;mn&lt;/code&gt; である &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; レコード名。それ以外の場合、 &lt;code&gt;mn&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; です。 &lt;code&gt;su&lt;/code&gt; と &lt;code&gt;ss&lt;/code&gt; はフィールドの解凍と厳密さの注釈であり、 &lt;code&gt;ds&lt;/code&gt; はGHCがフィールドに対して推測する厳密さです。</target>
        </trans-unit>
        <trans-unit id="d34a93041bfae2648000d66b86976acbec2d0642" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MkBar&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます、 &lt;code&gt;b&lt;/code&gt; 、及び &lt;code&gt;c&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ced4e254bc1eb559ceb481fab3bee8103d304a01" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MkBar&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます、 &lt;code&gt;b&lt;/code&gt; 、及び &lt;code&gt;c&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87dae09b658c1498dee148900bef2b9dd60aee21" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">で &lt;code&gt;MkFoo&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます &lt;code&gt;b&lt;/code&gt; は、なく。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe62b913f985335a3ba832edccdcf6977c0bf16" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">で &lt;code&gt;MkFoo&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; は定量化されます &lt;code&gt;b&lt;/code&gt; は、なく。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cc75f8d8c4b35c1f3e3a3913bb479147b81cb55" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monad&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">では &lt;code&gt;Monad&lt;/code&gt; 以下のいずれかの条件が成立しない場合はインスタンスの宣言は警告します：</target>
        </trans-unit>
        <trans-unit id="ce6899c2e8dfb1d03397333b9eb9a07339697044" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monoid&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">で &lt;code&gt;Monoid&lt;/code&gt; 以下のいずれかの条件が成立しない場合はインスタンス宣言は警告します：</target>
        </trans-unit>
        <trans-unit id="e39ca16be80f52a77708c1a747b96b2360e52634" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; is not quantified by the outermost &lt;code&gt;forall&lt;/code&gt;, so it is not in scope over the bodies of the functions. Neither is &lt;code&gt;b&lt;/code&gt; in scope over the body of &lt;code&gt;f3&lt;/code&gt;, as the &lt;code&gt;forall&lt;/code&gt; is tucked underneath the &lt;code&gt;Foo&lt;/code&gt; type synonym.</source>
          <target state="translated">&lt;code&gt;f1&lt;/code&gt; および &lt;code&gt;f2&lt;/code&gt; 、型変数 &lt;code&gt;b&lt;/code&gt; が最も外側によって定量化されていない &lt;code&gt;forall&lt;/code&gt; それは関数の本体上範囲内にないので、。 &lt;code&gt;forall&lt;/code&gt; は &lt;code&gt;Foo&lt;/code&gt; 型のシノニムの下に隠れているため、 &lt;code&gt;f3&lt;/code&gt; の本体全体のスコープにも &lt;code&gt;b&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="a77988f2a2ed6a0e43f6b8c5f856f98a253efb90" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">では &lt;code&gt;g&lt;/code&gt; の定義、我々はにインスタンス化します &lt;code&gt;(C alpha)&lt;/code&gt; と推定するしてみてください &lt;code&gt;(C alpha)&lt;/code&gt; から &lt;code&gt;(C a)&lt;/code&gt; 、そして失敗します。</target>
        </trans-unit>
        <trans-unit id="3a689d248410c565d4fb51360a8de99b622f55fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">では &lt;code&gt;g&lt;/code&gt; の定義、我々はにインスタンス化します &lt;code&gt;(C alpha)&lt;/code&gt; と推定するしてみてください &lt;code&gt;(C alpha)&lt;/code&gt; から &lt;code&gt;(C a)&lt;/code&gt; 、そして失敗します。</target>
        </trans-unit>
        <trans-unit id="2bc4c70c143662f5383482b6d67de0f92f7a365d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;kindOf&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; variable is used both in a kind position and a type position. Currently, &lt;code&gt;kindOf&lt;/code&gt; happens to be accepted as well.</source>
          <target state="translated">&lt;code&gt;kindOf&lt;/code&gt; 、 &lt;code&gt;k&lt;/code&gt; 個の変数は、両方の種類の位置及び型位置で使用されています。現在、 &lt;code&gt;kindOf&lt;/code&gt; も受け入れられています。</target>
        </trans-unit>
        <trans-unit id="0b35e40411bc58348de1c2765fb1a4292327ba91" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; look at the rules for &lt;code&gt;map&lt;/code&gt; to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn&amp;rsquo;t happen. More rules in &lt;code&gt;GHC/List.hs&lt;/code&gt;.</source>
          <target state="translated">では &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; ためのルールを見 &lt;code&gt;map&lt;/code&gt; 融合を行うと、まだ融合が起こらない場合であっても、効率的なプログラムを与えるルールを作成する方法を確認してください。 &lt;code&gt;GHC/List.hs&lt;/code&gt; のその他のルール。</target>
        </trans-unit>
        <trans-unit id="06a114c54d904ac4a8b931a8b996071d7f5db6f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;batch mode&lt;/em&gt;, GHC will compile one or more source files given on the command line.</source>
          <target state="translated">で&lt;em&gt;バッチモード&lt;/em&gt;、GHCは、コマンドラインで与えられた1つまたは複数のソースファイルをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="58d94fdb74e22b1e4ed6c0f3d1765a358e401fba" translate="yes" xml:space="preserve">
          <source>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to &lt;code&gt;-rtsopts=some&lt;/code&gt;.</source>
          <target state="translated">GHC 6.12.3以前では、デフォルトはすべてのRTSオプションを処理することでした。ただし、RTSオプションを使用すると、実行中のプログラムのセキュリティコンテキストでログデータを任意のファイルに書き込むことができるため、セキュリティ上の問題が発生する可能性があります。このため、GHC 7.0.1以降のデフォルトは &lt;code&gt;-rtsopts=some&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d1bf7ad7520a92b283b23d11132eda5dbd26c8a6" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful. It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.</source>
          <target state="translated">GHC 8.4と高く、中 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; のインスタンス &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 持ち上げるように修正された &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 代わりにインスタンスを &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; インスタンス。その結果、このタイプはもはや役に立ちません。GHC 8.8では非推奨とマークされ、GHC 8.10では削除されます。</target>
        </trans-unit>
        <trans-unit id="acf62f569044864c4ed60a6a7bb15cef4826949f" translate="yes" xml:space="preserve">
          <source>In GHC the &lt;code&gt;Int&lt;/code&gt; type follows the size of an address on the host architecture; in other words it holds 32 bits on a 32-bit machine, and 64-bits on a 64-bit machine.</source>
          <target state="translated">GHCでは、 &lt;code&gt;Int&lt;/code&gt; 型はホストアーキテクチャ上のアドレスのサイズに従います。つまり、32ビットマシンでは32ビット、64ビットマシンでは64ビットを保持します。</target>
        </trans-unit>
        <trans-unit id="9843e6ca6c6b645c8f794b9b1a427c411f140a1a" translate="yes" xml:space="preserve">
          <source>In GHC version 6.12 building shared libraries is supported for Linux (on x86 and x86-64 architectures). GHC version 7.0 adds support on Windows (see &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Building and using Win32 DLLs&lt;/a&gt;), FreeBSD and OpenBSD (x86 and x86-64), Solaris (x86) and Mac OS X (x86 and PowerPC).</source>
          <target state="translated">GHCバージョン6.12では、Linux（x86およびx86-64アーキテクチャ上）で共有ライブラリの構築がサポートされています。GHCバージョン7.0は、Windows（&lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Win32 DLLの構築と使用を&lt;/a&gt;参照）、FreeBSDおよびOpenBSD（x86およびx86-64）、Solaris（x86）およびMac OS X（x86およびPowerPC）でのサポートを追加します。</target>
        </trans-unit>
        <trans-unit id="1daba1b4560bdfc70e09fd592e0d65dc1e9c37b9" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;alloca&lt;/code&gt; is implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;, so allocation and deallocation are fast: much faster than C&amp;rsquo;s &lt;code&gt;malloc/free&lt;/code&gt;, but not quite as fast as stack allocation in C. Use &lt;code&gt;alloca&lt;/code&gt; whenever you can.</source>
          <target state="translated">GHCでは、 &lt;code&gt;alloca&lt;/code&gt; は &lt;code&gt;MutableByteArray#&lt;/code&gt; を使用して実装されているため、割り当てと割り当て解除は高速です。Cの &lt;code&gt;malloc/free&lt;/code&gt; よりはるかに高速ですが、Cでのスタック割り当てほど高速ではありません。できる限り &lt;code&gt;alloca&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="eaea8bf5bbec3eca1845287a1a36bf3f40ff1211" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; is also implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;. Although the memory is pointed to by a &lt;code&gt;ForeignPtr&lt;/code&gt;, there are no actual finalizers involved (unless you add one with &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;), and the deallocation is done using GC, so &lt;code&gt;mallocForeignPtr&lt;/code&gt; is normally very cheap.</source>
          <target state="translated">GHCでは、 &lt;code&gt;mallocForeignPtr&lt;/code&gt; も &lt;code&gt;MutableByteArray#&lt;/code&gt; を使用して実装されます。メモリがによって指されているが &lt;code&gt;ForeignPtr&lt;/code&gt; （あなたと1追加しない限り、関連する実際のファイナライザがない &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; を）、となるよう割り当て解除は、GCを使用して行われ &lt;code&gt;mallocForeignPtr&lt;/code&gt; は非常に安い通常です。</target>
        </trans-unit>
        <trans-unit id="39daf99f45a84ba8de844fc76ad7b4153033baaa" translate="yes" xml:space="preserve">
          <source>In GHC, a fixity declaration may accompany a local binding:</source>
          <target state="translated">GHCでは、固定性宣言が局所結合を伴うことがある。</target>
        </trans-unit>
        <trans-unit id="0d4c63d000de5dba60a416622dd3245150848f85" translate="yes" xml:space="preserve">
          <source>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</source>
          <target state="translated">GHC では、stdout ハンドルはデフォルトでラインバッファリングされています。しかし、GHCi では stdout のバッファリングをオフにしています。</target>
        </trans-unit>
        <trans-unit id="8852f0e928d58c915cd8b9e1a00743a1e68d9fa3" translate="yes" xml:space="preserve">
          <source>In GHC, this is 1 (a tab is just a character)</source>
          <target state="translated">GHCでは、これは1(タブはただの文字である</target>
        </trans-unit>
        <trans-unit id="d19c28d54f7c0de858c1b5974a88ffcb3bf56049" translate="yes" xml:space="preserve">
          <source>In GHC, threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</source>
          <target state="translated">GHCでは、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; によって作成されたスレッドは軽量スレッドであり、GHCランタイムによって完全に管理されます。通常、Haskellスレッドは、オペレーティングシステムスレッドよりも（時間と領域の両方の点で）1桁または2倍効率的です。</target>
        </trans-unit>
        <trans-unit id="1805c71d435523bc362fb0a41eec670b0de8eef4" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="translated">Haskell 2010では、特定の種類の式を括弧なしで演算子の引数として使用できますが、関数の引数としては使用できません。それらには、 &lt;code&gt;do&lt;/code&gt; 、lambda、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;case&lt;/code&gt; 、および &lt;code&gt;let&lt;/code&gt; 式が含まれます。一部のGHC拡張は、このタイプの言語構成体、 &lt;code&gt;mdo&lt;/code&gt; （&lt;a href=&quot;#recursive-do-notation&quot;&gt;再帰的なdo表記&lt;/a&gt;）、 &lt;code&gt;\case&lt;/code&gt; （&lt;a href=&quot;#lambda-case&quot;&gt;ラムダケース&lt;/a&gt;）、および &lt;code&gt;proc&lt;/code&gt; （&lt;a href=&quot;#arrow-notation&quot;&gt;矢印表記&lt;/a&gt;）も定義します。</target>
        </trans-unit>
        <trans-unit id="958b65070f6cab89550e593513742b0ca3a25efb" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, this is an opaque type.</source>
          <target state="translated">Haskell 2010では不透明型です。</target>
        </trans-unit>
        <trans-unit id="141c5fc516d90c0307fae2cd69b966988b2f5738" translate="yes" xml:space="preserve">
          <source>In Haskell 98 mode and by default (but not in Haskell 2010 mode), GHC is a little less strict about the layout rule when used in &lt;code&gt;do&lt;/code&gt; expressions. Specifically, the restriction that &amp;ldquo;a nested context must be indented further to the right than the enclosing context&amp;rdquo; is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a &lt;code&gt;do&lt;/code&gt; expression.</source>
          <target state="translated">Haskell 98モードとデフォルト（Haskell 2010モードではない）では、GHCは、 &lt;code&gt;do&lt;/code&gt; 式で使用されるときのレイアウト規則について少し厳密ではありません。特に、「ネストされたコンテキストは、囲んでいるコンテキストよりも右にインデントする必要がある」という制限が緩和され、囲んでいるコンテキストが &lt;code&gt;do&lt;/code&gt; 式の場合、ネストされたコンテキストを囲んでいるコンテキストと同じレベルにすることができます。</target>
        </trans-unit>
        <trans-unit id="599e88170bd7d883f77ba5d44a7ddebdba1a790b" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="translated">Haskell 98では、クラス宣言（スーパークラスを導入）のコンテキストは単純でなければなりません。つまり、各述語は、型変数に適用されるクラスで構成されている必要があります。拡張機能&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#flexible-contexts&quot;&gt;型シグネチャのコンテキスト&lt;/a&gt;）はこの制限を解除するため、クラス宣言のコンテキストに対する唯一の制限は、クラス階層が非循環でなければならないことです。したがって、これらのクラス宣言は問題ありません：</target>
        </trans-unit>
        <trans-unit id="b4c8da415db612e5f1ea4bd84f8b71735ea83ad2" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the head of an instance declaration must be of the form &lt;code&gt;C (T a1 ... an)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is the class, &lt;code&gt;T&lt;/code&gt; is a data type constructor, and the &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that&amp;rsquo;s the rules at the moment).</source>
          <target state="translated">Haskell 98では、インスタンス宣言のヘッドは &lt;code&gt;C (T a1 ... an)&lt;/code&gt; の形式でなければなりません。ここで、 &lt;code&gt;C&lt;/code&gt; はクラス、 &lt;code&gt;T&lt;/code&gt; はデータ型コンストラクター、 &lt;code&gt;a1 ... an&lt;/code&gt; は特殊型変数です。マルチパラメータータイプのクラスの場合、このルールはインスタンスヘッドの各パラメーターに適用されます（おそらく、1つだけがこのフォームを持ち、他はタイプ変数であっても大丈夫ですが、現時点ではそれがルールです）。</target>
        </trans-unit>
        <trans-unit id="ea4ec2e25de3b576b30de329ce5f6bd4501065f2" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the class constraints in the context of the instance declaration must be of the form &lt;code&gt;C a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable that occurs in the head.</source>
          <target state="translated">Haskell 98では、インスタンス宣言のコンテキストでのクラス制約は &lt;code&gt;C a&lt;/code&gt; の形式でなければなりません。ここで &lt;code&gt;a&lt;/code&gt; はヘッドで発生する型変数です。</target>
        </trans-unit>
        <trans-unit id="fc46eaaf6d9e1c84e4c85176656529491f0cd53f" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="translated">Haskell 98では、 &lt;code&gt;App&lt;/code&gt; の推定される種類は &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; です。しかし、これは過度に具体的です。これは、 &lt;code&gt;App&lt;/code&gt; 適した別のHaskell 98の種類が &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt; であり、 &lt;code&gt;a&lt;/code&gt; に割り当てられている種類が &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; です。実際、kindシグネチャ（&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;）がない場合、Haskellコンパイラが第2の種類を推測するためには、ダミーのコンストラクタを使用する必要があります。種類ポリモーフィズム（&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;）では、GHCは種類 &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt; Type&lt;/code&gt; 推測します。 （K - &amp;gt;タイプ） - &amp;gt; K - &amp;gt;タイプのための &lt;code&gt;App&lt;/code&gt; の最も一般的な種類です。</target>
        </trans-unit>
        <trans-unit id="aac9bc239948204f2a8d4ed156b20d8d29b1b9f6" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="translated">Haskell 98では、派生可能なクラスは &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Enum&lt;/code&gt; 、 &lt;code&gt;Ix&lt;/code&gt; 、 &lt;code&gt;Bounded&lt;/code&gt; 、 &lt;code&gt;Read&lt;/code&gt; 、および &lt;code&gt;Show&lt;/code&gt; のみです。&lt;a href=&quot;#deriving-extra&quot;&gt;さまざまな言語拡張機能&lt;/a&gt;がこのリストを拡張しています。</target>
        </trans-unit>
        <trans-unit id="2150415688076448290962ad6fd2b0c86ad5929a" translate="yes" xml:space="preserve">
          <source>In Haskell 98, we can define a parsing monad by</source>
          <target state="translated">Haskell 98では、解析モナドを次のように定義することができます。</target>
        </trans-unit>
        <trans-unit id="4c90bfb63f72d089b5eed20faef5057d4b7a83ec" translate="yes" xml:space="preserve">
          <source>In Haskell, a &lt;code&gt;let&lt;/code&gt; expression is followed by &lt;code&gt;in&lt;/code&gt;. However, in GHCi, since the expression can also be interpreted in the &lt;code&gt;IO&lt;/code&gt; monad, a &lt;code&gt;let&lt;/code&gt; binding with no accompanying &lt;code&gt;in&lt;/code&gt; statement can be signalled by an empty line, as in the above example.</source>
          <target state="translated">Haskellでは、 &lt;code&gt;let&lt;/code&gt; 式の後に &lt;code&gt;in&lt;/code&gt; が続きます。ただし、GHCiでは、式は &lt;code&gt;IO&lt;/code&gt; モナドでも解釈できるため、上記の例のように、 &lt;code&gt;in&lt;/code&gt; ステートメントを伴わない &lt;code&gt;let&lt;/code&gt; バインディングは空の行で通知できます。</target>
        </trans-unit>
        <trans-unit id="9068501a015364519d15db889c0608523757cd88" translate="yes" xml:space="preserve">
          <source>In Haskell, a newline is always represented by the character &lt;code&gt;'\n'&lt;/code&gt;. However, in files and external character streams, a newline may be represented by another character sequence, such as &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">Haskellでは、改行は常に文字 &lt;code&gt;'\n'&lt;/code&gt; 表されます。ただし、ファイルおよび外部文字ストリームでは、改行は &lt;code&gt;'\r\n'&lt;/code&gt; などの別の文字シーケンスで表される場合があります。</target>
        </trans-unit>
        <trans-unit id="cf7c74c15737415db5c329d8398aaad16be0f6da" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="translated">Haskellでは、プログラマー作成の型シグニチャーは、その自由型変数に対して暗黙的に数量化されます（Haskellレポートの&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;セクション4.1.2&lt;/a&gt;）。字句的にスコープされた型変数は、この暗黙の数量化規則に次のように影響します。スコープ内の型変数は、すべてが数量化される&lt;em&gt;わけで&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。たとえば、型変数 &lt;code&gt;a&lt;/code&gt; がスコープ内にある場合、</target>
        </trans-unit>
        <trans-unit id="8a045d12bdfe38097b59295fbb7e2d5b85ec1646" translate="yes" xml:space="preserve">
          <source>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the &lt;code&gt;fenv.h&lt;/code&gt; functions let you change the results of, or observe the effects of floating point operations, use of &lt;code&gt;fenv.h&lt;/code&gt; renders the behaviour of floating-point operations anywhere in the program undefined.</source>
          <target state="translated">Haskellでは、浮動小数点演算は純粋な型を持ち、評価順序は指定されていません。厳密に言うと、 &lt;code&gt;fenv.h&lt;/code&gt; 関数を使用すると、浮動小数点演算の結果を変更したり、その影響を観察したりできるため、 &lt;code&gt;fenv.h&lt;/code&gt; を使用すると、プログラム内の任意の場所の浮動小数点演算の動作が未定義になります。</target>
        </trans-unit>
        <trans-unit id="0d8a1e12648617b7ab29a94bd933ecabcb8fcfe6" translate="yes" xml:space="preserve">
          <source>In Haskell, you can&amp;rsquo;t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension &lt;a href=&quot;#extension-InstanceSigs&quot;&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; allows you to do so. For example:</source>
          <target state="translated">Haskellでは、インスタンス宣言で型シグネチャを記述することはできませんが、その方が便利な場合があります。また、言語拡張&lt;a href=&quot;#extension-InstanceSigs&quot;&gt; &lt;code&gt;InstanceSigs&lt;/code&gt; を&lt;/a&gt;使用すると、型シグネチャを記述できます。例えば：</target>
        </trans-unit>
        <trans-unit id="8427a76c9ee7a864a646e420064761a09284fce9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="translated">で&lt;em&gt;密閉型ファミリ&lt;/em&gt;のすべての方程式を注文し、一箇所でいます。方程式もペアでチェックされますが、今回は方程式を先行するすべての方程式とペアにする必要があります。もちろん、単一方程式のクローズドタイプファミリーは、単純に単射です（上記の（1）、（2）、または（3）が成り立つ場合を除く）。</target>
        </trans-unit>
        <trans-unit id="450e95ea754d91229aeb1e695390ebec4e7895e5" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="translated">で&lt;em&gt;ソース&lt;/em&gt;プログラム、これは何のコンストラクタ（GHC拡張子：見ていないようにTAを宣言し&lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;ていないコンストラクタを持つデータ型を&lt;/a&gt;）が、HI-ブートファイルには、「私が知っているか、コンストラクタが何であるかを気にしない」という意味します。これは簡単に理解できるため、データ型宣言の最も一般的な形式です。あなたは、&lt;em&gt;することができます&lt;/em&gt;また、あなたがそうするならば、あなたはその実際の定義のように正確にそれを書かなければならない、コンストラクタを書き出すけど。</target>
        </trans-unit>
        <trans-unit id="64d45f71dec31ef9b1d51fa3c3cf25f39fcadcc0" translate="yes" xml:space="preserve">
          <source>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive &lt;code&gt;Show&lt;/code&gt; for the type. (Data constructors declared infix are displayed infix by the derived &lt;code&gt;show&lt;/code&gt;.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by &lt;code&gt;Show&lt;/code&gt; iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</source>
          <target state="translated">GADTスタイルのデータ型宣言では、データコンストラクターが中置型であることを指定する明確な方法はありません。これは、型の &lt;code&gt;Show&lt;/code&gt; を派生する場合に違いがあります。（インフィックスで宣言されたデータコンストラクターは、派生した &lt;code&gt;show&lt;/code&gt; によってインフィックスで表示されます。）したがって、GHCは次の設計を実装します。GADTスタイルのデータ型宣言で宣言されたデータコンストラクターは、 &lt;code&gt;Show&lt;/code&gt; iffでインフィックスとして表示されます）2つの引数があります。（c）プログラマー提供の固定宣言があります。例えば</target>
        </trans-unit>
        <trans-unit id="07a23e9f4a3adccc2a7677063668d39db095dd14" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="translated">クラス宣言では、すべてのクラス型変数&lt;a href=&quot;#flexible-contexts&quot;&gt;は、（型シグネチャのコンテキストで説明&lt;/a&gt;されている意味で）各メソッド型の自由変数から到達可能でなければなりません。例えば：</target>
        </trans-unit>
        <trans-unit id="8c6ea776cade0a00536fe0dd1e2c07174843e962" translate="yes" xml:space="preserve">
          <source>In a concurrent program, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example:</source>
          <target state="translated">並行プログラムでは、基盤となるプロセッサアーキテクチャのメモリモデルによっては、 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 操作が別のスレッドに対して順不同に見える場合があります。たとえば、x86では、ロードがストアの前に移動する可能性があるため、次の例では、</target>
        </trans-unit>
        <trans-unit id="8414a11b42213e9da0ee87ae53530ee3ce8a4f45" translate="yes" xml:space="preserve">
          <source>In a few cases, even equality constraints cannot be deferred. Specifically:</source>
          <target state="translated">いくつかのケースでは、等質性制約であっても、延期することができません。具体的には</target>
        </trans-unit>
        <trans-unit id="b3f8a7d6c3b7eb5e07bab83a298a4d4322657fec" translate="yes" xml:space="preserve">
          <source>In a form that checks the invariant lazily.</source>
          <target state="translated">不変体を怠惰にチェックする形で。</target>
        </trans-unit>
        <trans-unit id="0e001e5b19bb7f459d52b88fa8993534911ab892" translate="yes" xml:space="preserve">
          <source>In a future release of GHC, both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;kindOf&lt;/code&gt; will be rejected per the &amp;ldquo;forall-or-nothing&amp;rdquo; rule. This warning, being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, allows to detect this before the actual breaking change takes place.</source>
          <target state="translated">GHCの将来のリリースでは、 &lt;code&gt;n&lt;/code&gt; と &lt;code&gt;kindOf&lt;/code&gt; の両方が「forall-or-nothing」ルールに従って拒否されます。この警告は&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;オプショングループの一部であるため、実際に重大な変更が行われる前にこれを検出できます。</target>
        </trans-unit>
        <trans-unit id="a786f90842cfbc1183ff12a32670a5ffa98f0bc7" translate="yes" xml:space="preserve">
          <source>In a multithreaded program, the current working directory is a global state shared among all threads of the process. Therefore, when performing filesystem operations from multiple threads, it is highly recommended to use absolute rather than relative paths (see: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">マルチスレッドプログラムでは、現在の作業ディレクトリは、プロセスのすべてのスレッド間で共有されるグローバルな状態です。したがって、複数のスレッドからファイルシステム操作を実行する場合は、相対パスではなく絶対パスを使用することを強くお勧めします（ &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="61315f4b8bb71a0b1c939d36bc50aba8647c5d4e" translate="yes" xml:space="preserve">
          <source>In a pattern context</source>
          <target state="translated">パターンコンテキストでは</target>
        </trans-unit>
        <trans-unit id="9010ad7519addcc90a448173aedba3758c2fa46a" translate="yes" xml:space="preserve">
          <source>In a pattern context with field puns</source>
          <target state="translated">フィールドダジャレを使ったパターン文脈で</target>
        </trans-unit>
        <trans-unit id="71bde6dc1de743e6a58a0db5f14b26f355407ecb" translate="yes" xml:space="preserve">
          <source>In a pattern context with record syntax</source>
          <target state="translated">レコード構文を持つパターンコンテキストでは</target>
        </trans-unit>
        <trans-unit id="f7c8cccfc50e043aecf8ac5ce9ee8531c541f745" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="translated">パターンタイプシグネチャ内（&lt;a href=&quot;#scoped-type-variables&quot;&gt;レキシカルスコープのタイプ変数を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="6844f7a79c5dfe3ec9aa5a919c116ac89f9053b7" translate="yes" xml:space="preserve">
          <source>In a record update</source>
          <target state="translated">記録更新では</target>
        </trans-unit>
        <trans-unit id="fa8401c566cf94c06de714273e8a2c803bf6fdb3" translate="yes" xml:space="preserve">
          <source>In a record update such as &lt;code&gt;e { x = 1 }&lt;/code&gt;, if there are multiple &lt;code&gt;x&lt;/code&gt; fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</source>
          <target state="translated">&lt;code&gt;e { x = 1 }&lt;/code&gt; などのレコードの更新で、スコープに複数の &lt;code&gt;x&lt;/code&gt; フィールドがある場合、コンテキストのタイプは、どのレコードデータタイプが意図されているかを修正するか、タイプアノテーションを提供する必要があります。次の定義を検討してください。</target>
        </trans-unit>
        <trans-unit id="0bd9f17a624418d16516d174a2fcb42b7bab910d" translate="yes" xml:space="preserve">
          <source>In a similar way, the earlier definition of &lt;code&gt;g&lt;/code&gt; will now be flagged as a type error.</source>
          <target state="translated">同様に、以前の &lt;code&gt;g&lt;/code&gt; の定義にはタイプエラーのフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="3ce7f512726e8d285ac156a0f35f6359e45bcb80" translate="yes" xml:space="preserve">
          <source>In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</source>
          <target state="translated">1つのパターンでは、ビューパターン式の左にあるパターンによってバインドされた変数がスコープ内にあります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="85b6b61563103c5b7dfd5b620fb5437b770cc196" translate="yes" xml:space="preserve">
          <source>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is &quot;daemonic threads&quot;).</source>
          <target state="translated">スタンドアロンの GHC プログラムでは、プロセスが終了するためにはメインスレッドだけが終了する必要があります。したがって、他のすべてのフォークされたスレッドは、単にメインスレッドと同時に終了します(この種の動作のための用語は、&quot;デーモニックスレッド &quot;です)。</target>
        </trans-unit>
        <trans-unit id="0aa908ae420e77e1f4bb85ee334ad239c1ccb262" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">厳密なモナドでは、各アクションがいつ実行されるかがわかりますが、モナドは戻り値や、モナドの他のコンポーネント（状態など）で必ずしも厳密ではありません。ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; を使用して、評価するコンポーネントで厳密なアクションを作成できます。</target>
        </trans-unit>
        <trans-unit id="7880166b35b3a24c62f866c80bb1e9fca6aab314" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">厳密なモナドでは、各アクションがいつ実行されるかがわかりますが、モナドは、戻り値や、状態などのモナドの他のコンポーネントでは必ずしも厳密ではありません。ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; を使用して、評価するコンポーネントで厳密なアクションを作成できます。</target>
        </trans-unit>
        <trans-unit id="43015c398315c351d899f4cc070e29bfc23b64c4" translate="yes" xml:space="preserve">
          <source>In absence of an inline kind annotation, the inferred arity includes all explicitly bound parameters and all immediately following invisible parameters:</source>
          <target state="translated">インラインの親切アノテーションがない場合、推論されたアリティには、明示的にバインドされたすべてのパラメータと、その直後に続くすべての不可視パラメータが含まれます。</target>
        </trans-unit>
        <trans-unit id="4597cb1599aee82731cada610232980bbc2d3431" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;#{stuff}&lt;/code&gt; is equivalent to &lt;code&gt;#stuff&lt;/code&gt; except that it&amp;rsquo;s self-delimited and thus needs not to be placed at the end of line or in some brackets.</source>
          <target state="translated">さらに、 &lt;code&gt;#{stuff}&lt;/code&gt; は &lt;code&gt;#stuff&lt;/code&gt; と同等ですが、自己区切られているため、行末や角括弧で囲む必要はありません。</target>
        </trans-unit>
        <trans-unit id="eb314fe5b2039048608ae504bca0f576e50cf0b7" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="translated">コアプラグインに加えて、GHCには制約チェッカーの動作を変更できるタイプチェッカープラグインの実験的なサポートがあります。たとえば、GHCに組み込まれている理論よりもタイプレベルの算術式の豊富な理論をサポートするために、コンパイラーをSMTソルバーにインターフェイスすることができます（&lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;タイプレベルのNatural&lt;/a&gt;を使用した計算を参照）。</target>
        </trans-unit>
        <trans-unit id="a4828c748a125eae444ad80c1e864e71abc3d059" translate="yes" xml:space="preserve">
          <source>In addition to being equivalent in the structural sense, the two also have &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instances that behave the same. This type will be marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are advised to use the variant from &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; and wrap it in &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">構造的な意味で同等であることに加えて、2つには同じ動作をする &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; インスタンスもあります。このタイプはGHC 8.8で非推奨とマークされ、GHC 8.10で削除されます。ユーザーは、&lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt;のバリアントを使用して、 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; でラップすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f8311e5504e292a63b6e04f775b8d4c2184db072" translate="yes" xml:space="preserve">
          <source>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</source>
          <target state="translated">コアと型チェッカーのプラグインに加えて、ソースコードの異なる表現にアクセスできるプラグインをインストールすることができます。これらのプラグインの主な目的は、開発ツールの実装を容易にすることです。</target>
        </trans-unit>
        <trans-unit id="babc3f5d8badd87263ede33fef263b59d78b2950" translate="yes" xml:space="preserve">
          <source>In addition to creating a DLL, the &lt;code&gt;-shared&lt;/code&gt; option also creates an import library. The import library name is derived from the name of the DLL, as follows:</source>
          <target state="translated">DLLの作成に加えて、 &lt;code&gt;-shared&lt;/code&gt; オプションはインポートライブラリも作成します。インポートライブラリ名は、DLLの名前から次のように派生します。</target>
        </trans-unit>
        <trans-unit id="249a7c61164a88062524e2aa24c887b8f5661159" translate="yes" xml:space="preserve">
          <source>In addition to exceptions thrown by &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. For more details, see:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作によってスローされる例外に加えて、例外は純粋なコード（不正確な例外）または外部イベント（非同期例外）によってスローされる場合がありますが、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドでのみキャッチされます。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="8ee7bbb76ed60016773cd70eeacaa30823fc8982" translate="yes" xml:space="preserve">
          <source>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</source>
          <target state="translated">プログラムの時間と割り当て動作をプロファイリングすることに加えて、時間経過に伴うメモリ使用量のグラフを作成することもできます。これは、プログラムがランタイムに必要以上のメモリを保持している場合に、スペースリークの原因を検出するのに役立ちます。スペースリークは、ガベージコレクタの活動が激しいために実行が遅くなり、プログラムが完全にメモリを使い果たしてしまう原因となることもあります。</target>
        </trans-unit>
        <trans-unit id="6a5fe76494632cc57e366196cfdfa66ddce021ab" translate="yes" xml:space="preserve">
          <source>In addition to the data that has just been written into your buffer by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action, it gives you a pre-existing chunk of data as a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It also gives you the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. It is safe to run this following action using a buffer with as much free space as was left by the previous run action.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; アクションによってバッファーに書き込まれたばかりのデータに加えて、既存のデータのチャンクを &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として提供します。また、次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; アクションも提供します。前の実行アクションで残されたのと同じくらいの空き容量を持つバッファを使用して、この次のアクションを実行しても安全です。</target>
        </trans-unit>
        <trans-unit id="68a3d1c2998b358fa67a87a4eae02294a3a1f06e" translate="yes" xml:space="preserve">
          <source>In addition to the usual DIEs specified by the DWARF specification, GHC produces a variety of others using the vendor-extensibility regions of the tag and attribute space.</source>
          <target state="translated">DWARF仕様で指定された通常のDIEに加えて、GHCはタグと属性空間のベンダ拡張領域を使用して様々なDIEを生成します。</target>
        </trans-unit>
        <trans-unit id="367b4aa700725245db9b4214f26896949ea4e52a" translate="yes" xml:space="preserve">
          <source>In addition you can use the &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; RTS option to get the following additional information:</source>
          <target state="translated">さらに、&lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt; RTSオプションを使用して、次の追加情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="34a0aaebb5d7ddb8779614a440c8d24ce42c1bca" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="translated">また、中に &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; モード、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; がスローされます &lt;code&gt;UserInterrupt&lt;/code&gt; のプロセスが終了している場合、例外を &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt; 。通常、この例外をキャッチする必要はありませんが、伝播させて、通常の正常なシャットダウンを提供します。注意すべき詳細の1つは、 &lt;code&gt;UserInterrupt&lt;/code&gt; 例外が &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; を呼び出すスレッドで&lt;em&gt;同期&lt;/em&gt;的にスロー&lt;em&gt;さ&lt;/em&gt;れるのに対し、通常は &lt;code&gt;SIGINT&lt;/code&gt; が例外をメインスレッドに&lt;em&gt;非同期&lt;/em&gt;的にスロー&lt;em&gt;する&lt;/em&gt;ことです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c471cd04e14694861eb5b4cffed48ebebd4ccc5" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="translated">また、中に &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; モード、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; がスローされます &lt;code&gt;UserInterrupt&lt;/code&gt; のプロセスが終了している場合、例外を &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt; 。通常、この例外をキャッチしたくない場合は、それを伝播させて、通常の正常なシャットダウンを行います。注意すべき詳細の1つは、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; を呼び出すスレッドで &lt;code&gt;UserInterrupt&lt;/code&gt; 例外が&lt;em&gt;同期&lt;/em&gt;的にスロー&lt;em&gt;さ&lt;/em&gt;れるのに対し、通常は &lt;code&gt;SIGINT&lt;/code&gt; によって例外がメインスレッドに&lt;em&gt;非同期&lt;/em&gt;でスローされることです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90bb874cbfbf13e44d04cff0d054e6082425071b" translate="yes" xml:space="preserve">
          <source>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</source>
          <target state="translated">さらに、セレクタへの引数には、意味するデータ型を型署名として与えることができます。</target>
        </trans-unit>
        <trans-unit id="4126bb6eb85667a0ba0f06971d33a3e7b8c05e03" translate="yes" xml:space="preserve">
          <source>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</source>
          <target state="translated">さらに、プロファイルは、特定の基準を満たすヒープデータに制限することができます。例えば、特定のモジュールによって生成されたデータのみをタイプ別にプロファイルを表示したい場合や、特定のタイプのデータに対してリテーナ別にプロファイルを表示したい場合などが考えられます。制限は以下のように指定します。</target>
        </trans-unit>
        <trans-unit id="99e228e4f1543c3dc7a9d1ed29f66747995deb83" translate="yes" xml:space="preserve">
          <source>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</source>
          <target state="translated">さらに、特殊な構文を持つフィールドもあります(パッケージ名、バージョン、依存関係など)。</target>
        </trans-unit>
        <trans-unit id="d6e619bf7b233d387015ddc79828be55161d099a" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="translated">さらに、&lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; &lt;/a&gt;を使用すると、インポートまたはエクスポートリストのデータコンストラクターの名前の前にキーワード &lt;code&gt;pattern&lt;/code&gt; を付けることができ、親タイプコンストラクターなしでデータコンストラクターのインポートまたはエクスポートを行うことができます（&lt;a href=&quot;#patsyn-impexp&quot;&gt;パターンシノニムのインポートおよびエクスポートを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3132ea808ceba667f793dbacd623742dade438fc" translate="yes" xml:space="preserve">
          <source>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal &lt;code&gt;368&lt;/code&gt; is exactly that of &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;; it&amp;rsquo;s fine for &lt;code&gt;fromInteger&lt;/code&gt; to have any of the types:</source>
          <target state="translated">すべての場合（矢印表記を除く）で、静的なセマンティクスは、それが少し予期しないものであっても、脱糖された形式のものでなければなりません。たとえば、リテラル &lt;code&gt;368&lt;/code&gt; の静的セマンティクスは、 &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; それとまったく同じです。以下のためのそれの罰金 &lt;code&gt;fromInteger&lt;/code&gt; はタイプのいずれかを持っています：</target>
        </trans-unit>
        <trans-unit id="5f38c78f8727c5dd6daeb670eabd5e48e13730ce" translate="yes" xml:space="preserve">
          <source>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</source>
          <target state="translated">それ以外のすべてのコンテキストでは、型のワイルドカードは禁止されており、名前付きワイルドカードは通常の型変数として扱われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e57867e96afea7ee28118e42687442828dc1fec7" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;instance&lt;/code&gt; declaration for the class, if no explicit &lt;code&gt;type instance&lt;/code&gt; declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</source>
          <target state="translated">で &lt;code&gt;instance&lt;/code&gt; 明示的な場合、クラスの宣言、 &lt;code&gt;type instance&lt;/code&gt; 宣言が関連するタイプのために指定されていない、デフォルト宣言は単にデフォルトクラスメソッドと同様に、代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="e2a6cf8b0ee18b4eb7df425b8e1b8603664a8706" translate="yes" xml:space="preserve">
          <source>In an import or export list, such as</source>
          <target state="translated">のようなインポートまたはエクスポートリストでは</target>
        </trans-unit>
        <trans-unit id="cc915ffb21811be1dad23381dc586229e4878e9d" translate="yes" xml:space="preserve">
          <source>In associated types, we order the type variables as if the type family was a top-level declaration, ignoring the visibilities of the class&amp;rsquo;s type variable binders. Here is an example:</source>
          <target state="translated">関連する型では、型族が最上位の宣言であるかのように型変数を順序付け、クラスの型変数バインダーの可視性を無視します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="e55a4f9d1aac9b09d0ad21c5b54130b49a8ea4a4" translate="yes" xml:space="preserve">
          <source>In base we can't use wordToNatural# as built-in rules transform some of them into Natural literals. Use this function instead.</source>
          <target state="translated">ベースでは wordToNatural#を使うことはできません。代わりにこの関数を使ってください。</target>
        </trans-unit>
        <trans-unit id="734a9d6aacdebfcf8e099a4ac67e6c63811f6437" translate="yes" xml:space="preserve">
          <source>In batch compilation mode, the name of the object file can also be overridden using the &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-o ⟨file⟩&lt;/code&gt;&lt;/a&gt; option, and the name of the interface file can be specified directly using the &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-ohi ⟨file⟩&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">バッチコンパイルモードでは、オブジェクトファイルの名前は&lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-o ⟨file⟩&lt;/code&gt; &lt;/a&gt;オプションを使用してオーバーライドすることもでき、インターフェースファイルの名前は&lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-ohi ⟨file⟩&lt;/code&gt; &lt;/a&gt;オプションを使用して直接指定できます。</target>
        </trans-unit>
        <trans-unit id="dabb8697131df61b0e2fe80e2efe74db486060e0" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="translated">さまざまなツールで後で分析できるように、バイナリ形式でファイルに変換します。そのようなツールの1つが&lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScopeです&lt;/a&gt;。これは、イベントログを解釈して、プログラムの視覚的な並列実行プロファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="03034364819bbabad90c6e7c5e8b8d93809898f3" translate="yes" xml:space="preserve">
          <source>In binary format to customized event log writer. This enables live analysis of the events while the program is running.</source>
          <target state="translated">カスタマイズされたイベントログライターにバイナリ形式で。これにより、プログラム実行中のイベントのライブ分析が可能になります。</target>
        </trans-unit>
        <trans-unit id="31be45f64d4525c6c8cb6e9758d8d1527903b2fe" translate="yes" xml:space="preserve">
          <source>In binding positions, we have similar parsing rules. Consider the following example</source>
          <target state="translated">バインディング位置では、同様の解析ルールがあります。次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0ed50f5a5fcb2b11667475d2e83b41c38eee4ebd" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;e&lt;/code&gt; is evaluated before starting to evaluate &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;body&lt;/code&gt; の評価を開始する前に &lt;code&gt;e&lt;/code&gt; が評価されます。</target>
        </trans-unit>
        <trans-unit id="bacc600884c7ef880d3490fde1eab0149e179ff1" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; are available both throughout the &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;rec&lt;/code&gt; block, and in the statements that follow it. The difference is that &lt;code&gt;let&lt;/code&gt; is non-monadic, while &lt;code&gt;rec&lt;/code&gt; is monadic. (In Haskell &lt;code&gt;let&lt;/code&gt; is really &lt;code&gt;letrec&lt;/code&gt;, of course.)</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;r1&lt;/code&gt; と &lt;code&gt;r2&lt;/code&gt; は、 &lt;code&gt;let&lt;/code&gt; または &lt;code&gt;rec&lt;/code&gt; ブロック全体と、それに続くステートメントの両方で使用できます。違いは、 &lt;code&gt;let&lt;/code&gt; はモナドではないが、 &lt;code&gt;rec&lt;/code&gt; はモナドであるということです。（もちろん、Haskellでは &lt;code&gt;let&lt;/code&gt; は本当に &lt;code&gt;letrec&lt;/code&gt; です。）</target>
        </trans-unit>
        <trans-unit id="be81ef5fcc497dfbbeafbf556c2438a6c9895ee9" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="translated">newtypeでクラスを派生させようとしたときに&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;もオンになっている&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;は、DeriveAnyClassが優先されます。</target>
        </trans-unit>
        <trans-unit id="a51760f56c296114327d0a572e7ed7fabe636444" translate="yes" xml:space="preserve">
          <source>In cases where several instances of &lt;code&gt;needle&lt;/code&gt; overlap, only the first one will be replaced:</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; 複数のインスタンスが重複する場合、最初のインスタンスのみが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="0f9ef87c7934b0a5953335739ae5904bf71e50d1" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="translated">&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;と連携して、GHCはより上位の種類をサポートします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="ecd1bab6934e5b406a45cc9d86aaae1eda35aa2c" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt;拡張機能と組み合わせて、空のデータ宣言で標準型クラスのインスタンスを派生させることもできます（&lt;a href=&quot;#empty-data-deriving&quot;&gt;空のデータ型のインスタンスの派生を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0160dd1b8a2fb226728d5dc6a312d10bda3db9e4" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt;拡張機能と組み合わせて、空のデータ宣言は標準型クラスのインスタンスを派生させることもできます（&lt;a href=&quot;#empty-data-deriving&quot;&gt;空のデータ型のインスタンスの派生を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b20440f6fb3e228846c05d91a5f12ecb0390cdea" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">対照的に、これを &lt;code&gt;g&lt;/code&gt; に対して行う確実な方法はありません。 &lt;code&gt;Eq a&lt;/code&gt; または &lt;code&gt;Eq b&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; の型の制約で最初にリストされるかどうかはわかりません。GHCのリリース間で可視型アプリケーションを堅牢にするために、 &lt;code&gt;g&lt;/code&gt; での使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="22f781a5702b84d96719b279819ee7bee564bebe" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">対照的に、 &lt;code&gt;g&lt;/code&gt; に対してこれを行う信頼できる方法はありません。 &lt;code&gt;Eq a&lt;/code&gt; または &lt;code&gt;Eq b&lt;/code&gt; が &lt;code&gt;g&lt;/code&gt; のタイプの制約の最初にリストされるかどうかはわかりません。可視タイプのアプリケーションをGHCのリリース間で堅牢にするために、 &lt;code&gt;g&lt;/code&gt; での使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="a3824b67115f2edecbe27bdcb0540496f21f8bbe" translate="yes" xml:space="preserve">
          <source>In dumps, suppress everything (except for uniques) that is suppressible.</source>
          <target state="translated">ダンプでは、抑制可能なものはすべて(ユニックを除く)抑制します。</target>
        </trans-unit>
        <trans-unit id="827cb020739fbf9c40831c2ab9e7d2857ae60ae1" translate="yes" xml:space="preserve">
          <source>In each case the appropriate class must be in scope before it can be mentioned in the &lt;code&gt;deriving&lt;/code&gt; clause.</source>
          <target state="translated">いずれの場合も、適切なクラスは、 &lt;code&gt;deriving&lt;/code&gt; 句で言及する前にスコープ内になければなりません。</target>
        </trans-unit>
        <trans-unit id="ea2baf294e27435a713527ed1fabd3f79a5937ec" translate="yes" xml:space="preserve">
          <source>In earlier versions of GHC, it was possible to omit the &lt;code&gt;forall&lt;/code&gt; in the type of the constructor if there was an explicit context. For example:</source>
          <target state="translated">GHCの以前のバージョンでは、明示的なコンテキストがある場合、コンストラクターのタイプで &lt;code&gt;forall&lt;/code&gt; を省略することが可能でした。例えば：</target>
        </trans-unit>
        <trans-unit id="1fa31c0c659980e252d481c558bed906f0492165" translate="yes" xml:space="preserve">
          <source>In either case, C is the only authority on package trust. It is up to the client to decide which &lt;a href=&quot;#safe-package-trust&quot;&gt;packages they trust&lt;/a&gt;.</source>
          <target state="translated">どちらの場合も、Cはパッケージの信頼に関する唯一の権限です。&lt;a href=&quot;#safe-package-trust&quot;&gt;信頼&lt;/a&gt;するパッケージを決定するのはクライアントの責任です。</target>
        </trans-unit>
        <trans-unit id="e577bd1cf962e0880951f56bb28b5bcc144b9dbd" translate="yes" xml:space="preserve">
          <source>In error messages, expressions are printed to a certain &amp;ldquo;depth&amp;rdquo;, with subexpressions beyond the depth replaced by ellipses. This flag sets the depth. Its default value is 5.</source>
          <target state="translated">エラーメッセージでは、式は特定の「深さ」に出力され、深さを超える部分式は省略記号に置き換えられます。このフラグは深さを設定します。デフォルト値は5です。</target>
        </trans-unit>
        <trans-unit id="4aea9c2bc91c202848f5c9b6db19bf9964c3bd1d" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;#5252&lt;/a&gt;).</source>
          <target state="translated">実際、技術的な理由から、&lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;なしでは効果がありません（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;＃5252を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d3785b1fb09bd9bd3050ae561da76ff7c2ea38ed" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue #5252&lt;/a&gt;).</source>
          <target state="translated">実際、技術的な理由から、&lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;なしでは効果がありません（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue＃5252を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3bbd3972ad6aafb5b6e87ed35007593f460b926a" translate="yes" xml:space="preserve">
          <source>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</source>
          <target state="translated">実際には、コマンドライン上に Haskell ソースファイルがあり、他のモードが指定されていない場合、GHC は自動的に make モードに入ります。</target>
        </trans-unit>
        <trans-unit id="99ccc14a1c3446055aa550c00e0053392d4a3107" translate="yes" xml:space="preserve">
          <source>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">実際、GHCiはブレークポイントに達したときにコマンドを実行する方法を提供するため、&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; を&lt;/a&gt;自動的に実行させることができます。</target>
        </trans-unit>
        <trans-unit id="4c63df3de91a091a7b7f15134cec823a993cb116" translate="yes" xml:space="preserve">
          <source>In function &lt;code&gt;showHelp&lt;/code&gt; GHC sees no overlapping instances, and so uses the &lt;code&gt;MyShow [a]&lt;/code&gt; instance without complaint. In the call to &lt;code&gt;myshow&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;, GHC resolves the &lt;code&gt;MyShow [T]&lt;/code&gt; constraint using the overlapping instance declaration in module &lt;code&gt;Main&lt;/code&gt;. As a result, the program prints</source>
          <target state="translated">関数 &lt;code&gt;showHelp&lt;/code&gt; で GHCは重複するインスタンスを検出しないため、 &lt;code&gt;MyShow [a]&lt;/code&gt; インスタンスを問題なく使用します。呼び出しで &lt;code&gt;myshow&lt;/code&gt; で &lt;code&gt;main&lt;/code&gt; 、GHCは解決 &lt;code&gt;MyShow [T]&lt;/code&gt; モジュールで重複インスタンス宣言使用して制約を &lt;code&gt;Main&lt;/code&gt; 。その結果、プログラムは</target>
        </trans-unit>
        <trans-unit id="2ec6fbf6ec53f51208aead68b9f4175c5c65a628" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">一般に、 &lt;code&gt;p&lt;/code&gt; が変数をバインドしない場合、 &lt;code&gt;p = e&lt;/code&gt; バインドする遅延パターンは何もしません。ワイルドカードパターンを1つだけ許可する動機は、警告が発生しない &lt;code&gt;_v = rhs3&lt;/code&gt; ないことです。そして、それらは型制約を追加するのに役立ちます、例えば &lt;code&gt;_ = x::Int&lt;/code&gt; 。強打パターン（&lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;強打パターンと厳密なHaskellを&lt;/a&gt;参照）は、評価を強制するので何もし&lt;em&gt;ないわけで&lt;/em&gt;は&lt;em&gt;なく&lt;/em&gt;、 &lt;code&gt;seq&lt;/code&gt; の代わりとして役立ちます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51f41108f0c2bbe0749431bd7963794d7183a3a6" translate="yes" xml:space="preserve">
          <source>In general terms, a weak pointer is a reference to an object that is not followed by the garbage collector - that is, the existence of a weak pointer to an object has no effect on the lifetime of that object. A weak pointer can be de-referenced to find out whether the object it refers to is still alive or not, and if so to return the object itself.</source>
          <target state="translated">一般的には、弱いポインタはガベージコレクタが追従しないオブジェクトへの参照であり、つまり、オブジェクトへの弱いポインタの存在はそのオブジェクトの寿命に影響しません。弱いポインタは、参照しているオブジェクトがまだ生きているかどうかを調べるために参照を解除することができます。</target>
        </trans-unit>
        <trans-unit id="481359b39a7a3a188516a1c2c13bacad1c4ff5db" translate="yes" xml:space="preserve">
          <source>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value &lt;code&gt;intEndo&lt;/code&gt; using the pattern synonyms &lt;code&gt;Arrow&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; as defined previously.</source>
          <target state="translated">一般に、3種類のパターン同義語があります。単方向、双方向、および明示的に双方向。これまでに示した例は、双方向パターン同義語の例です。双方向シノニムは、通常のデータコンストラクターと同じように動作します。パターンコンテキストで使用して値を分解したり、式コンテキストで使用して値を構築したりできます。たとえば、前に定義したパターンの同義語 &lt;code&gt;Arrow&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; を使用して、値 &lt;code&gt;intEndo&lt;/code&gt; を作成できます。</target>
        </trans-unit>
        <trans-unit id="2b27522334b948b2f46f2564190ed9a7b062b44c" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;ghc -M Foo&lt;/code&gt; does the following. For each module &lt;code&gt;M&lt;/code&gt; in the set &lt;code&gt;Foo&lt;/code&gt; plus all its imports (transitively), it adds to the Makefile:</source>
          <target state="translated">一般に、 &lt;code&gt;ghc -M Foo&lt;/code&gt; は次のことを行います。セット &lt;code&gt;Foo&lt;/code&gt; の各モジュール &lt;code&gt;M&lt;/code&gt; とそのすべてのインポート（推移的）について、Makefileに追加します。</target>
        </trans-unit>
        <trans-unit id="7f7c6f26fd4493c528d23d0ae55697bac0eab934" translate="yes" xml:space="preserve">
          <source>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</source>
          <target state="translated">一般的にGHCは、何らかの理由(どんなに軽微でも)があって、それが有用であると仮定した場合にのみ、機能をインライン化します。</target>
        </trans-unit>
        <trans-unit id="60a1f55e5825a2ce9deec4865aae9e5195367f7d" translate="yes" xml:space="preserve">
          <source>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</source>
          <target state="translated">一般的に、GHCは単相型(フォーオールがないもの)でしか多相関数をインスタンス化しません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="225fcb89e38b97f2054653e3553fa5805a7ccac0" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">一般に、&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;コマンドの後で、可能な場合は &lt;code&gt;*&lt;/code&gt; 形式で、最後に読み込まれた「ターゲット」モジュールのスコープに自動インポートが追加されます。たとえば、 &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; および &lt;code&gt;bar.hs&lt;/code&gt; にモジュール &lt;code&gt;Bar&lt;/code&gt; が含まれている場合、 &lt;code&gt;Bar&lt;/code&gt; が解釈されるとスコープは &lt;code&gt;*Bar&lt;/code&gt; に設定され、 &lt;code&gt;Bar&lt;/code&gt; がコンパイルされると &lt;code&gt;Prelude Bar&lt;/code&gt; （GHCi &lt;code&gt;Prelude&lt;/code&gt; が存在せず、 &lt;code&gt;*&lt;/code&gt; 形式のモジュールがない場合は、自動的にPreludeを追加します）。これらの自動的に追加されたインポートは、&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="f31992d81c36250762b8a1fe8122ed580d721498" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="translated">一般に、&lt;a href=&quot;#instance-resolution&quot;&gt;インスタンスの解決&lt;/a&gt;で説明したように、&lt;em&gt;GHCでは、型クラスの制約を解決するために使用するインスタンス宣言を明確にする必要があります&lt;/em&gt;。また、GHC &lt;em&gt;は、最も具体的な&lt;/em&gt;インスタンスがある場合に、複数のインスタンスを一致させることにより、インスタンスの解決を緩和する方法を提供します。さらに、最も具体的なインスタンスがあるかどうかに関係なく、複数のインスタンスを一致させることで、さらに緩めることができます。このセクションでは、詳細を説明します。</target>
        </trans-unit>
        <trans-unit id="a24a52ff5732e7457a6c0f10b8d48e80b50c3fe8" translate="yes" xml:space="preserve">
          <source>In general, if GHC sees an expression within Oxford brackets (e.g., &lt;code&gt;[|
foo bar |]&lt;/code&gt;, then GHC looks up each name within the brackets. If a name is global (e.g., suppose &lt;code&gt;foo&lt;/code&gt; comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose &lt;code&gt;bar&lt;/code&gt; is bound locally in the function definition &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt;), then GHC uses &lt;code&gt;lift&lt;/code&gt; on it (so GHC pretends &lt;code&gt;[| foo bar |]&lt;/code&gt; actually contains &lt;code&gt;[|
foo $(lift bar) |]&lt;/code&gt;). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</source>
          <target state="translated">一般に、GHCがOxfordブラケット内の式（たとえば &lt;code&gt;[| foo bar |]&lt;/code&gt; ）を見つけた場合、GHCはブラケット内の各名前を検索します。名前がグローバルの場合（たとえば、 &lt;code&gt;foo&lt;/code&gt; がインポートまたはトップレベル宣言）の場合、完全修飾名が引用符で直接使用されます。名前がローカルである場合（たとえば、 &lt;code&gt;bar&lt;/code&gt; が関数定義 &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt; でローカルにバインドされている場合）、GHCは &lt;code&gt;lift&lt;/code&gt; を使用します（したがって、GHCは &lt;code&gt;[| foo bar |]&lt;/code&gt; に &lt;code&gt;[| foo $(lift bar) |]&lt;/code&gt; |]が実際に含まれているように見せかけます。スプライス位置のスコープにないローカル名は、見積もりが処理されるときに実際に評価されます。</target>
        </trans-unit>
        <trans-unit id="c64b81fdef25b826556b46bc221a058713ff56df" translate="yes" xml:space="preserve">
          <source>In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using &lt;code&gt;MVar&lt;/code&gt;s between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit reference counting.</source>
          <target state="translated">一般に、ファイナライザーを個別のオブジェクトに使用し、それらの間に順序制約を設けることはお勧めしません。順序付けを堅牢に表現するには、ファイナライザ間で &lt;code&gt;MVar&lt;/code&gt; を使用した明示的な同期が必要ですが、ランタイムが単一のスレッドで複数のファイナライザを順番に実行する場合があるため（パフォーマンス上の理由から）、ファイナライザ間の同期により、人工的なデッドロックが発生する可能性があります。別の方法は、明示的な参照カウントを使用することです。</target>
        </trans-unit>
        <trans-unit id="2a479e2f380ec3084c0c0b21decb15ffdb8b192d" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;pluginRecompile&lt;/code&gt; field has the following type:</source>
          <target state="translated">一般に、 &lt;code&gt;pluginRecompile&lt;/code&gt; フィールドには次のタイプがあります。</target>
        </trans-unit>
        <trans-unit id="c8f3128b6b16c5e45ef1a5d99515ed3873e858da" translate="yes" xml:space="preserve">
          <source>In general, the rule for when a &lt;code&gt;do&lt;/code&gt; statement incurs a &lt;code&gt;Monad&lt;/code&gt; constraint is as follows. If the do-expression has the following form:</source>
          <target state="translated">一般に、 &lt;code&gt;do&lt;/code&gt; ステートメントが &lt;code&gt;Monad&lt;/code&gt; 制約を負うときの規則は次のとおりです。do式の形式が次の場合：</target>
        </trans-unit>
        <trans-unit id="16433cfc779e293649e5b61b5f49a9b6e34ab87f" translate="yes" xml:space="preserve">
          <source>In general, these options act on a &lt;code&gt;.tix&lt;/code&gt; file after an instrumented binary has generated it.</source>
          <target state="translated">一般に、これらのオプションは、インストルメントされたバイナリが生成した &lt;code&gt;.tix&lt;/code&gt; ファイルに作用します。</target>
        </trans-unit>
        <trans-unit id="16864de7adb994a5d73b4457714719a11060892c" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;lsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">一般に、任意ランク型の型推論は決定できません。GHCは、OderskyとLauferによって提案されたアルゴリズム（「型注釈を機能させる」、POPL'96）を使用して、プログラマーの助けを必要とする決定可能なアルゴリズムを取得します。「何らかの助け」の正式な仕様はまだありませんが、ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="31dba12d8f480c4aabbd58985394adff8da0a17b" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;rsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">一般に、任意のランクの型の型推論は決定不可能です。GHCは、OderskyとLauferによって提案されたアルゴリズム（「型注釈を機能させる」、POPL'96）を使用して、プログラマーの助けを必要とすることにより、決定可能なアルゴリズムを取得します。「いくつかのヘルプ」の正式な仕様はまだありませんが、ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2024a464eb534dfbe74fefedd702f7a3e2250030" translate="yes" xml:space="preserve">
          <source>In general, you can only pattern-match on an existentially-quantified constructor in a &lt;code&gt;case&lt;/code&gt; expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn&amp;rsquo;t make sense, because it&amp;rsquo;s not clear how to prevent the existentially-quantified type &amp;ldquo;escaping&amp;rdquo;. So for now, there&amp;rsquo;s a simple-to-state restriction. We&amp;rsquo;ll see how annoying it is.</source>
          <target state="translated">一般に、 &lt;code&gt;case&lt;/code&gt; 式または関数定義のパターンの実存的に数量化されたコンストラクターでのみパターン一致を行うことができます。この制限の理由は、実際には実装上のものです。バインディンググループの型チェックは、実存的なものを複雑にすることなく、すでに悪夢です。また、モジュールのトップレベルでの実存パターンバインディングは、実存的に数量化されたタイプの「エスケープ」を防ぐ方法が明確でないため、意味がありません。そのため、現時点では、状態を簡単に制限できます。それがいかに煩わしいかがわかります。</target>
        </trans-unit>
        <trans-unit id="98c6d67c9ce44b8e6eac2d0b4075c81dabba5106" translate="yes" xml:space="preserve">
          <source>In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</source>
          <target state="translated">高性能な Haskell コード (数値コードなど)では、内部ループからサンクを排除することは大きなメリットになります。GHCは3つの拡張機能をサポートしており、プログラマが遅延(コールバイニーズ)評価ではなく、厳密(コールバイバリュー)評価の使用を指定できるようになっています。</target>
        </trans-unit>
        <trans-unit id="c3bb19915354a80256cd126fd6a60161eb482c2d" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="translated">デフォルトのモードでは、GHCは次のバージョンの言語標準から削除することが決定されているため、データ型コンテキストを受け入れません。この動作は、 &lt;code&gt;DatatypeContexts&lt;/code&gt; 拡張機能で制御できます。&lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;データ型コンテキストを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="275629b87d7294aa0eaa9588d8a9a706ba895f13" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC makes some programs slightly more defined than they should be. For example, consider</source>
          <target state="translated">デフォルトのモードでは、GHC はいくつかのプログラムを本来あるべき姿よりも少しだけ定義しています。例えば、次のようなことを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e94f4b216d151b4a30a7c1bd717bfe451b1cb48d" translate="yes" xml:space="preserve">
          <source>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</source>
          <target state="translated">クラスメソッドがクラス変数を最初にリストアップする方法に倣って、関連付けられた型もクラス変数を他の変数よりも先にリストアップします。これは、クラスから推論された変数が、クラスから指定された変数の前に来ることを意味し、他の暗黙的にバインドされた変数の前に来ます。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="af1a88fdd917297213df61b4944e92d2f20600ce" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">多くの場合、 &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; 操作は、関数の適用を促進する &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; の使用に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="86e41b1490a2b7bfe151acff33ef58b56ab399e1" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">多くの場合、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; 操作は、関数の適用を促進する &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; の使用に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="3b2d8e96b23e6bc78c49594a14c36c62bbb7071e" translate="yes" xml:space="preserve">
          <source>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</source>
          <target state="translated">より複雑な例では、例外の階層全体を定義したい場合があります。</target>
        </trans-unit>
        <trans-unit id="4c4936db3ddc3e67725b71767b1d5c5e41743bb8" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;toLazyByteString&lt;/code&gt; で使用されるパラメーターは優れたパフォーマンスを提供します。 &lt;code&gt;toLazyByteString&lt;/code&gt; のサブパフォーマンスケースは、短い（128バイト未満） &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実行しています。この場合、最初の4kbバッファーの割り当てオーバーヘッドとトリミングコストが、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の実行コストを左右します。あなたはこの問題を回避することができます</target>
        </trans-unit>
        <trans-unit id="3027d30c8f8fb2c3a4b6e7dd0e32412aa9179811" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;toLazyByteString&lt;/code&gt; で使用されるパラメーターは優れたパフォーマンスを提供します。 &lt;code&gt;toLazyByteString&lt;/code&gt; のサブパフォーマンスケースは、短い（128バイト未満） &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実行しています。この場合、最初の4kbバッファーの割り当てオーバーヘッドとトリミングコストが、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の実行コストを左右します。あなたはこの問題を回避することができます</target>
        </trans-unit>
        <trans-unit id="76b1ffe4dff1aba8ccdccdaa16d342830f1d4227" translate="yes" xml:space="preserve">
          <source>In most cases, you must supply an explicit context (in the example the context is &lt;code&gt;(Eq a)&lt;/code&gt;), exactly as you would in an ordinary instance declaration. (In contrast, in a &lt;code&gt;deriving&lt;/code&gt; clause attached to a data type declaration, the context is inferred.)</source>
          <target state="translated">ほとんどの場合、通常のインスタンス宣言の場合とまったく同じように、明示的なコンテキスト（この例では、コンテキストは &lt;code&gt;(Eq a)&lt;/code&gt; ）を指定する必要があります。（対照的に、データ型宣言に付加された &lt;code&gt;deriving&lt;/code&gt; 句では、コンテキストが推測されます。）</target>
        </trans-unit>
        <trans-unit id="19e317a4f2744059301e6b1045661a71d5655709" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="translated">ほとんどのシナリオでは、すべての &lt;code&gt;deriving&lt;/code&gt; ステートメントが明確な方法でタイプクラスインスタンスを生成します。ただし、&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; の&lt;/a&gt;両方の拡張機能を同時に有効にすると、派生が曖昧になるという例外的なケースがあります。次の例を考えてみましょう</target>
        </trans-unit>
        <trans-unit id="1b692dc9121229cacd00afc8cf58d7662492e8b8" translate="yes" xml:space="preserve">
          <source>In mutually recursive bindings, such as &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;where&lt;/code&gt; 、またはトップレベルなどの相互再帰的なバインディングでは、1つの宣言のビューパターンが他の宣言によってバインドされた変数に言及しない場合があります。つまり、各宣言は自己完結型でなければなりません。たとえば、次のプログラムは許可されていません。</target>
        </trans-unit>
        <trans-unit id="becdc0c8077f7104b4c28a91add0067b223f02f7" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="translated">種類の使用方法に完全な柔軟性を持たせるには、種類システムを使用して、ボックス化された持ち上げられたタイプ（ &lt;code&gt;Int&lt;/code&gt; や &lt;code&gt;[Bool]&lt;/code&gt; などの通常の日常のタイプ）とボックス化されていないプリミティブタイプ（&lt;a href=&quot;#primitives&quot;&gt;ボックス化されていないタイプとプリミティブ操作&lt;/a&gt;）を区別する必要があります。） &lt;code&gt;Int#&lt;/code&gt; のように。したがって、いわゆる軽症多型性があります。</target>
        </trans-unit>
        <trans-unit id="e6cd748eca92cb9876cb47ec0d324628b6e60b35" translate="yes" xml:space="preserve">
          <source>In order to avoid conflicting with the built-in constraint solving, the following user-defined &lt;code&gt;HasField&lt;/code&gt; instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</source>
          <target state="translated">組み込みの制約解決との競合を回避するために、次のユーザー定義の &lt;code&gt;HasField&lt;/code&gt; インスタンスは禁止されています（インスタンスヘッドに表示されるタイプファミリーの禁止などの通常のルールに加えて）：</target>
        </trans-unit>
        <trans-unit id="93af4d623943d3f8bd7b71270963bbcbfaf23873" translate="yes" xml:space="preserve">
          <source>In order to be able to do this, we need to know the actual definitions of these types:</source>
          <target state="translated">そのためには、これらのタイプの実際の定義を知る必要があります。</target>
        </trans-unit>
        <trans-unit id="aec123491a69a064a575a51206895c88f02274ac" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="translated">型ファミリーが存在する場合の型推論が決定可能であることを保証するために、型インスタンス宣言の形成にいくつかの追加の制限を課す必要があります（「&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;オープンタイプ関数による型チェック&lt;/a&gt;」の定義5（緩和された条件）を参照）。 。インスタンス宣言には一般的な形式があります</target>
        </trans-unit>
        <trans-unit id="5a5e110d7e22d8c1fbc33d3a5b3e328299c301bb" translate="yes" xml:space="preserve">
          <source>In order to make graphs more readable, &lt;code&gt;hp2ps&lt;/code&gt; sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The &lt;code&gt;-d&lt;/code&gt; option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</source>
          <target state="translated">グラフを読みやすくするために、 &lt;code&gt;hp2ps&lt;/code&gt; は各識別子の影付きのバンドを並べ替えます。デフォルトの並べ替え順序は、面積が最も大きいバンドを、小さいバンドの上に積み上げることです。 &lt;code&gt;-d&lt;/code&gt; オプションは、粗いバンドが（最大標準偏差を用いて一連の値を表すもの）は滑らかなものの上に積層させます。</target>
        </trans-unit>
        <trans-unit id="05de27ae60fa5ff58255cf77bb61e0034b072231" translate="yes" xml:space="preserve">
          <source>In order to make use of multiple CPUs, your program must be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). Additionally, the following compiler options affect parallelism:</source>
          <target state="translated">複数のCPUを使用するには、プログラムを&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;オプションでリンクする必要があります（&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプションを&lt;/a&gt;参照）。さらに、次のコンパイラオプションは並列処理に影響します。</target>
        </trans-unit>
        <trans-unit id="a539e64a6ae327e4d4847a3da0692c246af57900" translate="yes" xml:space="preserve">
          <source>In order to stop the value &lt;code&gt;it&lt;/code&gt; being bound on each command, the flag &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt;&lt;code&gt;-fno-it&lt;/code&gt;&lt;/a&gt; can be set. The &lt;code&gt;it&lt;/code&gt; variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see &lt;a href=&quot;#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt;).</source>
          <target state="translated">各コマンドにバインドされ &lt;code&gt;it&lt;/code&gt; いる値を停止するために、フラグ&lt;a href=&quot;#ghc-flag--fno-it&quot;&gt; &lt;code&gt;-fno-it&lt;/code&gt; &lt;/a&gt;を設定できます。 &lt;code&gt;it&lt;/code&gt; 変数は、（参照により、GHCiのことでどのように扱われるか影の宣言にスペースリークの源となり得る&lt;a href=&quot;#ghci-decls&quot;&gt;タイプ、クラスや他の宣言を&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b5ff7b86e25253644ff1722e9fde733a07775459" translate="yes" xml:space="preserve">
          <source>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a &lt;code&gt;CTYPE&lt;/code&gt; pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</source>
          <target state="translated">CAPIで使用されるときにHaskell型が対応するC型をGHCに通知するために、型定義で &lt;code&gt;CTYPE&lt;/code&gt; プラグマを使用できます。タイプを定義するヘッダーは、オプションで指定することもできます。構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="47421418538d24c7ed6361fd82a54bf7f6224d2c" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">FFIをマルチスレッド設定で使用するには、&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;オプションを使用する必要があります（&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b3462ac0bc32460cb66fe5ad73156484f635fcbf" translate="yes" xml:space="preserve">
          <source>In order, &lt;code&gt;ghc&lt;/code&gt; will look for the package environment in the following locations:</source>
          <target state="translated">ためには、 &lt;code&gt;ghc&lt;/code&gt; 次の場所にパッケージ環境のためになります。</target>
        </trans-unit>
        <trans-unit id="6e148f1a9d40b361ea9368ff7b0c22490d6f5818" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s argument gets an implicit bang.</source>
          <target state="translated">通常のHaskellでは、 &lt;code&gt;f&lt;/code&gt; の引数は遅延しているため、 &lt;code&gt;x&lt;/code&gt; は遅延しています。そして &lt;code&gt;g&lt;/code&gt; は引数が厳密であり、したがって &lt;code&gt;x&lt;/code&gt; も厳密です。 &lt;code&gt;Strict&lt;/code&gt; ので、両方が厳しくなる &lt;code&gt;f&lt;/code&gt; の引数は暗黙の強打を取得します。</target>
        </trans-unit>
        <trans-unit id="f0c005424bafd0442e357105c93d1f9cfe1f688c" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s argument gets an implicit bang.</source>
          <target state="translated">通常のHaskellでは、 &lt;code&gt;f&lt;/code&gt; はその引数、したがって &lt;code&gt;x&lt;/code&gt; で怠惰です。そして &lt;code&gt;g&lt;/code&gt; がその引数に厳密したがっても厳密である &lt;code&gt;x&lt;/code&gt; 。 &lt;code&gt;Strict&lt;/code&gt; ので、両方が厳しくなる &lt;code&gt;f&lt;/code&gt; の引数は暗黙の強打を取得します。</target>
        </trans-unit>
        <trans-unit id="1405421d283da798715928c97732511b19ea5e87" translate="yes" xml:space="preserve">
          <source>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each &lt;code&gt;ByteArray#&lt;/code&gt; (interpreting the bytes as an array of &lt;code&gt;CInt&lt;/code&gt;) element of an &lt;code&gt;ArrayArray##&lt;/code&gt;&lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;:</source>
          <target state="translated">他の状況では、C関数はRTSクロージャタイプの知識を必要とする場合があります。次の例では、 &lt;code&gt;ArrayArray##&lt;/code&gt; &lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;の各 &lt;code&gt;ByteArray#&lt;/code&gt; （バイトを &lt;code&gt;CInt&lt;/code&gt; の配列として解釈）要素の最初の要素を合計します。</target>
        </trans-unit>
        <trans-unit id="8e11a6dcf1454bf3942eab61b919beed891ed2da" translate="yes" xml:space="preserve">
          <source>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</source>
          <target state="translated">しかし、他の方法では、スタンドアロン導出は通常の導出と同じルールに従います。</target>
        </trans-unit>
        <trans-unit id="0f9811e2dd3d2cfe0a2fc61f31ef2b584425e79b" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;check b = unless b retry&lt;/code&gt;.</source>
          <target state="translated">言い換えれば、 &lt;code&gt;check b = unless b retry&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7ef12b9b2ccb45bc50f9114a29f6067085963db3" translate="yes" xml:space="preserve">
          <source>In other words, throwing an exception short-circuits the rest of the monadic computation.</source>
          <target state="translated">言い換えれば、例外を投げることは、単項演算の残りの部分を短絡させることになります。</target>
        </trans-unit>
        <trans-unit id="09118f7c3443c63e9289f6a2ade854e33281ae45" translate="yes" xml:space="preserve">
          <source>In our situation, module &lt;code&gt;TCB_Runner&lt;/code&gt; compiles fine without importing module &lt;code&gt;Dangerous&lt;/code&gt;. So when deciding which instance to use for the call to &lt;code&gt;op&lt;/code&gt;, if we determine the instance &lt;code&gt;TC [Int]&lt;/code&gt; from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don&amp;rsquo;t trust (which is compiled using &lt;code&gt;-XSafe&lt;/code&gt; in Safe Haskell) from changing the behaviour of our existing code.</source>
          <target state="translated">この状況では、モジュール &lt;code&gt;TCB_Runner&lt;/code&gt; は、モジュール &lt;code&gt;Dangerous&lt;/code&gt; をインポートせずに正常にコンパイルされます。したがって、 &lt;code&gt;op&lt;/code&gt; の呼び出しに使用するインスタンスを決定するときに、Dangerousモジュールのインスタンス &lt;code&gt;TC [Int]&lt;/code&gt; が最も具体的であると判断した場合、これは安全ではありません。これにより、信頼できないサードパーティ（Safe Haskellで &lt;code&gt;-XSafe&lt;/code&gt; を使用してコンパイルされた）によって記述されたコードが既存のコードの動作を変更することを防ぎます。</target>
        </trans-unit>
        <trans-unit id="43b674e690d27f945dd913940cb2232c8d90f70b" translate="yes" xml:space="preserve">
          <source>In parallel GC, the amount of balanced data copied by all threads</source>
          <target state="translated">並列GCでは、すべてのスレッドでコピーされたバランスデータの量</target>
        </trans-unit>
        <trans-unit id="a61170ee3ee14c29ceaa4174895c06c76c4573d5" translate="yes" xml:space="preserve">
          <source>In parallel GC, the max amount of data copied by any one thread. Deprecated.</source>
          <target state="translated">並列GCでは、1つのスレッドでコピーされるデータの最大量。非推奨。</target>
        </trans-unit>
        <trans-unit id="bf8ef4c6fe3834e5d04cec18ee87b3394e6f88d0" translate="yes" xml:space="preserve">
          <source>In particular GHC produces the following DWARF sections,</source>
          <target state="translated">特にGHCは、以下のようなDWARFセクションを生成します。</target>
        </trans-unit>
        <trans-unit id="ccd52b4b1f1e992bf8f459eea8eeca8d965ef594" translate="yes" xml:space="preserve">
          <source>In particular Haskell shared libraries &lt;em&gt;must&lt;/em&gt; be made into packages. You cannot freely assign which modules go in which shared libraries. The Haskell shared libraries must match the package boundaries. The reason for this is that GHC handles references to symbols &lt;em&gt;within&lt;/em&gt; the same shared library (or main executable binary) differently from references to symbols &lt;em&gt;between&lt;/em&gt; different shared libraries. GHC needs to know for each imported module if that module lives locally in the same shared lib or in a separate shared lib. The way it does this is by using packages. When using &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, a module from a separate package is assumed to come from a separate shared lib, while modules from the same package (or the default &amp;ldquo;main&amp;rdquo; package) are assumed to be within the same shared lib (or main executable binary).</source>
          <target state="translated">特にHaskell共有ライブラリ&lt;em&gt;は&lt;/em&gt;パッケージにする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。どのモジュールをどの共有ライブラリに入れるかを自由に割り当てることはできません。 Haskell共有ライブラリは、パッケージの境界と一致する必要があります。これは、GHCが同じ共有ライブラリ（またはメインの実行可能バイナリ）&lt;em&gt;内&lt;/em&gt;のシンボルへの参照を&lt;em&gt;、&lt;/em&gt;異なる共有ライブラリ&lt;em&gt;間の&lt;/em&gt;シンボルへの参照と&lt;em&gt;は&lt;/em&gt;異なる方法で処理するためです。 GHCは、インポートされたモジュールごとに、そのモジュールが同じ共有libにローカルに存在するか、別の共有libに存在するかを知る必要があります。これを行う方法は、パッケージを使用することです。&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;を使用する場合、別のパッケージのモジュールは別の共有ライブラリからのものであると見なされますが、同じパッケージ（またはデフォルトの「メイン」パッケージ）からのモジュールは同じ共有ライブラリ（またはメインの実行可能バイナリ）内にあると見なされます。</target>
        </trans-unit>
        <trans-unit id="684eca7730ca7b2ff8a385904d2e0b0bdd7e41b3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</source>
          <target state="translated">特に、 &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e1ce5ee87d506ce95263e7f934380331fec187" translate="yes" xml:space="preserve">
          <source>In particular, after inlining this will expose &lt;code&gt;f&lt;/code&gt; to the loop body directly, allowing heavy specialisation over the recursive cases.</source>
          <target state="translated">特に、これをインライン化すると、 &lt;code&gt;f&lt;/code&gt; がループ本体に直接公開されるため、再帰的なケースでの特殊化が可能になります。</target>
        </trans-unit>
        <trans-unit id="5b268bd7dbdcc411a15b5953757d10b21ca32c1a" translate="yes" xml:space="preserve">
          <source>In particular, constructors are &lt;em&gt;not&lt;/em&gt; retainers.</source>
          <target state="translated">特に、コンストラクターはリテーナーではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="078a7a8154ddbe01c2111502e8ae65f0e2be01b1" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="translated">特に、インスタンス宣言がインスタンス宣言の&lt;em&gt;先頭&lt;/em&gt;で言及されているタイプまたはクラスの定義と同じモジュールにある場合（「 &lt;code&gt;=&amp;gt;&lt;/code&gt; 」の後の部分。&lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;インスタンスコンテキストの緩和されたルールを&lt;/a&gt;参照）、GHCはとにかく、そのインターフェイスファイルにアクセスしてください。例：</target>
        </trans-unit>
        <trans-unit id="5b3a1af7fc684a7365e0b7b609a3039be3699240" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="translated">特に、 &lt;code&gt;data&lt;/code&gt; および &lt;code&gt;newtype&lt;/code&gt; 宣言では、コンストラクター引数は任意のランクの多相型である可能性があります。例を参照&lt;a href=&quot;#univ&quot;&gt;の例を&lt;/a&gt;。ただし、宣言された型は常に単相性であることに注意してください。デフォルトでは、GHCは型変数を多態型にインスタンス化しないため、これは重要です（&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;予測的多態&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d5e004af97f91f3b14786a737ee2ee1e783b46be" translate="yes" xml:space="preserve">
          <source>In particular, the &quot;bigger&quot; functions in this module (&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;) are simply the composition of a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; followed by a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; with exception safety. These only have atomicity guarantees if all other threads perform a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; before a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as well; otherwise, they may block.</source>
          <target state="translated">特に、このモジュールの「より大きな」関数（ &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; ）は、 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; に続いてputMVarを構成した &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 、例外的な安全性があります。これらは、他のすべてのスレッドが &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 前にも &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を実行する場合にのみ原子性を保証します。そうしないと、ブロックされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="15d279defc6ca20240f2cd4bd6ca078465058a78" translate="yes" xml:space="preserve">
          <source>In particular, the functions in this module obey the following law:</source>
          <target state="translated">特に、このモジュールの関数は以下の法則に従います。</target>
        </trans-unit>
        <trans-unit id="9d41d9ff0d0d0895ae2e1959850587fbcb656b74" translate="yes" xml:space="preserve">
          <source>In particular, the occurrence &lt;code&gt;VarE nm1&lt;/code&gt; refers to the binding &lt;code&gt;VarP nm1&lt;/code&gt;, and is not captured by the binding &lt;code&gt;VarP nm2&lt;/code&gt;.</source>
          <target state="translated">特に、発生 &lt;code&gt;VarE nm1&lt;/code&gt; 結合を意味 &lt;code&gt;VarP nm1&lt;/code&gt; 、及び結合によって捕捉されない &lt;code&gt;VarP nm2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e3faed30034bb62c86f00fd56d131c7714b3f69" translate="yes" xml:space="preserve">
          <source>In practice, the FFI should not be used for a task as simple as reading bytes from a &lt;code&gt;MutableByteArray#&lt;/code&gt;. Users should prefer &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; for this.</source>
          <target state="translated">実際には、FFIは、 &lt;code&gt;MutableByteArray#&lt;/code&gt; からバイトを読み取るほど単純なタスクには使用しないでください。これには、 &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1d02df75e8eea52729bdf6cd2eb9e25ca0f13738" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;#13730&lt;/a&gt;).</source>
          <target state="translated">以前のリリースでは、GHCは、バイトコードインタープリターで &lt;code&gt;unsafe&lt;/code&gt; でない呼び出しの代わりに安全 &lt;code&gt;safe&lt;/code&gt; 外部呼び出しを実行することにより、チャプターによって提供される自由を利用していました。これは、コンパイル時に機能した一部のパッケージがGHCiで失敗することを意味しました（例：&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;＃13730&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="391b2886cb4e0d3786c17223969b938c2fef5e88" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue #13730&lt;/a&gt;).</source>
          <target state="translated">以前のリリースでは、GHCは、バイトコードインタープリターで &lt;code&gt;unsafe&lt;/code&gt; でない呼び出しの代わりに安全 &lt;code&gt;safe&lt;/code&gt; 外部呼び出しを実行することにより、支部が提供する自由を利用していました。これは、コンパイル時に機能した一部のパッケージがGHCiで失敗することを意味しました（例：&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;課題＃13730&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3ff8d012302e9131b060a6becba0fe4885a49e66" translate="yes" xml:space="preserve">
          <source>In principle you can use &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; without &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; in the link step. That means to statically link the runtime system and all of the base libraries into your new shared library. This would make a very big, but standalone shared library. On most platforms however that would require all the static libraries to have been built with &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; so that the code is suitable to include into a shared library and we do not do that at the moment.</source>
          <target state="translated">原則として、リンク手順で&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;なしで&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;を使用できます。つまり、ランタイムシステムとすべての基本ライブラリを新しい共有ライブラリに静的にリンクします。これは非常に大きく、スタンドアロンの共有ライブラリになります。ただし、ほとんどのプラットフォームでは、すべての静的ライブラリが&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;でビルドされている必要があるため、コードは共有ライブラリに含めるのに適しているため、現時点では行いません。</target>
        </trans-unit>
        <trans-unit id="fd263cf5ce99e2b91836dc4e35a2d6bb18f488af" translate="yes" xml:space="preserve">
          <source>In principle, with a suitable class declaration with a functional dependency, it&amp;rsquo;s possible that this type is not ambiguous; but GHC nevertheless rejects it. The type variables mentioned in the context of the data type declaration must be among the type parameters of the data type.</source>
          <target state="translated">原則として、機能的な依存関係を持つ適切なクラス宣言があれば、この型があいまいではない可能性があります。それにもかかわらずGHCはそれを拒否します。データ型宣言のコンテキストで言及されている型変数は、データ型の型パラメーターに含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="18e2f91b13004cb3ee73758eb6c0f3436fbf8f70" translate="yes" xml:space="preserve">
          <source>In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name. For example:</source>
          <target state="translated">レコードの構築やレコードパターンのマッチングでは、たとえスコープ内に共通のフィールド名を持つ2つの異なるデータ型があったとしても、どちらのフィールドが参照されているのかは完全に不明瞭です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="026f7b4f745c03773b13fa4d11e7929e66eb04db" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">つまり、このライブラリのすべての「キャッチ」メカニズムは、&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;モジュールの関数によってスローされた例外をキャッチできず、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="c7c0b572397dc91bfdb2bb7d885052532168e385" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">つまり、このライブラリのすべての「キャッチ」メカニズムは、&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;モジュールの関数によってスローされた例外をキャッチできません。その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="934808fb13fd2c8c5cce75253dd4e268d2a4d578" translate="yes" xml:space="preserve">
          <source>In short, if you compile a module and its interface changes, then all the modules that import that interface &lt;em&gt;must&lt;/em&gt; be re-compiled.</source>
          <target state="translated">つまり、モジュールをコンパイルしてそのインターフェースを変更した場合、そのインターフェースをインポートするすべてのモジュールを再コンパイルする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f81140bb54ceba3a8d0fad4549fca0af74b151f4" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;#9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">つまり、パターンシノニムにGADTのような動作が必要な場合は、（ &lt;code&gt;S1&lt;/code&gt; のような具象データコンストラクターとは異なり）明示的に指定された等式を使用して型を記述する必要があります。 &lt;code&gt;S1&lt;/code&gt; のような具体的なデータコンストラクターの場合、型シグネチャを &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; または &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; ;のいずれかとして記述できます。2つは同等です。パターンの同義語はそうではありません。上記の2つのケースを区別するために、2つの形式は異なります。（この選択の説明については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;＃9953&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="32c8b3bf997296fa73e6193137e7fe4e16c83b1a" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;Issue #9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">つまり、パターン同義語にGADTのような動作が必要な場合は、（ &lt;code&gt;S1&lt;/code&gt; のような具体的なデータコンストラクターとは異なり）、明示的に指定された等式で型を記述する必要があります。 &lt;code&gt;S1&lt;/code&gt; のような具象データコンストラクターの場合、型シグネチャを &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; または &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; いずれかとして記述できます。2つは同等です。パターン同義語ではそうではありません。上記の2つのケースを区別するために、2つの形式は異なります。（この選択の説明については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;問題＃9953&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="c2cfc1f8c0043394ab94a925d7089c33080293c8" translate="yes" xml:space="preserve">
          <source>In short, quantifed constraints do not introduce incoherence.</source>
          <target state="translated">要するに、定量化された制約は、支離滅裂さを導入しない。</target>
        </trans-unit>
        <trans-unit id="eedb3f453802c917804d8787ef3886b3897a16d7" translate="yes" xml:space="preserve">
          <source>In short: GHC does &lt;em&gt;not&lt;/em&gt; propagate kind information from the members of a class instance declaration into the instance declaration head.</source>
          <target state="translated">つまり、GHCはクラスインスタンス宣言のメンバーからインスタンス宣言ヘッドに種類情報を伝達しませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="65fcdd4e01ef4cdb5c7448159811829c535afe34" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">いくつかのケースでは、 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; は元に戻すことができ &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; の操作を：</target>
        </trans-unit>
        <trans-unit id="b6129fb34e144fcdfe206a301e6dfcb025a1c2ff" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">いくつかのケースでは、 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; は元に戻すことができ &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; の操作を：</target>
        </trans-unit>
        <trans-unit id="7dca494ed5d22b408ce97c79a38cce42379ecc3f" translate="yes" xml:space="preserve">
          <source>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</source>
          <target state="translated">いくつかのモナドでは、アプリカティブ演算子を使用することは、モナドバインドよりも効率的です。例えば、より多くの並列処理が可能になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="7dc076e52a11bd5ce04c056123ea9f1e10b44f69" translate="yes" xml:space="preserve">
          <source>In summary, Safe Haskell consists of the following three language flags:</source>
          <target state="translated">要約すると、Safe Haskellは以下の3つの言語フラグで構成されています。</target>
        </trans-unit>
        <trans-unit id="c0610e4e2f239ff00ac0559246fa585a0148acde" translate="yes" xml:space="preserve">
          <source>In summary, given an &lt;code&gt;mdo&lt;/code&gt; expression, GHC first performs segmentation, introducing &lt;code&gt;rec&lt;/code&gt; blocks to wrap over minimal recursive groups. Then, each resulting &lt;code&gt;rec&lt;/code&gt; is desugared, using a call to &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; as described in the previous section. The original &lt;code&gt;mdo&lt;/code&gt;-expression typechecks exactly when the desugared version would do so.</source>
          <target state="translated">要約すると、 &lt;code&gt;mdo&lt;/code&gt; 式が与えられると、GHCは最初にセグメンテーションを実行し、 &lt;code&gt;rec&lt;/code&gt; ブロックを導入して最小の再帰グループをラップします。次に、前のセクションで説明したように、 &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; への呼び出しを使用して、結果の各 &lt;code&gt;rec&lt;/code&gt; がdesuga されます。元の &lt;code&gt;mdo&lt;/code&gt; -expressionは、desugaredバージョンがいつそうするかを正確に型チェックします。</target>
        </trans-unit>
        <trans-unit id="a10dd2ac36a1ae45ee7e6746793e9b0203b43531" translate="yes" xml:space="preserve">
          <source>In terms of expressivity, the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; would be sufficient for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s. The fused variants of this function are provided because they allow for more efficient implementations. Our compilers are just not smart enough yet; and for some of the employed optimizations (see the code of &lt;code&gt;encodeByteStringWithF&lt;/code&gt;) they will very likely never be.</source>
          <target state="translated">表現力の面では、機能 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; は、構築するための十分であろう &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; からSを &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 秒。この関数の融合バリアントは、より効率的な実装を可能にするために提供されています。私たちのコンパイラはまだ十分にスマートではありません。採用されている一部の最適化（ &lt;code&gt;encodeByteStringWithF&lt;/code&gt; のコードを参照）では、そうなることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="16093d6461ecbdcf12ae1c671e142ce8282ad0b5" translate="yes" xml:space="preserve">
          <source>In terms of performance, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (aka bound) threads are much more expensive than &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (aka unbound) threads, because a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread is tied to a particular OS thread, whereas a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread can be run by any OS thread. Context-switching between a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread and a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread is many times more expensive than between two &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads.</source>
          <target state="translated">パフォーマンスの面では、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; （別名バインド）スレッドは、はるかに高価よりも &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; ので、（別名結合していない）スレッド &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; のスレッドは、特定のOSスレッドに結びついているのに対し、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; のスレッドが任意のOSのスレッドで実行することができます。間のコンテキストスイッチング &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; スレッドと &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; のスレッドが2間よりも何倍も高価である &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; のスレッド。</target>
        </trans-unit>
        <trans-unit id="bce56fe3f42df3f84c1b74ed1a9d8786ce76ea2b" translate="yes" xml:space="preserve">
          <source>In terms of the underlying bit encoding, each hexadecimal digit corresponds to 4 bits, and you may think of the exponent as &amp;ldquo;moving&amp;rdquo; the floating point by one bit left (negative) or right (positive). Here are some examples:</source>
          <target state="translated">基礎となるビットエンコーディングの観点から、各16進数字は4ビットに対応し、指数は浮動小数点を1ビット左（負）または右（正）に「移動」すると考えることができます。ここではいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="85cb551cd72062b6c610a57794278c527bfd88e5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:ExitCaseSuccess&quot;&gt;ExitCaseSuccess&lt;/a&gt;&lt;/code&gt; case, the state starts at &lt;code&gt;s0&lt;/code&gt;, flows through &lt;code&gt;acquire&lt;/code&gt; to become &lt;code&gt;s1&lt;/code&gt;, flows through &lt;code&gt;use&lt;/code&gt; to become &lt;code&gt;s2&lt;/code&gt;, and finally flows through &lt;code&gt;release&lt;/code&gt; to become &lt;code&gt;s3&lt;/code&gt;. In the other two cases, &lt;code&gt;release&lt;/code&gt; does not receive the value &lt;code&gt;s2&lt;/code&gt;, so its action cannot see the state changes performed by &lt;code&gt;use&lt;/code&gt;. This is fine, because in those two cases, an error was thrown in the base monad, so as per the usual interaction between effects in a monad transformer stack, those state changes get reverted. So we start from &lt;code&gt;s1&lt;/code&gt; instead.</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:ExitCaseSuccess&quot;&gt;ExitCaseSuccess&lt;/a&gt;&lt;/code&gt; の場合、の状態が開始 &lt;code&gt;s0&lt;/code&gt; 、流れる &lt;code&gt;acquire&lt;/code&gt; なるように &lt;code&gt;s1&lt;/code&gt; 、流れる &lt;code&gt;use&lt;/code&gt; になることを &lt;code&gt;s2&lt;/code&gt; 、及び最後に流れる &lt;code&gt;release&lt;/code&gt; となるように &lt;code&gt;s3&lt;/code&gt; 。他の2つのケースでは、 &lt;code&gt;release&lt;/code&gt; は値 &lt;code&gt;s2&lt;/code&gt; を受け取らないため、そのアクションは &lt;code&gt;use&lt;/code&gt; によって実行された状態変化を確認できません。これらの2つのケースでは、ベースモナドでエラーがスローされたため、これは問題ありません。モナド変換子スタック内のエフェクト間の通常の相互作用に従って、これらの状態の変化は元に戻ります。したがって、代わりに &lt;code&gt;s1&lt;/code&gt; から開始します。</target>
        </trans-unit>
        <trans-unit id="4c29bd546b673357d6a340429155e16543ce1ef1" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 例えば、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; は一定の応用的ファンクタ（とトラバーサルと同等であるべきである &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="26bd18f823787461b100c3022f6a3b7c840dc2a6" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンス、 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 同一応用的ファンクタ（とトラバーサルと同等であるべきである &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="96a50628ee823a13660f1210d45eabd5be493de8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 例えば、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; は一定の応用的ファンクタ（とトラバーサルと同等であるべきである &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2b0439badce801cd06d5468b87c04f9c720d7a99" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンス、 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 同一応用的ファンクタ（とトラバーサルと同等であるべきである &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ca7aaa131ade1d4a8a95415db546c6e55e36ffda" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ModIface&lt;/code&gt; datatype you can find lots of useful information, including the exported definitions and type class instances.</source>
          <target state="translated">で &lt;code&gt;ModIface&lt;/code&gt; のデータ型エクスポートされた定義と型クラスのインスタンスを含む有用な情報の多くを、見つけることができます。</target>
        </trans-unit>
        <trans-unit id="c9e4b692ce0d40c03d30c364c1d3096a5795a987" translate="yes" xml:space="preserve">
          <source>In the above desugarings, the functions &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt; are all methods of the &lt;code&gt;IsList&lt;/code&gt; class, which is itself exported from the &lt;code&gt;GHC.Exts&lt;/code&gt; module. The type class is defined as follows:</source>
          <target state="translated">上記のデガリングでは、関数 &lt;code&gt;toList&lt;/code&gt; 、 &lt;code&gt;fromList&lt;/code&gt; 、 &lt;code&gt;fromListN&lt;/code&gt; はすべて &lt;code&gt;IsList&lt;/code&gt; クラスのメソッドであり、それ自体が &lt;code&gt;GHC.Exts&lt;/code&gt; モジュールからエクスポートされます。タイプクラスは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="4825ce73481d56bef5ff3baeddca3bd6b9d29055" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt; の呼び出しで、 &lt;code&gt;digs&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、値は完全な精度で表示されます。 &lt;code&gt;digs&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; の場合、小数点以下最大 &lt;code&gt;d&lt;/code&gt; 桁が表示されます。</target>
        </trans-unit>
        <trans-unit id="a51c3b2c73eac013b9c52be99faf3b0167ac1d7a" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt; の呼び出しで、 &lt;code&gt;digs&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、値は完全な精度で表示されます。 &lt;code&gt;digs&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; の場合、小数点以下最大 &lt;code&gt;d&lt;/code&gt; 桁が表示されます。</target>
        </trans-unit>
        <trans-unit id="20f3428ed1923f90f0f3d4207a60933c2d70d92e" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt; の呼び出しで、 &lt;code&gt;digs&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; の場合、値は完全な精度で表示されます。 &lt;code&gt;digs&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; の場合、小数点以下最大 &lt;code&gt;d&lt;/code&gt; 桁が表示されます。</target>
        </trans-unit>
        <trans-unit id="faf271f3b7e45777b426c7cffb5c33694e0dd460" translate="yes" xml:space="preserve">
          <source>In the caret diagnostics, there is currently no inheritance at all between &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;fatal&lt;/code&gt;.</source>
          <target state="translated">キャレット診断では、現在、 &lt;code&gt;margin&lt;/code&gt; 、 &lt;code&gt;warning&lt;/code&gt; 、 &lt;code&gt;error&lt;/code&gt; 、および &lt;code&gt;fatal&lt;/code&gt; の間の継承はまったくありません。</target>
        </trans-unit>
        <trans-unit id="df6b03ed8eec1645f1ec33aca8ebc6b982b543ce" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, we append the encodings of the two subcomponents:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; の場合、2つのサブコンポーネントのエンコーディングを追加します。</target>
        </trans-unit>
        <trans-unit id="a978f8a308124dfc5a94e8b84169bed1e73065cf" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, we produce &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; depending on whether the constructor of the value provided is located on the left or on the right:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; の場合、指定された値のコンストラクターが左側にあるか右側にあるかに応じて、 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="ce418c4b3f9c3b015c79b89b8c9bc6967c098d2d" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; は、2項演算子、開始値（通常は演算子の左ID）、およびリストに適用されると、2項演算子を使用してリストを左から右に削減します。</target>
        </trans-unit>
        <trans-unit id="402a6cba8bb6099d8590be06c5b33a8b61bcddf5" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; は、2項演算子、開始値（通常は演算子の右ID）、およびリストに適用されると、2項演算子を使用してリストを右から左に減らします。</target>
        </trans-unit>
        <trans-unit id="685a71a3a3feec5434325876c2b1603c04dc1092" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; は、2項演算子、開始値（通常は演算子の左ID）、およびリストに適用されると、2項演算子を使用してリストを左から右に削減します。</target>
        </trans-unit>
        <trans-unit id="736cf45d430966ca499dea036acc85e2fd726f3c" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; は、2項演算子、開始値（通常は演算子の右ID）、およびリストに適用されると、2項演算子を使用してリストを右から左に減らします。</target>
        </trans-unit>
        <trans-unit id="d2c4ff0ca5914473682d3bb850acf33cf8e28c10" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; は、2項演算子、開始値（通常は演算子の左ID）、およびリストに適用されると、2項演算子を使用してリストを左から右に削減します。</target>
        </trans-unit>
        <trans-unit id="814e67cd70bc9b16fbc05fe331eda86206bb01d8" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">リストの場合、 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; は、2項演算子、開始値（通常は演算子の右ID）、およびリストに適用されると、2項演算子を使用してリストを右から左に減らします。</target>
        </trans-unit>
        <trans-unit id="9d49a0dc9233f8cd0bbb34abc56b57be8989f4d7" translate="yes" xml:space="preserve">
          <source>In the case of transform comprehensions, notice that the groups are parameterised over some arbitrary type &lt;code&gt;n&lt;/code&gt; (provided it has an &lt;code&gt;fmap&lt;/code&gt;, as well as the comprehension being over an arbitrary monad.</source>
          <target state="translated">変換内包の場合、グループが任意のタイプ &lt;code&gt;n&lt;/code&gt; でパラメーター化されていることに注意してください（ &lt;code&gt;fmap&lt;/code&gt; があり、内包が任意のモナド上にある場合）。</target>
        </trans-unit>
        <trans-unit id="3a3ec5fd8ab5dd582ca482ba430b56b04ee9d354" translate="yes" xml:space="preserve">
          <source>In the case where a module is compiled without one of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; being used, GHC will try to figure out itself if the module can be considered safe. This safety inference will never mark a module as trustworthy, only as either unsafe or as safe. GHC uses a simple method to determine this for a module M: If M would compile without error under the &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag, then M is marked as safe. Otherwise, it is marked as unsafe.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; のいずれ&lt;/a&gt;も使用せずにモジュールがコンパイルされた場合、GHCはモジュールが安全であると見なせるかどうかを判断しようとします。この安全性の推論は、モジュールを信頼できるものとしてマークすることはなく、安全でないか安全であるかのいずれかです。 GHCは単純な方法を使用して、モジュールMに対してこれを決定します。Mが&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;フラグの下でエラーなしにコンパイルされる場合、Mは安全とマークされます。それ以外の場合は、安全でないとマークされます。</target>
        </trans-unit>
        <trans-unit id="bef7088bfdbcf4a4161af79eaa7b29eb8e585121" translate="yes" xml:space="preserve">
          <source>In the case where all the type variables in the pattern type signature are already in scope (i.e. bound by the enclosing context), matters are simple: the signature simply constrains the type of the pattern in the obvious way.</source>
          <target state="translated">パターンの型シグネチャ内のすべての型変数がすでにスコープ内にある場合(つまり、囲まれたコンテキストにバインドされている場合)、問題は単純です:シグネチャは単に明白な方法でパターンの型を制約します。</target>
        </trans-unit>
        <trans-unit id="dd7dd4c533ac4dfdb79170f8873e9bdd1a07434d" translate="yes" xml:space="preserve">
          <source>In the class declaration, nothing constrains the kind of the type &lt;code&gt;a&lt;/code&gt;, so it becomes a poly-kinded type variable &lt;code&gt;(a :: k)&lt;/code&gt;. Yet, in the instance declaration, the right-hand side of the associated type instance &lt;code&gt;b -&amp;gt; b&lt;/code&gt; says that &lt;code&gt;b&lt;/code&gt; must be of kind &lt;code&gt;Type&lt;/code&gt;. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind &lt;code&gt;Type&lt;/code&gt;, as opposed to types of any kind. However, GHC does &lt;em&gt;not&lt;/em&gt; do this.</source>
          <target state="translated">クラス宣言では、タイプ &lt;code&gt;a&lt;/code&gt; の種類を制約するものは何もないため、多種類のタイプ変数 &lt;code&gt;(a :: k)&lt;/code&gt; ます。しかし、インスタンス宣言では、関連付けられた型インスタンス &lt;code&gt;b -&amp;gt; b&lt;/code&gt; の右側は、 &lt;code&gt;b&lt;/code&gt; の &lt;code&gt;Type&lt;/code&gt; なければならないことを示しています。理論的には、GHCはこの情報をインスタンスヘッドに伝播し、そのインスタンス宣言を、任意の種類の型ではなく、種類 &lt;code&gt;Type&lt;/code&gt; にのみ適用することができます。ただし、GHCは&lt;em&gt;これを&lt;/em&gt;行いませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1ea0fe630422f6fbaa324604dd0d23443b8c3800" translate="yes" xml:space="preserve">
          <source>In the common case where &lt;code&gt;CProv&lt;/code&gt; is empty, (i.e., &lt;code&gt;()&lt;/code&gt;), it can be omitted altogether in the above pattern type signature for &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CProv&lt;/code&gt; が空の場合（つまり &lt;code&gt;()&lt;/code&gt; ）の一般的なケースでは、上記の &lt;code&gt;P&lt;/code&gt; のパターン型シグネチャで完全に省略できます。</target>
        </trans-unit>
        <trans-unit id="738595723a083effce19571c75a1705b54ce2cd0" translate="yes" xml:space="preserve">
          <source>In the current GHC implementation, the call stack is only available if the program was compiled with &lt;code&gt;-prof&lt;/code&gt;; otherwise &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; behaves exactly like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;. Entries in the call stack correspond to &lt;code&gt;SCC&lt;/code&gt; annotations, so it is a good idea to use &lt;code&gt;-fprof-auto&lt;/code&gt; or &lt;code&gt;-fprof-auto-calls&lt;/code&gt; to add SCC annotations automatically.</source>
          <target state="translated">現在のGHC実装では、プログラムが &lt;code&gt;-prof&lt;/code&gt; でコンパイルされた場合にのみ、コールスタックを使用できます。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; とまったく同じように動作します。コールスタックのエントリは &lt;code&gt;SCC&lt;/code&gt; 注釈に対応するため、 &lt;code&gt;-fprof-auto&lt;/code&gt; または &lt;code&gt;-fprof-auto-calls&lt;/code&gt; を使用してSCC注釈を自動的に追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="acbdce2c4062331f2c3f39e4ae942c4efb63986d" translate="yes" xml:space="preserve">
          <source>In the definition for &lt;code&gt;F&lt;/code&gt;, the two equations are incompatible &amp;ndash; their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type &lt;code&gt;F a&lt;/code&gt; does not simplify; only a type such as &lt;code&gt;F Double&lt;/code&gt; will simplify to &lt;code&gt;Char&lt;/code&gt;. In &lt;code&gt;G&lt;/code&gt;, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, &lt;code&gt;G a&lt;/code&gt; will simplify to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; の定義では、2つの方程式に互換性がありません。それらのパターンはばらばらではありませんが、右辺は一致していません。したがって、GHCが2番目の方程式を選択する前に、最初の方程式が適用されないようにする必要があります。したがって、型 &lt;code&gt;F a&lt;/code&gt; は単純化されません。 &lt;code&gt;F Double&lt;/code&gt; などのタイプのみが &lt;code&gt;Char&lt;/code&gt; に簡略化されます。 &lt;code&gt;G&lt;/code&gt; 、一方、二つの式は、互換性があります。したがって、GHCは2番目の方程式を見るときに最初の方程式を無視できます。したがって、 &lt;code&gt;G a&lt;/code&gt; はに単純化され &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="846c20df94f9314fa1fe586ab3d9172b13b606cb" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;gmapQ&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; combinators, we use phantom type constructors for the &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; because the result type of a query does not involve the (polymorphic) type of the term argument. In the definition of &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; we simply use the plain constant type constructor because &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is left-associative anyway and so it is readily suited to fold a left-associative binary operation over the immediate subterms. In the definition of gmapQr, extra effort is needed. We use a higher-order accumulation trick to mediate between left-associative constructor application vs. right-associative binary operation (e.g., &lt;code&gt;(:)&lt;/code&gt;). When the query is meant to compute a value of type &lt;code&gt;r&lt;/code&gt;, then the result type withing generic folding is &lt;code&gt;r -&amp;gt; r&lt;/code&gt;. So the result of folding is a function to which we finally pass the right unit.</source>
          <target state="translated">&lt;code&gt;gmapQ&lt;/code&gt; &lt;em&gt;x&lt;/em&gt;コンビネーターの定義では、クエリの結果の型は（多形）型の項引数を含まないため、 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; の型の &lt;code&gt;c&lt;/code&gt; にファントム型コンストラクターを使用します。 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; の定義では、単純な定数型コンストラクターを使用します。 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; は、gfoldlがいずれも左結合であり、左結合バイナリ演算を直接のサブタームに折り畳むのに適しているためです。 gmapQrの定義では、追加の作業が必要です。高次の累積トリックを使用して、左結合コンストラクターアプリケーションと右結合バイナリ演算（たとえば、 &lt;code&gt;(:)&lt;/code&gt; を仲介します。）。クエリがタイプ &lt;code&gt;r&lt;/code&gt; の値を計算することを意図している場合、ジェネリックフォールディングを使用した結果のタイプは &lt;code&gt;r -&amp;gt; r&lt;/code&gt; です。したがって、フォールディングの結果は、最終的に正しいユニットを渡す関数になります。</target>
        </trans-unit>
        <trans-unit id="172ded5aaf2bf60400ff8b3fbe797e04c36dee1c" translate="yes" xml:space="preserve">
          <source>In the degenerate case where all the alternatives have zero width, such as the &lt;code&gt;Bool&lt;/code&gt;-like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt;, the unboxed sum layout only has an &lt;code&gt;Int32&lt;/code&gt; tag field (i.e., the whole thing is represented by an integer).</source>
          <target state="translated">&lt;code&gt;Bool&lt;/code&gt; のような &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt; ように、すべての選択肢の幅がゼロの縮退した場合、ボックス化されていない合計レイアウトには &lt;code&gt;Int32&lt;/code&gt; タグフィールドしかありません（つまり、全体が表されます）整数で）。</target>
        </trans-unit>
        <trans-unit id="eae7ddef52aa6d501f88a9704bbcc99c4b28932e" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ドキュメントでは、\（n \）はリスト内の要素の数、\（d \）はリスト内の個別の要素の数です。\（W \）は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のビット数です。</target>
        </trans-unit>
        <trans-unit id="f0778e8d7eb2efc83b2b32dc144b880b32c199c0" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ドキュメントでは、\（n \）はリスト内の要素の数であり、\（d \）はリスト内の個別の要素の数です。\（W \）は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のビット数です。</target>
        </trans-unit>
        <trans-unit id="f8410efb81dbdeacb0d6540b0e647a317447ad44" translate="yes" xml:space="preserve">
          <source>In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of &lt;code&gt;main()&lt;/code&gt; at link-time, you will have to. To signal that to the compiler when linking, use &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">別の（Haskell以外の）プログラムの一部としてghcでコンパイルされたコードを含めたい場合、RTSはリンク時に &lt;code&gt;main()&lt;/code&gt; の定義を提供しないため、そうする必要があります。リンク時にそれをコンパイラーに通知するには、 &lt;code&gt;-no-hs-main&lt;/code&gt; を使用します。&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;独自のmain（）の使用&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="d261a91a10cc118ec325a4c82debf0de9dec298f" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;Danger&lt;/code&gt; can import module &lt;code&gt;RIO&lt;/code&gt; because &lt;code&gt;RIO&lt;/code&gt; is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;Danger&lt;/code&gt; can make use of the &lt;code&gt;rioReadFile&lt;/code&gt; and &lt;code&gt;rioWriteFile&lt;/code&gt; functions to access permitted file names. The main application then imports both &lt;code&gt;RIO&lt;/code&gt; and &lt;code&gt;Danger&lt;/code&gt;. To run the plugin, it calls &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. The application is safe in the knowledge that the only &lt;code&gt;IO&lt;/code&gt; to ensue will be to files whose paths were approved by the &lt;code&gt;pathOK&lt;/code&gt; test.</source>
          <target state="translated">この例では、 &lt;code&gt;RIO&lt;/code&gt; が&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;でコンパイルされているため、 &lt;code&gt;Danger&lt;/code&gt; はモジュール &lt;code&gt;RIO&lt;/code&gt; をインポートできます。したがって、 &lt;code&gt;Danger&lt;/code&gt; を利用することができ &lt;code&gt;rioReadFile&lt;/code&gt; と &lt;code&gt;rioWriteFile&lt;/code&gt; ファイル名を許可されたアクセスに機能を。次に、メインアプリケーションは &lt;code&gt;RIO&lt;/code&gt; と &lt;code&gt;Danger&lt;/code&gt; の両方をインポートします。プラグインを実行するために、 &lt;code&gt;IO&lt;/code&gt; モナド内で &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; を呼び出します。パス &lt;code&gt;pathOK&lt;/code&gt; テストによってパスが承認されたファイルへの &lt;code&gt;IO&lt;/code&gt; のみが続くことを知っているため、アプリケーションは安全です。</target>
        </trans-unit>
        <trans-unit id="04e6cf746c3b3e5d963876bd4cd89448b3120476" translate="yes" xml:space="preserve">
          <source>In the examples above, all promoted constructors are prefixed with a single quote mark &lt;code&gt;'&lt;/code&gt;. This mark tells GHC to look in the data constructor namespace for a name, not the type (constructor) namespace. Consider</source>
          <target state="translated">上記の例では、昇格したすべてのコンストラクタの前に単一引用符 &lt;code&gt;'&lt;/code&gt; が付いています。このマークは、タイプ（コンストラクター）ネームスペースではなく、データコンストラクターネームスペースで名前を探すようにGHCに指示します。検討する</target>
        </trans-unit>
        <trans-unit id="40ee1ceda8e59fc5b01c325869581e1e58fcdd95" translate="yes" xml:space="preserve">
          <source>In the first application of &lt;code&gt;f&lt;/code&gt;, we had to do some more type reconstruction in order to recover the result type of &lt;code&gt;f&lt;/code&gt;. But after that, we are free to use &lt;code&gt;f&lt;/code&gt; normally.</source>
          <target state="translated">最初のアプリケーションでは &lt;code&gt;f&lt;/code&gt; 、我々は結果の型回復するためにいくつかのより多くの種類の再構築をしなければならなかった &lt;code&gt;f&lt;/code&gt; 。ただし、その後は通常どおり &lt;code&gt;f&lt;/code&gt; を自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="149193862750cd07d67aa98378a43e7fa5bcd8bc" translate="yes" xml:space="preserve">
          <source>In the first example above, &lt;code&gt;_x&lt;/code&gt; is generalised over (and is effectively replaced by a fresh type variable &lt;code&gt;a&lt;/code&gt;). In the second example, &lt;code&gt;_x&lt;/code&gt; is unified with the &lt;code&gt;Bool&lt;/code&gt; type, and as &lt;code&gt;Bool&lt;/code&gt; implements the &lt;code&gt;Show&lt;/code&gt; type class, the constraint &lt;code&gt;Show Bool&lt;/code&gt; can be simplified away.</source>
          <target state="translated">上記の最初の例では、 &lt;code&gt;_x&lt;/code&gt; が一般化されています（そして、新しいタイプの変数 &lt;code&gt;a&lt;/code&gt; によって事実上置き換えられています）。第2の例では、 &lt;code&gt;_x&lt;/code&gt; を用いて統一された &lt;code&gt;Bool&lt;/code&gt; 型、として &lt;code&gt;Bool&lt;/code&gt; 実装 &lt;code&gt;Show&lt;/code&gt; タイプのクラスは、制約 &lt;code&gt;Show Bool&lt;/code&gt; 離れて簡略化することができます。</target>
        </trans-unit>
        <trans-unit id="5c6ea9d39cdb3d6f149abc95c32c55d1e377bfe4" translate="yes" xml:space="preserve">
          <source>In the first example, the kind variable &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;invisible&lt;/em&gt; argument to &lt;code&gt;ProxyKInvis&lt;/code&gt;. In other words, a user does not need to instantiate &lt;code&gt;k&lt;/code&gt; explicitly, as kind inference automatically determines what &lt;code&gt;k&lt;/code&gt; should be. For instance, in &lt;code&gt;ProxyKInvis True&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; is inferred to be &lt;code&gt;Bool&lt;/code&gt;. This is reflected in the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;:</source>
          <target state="translated">最初の例では、種類変数 &lt;code&gt;k&lt;/code&gt; がある&lt;em&gt;不可視&lt;/em&gt;の引数 &lt;code&gt;ProxyKInvis&lt;/code&gt; 。言い換えると、種類の推論によって &lt;code&gt;k&lt;/code&gt; がどうあるべきかが自動的に決定されるため、ユーザーは &lt;code&gt;k&lt;/code&gt; を明示的にインスタンス化する必要はありません。たとえば、 &lt;code&gt;ProxyKInvis True&lt;/code&gt; では、 &lt;code&gt;k&lt;/code&gt; は &lt;code&gt;Bool&lt;/code&gt; であると推測されます。これは、 &lt;code&gt;ProxyKInvis&lt;/code&gt; の種類に反映されています。</target>
        </trans-unit>
        <trans-unit id="a4e49151ec338f81e6976a10a88331d5852242bf" translate="yes" xml:space="preserve">
          <source>In the following, &amp;ldquo;Haskell file&amp;rdquo; is the main output (usually a &lt;code&gt;.hs&lt;/code&gt; file), &amp;ldquo;compiled Haskell file&amp;rdquo; is the Haskell file after &lt;code&gt;ghc&lt;/code&gt; has compiled it to C (i.e. a &lt;code&gt;.hc&lt;/code&gt; file), &amp;ldquo;C program&amp;rdquo; is the program that outputs the Haskell file, &amp;ldquo;C file&amp;rdquo; is the optionally generated C file, and &amp;ldquo;C header&amp;rdquo; is its header file.</source>
          <target state="translated">以下では、「Haskellファイル」がメイン出力（通常は &lt;code&gt;.hs&lt;/code&gt; ファイル）、「コンパイルされたHaskellファイル」は &lt;code&gt;ghc&lt;/code&gt; がC（つまり &lt;code&gt;.hc&lt;/code&gt; ファイル）にコンパイルした後のHaskellファイル、「Cプログラム」はHaskellファイルを出力するプログラム、「Cファイル」はオプションで生成されるCファイル、「Cヘッダー」はそのヘッダーファイルです。</target>
        </trans-unit>
        <trans-unit id="dc1456dc1bb5376e50df9356963ec4ad4e2b367b" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;h&lt;/code&gt; we use the record selectors &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; to extract the polymorphic bind and return functions from the &lt;code&gt;MonadT&lt;/code&gt; data structure, rather than using pattern matching.</source>
          <target state="translated">関数 &lt;code&gt;h&lt;/code&gt; では、パターンマッチングを使用するのではなく、レコードセレクターの &lt;code&gt;return&lt;/code&gt; および &lt;code&gt;bind&lt;/code&gt; を使用して、 &lt;code&gt;MonadT&lt;/code&gt; データ構造から多態性バインドおよびリターン関数を抽出します。</target>
        </trans-unit>
        <trans-unit id="3c2ee3eafdcad4b683c78d591fee52c85b813144" translate="yes" xml:space="preserve">
          <source>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</source>
          <target state="translated">将来的には、GHC はマニフェストファイルを使用して、依存する DLL の場所を提供するなど、より多くのことに使用するかもしれません。</target>
        </trans-unit>
        <trans-unit id="8c26d49122d64dd0270b09c279fadaf85a7e889c" translate="yes" xml:space="preserve">
          <source>In the last line, we use the promoted constructor &lt;code&gt;'MkCompose&lt;/code&gt;, which has kind</source>
          <target state="translated">最後の行では、我々は昇格コンストラクタ使う &lt;code&gt;'MkCompose&lt;/code&gt; 種類があり、</target>
        </trans-unit>
        <trans-unit id="6ea81a9e9ab238a60258241f86c06e46f72fec13" translate="yes" xml:space="preserve">
          <source>In the last section we saw that besides a name, a &lt;code&gt;CoreDoPluginPass&lt;/code&gt; takes a pass of type &lt;code&gt;PluginPass&lt;/code&gt;. A &lt;code&gt;PluginPass&lt;/code&gt; is a synonym for &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;. &lt;code&gt;ModGuts&lt;/code&gt; is a type that represents the one module being compiled by GHC at any given time.</source>
          <target state="translated">前のセクションで、名前のほかに、 &lt;code&gt;CoreDoPluginPass&lt;/code&gt; が &lt;code&gt;PluginPass&lt;/code&gt; タイプのパスを取得することを確認しました。A &lt;code&gt;PluginPass&lt;/code&gt; はシノニムです &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; 。 &lt;code&gt;ModGuts&lt;/code&gt; は、GHCによって常にコンパイルされている1つのモジュールを表す型です。</target>
        </trans-unit>
        <trans-unit id="e7151264545101799acf59e7b7e571c55db95bd2" translate="yes" xml:space="preserve">
          <source>In the light of the overlap decision, instance lookup works like this when trying to solve a class constraint &lt;code&gt;C t&lt;/code&gt;</source>
          <target state="translated">重複の決定に照らして、クラスの制約 &lt;code&gt;C t&lt;/code&gt; を解決しようとすると、インスタンスルックアップは次のように機能します。</target>
        </trans-unit>
        <trans-unit id="53eb63bc56e230d6466f7d38014cd8cc4cf52862" translate="yes" xml:space="preserve">
          <source>In the messages from the compiler, we see that there is no line for &lt;code&gt;D&lt;/code&gt;. This is because it isn&amp;rsquo;t necessary to compile &lt;code&gt;D&lt;/code&gt;, because the source and everything it depends on is unchanged since the last compilation.</source>
          <target state="translated">コンパイラーからのメッセージで、 &lt;code&gt;D&lt;/code&gt; の行がないことがわかります。これは、 &lt;code&gt;D&lt;/code&gt; をコンパイルする必要がないためです。これは、ソースとそれが依存するすべてのものが前回のコンパイル以降変更されていないためです。</target>
        </trans-unit>
        <trans-unit id="ddeb2139081c601845dbe769a075fe10d73419d8" translate="yes" xml:space="preserve">
          <source>In the olden days, GHC compared the newly-generated &lt;code&gt;.hi&lt;/code&gt; file with the previous version; if they were identical, it left the old one alone and didn&amp;rsquo;t change its modification date. In consequence, importers of a module with an unchanged output &lt;code&gt;.hi&lt;/code&gt; file were not recompiled.</source>
          <target state="translated">昔、GHCは新しく生成された &lt;code&gt;.hi&lt;/code&gt; ファイルを以前のバージョンと比較しました。それらが同一である場合は、古いものをそのままにし、変更日を変更しませんでした。その結果、出力の &lt;code&gt;.hi&lt;/code&gt; ファイルが変更されていないモジュールのインポーターは再コンパイルされませんでした。</target>
        </trans-unit>
        <trans-unit id="374581211f11803a65e2cf204f4183e85b4fceb6" translate="yes" xml:space="preserve">
          <source>In the output above, observe that &lt;code&gt;T&lt;/code&gt; has two kind variables (&lt;code&gt;k&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt;) and two type variables (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;). Note that &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;inferred&lt;/em&gt; variable and &lt;code&gt;l&lt;/code&gt; is a &lt;em&gt;specified&lt;/em&gt; variable (see &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so as a result, they are displayed using slightly different syntax in the type &lt;code&gt;T @{k} @l a b&lt;/code&gt;. The application of &lt;code&gt;l&lt;/code&gt; (with &lt;code&gt;@l&lt;/code&gt;) is the standard syntax for visible type application (see &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). The application of &lt;code&gt;k&lt;/code&gt; (with &lt;code&gt;@{k}&lt;/code&gt;), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">上記の出力では、 &lt;code&gt;T&lt;/code&gt; に2つの種類の変数（ &lt;code&gt;k&lt;/code&gt; と &lt;code&gt;l&lt;/code&gt; ）と2つの型の変数（ &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; ）があることに注意してください。そのノート &lt;code&gt;k&lt;/code&gt; がある&lt;em&gt;推論&lt;/em&gt;変数と &lt;code&gt;l&lt;/code&gt; がある&lt;em&gt;指定された&lt;/em&gt;変数（参照&lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;型変数指定推論対を&lt;/a&gt;型にわずかに異なる構文を使用して、その結果、それらが表示される） &lt;code&gt;T @{k} @l a b&lt;/code&gt; 。 &lt;code&gt;l&lt;/code&gt; の適用（ &lt;code&gt;@l&lt;/code&gt; を使用）は、可視型アプリケーションの標準構文です（&lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;可視型アプリケーションを&lt;/a&gt;参照）。 &lt;code&gt;k&lt;/code&gt; の適用（ &lt;code&gt;@{k}&lt;/code&gt; ）は、しかしながら、推論された型変数の可視型アプリケーションに対して仮説的な構文を使用します。この構文は現在プログラマーには公開されていませんが、&lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;が有効になっている場合は表示されます。</target>
        </trans-unit>
        <trans-unit id="0a5a27aca496c351b26fd16433d9f2aacedebfda" translate="yes" xml:space="preserve">
          <source>In the paper and the previous implementation, values on the stack were paired to the right of the environment in a single argument, but now the environment and stack are separate arguments.</source>
          <target state="translated">論文や以前の実装では、スタック上の値は1つの引数で環境の右側にペアリングされていましたが、環境とスタックは別の引数になりました。</target>
        </trans-unit>
        <trans-unit id="e4a4ad8ff9e2ea2640cf5cde3b222326c4f733bc" translate="yes" xml:space="preserve">
          <source>In the previous example, we used a conditional expression to construct the input for an arrow. Sometimes we want to conditionally execute different commands, as in</source>
          <target state="translated">前の例では、条件式を使用して矢印の入力を構築しました。次のように、条件付きで異なるコマンドを実行したい場合もあります。</target>
        </trans-unit>
        <trans-unit id="53458cc6655e7a520b6f10bf393f2ad481ee4cd4" translate="yes" xml:space="preserve">
          <source>In the second declaration, GHC cannot immediately tell that &lt;code&gt;k&lt;/code&gt; should be a dependent variable, and so the declaration is rejected.</source>
          <target state="translated">2番目の宣言では、GHCは &lt;code&gt;k&lt;/code&gt; が従属変数でなければならないことをすぐに伝えることができないため、宣言は拒否されます。</target>
        </trans-unit>
        <trans-unit id="e04af78973d3e47e134276ff85a7f3c652f7d13c" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;visible&lt;/em&gt; argument to &lt;code&gt;ProxyKVis&lt;/code&gt;. That is to say, &lt;code&gt;k&lt;/code&gt; is an argument that users must provide explicitly when applying &lt;code&gt;ProxyKVis&lt;/code&gt;. For example, &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; is a well formed type.</source>
          <target state="translated">2番目の例では、 &lt;code&gt;k&lt;/code&gt; は &lt;code&gt;ProxyKVis&lt;/code&gt; に対する&lt;em&gt;目に見える&lt;/em&gt;引数です。つまり、 &lt;code&gt;k&lt;/code&gt; は、 &lt;code&gt;ProxyKVis&lt;/code&gt; を適用するときにユーザーが明示的に指定する必要がある引数です。たとえば、 &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; 式の型です。</target>
        </trans-unit>
        <trans-unit id="55addee8e051e63bec155782732ce1d09c9a2858" translate="yes" xml:space="preserve">
          <source>In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</source>
          <target state="translated">前項の単純なケースでは、指定された変数が左から右の順に現れると言えます。しかし、すべてのケースがそう単純なわけではありません。ここでは、より微妙なケースでのルールを紹介します。</target>
        </trans-unit>
        <trans-unit id="97b005cab59c28efe19b8404620d4586fb6285f7" translate="yes" xml:space="preserve">
          <source>In the threaded and SMP versions of the RTS (see &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), a major GC is automatically performed if the runtime has been idle (no Haskell computation has been running) for a period of time. The amount of idle time which must pass before a GC is performed is set by the &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; option. Specifying &lt;code&gt;-I0&lt;/code&gt; disables the idle GC.</source>
          <target state="translated">RTSのスレッドバージョンとSMPバージョン（&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;、「リンクに&lt;a href=&quot;phases#options-linker&quot;&gt;影響するオプション」を&lt;/a&gt;参照）では、ランタイムが一定期間アイドル状態（Haskell計算が実行されていない）である場合、メジャーGCが自動的に実行されます。GCが実行される前に経過しなければならないアイドル時間は、 &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; オプションによって設定されます。 &lt;code&gt;-I0&lt;/code&gt; を指定すると、アイドルGCが無効になります。</target>
        </trans-unit>
        <trans-unit id="1694137a8ab9fbad9a236c803a20b15d21740e1f" translate="yes" xml:space="preserve">
          <source>In the unification check in the final bullet, GHC also uses the &amp;ldquo;in-scope given constraints&amp;rdquo;. Consider for example</source>
          <target state="translated">最後の箇条書きの統一チェックでは、GHCは「範囲内の所定の制約」も使用します。例を考えます</target>
        </trans-unit>
        <trans-unit id="588a44eae37ca5b1dac65821d0d9f7a7a8542d81" translate="yes" xml:space="preserve">
          <source>In the unlikely case that modifier characters of some kind are desirable for a user-provided type, a &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; can be provided to process these characters. The resulting modifiers will appear in the &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; for use by the type-specific formatter.</source>
          <target state="translated">ある種の修飾文字がユーザー指定のタイプに望ましいというまれなケースでは、これらの文字を処理するために &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; を提供できます。結果の修飾子は、 &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; で使用するためにFieldFormatに表示されます。</target>
        </trans-unit>
        <trans-unit id="2ad711240568f9303ca209fe831d40e7c3af2733" translate="yes" xml:space="preserve">
          <source>In theory, this mechanism allows arbitrary data to be roundtripped via a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with no loss of data. In practice, there are two limitations to be aware of:</source>
          <target state="translated">理論的には、このメカニズムにより、データを失うことなく、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を介して任意のデータをラウンドトリップできます。実際には、注意すべき2つの制限があります。</target>
        </trans-unit>
        <trans-unit id="23cb01df08dfcb7824b863fc014f5bf29ea5fc79" translate="yes" xml:space="preserve">
          <source>In this case the derived instance declaration is of the form</source>
          <target state="translated">この場合、派生インスタンス宣言は次のような形式になります。</target>
        </trans-unit>
        <trans-unit id="71a288fd8d8656887893d68ab53108d408b426c0" translate="yes" xml:space="preserve">
          <source>In this case the kind parameter &lt;code&gt;k&lt;/code&gt; is actually an implicit parameter of the type family.</source>
          <target state="translated">この場合、種類パラメーター &lt;code&gt;k&lt;/code&gt; は実際にはタイプファミリーの暗黙的なパラメーターです。</target>
        </trans-unit>
        <trans-unit id="1458f3d45d7cf8add3f964f47bf5c04fad0f65f0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ cannot be used in expressions, only patterns, since it wouldn&amp;rsquo;t specify a value for the ⟨xs⟩ on the right-hand side. However, we can define an explicitly bidirectional pattern synonym by separately specifying how to construct and deconstruct a type. The syntax for doing this is as follows:</source>
          <target state="translated">この場合、 &lt;code&gt;Head&lt;/code&gt; が右側に⟨xs⟩の値を指定しないので⟨x⟩は、式、パターンのみで使用することができません。ただし、型の構築方法と分解方法を個別に指定することで、明示的に双方向パターンの同義語を定義できます。これを行うための構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a0936edcab6b0c6b0eac6247ce8f47c52daa2c9a" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;g&lt;/code&gt; is desugared to</source>
          <target state="translated">この場合、 &lt;code&gt;g&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="46b676aa5c3c6fb868cf3f9cd7c077e91b44b610" translate="yes" xml:space="preserve">
          <source>In this case, the child thread will receive a &lt;code&gt;NonTermination&lt;/code&gt; exception instead of waiting for the value of &lt;code&gt;r&lt;/code&gt; to be computed.</source>
          <target state="translated">この場合、子スレッドは、 &lt;code&gt;r&lt;/code&gt; の値が計算されるのを待つのではなく、 &lt;code&gt;NonTermination&lt;/code&gt; 例外を受け取ります。</target>
        </trans-unit>
        <trans-unit id="2cd24087d75374f112a445bc71400a6456c492b4" translate="yes" xml:space="preserve">
          <source>In this case, we could not simply bind &lt;code&gt;k&lt;/code&gt; on the left-hand side, as &lt;code&gt;k&lt;/code&gt; would become a &lt;em&gt;visible&lt;/em&gt; parameter:</source>
          <target state="translated">この場合、 &lt;code&gt;k&lt;/code&gt; が&lt;em&gt;目に見える&lt;/em&gt;パラメータになるため、左側で &lt;code&gt;k&lt;/code&gt; を単純にバインドすることはできません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cc674153a787afcfa95c57ed93cc3673880fbe" translate="yes" xml:space="preserve">
          <source>In this case, we were able to do this with &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;, but operations with more complex types require special lifting functions, which are provided by monad transformers for which they can be implemented. If you use the monad classes of the &lt;code&gt;mtl&lt;/code&gt; package or similar, this lifting is handled automatically by the instances of the classes, and you need only use the generalized methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">この場合、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; を使用してこれを行うことができましたが、より複雑なタイプの操作には、実装可能なモナド変換器によって提供される特別なリフティング関数が必要です。 &lt;code&gt;mtl&lt;/code&gt; パッケージなどのモナドクラスを使用する場合、このリフティングはクラスのインスタンスによって自動的に処理され、一般化されたメソッド &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;put&lt;/code&gt; のみを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7bb4a09f269488c7395d0751f14e5beb2db506fc" translate="yes" xml:space="preserve">
          <source>In this chapter you&amp;rsquo;ll find a complete reference to the GHC command-line syntax, including all 400+ flags. It&amp;rsquo;s a large and complex system, and there are lots of details, so it can be quite hard to figure out how to get started. With that in mind, this introductory section provides a quick introduction to the basic usage of GHC for compiling a Haskell program, before the following sections dive into the full syntax.</source>
          <target state="translated">この章では、すべての400以上のフラグを含む、GHCコマンドライン構文の完全なリファレンスを見つけます。これは大きくて複雑なシステムであり、詳細がたくさんあるため、開始方法を理解するのは非常に難しい場合があります。このことを念頭に置いて、この紹介セクションでは、HaskellプログラムをコンパイルするためのGHCの基本的な使用法を簡単に紹介してから、次のセクションで完全な構文を説明します。</target>
        </trans-unit>
        <trans-unit id="a4cb88a5dbcf9e66af97ada60f7fc8018cc84f7c" translate="yes" xml:space="preserve">
          <source>In this code, once we pass the initial check for an empty list we know that in the recursive case this pattern match is redundant. As such &lt;code&gt;-fspec-constr&lt;/code&gt; will transform the above code to:</source>
          <target state="translated">このコードでは、空のリストの初期チェックに合格すると、再帰的なケースでは、このパターンマッチは冗長であることがわかります。そのため、 &lt;code&gt;-fspec-constr&lt;/code&gt; は上記のコードを次のように変換します。</target>
        </trans-unit>
        <trans-unit id="b4c5c94cfab7bea6a279520afd17cf54b4f5145f" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;Reader&lt;/code&gt; monad provides access to variable bindings. Bindings are a &lt;code&gt;Map&lt;/code&gt; of integer variables. The variable &lt;code&gt;count&lt;/code&gt; contains number of variables in the bindings. You can see how to run a Reader monad and retrieve data from it with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt;, how to access the Reader data with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;Reader&lt;/code&gt; モナドは変数バインディングへのアクセスを提供します。バインディングは整数変数の &lt;code&gt;Map&lt;/code&gt; です。変数 &lt;code&gt;count&lt;/code&gt; には、バインディング内の変数の数が含まれています。 Readerモナドを実行し、 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt; でそこからデータを取得する方法、 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt; でリーダーデータにアクセスする方法を確認できます。</target>
        </trans-unit>
        <trans-unit id="5b2208e92b48546b397d55cc261960cb8033549a" translate="yes" xml:space="preserve">
          <source>In this example we use the operations &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;, which are defined only for monads that are applications of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. Alternatively one could use monad classes from the &lt;code&gt;mtl&lt;/code&gt; package or similar, which contain methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; with types generalized over all suitable monads.</source>
          <target state="translated">この例では、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; のアプリケーションであるモナドに対してのみ定義されている&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;からの操作 &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;put&lt;/code&gt; を使用します。別の方法として、 &lt;code&gt;mtl&lt;/code&gt; パッケージなどのモナドクラスを使用することもできます。これには、適切なモナドすべてに対して一般化された型で &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;put&lt;/code&gt; メソッドが含まれます。</target>
        </trans-unit>
        <trans-unit id="22ae5ddc301afbf76db451d6ae86206a63cdb84b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt; depends on &lt;code&gt;a&lt;/code&gt;. Even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">この例では、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; に依存し &lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; はaに依存します。にもかかわらず、字句の前に表示されます &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; ため、最初に定量化されているに依存し &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; 。さらに、 &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; は、依存条件に違反しない場合でも、相互に並べ替えられないことに注意してください。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3ac2fd6e175d918e681db807d09bc0d9cfd7a0f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;op&lt;/code&gt; is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of &lt;code&gt;op&lt;/code&gt;-used-at-type-Bool to a specialised function, say &lt;code&gt;opBool&lt;/code&gt;, where</source>
          <target state="translated">この例では、 &lt;code&gt;op&lt;/code&gt; は通常のトップレベル関数ではありません。これはクラスメソッドです。GHCは、 &lt;code&gt;op&lt;/code&gt; -used-at-type-Boolの出現を特殊な関数（ &lt;code&gt;opBool&lt;/code&gt; など）にすばやく書き換えます。</target>
        </trans-unit>
        <trans-unit id="a54c35f64a11f9102b446b75a06ab15997039209" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside&amp;hellip;</source>
          <target state="translated">この例では、内部の &lt;code&gt;reify&lt;/code&gt; &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="144a6001279409b5fe23e336fea6b41236a7436a" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside...</source>
          <target state="translated">この例では、内部を &lt;code&gt;reify&lt;/code&gt; します...</target>
        </trans-unit>
        <trans-unit id="d1ca7b6071a21a43da3a7e5ebc0b51fe9aa62cd1" translate="yes" xml:space="preserve">
          <source>In this example, all of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are considered kind variables and will always be placed before &lt;code&gt;b&lt;/code&gt;, a lowly type variable. (Note that &lt;code&gt;a&lt;/code&gt; is used in &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind.) Yet, even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">この例では &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; 、および &lt;code&gt;k&lt;/code&gt; はすべて種類変数と見なされ、常に型の低い変数である &lt;code&gt;b&lt;/code&gt; の前に配置されます。 （注意ことに使用される &lt;code&gt;b&lt;/code&gt; 種類の。）しかし、にもかかわらず前字句表示 &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; ため、最初の定量化に依存して &lt;code&gt;j&lt;/code&gt; 及び &lt;code&gt;k&lt;/code&gt; 。さらに、依存関係の条件に違反しない場合でも、 &lt;code&gt;j&lt;/code&gt; と &lt;code&gt;k&lt;/code&gt; は互いに対して並べ替えられないことに注意してください。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea70ba4f788151f3c14bd89916938adefd9dddbc" translate="yes" xml:space="preserve">
          <source>In this example, the declaration has only one variant. In general, it can be any number.</source>
          <target state="translated">この例では、宣言は1つの変種だけを持っています。一般的には、任意の数にすることができます。</target>
        </trans-unit>
        <trans-unit id="c73dc37636c8cb640cf041df73293ff0e50794dc" translate="yes" xml:space="preserve">
          <source>In this example, the list &lt;code&gt;output&lt;/code&gt; would take on the value:</source>
          <target state="translated">この例では、リスト &lt;code&gt;output&lt;/code&gt; は次の値を取ります。</target>
        </trans-unit>
        <trans-unit id="0477cc1de77b96d2dcbf9d8cc1e8fbeac11cb261" translate="yes" xml:space="preserve">
          <source>In this example, we inspect all available details of the compiled source code. We don&amp;rsquo;t change any of the representation, but write out the details to the standard output. The pretty printed representation of the parsed, renamed and type checked syntax tree will be in the output as well as the evaluated splices and quasi quotes. The name of the interfaces that are loaded will also be displayed.</source>
          <target state="translated">この例では、コンパイルされたソースコードのすべての利用可能な詳細を検査します。表現は一切変更しませんが、詳細を標準出力に書き出します。構文解析され、名前が変更され、タイプがチェックされた構文ツリーのきれいに印刷された表現が、評価されたスプライスと準引用符と同様に出力に含まれます。ロードされているインターフェースの名前も表示されます。</target>
        </trans-unit>
        <trans-unit id="ce7a808f73475173c84b4a7d49aa6676ec3a0955" translate="yes" xml:space="preserve">
          <source>In this example, you cannot say &lt;code&gt;... deriving( Show )&lt;/code&gt; on the data type declaration for &lt;code&gt;T&lt;/code&gt;, because &lt;code&gt;T&lt;/code&gt; is a GADT, but you &lt;em&gt;can&lt;/em&gt; generate the instance declaration using stand-alone deriving.</source>
          <target state="translated">この例では、 &lt;code&gt;T&lt;/code&gt; はGADTであるため、 &lt;code&gt;T&lt;/code&gt; のデータ型宣言で &lt;code&gt;... deriving( Show )&lt;/code&gt; とは言えませんが、スタンドアロンの派生を使用してインスタンス宣言を生成&lt;em&gt;でき&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af62a3290de70aad01a1a52e1391134fd1bf6e1e" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;.</source>
          <target state="translated">このモードでは、GHCはマルチモジュールのHaskellプログラムを自動的に構築し、それ自体の依存関係を把握します。単純なHaskellプログラムがある場合、これは&lt;strong&gt;make&lt;/strong&gt;を使用&lt;strong&gt;する&lt;/strong&gt;よりもはるかに簡単で高速です。makeモードについては、&lt;a href=&quot;#make-mode&quot;&gt;ghc -makeの使用&lt;/a&gt;で説明しています。</target>
        </trans-unit>
        <trans-unit id="05b4a3b6689dfdb162bbf16479c4e6487fd716f8" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;.</source>
          <target state="translated">このモードでは、GHCはマルチモジュールHaskellプログラムを自動的に構築し、それ自体の依存関係を把握します。単純なHaskellプログラムを使用している場合、これは&lt;strong&gt;make&lt;/strong&gt;を使用&lt;strong&gt;する&lt;/strong&gt;よりもはるかに簡単で高速になる可能性があります。メイクモードについては、&lt;a href=&quot;#make-mode&quot;&gt;ghc--makeの使用&lt;/a&gt;で説明しています。</target>
        </trans-unit>
        <trans-unit id="14b5fc6a536a1554868646b6ca60e10360d30c4b" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program by following dependencies from one or more root modules (usually just &lt;code&gt;Main&lt;/code&gt;). For example, if your &lt;code&gt;Main&lt;/code&gt; module is in a file called &lt;code&gt;Main.hs&lt;/code&gt;, you could compile and link the program like this:</source>
          <target state="translated">このモードでは、GHCは1つ以上のルートモジュール（通常は &lt;code&gt;Main&lt;/code&gt; のみ）からの依存関係に従ってマルチモジュールHaskellプログラムを構築します。たとえば、 &lt;code&gt;Main&lt;/code&gt; モジュールが &lt;code&gt;Main.hs&lt;/code&gt; というファイルにある場合、次のようにプログラムをコンパイルしてリンクできます。</target>
        </trans-unit>
        <trans-unit id="28db988427b635ef091ce5edd09284a3efe60154" translate="yes" xml:space="preserve">
          <source>In this notation floating point numbers are written using hexadecimal digits, and so the digits are interpreted using base 16, rather then the usual 10. This means that digits left of the decimal point correspond to positive powers of 16, while the ones to the right correspond to negative ones.</source>
          <target state="translated">この表記法では、浮動小数点数は16進数で書かれているため、数字は通常の10ではなく16進数で解釈されます。これは、小数点以下の桁が16の正の桁に対応し、右側の桁が負の桁に対応することを意味します。</target>
        </trans-unit>
        <trans-unit id="1625565ac67aff08f4fe4a675ec370d8a1444409" translate="yes" xml:space="preserve">
          <source>In this redefinition, we give an explicit kind for &lt;code&gt;(:~~:)&lt;/code&gt;, deferring the choice of &lt;code&gt;k2&lt;/code&gt; until after the first argument (&lt;code&gt;a&lt;/code&gt;) has been given. With this declaration for &lt;code&gt;(:~~:)&lt;/code&gt;, the instance for &lt;code&gt;HTestEquality&lt;/code&gt; is accepted.</source>
          <target state="translated">この再定義では、 &lt;code&gt;(:~~:)&lt;/code&gt; に明示的な種類を与え、最初の引数（ &lt;code&gt;a&lt;/code&gt; ）が与えられるまで &lt;code&gt;k2&lt;/code&gt; の選択を延期します。 &lt;code&gt;(:~~:)&lt;/code&gt; この宣言により、 &lt;code&gt;HTestEquality&lt;/code&gt; のインスタンスが受け入れられます。</target>
        </trans-unit>
        <trans-unit id="241d07916ab9a1a491c806d2158cdc7962a6343f" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is lazy, so that for example the following produces a usable result:</source>
          <target state="translated">このバージョンでは、計算の順序付けが遅延しているため、例えば以下のように使用可能な結果が得られます。</target>
        </trans-unit>
        <trans-unit id="c84b399cd2cbed2ef45d9909f32f6700a23e3816" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">このバージョンでは、計算の順序付けは厳密です（ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; などで強制しない限り、状態の計算は厳密ではありません）。同じインターフェースを持つ遅延バージョンについては、&lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazyを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="733a7b8597e3bea6d79329500059b7357f9f04c9" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">このバージョンでは、計算の順序付けは厳密です（ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; などで強制しない限り、状態では計算は厳密ではありません）。同じインターフェースを持つレイジーバージョンについては、&lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazyを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2d6a029dcaf77ff2149eaa82e23825caa41a60b1" translate="yes" xml:space="preserve">
          <source>In type errors, also print type-synonym-expanded types.</source>
          <target state="translated">型エラーでは、型代名詞が拡張された型も表示します。</target>
        </trans-unit>
        <trans-unit id="9cdca6bb9120edae790472f128bdcd1be571c545" translate="yes" xml:space="preserve">
          <source>In types, an operator symbol like &lt;code&gt;(+)&lt;/code&gt; is normally treated as a type &lt;em&gt;variable&lt;/em&gt;, just like &lt;code&gt;a&lt;/code&gt;. Thus in Haskell 98 you can say</source>
          <target state="translated">タイプでは、のような演算子記号 &lt;code&gt;(+)&lt;/code&gt; は、通常、タイプとして扱われる&lt;em&gt;変数&lt;/em&gt;と同じように、。したがって、Haskell 98では次のように言うことができます &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65afe3f89d89dfa50d619b7bc79e59801641ec08" translate="yes" xml:space="preserve">
          <source>In typical use cases it can be imported alongside &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;, e.g.</source>
          <target state="translated">通常の使用例では、&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;と一緒にインポートできます。</target>
        </trans-unit>
        <trans-unit id="d1e5195c56fb5f6cf6fae4475985c40c8b88fe88" translate="yes" xml:space="preserve">
          <source>In your program, you import a module &lt;code&gt;Foo&lt;/code&gt; by saying &lt;code&gt;import Foo&lt;/code&gt;. In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, GHC will look for a source file for &lt;code&gt;Foo&lt;/code&gt; and arrange to compile it first. Without &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, GHC will look for the interface file for &lt;code&gt;Foo&lt;/code&gt;, which should have been created by an earlier compilation of &lt;code&gt;Foo&lt;/code&gt;. GHC uses the same strategy in each of these cases for finding the appropriate file.</source>
          <target state="translated">プログラムでは、 &lt;code&gt;import Foo&lt;/code&gt; と言ってモジュール &lt;code&gt;Foo&lt;/code&gt; をインポートします。で&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;モードまたはGHCiの、GHCは、ソースファイルを探します &lt;code&gt;Foo&lt;/code&gt; と最初にそれをコンパイルする手配します。&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; を使用し&lt;/a&gt;ない場合、GHCは &lt;code&gt;Foo&lt;/code&gt; のインターフェースファイルを検索します。これは、 &lt;code&gt;Foo&lt;/code&gt; の以前のコンパイルで作成されているはずです。GHCは、適切なファイルを見つけるために、これらの各ケースで同じ戦略を使用します。</target>
        </trans-unit>
        <trans-unit id="e6fb0b72e73092b08131513da6dffeda9e5d2c1b" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current output history on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">新しいモナドへの &lt;code&gt;callCC&lt;/code&gt; 操作のその場解除。このバージョンでは、継続の入力時に現在の出力履歴を使用します。均一性プロパティを満たしていません（&lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signaturesを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ed82252f8ef32e515385822c367b97c16dae701f" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation.</source>
          <target state="translated">新しいモナドへの &lt;code&gt;callCC&lt;/code&gt; 操作のその場解除。このバージョンでは、継続の開始時に現在の状態を使用します。</target>
        </trans-unit>
        <trans-unit id="6a76bfe845d96c79100211ad66d5be912f9bcb9e" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">新しいモナドへの &lt;code&gt;callCC&lt;/code&gt; 操作のその場解除。このバージョンでは、継続の開始時に現在の状態を使用します。均一性プロパティを満たしていません（&lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signaturesを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0bc346f91d9ddc5a0ccbe414514a097c0e2ae594" translate="yes" xml:space="preserve">
          <source>InappropriateType</source>
          <target state="translated">InappropriateType</target>
        </trans-unit>
        <trans-unit id="491a2c5d60825a9925b3d9a2ec49e95b47e7f9c8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples or sums.</source>
          <target state="translated">ちなみに、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;がGHCiと互換性がないという前のポイントは、バイトコードコンパイラがボックス化されていないタプルまたは合計を処理できないためです。</target>
        </trans-unit>
        <trans-unit id="fc5a86ec622c5d2ce4a51514213ff5193a71f6e8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples.</source>
          <target state="translated">ちなみに、前述の&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;はGHCiと互換性がないというのは、バイトコードコンパイラがボックス化されていないタプルを処理できないためです。</target>
        </trans-unit>
        <trans-unit id="04035088cec19a7e2a3af045cabd4c24b2d47171" translate="yes" xml:space="preserve">
          <source>Include preprocessor dependencies</source>
          <target state="translated">プリプロセッサの依存関係を含める</target>
        </trans-unit>
        <trans-unit id="ac7ecb7c530843411667d62a790e5a78d07bb31e" translate="yes" xml:space="preserve">
          <source>Include the memory occupied by threads in a heap profile. Each thread takes up a small area for its thread state in addition to the space allocated for its stack (stacks normally start small and then grow as necessary).</source>
          <target state="translated">スレッドが占有するメモリをヒーププロファイルに含めます。各スレッドは、スタックに割り当てられた領域に加えて、スレッドの状態を表す小さな領域を占有します (スタックは通常小さく始まり、必要に応じて大きくなります)。</target>
        </trans-unit>
        <trans-unit id="bf6b5e91451bcaf207fe546e25dfb945b2ef9008" translate="yes" xml:space="preserve">
          <source>Incoherent</source>
          <target state="translated">Incoherent</target>
        </trans-unit>
        <trans-unit id="b38b4aae2bf24bfd05e072f52c00b63da2993ab0" translate="yes" xml:space="preserve">
          <source>IncoherentInstances</source>
          <target state="translated">IncoherentInstances</target>
        </trans-unit>
        <trans-unit id="c456a08558be1da87f0db1872fa8594cdebf4bc0" translate="yes" xml:space="preserve">
          <source>Incompatibilities between closed type family equations can be displayed in &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; &lt;/a&gt;が有効になっている場合、閉じた型族の方程式間の非互換性を&lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;に表示できます。</target>
        </trans-unit>
        <trans-unit id="835b6be9a8a369d9816b32613c73aac90a0d27dc" translate="yes" xml:space="preserve">
          <source>Increases the precedence context by one.</source>
          <target state="translated">優先順位のコンテキストを1つ増やします。</target>
        </trans-unit>
        <trans-unit id="9fce6bc4b7e5c5a1ab1bd960ce68b81905da42d1" translate="yes" xml:space="preserve">
          <source>Increasing the allocation area size may or may not give better performance (a bigger allocation area means worse cache behaviour but fewer garbage collections and less promotion).</source>
          <target state="translated">割り当て領域のサイズを大きくするとパフォーマンスが向上するかもしれません(割り当て領域が大きくなるとキャッシュの挙動が悪くなりますが、ガベージコレクションの数が減り、プロモーションが少なくなります)。</target>
        </trans-unit>
        <trans-unit id="90bbbaecf2c42b5555ebc1a33319be6fd0d0626c" translate="yes" xml:space="preserve">
          <source>Increasing this figure is more likely to result in longer compile times than faster code. The &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is more useful.</source>
          <target state="translated">この数値を大きくすると、高速なコードよりもコンパイル時間が長くなる可能性が高くなります。&lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt;より有用です。</target>
        </trans-unit>
        <trans-unit id="4f85c1ee822e61bcfb4fe66d19d113d5f463b45b" translate="yes" xml:space="preserve">
          <source>Incremental array updates</source>
          <target state="translated">配列のインクリメンタル更新</target>
        </trans-unit>
        <trans-unit id="df1b72108d080551ba84e7f0b92fa55056537617" translate="yes" xml:space="preserve">
          <source>Increments the column number of a source position.</source>
          <target state="translated">ソース位置のカラム番号を増加させます。</target>
        </trans-unit>
        <trans-unit id="e41e0acce642a9a1ccc70291606c4bb9e436f67f" translate="yes" xml:space="preserve">
          <source>Increments the line number of a source position.</source>
          <target state="translated">ソース位置の行数を増加させます。</target>
        </trans-unit>
        <trans-unit id="3b6b076780f1d62948deeee6a296d893d53b3592" translate="yes" xml:space="preserve">
          <source>Indeed, the bindings can even be recursive.</source>
          <target state="translated">実際、バインディングは再帰的なものであっても構いません。</target>
        </trans-unit>
        <trans-unit id="96dc8cbd171c88cf2266f42fcde1d0fd90902e1c" translate="yes" xml:space="preserve">
          <source>Indeed, we can even set breakpoints,</source>
          <target state="translated">実際、ブレークポイントを設定することもできます。</target>
        </trans-unit>
        <trans-unit id="ec8be4828bc680f1764ecad7e8b3a8f6a6c5c173" translate="yes" xml:space="preserve">
          <source>Indexed</source>
          <target state="translated">Indexed</target>
        </trans-unit>
        <trans-unit id="06793fabc8f42b418a1cb6b931583c1a10698618" translate="yes" xml:space="preserve">
          <source>Indexed data families are introduced by a signature, such as</source>
          <target state="translated">インデックス化されたデータファミリは、以下のようなシグネチャによって導入されます。</target>
        </trans-unit>
        <trans-unit id="35f58c1b9b260f98cfc78bcd3803628ca7e2f859" translate="yes" xml:space="preserve">
          <source>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</source>
          <target state="translated">インデックス付き型ファミリには、データファミリ、オープン型シノニムファミリ、クローズド型シノニムファミリの3つのフレーバーがあります。これらはそれぞれ代数的なデータ型と型同義語のインデックス付きファミリーの亜種です。データファミリーのインスタンスはデータ型とnewtypesである。</target>
        </trans-unit>
        <trans-unit id="d12b44f71b7203449d4ead8607709958c3027d75" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">インデックス付きの型ファミリーは、型レベルのプログラミングを容易にする拡張機能を形成します。タイプファミリーは、関連するデータタイプ&lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt;および関連するタイプの同義語&lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]の&lt;/a&gt;一般化です。タイプファミリー自体は、Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]で&lt;/a&gt;説明されています。タイプファミリーは基本的に、タイプインデックス付きのデータタイプとタイプの名前付き関数を提供します。これらは、ジェネリックプログラミングや高度にパラメーター化されたライブラリインターフェイス、および依存型のように拡張された静的情報を持つインターフェイスに役立ちます。これらは、関数の依存関係の代替と見なすこともできますが、関数の依存関係のリレーショナルスタイルよりも、タイプレベルのプログラミングの機能的なスタイルを提供します。</target>
        </trans-unit>
        <trans-unit id="c623b2752a83108ab46f6eab2be4ef5e8f114c82" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">インデックス付きタイプファミリは、タイプレベルのプログラミングを容易にする拡張機能を形成します。型族は、関連するデータ型&lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt;と関連する型同義語&lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]の&lt;/a&gt;一般化です。型族自体は、Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]で&lt;/a&gt;説明されています。型族は基本的に、型インデックス付きのデータ型と型の名前付き関数を提供します。これらは、ジェネリックプログラミングや高度にパラメーター化されたライブラリインターフェイス、および依存型と同様に拡張された静的情報を持つインターフェイスに役立ちます。これらは、関数従属性の代替と見なされる場合もありますが、関数従属性のリレーショナルスタイルよりもタイプレベルのプログラミングのより機能的なスタイルを提供します。</target>
        </trans-unit>
        <trans-unit id="7316d5d3f19bb830a24f91422d22cdab9dd77e21" translate="yes" xml:space="preserve">
          <source>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</source>
          <target state="translated">インデックス付き型ファミリ(略して型ファミリ)は、型の集合を表す型コンストラクタです。セットのメンバは、型ファミリのコンストラクタに型パラメータを与えることで表されます。バニラのパラメトリック型コンストラクタとファミリコンストラクタの違いは,パラメトリック多相関数と型クラスの(その場しのぎの)メソッドの違いによく似ています.パラメトリック多相関数はすべての型インスタンスで同じ振る舞いをしますが、クラスメソッドはクラスの型パラメータに依存して振る舞いを変えることができます。同様に、バニラ型のコンストラクタは、すべての型インスタンスで同じデータ表現を意味しますが、ファミリ型のコンストラクタは、型インデックスの変化に応じて表現タイプを変化させることができます。</target>
        </trans-unit>
        <trans-unit id="b949d0cdd6e23a0ad23263d4ec380e2896eb8d8b" translate="yes" xml:space="preserve">
          <source>IndexedQueue</source>
          <target state="translated">IndexedQueue</target>
        </trans-unit>
        <trans-unit id="8fa14decb45552b922c2f1e05a96dc53620208d3" translate="yes" xml:space="preserve">
          <source>IndexedTaggedQueue</source>
          <target state="translated">IndexedTaggedQueue</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="e8487b7ebf53e6a4c89fb11a42e40edb17475681" translate="yes" xml:space="preserve">
          <source>Indexing ByteStrings</source>
          <target state="translated">ByteStringsのインデックス作成</target>
        </trans-unit>
        <trans-unit id="a877b32121d14e603604359d2ca06dd6d1231f86" translate="yes" xml:space="preserve">
          <source>Indexing lists</source>
          <target state="translated">インデキシングリスト</target>
        </trans-unit>
        <trans-unit id="10dea83b6d35fb66236376830ee8aaca1d2aa47d" translate="yes" xml:space="preserve">
          <source>Indexing streams</source>
          <target state="translated">インデキシングストリーム</target>
        </trans-unit>
        <trans-unit id="9d4cf9835a874b031aa2556ce944d3dfd7d3212c" translate="yes" xml:space="preserve">
          <source>Indexing with predicates</source>
          <target state="translated">述語を使った索引付け</target>
        </trans-unit>
        <trans-unit id="7bb8fb7fdc165fa4b18dff47b53df0d3155ddd63" translate="yes" xml:space="preserve">
          <source>Indicates a mode in which a file should be locked.</source>
          <target state="translated">ファイルをロックするモードを示します。</target>
        </trans-unit>
        <trans-unit id="3355b10b90f7375e78f86318065481808ee2eee6" translate="yes" xml:space="preserve">
          <source>Indicates an &quot;alternate format&quot;. See &lt;code&gt;printf(3)&lt;/code&gt; for the details, which vary by argument spec.</source>
          <target state="translated">「代替フォーマット」を示します。参照 &lt;code&gt;printf(3)&lt;/code&gt; 引数の仕様により異なります詳細については、を。</target>
        </trans-unit>
        <trans-unit id="ee701376e3689ff56e8540e626710f8190183f54" translate="yes" xml:space="preserve">
          <source>Indicates that this RunTH is finished, and the next message will be the result of RunTH (a QResult).</source>
          <target state="translated">このRunTHが終了し、次のメッセージがRunTHの結果(QResult)であることを示します。</target>
        </trans-unit>
        <trans-unit id="ffebd8440073e88e499e1336894f2e16eae1751e" translate="yes" xml:space="preserve">
          <source>Indirections include the two special directories &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;, as well as any symbolic links (and junction points on Windows). The input path need not point to an existing file or directory. Canonicalization is performed on the longest prefix of the path that points to an existing file or directory. The remaining portion of the path that does not point to an existing file or directory will still be normalized, but case canonicalization and indirection removal are skipped as they are impossible to do on a nonexistent path.</source>
          <target state="translated">間接参照には、2つの特別なディレクトリが含まれます &lt;code&gt;.&lt;/code&gt; および &lt;code&gt;..&lt;/code&gt; 、およびすべてのシンボリックリンク（およびWindowsのジャンクションポイント）。入力パスは、既存のファイルまたはディレクトリを指す必要はありません。正規化は、既存のファイルまたはディレクトリを指すパスの最長プレフィックスで実行されます。既存のファイルまたはディレクトリを指していないパスの残りの部分は正規化されますが、存在しないパスでは実行できないため、ケースの正規化と間接削除はスキップされます。</target>
        </trans-unit>
        <trans-unit id="66db8a5a7f44af7446c06e6455194d161c7318dd" translate="yes" xml:space="preserve">
          <source>Individual fields of constructors: &lt;code&gt;K1&lt;/code&gt;</source>
          <target state="translated">コンストラクタの個々のフィールド： &lt;code&gt;K1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004823746d749da477fecffe53c215cee2dcb8f7" translate="yes" xml:space="preserve">
          <source>Infer less polymorphic types for local bindings by default.</source>
          <target state="translated">デフォルトでは、ローカルバインディングの多相型を少なくします。</target>
        </trans-unit>
        <trans-unit id="a49aa56d23bf8a67723b80736f57bcc1ae0f7ed4" translate="yes" xml:space="preserve">
          <source>InferR</source>
          <target state="translated">InferR</target>
        </trans-unit>
        <trans-unit id="b62fa7fe203f750a1b3935b720b00e4d542210bf" translate="yes" xml:space="preserve">
          <source>Inferring equality from other types</source>
          <target state="translated">他のタイプからの平等性の推論</target>
        </trans-unit>
        <trans-unit id="3744a97e602ea3666eb2a1e01050a64e4445a1a1" translate="yes" xml:space="preserve">
          <source>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as &lt;code&gt;Either Int&lt;/code&gt;. In fact, &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt;&lt;code&gt;:kind&lt;/code&gt;&lt;/a&gt; even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</source>
          <target state="translated">「タイプ」の種類を推測して出力します。後者は、 &lt;code&gt;Either Int&lt;/code&gt; などの型コンストラクターの部分的な適用を含む、任意の型式にすることができます。実際、&lt;a href=&quot;#ghci-cmd-:kind&quot;&gt; &lt;code&gt;:kind&lt;/code&gt; &lt;/a&gt;を使用すると、型シノニムの部分的なアプリケーション（通常は許可されない）を作成できるため、次のように機能します。</target>
        </trans-unit>
        <trans-unit id="3177c8b6010228311525b74fd82e8bb7622e8e6c" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">「式」のタイプを推測して出力しますが、タイプ変数やクラス制約をいじる必要はありません。これは、&lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;を使用していて、指定された型変数（型アプリケーションで利用可能）と推論された型変数（利用不可）の違いに注意する場合に役立ちます。このモードは、すぐに解決できる制約（ &lt;code&gt;Show Int&lt;/code&gt; など）を出力することがありますが、これらの制約を解決すると型変数に影響する可能性があるため、GHCは控えます。</target>
        </trans-unit>
        <trans-unit id="8a06b410b4c6d06c8f15b06ce8d7dbe7ce974ec5" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (&lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, or &lt;code&gt;Traversable&lt;/code&gt;), the constrained type variable(s) are defaulted according to the rules described under &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt;. This mode is quite useful when the inferred type is quite general (such as for &lt;code&gt;foldr&lt;/code&gt;) and it may be helpful to see a more concrete instantiation.</source>
          <target state="translated">「式」のタイプを推測して出力し、可能な場合はデフォルトのタイプ変数を使用します。このモードでは、推論された型がインタラクティブクラス（ &lt;code&gt;Num&lt;/code&gt; 、 &lt;code&gt;Show&lt;/code&gt; 、 &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Foldable&lt;/code&gt; 、または &lt;code&gt;Traversable&lt;/code&gt; ）によって制約されている場合、制約された型の変数は、&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; で&lt;/a&gt;説明されているルールに従ってデフォルト設定されます。このモードは、推論されたタイプが非常に一般的な場合（ &lt;code&gt;foldr&lt;/code&gt; など）に非常に役立ち、より具体的なインスタンス化を確認すると役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="9b49ea1e8603da8d3ed4f7b29043ab1b859d18a2" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</source>
          <target state="translated">多相型のための明示的なforall量詞を含む、⟨式⟩の型を推定して表示します。報告される型は、式に代入された変数に対して推論される型ですが、単相性制限が適用されていません。</target>
        </trans-unit>
        <trans-unit id="89ab60251bc6707c53f48175ddc8665e44956e1a" translate="yes" xml:space="preserve">
          <source>Infinite ByteStrings</source>
          <target state="translated">無限バイト文字列</target>
        </trans-unit>
        <trans-unit id="f1a0caa9cda260897b3d3a8a3366456b3f12604b" translate="yes" xml:space="preserve">
          <source>Infinite lists</source>
          <target state="translated">無限リスト</target>
        </trans-unit>
        <trans-unit id="fe77bd8489f76d5d9e8b67c97bcc2fb77aac9380" translate="yes" xml:space="preserve">
          <source>Infix</source>
          <target state="translated">Infix</target>
        </trans-unit>
        <trans-unit id="dc17702bd4456d8936d032b3557ed49fb5376c40" translate="yes" xml:space="preserve">
          <source>InfixL</source>
          <target state="translated">InfixL</target>
        </trans-unit>
        <trans-unit id="20413b58a0ca7cb9b7575983b614a1c19ab4ff77" translate="yes" xml:space="preserve">
          <source>InfixN</source>
          <target state="translated">InfixN</target>
        </trans-unit>
        <trans-unit id="028e6ce7a43f27e4616aed257c32e084ad147516" translate="yes" xml:space="preserve">
          <source>InfixR</source>
          <target state="translated">InfixR</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="83ca07e3694e10dbb5ccf3a65b2e15a2aa71adaa" translate="yes" xml:space="preserve">
          <source>InfoQ</source>
          <target state="translated">InfoQ</target>
        </trans-unit>
        <trans-unit id="ce6a0a5b544415ee768925ccfd3225f374bbf9b6" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;Strict&lt;/code&gt; language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding &lt;code&gt;~&lt;/code&gt; in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding &lt;code&gt;!&lt;/code&gt; in front of a variable.</source>
          <target state="translated">非公式に、 &lt;code&gt;Strict&lt;/code&gt; 言語拡張機能は、デフォルトで関数、データ型、バインディングを厳密に切り替え、変数の前に &lt;code&gt;~&lt;/code&gt; を追加することでオプションの遅延を許可します。これは基本的に、遅延がデフォルトである現在の状況を逆転させ、オプションで &lt;code&gt;!&lt;/code&gt; 変数の前。</target>
        </trans-unit>
        <trans-unit id="b7a8fe8965d2d84c47cc81ac096afe56b49210c8" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;StrictData&lt;/code&gt; language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a &lt;code&gt;~&lt;/code&gt; in front of the field.</source>
          <target state="translated">非公式に、 &lt;code&gt;StrictData&lt;/code&gt; 言語拡張機能は、デフォルトでデータ型宣言を厳密に切り替え、フィールドの前に &lt;code&gt;~&lt;/code&gt; を追加することでフィールドを遅延させることができます。</target>
        </trans-unit>
        <trans-unit id="c1d79469162855a43f3eaf9e3321d8cf50684dcb" translate="yes" xml:space="preserve">
          <source>Informally, if we have a closed expression</source>
          <target state="translated">非公式には、閉じた式があれば</target>
        </trans-unit>
        <trans-unit id="bc65f2d3fbd1ee9f583dec831481e53abb70fa26" translate="yes" xml:space="preserve">
          <source>Information Preservation</source>
          <target state="translated">情報の保存</target>
        </trans-unit>
        <trans-unit id="ccf896e081192f981240670d0e7869acc682d16d" translate="yes" xml:space="preserve">
          <source>Information about a received signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">受信信号に関する情報（ &lt;code&gt;siginfo_t&lt;/code&gt; から派生）。</target>
        </trans-unit>
        <trans-unit id="e730d579902dace90d61c30931b7c39b9b5c188a" translate="yes" xml:space="preserve">
          <source>Information about the characteristics of the host system lucky enough to run your program.</source>
          <target state="translated">プログラムを運良く実行できたホストシステムの特徴についての情報。</target>
        </trans-unit>
        <trans-unit id="97818649517ae55c8ef983801726362db33a72b7" translate="yes" xml:space="preserve">
          <source>Information about your computer.</source>
          <target state="translated">パソコンに関する情報です。</target>
        </trans-unit>
        <trans-unit id="7590d8f956e48cf87c1411168c5822d362a8880b" translate="yes" xml:space="preserve">
          <source>Information specific to a particular type of signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">特定のタイプの信号に固有の情報（ &lt;code&gt;siginfo_t&lt;/code&gt; から派生）。</target>
        </trans-unit>
        <trans-unit id="18f99833bb423f35b13b6374e87a08306b82f669" translate="yes" xml:space="preserve">
          <source>Inherit</source>
          <target state="translated">Inherit</target>
        </trans-unit>
        <trans-unit id="10a7ab6418304c704b776a62f13dc7b3f3d8190a" translate="yes" xml:space="preserve">
          <source>Inherit Handle from parent</source>
          <target state="translated">親からハンドルを継承</target>
        </trans-unit>
        <trans-unit id="131da1e4b635c2e4aa073e59724b377201ce6033" translate="yes" xml:space="preserve">
          <source>InitialQuote</source>
          <target state="translated">InitialQuote</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="468840c91f4e11363baba6fad080b835e2d90e74" translate="yes" xml:space="preserve">
          <source>Initialize a session of line-oriented user interaction.</source>
          <target state="translated">ライン指向のユーザーインタラクションのセッションを初期化します。</target>
        </trans-unit>
        <trans-unit id="79a1bd4a448da27813a2c98ec5cbdca961401161" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library to the given terminal entry.</source>
          <target state="translated">Terminfoライブラリを与えられたターミナルエントリに初期化します。</target>
        </trans-unit>
        <trans-unit id="f311d39fb45ca161e338979b5589e040c6185db3" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library, using the &lt;code&gt;TERM&lt;/code&gt; environmental variable. If &lt;code&gt;TERM&lt;/code&gt; is not set, we use the generic, minimal entry &lt;code&gt;dumb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TERM&lt;/code&gt; 環境変数を使用して、terminfoライブラリを初期化します。 &lt;code&gt;TERM&lt;/code&gt; が設定されていない場合は、汎用の最小エントリ &lt;code&gt;dumb&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="939c8fcbb3a241e55009e926ba9e9f9f130c11fc" translate="yes" xml:space="preserve">
          <source>Initializes your &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This is optional.</source>
          <target state="translated">&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; を&lt;/a&gt;初期化します。これはオプションです。</target>
        </trans-unit>
        <trans-unit id="c79f3175dc50a18ee0d2393eff10c5aa2297aaaf" translate="yes" xml:space="preserve">
          <source>Inject a value into the monadic type.</source>
          <target state="translated">モナディック型に値を注入します。</target>
        </trans-unit>
        <trans-unit id="7de60f53f52e7d4a1d23489236b528a745ebb923" translate="yes" xml:space="preserve">
          <source>Injective type families are enabled with &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; language extension. This extension implies &lt;code&gt;-XTypeFamilies&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; タイプファミリーは、-XTypeFamilyDependencies言語拡張機能で有効になります。この拡張機能は &lt;code&gt;-XTypeFamilies&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="3800191eed005fd216c850a6af16770c6198afc5" translate="yes" xml:space="preserve">
          <source>Injectivity annotation</source>
          <target state="translated">インジェクティビティのアノテーション</target>
        </trans-unit>
        <trans-unit id="20740ccc0ccfa9620154536bb90e4481418a8cde" translate="yes" xml:space="preserve">
          <source>Injectivity annotation is added after type family head and consists of two parts:</source>
          <target state="translated">射影性アノテーションは、ファミリーヘッド型の後に追加され、2つの部分から構成されています。</target>
        </trans-unit>
        <trans-unit id="5ce4a424681e8e8d4af68879e4d178e19578aaeb" translate="yes" xml:space="preserve">
          <source>InjectivityAnn</source>
          <target state="translated">InjectivityAnn</target>
        </trans-unit>
        <trans-unit id="70da87d6559d7f1134da3bb10fd8c978c0bbd8a1" translate="yes" xml:space="preserve">
          <source>Inlinable</source>
          <target state="translated">Inlinable</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="2cf1a81193ffc568b768198d38637e294820f553" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memcpy&lt;/code&gt; calls if they would generate no more than ⟨n⟩ pseudo-instructions.</source>
          <target state="translated">生成される疑似命令が「n」個以下の場合、インライン &lt;code&gt;memcpy&lt;/code&gt; 呼び出し。</target>
        </trans-unit>
        <trans-unit id="5455a4bec4fb43a62132e2ac05940c352abd92c6" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memset&lt;/code&gt; calls if they would generate no more than n pseudo instructions.</source>
          <target state="translated">生成する疑似命令がn以下の場合、インライン &lt;code&gt;memset&lt;/code&gt; 呼び出し。</target>
        </trans-unit>
        <trans-unit id="f455d62d020e6eddcc787a8c9c55ba1f78236d68" translate="yes" xml:space="preserve">
          <source>Input / Output</source>
          <target state="translated">入力/出力</target>
        </trans-unit>
        <trans-unit id="d395c711b92fc61b74f8c3ff68d9004aa7cb8404" translate="yes" xml:space="preserve">
          <source>Input functions</source>
          <target state="translated">入力機能</target>
        </trans-unit>
        <trans-unit id="5d1b609b532bb8aa117614c8340893874e0d56cc" translate="yes" xml:space="preserve">
          <source>Input string.</source>
          <target state="translated">入力文字列。</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">テキストを入力します。</target>
        </trans-unit>
        <trans-unit id="59f2d1955d5cf0a2b8bee3b6d9a4ed1809c129a3" translate="yes" xml:space="preserve">
          <source>InputLineLimit</source>
          <target state="translated">InputLineLimit</target>
        </trans-unit>
        <trans-unit id="a1aa2989284777e5694122e01199982258b92b20" translate="yes" xml:space="preserve">
          <source>InputQueue</source>
          <target state="translated">InputQueue</target>
        </trans-unit>
        <trans-unit id="642ac7e20b3f8a8dd831942dd30d6fb267ed8a73" translate="yes" xml:space="preserve">
          <source>InputQueueLimit</source>
          <target state="translated">InputQueueLimit</target>
        </trans-unit>
        <trans-unit id="6b355e50341a905ef45c8beb3f4a624b29b98e2e" translate="yes" xml:space="preserve">
          <source>InputState</source>
          <target state="translated">InputState</target>
        </trans-unit>
        <trans-unit id="49141e9c95b68ea8d21c96c95e556fd4e3c8b9a0" translate="yes" xml:space="preserve">
          <source>InputT</source>
          <target state="translated">InputT</target>
        </trans-unit>
        <trans-unit id="e75f30b22d5bec33bb907d8901f7fb77cde5c043" translate="yes" xml:space="preserve">
          <source>InputUnderflow</source>
          <target state="translated">InputUnderflow</target>
        </trans-unit>
        <trans-unit id="d42b1cf617b7ff4fdd4f096b44e1d83b5423c29e" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;error&lt;/code&gt; expressions after bottoming expressions; useful when debugging the compiler.</source>
          <target state="translated">ボトム式の後に &lt;code&gt;error&lt;/code&gt; 式を挿入します。コンパイラのデバッグ時に役立ちます。</target>
        </trans-unit>
        <trans-unit id="76aa707dc17cbfd229d5de411f19e42614784006" translate="yes" xml:space="preserve">
          <source>Insert a scalar at the given position in a vector.</source>
          <target state="translated">ベクトルの指定された位置にスカラを挿入します.</target>
        </trans-unit>
        <trans-unit id="6ffaeff164e1d6773f39ae8fe9bbe6e6ef734c6a" translate="yes" xml:space="preserve">
          <source>Insertion</source>
          <target state="translated">Insertion</target>
        </trans-unit>
        <trans-unit id="0fb526c25f533482f1770bd05055cb689b6470bc" translate="yes" xml:space="preserve">
          <source>Insertion/removal</source>
          <target state="translated">Insertion/removal</target>
        </trans-unit>
        <trans-unit id="33b33d75acd9bccbdc63b02e3a1b9e48f6928c65" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;内では、他のフラグ設定に関係なく、「 &lt;code&gt;forall&lt;/code&gt; 」はキーワードとして扱われます。さらに、&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;内では、言語拡張&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;が自動的に有効になります。&lt;a href=&quot;#scoped-type-variables&quot;&gt;字句スコープの型変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3de0c91236421ce4d302848e923cf815031f7fda" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;RULE&lt;/code&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RULE&lt;/code&gt; 内では、「 &lt;code&gt;forall&lt;/code&gt; 」は、他のフラグ設定に関係なく、キーワードとして扱われます。さらに、RULE内では、言語拡張&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;が自動的に有効になります。&lt;a href=&quot;#scoped-type-variables&quot;&gt;字句スコープの型変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8052685f0cc727e7c2ebcd111bc548b4add6a4b8" translate="yes" xml:space="preserve">
          <source>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</source>
          <target state="translated">スプライスの中では、インポートされたモジュールで定義された関数のみを呼び出すことができ、同じモジュール内の他の場所で定義された関数は呼び出すことができません。宣言スプライスは、トップレベル (他の宣言の外側)以外の場所では許されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="545835b49fc011bc077a5db3657fd4e34d03642a" translate="yes" xml:space="preserve">
          <source>Inspecting</source>
          <target state="translated">Inspecting</target>
        </trans-unit>
        <trans-unit id="2409022af23815ff0491ac232cbdc6c5b9d6cd9e" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">紙に触発&lt;em&gt;オーバーロードと高次多型と関数型プログラミング&lt;/em&gt;、マーク・P・ジョーンズ（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;）関数プログラミングの高度な学校、1995。</target>
        </trans-unit>
        <trans-unit id="70c309e18c61bc57ee637952f14b1c7107d7947a" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">紙に触発&lt;em&gt;オーバーロードと高次多型と関数型プログラミング&lt;/em&gt;、マーク・P・ジョーンズ（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;）関数プログラミングの高度な学校、1995。</target>
        </trans-unit>
        <trans-unit id="c0aacbdde24ca156566b7d32f70c5cccf57ab9e3" translate="yes" xml:space="preserve">
          <source>Install standard signal handlers for catching ^C, which just throw an exception in the target thread. The current target thread is the thread at the head of the list in the MVar passed to installSignalHandlers.</source>
          <target state="translated">C をキャッチするための標準のシグナルハンドラをインストールします。現在のターゲットスレッドは、installSignalHandlers に渡された MVar のリストの先頭にあるスレッドです。</target>
        </trans-unit>
        <trans-unit id="4a69978d36d4f8c81b1e10d8995051dff3da9a47" translate="yes" xml:space="preserve">
          <source>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don&amp;rsquo;t depend on the user having disabled installer detection.</source>
          <target state="translated">インストーラー検出は、セキュリティコントロールパネルを使用してシステムに対してグローバルにオフにすることもできますが、GHCはデフォルトで、インストーラー検出を無効にしたユーザーに依存しないバイナリを生成します。</target>
        </trans-unit>
        <trans-unit id="7cc8d33f2d97d8e835a27045d7ac58f353fddcec" translate="yes" xml:space="preserve">
          <source>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</source>
          <target state="translated">インスタンス宣言は、その頭が全く同じである場合にのみマージされるので、たとえ重ならない方法で実装されていても、シグネチャ内のインスタンスが重なっているとGHCが考えるような状況に陥る可能性があります。もしこれが問題を引き起こしているのであれば、私たちに声をかけてください。</target>
        </trans-unit>
        <trans-unit id="44d84e2252fdea394c95b5f2a46555b5e11e4e23" translate="yes" xml:space="preserve">
          <source>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the &lt;code&gt;Either&lt;/code&gt; instance for &lt;code&gt;GMap&lt;/code&gt; is</source>
          <target state="translated">データおよびnewtypeファミリーのインスタンス宣言は、標準のデータおよびnewtype宣言と非常に似ています。唯一の2つの違いは、キーワード &lt;code&gt;data&lt;/code&gt; または &lt;code&gt;newtype&lt;/code&gt; の後に &lt;code&gt;instance&lt;/code&gt; が続くことと、型引数の一部またはすべてが非変数型である可能性があることですが、forall型または型の同義語ファミリーが含まれていない場合があります。ただし、データファミリーは通常、型パラメーターで許可され、完全に適用され、それ自体が許容される型に拡張される限り、型の同義語が許可されます-これは、クラスインスタンスパラメーターでの型の同義語の出現に必要とされるのとまったく同じです。たとえば、 &lt;code&gt;GMap&lt;/code&gt; の &lt;code&gt;Either&lt;/code&gt; インスタンスは</target>
        </trans-unit>
        <trans-unit id="83bfa7778c9507fc8976cd01f0cb81fffebfd1e7" translate="yes" xml:space="preserve">
          <source>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword &lt;code&gt;type&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the &lt;code&gt;[e]&lt;/code&gt; instance for &lt;code&gt;Elem&lt;/code&gt; is</source>
          <target state="translated">型ファミリーのインスタンス宣言は、標準の型シノニム宣言と非常によく似ています。唯一の2つの違いは、キーワード &lt;code&gt;type&lt;/code&gt; 後に &lt;code&gt;instance&lt;/code&gt; が続くことと、タイプ引数の一部またはすべてが変数以外のタイプになる可能性があることですが、forallタイプまたはタイプシノニムファミリーを含めることはできません。ただし、データファミリーは一般に許可され、タイプのシノニムは完全に適用され、許容可能なタイプに拡張される限り許可されます。これらはデータインスタンスの場合とまったく同じ要件です。たとえば、 &lt;code&gt;Elem&lt;/code&gt; の &lt;code&gt;[e]&lt;/code&gt; インスタンスは</target>
        </trans-unit>
        <trans-unit id="aa54ccd8a5b1e6248e90321db5cede28dbc27c83" translate="yes" xml:space="preserve">
          <source>Instance details</source>
          <target state="translated">インスタンスの詳細</target>
        </trans-unit>
        <trans-unit id="7e9c3e59e4902eb11a9bc6ca6aecc9cd55844913" translate="yes" xml:space="preserve">
          <source>Instance lookup</source>
          <target state="translated">インスタンスルックアップ</target>
        </trans-unit>
        <trans-unit id="4d286d9c6958cb859af4d3cc5f70112b22b5d71b" translate="yes" xml:space="preserve">
          <source>InstanceDec</source>
          <target state="translated">InstanceDec</target>
        </trans-unit>
        <trans-unit id="fd5054f4d8b7d330705d793f60720bb1539b82c2" translate="yes" xml:space="preserve">
          <source>InstanceSigs</source>
          <target state="translated">InstanceSigs</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="87602c33058f0ebd121afb309504a6eb0e28e43e" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">インスタンスは &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; に似ています。たとえば、データ型が与えられます</target>
        </trans-unit>
        <trans-unit id="2b4574eaaa234d54582199f6b7f5240c28a0c1c8" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">インスタンスは &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; に似ています。たとえば、データ型が与えられます</target>
        </trans-unit>
        <trans-unit id="e4b471ed6e4af73beb38b8a58ed041752edf7705" translate="yes" xml:space="preserve">
          <source>Instances details</source>
          <target state="translated">インスタンスの詳細</target>
        </trans-unit>
        <trans-unit id="d8a851e89f00abbc9380f8fe634c1825d148cc64" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスは以下を満たす必要があります：</target>
        </trans-unit>
        <trans-unit id="f456cfda455d78aa8a5bb61b135052b5780b6a6d" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; のインスタンスは、次の法則を満たしている必要があります： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; は&amp;gt;&amp;gt; =の左ゼロでなければなりません。</target>
        </trans-unit>
        <trans-unit id="af23596067e4762785ef1756f8ec64eb7e700ca3" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; のインスタンスは、次の法則を満たしている必要があります： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; は&amp;gt;&amp;gt; =の左ゼロでなければなりません。</target>
        </trans-unit>
        <trans-unit id="d95157f0e1123c9e701efbf70b7e19778274e572" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスは以下を満たす必要があります：</target>
        </trans-unit>
        <trans-unit id="c793ddfb9db8e74c5e0c06e1d28e546ad4cb0556" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; のインスタンスは、構成要素の型が &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; にある任意のユーザー定義データ型から派生できます。データ宣言でのコンストラクターの宣言された順序は、派生 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; インスタンスの順序を決定します。 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; データ型は、2つのオブジェクトの正確な順序を決定するために、単一の比較を可能にします。</target>
        </trans-unit>
        <trans-unit id="2b35050349db25cdc61794ff971eb58445ded210" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスは以下を満たす必要があります：</target>
        </trans-unit>
        <trans-unit id="54c208a5a34a501f171c263767afb89fcd30fabe" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; のインスタンスは、任意の列挙型（コンストラクターにフィールドがない型）から派生できます。nullaryコンストラクターは、 &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;n-1&lt;/code&gt; までの &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; によって左から右に番号が付けられていると想定されます。詳細については、&lt;em&gt;Haskellレポートの&lt;/em&gt;第10章を参照してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993368854467462dff364596a665427fa9e766be" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; のインスタンスは、任意の列挙型（コンストラクターにフィールドがない型）から派生できます。nullaryコンストラクターは、 &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;n-1&lt;/code&gt; までの &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; によって左から右に番号が付けられていると想定されます。詳細については、&lt;em&gt;Haskellレポートの&lt;/em&gt;第10章を参照してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6abd05054200d033151c38fc2023bfb19af24a4f" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; インスタンスは以下を満たす必要があります：</target>
        </trans-unit>
        <trans-unit id="81df02f73af490aca4a8ceac4875eec434e49205" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; のインスタンスは、次の法則を満たしている必要があります： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; は&amp;gt;&amp;gt; =の左ゼロでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8400c20b4cb48bf7adc682e14acc2013d85e7139" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; のインスタンスは、構成要素の型が &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; にある任意のユーザー定義データ型から派生できます。データ宣言でのコンストラクターの宣言された順序は、派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; インスタンスの順序を決定します。 &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; データ型は、2つのオブジェクトの正確な順序を決定するために、単一の比較を可能にします。</target>
        </trans-unit>
        <trans-unit id="8498083049962c5ddf48a88c7ef6ff394e9c7be7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Monoid&lt;/code&gt; should also be instances of &lt;code&gt;Semigroup&lt;/code&gt;</source>
          <target state="translated">インスタンス &lt;code&gt;Monoid&lt;/code&gt; またのインスタンスでなければなりません &lt;code&gt;Semigroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42499a12ab52b772685bdffe6cd77d34696c747" translate="yes" xml:space="preserve">
          <source>Instances of Binary should satisfy the following property:</source>
          <target state="translated">Binaryのインスタンスは、以下の特性を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="679c72c6bd3806fccb37008ccaad716ad6e46022" translate="yes" xml:space="preserve">
          <source>Instances of these classes can be derived by GHC with the &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt; extension, and are necessary to be able to define generic instances automatically.</source>
          <target state="translated">これらのクラスのインスタンスは、&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;拡張を使用してGHCによって派生させることができ、ジェネリックインスタンスを自動的に定義できるようにするために必要です。</target>
        </trans-unit>
        <trans-unit id="65c1e5f128f1f1839602ec922ecbb3d89a2bfa33" translate="yes" xml:space="preserve">
          <source>Instances should ensure that, in the following code:</source>
          <target state="translated">インスタンスは、次のコードで、それを確実にする必要があります。</target>
        </trans-unit>
        <trans-unit id="60ec83a7328fd0f4c726f4dd91a7d148a7b39c03" translate="yes" xml:space="preserve">
          <source>Instances should obey the following law:</source>
          <target state="translated">インスタンスは次の法則に従うべきです。</target>
        </trans-unit>
        <trans-unit id="89fe09bb4f8ebf1e47ee60af8037d77fb33c5ffb" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; is a transformer of monads:</source>
          <target state="translated">インスタンスは、 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; がモナドの変換子であると述べている次の法律を満たしている必要があります。</target>
        </trans-unit>
        <trans-unit id="1abade2b53df1a1ba01e60f984a3a5290e836572" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws:</source>
          <target state="translated">インスタンスは以下の法則を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="9d7bb7203c91aa0d38c7b980a4ce66dfed489cf2" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following:</source>
          <target state="translated">インスタンスは以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="e86269f38cc2b59aa37a9312708da931d8afbda8" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the laws:</source>
          <target state="translated">インスタンスは法律を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="b012f0abcde18071b0722ff582581b311bd03281" translate="yes" xml:space="preserve">
          <source>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms &lt;code&gt;-&amp;lt;&lt;/code&gt; (first-order) and &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (higher-order).</source>
          <target state="translated">2つの変換を伴う単一の形式の矢印アプリケーション（矢印の尾）の代わりに、実装は2つの形式 &lt;code&gt;-&amp;lt;&lt;/code&gt; （1次）および &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; （高次）を提供します。</target>
        </trans-unit>
        <trans-unit id="886e0a6b103c70f084410d0784c49a059007efdd" translate="yes" xml:space="preserve">
          <source>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</source>
          <target state="translated">GHCは実行ファイルを作成する代わりに、このリンカーフラグを持つ共有オブジェクトを生成します。オペレーティングシステムのターゲットによっては、これはELFのDSO、WindowsのDLL、またはMac OSのdylibかもしれません。GHCは、この統一フラグの下にオペレーティングシステムの詳細を隠します。</target>
        </trans-unit>
        <trans-unit id="4bea18059726367b2d2fc3a93789ffe96f83da94" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">再帰呼び出しを行う代わりに、ダミーパラメータ &lt;code&gt;rec&lt;/code&gt; を導入します。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 内で使用すると、このパラメーターは &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 引数を参照するため、再帰が再導入されます。</target>
        </trans-unit>
        <trans-unit id="4d75fde1ad8ce1fe9457a9340d10b92d1fe2f1c4" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s argument, hence the recursion is reintroduced.</source>
          <target state="translated">再帰呼び出しを行う代わりに、ダミーパラメータ &lt;code&gt;rec&lt;/code&gt; を導入します。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 内で使用される場合、このパラメーターは &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; の引数を参照するため、再帰が再導入されます。</target>
        </trans-unit>
        <trans-unit id="43d6bd77abb0145c25600eed500e3ab34605d53a" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">再帰呼び出しを行う代わりに、ダミーパラメータ &lt;code&gt;rec&lt;/code&gt; を導入します。 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 内で使用すると、このパラメーターは &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 引数を参照するため、再帰が再導入されます。</target>
        </trans-unit>
        <trans-unit id="f408254609f2594f75fbcdb0b71c211f8a49859f" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s argument, hence the recursion is reintroduced.</source>
          <target state="translated">再帰呼び出しを行う代わりに、ダミーパラメータ &lt;code&gt;rec&lt;/code&gt; を導入します。 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 内で使用される場合、このパラメーターは &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; の引数を参照するため、再帰が再導入されます。</target>
        </trans-unit>
        <trans-unit id="e766beefc2f70f81de8c559b30c93536dd165acf" translate="yes" xml:space="preserve">
          <source>Instead of reusing &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, a separate data family &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; is used to mark occurrences of common unlifted types:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; を再利用する代わりに、別のデータファミリー &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; を使用して、リフトされていない一般的なタイプの発生をマークします。</target>
        </trans-unit>
        <trans-unit id="28acba53025bd15fee205581c34d0d6b581a22f3" translate="yes" xml:space="preserve">
          <source>Instead, use a &lt;code&gt;case&lt;/code&gt; expression:</source>
          <target state="translated">代わりに、 &lt;code&gt;case&lt;/code&gt; 式を使用します。</target>
        </trans-unit>
        <trans-unit id="904bf5c0f9e80212c91a23a693a49eb67e501513" translate="yes" xml:space="preserve">
          <source>Instead, we can use the &lt;a href=&quot;#ghci-cmd-:main&quot;&gt;&lt;code&gt;:main&lt;/code&gt;&lt;/a&gt; command. This runs whatever &lt;code&gt;main&lt;/code&gt; is in scope, with any arguments being treated the same as command-line arguments, e.g.:</source>
          <target state="translated">代わりに、&lt;a href=&quot;#ghci-cmd-:main&quot;&gt; &lt;code&gt;:main&lt;/code&gt; &lt;/a&gt;コマンドを使用できます。これは、スコープ内の &lt;code&gt;main&lt;/code&gt; が何であっても実行します。引数はコマンドライン引数と同じように扱われます。例：</target>
        </trans-unit>
        <trans-unit id="ed612bf7d1e1bf9249388e996ba2c817a283fe3f" translate="yes" xml:space="preserve">
          <source>Instead, we provide a function &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;, which would be used thus:</source>
          <target state="translated">代わりに、次のように使用される関数 &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="af0a510e3a346d26bd86b56dc0c175daeafd39a0" translate="yes" xml:space="preserve">
          <source>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even &quot;any IO exception&quot;; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</source>
          <target state="translated">その代わり、本当に必要な例外だけを捕捉するべきです。この場合、これはおそらく &quot;any IO exception &quot;よりもより具体的なものになるでしょう。その代わりに、おそらく次のようなものが必要になるでしょう。</target>
        </trans-unit>
        <trans-unit id="ad2288edd1fb8d5afcaabf253b85250d058d0294" translate="yes" xml:space="preserve">
          <source>Instead, you would have to write &lt;code&gt;foo&lt;/code&gt; as a class operation, thus:</source>
          <target state="translated">代わりに、 &lt;code&gt;foo&lt;/code&gt; をクラスオペレーションとして記述する必要があるため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="dbd230bbda194ea68580a1f846c3ea6c3d1dcbb0" translate="yes" xml:space="preserve">
          <source>Instruct &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to use &lt;code&gt;Show&lt;/code&gt; instances where possible.</source>
          <target state="translated">指示&lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;に使用する &lt;code&gt;Show&lt;/code&gt; 可能なインスタンスを。</target>
        </trans-unit>
        <trans-unit id="b8b938452c4d4e801965219c0e20127da862913e" translate="yes" xml:space="preserve">
          <source>Instruct the linker to produce a position-independent executable.</source>
          <target state="translated">リンカに位置に依存しない実行ファイルを生成するように指示します。</target>
        </trans-unit>
        <trans-unit id="395f6e3c69e858b418512c3a6a34e4c05014b51b" translate="yes" xml:space="preserve">
          <source>Instructs GHC to consider a value to be especially cheap to inline.</source>
          <target state="translated">GHCにインラインで特に安い値を検討するよう指示する。</target>
        </trans-unit>
        <trans-unit id="bccb53bdffc16a668b6a787212ca241e78854706" translate="yes" xml:space="preserve">
          <source>Instructs GHC to use the platform&amp;rsquo;s native vector registers to pass vector arguments during function calls. As with all vector support, this requires &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">関数呼び出し中にプラットフォームのネイティブベクトルレジスタを使用してベクトル引数を渡すようにGHCに指示します。すべてのベクトルサポートと同様に、これには&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="8fc26ab3c56e988207cb5b87c0a8f1b8c3e39ed8" translate="yes" xml:space="preserve">
          <source>Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in &lt;code&gt;/tmp&lt;/code&gt; (or possibly elsewhere; see &lt;a href=&quot;#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;). Running GHC with &lt;code&gt;-v&lt;/code&gt; will show you what temporary files were generated along the way.</source>
          <target state="translated">GHCドライバーに、一時ファイルを削除しないように指示します。一時ファイルは通常 &lt;code&gt;/tmp&lt;/code&gt; に保持されます（または他の場所にある可能性があります。&lt;a href=&quot;#temp-files&quot;&gt;一時ファイルのリダイレクトを&lt;/a&gt;参照してください）。 &lt;code&gt;-v&lt;/code&gt; を指定してGHCを実行すると、途中で生成された一時ファイルが表示されます。</target>
        </trans-unit>
        <trans-unit id="eeeb93766512243c6a86ffca2e17fc90c9bf7fbd" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;#11487&lt;/a&gt;).</source>
          <target state="translated">LLVMコードジェネレーターに、呼び出しで &lt;code&gt;undef&lt;/code&gt; ではなく、デッドSTGレジスターをガベージで埋めるように指示します。これにより、コードジェネレーターとランタイムシステムの微妙なバグを簡単に&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;見つける&lt;/a&gt;ことができます（例：＃11487を参照）。</target>
        </trans-unit>
        <trans-unit id="2154c477da950e933ffd834aafe87aa85025a4f4" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue #11487&lt;/a&gt;).</source>
          <target state="translated">呼び出しで &lt;code&gt;undef&lt;/code&gt; の代わりに不要な STGレジスタをガベージで埋めるようにLLVMコードジェネレーターに指示します。これにより、微妙なコードジェネレーターやランタイムシステムのバグを簡単に検出できるようになります（たとえば、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;問題＃11487を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bfa150c9679995565d99e25e8bfa01f17da6a7ba" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to inline a value.</source>
          <target state="translated">コンパイラに値をインライン化しないように指示します。</target>
        </trans-unit>
        <trans-unit id="675da7443910dccefb93ff214351f3b254eb9326" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to unpack a constructor field.</source>
          <target state="translated">コンストラクタ・フィールドをアンパックしないようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="91e67ac1bd85402d088ab03ef989ae5c792d157d" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</source>
          <target state="translated">コンストラクタ・フィールドの内容をコンストラクタ自身に展開するようにコンパイラに指示します。</target>
        </trans-unit>
        <trans-unit id="365865761dffc2759227bec5082fd7cd2a7643d4" translate="yes" xml:space="preserve">
          <source>Instructs the simplifier to emit &lt;code&gt;error&lt;/code&gt; expressions in the continuation of empty case analyses (which should bottom and consequently not return). This is helpful when debugging demand analysis bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">空のケース分析の継続時に &lt;code&gt;error&lt;/code&gt; 式を出力するように簡略化プログラムに指示します（これにより、ボトムになり、結果として返されません）。これは、セグメンテーションエラーとして現れることがあるデマンド分析バグをデバッグするときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="40743f84300c6c1b0918774a56963484d75164e4" translate="yes" xml:space="preserve">
          <source>Insufficient resources are available to perform the operation.</source>
          <target state="translated">操作を実行するためのリソースが不足している。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="b0b14c298354a19d3dea6a61e98e487fa2e51bfb" translate="yes" xml:space="preserve">
          <source>Int results</source>
          <target state="translated">ちゅうかんけっか</target>
        </trans-unit>
        <trans-unit id="474e49b09d35d1abae6313b6259476068b2d3bdb" translate="yes" xml:space="preserve">
          <source>Int#</source>
          <target state="translated">Int#</target>
        </trans-unit>
        <trans-unit id="7982e8c08d84551a97dde8c3cc98e03fc2d6082c" translate="yes" xml:space="preserve">
          <source>Int16</source>
          <target state="translated">Int16</target>
        </trans-unit>
        <trans-unit id="89aeb74564c1a3c6fca4d47bfe34fd7d47efe931" translate="yes" xml:space="preserve">
          <source>Int16#</source>
          <target state="translated">Int16#</target>
        </trans-unit>
        <trans-unit id="ea2b1a89854df33ae5484ba3a6d447aba6945b77" translate="yes" xml:space="preserve">
          <source>Int16ElemRep</source>
          <target state="translated">Int16ElemRep</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
