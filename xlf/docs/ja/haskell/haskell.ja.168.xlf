<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">再コンパイルチェックをオフにします。これは、単一のファイルをコンパイルするとき（つまり&lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;を使用するとき）の &lt;code&gt;-ddump-X&lt;/code&gt; オプションによって暗示されます。</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">「ステートハック」をオフにします。これにより、引数として &lt;code&gt;State#&lt;/code&gt; トークンを持つラムダは単一エントリと見なされるため、その中にインライン化しても問題ありません。これにより、IOおよびSTモナドコードのパフォーマンスが向上しますが、共有が減少するリスクがあります。</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">強制オプティマイザーをオフにする</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">強制オプティマイザーをオフにしてください。</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">実世界の状態トークンを引数に持つラムダはシングルエントリとみなされるため、状態ハックをオフにします。したがって、その中でインライン化しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;熱心なブラックホールを&lt;/a&gt;オンにする</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">デマンドアナライザーでCPR分析をオンにします。</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デマンドアナライザーでCPR分析をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">Haskellプログラムのカバレッジ・インスツルメンテーションをオンにする</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">コールパターンの特殊化をオンにします。&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskellプログラムの呼び出しパターン特殊化を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">デバッグ印刷をオンにする (詳細)</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">完全な遅延をオンにします（バインディングを外側にフローティング）。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">コアレベルで、GHC内のヘビーウェイトパス内サニティチェックをオンにします。（それはあなたのものではなくGHCの健全性をチェックします。）</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">内部のサニティーチェックをオンにする</target>
        </trans-unit>
        <trans-unit id="dc3c205a62aa2d2da8175eab4c4b97ecb966fe59" translate="yes" xml:space="preserve">
          <source>Turn on linearity checking in GHC. Currently, some optimizations in GHC might not preserve linearity and they valid programs might fail Linear Core Lint. In the near future, this option will be removed and folded into normal Core Lint.</source>
          <target state="translated">GHC の線形性チェックをオンにします。現在、GHC の最適化の中には線形性を保持しないものがあり、そのような有効なプログラムは Linear Core Lint に失敗する可能性があります。近い将来、このオプションは削除され、通常の Core Lint に組み込まれる予定です。</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">GHCiでの製本結果の印刷をオンにする</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">プロファイリングをオンにする</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">他のモジュールからインポートしたオーバーロードされた関数の特殊化をオンにします。</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">アンフォールディングが可能な場合は、サイズに関係なくオーバーロードされた関数の特殊化をオンにします。</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オーバーロードされた関数の特殊化をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">厳密性分析をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。意味&lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt; &lt;code&gt;-fworker-wrapper&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">厳密性分析をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。意味 &lt;code&gt;-fworker-wrapper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SpecConstr変換をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">フロートイン変換をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">解放ケース変換をオンにします。&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">解放ケース変換をオンにします。これは、それ自体のRHSで再帰関数を1回アンロールして、自由変数のケース分析が繰り返されるのを防ぎます。これは、呼び出しパターンの特殊化（&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt;）に少し似ていますが、引数ではなく自由変数用です。</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">静的引数変換をオンにします。これは、再帰関数をローカルの再帰ループを持つ非再帰関数に変換します。&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santosの博士論文の&lt;/a&gt;第7章を参照してください。</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">静的な引数変換をオンにします。</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">チクチクするプロファイリングをオンにする</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">飽和した自己再帰末尾呼び出しを、生成されたアセンブリのローカルジャンプに変換します。&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="817ee37f90284803efb9153022786df4682fbe53" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">タイプエラーを警告に変え、&lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;実行時までエラーを延期します&lt;/a&gt;。意味&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">タイプエラーを警告に変換し、&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;実行時までエラーを延期します&lt;/a&gt;。意味&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">特別な構文を有効にするオプションをオンにすると、おそらく予約語になった変数名を使用しているために、機能しているHaskell 98コードのコンパイルが失敗する&lt;em&gt;可能性が&lt;/em&gt;あります。このセクションでは、言語拡張機能によって「盗まれる」構文をリストします。Haskell 98字句構文の表記法と非終端名を使用します（Haskell 98レポートを参照）。ここでは、既存の作業プログラムに影響を与える可能性のある構文の変更（つまり、「盗まれた」構文）のみをリストします。これらの拡張機能の多くは、新しいコンテキストフリー構文も有効にしますが、すべてのケースで、新しい構文を使用するように作成されたプログラムは、オプションを有効にしないとコンパイルできません。</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;Strict&lt;/code&gt; が有効になっている場合、パターンを反駁できないパターンに変換するには、 &lt;code&gt;~(~p)&lt;/code&gt; 〜p ）または &lt;code&gt;(~ ~p)&lt;/code&gt; 〜〜p）が必要です。</target>
        </trans-unit>
        <trans-unit id="c36dca2d0bb2acce2b8d943939d7c270f3396cfe" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;Strict&lt;/code&gt; が有効になっている場合、パターンを反駁できないパターンに変換するには、 &lt;code&gt;~(~p)&lt;/code&gt; 〜p）が必要です。</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">モナド演算によって与えられるファイナライザを参照に関連付けることにより、プレーンメモリ参照を外部オブジェクトに変換します。ストレージマネージャは、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; への最後の参照が削除されてからしばらくして、別のスレッドでファイナライザを開始します。迅速性の保証はなく、実際にはファイナライザーが最終的に実行される保証はありません。</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">モナド演算によって与えられるファイナライザを参照に関連付けることにより、プレーンメモリ参照を外部オブジェクトに変換します。ストレージマネージャは、 &lt;code&gt;ForeignPtr&lt;/code&gt; への最後の参照が削除されてからしばらくして、別のスレッドでファイナライザを開始します。迅速性の保証はなく、実際にはファイナライザーが最終的に実行される保証はありません。</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単純なメモリ参照を、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; を使用してファイナライザに関連付けることができる外部ポインタに変換します。</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単純なメモリ参照を、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; を使用してファイナライザに関連付けることができる外部ポインタに変換します。</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">単純なメモリ参照を、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; を使用してファイナライザに関連付けることができる外部ポインタに変換します。</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">プレーンメモリ参照を外部ポインタに変換し、その参照にファイナライザを関連付けます。ファイナライザは、外部オブジェクトへの最後の参照が削除された後に実行されます。プロンプト性は保証されていませんが、プログラムが終了する前にファイナライザが実行されます。</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">すべてのテキスト属性をオフにする。この能力は常に成功しますが、テキスト属性をサポートしていない端末では効果がありません。</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">標準のものと&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;が有効にしていないものを含むすべての警告をオフにします。</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">潜在的に疑わしいコードを示すすべての警告オプションをオンにします。&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; で&lt;/a&gt;有効になって&lt;em&gt;いない&lt;/em&gt;警告は、</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">与えられたテキストを出力する前に太字モードをオンにし、その後すべての属性をオフにします。</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">コンパイラがサポートするすべての警告をオンにします。</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">与えられたテキストを出力する前にスタンドアウトモードをオンにし、その後オフにします。</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">与えられたテキストを出力する前にアンダーラインモードをオンにし、その後オフにします。</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">将来的にデフォルトで有効になりますが、通常のコンパイルでは当面オフのままの警告をオンにします。これにより、コードを将来的に互換性のあるものにしたいと考えているライブラリの作者は、警告を生成する前に新しい機能に適応することができます。</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">2つのコマンドラインオプションは、起動ファイルを読み込むかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">気をつけるべき2つのこと</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">2つのタイプは、すべての可能な置換について、そのタイプが共通の還元体に還元できない場合、離れているとみなされます。</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">2つのタイプのメッセージが生成されます。 &lt;code&gt;***&lt;/code&gt; で始まるメッセージはコンパイル段階の始まりを示しますが、 &lt;code&gt;!!!&lt;/code&gt; で始まるメッセージは!!! パスの終了をマークし、割り当てと実行時の統計を伴います。</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">タイプリテラル</target>
        </trans-unit>
        <trans-unit id="0ff156671a95e7d7958f54c3801c9a78059e1834" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">引数の名前が​​重要でない場合は、型引数をアンダースコア（ &lt;code&gt;_&lt;/code&gt; ）に置き換えることができます。これは、一意の名前で型変数を作成するのと同じです。&lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;フラグが有効になっている場合の警告を回避するために、未使用の型引数をアンダースコアで置き換えるか、接頭辞を付けることができます。&lt;a href=&quot;#data-instance-declarations&quot;&gt;データインスタンス宣言の場合&lt;/a&gt;と同じルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">引数の名前が​​重要でない場合は、型引数をアンダースコア（ &lt;code&gt;_&lt;/code&gt; ）に置き換えることができます。これは、一意の名前で型変数を書き込むのと同じです。&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;フラグが有効になっている場合、警告を回避するために、未使用の型引数をアンダースコアで置き換えるか、プレフィックスを付けることができます。&lt;a href=&quot;#data-instance-declarations&quot;&gt;Dataインスタンス宣言&lt;/a&gt;と同じ規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">タイプチェッカーでは、穴のタイプを推測することができます。</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I/O プロバイダの型クラス。</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt;など、独自の拡張機能の派生を有効にする必要がある型クラス（&lt;a href=&quot;#deriving-extra&quot;&gt;追加クラスのインスタンスの派生（データなど）を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;など、独自の拡張機能を派生させる必要がある型クラス（&lt;a href=&quot;#deriving-extra&quot;&gt;追加クラス（データなど）のインスタンスの派生を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="561c814be6dae335c98b673227b1a4d073e164e6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;deriving_extra#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;deriving_extra#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;など、独自の拡張機能を派生させる必要がある型クラス（&lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;追加クラス（データなど）のインスタンスの派生を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">for- &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;含む型に適用される型コンストラクター（ImpredicativeTypesがオフの場合）</target>
        </trans-unit>
        <trans-unit id="ccd8b1a39bf697129dfe9925ae54f15bbbb0a75a" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;impredicative_types#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">for-allsを含む型に適用される型コンストラクター（&lt;a href=&quot;impredicative_types#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;がオフの場合）</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">型のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">型のコンストラクタとクラス;Haskellでは、今のところ同じ名前の空間にそれらを置いています。</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="translated">フォーオールの下での型の均等性は延期できません(c.f.#14605)。</target>
        </trans-unit>
        <trans-unit id="9fc11fe5ce4f23f06fca295618c3b4ba02ddb103" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14605&quot;&gt;#14605&lt;/a&gt;).</source>
          <target state="translated">forallの下での型の&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14605&quot;&gt;同等性は&lt;/a&gt;延期できません（＃14605を参照）。</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">フォアオールの下でのタイプの均等性は延期できません(cf.Trac #14605)。</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">タイプの平等</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">型ファミリーには、3 つの種類があります。(1)トップレベル上でオープン・ファミリーとして定義すること、(2)トップレベル上でクローズド・ファミリーとして定義すること、(3)タイプ・クラスの内部に出現すること(この場合、関連するタイプ・シノニムとして知られています)です。トップレベル・ファミリーは、型インデックスがクラス・パラメータと一致している必要がないため、より一般的なものです。しかし、関連付けられた型同義語を使用すると、コードの構造がより明確になり、型インスタンスが誤って省略された場合にコンパイラが警告を出すことがあります。以下では、常に最初に一般的なトップレベル型について説明し、次に関連型に課せられる追加の制約について説明します。閉じた関連型の同義語は存在しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">タイプファミリーは、言語拡張&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;によって有効になります。GHCでのタイプファミリーの使用に関する追加情報は、タイプファミリー&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;のHaskell wikiページにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f76f6ce50fb342101781212e18ae010ee327b2c4" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">型族は、言語拡張&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;によって有効になります。GHCでの型族の使用に関する追加情報は、型族に関する&lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;Haskellwikiページで&lt;/a&gt;入手できます。</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">タイプファミリーでは、インスタンスヘッドの形式のルールを拡張する必要があります。これは&lt;a href=&quot;#flexible-instance-head&quot;&gt;、インスタンスヘッドのリラックスルールで&lt;/a&gt;指定されています。具体的には：</target>
        </trans-unit>
        <trans-unit id="f4251de5d3214c46072d1ab7da575f6b1ff192df" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;instances#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">型族では、インスタンスヘッドの形式のルールを拡張する必要があります。これは&lt;a href=&quot;instances#flexible-instance-head&quot;&gt;、インスタンスヘッドのリラックスルールで&lt;/a&gt;指定されています。具体的には：</target>
        </trans-unit>
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">型ファミリー宣言には右辺がありませんが、GHCは &lt;code&gt;F&lt;/code&gt; の種類を推測する必要があります。制約がないため、 &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; 推測できます。k1-&amp;gt; k2ですが、多態&lt;em&gt;すぎる&lt;/em&gt;ようです。したがって、GHCはこれらの完全に制約のないkind変数をデフォルトで &lt;code&gt;Type&lt;/code&gt; に設定し、 &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; を取得します。種類シグネチャを使用して、 &lt;code&gt;F&lt;/code&gt; を種類多相であると宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">型ファミリのインスタンス宣言は、適切なファミリ宣言がスコープ内にある場合にのみ正当なものとなります-クラスインスタンスがクラス宣言を可視化することを必要とするのと同じように。さらに、各インスタンス宣言は、そのファミリ宣言によって決定された種類に準拠しなければならず、インスタンス宣言の型パラメータの数は、ファミリ宣言の型パラメータの数と一致しなければならない。最後に、型インスタンスの右辺はモノタイプでなければならず(すなわち、フォアオールを含んではならない)、すべての飽和したバニラ型の同義語を展開した後は、ファミリー同義語以外の同義語は残ってはならない。</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">タイプファミリーの結果</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">タイプファミリーの結果署名</target>
        </trans-unit>
        <trans-unit id="c9902ea99522cdd8d23085400914695929774e22" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;#10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;#10946&lt;/a&gt;)</source>
          <target state="translated">タイプされたスプライスに穴をタイプします（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;＃10945&lt;/a&gt;および&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;＃10946&lt;/a&gt;を参照）</target>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">型付きスプライスに穴を入力します（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;問題＃10945&lt;/a&gt;および&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;問題＃10946を参照&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="276b31a5f89d022c33dce55c2768f21e907ef802" translate="yes" xml:space="preserve">
          <source>Type lookup</source>
          <target state="translated">タイプ検索</target>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; 使用できるデバイスのタイプ（mkFileHandleも参照）。標準ライブラリは、ファイル記述子（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; を参照）を使用したPosixファイル操作を介して &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; の作成を提供します。FDは、基になる &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; インスタンスです。</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">フォーマット文字列から修飾文字を解析する関数の型。</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">型の表現</target>
        </trans-unit>
        <trans-unit id="d476627bc725ea2b4474151d280a2bff44c61eb5" translate="yes" xml:space="preserve">
          <source>Type representing 128-bit Unicode subset bitfields, as the &lt;code&gt;base&lt;/code&gt; package does include a module exporting a 128-bit unsigned integer type.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; パッケージには128ビットの符号なし整数型をエクスポートするモジュールが含まれているため、128ビットのUnicodeサブセットビットフィールドを表す型。</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">&lt;em&gt;生の&lt;/em&gt;任意精度のNaturalsを表す型</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">GMP肢を表すタイプ</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">任意精度の非負の整数を表す型.</target>
        </trans-unit>
        <trans-unit id="07805eadc38f7082f8142805c647fecdc2fe145b" translate="yes" xml:space="preserve">
          <source>Type representing locale data</source>
          <target state="translated">ロケールデータを表す型</target>
        </trans-unit>
        <trans-unit id="04f3c2b34d933ed0082ee4d9a77619193e0fa0ae" translate="yes" xml:space="preserve">
          <source>Type signature declarations for functions, values, and class methods</source>
          <target state="translated">関数、値、およびクラスメソッドの型シグネチャ宣言</target>
        </trans-unit>
        <trans-unit id="1e453cabd9572ae7f533e9e17c78f4446cb10208" translate="yes" xml:space="preserve">
          <source>Type signatures for &lt;a href=&quot;gadt#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt; constructors</source>
          <target state="translated">&lt;a href=&quot;gadt#gadt&quot;&gt;一般化代数的データ型（GADT）&lt;/a&gt;コンストラクターの型シグネチャ</target>
        </trans-unit>
        <trans-unit id="b796829535549c68436fd73f285f127abfd7701a" translate="yes" xml:space="preserve">
          <source>Type signatures for &lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;パターンシノニムの&lt;/a&gt;型シグネチャ</target>
        </trans-unit>
        <trans-unit id="27011d116ac3ec121518ae6e931cca052bc0fc9e" translate="yes" xml:space="preserve">
          <source>Type signatures in a &lt;a href=&quot;pragmas#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt; or &lt;a href=&quot;pragmas#specialize-instance-pragma&quot;&gt;SPECIALIZE instance pragma&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragmas#specialize-pragma&quot;&gt;SPECIALIZEプラグマ&lt;/a&gt;または&lt;a href=&quot;pragmas#specialize-instance-pragma&quot;&gt;SPECIALIZEインスタンスプラグマに&lt;/a&gt;署名を入力します</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">タイプスプライス:タイプスプライスでは、匿名ワイルドカードのみがサポートされています。名前付きワイルドカードと制約外ワイルドカードはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">型同義語ファミリーは、インスタンスヘッドには(全く)現れない場合があります。</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr＃の&lt;/a&gt;類義語を入力</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char＃の&lt;/a&gt;類義語を入力</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double＃の&lt;/a&gt;類義語を入力</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float＃の&lt;/a&gt;類義語を入力</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int＃の&lt;/a&gt;類義語を入力</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word＃の&lt;/a&gt;類義語を入力</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">コンストラクタのメタ情報を符号化するための型の代名詞</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">データ型のためのメタ情報を符号化するための型シノニム</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">レコードセレクタのためのメタ情報を符号化するための型シノニム</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">（種類 &lt;code&gt;Type&lt;/code&gt; の）再帰をエンコードするための型の同義語</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">タイプの同義語</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">型の同義語は型レベルのマクロのようなものですが、Haskell 98は個々の同義語の宣言に多くの規則を課しています。&lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; の&lt;/a&gt;延長、GHCはタイプの妥当性検査を行う&lt;em&gt;だけで型シノニムを展開した後&lt;/em&gt;。つまり、GHCは型の同義語に関してHaskell 98よりもはるかに寛大である可能性があります。</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">タイプワイルドカードは、アンダースコアに接尾辞としての識別子、つまり &lt;code&gt;_a&lt;/code&gt; を付けることで名前を付けることもできます。これらは、&lt;em&gt;名前付きワイルドカード&lt;/em&gt;と呼ば&lt;em&gt;れ&lt;/em&gt;ます。1つの型シグネチャ内で同じ名前のワイルドカードが出現すると、すべて同じ型に統合されます。例えば：</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">タイプチェックと名前の変更</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">タイプクラスと暗黙のパラメータ制約</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">タイプレベルの「と</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">タイプレベルの「not」。 &lt;code&gt;4.10.0.0&lt;/code&gt; 以降の単射型ファミリー。</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">タイプレベルの「または</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">タイプレベルの&lt;a href=&quot;if&quot;&gt;場合&lt;/a&gt;。 &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; の場合 ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">タイプセーフキャスト</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">命題の平等性を利用したタイプセーフキャスト</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">表現の平等性を利用したタイプセーフキャスト</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="40fb2a246a44fdd76a25bc4dee91c9b12c42ad29" translate="yes" xml:space="preserve">
          <source>Typeclass</source>
          <target state="translated">Typeclass</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">型クラス &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; -formattable値。 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; の方法は、値とフィールド形式の記述子を取り、悪い記述のために失敗した場合や、生産のいずれか &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; 、結果としては。デフォルトの &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; は修飾子を想定していません。これは通常のケースです。最小インスタンス： &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26ab741c0b6c1149ecdfc5c0b36d8ccc700d5b32" translate="yes" xml:space="preserve">
          <source>Typed TH quotes on the other hand are perfectly compatible with the eager application of rebindable syntax rules, and GHC will therefore process any such quotes according to the rebindable syntax rules whenever the &lt;code&gt;RebindableSyntax&lt;/code&gt; extension is turned on in the modules where such quotes appear.</source>
          <target state="translated">一方、型指定されたTH引用符は、再バインド可能な構文ルールの熱心なアプリケーションと完全に互換性があるため、GHCは、そのような引用符が表示されるモジュールで &lt;code&gt;RebindableSyntax&lt;/code&gt; 拡張機能がオンになっている場合は常に、再バインド可能な構文ルールに従ってそのような引用符を処理します。</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">型付き式スプライス:(型付きでない)式スプライスと同じワイルドカードがサポートされています。</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">型付けされた表現</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">型付き穴が有力アンダースコアで書かれた特別なプレースホルダを可能にGHCの機能です（例えば、「 &lt;code&gt;_&lt;/code&gt; 」、「 &lt;code&gt;_foo&lt;/code&gt; 」、「 &lt;code&gt;_bar&lt;/code&gt; は」）、式として使用されます。コンパイル中に、これらのホールは、ホールの場所で予期されるタイプ、フリータイプ変数の発生元に関する情報、およびホールを埋めるのに役立つ可能性があるローカルバインディングのリストと、タイプに適合するスコープのバインディングを示すエラーメッセージを生成します実際のコードで穴を埋めるのに役立つかもしれない穴の。型付き穴はGHCで常に有効になっています。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">UTCとUT1の型と関数</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">Unicodeテキストのエンコーディングやデコーディングの誤りに対処するための型と関数。</target>
        </trans-unit>
        <trans-unit id="a2c52d7c6cf4bc87e6f29125e9f05a6c3ab0de78" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs</source>
          <target state="translated">リモートGHCiでリモートオブジェクトを参照するためのタイプ。詳細については、コンパイラ&lt;em&gt;GHC&lt;/em&gt; Runtime /Interpreter.hsの注[外部GHCiポインタ]を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">リモートGHCiでリモートオブジェクトを参照するためのタイプ。詳細については、コンパイラ&lt;em&gt;ghci&lt;/em&gt; GHCi.hsの注[外部GHCiポインタ]を参照してください。</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">テキストのエンコード/デコードが失敗する方法を指定するタイプ</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">I/Oエラーの種類</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">型、クラス制約はinfixで書くことができます。例えば</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">一般的な使用方法： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2b54a022fd50a70fd5342e23351e38dc98cf9e0" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">一般的な使用方法： &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f47fb4e5fc6ce9d393da5169defdd4830664a47" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.15.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">一般的な使用方法： &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.15.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">一般的な使用方法： &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">通常、GHCiは&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;コマンドの後にロードしたモジュールの数のみを表示します。このフラグを使用すると、GHCはロードされたモジュールの名前もリストします。これはGHC 8.2.1より前のデフォルトの動作であり、一部のツールユーザーには役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">通常、この &lt;code&gt;GSerialize&lt;/code&gt; クラスはエクスポートされません。これは、表現タイプのインスタンスを持つことが理にかなっているためです。</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; を単独で入力すると、現在定義されているマクロが一覧表示されます。既存のコマンド名を再定義しようとすると、 &lt;code&gt;:def!&lt;/code&gt; formが使用されます。その場合、その名前の古いコマンドは警告なしに上書きされます。</target>
        </trans-unit>
        <trans-unit id="03049aa8714feb7c10314b4dd7463192a8695411" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; と入力すると、現在定義されているマクロが一覧表示されます。既存のコマンド名を再定義しようとすると、 &lt;code&gt;:def!&lt;/code&gt; でない限り、エラーが発生します。 formが使用されます。この場合、その名前の古いコマンドはサイレントに上書きされます。ただし、組み込みコマンドの場合は、コマンド名の前に二重コロンを付けることで古いコマンドを使用できます（例 &lt;code&gt;::load&lt;/code&gt; ）。これは、コマンドを再定義することはできません &lt;code&gt;:{&lt;/code&gt; 、 &lt;code&gt;:}&lt;/code&gt; と &lt;code&gt;:!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6e5374291987ed29812b27d3b5a192b78251690" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceeding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:def&lt;/code&gt; を単独で入力すると、現在定義されているマクロが一覧表示されます。既存のコマンド名を再定義しようとすると、 &lt;code&gt;:def!&lt;/code&gt; でない限り、エラーが発生します。フォームが使用されます。この場合、その名前の古いコマンドはサイレントに上書きされます。ただし、組み込みコマンドの場合は、コマンド名の前に二重コロンを付けることで、古いコマンドを引き続き使用できます（例 &lt;code&gt;::load&lt;/code&gt; ）。これは、コマンドを再定義することはできません &lt;code&gt;:{&lt;/code&gt; 、 &lt;code&gt;:}&lt;/code&gt; と &lt;code&gt;:!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">入力：「exp」のタイプが「T1」 &lt;code&gt;-&amp;gt;&lt;/code&gt; 「 T2」で、「pat」が「T2」に一致する場合、ビューパターン全体が「T1」に一致します。</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">UNIXスタイルフォーマット</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">UNIXスタイルの構文解析</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">USERPROFILE環境変数。</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">UTCは、&quot;うるう秒 &quot;として知られている時折の秒を追加または削除することにより、地球とのペースを保つために補正された時計によって測定された時間です。これらの修正は予測可能ではなく、6ヶ月前に発表されます。これらの修正の表は提供されていませんが、それを使って編纂されたプログラムは6ヶ月で古くなってしまいます。</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16(Windowsシステムで使用されているもの)。</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">IO ライブラリ用の UTF-16 コーデック</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16サロゲートコードポイントは、Unicodeスカラー値のセットには含まれていませんが、Haskellにより、残念ながら有効な &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値として認められています。それらを &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; で表すことはできません。この関数は、それらのコードポイントをUnicode置換文字（U + FFFD、 ''）に再マップし、他のコードポイントは変更しません。</target>
        </trans-unit>
        <trans-unit id="62cdcaea7e563aff141140dcd64fe723c057ad8d" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16サロゲートコードポイントはUnicodeスカラー値のセットには含まれていませんが、残念ながらHaskellによって有効な &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値として認められています。 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; で表すことはできません。この関数は、これらのコードポイントをUnicode置換文字（U + FFFD、 ' '）に再マップし、他のコードポイントは変更しないままにします。</target>
        </trans-unit>
        <trans-unit id="9f5128ce869af750fe326f9013d7f2423f34ccae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16サロゲートコードポイントはUnicodeスカラー値のセットに含まれていませんが、残念ながらHaskellによって有効な &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値として認められています。 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; で表すことはできません。この関数は、これらのコードポイントをUnicode置換文字（U + FFFD、 ' '）に再マップし、他のコードポイントは変更しないままにします。</target>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32（Cコンパイラは &lt;code&gt;201605L&lt;/code&gt; を定義）、または</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">IO ライブラリ用の UTF-32 コーデック</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">IO ライブラリ用の UTF-8 コーデック</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; をエンコードします。</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; エンコードします。</target>
        </trans-unit>
        <trans-unit id="a7eb34db31e9392459f63eb077bb3f212ab1af60" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; をエンコードします。</target>
        </trans-unit>
        <trans-unit id="f0c0cd4179d49f23f7a3bf2bc61e8abbec66b800" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; エンコードします。</target>
        </trans-unit>
        <trans-unit id="a56714f6e98c5c1a765732fe18ea00295cc6fbfa" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8は &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; をエンコードします。</target>
        </trans-unit>
        <trans-unit id="dae2c4b8b30ebe563e4e1fec9abe5214e0622a59" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8は &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; エンコードします。</target>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">単項否定。</target>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">単項否定。負の &lt;code&gt;Int#&lt;/code&gt; の範囲は正の範囲より1つ &lt;code&gt;negateInt#&lt;/code&gt; ため、最も負の数のnegateInt＃は恒等演算です。このように、 &lt;code&gt;negateInt#&lt;/code&gt; は常に独自の逆です。</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">式で使用される非バインドデータコンストラクターは、上記とまったく同じように動作します。ただし、&lt;em&gt;パターンで&lt;/em&gt;使用される非バインドデータコンストラクターは&lt;em&gt;据え置く&lt;/em&gt;ことができず、代わりにコンパイルを停止します。（実装に関しては、型チェッカーではなくリネーマーによって報告されます。）</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">同じ名前の結合されていない識別子は、同じ関数内であっても統一されることはなく、個別に表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">縛られていないチャンネル。</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">箱から出した配列</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">アンボックス化された不変配列。</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">アンボックス化された表現タイプ</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">アンボックス化された和データのコンストラクタ</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">アンボックス化された和型コンストラクタ</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">ボックス化されていない合計は、ヒープに合計を割り当てて値をポインターとして表すのではなく、ボックス化されていないタプルと同様に、それらのコンポーネントとして表されるという意味で「ボックス化解除」されます。これらの「コンポーネント」は、合計タイプの選択肢に依存します。ボックス化されていないタプルと同様に、ボックス化されていない合計は、持ち上げられたコンポーネントで遅延します。</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">アンボックス化されたタプルデータのコンストラクタ</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">アンボックス化されたタプル型のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">ボックス化されていないタプルは、複数の値を返す必要がある関数に使用されますが、完全なタプルの使用に通常関連するヒープ割り当てを回避します。ボックス化されていないタプルが返されると、コンポーネントは直接レジスターまたはスタックに入れられます。ボックス化されていないタプル自体には複合表現がありません。 &lt;code&gt;primops.txt.pp&lt;/code&gt; にリストされているプリミティブな操作の多くは、ボックス化されていないタプルを返します。特に、 &lt;code&gt;IO&lt;/code&gt; モナドと &lt;code&gt;ST&lt;/code&gt; モナドはボックス化されていないタプルを使用して、一連の操作中に不要な割り当てを回避します。</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">ボックス化されていないタプルは実際には &lt;code&gt;GHC.Exts&lt;/code&gt; によってエクスポートされません。それらは構文拡張です（&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;）。ボックス化されていないタプルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">アンボックス化されたタプルは、多値代用に使用することができます。例えば</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">ボックス化されていないタイプは、Cで使用する「生のマシン」タイプに対応します： &lt;code&gt;Int#&lt;/code&gt; （long int）、 &lt;code&gt;Double#&lt;/code&gt; （double）、 &lt;code&gt;Addr#&lt;/code&gt; （void *）など。これらのタイプの&lt;em&gt;基本操作&lt;/em&gt;（PrimOps）は、期待するかもしれません。たとえば、 &lt;code&gt;(+#)&lt;/code&gt; は &lt;code&gt;Int#&lt;/code&gt; での加算であり、私たち全員が知っており、愛しているマシン加算です。通常は1つの命令です。</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">チェックを外したアクセス</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">チェックを外した浮動小数点演算</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">不変配列のチェックを外した読み込み。ガベージを返したり、範囲外のアクセスでクラッシュしたりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">チェックされていない突然変異可能な配列の書き込み。ガベージを返したり、範囲外のアクセスでクラッシュしたりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">提案の実績やタイプのアプリケーションを表示しないことで、有効なホールフィットのリストを整理します。</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">Cプリプロセッサでシンボルを定義しない</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">マクロ ⟨symbol⟩ を通常の方法で定義解除します。</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">ユーザー定義コマンド「name」の定義を解除します（上記の&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="739d95b825e4aa989aff734d85f2e64f070e8d07" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt;, negated literals are desugared without &lt;code&gt;negate&lt;/code&gt;. That is, &lt;code&gt;-123&lt;/code&gt; stands for &lt;code&gt;fromInteger (-123)&lt;/code&gt; rather than &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. This makes &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt; a valid replacement for &lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">下に&lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; &lt;/a&gt;、否定リテラルはなし脱糖さ &lt;code&gt;negate&lt;/code&gt; 。つまり、 &lt;code&gt;-123&lt;/code&gt; は、 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; ではなく &lt;code&gt;fromInteger (-123)&lt;/code&gt; 表します。これにより、&lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; の&lt;/a&gt;有効な代替品になります。</target>
        </trans-unit>
        <trans-unit id="548a3041dcf33dfa2cebed472eb6cc52a0efe3ba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">下に&lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;*&lt;/code&gt; タイプでは、オペレータも名前もありませんが、それの略特別な構文である &lt;code&gt;Data.Kind.Type&lt;/code&gt; 。つまり、 &lt;code&gt;Either * Char&lt;/code&gt; ような式は、 &lt;code&gt;(*) Either Char&lt;/code&gt; ではなく &lt;code&gt;Either (*) Char&lt;/code&gt; として解析されます。</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">下に&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;*&lt;/code&gt; タイプでは、オペレータも名前もありませんが、それの略特別な構文である &lt;code&gt;Data.Kind.Type&lt;/code&gt; 。つまり、 &lt;code&gt;Either * Char&lt;/code&gt; ような式は、 &lt;code&gt;(*) Either Char&lt;/code&gt; ではなく &lt;code&gt;Either (*) Char&lt;/code&gt; として解析されます。</target>
        </trans-unit>
        <trans-unit id="6c0d27dce34085e806931a10af8a883394beb69a" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">下に&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;*&lt;/code&gt; タイプでは、オペレータも名前もありませんが、それの略特別な構文である &lt;code&gt;Data.Kind.Type&lt;/code&gt; 。つまり、 &lt;code&gt;Either * Char&lt;/code&gt; ような式は、 &lt;code&gt;(*) Either Char&lt;/code&gt; ではなく &lt;code&gt;Either (*) Char&lt;/code&gt; として解析されます。</target>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10以前のバージョンでは、システムI/Oライブラリは、ロケールセンシティブI/Oや行末変換をサポートしていません。これらのバージョンのGHCでは、このライブラリの関数はすべてUTF-8を使用しています。これは実際にはどのような意味があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">GHC 6.10以前のバージョンでは、システムI/Oライブラリは、ロケールセンシティブI/Oおよび行末変換をサポートしていません。これらのバージョンのGHCでは、このライブラリの関数はすべてUTF-8を使用しています。これは実際にはどのような意味があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">GHC の下では、書き換えルールは break (==)を特殊な breakByte の呼び出しに変換します。</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">Mac OS Xでは、デバッグ情報は実行可能ファイルとは別に保持されます。実行可能ファイルをコンパイルした後、 &lt;code&gt;dsymutil&lt;/code&gt; ユーティリティを使用してデバッグ情報を抽出し、デバッグアーカイブに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">ほとんどの場合、コンストラクタがすべてスコープ内にないデータ型のインスタンスを作成するためにスタンドアロン導出を使用することはできません。これは、導出されたインスタンスが裏でコンストラクタを使用するコードを生成してしまい、抽象化が崩れてしまうからです。</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="73d89b3a81eb250a4b44258aed0e8fed46b29f5a" translate="yes" xml:space="preserve">
          <source>Underlying monadic value</source>
          <target state="translated">根本的なモナドの価値</target>
        </trans-unit>
        <trans-unit id="c982cc09160648fab8b183af5c0c2149ea73000b" translate="yes" xml:space="preserve">
          <source>Underlying untyped Template Haskell expression</source>
          <target state="translated">型付けされていないテンプレートHaskell式の下にあるもの</target>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">展開されたByteStrings</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">コンストラクタのアプリケーションを展開</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">残念ながら、DWARFはGHCが生成するコードを完全に説明するのに十分な表現力を備えていません。これは、GHCがさまざまな可能な発信元の場所からいくつかを選択することを強制される回線情報の場合に最も明白です。これにより、従来の統計プロファイリングツールではDWARF情報の有用性が制限されます。プロファイリングには、拡張デバッグ情報を使用することをお勧めします。以下の&lt;em&gt;プロファイリングの&lt;/em&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">残念ながら違います。まだ実装していません。問題のあるモジュールをGHCiにロードする前に手動でコンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">Unicode一般カテゴリ(UnicodeDataテーブルの2列目)は、Unicode標準(特にUnicode文字データベース)に記載されている順に並べられています。</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">Unicodeローマ数字も「数字」です。</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">ユニコード代替</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">Unicodeの文字は、文字、数字、マーク、句読点、記号、セパレータ(スペースを含む)、その他(制御文字を含む)に分けられます。</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">ユニコード符号化/復号化</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">ユニコードエンコーディング</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">ユニコード一般分類</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="28994769bba962bb066d22d1fcd75c46baf1f910" translate="yes" xml:space="preserve">
          <source>UnicodeSubsetBitfield</source>
          <target state="translated">UnicodeSubsetBitfield</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">一方向性の同義語はパターンコンテキストでのみ使用でき、以下のように定義されます。</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">新しいモナドへの &lt;code&gt;callCC&lt;/code&gt; 操作の均一な解除。このバージョンは、継続に入ると元の出力履歴にロールバックします。</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">新しいモナドへの &lt;code&gt;callCC&lt;/code&gt; 操作の均一な解除。このバージョンは、継続に入ると元の状態にロールバックします。</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">無人データ型</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">データ型コンストラクタのためのユニークなインデックスで、プログラムのテキストで指定された順に1から数えます。</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">ユニークなオブジェクト</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">ユニット:引数を持たないコンストラクタで使用されます。</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">ユニバーサルタイム</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">ユニバーサルコンバイン機能</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">ユニックスシステム</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">他に文書化されていない限り</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="5b45d2b7d96fbef96a9bc758815c76e0e2e71a5f" translate="yes" xml:space="preserve">
          <source>UnliftedNewtypes</source>
          <target state="translated">UnliftedNewtypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;とは異なり、&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;は、右側に関数型を含むデータ型では使用できません。</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt;とは異なり、&lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; に&lt;/a&gt;は含まれません。この決定の理論的根拠は、用語レベルのパターン名とは異なり、タイプ名はドキュメントの目的で明示的に選択されることが多いため、タイプ名にアンダースコアを使用すると、ドキュメントが読みにくくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">プログラムを不完全にし、評価時にエラーを生成する&lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;とは異なり、型シグネチャの穴がそうである必要はありません。型チェッカーは、（ほとんどの場合）型シグネチャの有無にかかわらずバインディングを型チェックできます。部分的な型シグネチャは、2つの両極端の間のギャップを埋めます。プログラマは、型のどの部分に注釈を付け、どの部分を型チェッカーに任せて推論するかを選択できます。</target>
        </trans-unit>
        <trans-unit id="0b99ca092888b44bba510df4577b6b4d2d84d797" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;typed_holes#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">プログラムを不完全にし、評価時にエラーを生成する&lt;a href=&quot;typed_holes#typed-holes&quot;&gt;型付き穴&lt;/a&gt;とは異なり、型署名の穴の場合はそうである必要はありません。型チェッカーは、（ほとんどの場合）型署名の有無にかかわらずバインディングを型チェックすることができます。部分的な型シグネチャは、2つの極値間のギャップを埋めます。プログラマは、型のどの部分に注釈を付け、どちらを型チェッカーに任せて推測するかを選択できます。</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; とは異なり、このオプションでは、パッケージ⟨pkg⟩が結果の実行可能ファイルまたは共有オブジェクトにリンクされることはありません。</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; とは異なり、この関数は引数のUnicodeデコードを行いません。OSによってプログラムに渡された正確なバイトを取得します。引数をテキストとして解釈するには、いくつかのUnicodeデコードを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="897acea06a039f9d84c343986efe70490281cb9e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; とは異なり、この関数は引数のUnicodeデコードを行いません。OSによってプログラムに渡された正確なバイトを取得します。引数をテキストとして解釈するには、Unicodeデコードを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="05566e43d5c34bd670cdfbd05fbe866ec3e61186" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; とは異なり、この関数は引数のUnicodeデコードを行いません。OSによってプログラムに渡された正確なバイトを取得します。引数をテキストとして解釈するには、Unicodeデコードを適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; とは異なり、これを使用すると、要素を強制せずに取得できます。例えば、シーケンスの5番目の要素を挿入するために &lt;code&gt;xs&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; キーで &lt;code&gt;k&lt;/code&gt; は、あなたが使用することができます</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; タイプのコンストラクターは &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; にマップされません。これらは次のように直接定義されます。</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; は、コンパイラーがデータコンストラクターフィールドに対して選択する厳密さを参照します。これは、ソースコードで記述されているものとは異なる場合があります。詳細については、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; は、コンパイラーがデータコンストラクターフィールドに対して選択する厳密さを参照します。これは、ソースコードで記述されているものとは異なる場合があります。詳細については、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; とは異なり、この機能は失敗しません。それが返す &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の機能がfalseに存在しないか、または設定されている場合は、と返し &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="255633d21e505289c6e8c6e3a244c4a2c1e30045" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; とは異なり、この機能は失敗しません。機能がないかfalseに設定されている場合は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b6ac906b2e87deb1331972ed52f86a854e2d6b08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; とは異なり、この機能は失敗することはありません。機能がないかfalseに設定されている場合は &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; とは異なり、再帰関数で &lt;code&gt;INLINABLE&lt;/code&gt; プラグマを使用することは問題ありません。主な理由は、後で &lt;code&gt;SPECIALISE&lt;/code&gt; 使用できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">Cの &lt;code&gt;printf(3)&lt;/code&gt; とは異なり、この &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; のフォーマットは引数の型によって決まります。書式はタイプ固有です。「すぐに &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 」printfでフォーマットされたタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 宣言に添付された &lt;code&gt;deriving&lt;/code&gt; 宣言とは異なり、GHCはデータ型の形式を制限しません。代わりに、GHCは指定されたクラスに適切なボイラープレートコードを生成し、タイプチェックするだけです。タイプエラーがある場合は、それが問題です。（型エラーがある場合、GHCは問題のあるコードを表示します。）</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">異なり &lt;code&gt;deriving&lt;/code&gt; に取り付けられた宣言 &lt;code&gt;data&lt;/code&gt; 宣言、インスタンスは、データ・タイプ（あなたはまた、使用想定より特異的であり得る&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; を&lt;/a&gt;、&lt;a href=&quot;#instance-rules&quot;&gt;インスタンスコンテキストの緩和ルール&lt;/a&gt;）。例を考えます</target>
        </trans-unit>
        <trans-unit id="b63d1a43428a8154e612e52025ecfc75af2b7757" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;instances#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;instances#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 宣言に添付された &lt;code&gt;deriving&lt;/code&gt; 宣言とは異なり、インスタンスはデータ型よりも具体的である可能性があります（&lt;a href=&quot;instances#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;instances#instance-rules&quot;&gt;インスタンスコンテキストのリラックスルール&lt;/a&gt;も使用していると仮定します）。たとえば考えてみてください</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">Haskell-98スタイルのデータ型宣言とは異なり、「 &lt;code&gt;data Set a where&lt;/code&gt; 」ヘッダーの型変数にはスコープがありません。確かに、代わりに親切な署名を書くことができます：</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">式や宣言型のシグネチャとは異なり、パターン型のシグネチャは暗黙的に一般化されていません。&lt;em&gt;パターンバインディング&lt;/em&gt;のパターンは、既にスコープ内にある型変数のみを言及できます。例えば：</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">異なり &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 、のインスタンス &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; を指す &lt;code&gt;encode'&lt;/code&gt; ではなく &lt;code&gt;encode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; 形式の通常の宣言スプライスとは異なり、宣言の準引用符は宣言グループのブレークを引き起こしません。詳細については、&lt;a href=&quot;#th-syntax&quot;&gt;構文&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">通常の宣言スプライスとは異なり、宣言準引用符は中断を引き起こしません。これらの準クォータは、残りの宣言グループが処理される前に展開され、生成された宣言は周囲の宣言グループにマージされます。その結果、宣言の &lt;code&gt;reify&lt;/code&gt; からreifyによって見られる型環境には、準クォータの宣言グループからのものが含まれません。</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">シグネチャファイルで宣言されたエンティティのみがスコープに入る他の宣言とは異なり、実装からのインスタンスは、たとえシグネチャファイルで宣言されていなくても、常にスコープに入ります。これは、モジュールがシグネチャに対してはタイプチェックをしても、一致する実装に対してはタイプチェックをしないことを意味します。このような状況を避けるには、シグネチャを持つパッケージの中では決して孤児インスタンスを定義しないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">他の削除機能とは異なり、この機能は、読み取り専用とマークされたファイルや、パーミッションのために削除不可能にされたファイルの削除も試みます。その結果、削除が不完全な場合、残りのファイルのパーミッションや属性が変更される可能性があります。ディレクトリ内にハードリンクがある場合、関連するすべてのハードリンクのパーミッションが変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">他の同様の名前の関数とは異なり、 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; はWin32 APIからの &lt;code&gt;SearchPath&lt;/code&gt; を使用しません。したがって、Windowsでのこの関数の動作は、Windows以外のプラットフォームでの動作と同じです。</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">通常のモジュールとは異なり、署名の定義済みエンティティには、ローカルの &lt;code&gt;hsig&lt;/code&gt; ファイルに記述されたエンティティだけでなく、継承された署名からの &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; れます（-package-id⟨unit-id⟩フラグから推測）。これらのエンティティは、ローカルの &lt;code&gt;hsig&lt;/code&gt; ファイルをタイプチェックするときにスコープ内とは見なされませんが、署名をインポートするすべてのモジュールまたは署名によってインポートできます。このルールの1つの例外は、以下で説明するエクスポートリストです。</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">異なり &lt;code&gt;forall&lt;/code&gt; フォーム、変数タイプ &lt;code&gt;a&lt;/code&gt; から &lt;code&gt;f&lt;/code&gt; の署名がオーバースコープされていない &lt;code&gt;f&lt;/code&gt; の式（S）です。パターンシグネチャによってバインドされた型変数 &lt;code&gt;aa&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の方程式の右辺をスコープとしています。（したがって、異なるタイプの変数を使用する必要はありません。使用して同等であろう。） &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b933a24b64cdbef2c38c5866a81b259e2fd9806b" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">異なり &lt;code&gt;forall&lt;/code&gt; フォーム、変数タイプ &lt;code&gt;a&lt;/code&gt; から &lt;code&gt;f&lt;/code&gt; の署名がオーバースコープされていない &lt;code&gt;f&lt;/code&gt; の式（S）です。パターンシグニチャによってバインドされた型変数 &lt;code&gt;aa&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; の方程式の右辺にスコープされます。（したがって、異なるタイプの変数を使用する必要はありません。使用して同等であろう。） &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">関連する型ファミリー宣言自体とは異なり、デフォルトインスタンスの型変数は親クラスの型変数とは独立しています。</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; のデフォルトの定義とは異なり、これは0に定義されているので、可能な限り推奨されます。</target>
        </trans-unit>
        <trans-unit id="865d4045d80f8564c6ad3ca37c512ab3a0dd4aa4" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">前の例とは異なり、現在、&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;を使用してあいまいさを手動で解決することはできません。</target>
        </trans-unit>
        <trans-unit id="77dcfd6345308258ebb060f9ef483bfd2e2232d6" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">前の例とは異なり、現在、&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;を使用してあいまいさを手動で解決することはできません。</target>
        </trans-unit>
        <trans-unit id="9b6cc89d8ca2d4d98a8cd94a124ce20e53b59f2e" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;. It can alternatively be:</source>
          <target state="translated">通常のデータ定義とは異なり、データファミリの結果の種類は &lt;code&gt;Type&lt;/code&gt; である必要はありません。あるいは、次のようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">通常のデータ定義とは異なり、データファミリーの結果の種類は &lt;code&gt;Type&lt;/code&gt; である必要はありません。代わりに、種類変数（&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; を使用&lt;/a&gt;）にすることもできます。ただし、データインスタンスの種類は &lt;code&gt;Type&lt;/code&gt; で終わる必要があります。</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">ありそうもない:-) GHCに与える有用なbe-more-paranoidオプションは &lt;code&gt;-dcore-lint&lt;/code&gt; -dcore-lintオプションです。これにより、各コアからコアへの変換パスの後に、「lint」パスがエラー（特にタイプエラー）をチェックします。 &lt;code&gt;-dcore-lint&lt;/code&gt; で実行します。コンパイル時間は約5％かかります。</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">セマフォのロックを解除します。</target>
        </trans-unit>
        <trans-unit id="1cd4113e1e43e9853f32e740b4dd9283a784af37" translate="yes" xml:space="preserve">
          <source>Unlocks a given range in a file handle, To unlock an entire file use 0xFFFFFFFFFFFFFFFF for size and 0 for offset.</source>
          <target state="translated">ファイルハンドルの指定した範囲のロックを解除します。ファイル全体のロックを解除するには、sizeに0xFFFFFFFF、offsetに0を指定します。</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">ベクトルの要素をタプルに展開します。#</target>
        </trans-unit>
        <trans-unit id="f45849052f775de0ca7ba2014ab45df8d98aa51a" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id16&quot; id=&quot;id15&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">コンストラクタフィールドのアンパックは、&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id16&quot; id=&quot;id15&quot;&gt; [1]&lt;/a&gt;と組み合わせてのみ使用する必要があります。これは、アンフォールディングをコンパイラに公開して、リボックスをできるだけ頻繁に削除できるようにするためです。例えば：</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">展開フィールドをできるだけ頻繁に削除できるように展開をコンパイラーに公開するには、コンストラクターフィールドのアンパックを&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt;と組み合わせてのみ使用する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="186ac86a8a426917ea872e83fd56ac894b4b2cf2" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt;1&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">コンストラクタフィールドのアンパックは、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt; 1&lt;/a&gt;と組み合わせてのみ使用する必要があります。これは、アンフォールディングをコンパイラに公開して、リボックスをできるだけ頻繁に削除できるようにするためです。例えば：</target>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">アクティブなタイムアウトの登録を解除します。</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">登録されていないコンパイルは、GHCを新しいマシンに移植するときに便利です。これは、必要なツールを &lt;code&gt;gcc&lt;/code&gt; 、 &lt;code&gt;as&lt;/code&gt; 、 &lt;code&gt;ld&lt;/code&gt; などに減らし、さらに、登録されていないコンパイルを取得するために記述する必要があるプラットフォーム固有のコードの量を減らすためです。行くことは通常かなり小さいです。</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">登録されていないコンパイルはコンパイル時に選択できません。詳細はGHC構築ガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">安全ではない &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; インデックス（添え字）演算子、0から始まり、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; を返すこれは境界チェックを省略します。これは、境界が他の方法でチェックされることを保証するという付随的な義務がプログラマーにあることを意味します。</target>
        </trans-unit>
        <trans-unit id="0dd91a3653dbdf62b055e276b77befee135ac9fe" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">安全でない &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; インデックス（添え字）演算子、0から始まり、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; を返します。これにより、境界チェックが省略されます。つまり、他の方法で境界がチェックされるようにする義務がプログラマーにあります。</target>
        </trans-unit>
        <trans-unit id="0e304ea4f61d467cda0009f4bab7e4e8c2092dcc" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">安全でない &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; インデックス（添え字）演算子、0から始まり、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; を返します。これにより、境界チェックが省略されます。つまり、他の方法で境界がチェックされるようにする義務がプログラマーにあります。</target>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">安全でない &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">安全でないAPIのみ。</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">安全でないAPI。</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">安全でない IO 操作</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 間の安全でない変換。これは何もせず、8ビットのChars&amp;gt; '255'に静かに切り捨てます。これは、ByteStringの構築に便利なように提供されています。</target>
        </trans-unit>
        <trans-unit id="051c814b3361ac5063677f84f8043980e0deb4d4" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の間の安全でない変換。これはノーオペレーションであり、8ビット文字&amp;gt;「255」にサイレントに切り捨てられます。これは、ByteString構築の便宜のために提供されています。</target>
        </trans-unit>
        <trans-unit id="8241dd25799379ccded94491ee5eb28c3782621d" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の間の安全でない変換。これはノーオペレーションであり、8ビット文字&amp;gt;「255」にサイレントに切り捨てられます。これは、ByteString構築の便宜のために提供されています。</target>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">安全でない変換コード</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">10進数の変換が安全ではありません。</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">安全でない機能</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">安全でない一般的な結合機能</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">安全でない低レベル操作</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">安全でない操作</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">安全ではない、マシンレベルのアトミックな比較とスワップ。</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">安全ではない、マシンレベルのアトミック比較と配列内の要素のスワップ。</target>
        </trans-unit>
        <trans-unit id="da875dda0af919ad5cb1b82f3bb406408186e93d" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array. See the documentation of &lt;code&gt;casArray#&lt;/code&gt;.</source>
          <target state="translated">配列内の要素に対する安全でないマシンレベルのアトミックコンペアアンドスワップ。 &lt;code&gt;casArray#&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="23605c5b9ae4700123f875a656e77bc71e5d4742" translate="yes" xml:space="preserve">
          <source>Unsafe.Coerce</source>
          <target state="translated">Unsafe.Coerce</target>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="35f4214602b8699ce1216c3d3a7141e959379206" translate="yes" xml:space="preserve">
          <source>Unsafely convert an untyped code representation into a typed code representation.</source>
          <target state="translated">型付けされていないコード表現を型付けされたコード表現に非安全に変換します。</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">STMモナドで安全でないIOを実行します。注意:これは非常に危険な行為です。</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">特定のオプションの設定を解除します。使用可能なオプションのリストについては、&lt;a href=&quot;#ghci-set&quot;&gt;：setおよび：setiコマンド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">符号なし整数型。</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">符号なし整数型</target>
        </trans-unit>
        <trans-unit id="0e683d0c1771359f194744b32634eb2816c4aba7" translate="yes" xml:space="preserve">
          <source>Unsound</source>
          <target state="translated">Unsound</target>
        </trans-unit>
        <trans-unit id="1afd000d072edf5c9a0c898690bcf0eb48c73be4" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Unsound Sound</source>
          <target state="translated">ウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウン</target>
        </trans-unit>
        <trans-unit id="ad6bfcbce4213c08e4e664178dc9b7272c478b19" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Sound</source>
          <target state="translated">ウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウン</target>
        </trans-unit>
        <trans-unit id="d5fc19d20b078f2546ad7041f570431236521a3c" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound</source>
          <target state="translated">ウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウンウン</target>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">不安定なスナップショットリリースの名前は &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; です。ここで、 &lt;code&gt;YYYYMMDD&lt;/code&gt; は、スナップショットが作成されたソースの日付です。たとえば、 &lt;code&gt;6.7.20040225&lt;/code&gt; は、 &lt;code&gt;6.8&lt;/code&gt; ブランチを作成する前のHEADのスナップショットです。</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">状態モナド計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">状態モナド計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">状態モナド計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">状態モナド計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">ライターの計算を（結果、出力）ペアとしてアンラップします。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">ライターの計算を（結果、出力）ペアとしてアンラップします。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">ライターの計算を（結果、出力）ペアとしてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">ライターの計算を（結果、出力）ペアとしてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">ライターの計算を（結果、出力）ペアとしてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; の逆。）</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">ライターの計算をアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWS計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RWST計算を関数としてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">累積計算を（結果、出力）ペアとしてアンラップします。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; の逆です。）</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">累積計算をアンラップします。</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">一連のペアを解凍します。</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">文字を指定してソース位置を更新します。文字が改行（ '\ n'）またはキャリッジリターン（ '\ r'）の場合、行番号は1ずつ増加します。文字がタブ（ 't'）の場合、列番号は最も近い8 'に増加します。番目の列、つまり &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; 。他のすべての場合、列は1ずつ増分されます。</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">指定されたマイクロ秒数で起動するアクティブタイムアウトを更新します。</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">「 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; 」を使用して、 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; に対して事前に書き込まれた正確なバイト数を計算します。以下の場合には &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; を書き込み、レポートゼロであろう一方、書き込まれたバイト &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; のレポート1バイト。</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; &lt;/a&gt;プリプロセッサとして使用するプログラムを選択します。呼び出されると、「cmd」プリプロセッサのコマンドラインで少なくとも3つの引数が与えられます。最初の引数は元のソースファイルの名前、2番目は入力を保持するファイルの名前、3番目は「cmd」が出力を書き込むファイルの名前。</target>
        </trans-unit>
        <trans-unit id="0b4372542a118b48b81e477bf6a20ba6b09913d2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">使用&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;ルールが発射されているか詳細に確認してください。&lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt;を追加すると、さらに詳細なリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="e56a9d5c91f6126fe3042d4f398b5871676f85bf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">&lt;a href=&quot;../debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt;を使用して&lt;em&gt;、このモジュールで&lt;/em&gt;定義さ&lt;em&gt;れ&lt;/em&gt;ているルールを確認し&lt;em&gt;ます&lt;/em&gt;。これには、特殊化パスによって生成されたルールが含まれますが、他のモジュールからインポートされたルールは除外されます。</target>
        </trans-unit>
        <trans-unit id="b11f0cc2df4b4a340cba4cb75322d6acc2d731d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;を使用して、実行されているルールを確認します。&lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt;を追加すると、より詳細なリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">使用&lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;ルールが発射されているか詳細に確認してください。&lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt;を追加すると、さらに詳細なリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">&lt;em&gt;このモジュールで&lt;/em&gt;定義さ&lt;em&gt;れ&lt;/em&gt;ている&lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt;を確認するには、-ddump-rulesを使用し&lt;em&gt;ます&lt;/em&gt;。これには、スペシャライゼーションパスによって生成されたルールが含まれますが、他のモジュールからインポートされたルールは含まれません。</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;を使用して、どのルールが実行されているかを確認します。&lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; &lt;/a&gt;を追加すると、より詳細なリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を使用し、割り込み可能な操作を避けます。これを行うには、割り込み可能な操作を知る必要があります。特定のライブラリ関数について、内部で割り込み可能な操作を呼び出すかどうかを知ることは不可能です。そのため、代わりに、割り込みが保証されない操作のリストを以下に示します。</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; を使用します。これは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; のスコープ中に呼び出された割り込み可能な操作が短時間しかブロックできないことを保証できない限り、通常はお勧めできません。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; は、プログラムをデッドロックにしてユーザーの割り込みに応答しないようにするための良い方法です。</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">この問題を回避するには、 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; を使用して、&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;から &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; の動作を取得します。</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; を使用して、&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;から &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; の動作を取得します。</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">利用 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; の任意の関数にプラグマとして &lt;code&gt;foo&lt;/code&gt; 呼び出し &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を。呼び出しがインライン化されている場合、I / Oは複数回実行される可能性があります。</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">利用 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; の任意の関数にプラグマとして &lt;code&gt;foo&lt;/code&gt; 呼び出し &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を。呼び出しがインライン化されている場合、I / Oは複数回実行される可能性があります。</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">利用 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; の任意の関数にプラグマとして &lt;code&gt;foo&lt;/code&gt; 呼び出し &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を。呼び出しがインライン化されている場合、I / Oは複数回実行される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">実行可能ファイルで&lt;strong&gt;ストリップ&lt;/strong&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">LLVM経由でコンパイルするのではなく、GHCの&lt;a href=&quot;codegens#native-code-gen&quot;&gt;ネイティブコードジェネレーターを&lt;/a&gt;使用します。 &lt;code&gt;-fasm&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">通常のモジュールでGHCiの拡張デフォルトルールを使用します。</target>
        </trans-unit>
        <trans-unit id="559c9b9fd04f1e3041713b6f2cf9e35cff9d879f" translate="yes" xml:space="preserve">
          <source>Use GHCi's extended default rules in a normal module.</source>
          <target state="translated">GHCiの拡張デフォルトルールを通常のモジュールで使用します。</target>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">STMを使用します。トランザクションは常に完全に実行されているか、全く実行されていないかのどちらかであるため、トランザクションは、非同期的な(実際には同期的な)例外が発生した場合に、状態に対する不変性を維持するための良い方法です。</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt; を使用する</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; な証拠として使用します。</target>
        </trans-unit>
        <trans-unit id="746a26a0ae875d24d6db1c324d9b7183d086ea3c" translate="yes" xml:space="preserve">
          <source>Use a POSIX I/O Sub-System</source>
          <target state="translated">POSIX I/Oサブシステムの使用</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">大きなヒープを使用してください!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">最古の世代を収集するために圧縮アルゴリズムを使用します。デフォルトでは、最も古い世代はコピーアルゴリズムを使用して収集されます。圧縮アルゴリズムはコピーアルゴリズムよりも遅くなりますが、メモリ使用量の節約にはかなりの効果があります。</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">ApplicativeDoのために、より遅いがより良いアルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">タイトルには小箱を使用します。</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">辞書セレクターには特需トランスを使用します。</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">辞書セレクタに特需トランスを使用します。デフォルトでは常に有効になっています。</target>
        </trans-unit>
        <trans-unit id="b25b503bf1e131032b9194d35870945071ac8245" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Behaviour is unconditionally enabled starting with 9.2</source>
          <target state="translated">辞書セレクタに特別な要求変換を使用する。9.2から無条件に有効になります。</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">のように、レコード式に明示的な型署名を使用します。</target>
        </trans-unit>
        <trans-unit id="292fc35c66c20d657884010ef14bdc8af40861f8" translate="yes" xml:space="preserve">
          <source>Use as: s -&amp;gt; atomicCasAddrAddr# location expected desired s</source>
          <target state="translated">次のように使用します。s-&amp;gt; atomicCasAddrAddr＃の場所が必要です</target>
        </trans-unit>
        <trans-unit id="ff515038361d9bf7c3d5fdf1f946a7c3b1673ee7" translate="yes" xml:space="preserve">
          <source>Use as: s -&amp;gt; atomicCasWordAddr# location expected desired s</source>
          <target state="translated">次のように使用します。s-&amp;gt; atomicCasWordAddr＃の場所が必要です</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">エラーメッセージに色を使う</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">GHCiコマンド履歴ファイル &lt;code&gt;.ghci-history&lt;/code&gt; には現在のディレクトリを使用します。</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">間値の小数点表記を使用し &lt;code&gt;0.1&lt;/code&gt; と &lt;code&gt;9,999,999&lt;/code&gt; そうでなければ、科学表記法。</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; から入力を読み取り、ファイル形式の相互作用を使用します。</target>
        </trans-unit>
        <trans-unit id="babd2ff76089a3d1f8aa9f2a697eb17aef342e31" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; から入力を読み取り、ファイルスタイルの対話を使用します。</target>
        </trans-unit>
        <trans-unit id="a9390e87846d6a93528abe67fa5bb72b908f7c7f" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; から入力を読み取り、ファイルスタイルの相互作用を使用します。</target>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">与えられたファイルから入力を読み取る、ファイルスタイルのインタラクションを使用します。</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">外部から呼び出したいHaskell関数をエクスポートするには、外部エクスポート宣言を使用します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リソース制限として使用します。 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リソース制限として使用します。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リソース制限として使用します。 &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; を使用して、単純なプロファイリングメカニズムとして使用します。</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; を使用して、単純なプロファイリングメカニズムとして使用します。</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; を使用して、単純なプロファイリングメカニズムとして使用します。</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">⟨gen⟩以降の世代では、並列 GC 2011 でロードバランシングを使用します。⟨gen⟩ を省略すると、ロードバランシングが完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">より多くのメモリを使用してください。</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">このタイプの使用はお勧めしません。以下の等価性に注意してください。</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">⟨gen⟩以降の世代では、パラレルGCを使用します。⟨gen⟩を省略すると、シーケンシャルGCに戻り、パラレルGCを完全にオフにします。</target>
        </trans-unit>
        <trans-unit id="1de741d6efbec754e80e7e93becb988786a18010" translate="yes" xml:space="preserve">
          <source>Use platform native Sub-System. For unix OSes this is the same as IoPOSIX, but on Windows this means use the Windows native APIs for I/O, including IOCP and RIO.</source>
          <target state="translated">プラットフォームネイティブのサブシステムを使う。ユニックスOSではIoPOSIXと同じですが、WindowsではIOCPやRIOなどのI/O用WindowsネイティブAPIを使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">posix setgidを使用して子プロセスのグループIDを設定します。</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">posix setsidを使用して、新しいセッションで新しいプロセスを開始します。</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">posix setuidを使用して子プロセスのユーザIDを設定します。</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">以前のパラメーターを使用します。デフォルトでは、PostScriptグラフは水平方向と垂直方向の両方に自動的にスケーリングされ、ページ全体に表示されます。ただし、プレゼンテーションで使用する一連のグラフを準備する場合、以前のグラフと同じ縮尺、網かけ、順序を使用して新しいグラフを描くと便利な場合があります。 &lt;code&gt;-p&lt;/code&gt; フラグの前回の実行によって決定されたパラメータ使用して描画するグラフを引き起こす &lt;code&gt;hp2ps&lt;/code&gt; 上の &lt;code&gt;file&lt;/code&gt; 。これらは &lt;code&gt;file@.aux&lt;/code&gt; から抽出されます。</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">静的なHaskellライブラリを使用する</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">厳格さの注釈を使用します。</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; が端末でない場合でも、可能な限り端末スタイルの対話を使用してください。</target>
        </trans-unit>
        <trans-unit id="6c701d48b2ddc2ad9f38319eaef995257ab48d8b" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; および/または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; が端末でない場合でも、可能な限り端末スタイルの対話を使用してください。</target>
        </trans-unit>
        <trans-unit id="702fcd88a46378df6ea71ccb1190fa14cbe9bac6" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; が端末でない場合でも、可能な限り端末スタイルの対話を使用してください。</target>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codegens#native-code-gen&quot;&gt;ネイティブコードジェネレーターを&lt;/a&gt;使用する</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; ブロックで反駁可能なパターンを &lt;code&gt;Monad.fail&lt;/code&gt; する場合は、従来のMonad.fail関数の代わりに &lt;code&gt;MonadFail.fail&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6d4d3a4fd4f7e397d42bb7af957939ab364ef83c" translate="yes" xml:space="preserve">
          <source>Use the C code generator. Only supposed in unregisterised GHC builds.</source>
          <target state="translated">Cコードジェネレータを使用してください。未登録の GHC ビルドでのみ使用することになっています。</target>
        </trans-unit>
        <trans-unit id="3b6c94c81606492d87dce6da844389bd6d123781" translate="yes" xml:space="preserve">
          <source>Use the Haskell 2010 language variant.</source>
          <target state="translated">Haskell 2010 の言語バリアントを使用します。</target>
        </trans-unit>
        <trans-unit id="66e695e59e51ae41d59efa1f0452144c08e51e4d" translate="yes" xml:space="preserve">
          <source>Use the Haskell 98 language variant.</source>
          <target state="translated">Haskell 98の言語バリアントを使用します。</target>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">OSのアフィニティ機能を使用して、OSスレッドをCPUコアに固定しようとします。</target>
        </trans-unit>
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">コンパイラフラグ &lt;code&gt;-fno-cse&lt;/code&gt; を使用して、モジュールで一般的な部分式の削除が実行されないようにします。これにより、分離することを意図していた2つの副作用が組み合わされる可能性があります。良い例は、複数のグローバル変数を使用することです（以下の例の &lt;code&gt;test&lt;/code&gt; のように）。</target>
        </trans-unit>
        <trans-unit id="7fe585682db3ba3c0e51a716fd4585abd8b10372" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">デバッグフラグ&lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;を使用して、実行されたルールを確認します。さらに情報が必要な場合は、&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; で&lt;/a&gt;個々のルールの実行が表示され、&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; で&lt;/a&gt;再書き込みの前後のコードがどのように表示されるかも表示されます。</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">デバッグフラグ&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;を使用して、実行されたルールを確認します。さらに情報が必要な場合、&lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;は個々のルールの実行を示し、&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;は書き換えの前後のコードの外観も示します。</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">デバッグランタイムを使用する</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ネイティブコードジェネレーターでのレジスター割り当てには、グラフカラーリングレジスターアロケーターを使用します。&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">ネイティブ コード ジェネレーターで反復合体グラフのカラーリング レジスタ アロケーターを使用します。</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">入力と出力の両方でネイティブの改行表現を使用します。</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">新しい cfg ベースのブロックレイアウトアルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">「ファイル」または &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; のパッケージ環境を使用します。設定されている場合 &lt;code&gt;-&lt;/code&gt; パッケージ環境は読み込まれません。</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">私用エスケープメカニズムを使用して、不正なシーケンスがラウンドトリップされることを許可しようとします。</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">実行可能プログラムでランタイムフラグ&lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;を使用して、 &lt;code&gt;-with-rtsopts&lt;/code&gt; で設定されたオプションを確認します。</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">指定されたパッケージ環境を使用します。</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">付属のハンドルを使用します。</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">スレッドランタイムを使用する</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">以下のように、レコード更新にプッシュされるタイプを使用します。</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">プロセスを作成する際には、windows CREATE_NEW_CONSOLE フラグを使用してください。</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">プロセスを作成する際にwindowsのDETACHED_PROCESSフラグを使用します。</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">この関数は、バインドされたスレッドの使用によるパフォーマンスの低下を実際に観察したまれな場合に&lt;em&gt;のみ&lt;/em&gt;使用してください。メインスレッドをバインドする必要がなく、同時実行性を&lt;em&gt;多用&lt;/em&gt;するプログラム（Webサーバーなど）では、その &lt;code&gt;main&lt;/code&gt; アクションを &lt;code&gt;runInUnboundThread&lt;/code&gt; でラップする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">この関数は、JSONやHTMLのようなテキストベースのフォーマットのための効率的なエンコーダーを実装するために使用します。</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数を使用して、小さめの（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を作成するか、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; によって生成されたチャンクと共有されないことを保証する必要がある場合。</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数を使用して、小さめの（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を作成するか、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; によって生成されたチャンクと共有されないことを保証する必要がある場合。</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">この戦略を使用して、生成された直後にチャンクが破棄される遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を生成します。たとえば、それらを生成してネットワークソケットに書き込むだけの場合。</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">この戦略を使用して、チャンクが1つのガベージコレクションで存続する可能性が高い遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を生成します。この戦略は、メモリが過剰にこぼれるのを避けるために、半分未満しか満たされていないバッファーをトリミングします。</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">箱なしタイプ(GHCの拡張機能)を使用します。</target>
        </trans-unit>
        <trans-unit id="b123b85d967a1500e8666eb4e128ba145310fa7f" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">式、タイプ、および種類を出力するときは、Unicode構文を使用してください。&lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">式、型、種類を出力するときは、Unicode構文を使用してください。&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="1217e1edd93d0feba5136f9afad7e849709839fd" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">式、タイプ、および種類を出力するときは、Unicode構文を使用してください。&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="cc21fce3863bcaec7184d0faa94b76871818b8de" translate="yes" xml:space="preserve">
          <source>Use whitespace to determine whether the minus sign stands for negation or subtraction.</source>
          <target state="translated">空白を利用して、マイナス記号が否定を表しているのか、引き算を表しているのかを判断します。</target>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; で使用</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; で使用する</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">⟨cmd⟩ を C コンパイラとして使用します。</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">⟨cmd⟩をCコンパイラとして使用します。</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">⟨cmd⟩をCプリプロセッサとして使用（ &lt;code&gt;-cpp&lt;/code&gt; のみ）</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">Cプリプロセッサとして⟨cmdwithを使用します（ &lt;code&gt;-cpp&lt;/code&gt; のみ）。</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">DLLジェネレータとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">DLLジェネレータとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">LLVMコンパイラとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">LLVMコンパイラとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">LLVMオプティマイザとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">LLVMオプティマイザとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">アセンブラとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">アセンブラには⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="bb31dfc0c69b643471fc895b68566295b7824e3e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">libtoolのコマンドとして⟨cmd⟩を使用します（&lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt;のみ）。</target>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtoolのコマンドとして⟨cmd⟩を使用します（ &lt;code&gt;-staticlib&lt;/code&gt; のみを使用）。</target>
        </trans-unit>
        <trans-unit id="71a83bd18619d2dc927e0bb5ca8f99a89d38bbb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">⟨cmd⟩を外部インタープリターコマンドとして使用します（&lt;a href=&quot;ghci#external-interpreter&quot;&gt;別のプロセスでのインタープリターの実行を&lt;/a&gt;参照）。デフォルト： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 場合&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; が&lt;/a&gt;有効になっている、 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 場合&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; が&lt;/a&gt;有効になっている、または &lt;code&gt;ghc-iserv&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">⟨cmd⟩を外部インタープリターコマンドとして使用します（「&lt;a href=&quot;ghci#external-interpreter&quot;&gt;インタープリターを別のプロセスで実行する&lt;/a&gt;」を参照）。デフォルト： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 場合 &lt;code&gt;-prof&lt;/code&gt; が有効になっている、 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 場合 &lt;code&gt;-dynamic&lt;/code&gt; が有効になっている、または &lt;code&gt;ghc-iserv&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">外部インタプリタコマンドとして、⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="481e440a89078b7c2339966f16ab888ce0b1d958" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">libtoolコマンドとして⟨cmd⟩を使用します（&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt;のみを使用する場合）。</target>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">toolcmd⟩をlibtoolコマンドとして使用します（ &lt;code&gt;-staticlib&lt;/code&gt; のみを使用する場合）。</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">リンカとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="ac711284292bd26e5315cd00ca382caef9435d2c" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files</source>
          <target state="translated">オブジェクトファイルをマージする際のリンカーとして、Paces_27E8cmansansoredPe_27E9ansoredを使用します。</target>
        </trans-unit>
        <trans-unit id="aa8be27c0b9f201fc0c9472f4f8108d93d582bc5" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</source>
          <target state="translated">オブジェクトファイルをマージするとき(GHCiにロードするために結合されたオブジェクトを生成するときなど)のリンカとして、Ps_27E8cmanswagend DealsPe_27E9 americanを使用してください。</target>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">リンカには⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">リテレートプリプロセッサとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">⟨cmd⟩ をリテレートプリプロセッサとして使用します。</target>
        </trans-unit>
        <trans-unit id="ae3fcd7e913573d0ca98fd73aac79e8ca6510b13" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">プリプロセッサとして⟨cmd⟩を使用します（&lt;a href=&quot;#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt;のみ）。</target>
        </trans-unit>
        <trans-unit id="7a29c6934473566c99b28cee4bc5456cde213b21" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;phases#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only)</source>
          <target state="translated">プリプロセッサとして⟨cmd⟩を使用します（&lt;a href=&quot;phases#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt;のみ）</target>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">⟨cmd⟩をプリプロセッサとして使用（ &lt;code&gt;-F&lt;/code&gt; のみ）</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">⟨cmd⟨をプリプロセッサとして使用します（ &lt;code&gt;-F&lt;/code&gt; のみを使用）。</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">Windows上でマニフェストを埋め込むプログラムとして、⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="06f092be8a595002e75e8cde42011af9133ed460" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inject &lt;code&gt;runpath&lt;/code&gt; into mach-o dylibs on macOS</source>
          <target state="translated">ジェクトにプログラムとして⟨cmd⟩使用し &lt;code&gt;runpath&lt;/code&gt; にMacOSでdylibsマッハ-O</target>
        </trans-unit>
        <trans-unit id="2aa3b14fe034bb785dbc95f7e2f098debf4b70be" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inject &lt;code&gt;runpath``s into mach-o dynamic
libraries and executables.&amp;nbsp; As detected by the ``otool&lt;/code&gt; call.</source>
          <target state="translated">⟨cmd⟩をプログラムとして使用して、 &lt;code&gt;runpath``s into mach-o dynamic libraries and executables.&amp;nbsp; As detected by the ``otool&lt;/code&gt; に挿入します。「otool呼び出しによって検出されたように。</target>
        </trans-unit>
        <trans-unit id="e75123a572cd455ff35b1a2ec2ba9af921d11a57" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inspect mach-o dylibs on macOS</source>
          <target state="translated">⟨cmd⟩をmacOSのmach-o dylibsを検査するプログラムとして使用する。</target>
        </trans-unit>
        <trans-unit id="5b79c5d224e16858a476d6f862fdbc459ee62882" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inspect mach-o dynamic libraries and executables to read the dynamic library dependencies. We will compute the necessary &lt;code&gt;runpath``s to embed for the dependencies based on the
result of the ``otool&lt;/code&gt; call.</source>
          <target state="translated">⟨cmd⟩をプログラムとして使用して、mach-oダイナミックライブラリと実行可能ファイルを検査し、ダイナミックライブラリの依存関係を読み取ります。 &lt;code&gt;runpath``s to embed for the dependencies based on the result of the ``otool&lt;/code&gt; 呼び出しの結果に基づいて、依存関係に埋め込むために必要なrunpath``を計算します。</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windowsにマニフェストを埋め込むために使用するプログラムとして「cmd」を使用します。通常、これはプログラム &lt;code&gt;windres&lt;/code&gt; であり、GHCインストールで提供されます。&lt;a href=&quot;#options-linker&quot;&gt;リンクに影響&lt;/a&gt;するオプションの &lt;code&gt;-fno-embed-manifest&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">⟨cmd⟩をスプリッターとして使用します。</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">⟨cmd⟩をスプリッターとして使用します。</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">makefile として ⟨file⟩ を使用します。</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makefile&lt;/code&gt; または &lt;code&gt;Makefile&lt;/code&gt; ではなく、「file」をmakefileとして使用します。「ファイル」が存在しない場合は、 &lt;code&gt;mkdependHS&lt;/code&gt; によって作成されます。私たちは、頻繁に使用する &lt;code&gt;-dep-makefile .depend&lt;/code&gt; で依存関係を入れて &lt;code&gt;.depend&lt;/code&gt; をして、 &lt;code&gt;include&lt;/code&gt; たファイル &lt;code&gt;.depend&lt;/code&gt; に &lt;code&gt;Makefile&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">プログラムの実行時には、⟨x⟩同時スレッドを使用します。</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">GHCiがインタラクティブバインディングのセットのSPTエントリを追加するために使用します。</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">x などで使用されますが、プログラマは使用できません。</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">コンパイラが生成したエラーメッセージに使用されます。</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">パラメータの出現をマークするために使用します。</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">オーバーロードされたリテラルとオーバーロードされていないリテラルに使用されます。今のところ、オーバーロードされていないリテラルを表現する良い方法がありません。多分、それは重要ではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">Haskellの翻訳で使用される &lt;code&gt;[n,n'..]&lt;/code&gt; と &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 、可能な実装はされて &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; 、 &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; 、 &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; および &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 例：</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">Haskellの翻訳で使用される &lt;code&gt;[n,n'..m]&lt;/code&gt; と &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; 、ある可能な実施 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; 、 &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 、 &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; および &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 例：</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">Haskellの翻訳に使用される &lt;code&gt;[n..]&lt;/code&gt; と &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; 、ある可能な実施 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">Haskellの翻訳で使用される &lt;code&gt;[n..m]&lt;/code&gt; と &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; 、可能な実現さ &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">Fast String フラグメントを表現するために使用されていましたが、現在は非推奨となっており、Str コンストラクタと同じです。</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">組み合わせて使用するための有用なコンビネータ &lt;code&gt;xxxBy&lt;/code&gt; のからの機能の家族&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;例えば、：</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">便利なエラー処理機能</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">NF = WHNFが保持するタイプの &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; を定義するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">ガベージコレクションを必要とする長期間の割り当てに役立ちます。ただし、メモリへのポインタを外部データ構造に格納する場合は、 &lt;code&gt;mallocForeignPtr&lt;/code&gt; は適切な選択肢ではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">割り当てが特定の &lt;code&gt;IO&lt;/code&gt; 計算を対象とすることを目的としている場合、短期的な割り当てに役立ちます。この種の割り当ては、FFI関数との間でデータをマーシャリングするときに一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">役に立ちます。</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">便利な関数や組み合わせ。</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">便利な機能をご紹介します。</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">便利なヘルパー機能</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">インスタンスを書くのに便利なヘルパー</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">不変量から得られる有用な特性。</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">ユーザー環境</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">ユーザーインタラクション機能</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">ユーザー名</target>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">ユーザー設定</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">ユーザー定義の演算子には、新しい &lt;code&gt;form&lt;/code&gt; キーワードではなくバナナブラケットが付いています。</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">ユーザー定義型エラー</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">ユーザー提供の比較（ &lt;code&gt;Ord&lt;/code&gt; コンテキストの置き換え）</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">ユーザー指定の等価性（ &lt;code&gt;Eq&lt;/code&gt; コンテキストの置き換え）</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">ユーザーは、GHCが指紋を計算するために内部で使用するのと同じ関数を使用できます。&lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprintの&lt;/a&gt;モジュールは、指紋を構築するための便利な機能を提供します。たとえば、 &lt;code&gt;fingerprintFingerprints&lt;/code&gt; と &lt;code&gt;fingerprintString&lt;/code&gt; を組み合わせると、プラグインへの引数を簡単に単純にフィンガープリントできます。</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">ユーザーは &lt;code&gt;~/.haskeline&lt;/code&gt; ファイルでインターフェースをカスタマイズできます。詳細については、&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https：//github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">組み込みの制約解決動作と競合しない &lt;code&gt;HasField&lt;/code&gt; 、ユーザーはHasFieldの独自のインスタンスを定義できます。これにより、「仮想」レコードフィールドを、他の方法では持たないデータ型に対して定義できます。</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">ユーザーは &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; のカスタムインスタンスを提供できますが、これは次のルールに準拠することが期待されています。</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">この関数のユーザーは、readProcessの結果を待つ間、他のHaskellスレッドを実行し続けたい場合は、 &lt;code&gt;-threaded&lt;/code&gt; でコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">ユーザーが最も可能性が高いでしょう &lt;code&gt;~&lt;/code&gt; 、しかし &lt;code&gt;~~&lt;/code&gt; GHCが関心の2種類が同じようなものを持っていることを、先験的に知ることができない場合は利用可能です。 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; が、GHCに &lt;code&gt;k1&lt;/code&gt; と &lt;code&gt;k2&lt;/code&gt; が同じであり、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が同じであることを伝えていることの証拠。</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">構成やパターンマッチングなどのコンストラクタについて言及しているため、常に明確なフィールドの使用では、重複したフィールド名を自由に使用できます。たとえば、以下は許可されます（&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;と同様に）：</target>
        </trans-unit>
        <trans-unit id="0265064a73ec5c4a274e96b0ad1d58643baccfe3" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">コンストラクターに言及しているために常に明確なフィールドの使用（構築やパターンマッチングなど）では、重複するフィールド名を自由に使用できます。たとえば、次のものが許可されます（&lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; の場合&lt;/a&gt;と同様）。</target>
        </trans-unit>
        <trans-unit id="3581ad6f94790a2bc201861caba85a7f7a678467" translate="yes" xml:space="preserve">
          <source>Uses the generational copying garbage collector for all generations. This is the default.</source>
          <target state="translated">すべての世代で世代コピーガベージコレクタを使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">8ビット文字の使用</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">プログラマーは、&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#newtype-deriving&quot;&gt;newtypesの一般化された派生インスタンス&lt;/a&gt;）を使用して、クラスの既存のインスタンスを取得し、それらをnewtypeのそのクラスのインスタンスに「リフト」できます。ただし、これは常に安全であるとは限りません。たとえば、次のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="2206acdb3d9d430eddec1b9a13c7b987ec134bee" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; tells GHC to display incompatibilities between closed type families&amp;rsquo; equations, whenever they are printed by &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは、&lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; &lt;/a&gt;によって出力される場合は常に、閉じた型族の方程式間の非互換性を表示するように指示されます。</target>
        </trans-unit>
        <trans-unit id="ec190b27f84b5eb38a386fb9b591e8f3127b6c54" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;exts/equality_constraints#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは、印刷時に等式関係を区別するようになります。たとえば、 &lt;code&gt;~&lt;/code&gt; は同種のリフトされた等式（引数の種類は同じ）であり、 &lt;code&gt;~~&lt;/code&gt; は異種のリフトされた等式（引数の種類は異なる場合があります）であり、 &lt;code&gt;~#&lt;/code&gt; は異種のリフトされていない等式であり、GHCで使用される内部等式関係です。ソルバー。通常、ユーザーはここでの微妙な点について心配する必要はありません。 &lt;code&gt;~&lt;/code&gt; はおそらくあなたが望むものです。&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; が&lt;/a&gt;ない場合、GHCはこれらすべてを &lt;code&gt;~&lt;/code&gt; として出力します。&lt;a href=&quot;exts/equality_constraints#equality-constraints&quot;&gt;等式制約&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;を使用すると、GHCに、印刷時に同等の関係を区別するよう指示します。たとえば、 &lt;code&gt;~&lt;/code&gt; は同種のリフトされた等式（引数の種類は同じ）ですが、 &lt;code&gt;~~&lt;/code&gt; は異種のリフトされた等式（引数の種類は異なる場合があります）であり、 &lt;code&gt;~#&lt;/code&gt; は異種のリフトされていない等式、GHCで使用される内部等式関係ですソルバー。一般に、ユーザーはここで微妙なことを心配する必要はありません。 &lt;code&gt;~&lt;/code&gt; はおそらくあなたが望むものです。&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; が&lt;/a&gt;ない場合、GHCはこれらすべてを &lt;code&gt;~&lt;/code&gt; として出力します。&lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;等式制約&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは型で強制変換を印刷します。異なる種類の型間の同等性を証明しようとするとき、GHCは型レベルの強制を使用します。これらは内部用であるため、ユーザーがこれらを表示する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;を使用すると、GHC は型のトップレベルで明示的な &lt;code&gt;forall&lt;/code&gt; 数量化を出力します。通常、これは抑制されます。たとえば、GHCiの場合：</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは種類の引数を印刷しますが、通常は抑制されます。これは、親切なポリモーフィズムを使用している場合に重要です。例えば：</target>
        </trans-unit>
        <trans-unit id="b89399a162079f667d1fdc83d81ed74335bde10d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;を使用すると、 &lt;code&gt;myLength1&lt;/code&gt; の型シグネチャ内の型変数のいずれも型アプリケーションに使用できないと結論付ける可能性があります。しかし、これは真実ではありません！表示されるタイプのアプリケーションプロパティに関して最も正確な情報が必要な場合は、必ず&lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;を使用すると、 &lt;code&gt;myLength1&lt;/code&gt; の型シグネチャの型変数はいずれも型アプリケーションで使用できないと結論付ける可能性があります。しかし、これは真実ではありません！表示されるタイプのアプリケーションプロパティに関して最も正確な情報が必要な場合は、必ず&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="b75747b0323839514f55b98e3b0763a8b7a1bc59" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;rsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;を使用すると、 &lt;code&gt;myLength1&lt;/code&gt; の型シグネチャの型変数はいずれも型アプリケーションで使用できないと結論付ける可能性があります。しかし、これは真実ではありません！表示されるタイプのアプリケーションプロパティに関して最も正確な情報が必要な場合は、必ず&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="6570d089faca67f533b154812bbbc95cc61616d4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">使用&lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;newtypesの一般導出インスタンスを&lt;/a&gt;）、プログラマは既存のクラスのインスタンスとnewtypeのために、そのクラスのインスタンスにこれらの「リフト」を取ることができます。ただし、これは常に安全であるとは限りません。たとえば、次のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;を使用することは、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;と組み合わせた場合にのみ実際に良いアイデアです。それ以外の場合、追加のパックとアンパックは最適化されないためです。実際には、可能性があり&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;さえパフォーマンスを悪化させること&lt;em&gt;で&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;（それはあなたに何が起こる場合はお知らせ）が、これはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部で &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、理由はさまざまです。詳細については、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="1d18768c0ec1399365712ea9b78325eb3b52d261" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、さまざまな理由があります。詳細については、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="a922b4d719b40ab46b07c97a191b43983233d5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、さまざまな理由があります。詳細については、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を使用しても、Haskellランタイムシステムのスケジューリング動作はまったく変わりません。あなたが使用する必要があるという一般的な誤解である &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 代わりの &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を外国電話をかける際に、すべてのHaskellのスレッドをブロックを避けるために。これはそうではありません。すべてのHaskellスレッド（GHCを使用）をブロックせずに外部呼び出しを許可するには、プログラムをリンクするときに &lt;code&gt;-threaded&lt;/code&gt; オプションを使用し、外部インポートが &lt;code&gt;unsafe&lt;/code&gt; でないとマークされていないことを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が覆されます。サンクが評価されるタイミングに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試みる可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="653b55d8219ef951a3573cfdf98d122082b2dcdc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が破壊されます。サンクがいつ評価されるかに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試行する可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="96c07fa0636126bb91dda25884d1c1fbe2b0138a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が破壊されます。サンクがいつ評価されるかに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試行する可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 使用は &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が覆されます。サンクが評価されるタイミングに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試みる可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が覆されます。サンクが評価されるタイミングに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試みる可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部で &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、理由はさまざまです。詳細については、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部で &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、理由はさまざまです。詳細については、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ab3deb78b20e89efa13a9a442f13a5722f047491" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="b96ae088c649d5a06c694f9e9ee5ee9dc8687a02" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="5d111b0d48c558b38badb2c9405749a987627b42" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="b2172f3ccd962a6ecd9b4cc15ce3cf95a1be7eb5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="f674202704940c277740f7f4ae49cd37b3a5f78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt;' can be understood as the pseudo-&lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt; 'は、疑似 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="c7b459af09ae8043d5f7b1a6c9159131c0b0fd22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt; 」として理解することができる &lt;code&gt;do&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="a4087f9008dd31f8281176bc7c8f4d1d90f9e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; 理解することができる」として &lt;code&gt;do&lt;/code&gt; 式を</target>
        </trans-unit>
        <trans-unit id="1570094d52e557732c703a05b9b1c145c2dd064a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="41f501d2ca81d0c4860698f021f0de3ecdc4a0f4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="108f9b97edb22ce149c8927414975f8505b7580d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; 理解することができる」として &lt;code&gt;do&lt;/code&gt; 式を</target>
        </trans-unit>
        <trans-unit id="2c837790b7d1462717c4308d600ad3e92eeaf1c9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt; 」として理解することができる &lt;code&gt;do&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="14c32ccf8b63eb011e4dfda0a4088dddc4bcbb92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="ffd6b1455603f9e6df9249daef0be0bed100da03" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="e2a8dbc4ffe0ccbf1d373d624329159d46946500" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="72b865211f58b24998cdf3ed8e08bdcf5e692e5e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="00a3efcb29a05c36224847d355496627fce12e1f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="9165dbc2c9969c24f2215ef6972a0880bb8278cb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="6e4a4d9eb30eacc6d2b8ca81bb1bd234ce8594a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="c8ccbb1fb2ddb1f53f896c4cc85e9a37ce0b41f0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="3fce8cbc36fc6d6dcdd6a6150d8297a2eb75e02c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="1004bfc9a7477fe977e15f814e05ceb1b205da67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="71cb9307570de629188fffa91efa031876cc2110" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="774bbfc5e54c815dbed906d0f74123e150de4f6c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="69d911e731ca95c1fd9a07c919774126a522e977" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="84196a31a9d5c8e34d17aa2ef18dc24c40e44aab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="5b25d8a860bc159c6b22d827207b11014882905b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="8a06315a7f9f08f9387659d3c5c4197621c13971" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="64871c74d2047073bc61343ed982993443145244" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="7235239be554865a0935a618eb2b2336543f4705" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="6309b1896f5220de1092c0929134f7a07019870d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="2a548000114a6581f99bb89aac62e4c4178082e2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="a6203018fe62d6ff03754e5bb607909a52d373ff" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バイト文字列を使用して &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; のS</target>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">バイト文字列を使用して &lt;code&gt;CString&lt;/code&gt; の S</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">ByteStringsをCStringsとして使用する</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">ByteStringsをCStrings用の関数で使用する</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">&lt;code&gt;-threaded&lt;/code&gt; オプションを指定せずにGHCを使用すると、すべての外部呼び出しはシステム内の他のすべてのHaskellスレッドをブロックしますが、I / O操作はブロックしません。 &lt;code&gt;-threaded&lt;/code&gt; オプションを使用すると、 &lt;code&gt;unsafe&lt;/code&gt; 属性を持つ外部呼び出しのみが他のすべてのスレッドをブロックします。</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">共有オブジェクト名にGHCのバージョン番号を使用すると、GHCの異なるバージョンによってコンパイルされた異なるライブラリバージョンを、たとえば* nix &lt;code&gt;/usr/lib&lt;/code&gt; の下など、標準のシステムの場所にインストールできます。GHCのバージョン番号を取得するには、 &lt;code&gt;ghc --numeric-version&lt;/code&gt; を呼び出し、「GHCVersion」の代わりにその出力を使用します。共有オブジェクトリンク用にオブジェクトファイルを準備する方法については、&lt;a href=&quot;phases#options-codegen&quot;&gt;コード生成&lt;/a&gt;に影響するオプションも参照してください。</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; の&lt;/a&gt;組み合わせを使用すると、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;フレームワークを使用してデータ型ジェネリックプログラミングを簡単に実行できます。このセクションでは、その方法の非常に簡単な概要を示します。</target>
        </trans-unit>
        <trans-unit id="f8eaede999cdbad9cc93f8d51a7d597d7f74c072" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; の&lt;/a&gt;組み合わせを使用すると、&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;フレームワークを使用してデータ型ジェネリックプログラミングを簡単に実行できます。このセクションでは、その方法の概要を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="2c82c05e8fe15e1579841159f1a517a26f5bffb8" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; の&lt;/a&gt;組み合わせを使用すると、&lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;フレームワークを使用してデータ型ジェネリックプログラミングを簡単に実行できます。このセクションでは、その方法の概要を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">ロケールに依存したエンコーディングを使用する</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">パッケージを使用するのはもっと簡単です &lt;code&gt;--make&lt;/code&gt; またはGHCi を使用している場合、インストールされているパッケージのほとんどは、追加のオプションなしでプログラムで自動的に使用できます。このルールの例外については、&lt;a href=&quot;#using-packages&quot;&gt;パッケージの使用&lt;/a&gt;で後述します。</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">ゼロの値を使用すると、RTS クロックは完全に無効化され、それに依存するタイマー(コンテキストスイッチタイマーとヒーププロファイリングタイマー)を無効化する効果があります。コンテキストスイッチは依然として発生しますが、決定論的に、通常よりもはるかに速い速度で発生します。インターバルタイマーを無効にすると、実行時の非決定性の原因を取り除くことができるので、デバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="6a4a9903244534f370840c1922f33e5fac470a05" translate="yes" xml:space="preserve">
          <source>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</source>
          <target state="translated">ホールフィットプラグインを使用すると、有効なホールフィットの提案の動作を拡張して、例えばHoogleや他の外部ツールを使用して、GHCが使用しているタイプドホールに関する情報と同じ情報で、有効なホールフィットを見つけたり、合成したりすることができます。</target>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">レコードセレクタの使用</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;フラグを使用すると、モジュールを並行してコンパイルできます。「-n」ジョブを並行してコンパイルするには、 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; を指定します。「n」を省略すると、デフォルトでプロセッサの数になります。</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; コマンドの &lt;code&gt;module&lt;/code&gt; コマンドを使用すると、モジュールが現在のスコープに追加され、 &lt;code&gt;-&lt;/code&gt; で削除されます。 &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; がない場合、現在のスコープは指定されたモジュールのセットで置き換えられます。このフォームを使用して &lt;code&gt;Prelude&lt;/code&gt; を省略した場合、暗黙的な &lt;code&gt;Prelude&lt;/code&gt; インポートが自動的に追加されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dcd0ac8cbd97b2347e8fe4749682a842e661035c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;control-monad#v:Except&quot;&gt;Except&lt;/a&gt;&lt;/code&gt;, the following functions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:Except&quot;&gt;Except&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; インスタンスを使用すると、次の機能があります。</target>
        </trans-unit>
        <trans-unit id="88ce1fb571afb65c6d0e842b399fa0b1a914f2d0" translate="yes" xml:space="preserve">
          <source>Using this is expected to make the program slightly slower.</source>
          <target state="translated">これを使うことで、プログラムの動作が少し遅くなることが予想されます。</target>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">通常、GHCはスレッドを切り替えるときにのみサンクをブラックホール化します。このフラグは、サンクが入力されるとすぐにそうします。&lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;共有メモリマルチプロセッサ上のHaskellを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">通常はユーザの実名 (pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">通常、ファイルの名前はモジュール名に基づいて付け、モジュール名のドットをディレクトリ区切り文字に置き換えます。たとえば、Unixシステムでは、モジュール &lt;code&gt;A.B.C&lt;/code&gt; は、いくつかのベースディレクトリに対して、ファイル &lt;code&gt;A/B/C.hs&lt;/code&gt; に配置する必要があります。モジュールが別のモジュール（ &lt;code&gt;Main&lt;/code&gt; など）によってインポートされない場合は、任意のファイル名を自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">Win32 APIを呼び出すためのユーティリティ</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">プリミティブマーシャリングのためのユーティリティ</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">C文字列のプリミティブマーシャリングのためのユーティリティ。</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">Windows の C 文字列のプリミティブマーシャリングのためのユーティリティ。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">ユーティリティ機能</target>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">ドキュメントのユーティリティ機能</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="0dd37a83e54442139e4aed5d892a8264e1d1a20d" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls: &lt;code&gt;ByteArray#&lt;/code&gt; and &lt;code&gt;MutableByteArray#&lt;/code&gt;. The byte array must be &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;pinned&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;foreign import safe&lt;/code&gt; FFI呼び出しの有効な引数： &lt;code&gt;ByteArray#&lt;/code&gt; および &lt;code&gt;MutableByteArray#&lt;/code&gt; 。バイト配列は&lt;a href=&quot;#pinned-byte-arrays&quot;&gt;固定する&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="89dcf84a837ed25d40e781204368ac37d7aee9e9" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI calls: &lt;code&gt;Array#&lt;/code&gt;, &lt;code&gt;SmallArray#&lt;/code&gt;, &lt;code&gt;ArrayArray#&lt;/code&gt;, &lt;code&gt;ByteArray#&lt;/code&gt;, and the mutable counterparts of these types.</source>
          <target state="translated">&lt;code&gt;foreign import unsafe&lt;/code&gt; FFI呼び出しの有効な引数： &lt;code&gt;Array#&lt;/code&gt; 、 &lt;code&gt;SmallArray#&lt;/code&gt; 、 &lt;code&gt;ArrayArray#&lt;/code&gt; 、 &lt;code&gt;ByteArray#&lt;/code&gt; 、およびこれらのタイプの可変の対応物。</target>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">洗練レベルがあるときに有効な洗練穴フィットがしばしば大きくなる可能性があり、有効なリスト &lt;code&gt;&amp;gt;= 2&lt;/code&gt; のような穴で、 &lt;code&gt;head _ _&lt;/code&gt; または &lt;code&gt;fst _ _&lt;/code&gt; 有効な改良されている、しかし、穴の一つ以上のことから、関連する可能性は低いですそれらの穴のタイプも種類も提案された識別子によってまったく制約されないという点で、まだ完全にオープンです。デフォルトでは、このようなホールは報告されません。このフラグをオンにすると、そのような穴は有効なリファインホールフィットのリストに含まれます。</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 検証します。このアプローチは、使用しての利点を示して &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; をかけて &lt;code&gt;return&lt;/code&gt; 。私たちは、に継続を渡し &lt;code&gt;validateName&lt;/code&gt; 、との割り込み実行 &lt;code&gt;Cont&lt;/code&gt; からブロック&lt;em&gt;内部&lt;/em&gt;の &lt;code&gt;validateName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="7e3d80a59e713df86b771fc1d2dd18a3958c972f" translate="yes" xml:space="preserve">
          <source>Validation use-case</source>
          <target state="translated">バリデーションの使用例</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の入力中に計算された値。</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; クラスを使用してエンコードされた値は常にネットワーク順（ビッグエンディアン）の形式でエンコードされ、エンコードされたデータはマシンのエンディアン、ワードサイズ、またはコンパイラのバージョン間で移植可能である必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; クラスを使用してエンコードされたデータは、任意のマシンで書き込み、別のマシンで読み戻すことができます。</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;TExp a&lt;/code&gt; の値は、関数 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; を使用してタイプ &lt;code&gt;Exp&lt;/code&gt; の値に変換できます。</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">バニラ型の同義語宣言はHaskellと全く同じです。</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">型のアプリケーションでは使用できない変数が先に来ます。</target>
        </trans-unit>
        <trans-unit id="ad3fca5915fe871548a7a02e59688c2946d84dec" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">ユーザーによって明示的な&lt;a href=&quot;#scopedsort&quot;&gt;順序が指定されていない変数は、&lt;/a&gt; ScopedSort（指定された変数の順序）に従って並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="d7cf04f66b938e191f936b1736b7f07717f7def2" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;type_applications#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">ユーザーによって明示的な&lt;a href=&quot;type_applications#scopedsort&quot;&gt;順序が指定されていない変数は、&lt;/a&gt; ScopedSort（指定された変数の順序）に従って並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">ユーザーによって明示的な順序付けが与えられていない変数は、ScopedSort(ScopedSort)に従ってソートされます。</target>
        </trans-unit>
        <trans-unit id="ce923a612b2be3e0d26e1de671e160005bec40d5" translate="yes" xml:space="preserve">
          <source>Variant of (&amp;gt;&amp;gt;) which allows effectful computations to be injected into code generation.</source>
          <target state="translated">効果的な計算をコード生成に注入できるようにする（&amp;gt;&amp;gt;）のバリアント。</target>
        </trans-unit>
        <trans-unit id="7e69428f906bf03a78f1b42caa4156197b506c43" translate="yes" xml:space="preserve">
          <source>Variant of (&amp;gt;&amp;gt;=) which allows effectful computations to be injected into code generation.</source>
          <target state="translated">効果的な計算をコード生成に注入できるようにする（&amp;gt;&amp;gt; =）のバリアント。</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">バリアント &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; というプロパティを「並べ替えの障壁」と &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">バリアント &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; のスタイルで &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">バリアント &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; のスタイルで &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">許容されるインスタンスのオーバーラップの種類。</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">OSのバージョンを確認する</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">バージョン情報</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">お使いのコンピュータのバージョン情報です。</target>
        </trans-unit>
        <trans-unit id="e16193c9fa0396ab60a71b729b4a04cd813d0d61" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; without any value being passed to the second and third actions.</source>
          <target state="translated">2番目と3番目のアクションに値が渡されない &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; バージョン。</target>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="74c019334e2fff57ca4e39f259c2452610b715a1" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="1e7284b212c3e18b15655fd8a93f4230611c203f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 構築 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 構築 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="3383f2c0a3a8b49db2500fd0baa98b81bb0d0957" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="9d7b173a0dcac34771410bf511deb7fb53172de2" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; サイズのモジュラス用の &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; サイズの &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 用のpowModIntegerのバージョン</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="bcd38df7c17761d370b1e5803d31bed7f709a369" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="1c0304fc532fda6e0a0fb66673b691dbdd8f5987" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22b9c46cdd68688219fc77a7a7a0110bec5346a6" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; のバージョン＃</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="e9f8dae2a07adfa71cf9369406dff32b07be5f54" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;nextPrimeInteger&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="0ebfec0d93e79f27fbe5c6446dcd99376cb8889b" translate="yes" xml:space="preserve">
          <source>Version of Unicode standard used by &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 使用されるUnicode標準のバージョン。</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">バージョンスキームは多種多様なので、このライブラリが提供するバージョン表現は、ほとんど共通の機能が合理的に提供できないような完全な一般性と、おそらく制限が強すぎるであろう特定のバージョンスキームを修正することとの間の妥協点となるように意図されています。</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="7c6f1ef6ee2199899662d0306223ad7c19cd46c1" translate="yes" xml:space="preserve">
          <source>Very unsafe coercion</source>
          <target state="translated">非常に危険な強制力</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">シーケンスの左端の様子。</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">シーケンスの右端を見る。</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">パターンを見る</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">ビューパターンは、言語拡張&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;によって有効になります。詳細とビューパターンの例は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wikiページにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e310bf26720d505a9536f51e809dfeaae92ef176" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">ビューパターンは、言語拡張&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;によって有効になります。ビューパターンの詳細と例は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wikiページにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">ビューパターンは、他のパターンの中に入れ子にすることができるパターンガードのようなものです。これらのパターンは、抽象型の値に対してパターンマッチングを行う便利な方法です。例えば、プログラミング言語の実装では、言語の型の構文を次のように表現します。</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">ビューパターンでは、パターン内のビュー関数を呼び出して結果と照合することができます。</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">事実上すべてのデータコンストラクタは、リッチな種類のものであっても昇格させることができます。このルールにはいくつかの例外があります。</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">Void:コンストラクタを持たないデータ型で使用します。</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：この関数は破損したマップを生成する可能性があり、その結果はその入力の内部構造に依存する場合があります。ユーザーは &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; を優先する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：この関数は破損したマップを生成する可能性があり、その結果はその入力の内部構造に依存する場合があります。ユーザーは &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; を優先する必要があります。</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">警告:通常の非原始的な Haskell 型への弱いポインタは、コンパイラが自由に最適化したり、基礎となるデータ構造を 複製したりするため、特に脆弱です。そのため、通常の Haskell 型にファイナライザを配置しようとすると、ファイナライザが予想よりも早く実行されてしまう可能性があります。これはキャッシュやメモテーブルの場合は問題ありませんが、早期のファイナライズは問題ありません。</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">ユニットが使えるようになるまで待つ</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">指定された数量が利用可能になるのを待つ</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; （別名&lt;strong&gt;P&lt;/strong&gt;操作）で待機します。</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">信号待ち</target>
        </trans-unit>
        <trans-unit id="572c89962b6ad39f8a6c6c966a575192e24a760d" translate="yes" xml:space="preserve">
          <source>Waits for one key to be pressed, then returns. Ignores the value of the specific key.</source>
          <target state="translated">1つのキーが押されるのを待ってから戻ります。特定のキーの値を無視します。</target>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">指定したプロセスの終了を待ち、その終了コードを返します。</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">トップレベルのインスタンス宣言を使用して簡略化できる型シグネチャのクラス制約について警告します。</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">トップレベルのインスタンス宣言を使用して簡略化できる型シグネチャ内のクラス制約について警告します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2f17deafc978e685508816d0d4ac503ec8d814c7" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when none of the bound variables are used.</source>
          <target state="translated">バウンド変数が使用されていない場合、レコードのワイルドカードマッチについて警告します。</target>
        </trans-unit>
        <trans-unit id="a962ab5861876e6eea5477b0e84923e9646bd87f" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when the wildcard binds no patterns.</source>
          <target state="translated">ワイルドカードがパターンをバインドしていない場合のレコードワイルドカードのマッチについて警告します。</target>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(*&amp;gt;)&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり、 &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり、 &lt;code&gt;pure = return&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">パターン・バインディングが、単独のワイルドカード・パターン、またはバングされたパターンでない限り、変数を全くバインドしない場合に警告します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">昇格したデータコンストラクタが、その名前の前にチェックを入れずに使用されている場合に警告を出します。</target>
        </trans-unit>
        <trans-unit id="086bb0536ea1d969c7c5649822f9159c7df38091" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;exts/rewrite_rules#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">ルールが起動する前に関数がインライン化される可能性があるため、書き換えRULEが起動に失敗する可能性がある場合に警告します。&lt;a href=&quot;exts/rewrite_rules#rules-inline&quot;&gt;ルールがINLINE / NOINLINEプラグマとどのように相互作用するかを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">ルールが起動する前に関数がインライン化される可能性があるため、書き換えRULEの起動に失敗する可能性がある場合に警告します。&lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;ルールとINLINE / NOINLINEプラグマとの相互作用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">非正規の &lt;code&gt;Applicative&lt;/code&gt; または &lt;code&gt;Monad&lt;/code&gt; インスタンス宣言が検出された場合に警告します。</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">非正規の &lt;code&gt;Monad&lt;/code&gt; または &lt;code&gt;MonadFail&lt;/code&gt; インスタンス宣言が検出された場合に警告します。</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">非 &lt;code&gt;Semigroup&lt;/code&gt; セミグループまたは &lt;code&gt;Monoid&lt;/code&gt; インスタンスの宣言が検出された場合に警告します。</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">GHCiが共有ライブラリを読み込めない場合に警告します。これは、パッケージを読み込み、ターゲットパッケージの説明の追加ライブラリスタンザを分析するときに読み込む必要があると推定します。</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCiが共有ライブラリをロードできないときに警告します。</target>
        </trans-unit>
        <trans-unit id="6590e9bd34bfc2ad804659f30bd772d752f4af5b" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can't load a shared lib.</source>
          <target state="translated">GHCiが共有libをロードできない場合に警告が出る。</target>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">遅延された範囲外の変数に遭遇した場合に警告します。</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;MonadFail&lt;/code&gt; インスタンスを持たないdoブロックで失敗可能なパターンが使用されたときに警告します。</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">定義が &lt;code&gt;Semigroup&lt;/code&gt; の標準型クラスへの将来の包含と競合する場合に警告します。</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">サポートされていないバージョンのLLVMで&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;を使用すると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">警告：指定された &lt;code&gt;Vertex&lt;/code&gt; が存在しない場合、 &lt;code&gt;nodeFromVertex&lt;/code&gt; 関数はランタイム例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">警告。この関数にはいくつかの欠点があります (ドキュメントを参照してください)。代わりにControl.Concurrent.threadDelayの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">警告：エッジリスト内の頂点が与えられた範囲内でない場合、この関数は、実行時例外が発生します &lt;code&gt;Bounds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">警告。これは不安定なインターフェースです。</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">警告:改行やタブ文字は区切り文字とはみなされません。</target>
        </trans-unit>
        <trans-unit id="ee168ab9a58029df5beac805f3270bcfd9fe72d2" translate="yes" xml:space="preserve">
          <source>Warning: since the &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; is called from the I/O manager, it must not throw an exception or block for a long period of time. In particular, be wary of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;: if the target thread is making a foreign call, these functions will block until the call completes.</source>
          <target state="translated">警告： &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; はI / Oマネージャから呼び出されるため、長期間にわたって例外やブロックをスローしてはなりません。特に、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; に注意してください。ターゲットスレッドが外部呼び出しを行っている場合、これらの関数は呼び出しが完了するまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="6d01607b3c9e9f53fb1f960cc714c8c6dd8da973" translate="yes" xml:space="preserve">
          <source>Warning: since the &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; is called from the I/O manager, it must not throw an exception or block for a long period of time. In particular, be wary of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;: if the target thread is making a foreign call, these functions will block until the call completes.</source>
          <target state="translated">警告： &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; はI / Oマネージャから呼び出されるため、長期間にわたって例外やブロックをスローしてはなりません。特に、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; に注意してください。ターゲットスレッドが外部呼び出しを行っている場合、これらの関数は呼び出しが完了するまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*このモジュールは内部モジュールです。必要だと分かった場合はメンテナに連絡して、何をしようとしているのかを説明し、公開APIで何が必要なのかを議論してください。このモジュールは将来のリリースでは全く公開されないかもしれないので、これを行うことが重要です。</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*このモジュールは内部モジュールです。もし必要だと思ったら、メンテナに連絡して、何をしようとしているのかを説明し、パブリック API で何が必要かを議論してください。このモジュールは将来のリリースでは全く公開されないかもしれないので、これを行うことが重要です。</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">(a)定義モジュール内での使用、(b)クラスインスタンス内でのメソッド定義、(c)エクスポートリスト内での使用については、警告や非推奨事項は報告されません。後者は、あるモジュールが他のいくつかのモジュールのエクスポートをまとめて再エクスポートするライブラリ内での不満を軽減します。</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告はエラーとしてではなく、警告としてのみ扱われます。これはデフォルトですが、&lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;フラグを無効にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="2494895ad5475179cdf03bf37393c57bb4ffcf96" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告は、エラーとしてではなく、警告としてのみ扱われます。これはデフォルトですが、&lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;フラグを無効にするのに役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="3800447d155c1657cd8727b0981f5edb4c28c0bc" translate="yes" xml:space="preserve">
          <source>Warns on qualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</source>
          <target state="translated">将来の GHC リリースで変更される可能性のあるコアライブラリモジュールのインポートについて警告します。現在、以下のモジュールがこの警告の対象となっています。</target>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">このプログラムはGHCの&lt;a href=&quot;codegens#unreg&quot;&gt;「未登録」&lt;/a&gt;バージョンでコンパイルされましたか？（つまり、現在サポートされていないプラットフォームであるため、プラットフォーム固有の最適化がコンパイルされていないGHCのバージョンです。）この値は、GHCの実験的ビルドを使用していない限り、通常はありません。</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">（1）バッファーへの書き込みの制御を完全に &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実装する &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; に引き渡すことで実現します。この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; は、バッファの開始と終了（ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; として表される）を通知されるだけです。次に、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; は、この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; のプレフィックスに任意の方法で書き込むことができます。場合 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; が行われ、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; が満杯であるか、またはバイトの長いシーケンスは、次に、直接挿入されるべき &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; を使用して発信者にこれを信号 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">私たちはすべてのことを要求することにより、（2）を達成 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; がで実装され &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 継続取り &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; それが更新さを呼び出して、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; それが行われた後に。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の連結を実装するには、関数呼び出しで2つのポインタのみを渡す必要があります。さらに、多くの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は完全にインライン化されているため、コンパイラーは、関数を呼び出すことなく、またボックス化をまったく行わずにそれらをシーケンスできます。</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">並列プログラムのプロファイリングには&lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;を使用することもお勧めします。並列実行を視覚化するためのGUIを提供し、GHCで提供される時間と空間のプロファイリング機能を補完します。</target>
        </trans-unit>
        <trans-unit id="c301d61ee67c2ed79282027770ed709d177658e3" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">また、並列プログラムのプロファイリングには&lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;を使用することをお勧めします。並列実行を視覚化するためのGUIを提供し、GHCで提供される時間と空間のプロファイリング機能を補完します。</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; の両方で &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; の操作を引き上げたいと考えています。操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;throwE e&lt;/code&gt; は単純なアクションであるため、2 つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; s を &lt;code&gt;InterpM&lt;/code&gt; して2 つのモナドトランスフォーマーからInterpMにリフトできます。</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">実際には、ここではより具体的なタイプで &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; を使用しています</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">我々は、単一のモジュールに限定されない：GHCiのは、のいずれかの混合物中に、複数のモジュールからスコープを組み合わせることができます &lt;code&gt;*&lt;/code&gt; と非 &lt;code&gt;*&lt;/code&gt; 形式。GHCiは、これらすべてのモジュールのスコープを組み合わせて、プロンプトで有効なスコープを形成します。</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">これをプロシージャまたは矢印抽象化と呼びます。ラムダ式の場合と同様に、変数 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;proc&lt;/code&gt; -expression 内でバインドされた新しい変数です。矢印への入力を指します。上記の例では、 &lt;code&gt;-&amp;lt;&lt;/code&gt; は識別子ではなく、矢印タイプの式とその矢印への入力として供給される式からコマンドを作成するために使用される新しい予約済みシンボルです。（奇妙な外観は後でより意味をなすでしょう。）これは、矢印のアプリケーションのアナログとして読むことができます。上記の例は、Haskell式と同等です。</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">Writerを使ってプリミティブを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">同様の方法でコンストラクタクラスのインスタンスを導出することもできます。たとえば、以下のような状態と失敗のモナド変換器を実装したとします。</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">また、ハンドルやファイルとの間で値を直接シリアライズすることもできます。</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">また、マークアップされたバージョンのソースを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">スペースのような文字を含む引数を引用することもできますし、Haskellの文字列のように扱うこともできますし、Haskellのリスト構文を使うこともできます。</target>
        </trans-unit>
        <trans-unit id="3c5f88dde35a93a41c4cb3d95351a5898162e27d" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-ascii#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; example above.</source>
          <target state="translated">上記の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-ascii#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; の例に示すように、これを使用して厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を16進エンコードすることもできます。</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">上記の &lt;code&gt;byteStringHex&lt;/code&gt; の例に示すように、これを使用して厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を16進エンコードすることもできます。</target>
        </trans-unit>
        <trans-unit id="1ce8823816dc5997208d0d3df16b93ce9755a58f" translate="yes" xml:space="preserve">
          <source>We can carry this further, and define more non-default methods...</source>
          <target state="translated">これをさらに進めて、デフォルトではないメソッドをさらに定義することもできます...。</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">これで、予想どおり、 &lt;code&gt;x&lt;/code&gt; の型が再構築され、 &lt;code&gt;f&lt;/code&gt; の型も再構成されたことを確認できます。</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">&lt;em&gt;バイナリ&lt;/em&gt;形式に変換していることがはっきりとわかります。127を超えるUnicodeコードポイントを持つ「&amp;lambda;」および「&amp;ouml;」文字は、対応するUTF-8マルチバイト表現に拡張されます。</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; を複数回使用して、複数のプリミティブを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; を複数回使用して、複数のプリミティブを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 関数を使用して、リスト内の複数の値を1つの値に組み合わせることができます。 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; はいくつかの異なる操作でモノイドであるため、ここではタイプを指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; をコンパイルしてから、次のようにプログラム全体をロードできます。</target>
        </trans-unit>
        <trans-unit id="6673177b0a5b4448a0b279c9a7468bd7b3f97bc2" translate="yes" xml:space="preserve">
          <source>We can convert a regular list to an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; with:</source>
          <target state="translated">通常のリストを次の&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt;で&lt;strong&gt;FRListに&lt;/strong&gt;変換できます。</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">ファイルからGHCiの入力を読み込むコマンドを定義することができます。これは、繰り返しGHCiセッションにロードしたいバインディングのセットを作成するのに便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; トランスフォーマーを追加することでカウントするパーサーを定義できます。</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">&lt;code&gt;pat_lhs&lt;/code&gt; の形式を変更することで、プレフィックス、インフィックス、またはレコードパターンの同義語を定義できます。これらの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">通常の内包表記に変換することで、並列リスト内包表記を定義できます。基本的な考え方は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">このようなパーサーモナドを定義するには、 &lt;code&gt;[]&lt;/code&gt; モナドに状態（解析対象の残りの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）を追加します。これにより、非決定性が提供されます。</target>
        </trans-unit>
        <trans-unit id="b9c01a3a2622d4196ecfba7e8743aedf0cb3a68d" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">このようなパーサーモナドを定義するには、状態（解析される残りの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）を &lt;code&gt;[]&lt;/code&gt; モナドに追加します。これにより、非決定性が提供されます。</target>
        </trans-unit>
        <trans-unit id="df8374e1acf095dee848a44f1577d87dbc000a3e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">このようなパーサーモナドを定義するには、状態（解析される残りの &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）を &lt;code&gt;[]&lt;/code&gt; モナドに追加します。これにより、非決定性が提供されます。</target>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">この型の値をバイト文字列にエンコードするには、以下のインスタンスを使用します。</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">newtypeが最後のクラスパラメーターであれば、マルチパラメータークラスのインスタンスを派生させることもできます。この場合、クラスの「部分的なアプリケーション」が &lt;code&gt;deriving&lt;/code&gt; 句に表示されます。たとえば、クラスが</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">代わりに、newtype &lt;code&gt;App&lt;/code&gt; （ &lt;code&gt;App f a&lt;/code&gt; と &lt;code&gt;f a&lt;/code&gt; はメモリ内で同じように表現されます）を作成し、&lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt;を使用してこのパターンの使用を明示的に有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="34d5422d9cdcd8f1fd638150c60756059c44e629" translate="yes" xml:space="preserve">
          <source>We can lift &lt;code&gt;append&lt;/code&gt; and apply it to &lt;code&gt;f0&lt;/code&gt; to get:</source>
          <target state="translated">&lt;code&gt;append&lt;/code&gt; を持ち上げて &lt;code&gt;f0&lt;/code&gt; に適用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;MismatchedParentheses&lt;/code&gt; 例外を &lt;code&gt;MismatchedParentheses&lt;/code&gt; 、 &lt;code&gt;SomeFrontendException&lt;/code&gt; 、または &lt;code&gt;SomeCompilerException&lt;/code&gt; としてキャッチできるようになりましたが、 &lt;code&gt;IOException&lt;/code&gt; などの他のタイプはキャッチできません。</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">評価ステップの履歴を検査できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a6f3e30515c510be759d2caa31d207bd8d44a8cd" translate="yes" xml:space="preserve">
          <source>We can only make field selectors for pattern synonym records that do not mention any existential type variables whatsoever in their types, per &lt;a href=&quot;pattern_synonyms#record-patsyn&quot;&gt;Record Pattern Synonyms&lt;/a&gt;. (This is a stronger requirement than for GADT records, whose types can mention existential type variables provided that they are also mentioned in the return type.) We can see that &lt;code&gt;unP2&lt;/code&gt; cannot be used as a top-level field selector since its type has a free type variable &lt;code&gt;n&lt;/code&gt;, which is existential. &lt;code&gt;unP1&lt;/code&gt; is fine, on the other hand, as its type only has one free variable, the universal type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;pattern_synonyms#record-patsyn&quot;&gt;レコードパターンシノニム&lt;/a&gt;ごとに、タイプに存在するタイプ変数がまったく記載されていないパターンシノニムレコードのフィールドセレクターのみを作成できます。 （これは、GADTレコードよりも強い要件です。GADTレコードの型は、戻り値の型にも記載されている場合、既存の型変数を記載できます。） &lt;code&gt;unP2&lt;/code&gt; の型には、実存的である自由型変数 &lt;code&gt;n&lt;/code&gt; 。一方、 &lt;code&gt;unP1&lt;/code&gt; は、その型に1つの自由変数、つまりユニバーサル型変数 &lt;code&gt;a&lt;/code&gt; しかないため、問題ありません。</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">値とアプリケーションからなる単純な式を EvalStmt に渡すことができます。これにより、別の関数で実行される文をラップすることができ、GHCiが :set argsと :set progを実装するために使用しています。将来的にはこの小さな言語を拡張する価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">クラス宣言から空のメンバを削除することで、この特有の問題を回避することができます。しかし、残りのメンバであるinsertとmemberは型が曖昧ではありませんが、それらを使おうとすると問題が発生します。例えば、次の 2 つの関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">モナディックコンビネーターを使用して、 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; インスタンスの記述を簡略化できます。</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">最後の2つで構築されたコマンドを通常の式に適用することで、必要とされる余分な入力を供給することができます。</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">次に、式とパターンの両方のコンテキストで &lt;code&gt;HeadC&lt;/code&gt; を使用できます。パターンコンテキストでは、少なくとも1つの長さのリストの先頭に一致します。式のコンテキストでは、シングルトンリストを作成します。</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">したがって、型 &lt;code&gt;P&lt;/code&gt; （コンストラクタ &lt;code&gt;MkP&lt;/code&gt; を持つ）を昇格されたデータコンストラクタ &lt;code&gt;'P&lt;/code&gt; （種類 &lt;code&gt;Prom&lt;/code&gt; ）から区別できます。</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">この署名に対して &lt;code&gt;A&lt;/code&gt; をタイプチェックするか、次の宣言を提供するモジュールを使用して &lt;code&gt;Str&lt;/code&gt; をインスタンス化できます。署名をインスタンス化する方法の詳細については、Cabalのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Monad&lt;/code&gt; はなく、 &lt;code&gt;Applicative&lt;/code&gt; および &lt;code&gt;Functor&lt;/code&gt; のインスタンスである型でdo表記を使用できます。</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">例えば、プリミティブに固定値を前置したり、追加したりすることができます。</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">levityポリモーフィズムを使用して、 &lt;code&gt;error&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; で効果を上げることができます。そのタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">ピースを抽出するには、以下のような関数を使うことができます。</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">GHCiを使用する場合、プロファイラーを使用してスタックトレースを収集できます（GHCiの&lt;a href=&quot;#ghci-stack-traces&quot;&gt;スタックトレースを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">これを使って、リストの中で一番長いエントリを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">これを利用して、リストの中で一番短い項目を探すことができます。</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">これらの関数を使用する可能性のあるモジュール（&lt;a href=&quot;ghc-base&quot;&gt;GHC.Baseなど&lt;/a&gt;）でこれらの関数を定義することはできません。これは、不思議なワイヤードインタイプがタイプチェッカーの計算結果と混同されるためです。</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">独自の演算子を定義することができます。</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">3つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを &lt;code&gt;InterpM&lt;/code&gt; にリフトできますが、 &lt;code&gt;InterpM&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; のインスタンスであるため、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="552e222727964454376c689c5337b632f2f7ae47" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">3つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを &lt;code&gt;InterpM&lt;/code&gt; にリフトできますが、 &lt;code&gt;InterpM&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; のインスタンスになるため、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="b98be665de6d96e1b325862bf69bb2db5b4de5f2" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">3つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを &lt;code&gt;InterpM&lt;/code&gt; にリフトできますが、 &lt;code&gt;InterpM&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; のインスタンスになるため、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">何かをデコードするのに十分な入力を &lt;code&gt;f0&lt;/code&gt; に与えることができなかったため、空の文字列を返しました。2番目の継続 &lt;code&gt;f1&lt;/code&gt; を入力の最後のバイトにフィードすると、進行します。</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">私たちは、シミュレートすることができ &lt;code&gt;if&lt;/code&gt; 定義することで、</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; に &lt;code&gt;g&lt;/code&gt; を適用してみることができます。ただし、 &lt;code&gt;g&lt;/code&gt; はタイプ &lt;code&gt;a&lt;/code&gt; の引数と &lt;code&gt;x :: b&lt;/code&gt; 想定しているため、これは機能しません。さらに悪いことに、 &lt;code&gt;f&lt;/code&gt; も &lt;code&gt;a&lt;/code&gt; 型の引数を必要とするため &lt;code&gt;a&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; をa型に変換することはできません。要するに、これを機能させる良い方法はありません。</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; の 2つの値を作成します。1つは &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクターを使用し、もう1つは &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクターを使用します。次に、 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 関数（ &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; がある場合）または「times-two」関数（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; がある場合）のいずれかを適用します。</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; の 2つの値を作成します。1つは &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクターを使用し、もう1つは &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクターを使用します。次に、 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 関数（ &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; がある場合）または「times-two」関数（ &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; がある場合）のいずれかを適用します。</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">UTF-8のCSVエンコーディング機能を以下の表に示します。</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">コンパイルされたバージョンの &lt;code&gt;C&lt;/code&gt; を取得できませんでした！どうした？GHCiでは、コンパイルされたモジュールは他のコンパイル済みモジュールにのみ依存する場合があり、この場合、 &lt;code&gt;C&lt;/code&gt; はオブジェクトファイルを持たない &lt;code&gt;D&lt;/code&gt; に依存するため、GHCiも &lt;code&gt;C&lt;/code&gt; のオブジェクトファイルを拒否しました。では、 &lt;code&gt;D&lt;/code&gt; もコンパイルしましょう：</target>
        </trans-unit>
        <trans-unit id="3b8a8e128dde8f3cc09d2617fe4a012e9ad66250" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; のコンパイル済みバージョンを入手できませんでした！どうした？GHCiでは、コンパイルされたモジュールは他のコンパイルされたモジュールにのみ依存する可能性があります。この場合、 &lt;code&gt;C&lt;/code&gt; はオブジェクトファイルを持たない &lt;code&gt;D&lt;/code&gt; に依存するため、GHCiも &lt;code&gt;C&lt;/code&gt; のオブジェクトファイルを拒否しました。では、 &lt;code&gt;D&lt;/code&gt; もコンパイルしましょう：</target>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">ワイルドカードには3種類の種類があります。</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は普遍的な多形ではないので、 &lt;code&gt;E3&lt;/code&gt; の引数については説明しません。 &lt;code&gt;a&lt;/code&gt; における &lt;code&gt;E3&lt;/code&gt; は、それが最後のタイプのパラメータと同じではないので、（暗黙的に）存在量化である &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(a ~ Int)&lt;/code&gt; であっても、 &lt;code&gt;Int&lt;/code&gt; は構文的に &lt;code&gt;a&lt;/code&gt; と同等ではないため、 &lt;code&gt;E1&lt;/code&gt; または &lt;code&gt;E4&lt;/code&gt; の引数を折りたたみません。</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">難しい方法でパッケージをビルドすることはお勧めしません。代わりに、可能であれば&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt;インフラストラクチャを使用してください。パッケージが特に複雑であるか、多くの構成が必要な場合は、低レベルのメカニズムにフォールバックする必要がある可能性があるため、これらの勇敢な魂のためのいくつかのヒントに従います。</target>
        </trans-unit>
        <trans-unit id="1756ea7351d5c75b6ae409dae0c3a8cdf9b2c46f" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">パッケージを難しい方法でビルドすることはお勧めしません。代わりに、可能であれば&lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt;インフラストラクチャを使用してください。パッケージが特に複雑であるか、多くの構成が必要な場合は、低レベルのメカニズムにフォールバックする必要があるかもしれないので、それらの勇敢な魂のためのいくつかのヒントが続きます。</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">日常業務には &lt;code&gt;-O*&lt;/code&gt; フラグを使用しません。かなりの速度を得るために &lt;code&gt;-O&lt;/code&gt; を使用します。たとえば、何かを測定したい場合。休憩に行きたいときは、 &lt;code&gt;-O2&lt;/code&gt; を使う傾向があります（そして、たくさんのコーヒーブレークに行きます）。</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が同じ型レベルの数値でインスタンス化されたという証拠、または &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が同じ型レベルのシンボルでインスタンス化されたという証拠、または &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">&lt;code&gt;_t1&lt;/code&gt; サンクのみを評価し、リストの先頭を明らかにし &lt;code&gt;_t2&lt;/code&gt; 。テールは、現在_t2にバインドされている別のサンクです。ここで &lt;code&gt;seq&lt;/code&gt; 関数を使用するのは少し不便なので、&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;を使用してより良いインターフェイスを作成することをお勧めします（読者のための練習として残しておきます）。</target>
        </trans-unit>
        <trans-unit id="9fdb86aff4e68170d19ff52b844aa793fc663425" translate="yes" xml:space="preserve">
          <source>We extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; （警告：これはかなり紛らわしい名前の非終端記号です）を2つの追加の形式、つまりインスタンス宣言に表示できるもので拡張します。</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">私たちは、現在の機能番号を見つけるとに戻されるC.これに渡し &lt;code&gt;hs_try_putmvar&lt;/code&gt; を、そしてRTSはそれを実行しようとするべき機能を知るのに役立ちます &lt;code&gt;tryPutMVar&lt;/code&gt; を上。気にしない場合は、 &lt;code&gt;hs_try_putmvar&lt;/code&gt; に機能に &lt;code&gt;-1&lt;/code&gt; を渡すと、任意の機能が選択されます。</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">我々は持っている &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; 、 &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; 、および &lt;code&gt;x :: b&lt;/code&gt; 。これらを使用して、何らかの方法で穴（アンダースコアで示される）を &lt;code&gt;Int&lt;/code&gt; 型の値で埋める必要があります。私たちのオプションは何ですか？</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">この不自然なプログラム以外に、GHCを分岐させる別のクラスのプログラムを見つけたことはありません。問題を修正すると、すべてのコンパイルで余分なオーバーヘッドが発生します。したがって、バグは未修正のままです。&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inlinerには、&lt;/a&gt;より多くの背景があります。</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">私たちはこれらの種類を推測します。</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">テーブル内のセルを内部的に表現するには、次のような型のオブジェクトを使用します。</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">新しいサンプルの始まりを &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; イベントでマークし、</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">我々はまた、我々はそれらを検出した場合の配列をコードする際に無効な文字を通知する必要があるかもしれません &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; にSを &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; ための &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; のモードは往復にこれらを作成し、当社の内部UTF-16エンコーディングによってバイト。</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">将来的には、この機能の構文や意味を変更する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEADのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;をダウンロード&lt;/a&gt;できるようにする場合があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="2ebe98c6a2119e741bdf064584e3db025f6347d2" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEADのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;をダウンロード&lt;/a&gt;できるようにする場合があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="c79f15081f54da10e6044689f529ce2f478e6d97" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;https://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEADのスナップショットリリース&lt;a href=&quot;https://www.haskell.org/ghc/dist/current/dist/&quot;&gt;をダウンロード&lt;/a&gt;できるようにする場合があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">現在の安定版ブランチのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;をダウンロードできるようにする場合&lt;/a&gt;があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="f4fb296fd8e8ef0d2da857b55d5e427e6713096b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">現在の安定版ブランチのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;をダウンロードできるようにする場合&lt;/a&gt;があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="f8f550102596507541eecd8fea3584501d85066c" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;https://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">現在の安定したブランチのスナップショットリリース&lt;a href=&quot;https://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;をダウンロードできるようにする場合&lt;/a&gt;があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="c0f8df20c6e6b47bd015211c44bf700bb364d39e" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">レイジー計算、つまりサンクは、作成時に現在のスタックをキャプチャし、評価時にこのスタックを復元することを前述しました。トップレベルのサンクはどうですか？それらはプログラムのコンパイル時に「作成」されるので、どのスタックを与える必要がありますか？トップレベルのサンクの技術名はCAF（「ConstantApplicativeForm」）です。 GHCは、モジュール内のすべてのCAFに、単一のコストセンター &lt;code&gt;M.CAF&lt;/code&gt; で構成されるスタックを割り当てます。ここで、 &lt;code&gt;M&lt;/code&gt; はモジュールの名前です。オプション&lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;を使用して、各CAFに異なるスタックを与えることもできます。これは、&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; を&lt;/a&gt;使用してコンパイルする場合に特に便利です（&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; の&lt;/a&gt;デフォルトのように）関数本体の定数がトップレベルに引き上げられ、CAFになるため。これらのCAFが何に対応するかを判断するには、おそらくコア（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）を参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">先に述べたように、遅延計算（サンク）は、作成時に現在のスタックをキャプチャし、評価時にこのスタックを復元します。トップレベルのサンクはどうですか？それらはプログラムのコンパイル時に「作成」されるので、どのスタックにそれらを与える必要がありますか？トップレベルサンクの技術名はCAF（「Constant Applicative Form」）です。 GHCは、モジュール内のすべてのCAFに、単一のコストセンター &lt;code&gt;M.CAF&lt;/code&gt; で構成されるスタックを割り当てます。ここで、 &lt;code&gt;M&lt;/code&gt; はモジュールの名前です。オプション&lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;を使用して、各CAFに異なるスタックを提供することもできます。これは、&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; を&lt;/a&gt;使用してコンパイルする場合に特に便利です（&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; を&lt;/a&gt;使用したデフォルトの場合）以上）、関数本体の定数がトップレベルに引き上げられ、CAFになるため。これらのCAFが何に対応するかを判別するには、おそらくコア（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）を調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="7ac173e2f1e3e157189bce46a9d6b1220792bdd5" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;../using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">私たちは（B）を大いに好みます。どうして？GHCは、 &lt;code&gt;(True :~: False)&lt;/code&gt; が空の型であることを理解できるためです。したがって、（B）には部分性がなく、GHCは&lt;a href=&quot;../using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;を使用してコンパイルできます。一方、（A）は危険に見え、GHCは、実際に関数が呼び出されないことを確認しません。</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">私たちは（B）をはるかに好みます。どうして？GHCは &lt;code&gt;(True :~: False)&lt;/code&gt; が空の型であることを理解できるためです。したがって、（B）には&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;がなく、GHCは-Wincomplete-patternsおよび&lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;を使用してコンパイルできます。一方、（A）は危険に見え、GHCは実際には関数が呼び出されないことを確認しません。</target>
        </trans-unit>
        <trans-unit id="703530a9bd76b6d41cdef63f80ac7642abb989f8" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">私たちは（B）を大いに好みます。どうして？GHCは、 &lt;code&gt;(True :~: False)&lt;/code&gt; が空のタイプであることを理解できるためです。したがって、（B）には&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;がなく、GHCは-Wincomplete-patternsおよび&lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;を使用してコンパイルできます。一方、（A）は危険に見え、GHCは、実際に関数が呼び出されないことを確認しません。</target>
        </trans-unit>
        <trans-unit id="6b18525b3456e672ccab92cf738f47ed84e0b770" translate="yes" xml:space="preserve">
          <source>We normally mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">通常、新しいサンプルの開始を &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; イベントでマークします。</target>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">次に、実際の &lt;code&gt;encode&lt;/code&gt; 関数のクラス &lt;code&gt;Encode&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">ここでは、hpcの主なモードについて、より詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">私たちは元々、式の自由変数だけではなく、スコープ内のすべての変数にバインディングを提供していましたが、これがパフォーマンスに大きく影響することがわかりましたので、現在は自由変数だけに制限しています。</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; と &lt;code&gt;argv&lt;/code&gt; への参照を &lt;code&gt;hs_init()&lt;/code&gt; に渡して、RTSの引数（ &lt;code&gt;+RTS...-RTS&lt;/code&gt; 間の引数）を分離できるようにします。</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">ファイルが見つからなかったり、読み込みに失敗した場合は終了します。(ハドックや他のクライアントのための便利なルーチン)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;フラグと並行して実行することを目的としたコードをコンパイルすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">標準のWindowsコンソールでGHCiを実行することをお勧めします &lt;code&gt;ghci&lt;/code&gt; インストーラーによって追加されたスタートメニュー項目から &lt;code&gt;GHCi&lt;/code&gt; オプションを選択するか、スタート- &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; を使用してWindowsコンソールを取得し、そこからghciを呼び出しますあなたの &lt;code&gt;PATH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">ブランチを &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のリストとして表すため、バージョン3.2.1は[3,2,1]になります。辞書式順序（のすなわちデフォルトインスタンス &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;[Int]&lt;/code&gt; ）枝の自然順序付けを提供します。</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;default&lt;/code&gt; を再利用して、署名がデフォルトのメソッドにのみ適用されることを通知します。 &lt;code&gt;Enum&lt;/code&gt; クラスのインスタンスを定義するときに、元の &lt;code&gt;enum&lt;/code&gt; のタイプ &lt;code&gt;[a]&lt;/code&gt; が引き続き適用されます。ただし、空のインスタンスを指定すると、デフォルトの実装 &lt;code&gt;(map to genum)&lt;/code&gt; が入力され、型 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 型チェックされます。</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">境界チェックが融合されるように、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; の連続使用を書き換えます。例えば、</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">GHCについては、以下のメーリングリストを運営しています。適当と思われる方は、ぜひご参加ください。</target>
        </trans-unit>
        <trans-unit id="f1dbba1856e51980e45e786acb354e0d1d1df7c9" translate="yes" xml:space="preserve">
          <source>We say that a variable whose multiplicity constraint is &lt;code&gt;Many&lt;/code&gt; is &lt;em&gt;unrestricted&lt;/em&gt;.</source>
          <target state="translated">多重度制約が &lt;code&gt;Many&lt;/code&gt; である変数は&lt;em&gt;無制限&lt;/em&gt;であると言います。</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の型変数は&lt;em&gt;指定され&lt;/em&gt;ているが、 &lt;code&gt;g&lt;/code&gt; の型変数は&lt;em&gt;推論&lt;/em&gt;&lt;em&gt;さ&lt;/em&gt;れていると言います。一般的なルールは次のとおりです。ユーザーがソースプログラムで型変数を書き込んだ場合は、それが&lt;em&gt;指定されます&lt;/em&gt;。そうでない場合は、&lt;em&gt;推定され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="86eabd9ae7f589e2df7e5f7c967151a67519bb49" translate="yes" xml:space="preserve">
          <source>We see that a lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;g e&lt;/code&gt; endomorphisms, with &lt;code&gt;f'&lt;/code&gt; as as the operator, in fact yields a strict left fold, that avoids building a deep chain of intermediate thunks:</source>
          <target state="translated">&lt;code&gt;f'&lt;/code&gt; を演算子として使用した、 &lt;code&gt;g e&lt;/code&gt; 自己準同型の怠惰な &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; は、実際には厳密な左フォールドを生成し、中間のサンクの深いチェーンの構築を回避します。</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; にブレークポイントを設定して呼び出します。</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">エントリ数も共有メモリに格納され、複数のコアでの継続的な更新が非常に遅いため、複数のコアでプロファイルされるプログラムをコンパイルするときは&lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt;を使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">次に、新しいSafe Haskell &lt;code&gt;-XSafe&lt;/code&gt; フラグを使用して &lt;code&gt;Danger&lt;/code&gt; プラグインをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; を拡張する（警告：これはやや紛らわしい名前の非終端記号です）、2つの追加の形式、つまり、インスタンス宣言に表示できるものを正確に</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">デフォルトのシグネチャを使用して、GHCの&lt;a href=&quot;#generic-programming&quot;&gt;ジェネリックプログラミング&lt;/a&gt;（ジェネリックプログラミング）を簡略化します。</target>
        </trans-unit>
        <trans-unit id="688e02acbe0a3ecd6d1989ae0fb801ec38f3ebed" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">デフォルトの署名を使用して、GHC（&lt;a href=&quot;generics#generic-programming&quot;&gt;ジェネリックプログラミング&lt;/a&gt;）のジェネリックプログラミングを簡素化します。</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">&lt;code&gt;criterion&lt;/code&gt; ライブラリ（&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;）を使用して、次の表にあるエンコード関数の効率をベンチマークします。</target>
        </trans-unit>
        <trans-unit id="1dae9d07b3904219cff50bee9567703d83f53689" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;https://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">&lt;code&gt;criterion&lt;/code&gt; ライブラリ（&lt;a href=&quot;https://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;）を使用して、次の表でエンコード関数の効率をベンチマークします。</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">継続 &lt;code&gt;f0&lt;/code&gt; を使用して、2番目のパケットをデコードします。</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">以下のインポートを使用し、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; を省略して読みやすくしています。</target>
        </trans-unit>
        <trans-unit id="f22709004a13a3fd94746ba6a021463ab6f37071" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">以下のインポートを使用し、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; を省略して読みやすくします。</target>
        </trans-unit>
        <trans-unit id="22f0961872a4ad51f0a43371524e8f12b244e439" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">以下のインポートを使用し、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; を省略して読みやすくします。</target>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">このような動作をバグとして報告していただければ、修正できるようになります。</target>
        </trans-unit>
        <trans-unit id="cc16631b4890edd93973a20a4f9c5e2d14d862c2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">GHC固有のビットを &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt; ; 残りのコードは、FFI標準をサポートするHaskell実装間で移植可能である必要があります。</target>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">GHC固有のビットを &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; で囲みました。残りのコードは、FFI標準をサポートするHaskell実装間で移植可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">弱いポインタは、キャッシュやメモテーブルに特に便利です。メモ・テーブルを構築するには、関数の引数(キー)からその結果(値)へのデータ構造のマッピングを構築します。新しい引数に関数を適用するときは、まず、キーと値のペアがすでにメモテーブルにあるかどうかをチェックします。ここで重要なのは、メモテーブル自体がキーと値を保持してはいけないということです。したがって、テーブルには通常のポインタではなく、キーへの弱いポインタが含まれていなければなりません。値へのポインタは弱くてはいけません。値への唯一の参照が実際にはメモテーブルからのものかもしれないからです。</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">弱いポインター。</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">ThreadIdsへの参照が弱い</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">GHCユーザーズガイドへようこそ</target>
        </trans-unit>
        <trans-unit id="9a43d24919845073d089f519130b6009f44f6465" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;.</source>
          <target state="translated">再帰関数、および相互再帰的な関数のグループはどうですか？コストはどこに起因しますか？GHCは、関数のどのグループが互いに再帰的に呼び出されたかに関する情報を保持しますが、この情報は基本的な時間と割り当てプロファイルには表示されません。代わりに、コールグラフは次のようにツリーにフラット化されます。現在のスタックの他の場所で発生した場合、スタック上の別のエントリはプッシュされません。代わりに、この呼び出しのコストが呼び出し元&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2に&lt;/a&gt;集約されます。</target>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">再帰関数、および相互に再帰的な関数グループについてはどうですか？費用はどこに帰属しますか？まあ、GHCは相互に再帰的に呼び出される関数のグループに関する情報を保持しますが、この情報は基本的な時間および割り当てプロファイルには表示されません。代わりに、コールグラフは次のようにツリーにフラット化されます。現在のスタックの他の場所で発生し、スタック上の別のエントリをプッシュせず、代わりにこの呼び出しのコストが呼び出し元に集計されます&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">元の定義で発生したあいまいさの問題はどうですか？空の関数は、まだ型を持つ &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; 、曖昧な型としてことを考えることはもはや必要ではない：変数が、 &lt;code&gt;e&lt;/code&gt; が右側に表示されない &lt;code&gt;=&amp;gt;&lt;/code&gt; シンボル、クラスの依存関係 &lt;code&gt;Collects&lt;/code&gt; 教えてくれる &lt;code&gt;=&amp;gt;&lt;/code&gt; 記号の右側に表示される &lt;code&gt;ce&lt;/code&gt; によって一意に決定されること。したがって、空が使用されているコンテキストは、 &lt;code&gt;ce&lt;/code&gt; と &lt;code&gt;e&lt;/code&gt; の両方のタイプを判別するのに十分な情報を提供できます、あいまいさなし。より一般的には、 &lt;code&gt;=&amp;gt;&lt;/code&gt; の左側に、右側の変数によって（直接または間接的に）一意に決定されない変数が含まれている場合にのみ、型をあいまいであると見なす必要があります。</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">実際に起こるのは、GHCiが式を型チェックし、 &lt;code&gt;IO&lt;/code&gt; 型がない場合は次のように変換することです。式 &lt;code&gt;e&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 型の値を使用して何ができますか？特に、 &lt;code&gt;MkFoo&lt;/code&gt; でパターンマッチングを行うとどうなりますか？</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">xに明示的な型を「提供する」とはどういう意味ですか？パターンタイプシグネチャ（&lt;a href=&quot;#scoped-type-variables&quot;&gt;レキシカルスコープのタイプ変数&lt;/a&gt;）を使用して、xのタイプシグネチャを直接指定することで、次のようになります。</target>
        </trans-unit>
        <trans-unit id="91ea760880e6d9bd2555f022fdf2a6393ee5b3e8" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">xに明示的な型を「提供」するとはどういう意味ですか？これを行うには、パターン型署名（&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;字句スコープの型変数&lt;/a&gt;）を使用して、xの型署名を直接指定します。したがって、次のようになります。</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">安全とはどういう意味ですか？&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; で&lt;/a&gt;コンパイルされたモジュールをインポートしても、モジュールをインポートせずに正常にコンパイルされるコードの意味が変わることはありません。これは、&lt;em&gt;セマンティック整合&lt;/em&gt;性と呼ばれるSafe Haskellプロパティです。</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">型コンストラクタの「ユーザー指定の完全な種類シグネチャ」とは正確に何と見なされますか これらはフォームです：</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">これは&lt;em&gt;実存的&lt;/em&gt;定量化とどのように関係していますか？単にその &lt;code&gt;MkFoo&lt;/code&gt; が（ほぼ）同型のタイプを持っていること</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">私たちは（のようなタイプのコンストラクタを介して、その範囲の一般的なクラスを定義する場合 &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; の、または &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; ）？</target>
        </trans-unit>
        <trans-unit id="52d850cf6e82ee71cba430d22124534321d40e28" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depend&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; の種類は何ですか？ &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; と言う人もいるかもしれません。タイプ-&amp;gt; k-&amp;gt;タイプですが、これは正しくありません。これは、 &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; のような誤ったものを許可するためです。これは、 &lt;code&gt;Int&lt;/code&gt; が &lt;code&gt;Bool&lt;/code&gt; の種類ではないため、拒否する必要があります。重要な観察は、2番目の引数の種類が最初の引数に&lt;em&gt;依存&lt;/em&gt;するということです。 GHCは、 &lt;code&gt;ProxyKVis&lt;/code&gt; の種類に与える構文でこの依存関係を示します。</target>
        </trans-unit>
        <trans-unit id="39c87b0db40f56398a44a5dc90aefe416e407bb2" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depends&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; の種類は何ですか？ &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; と言う人もいるかもしれません。タイプ-&amp;gt; k-&amp;gt;タイプですが、これは正しくありません。これは、 &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; のような誤ったものを許可するためです。これは、 &lt;code&gt;Int&lt;/code&gt; が &lt;code&gt;Bool&lt;/code&gt; の種類ではないため、拒否する必要があります。重要な観察は、2番目の引数の種類が最初の引数に&lt;em&gt;依存&lt;/em&gt;するということです。GHCは、 &lt;code&gt;ProxyKVis&lt;/code&gt; の種類に与える構文でこの依存関係を示します。</target>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">結果タイプのこの「 &lt;code&gt;a&lt;/code&gt; 」は何ですか？明らかにこれを意味するものではありません。</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">どのようなスプライスなのか</target>
        </trans-unit>
        <trans-unit id="658954d7cdd84a10f186220aa5a43363b9844f19" translate="yes" xml:space="preserve">
          <source>What remains to be done is an inductive step beyond the empty and singleton cases. For a concrete &lt;code&gt;Traversable&lt;/code&gt; functor &lt;code&gt;T&lt;/code&gt; we need to be able to extend our structure incrementally by filling in holes. We can view a partially built structure &lt;strong&gt;&lt;code&gt;t0 :: T a&lt;/code&gt;&lt;/strong&gt; as a function &lt;strong&gt;&lt;code&gt;append :: a -&amp;gt; T a&lt;/code&gt;&lt;/strong&gt; that takes one more element &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; to insert into the container to the right of the existing elements to produce a larger structure. Conversely, we can view an element &lt;code&gt;a&lt;/code&gt; as a function &lt;strong&gt;&lt;code&gt;prepend :: T a -&amp;gt; T a&lt;/code&gt;&lt;/strong&gt; of a partially built structure that inserts the element to the left of the existing elements.</source>
          <target state="translated">やらなければならないことは、空の場合やシングルトンの場合を超えた帰納的なステップです。具体的な &lt;code&gt;Traversable&lt;/code&gt; 可能なファンクター &lt;code&gt;T&lt;/code&gt; の場合、穴を埋めることによって構造を段階的に拡張できる必要があります。部分的に構築された構造&lt;strong&gt; &lt;code&gt;t0 :: T a&lt;/code&gt; &lt;/strong&gt;関数&lt;strong&gt; &lt;code&gt;append :: a -&amp;gt; T a&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;T a&lt;/strong&gt;として表示できます。これは、既存の要素の右側にあるコンテナに挿入する要素&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;をもう1つ取り、より大きな構造を生成します。逆に、要素 &lt;code&gt;a&lt;/code&gt; を、既存の要素の左側に要素を挿入する部分的に構築された構造の関数&lt;strong&gt; &lt;code&gt;prepend :: T a -&amp;gt; T a&lt;/code&gt; &lt;/strong&gt;として表示できます。</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">与えられた型パラメーターが持つべき役割は何か？ GHCは役割推論を実行して、すべてのパラメーターの正しい役割を決定します。それはいくつかの基本的な事実から始まります： &lt;code&gt;(-&amp;gt;)&lt;/code&gt; には2つの表現パラメーターがあります。 &lt;code&gt;(~)&lt;/code&gt; 2つの公称パラメーターがあります。すべてのタイプファミリーのパラメーターは公称値です。そして、すべてのGADTのようなパラメーターは公称値です。次に、これらのファクトは、これらのタイプが使用されるすべての場所に伝搬されます。データ型とシノニムのデフォルトの役割はファントムです。クラスのデフォルトの役割は名義です。したがって、データ型とシノニムの場合、右側で使用されていない（またはファントム位置の他のタイプでのみ使用されている）パラメータはファントムになります。パラメーターが表現位置で使用される（つまり、対応する変数がロール表現であるコンストラクターへの型引数として使用される）場合は常に、その役割をファントムから表現に上げます。同様に、パラメーターが公称位置で使用される場合、その役割は公称にアップグレードされます。役割を公称からファントムまたは表現に、または表現からファントムにダウングレードすることはありません。このようにして、各パラメーターの最も一般的な役割を推測します。</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; の役割はどうあるべきですか？最初は赤面しますが、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はどちらも右側で使用され、どちらもタイプファミリーに含まれていないため、どちらもロールを表すものである必要があります。ただし、次の例に示すように、これは誤りです。</target>
        </trans-unit>
        <trans-unit id="7201ad0e4b9c4fd0ef63e8c881a6df6e60416a86" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;rsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; の役割はどうあるべきですか？一見 &lt;code&gt;a&lt;/code&gt; と、 &lt;code&gt;b&lt;/code&gt; とbの両方が右側で使用され、どちらも型族に関与していないため、aとbの両方が役割を表す必要があるように思われます。ただし、次の例が示すように、これは間違っています。</target>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCiは何をすべきか？厳密に言えば、プログラムがあいまいです。 &lt;code&gt;show (reverse [])&lt;/code&gt; （GHCiがここで計算するもの）にはタイプ &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; あり、その表示方法はタイプ &lt;code&gt;a&lt;/code&gt; によって異なります。例えば：</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">単一のパターンセットに適用される複数の &lt;code&gt;COMPLETE&lt;/code&gt; セットがある場合はどうなりますか？この例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">どのようなヒーププロファイルを集めているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskellコンパイラーが適切に生成するものは、使用されるバックエンドコードジェネレーターによって異なります。詳細については、&lt;a href=&quot;codegens#code-generators&quot;&gt;GHCバックエンド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">インスタンスを導出する際にユーザーが明示的に要求するもの。</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">これでできることは、異種の値を操作する関数の束と一緒にパッケージ化して、そのパッケージの集合を統一的に扱うことです。この方法でかなりオブジェクト指向的なプログラミングを表現することができます。</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">最後に何をするか。</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m2&lt;/code&gt; ではなく &lt;code&gt;m1&lt;/code&gt; のキーをどうするか</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; ではなく &lt;code&gt;m2&lt;/code&gt; のキーをどうするか</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; と &lt;code&gt;m2&lt;/code&gt; の両方のキーをどうするか</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">非オプションに続くオプションをどうするか</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">テキストをどうするか。</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">私たちが示したものは、どの &lt;code&gt;make&lt;/code&gt; でも機能するはずです。</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">何異なるのは、私たちが今使っていることである &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; （にするために使用し、そのパラメータ、パラメータを参照するために）、名前のどこかで明示的に言及されていません。また、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;Tree a&lt;/code&gt; の再帰的な使用を参照しています。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">例外が発生したときにターゲットスレッドが行っていた作業が失われることはありません。</target>
        </trans-unit>
        <trans-unit id="25aaf639f200ab012209ed7c616b7427cf43a690" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;が有効になっている場合は、 &lt;code&gt;anyclass&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">とき&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; が&lt;/a&gt;有効になっている、あいまいなフィールドではなく、トップレベルでのよりも、そのデータ型の一部としてエクスポートする必要があります。たとえば、以下は合法です。</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、タイプおよび種類の変数は、&lt;a href=&quot;#data-instance-declarations&quot;&gt;Dataインスタンス宣言&lt;/a&gt;または&lt;a href=&quot;#type-instance-declarations&quot;&gt;Typeインスタンス宣言&lt;/a&gt;と同じ方法で（および同じ制限付きで）関連データまたはタイプファミリーインスタンスに明示的にバインドできます。たとえば、上記を適用すると、以下が受け入れられます。</target>
        </trans-unit>
        <trans-unit id="dcb444e9dc2c42002165fa1d9f676b2862da1a0d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、左側で使用される型変数と種類変数を明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、左側で使用されるtypeまたはkind変数を明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="9b1b787d1263816e3855c7cfe78d8c359b80a2c3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; が&lt;/a&gt;有効になっていると我々はnewtypeのために導出され、その後、使用 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">とき&lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt;有効になっている、GHCは、印刷し &lt;code&gt;RuntimeRep&lt;/code&gt; の軽さ、ポリモーフィック型の型変数を。そうでない場合、GHCはこれらをデフォルトで &lt;code&gt;LiftedRep&lt;/code&gt; に設定します。例えば、</target>
        </trans-unit>
        <trans-unit id="5cd8e7617284a82575e75959536dc8754f27decc" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;が有効になっている場合は、 &lt;code&gt;anyclass&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2a39604dbdf930eeb49569712f91ae6fd1a07491" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicitly bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、タイプ変数と種類変数は、&lt;a href=&quot;#data-instance-declarations&quot;&gt;データインスタンス宣言&lt;/a&gt;または&lt;a href=&quot;#type-instance-declarations&quot;&gt;タイプインスタンス宣言&lt;/a&gt;と同じ方法で（同じ制限付きで）、関連付けられたデータまたはタイプファミリーインスタンスに明示的にバインドできます。たとえば、上記を適応させると、次のことが受け入れられます。</target>
        </trans-unit>
        <trans-unit id="37685117656dc05c88d241b88847cf56b98f6523" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、左側で使用される型変数と種類変数を明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="1700d840d06c00c9fb0b89fd7a848535205dcc1d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;exts/explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">&lt;a href=&quot;exts/explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、明示的に定量化された型変数も未使用として識別される場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効な場合、明示的に数量化された型変数も未使用として識別される場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="5311fb9fec0c8a69090b42668184cdd614a4ed78" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; が&lt;/a&gt;有効になっていると我々はnewtypeのために導出され、その後、使用 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;が有効な場合、推論された変数は中括弧で出力されます。したがって、前の例のデータコンストラクター &lt;code&gt;Proxy&lt;/code&gt; タイプは、 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; 。GHCiセッションでこの動作を観察できます。</target>
        </trans-unit>
        <trans-unit id="7e630e40474031593156647d2e58d26eafbc9c93" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-pgmc&lt;/code&gt; is used, GHC by default will never pass the &lt;code&gt;-no-pie&lt;/code&gt; command line flag. The rationale is that it is not known whether the specified compiler will support it. This flag can be used to indicate that &lt;code&gt;-no-pie&lt;/code&gt; is supported. It has to be passed after &lt;code&gt;-pgmc&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;-pgmc&lt;/code&gt; が使用され、GHCはデフォルトで渡すことは決してありません &lt;code&gt;-no-pie&lt;/code&gt; コマンドラインフラグを。理論的根拠は、指定されたコンパイラがそれをサポートするかどうかがわからないということです。このフラグは、 &lt;code&gt;-no-pie&lt;/code&gt; がサポートされていることを示すために使用できます。 &lt;code&gt;-pgmc&lt;/code&gt; の後に渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐには、通常、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; を使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐために、通常は &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; のみを使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐには、通常、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; を使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐために、通常は &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; のみを使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
