<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">コンパイラフラグ &lt;code&gt;-fno-cse&lt;/code&gt; を使用して、モジュールで一般的な部分式の削除が実行されないようにします。これにより、分離することを意図していた2つの副作用が組み合わされる可能性があります。良い例は、複数のグローバル変数を使用することです（以下の例の &lt;code&gt;test&lt;/code&gt; のように）。</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">デバッグフラグ&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;を使用して、実行されたルールを確認します。さらに情報が必要な場合、&lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;は個々のルールの実行を示し、&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;は書き換えの前後のコードの外観も示します。</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">デバッグランタイムを使用する</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ネイティブコードジェネレーターでのレジスター割り当てには、グラフカラーリングレジスターアロケーターを使用します。&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">ネイティブ コード ジェネレーターで反復合体グラフのカラーリング レジスタ アロケーターを使用します。</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">入力と出力の両方でネイティブの改行表現を使用します。</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">新しい cfg ベースのブロックレイアウトアルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">「ファイル」または &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; のパッケージ環境を使用します。設定されている場合 &lt;code&gt;-&lt;/code&gt; パッケージ環境は読み込まれません。</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">私用エスケープメカニズムを使用して、不正なシーケンスがラウンドトリップされることを許可しようとします。</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">実行可能プログラムでランタイムフラグ&lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;を使用して、 &lt;code&gt;-with-rtsopts&lt;/code&gt; で設定されたオプションを確認します。</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">指定されたパッケージ環境を使用します。</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">付属のハンドルを使用します。</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">スレッドランタイムを使用する</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">以下のように、レコード更新にプッシュされるタイプを使用します。</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">プロセスを作成する際には、windows CREATE_NEW_CONSOLE フラグを使用してください。</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">プロセスを作成する際にwindowsのDETACHED_PROCESSフラグを使用します。</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">この関数は、バインドされたスレッドの使用によるパフォーマンスの低下を実際に観察したまれな場合に&lt;em&gt;のみ&lt;/em&gt;使用してください。メインスレッドをバインドする必要がなく、同時実行性を&lt;em&gt;多用&lt;/em&gt;するプログラム（Webサーバーなど）では、その &lt;code&gt;main&lt;/code&gt; アクションを &lt;code&gt;runInUnboundThread&lt;/code&gt; でラップする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">この関数は、JSONやHTMLのようなテキストベースのフォーマットのための効率的なエンコーダーを実装するために使用します。</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数を使用して、小さめの（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を作成するか、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; によって生成されたチャンクと共有されないことを保証する必要がある場合。</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数を使用して、小さめの（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を作成するか、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; によって生成されたチャンクと共有されないことを保証する必要がある場合。</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">この戦略を使用して、生成された直後にチャンクが破棄される遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を生成します。たとえば、それらを生成してネットワークソケットに書き込むだけの場合。</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">この戦略を使用して、チャンクが1つのガベージコレクションで存続する可能性が高い遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を生成します。この戦略は、メモリが過剰にこぼれるのを避けるために、半分未満しか満たされていないバッファーをトリミングします。</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">箱なしタイプ(GHCの拡張機能)を使用します。</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">式、型、種類を出力するときは、Unicode構文を使用してください。&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="1217e1edd93d0feba5136f9afad7e849709839fd" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">式、タイプ、および種類を出力するときは、Unicode構文を使用してください。&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; で使用</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; で使用する</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">⟨cmd⟩ を C コンパイラとして使用します。</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">⟨cmd⟩をCコンパイラとして使用します。</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">⟨cmd⟩をCプリプロセッサとして使用（ &lt;code&gt;-cpp&lt;/code&gt; のみ）</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">Cプリプロセッサとして⟨cmdwithを使用します（ &lt;code&gt;-cpp&lt;/code&gt; のみ）。</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">DLLジェネレータとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">DLLジェネレータとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">LLVMコンパイラとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">LLVMコンパイラとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">LLVMオプティマイザとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">LLVMオプティマイザとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">アセンブラとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">アセンブラには⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="bb31dfc0c69b643471fc895b68566295b7824e3e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">libtoolのコマンドとして⟨cmd⟩を使用します（&lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt;のみ）。</target>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">libtoolのコマンドとして⟨cmd⟩を使用します（ &lt;code&gt;-staticlib&lt;/code&gt; のみを使用）。</target>
        </trans-unit>
        <trans-unit id="71a83bd18619d2dc927e0bb5ca8f99a89d38bbb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">⟨cmd⟩を外部インタープリターコマンドとして使用します（&lt;a href=&quot;ghci#external-interpreter&quot;&gt;別のプロセスでのインタープリターの実行を&lt;/a&gt;参照）。デフォルト： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 場合&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; が&lt;/a&gt;有効になっている、 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 場合&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; が&lt;/a&gt;有効になっている、または &lt;code&gt;ghc-iserv&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">⟨cmd⟩を外部インタープリターコマンドとして使用します（「&lt;a href=&quot;ghci#external-interpreter&quot;&gt;インタープリターを別のプロセスで実行する&lt;/a&gt;」を参照）。デフォルト： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 場合 &lt;code&gt;-prof&lt;/code&gt; が有効になっている、 &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 場合 &lt;code&gt;-dynamic&lt;/code&gt; が有効になっている、または &lt;code&gt;ghc-iserv&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">外部インタプリタコマンドとして、⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="481e440a89078b7c2339966f16ab888ce0b1d958" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">libtoolコマンドとして⟨cmd⟩を使用します（&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt;のみを使用する場合）。</target>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">toolcmd⟩をlibtoolコマンドとして使用します（ &lt;code&gt;-staticlib&lt;/code&gt; のみを使用する場合）。</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">リンカとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="ac711284292bd26e5315cd00ca382caef9435d2c" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files</source>
          <target state="translated">オブジェクトファイルをマージする際のリンカーとして、Paces_27E8cmansansoredPe_27E9ansoredを使用します。</target>
        </trans-unit>
        <trans-unit id="aa8be27c0b9f201fc0c9472f4f8108d93d582bc5" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</source>
          <target state="translated">オブジェクトファイルをマージするとき(GHCiにロードするために結合されたオブジェクトを生成するときなど)のリンカとして、Ps_27E8cmanswagend DealsPe_27E9 americanを使用してください。</target>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">リンカには⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">リテレートプリプロセッサとして⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">⟨cmd⟩ をリテレートプリプロセッサとして使用します。</target>
        </trans-unit>
        <trans-unit id="ae3fcd7e913573d0ca98fd73aac79e8ca6510b13" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">プリプロセッサとして⟨cmd⟩を使用します（&lt;a href=&quot;#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt;のみ）。</target>
        </trans-unit>
        <trans-unit id="7a29c6934473566c99b28cee4bc5456cde213b21" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;phases#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only)</source>
          <target state="translated">プリプロセッサとして⟨cmd⟩を使用します（&lt;a href=&quot;phases#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt;のみ）</target>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">⟨cmd⟩をプリプロセッサとして使用（ &lt;code&gt;-F&lt;/code&gt; のみ）</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">⟨cmd⟨をプリプロセッサとして使用します（ &lt;code&gt;-F&lt;/code&gt; のみを使用）。</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">Windows上でマニフェストを埋め込むプログラムとして、⟨cmd⟩を使用します。</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">Windowsにマニフェストを埋め込むために使用するプログラムとして「cmd」を使用します。通常、これはプログラム &lt;code&gt;windres&lt;/code&gt; であり、GHCインストールで提供されます。&lt;a href=&quot;#options-linker&quot;&gt;リンクに影響&lt;/a&gt;するオプションの &lt;code&gt;-fno-embed-manifest&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">⟨cmd⟩をスプリッターとして使用します。</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">⟨cmd⟩をスプリッターとして使用します。</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">makefile として ⟨file⟩ を使用します。</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makefile&lt;/code&gt; または &lt;code&gt;Makefile&lt;/code&gt; ではなく、「file」をmakefileとして使用します。「ファイル」が存在しない場合は、 &lt;code&gt;mkdependHS&lt;/code&gt; によって作成されます。私たちは、頻繁に使用する &lt;code&gt;-dep-makefile .depend&lt;/code&gt; で依存関係を入れて &lt;code&gt;.depend&lt;/code&gt; をして、 &lt;code&gt;include&lt;/code&gt; たファイル &lt;code&gt;.depend&lt;/code&gt; に &lt;code&gt;Makefile&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">プログラムの実行時には、⟨x⟩同時スレッドを使用します。</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">GHCiがインタラクティブバインディングのセットのSPTエントリを追加するために使用します。</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">x などで使用されますが、プログラマは使用できません。</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">コンパイラが生成したエラーメッセージに使用されます。</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; の出現をマークするために使用されます</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">パラメータの出現をマークするために使用します。</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">オーバーロードされたリテラルとオーバーロードされていないリテラルに使用されます。今のところ、オーバーロードされていないリテラルを表現する良い方法がありません。多分、それは重要ではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">Haskellの翻訳で使用される &lt;code&gt;[n,n'..]&lt;/code&gt; と &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 、可能な実装はされて &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; 、 &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; 、 &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; および &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 例：</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">Haskellの翻訳で使用される &lt;code&gt;[n,n'..m]&lt;/code&gt; と &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; 、ある可能な実施 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; 、 &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 、 &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; および &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 例：</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">Haskellの翻訳に使用される &lt;code&gt;[n..]&lt;/code&gt; と &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; 、ある可能な実施 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">Haskellの翻訳で使用される &lt;code&gt;[n..m]&lt;/code&gt; と &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; 、可能な実現さ &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">Fast String フラグメントを表現するために使用されていましたが、現在は非推奨となっており、Str コンストラクタと同じです。</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">組み合わせて使用するための有用なコンビネータ &lt;code&gt;xxxBy&lt;/code&gt; のからの機能の家族&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;例えば、：</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">便利なエラー処理機能</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">NF = WHNFが保持するタイプの &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; を定義するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">ガベージコレクションを必要とする長期間の割り当てに役立ちます。ただし、メモリへのポインタを外部データ構造に格納する場合は、 &lt;code&gt;mallocForeignPtr&lt;/code&gt; は適切な選択肢ではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">割り当てが特定の &lt;code&gt;IO&lt;/code&gt; 計算を対象とすることを目的としている場合、短期的な割り当てに役立ちます。この種の割り当ては、FFI関数との間でデータをマーシャリングするときに一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">役に立ちます。</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">便利な関数や組み合わせ。</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">便利な機能をご紹介します。</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">便利なヘルパー機能</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">インスタンスを書くのに便利なヘルパー</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">不変量から得られる有用な特性。</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">ユーザー環境</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">ユーザーインタラクション機能</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">ユーザー名</target>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">ユーザー設定</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">ユーザー定義の演算子には、新しい &lt;code&gt;form&lt;/code&gt; キーワードではなくバナナブラケットが付いています。</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">ユーザー定義型エラー</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">ユーザー提供の比較（ &lt;code&gt;Ord&lt;/code&gt; コンテキストの置き換え）</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">ユーザー指定の等価性（ &lt;code&gt;Eq&lt;/code&gt; コンテキストの置き換え）</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">ユーザーは、GHCが指紋を計算するために内部で使用するのと同じ関数を使用できます。&lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprintの&lt;/a&gt;モジュールは、指紋を構築するための便利な機能を提供します。たとえば、 &lt;code&gt;fingerprintFingerprints&lt;/code&gt; と &lt;code&gt;fingerprintString&lt;/code&gt; を組み合わせると、プラグインへの引数を簡単に単純にフィンガープリントできます。</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">ユーザーは &lt;code&gt;~/.haskeline&lt;/code&gt; ファイルでインターフェースをカスタマイズできます。詳細については、&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https：//github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">組み込みの制約解決動作と競合しない &lt;code&gt;HasField&lt;/code&gt; 、ユーザーはHasFieldの独自のインスタンスを定義できます。これにより、「仮想」レコードフィールドを、他の方法では持たないデータ型に対して定義できます。</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">ユーザーは &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; のカスタムインスタンスを提供できますが、これは次のルールに準拠することが期待されています。</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">この関数のユーザーは、readProcessの結果を待つ間、他のHaskellスレッドを実行し続けたい場合は、 &lt;code&gt;-threaded&lt;/code&gt; でコンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">ユーザーが最も可能性が高いでしょう &lt;code&gt;~&lt;/code&gt; 、しかし &lt;code&gt;~~&lt;/code&gt; GHCが関心の2種類が同じようなものを持っていることを、先験的に知ることができない場合は利用可能です。 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; が、GHCに &lt;code&gt;k1&lt;/code&gt; と &lt;code&gt;k2&lt;/code&gt; が同じであり、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; が同じであることを伝えていることの証拠。</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">構成やパターンマッチングなどのコンストラクタについて言及しているため、常に明確なフィールドの使用では、重複したフィールド名を自由に使用できます。たとえば、以下は許可されます（&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;と同様に）：</target>
        </trans-unit>
        <trans-unit id="3581ad6f94790a2bc201861caba85a7f7a678467" translate="yes" xml:space="preserve">
          <source>Uses the generational copying garbage collector for all generations. This is the default.</source>
          <target state="translated">すべての世代で世代コピーガベージコレクタを使用します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">8ビット文字の使用</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">プログラマーは、&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#newtype-deriving&quot;&gt;newtypesの一般化された派生インスタンス&lt;/a&gt;）を使用して、クラスの既存のインスタンスを取得し、それらをnewtypeのそのクラスのインスタンスに「リフト」できます。ただし、これは常に安全であるとは限りません。たとえば、次のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="2206acdb3d9d430eddec1b9a13c7b987ec134bee" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; tells GHC to display incompatibilities between closed type families&amp;rsquo; equations, whenever they are printed by &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは、&lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; &lt;/a&gt;によって出力される場合は常に、閉じた型族の方程式間の非互換性を表示するように指示されます。</target>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;を使用すると、GHCに、印刷時に同等の関係を区別するよう指示します。たとえば、 &lt;code&gt;~&lt;/code&gt; は同種のリフトされた等式（引数の種類は同じ）ですが、 &lt;code&gt;~~&lt;/code&gt; は異種のリフトされた等式（引数の種類は異なる場合があります）であり、 &lt;code&gt;~#&lt;/code&gt; は異種のリフトされていない等式、GHCで使用される内部等式関係ですソルバー。一般に、ユーザーはここで微妙なことを心配する必要はありません。 &lt;code&gt;~&lt;/code&gt; はおそらくあなたが望むものです。&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; が&lt;/a&gt;ない場合、GHCはこれらすべてを &lt;code&gt;~&lt;/code&gt; として出力します。&lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;等式制約&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは型で強制変換を印刷します。異なる種類の型間の同等性を証明しようとするとき、GHCは型レベルの強制を使用します。これらは内部用であるため、ユーザーがこれらを表示する必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;を使用すると、GHC は型のトップレベルで明示的な &lt;code&gt;forall&lt;/code&gt; 数量化を出力します。通常、これは抑制されます。たとえば、GHCiの場合：</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;を使用すると、GHCは種類の引数を印刷しますが、通常は抑制されます。これは、親切なポリモーフィズムを使用している場合に重要です。例えば：</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;を使用すると、 &lt;code&gt;myLength1&lt;/code&gt; の型シグネチャの型変数はいずれも型アプリケーションで使用できないと結論付ける可能性があります。しかし、これは真実ではありません！表示されるタイプのアプリケーションプロパティに関して最も正確な情報が必要な場合は、必ず&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="b75747b0323839514f55b98e3b0763a8b7a1bc59" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;rsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;を使用すると、 &lt;code&gt;myLength1&lt;/code&gt; の型シグネチャの型変数はいずれも型アプリケーションで使用できないと結論付ける可能性があります。しかし、これは真実ではありません！表示されるタイプのアプリケーションプロパティに関して最も正確な情報が必要な場合は、必ず&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;を使用することは、&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;と組み合わせた場合にのみ実際に良いアイデアです。それ以外の場合、追加のパックとアンパックは最適化されないためです。実際には、可能性があり&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;さえパフォーマンスを悪化させること&lt;em&gt;で&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;（それはあなたに何が起こる場合はお知らせ）が、これはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部で &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、理由はさまざまです。詳細については、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="1d18768c0ec1399365712ea9b78325eb3b52d261" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、さまざまな理由があります。詳細については、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を使用しても、Haskellランタイムシステムのスケジューリング動作はまったく変わりません。あなたが使用する必要があるという一般的な誤解である &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 代わりの &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を外国電話をかける際に、すべてのHaskellのスレッドをブロックを避けるために。これはそうではありません。すべてのHaskellスレッド（GHCを使用）をブロックせずに外部呼び出しを許可するには、プログラムをリンクするときに &lt;code&gt;-threaded&lt;/code&gt; オプションを使用し、外部インポートが &lt;code&gt;unsafe&lt;/code&gt; でないとマークされていないことを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が覆されます。サンクが評価されるタイミングに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試みる可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="653b55d8219ef951a3573cfdf98d122082b2dcdc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が破壊されます。サンクがいつ評価されるかに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試行する可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 使用は &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; ショートカットです。</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が覆されます。サンクが評価されるタイミングに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試みる可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に使用すると、STMが提供する保証の一部が覆されます。サンクが評価されるタイミングに応じて、別のトランザクション内でトランザクションを実行することができます。ネストされたトランザクションが試行されると、ランタイムによって例外がスローされます。 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内で &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; に安全に使用することは可能ですが、タイプチェッカーはネストされたトランザクションを試みる可能性のあるプログラムを除外しません。つまり、プログラマーはこれらを防ぐために特別な注意を払う必要があります。</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部で &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、理由はさまざまです。詳細については、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部で &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; を使用することも危険ですが、理由はさまざまです。詳細については、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="b96ae088c649d5a06c694f9e9ee5ee9dc8687a02" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="5d111b0d48c558b38badb2c9405749a987627b42" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="b2172f3ccd962a6ecd9b4cc15ce3cf95a1be7eb5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="f674202704940c277740f7f4ae49cd37b3a5f78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt;' can be understood as the pseudo-&lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt; 'は、疑似 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="c7b459af09ae8043d5f7b1a6c9159131c0b0fd22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt; 」として理解することができる &lt;code&gt;do&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="a4087f9008dd31f8281176bc7c8f4d1d90f9e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; 理解することができる」として &lt;code&gt;do&lt;/code&gt; 式を</target>
        </trans-unit>
        <trans-unit id="1570094d52e557732c703a05b9b1c145c2dd064a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="41f501d2ca81d0c4860698f021f0de3ecdc4a0f4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="108f9b97edb22ce149c8927414975f8505b7580d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; 理解することができる」として &lt;code&gt;do&lt;/code&gt; 式を</target>
        </trans-unit>
        <trans-unit id="2c837790b7d1462717c4308d600ad3e92eeaf1c9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; を：「 &lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt; 」として理解することができる &lt;code&gt;do&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="14c32ccf8b63eb011e4dfda0a4088dddc4bcbb92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="e2a8dbc4ffe0ccbf1d373d624329159d46946500" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="72b865211f58b24998cdf3ed8e08bdcf5e692e5e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="00a3efcb29a05c36224847d355496627fce12e1f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="9165dbc2c9969c24f2215ef6972a0880bb8278cb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="6e4a4d9eb30eacc6d2b8ca81bb1bd234ce8594a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="c8ccbb1fb2ddb1f53f896c4cc85e9a37ce0b41f0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="3fce8cbc36fc6d6dcdd6a6150d8297a2eb75e02c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="1004bfc9a7477fe977e15f814e05ceb1b205da67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="71cb9307570de629188fffa91efa031876cc2110" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="774bbfc5e54c815dbed906d0f74123e150de4f6c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="69d911e731ca95c1fd9a07c919774126a522e977" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="84196a31a9d5c8e34d17aa2ef18dc24c40e44aab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="5b25d8a860bc159c6b22d827207b11014882905b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="8a06315a7f9f08f9387659d3c5c4197621c13971" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="64871c74d2047073bc61343ed982993443145244" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; ： ' &lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; 'として使用すると、 &lt;code&gt;do&lt;/code&gt; 式として理解できます。</target>
        </trans-unit>
        <trans-unit id="7235239be554865a0935a618eb2b2336543f4705" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="6309b1896f5220de1092c0929134f7a07019870d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="2a548000114a6581f99bb89aac62e4c4178082e2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;ApplicativeDo&lt;/code&gt; の使用： ' &lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; 'は &lt;code&gt;do&lt;/code&gt; 式として理解できます</target>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">バイト文字列を使用して &lt;code&gt;CString&lt;/code&gt; の S</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">ByteStringsをCStringsとして使用する</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">ByteStringsをCStrings用の関数で使用する</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">&lt;code&gt;-threaded&lt;/code&gt; オプションを指定せずにGHCを使用すると、すべての外部呼び出しはシステム内の他のすべてのHaskellスレッドをブロックしますが、I / O操作はブロックしません。 &lt;code&gt;-threaded&lt;/code&gt; オプションを使用すると、 &lt;code&gt;unsafe&lt;/code&gt; 属性を持つ外部呼び出しのみが他のすべてのスレッドをブロックします。</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">共有オブジェクト名にGHCのバージョン番号を使用すると、GHCの異なるバージョンによってコンパイルされた異なるライブラリバージョンを、たとえば* nix &lt;code&gt;/usr/lib&lt;/code&gt; の下など、標準のシステムの場所にインストールできます。GHCのバージョン番号を取得するには、 &lt;code&gt;ghc --numeric-version&lt;/code&gt; を呼び出し、「GHCVersion」の代わりにその出力を使用します。共有オブジェクトリンク用にオブジェクトファイルを準備する方法については、&lt;a href=&quot;phases#options-codegen&quot;&gt;コード生成&lt;/a&gt;に影響するオプションも参照してください。</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; の&lt;/a&gt;組み合わせを使用すると、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;フレームワークを使用してデータ型ジェネリックプログラミングを簡単に実行できます。このセクションでは、その方法の非常に簡単な概要を示します。</target>
        </trans-unit>
        <trans-unit id="f8eaede999cdbad9cc93f8d51a7d597d7f74c072" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; の&lt;/a&gt;組み合わせを使用すると、&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;フレームワークを使用してデータ型ジェネリックプログラミングを簡単に実行できます。このセクションでは、その方法の概要を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">ロケールに依存したエンコーディングを使用する</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">パッケージを使用するのはもっと簡単です &lt;code&gt;--make&lt;/code&gt; またはGHCi を使用している場合、インストールされているパッケージのほとんどは、追加のオプションなしでプログラムで自動的に使用できます。このルールの例外については、&lt;a href=&quot;#using-packages&quot;&gt;パッケージの使用&lt;/a&gt;で後述します。</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">ゼロの値を使用すると、RTS クロックは完全に無効化され、それに依存するタイマー(コンテキストスイッチタイマーとヒーププロファイリングタイマー)を無効化する効果があります。コンテキストスイッチは依然として発生しますが、決定論的に、通常よりもはるかに速い速度で発生します。インターバルタイマーを無効にすると、実行時の非決定性の原因を取り除くことができるので、デバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="6a4a9903244534f370840c1922f33e5fac470a05" translate="yes" xml:space="preserve">
          <source>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</source>
          <target state="translated">ホールフィットプラグインを使用すると、有効なホールフィットの提案の動作を拡張して、例えばHoogleや他の外部ツールを使用して、GHCが使用しているタイプドホールに関する情報と同じ情報で、有効なホールフィットを見つけたり、合成したりすることができます。</target>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">レコードセレクタの使用</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;フラグを使用すると、モジュールを並行してコンパイルできます。「-n」ジョブを並行してコンパイルするには、 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; を指定します。「n」を省略すると、デフォルトでプロセッサの数になります。</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; コマンドの &lt;code&gt;module&lt;/code&gt; コマンドを使用すると、モジュールが現在のスコープに追加され、 &lt;code&gt;-&lt;/code&gt; で削除されます。 &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; がない場合、現在のスコープは指定されたモジュールのセットで置き換えられます。このフォームを使用して &lt;code&gt;Prelude&lt;/code&gt; を省略した場合、暗黙的な &lt;code&gt;Prelude&lt;/code&gt; インポートが自動的に追加されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="88ce1fb571afb65c6d0e842b399fa0b1a914f2d0" translate="yes" xml:space="preserve">
          <source>Using this is expected to make the program slightly slower.</source>
          <target state="translated">これを使うことで、プログラムの動作が少し遅くなることが予想されます。</target>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">通常、GHCはスレッドを切り替えるときにのみサンクをブラックホール化します。このフラグは、サンクが入力されるとすぐにそうします。&lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;共有メモリマルチプロセッサ上のHaskellを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">通常はユーザの実名 (pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">通常、ファイルの名前はモジュール名に基づいて付け、モジュール名のドットをディレクトリ区切り文字に置き換えます。たとえば、Unixシステムでは、モジュール &lt;code&gt;A.B.C&lt;/code&gt; は、いくつかのベースディレクトリに対して、ファイル &lt;code&gt;A/B/C.hs&lt;/code&gt; に配置する必要があります。モジュールが別のモジュール（ &lt;code&gt;Main&lt;/code&gt; など）によってインポートされない場合は、任意のファイル名を自由に使用できます。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">Win32 APIを呼び出すためのユーティリティ</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">プリミティブマーシャリングのためのユーティリティ</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">C文字列のプリミティブマーシャリングのためのユーティリティ。</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">Windows の C 文字列のプリミティブマーシャリングのためのユーティリティ。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">ユーティリティ機能</target>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">ドキュメントのユーティリティ機能</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="0dd37a83e54442139e4aed5d892a8264e1d1a20d" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls: &lt;code&gt;ByteArray#&lt;/code&gt; and &lt;code&gt;MutableByteArray#&lt;/code&gt;. The byte array must be &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;pinned&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;foreign import safe&lt;/code&gt; FFI呼び出しの有効な引数： &lt;code&gt;ByteArray#&lt;/code&gt; および &lt;code&gt;MutableByteArray#&lt;/code&gt; 。バイト配列は&lt;a href=&quot;#pinned-byte-arrays&quot;&gt;固定する&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="89dcf84a837ed25d40e781204368ac37d7aee9e9" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI calls: &lt;code&gt;Array#&lt;/code&gt;, &lt;code&gt;SmallArray#&lt;/code&gt;, &lt;code&gt;ArrayArray#&lt;/code&gt;, &lt;code&gt;ByteArray#&lt;/code&gt;, and the mutable counterparts of these types.</source>
          <target state="translated">&lt;code&gt;foreign import unsafe&lt;/code&gt; FFI呼び出しの有効な引数： &lt;code&gt;Array#&lt;/code&gt; 、 &lt;code&gt;SmallArray#&lt;/code&gt; 、 &lt;code&gt;ArrayArray#&lt;/code&gt; 、 &lt;code&gt;ByteArray#&lt;/code&gt; 、およびこれらのタイプの可変の対応物。</target>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">洗練レベルがあるときに有効な洗練穴フィットがしばしば大きくなる可能性があり、有効なリスト &lt;code&gt;&amp;gt;= 2&lt;/code&gt; のような穴で、 &lt;code&gt;head _ _&lt;/code&gt; または &lt;code&gt;fst _ _&lt;/code&gt; 有効な改良されている、しかし、穴の一つ以上のことから、関連する可能性は低いですそれらの穴のタイプも種類も提案された識別子によってまったく制約されないという点で、まだ完全にオープンです。デフォルトでは、このようなホールは報告されません。このフラグをオンにすると、そのような穴は有効なリファインホールフィットのリストに含まれます。</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 検証します。このアプローチは、使用しての利点を示して &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; をかけて &lt;code&gt;return&lt;/code&gt; 。私たちは、に継続を渡し &lt;code&gt;validateName&lt;/code&gt; 、との割り込み実行 &lt;code&gt;Cont&lt;/code&gt; からブロック&lt;em&gt;内部&lt;/em&gt;の &lt;code&gt;validateName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の入力中に計算された値。</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; クラスを使用してエンコードされた値は常にネットワーク順（ビッグエンディアン）の形式でエンコードされ、エンコードされたデータはマシンのエンディアン、ワードサイズ、またはコンパイラのバージョン間で移植可能である必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; クラスを使用してエンコードされたデータは、任意のマシンで書き込み、別のマシンで読み戻すことができます。</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;TExp a&lt;/code&gt; の値は、関数 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; を使用してタイプ &lt;code&gt;Exp&lt;/code&gt; の値に変換できます。</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">バニラ型の同義語宣言はHaskellと全く同じです。</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">型のアプリケーションでは使用できない変数が先に来ます。</target>
        </trans-unit>
        <trans-unit id="ad3fca5915fe871548a7a02e59688c2946d84dec" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">ユーザーによって明示的な&lt;a href=&quot;#scopedsort&quot;&gt;順序が指定されていない変数は、&lt;/a&gt; ScopedSort（指定された変数の順序）に従って並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">ユーザーによって明示的な順序付けが与えられていない変数は、ScopedSort(ScopedSort)に従ってソートされます。</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">バリアント &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; というプロパティを「並べ替えの障壁」と &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">バリアント &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; のスタイルで &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">バリアント &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; のスタイルで &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">許容されるインスタンスのオーバーラップの種類。</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">OSのバージョンを確認する</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">バージョン情報</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">お使いのコンピュータのバージョン情報です。</target>
        </trans-unit>
        <trans-unit id="e16193c9fa0396ab60a71b729b4a04cd813d0d61" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; without any value being passed to the second and third actions.</source>
          <target state="translated">2番目と3番目のアクションに値が渡されない &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; バージョン。</target>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="74c019334e2fff57ca4e39f259c2452610b715a1" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="1e7284b212c3e18b15655fd8a93f4230611c203f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 構築 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 構築 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="3383f2c0a3a8b49db2500fd0baa98b81bb0d0957" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="9d7b173a0dcac34771410bf511deb7fb53172de2" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; サイズのモジュラス用の &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; サイズの &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 用のpowModIntegerのバージョン</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="bcd38df7c17761d370b1e5803d31bed7f709a369" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="1c0304fc532fda6e0a0fb66673b691dbdd8f5987" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22b9c46cdd68688219fc77a7a7a0110bec5346a6" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; で動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; のバージョン＃</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="e9f8dae2a07adfa71cf9369406dff32b07be5f54" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">バージョン &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上で動作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;nextPrimeInteger&lt;/code&gt; 動作する &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; のバージョン</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">バージョンスキームは多種多様なので、このライブラリが提供するバージョン表現は、ほとんど共通の機能が合理的に提供できないような完全な一般性と、おそらく制限が強すぎるであろう特定のバージョンスキームを修正することとの間の妥協点となるように意図されています。</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">シーケンスの左端の様子。</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">シーケンスの右端を見る。</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">パターンを見る</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">ビューパターンは、言語拡張&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;によって有効になります。詳細とビューパターンの例は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wikiページにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e310bf26720d505a9536f51e809dfeaae92ef176" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">ビューパターンは、言語拡張&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;によって有効になります。ビューパターンの詳細と例は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wikiページにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">ビューパターンは、他のパターンの中に入れ子にすることができるパターンガードのようなものです。これらのパターンは、抽象型の値に対してパターンマッチングを行う便利な方法です。例えば、プログラミング言語の実装では、言語の型の構文を次のように表現します。</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">ビューパターンでは、パターン内のビュー関数を呼び出して結果と照合することができます。</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">事実上すべてのデータコンストラクタは、リッチな種類のものであっても昇格させることができます。このルールにはいくつかの例外があります。</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">Void:コンストラクタを持たないデータ型で使用します。</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：この関数は破損したマップを生成する可能性があり、その結果はその入力の内部構造に依存する場合があります。ユーザーは &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; を優先する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：この関数は破損したマップを生成する可能性があり、その結果はその入力の内部構造に依存する場合があります。ユーザーは &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; を優先する必要があります。</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">警告:通常の非原始的な Haskell 型への弱いポインタは、コンパイラが自由に最適化したり、基礎となるデータ構造を 複製したりするため、特に脆弱です。そのため、通常の Haskell 型にファイナライザを配置しようとすると、ファイナライザが予想よりも早く実行されてしまう可能性があります。これはキャッシュやメモテーブルの場合は問題ありませんが、早期のファイナライズは問題ありません。</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">ユニットが使えるようになるまで待つ</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">指定された数量が利用可能になるのを待つ</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; （別名&lt;strong&gt;P&lt;/strong&gt;操作）で待機します。</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">信号待ち</target>
        </trans-unit>
        <trans-unit id="572c89962b6ad39f8a6c6c966a575192e24a760d" translate="yes" xml:space="preserve">
          <source>Waits for one key to be pressed, then returns. Ignores the value of the specific key.</source>
          <target state="translated">1つのキーが押されるのを待ってから戻ります。特定のキーの値を無視します。</target>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">指定したプロセスの終了を待ち、その終了コードを返します。</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">トップレベルのインスタンス宣言を使用して簡略化できる型シグネチャのクラス制約について警告します。</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">トップレベルのインスタンス宣言を使用して簡略化できる型シグネチャ内のクラス制約について警告します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2f17deafc978e685508816d0d4ac503ec8d814c7" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when none of the bound variables are used.</source>
          <target state="translated">バウンド変数が使用されていない場合、レコードのワイルドカードマッチについて警告します。</target>
        </trans-unit>
        <trans-unit id="a962ab5861876e6eea5477b0e84923e9646bd87f" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when the wildcard binds no patterns.</source>
          <target state="translated">ワイルドカードがパターンをバインドしていない場合のレコードワイルドカードのマッチについて警告します。</target>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;(*&amp;gt;)&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり、 &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; が逆方向に定義されている場合に警告します（つまり、 &lt;code&gt;pure = return&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">パターン・バインディングが、単独のワイルドカード・パターン、またはバングされたパターンでない限り、変数を全くバインドしない場合に警告します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">昇格したデータコンストラクタが、その名前の前にチェックを入れずに使用されている場合に警告を出します。</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">ルールが起動する前に関数がインライン化される可能性があるため、書き換えRULEの起動に失敗する可能性がある場合に警告します。&lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;ルールとINLINE / NOINLINEプラグマとの相互作用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">非正規の &lt;code&gt;Applicative&lt;/code&gt; または &lt;code&gt;Monad&lt;/code&gt; インスタンス宣言が検出された場合に警告します。</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">非正規の &lt;code&gt;Monad&lt;/code&gt; または &lt;code&gt;MonadFail&lt;/code&gt; インスタンス宣言が検出された場合に警告します。</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">非 &lt;code&gt;Semigroup&lt;/code&gt; セミグループまたは &lt;code&gt;Monoid&lt;/code&gt; インスタンスの宣言が検出された場合に警告します。</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">GHCiが共有ライブラリを読み込めない場合に警告します。これは、パッケージを読み込み、ターゲットパッケージの説明の追加ライブラリスタンザを分析するときに読み込む必要があると推定します。</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCiが共有ライブラリをロードできないときに警告します。</target>
        </trans-unit>
        <trans-unit id="6590e9bd34bfc2ad804659f30bd772d752f4af5b" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can't load a shared lib.</source>
          <target state="translated">GHCiが共有libをロードできない場合に警告が出る。</target>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">遅延された範囲外の変数に遭遇した場合に警告します。</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;MonadFail&lt;/code&gt; インスタンスを持たないdoブロックで失敗可能なパターンが使用されたときに警告します。</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">定義が &lt;code&gt;Semigroup&lt;/code&gt; の標準型クラスへの将来の包含と競合する場合に警告します。</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">サポートされていないバージョンのLLVMで&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;を使用すると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">警告：指定された &lt;code&gt;Vertex&lt;/code&gt; が存在しない場合、 &lt;code&gt;nodeFromVertex&lt;/code&gt; 関数はランタイム例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">警告。この関数にはいくつかの欠点があります (ドキュメントを参照してください)。代わりにControl.Concurrent.threadDelayの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">警告：エッジリスト内の頂点が与えられた範囲内でない場合、この関数は、実行時例外が発生します &lt;code&gt;Bounds&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">警告。これは不安定なインターフェースです。</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">警告:改行やタブ文字は区切り文字とはみなされません。</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*このモジュールは内部モジュールです。必要だと分かった場合はメンテナに連絡して、何をしようとしているのかを説明し、公開APIで何が必要なのかを議論してください。このモジュールは将来のリリースでは全く公開されないかもしれないので、これを行うことが重要です。</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*このモジュールは内部モジュールです。もし必要だと思ったら、メンテナに連絡して、何をしようとしているのかを説明し、パブリック API で何が必要かを議論してください。このモジュールは将来のリリースでは全く公開されないかもしれないので、これを行うことが重要です。</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">(a)定義モジュール内での使用、(b)クラスインスタンス内でのメソッド定義、(c)エクスポートリスト内での使用については、警告や非推奨事項は報告されません。後者は、あるモジュールが他のいくつかのモジュールのエクスポートをまとめて再エクスポートするライブラリ内での不満を軽減します。</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告はエラーとしてではなく、警告としてのみ扱われます。これはデフォルトですが、&lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;フラグを無効にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="2494895ad5475179cdf03bf37393c57bb4ffcf96" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告は、エラーとしてではなく、警告としてのみ扱われます。これはデフォルトですが、&lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;フラグを無効にするのに役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="3800447d155c1657cd8727b0981f5edb4c28c0bc" translate="yes" xml:space="preserve">
          <source>Warns on qualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</source>
          <target state="translated">将来の GHC リリースで変更される可能性のあるコアライブラリモジュールのインポートについて警告します。現在、以下のモジュールがこの警告の対象となっています。</target>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">このプログラムはGHCの&lt;a href=&quot;codegens#unreg&quot;&gt;「未登録」&lt;/a&gt;バージョンでコンパイルされましたか？（つまり、現在サポートされていないプラットフォームであるため、プラットフォーム固有の最適化がコンパイルされていないGHCのバージョンです。）この値は、GHCの実験的ビルドを使用していない限り、通常はありません。</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">（1）バッファーへの書き込みの制御を完全に &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実装する &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; に引き渡すことで実現します。この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; は、バッファの開始と終了（ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; として表される）を通知されるだけです。次に、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; は、この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; のプレフィックスに任意の方法で書き込むことができます。場合 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; が行われ、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; が満杯であるか、またはバイトの長いシーケンスは、次に、直接挿入されるべき &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; を使用して発信者にこれを信号 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">私たちはすべてのことを要求することにより、（2）を達成 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; がで実装され &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 継続取り &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; それが更新さを呼び出して、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; それが行われた後に。したがって、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の連結を実装するには、関数呼び出しで2つのポインタのみを渡す必要があります。さらに、多くの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は完全にインライン化されているため、コンパイラーは、関数を呼び出すことなく、またボックス化をまったく行わずにそれらをシーケンスできます。</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">並列プログラムのプロファイリングには&lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;を使用することもお勧めします。並列実行を視覚化するためのGUIを提供し、GHCで提供される時間と空間のプロファイリング機能を補完します。</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; の両方で &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; の操作を引き上げたいと考えています。操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; の場合、 &lt;code&gt;throwE e&lt;/code&gt; は単純なアクションであるため、2 つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; s を &lt;code&gt;InterpM&lt;/code&gt; して2 つのモナドトランスフォーマーからInterpMにリフトできます。</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">実際には、ここではより具体的なタイプで &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; を使用しています</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">我々は、単一のモジュールに限定されない：GHCiのは、のいずれかの混合物中に、複数のモジュールからスコープを組み合わせることができます &lt;code&gt;*&lt;/code&gt; と非 &lt;code&gt;*&lt;/code&gt; 形式。GHCiは、これらすべてのモジュールのスコープを組み合わせて、プロンプトで有効なスコープを形成します。</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">これをプロシージャまたは矢印抽象化と呼びます。ラムダ式の場合と同様に、変数 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;proc&lt;/code&gt; -expression 内でバインドされた新しい変数です。矢印への入力を指します。上記の例では、 &lt;code&gt;-&amp;lt;&lt;/code&gt; は識別子ではなく、矢印タイプの式とその矢印への入力として供給される式からコマンドを作成するために使用される新しい予約済みシンボルです。（奇妙な外観は後でより意味をなすでしょう。）これは、矢印のアプリケーションのアナログとして読むことができます。上記の例は、Haskell式と同等です。</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">Writerを使ってプリミティブを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">同様の方法でコンストラクタクラスのインスタンスを導出することもできます。たとえば、以下のような状態と失敗のモナド変換器を実装したとします。</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">また、ハンドルやファイルとの間で値を直接シリアライズすることもできます。</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">また、マークアップされたバージョンのソースを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">スペースのような文字を含む引数を引用することもできますし、Haskellの文字列のように扱うこともできますし、Haskellのリスト構文を使うこともできます。</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">上記の &lt;code&gt;byteStringHex&lt;/code&gt; の例に示すように、これを使用して厳密な &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を16進エンコードすることもできます。</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">これで、予想どおり、 &lt;code&gt;x&lt;/code&gt; の型が再構築され、 &lt;code&gt;f&lt;/code&gt; の型も再構成されたことを確認できます。</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">&lt;em&gt;バイナリ&lt;/em&gt;形式に変換していることがはっきりとわかります。127を超えるUnicodeコードポイントを持つ「&amp;lambda;」および「&amp;ouml;」文字は、対応するUTF-8マルチバイト表現に拡張されます。</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; を複数回使用して、複数のプリミティブを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; を複数回使用して、複数のプリミティブを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 関数を使用して、リスト内の複数の値を1つの値に組み合わせることができます。 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; はいくつかの異なる操作でモノイドであるため、ここではタイプを指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; をコンパイルしてから、次のようにプログラム全体をロードできます。</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">ファイルからGHCiの入力を読み込むコマンドを定義することができます。これは、繰り返しGHCiセッションにロードしたいバインディングのセットを作成するのに便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; トランスフォーマーを追加することでカウントするパーサーを定義できます。</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">&lt;code&gt;pat_lhs&lt;/code&gt; の形式を変更することで、プレフィックス、インフィックス、またはレコードパターンの同義語を定義できます。これらの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">通常の内包表記に変換することで、並列リスト内包表記を定義できます。基本的な考え方は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">このようなパーサーモナドを定義するには、 &lt;code&gt;[]&lt;/code&gt; モナドに状態（解析対象の残りの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）を追加します。これにより、非決定性が提供されます。</target>
        </trans-unit>
        <trans-unit id="b9c01a3a2622d4196ecfba7e8743aedf0cb3a68d" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">このようなパーサーモナドを定義するには、状態（解析される残りの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）を &lt;code&gt;[]&lt;/code&gt; モナドに追加します。これにより、非決定性が提供されます。</target>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">この型の値をバイト文字列にエンコードするには、以下のインスタンスを使用します。</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">newtypeが最後のクラスパラメーターであれば、マルチパラメータークラスのインスタンスを派生させることもできます。この場合、クラスの「部分的なアプリケーション」が &lt;code&gt;deriving&lt;/code&gt; 句に表示されます。たとえば、クラスが</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">代わりに、newtype &lt;code&gt;App&lt;/code&gt; （ &lt;code&gt;App f a&lt;/code&gt; と &lt;code&gt;f a&lt;/code&gt; はメモリ内で同じように表現されます）を作成し、&lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt;を使用してこのパターンの使用を明示的に有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;MismatchedParentheses&lt;/code&gt; 例外を &lt;code&gt;MismatchedParentheses&lt;/code&gt; 、 &lt;code&gt;SomeFrontendException&lt;/code&gt; 、または &lt;code&gt;SomeCompilerException&lt;/code&gt; としてキャッチできるようになりましたが、 &lt;code&gt;IOException&lt;/code&gt; などの他のタイプはキャッチできません。</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">評価ステップの履歴を検査できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">値とアプリケーションからなる単純な式を EvalStmt に渡すことができます。これにより、別の関数で実行される文をラップすることができ、GHCiが :set argsと :set progを実装するために使用しています。将来的にはこの小さな言語を拡張する価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">クラス宣言から空のメンバを削除することで、この特有の問題を回避することができます。しかし、残りのメンバであるinsertとmemberは型が曖昧ではありませんが、それらを使おうとすると問題が発生します。例えば、次の 2 つの関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">モナディックコンビネーターを使用して、 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; インスタンスの記述を簡略化できます。</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">最後の2つで構築されたコマンドを通常の式に適用することで、必要とされる余分な入力を供給することができます。</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">次に、式とパターンの両方のコンテキストで &lt;code&gt;HeadC&lt;/code&gt; を使用できます。パターンコンテキストでは、少なくとも1つの長さのリストの先頭に一致します。式のコンテキストでは、シングルトンリストを作成します。</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">したがって、型 &lt;code&gt;P&lt;/code&gt; （コンストラクタ &lt;code&gt;MkP&lt;/code&gt; を持つ）を昇格されたデータコンストラクタ &lt;code&gt;'P&lt;/code&gt; （種類 &lt;code&gt;Prom&lt;/code&gt; ）から区別できます。</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">この署名に対して &lt;code&gt;A&lt;/code&gt; をタイプチェックするか、次の宣言を提供するモジュールを使用して &lt;code&gt;Str&lt;/code&gt; をインスタンス化できます。署名をインスタンス化する方法の詳細については、Cabalのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Monad&lt;/code&gt; はなく、 &lt;code&gt;Applicative&lt;/code&gt; および &lt;code&gt;Functor&lt;/code&gt; のインスタンスである型でdo表記を使用できます。</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">例えば、プリミティブに固定値を前置したり、追加したりすることができます。</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">levityポリモーフィズムを使用して、 &lt;code&gt;error&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; で効果を上げることができます。そのタイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">ピースを抽出するには、以下のような関数を使うことができます。</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">GHCiを使用する場合、プロファイラーを使用してスタックトレースを収集できます（GHCiの&lt;a href=&quot;#ghci-stack-traces&quot;&gt;スタックトレースを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">これを使って、リストの中で一番長いエントリを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">これを利用して、リストの中で一番短い項目を探すことができます。</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">これらの関数を使用する可能性のあるモジュール（&lt;a href=&quot;ghc-base&quot;&gt;GHC.Baseなど&lt;/a&gt;）でこれらの関数を定義することはできません。これは、不思議なワイヤードインタイプがタイプチェッカーの計算結果と混同されるためです。</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">独自の演算子を定義することができます。</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">3つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを &lt;code&gt;InterpM&lt;/code&gt; にリフトできますが、 &lt;code&gt;InterpM&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; のインスタンスであるため、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="552e222727964454376c689c5337b632f2f7ae47" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">3つの &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを &lt;code&gt;InterpM&lt;/code&gt; にリフトできますが、 &lt;code&gt;InterpM&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; のインスタンスになるため、代わりに &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">何かをデコードするのに十分な入力を &lt;code&gt;f0&lt;/code&gt; に与えることができなかったため、空の文字列を返しました。2番目の継続 &lt;code&gt;f1&lt;/code&gt; を入力の最後のバイトにフィードすると、進行します。</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">私たちは、シミュレートすることができ &lt;code&gt;if&lt;/code&gt; 定義することで、</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; に &lt;code&gt;g&lt;/code&gt; を適用してみることができます。ただし、 &lt;code&gt;g&lt;/code&gt; はタイプ &lt;code&gt;a&lt;/code&gt; の引数と &lt;code&gt;x :: b&lt;/code&gt; 想定しているため、これは機能しません。さらに悪いことに、 &lt;code&gt;f&lt;/code&gt; も &lt;code&gt;a&lt;/code&gt; 型の引数を必要とするため &lt;code&gt;a&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; をa型に変換することはできません。要するに、これを機能させる良い方法はありません。</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; の 2つの値を作成します。1つは &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクターを使用し、もう1つは &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクターを使用します。次に、 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 関数（ &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; がある場合）または「times-two」関数（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; がある場合）のいずれかを適用します。</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; の 2つの値を作成します。1つは &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクターを使用し、もう1つは &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクターを使用します。次に、 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 関数（ &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; がある場合）または「times-two」関数（ &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; がある場合）のいずれかを適用します。</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">UTF-8のCSVエンコーディング機能を以下の表に示します。</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">コンパイルされたバージョンの &lt;code&gt;C&lt;/code&gt; を取得できませんでした！どうした？GHCiでは、コンパイルされたモジュールは他のコンパイル済みモジュールにのみ依存する場合があり、この場合、 &lt;code&gt;C&lt;/code&gt; はオブジェクトファイルを持たない &lt;code&gt;D&lt;/code&gt; に依存するため、GHCiも &lt;code&gt;C&lt;/code&gt; のオブジェクトファイルを拒否しました。では、 &lt;code&gt;D&lt;/code&gt; もコンパイルしましょう：</target>
        </trans-unit>
        <trans-unit id="3b8a8e128dde8f3cc09d2617fe4a012e9ad66250" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; のコンパイル済みバージョンを入手できませんでした！どうした？GHCiでは、コンパイルされたモジュールは他のコンパイルされたモジュールにのみ依存する可能性があります。この場合、 &lt;code&gt;C&lt;/code&gt; はオブジェクトファイルを持たない &lt;code&gt;D&lt;/code&gt; に依存するため、GHCiも &lt;code&gt;C&lt;/code&gt; のオブジェクトファイルを拒否しました。では、 &lt;code&gt;D&lt;/code&gt; もコンパイルしましょう：</target>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">ワイルドカードには3種類の種類があります。</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は普遍的な多形ではないので、 &lt;code&gt;E3&lt;/code&gt; の引数については説明しません。 &lt;code&gt;a&lt;/code&gt; における &lt;code&gt;E3&lt;/code&gt; は、それが最後のタイプのパラメータと同じではないので、（暗黙的に）存在量化である &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(a ~ Int)&lt;/code&gt; であっても、 &lt;code&gt;Int&lt;/code&gt; は構文的に &lt;code&gt;a&lt;/code&gt; と同等ではないため、 &lt;code&gt;E1&lt;/code&gt; または &lt;code&gt;E4&lt;/code&gt; の引数を折りたたみません。</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">難しい方法でパッケージをビルドすることはお勧めしません。代わりに、可能であれば&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt;インフラストラクチャを使用してください。パッケージが特に複雑であるか、多くの構成が必要な場合は、低レベルのメカニズムにフォールバックする必要がある可能性があるため、これらの勇敢な魂のためのいくつかのヒントに従います。</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">日常業務には &lt;code&gt;-O*&lt;/code&gt; フラグを使用しません。かなりの速度を得るために &lt;code&gt;-O&lt;/code&gt; を使用します。たとえば、何かを測定したい場合。休憩に行きたいときは、 &lt;code&gt;-O2&lt;/code&gt; を使う傾向があります（そして、たくさんのコーヒーブレークに行きます）。</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が同じ型レベルの数値でインスタンス化されたという証拠、または &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が同じ型レベルのシンボルでインスタンス化されたという証拠、または &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">&lt;code&gt;_t1&lt;/code&gt; サンクのみを評価し、リストの先頭を明らかにし &lt;code&gt;_t2&lt;/code&gt; 。テールは、現在_t2にバインドされている別のサンクです。ここで &lt;code&gt;seq&lt;/code&gt; 関数を使用するのは少し不便なので、&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;を使用してより良いインターフェイスを作成することをお勧めします（読者のための練習として残しておきます）。</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">私たちは、現在の機能番号を見つけるとに戻されるC.これに渡し &lt;code&gt;hs_try_putmvar&lt;/code&gt; を、そしてRTSはそれを実行しようとするべき機能を知るのに役立ちます &lt;code&gt;tryPutMVar&lt;/code&gt; を上。気にしない場合は、 &lt;code&gt;hs_try_putmvar&lt;/code&gt; に機能に &lt;code&gt;-1&lt;/code&gt; を渡すと、任意の機能が選択されます。</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">我々は持っている &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; 、 &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; 、および &lt;code&gt;x :: b&lt;/code&gt; 。これらを使用して、何らかの方法で穴（アンダースコアで示される）を &lt;code&gt;Int&lt;/code&gt; 型の値で埋める必要があります。私たちのオプションは何ですか？</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">この不自然なプログラム以外に、GHCを分岐させる別のクラスのプログラムを見つけたことはありません。問題を修正すると、すべてのコンパイルで余分なオーバーヘッドが発生します。したがって、バグは未修正のままです。&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inlinerには、&lt;/a&gt;より多くの背景があります。</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">私たちはこれらの種類を推測します。</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">テーブル内のセルを内部的に表現するには、次のような型のオブジェクトを使用します。</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">新しいサンプルの始まりを &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; イベントでマークし、</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">我々はまた、我々はそれらを検出した場合の配列をコードする際に無効な文字を通知する必要があるかもしれません &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; にSを &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; ための &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; のモードは往復にこれらを作成し、当社の内部UTF-16エンコーディングによってバイト。</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">将来的には、この機能の構文や意味を変更する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEADのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;をダウンロード&lt;/a&gt;できるようにする場合があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="2ebe98c6a2119e741bdf064584e3db025f6347d2" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">HEADのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;をダウンロード&lt;/a&gt;できるようにする場合があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">現在の安定版ブランチのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;をダウンロードできるようにする場合&lt;/a&gt;があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="f4fb296fd8e8ef0d2da857b55d5e427e6713096b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">現在の安定版ブランチのスナップショットリリース&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;をダウンロードできるようにする場合&lt;/a&gt;があり&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;ます&lt;/a&gt;。最新のソースはgitリポジトリから入手できます。</target>
        </trans-unit>
        <trans-unit id="c0f8df20c6e6b47bd015211c44bf700bb364d39e" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">レイジー計算、つまりサンクは、作成時に現在のスタックをキャプチャし、評価時にこのスタックを復元することを前述しました。トップレベルのサンクはどうですか？それらはプログラムのコンパイル時に「作成」されるので、どのスタックを与える必要がありますか？トップレベルのサンクの技術名はCAF（「ConstantApplicativeForm」）です。 GHCは、モジュール内のすべてのCAFに、単一のコストセンター &lt;code&gt;M.CAF&lt;/code&gt; で構成されるスタックを割り当てます。ここで、 &lt;code&gt;M&lt;/code&gt; はモジュールの名前です。オプション&lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;を使用して、各CAFに異なるスタックを与えることもできます。これは、&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; を&lt;/a&gt;使用してコンパイルする場合に特に便利です（&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; の&lt;/a&gt;デフォルトのように）関数本体の定数がトップレベルに引き上げられ、CAFになるため。これらのCAFが何に対応するかを判断するには、おそらくコア（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）を参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">先に述べたように、遅延計算（サンク）は、作成時に現在のスタックをキャプチャし、評価時にこのスタックを復元します。トップレベルのサンクはどうですか？それらはプログラムのコンパイル時に「作成」されるので、どのスタックにそれらを与える必要がありますか？トップレベルサンクの技術名はCAF（「Constant Applicative Form」）です。 GHCは、モジュール内のすべてのCAFに、単一のコストセンター &lt;code&gt;M.CAF&lt;/code&gt; で構成されるスタックを割り当てます。ここで、 &lt;code&gt;M&lt;/code&gt; はモジュールの名前です。オプション&lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;を使用して、各CAFに異なるスタックを提供することもできます。これは、&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; を&lt;/a&gt;使用してコンパイルする場合に特に便利です（&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; を&lt;/a&gt;使用したデフォルトの場合）以上）、関数本体の定数がトップレベルに引き上げられ、CAFになるため。これらのCAFが何に対応するかを判別するには、おそらくコア（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）を調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">私たちは（B）をはるかに好みます。どうして？GHCは &lt;code&gt;(True :~: False)&lt;/code&gt; が空の型であることを理解できるためです。したがって、（B）には&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;がなく、GHCは-Wincomplete-patternsおよび&lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;を使用してコンパイルできます。一方、（A）は危険に見え、GHCは実際には関数が呼び出されないことを確認しません。</target>
        </trans-unit>
        <trans-unit id="703530a9bd76b6d41cdef63f80ac7642abb989f8" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">私たちは（B）を大いに好みます。どうして？GHCは、 &lt;code&gt;(True :~: False)&lt;/code&gt; が空のタイプであることを理解できるためです。したがって、（B）には&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;がなく、GHCは-Wincomplete-patternsおよび&lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;を使用してコンパイルできます。一方、（A）は危険に見え、GHCは、実際に関数が呼び出されないことを確認しません。</target>
        </trans-unit>
        <trans-unit id="6b18525b3456e672ccab92cf738f47ed84e0b770" translate="yes" xml:space="preserve">
          <source>We normally mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">通常、新しいサンプルの開始を &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; イベントでマークします。</target>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">次に、実際の &lt;code&gt;encode&lt;/code&gt; 関数のクラス &lt;code&gt;Encode&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">ここでは、hpcの主なモードについて、より詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">私たちは元々、式の自由変数だけではなく、スコープ内のすべての変数にバインディングを提供していましたが、これがパフォーマンスに大きく影響することがわかりましたので、現在は自由変数だけに制限しています。</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; と &lt;code&gt;argv&lt;/code&gt; への参照を &lt;code&gt;hs_init()&lt;/code&gt; に渡して、RTSの引数（ &lt;code&gt;+RTS...-RTS&lt;/code&gt; 間の引数）を分離できるようにします。</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">ファイルが見つからなかったり、読み込みに失敗した場合は終了します。(ハドックや他のクライアントのための便利なルーチン)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;フラグと並行して実行することを目的としたコードをコンパイルすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">標準のWindowsコンソールでGHCiを実行することをお勧めします &lt;code&gt;ghci&lt;/code&gt; インストーラーによって追加されたスタートメニュー項目から &lt;code&gt;GHCi&lt;/code&gt; オプションを選択するか、スタート- &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; を使用してWindowsコンソールを取得し、そこからghciを呼び出しますあなたの &lt;code&gt;PATH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">ブランチを &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のリストとして表すため、バージョン3.2.1は[3,2,1]になります。辞書式順序（のすなわちデフォルトインスタンス &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; のための &lt;code&gt;[Int]&lt;/code&gt; ）枝の自然順序付けを提供します。</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;default&lt;/code&gt; を再利用して、署名がデフォルトのメソッドにのみ適用されることを通知します。 &lt;code&gt;Enum&lt;/code&gt; クラスのインスタンスを定義するときに、元の &lt;code&gt;enum&lt;/code&gt; のタイプ &lt;code&gt;[a]&lt;/code&gt; が引き続き適用されます。ただし、空のインスタンスを指定すると、デフォルトの実装 &lt;code&gt;(map to genum)&lt;/code&gt; が入力され、型 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 型チェックされます。</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">境界チェックが融合されるように、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; の連続使用を書き換えます。例えば、</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">GHCについては、以下のメーリングリストを運営しています。適当と思われる方は、ぜひご参加ください。</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の型変数は&lt;em&gt;指定され&lt;/em&gt;ているが、 &lt;code&gt;g&lt;/code&gt; の型変数は&lt;em&gt;推論&lt;/em&gt;&lt;em&gt;さ&lt;/em&gt;れていると言います。一般的なルールは次のとおりです。ユーザーがソースプログラムで型変数を書き込んだ場合は、それが&lt;em&gt;指定されます&lt;/em&gt;。そうでない場合は、&lt;em&gt;推定され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; にブレークポイントを設定して呼び出します。</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">エントリ数も共有メモリに格納され、複数のコアでの継続的な更新が非常に遅いため、複数のコアでプロファイルされるプログラムをコンパイルするときは&lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt;を使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">次に、新しいSafe Haskell &lt;code&gt;-XSafe&lt;/code&gt; フラグを使用して &lt;code&gt;Danger&lt;/code&gt; プラグインをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; を拡張する（警告：これはやや紛らわしい名前の非終端記号です）、2つの追加の形式、つまり、インスタンス宣言に表示できるものを正確に</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">デフォルトのシグネチャを使用して、GHCの&lt;a href=&quot;#generic-programming&quot;&gt;ジェネリックプログラミング&lt;/a&gt;（ジェネリックプログラミング）を簡略化します。</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">&lt;code&gt;criterion&lt;/code&gt; ライブラリ（&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;）を使用して、次の表にあるエンコード関数の効率をベンチマークします。</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">継続 &lt;code&gt;f0&lt;/code&gt; を使用して、2番目のパケットをデコードします。</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">以下のインポートを使用し、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; を省略して読みやすくしています。</target>
        </trans-unit>
        <trans-unit id="f22709004a13a3fd94746ba6a021463ab6f37071" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">以下のインポートを使用し、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; を省略して読みやすくします。</target>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">このような動作をバグとして報告していただければ、修正できるようになります。</target>
        </trans-unit>
        <trans-unit id="cc16631b4890edd93973a20a4f9c5e2d14d862c2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">GHC固有のビットを &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt; ; 残りのコードは、FFI標準をサポートするHaskell実装間で移植可能である必要があります。</target>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">GHC固有のビットを &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; で囲みました。残りのコードは、FFI標準をサポートするHaskell実装間で移植可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">弱いポインタは、キャッシュやメモテーブルに特に便利です。メモ・テーブルを構築するには、関数の引数(キー)からその結果(値)へのデータ構造のマッピングを構築します。新しい引数に関数を適用するときは、まず、キーと値のペアがすでにメモテーブルにあるかどうかをチェックします。ここで重要なのは、メモテーブル自体がキーと値を保持してはいけないということです。したがって、テーブルには通常のポインタではなく、キーへの弱いポインタが含まれていなければなりません。値へのポインタは弱くてはいけません。値への唯一の参照が実際にはメモテーブルからのものかもしれないからです。</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">弱いポインター。</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">ThreadIdsへの参照が弱い</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">GHCユーザーズガイドへようこそ</target>
        </trans-unit>
        <trans-unit id="9a43d24919845073d089f519130b6009f44f6465" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;.</source>
          <target state="translated">再帰関数、および相互再帰的な関数のグループはどうですか？コストはどこに起因しますか？GHCは、関数のどのグループが互いに再帰的に呼び出されたかに関する情報を保持しますが、この情報は基本的な時間と割り当てプロファイルには表示されません。代わりに、コールグラフは次のようにツリーにフラット化されます。現在のスタックの他の場所で発生した場合、スタック上の別のエントリはプッシュされません。代わりに、この呼び出しのコストが呼び出し元&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2に&lt;/a&gt;集約されます。</target>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">再帰関数、および相互に再帰的な関数グループについてはどうですか？費用はどこに帰属しますか？まあ、GHCは相互に再帰的に呼び出される関数のグループに関する情報を保持しますが、この情報は基本的な時間および割り当てプロファイルには表示されません。代わりに、コールグラフは次のようにツリーにフラット化されます。現在のスタックの他の場所で発生し、スタック上の別のエントリをプッシュせず、代わりにこの呼び出しのコストが呼び出し元に集計されます&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">元の定義で発生したあいまいさの問題はどうですか？空の関数は、まだ型を持つ &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; 、曖昧な型としてことを考えることはもはや必要ではない：変数が、 &lt;code&gt;e&lt;/code&gt; が右側に表示されない &lt;code&gt;=&amp;gt;&lt;/code&gt; シンボル、クラスの依存関係 &lt;code&gt;Collects&lt;/code&gt; 教えてくれる &lt;code&gt;=&amp;gt;&lt;/code&gt; 記号の右側に表示される &lt;code&gt;ce&lt;/code&gt; によって一意に決定されること。したがって、空が使用されているコンテキストは、 &lt;code&gt;ce&lt;/code&gt; と &lt;code&gt;e&lt;/code&gt; の両方のタイプを判別するのに十分な情報を提供できます、あいまいさなし。より一般的には、 &lt;code&gt;=&amp;gt;&lt;/code&gt; の左側に、右側の変数によって（直接または間接的に）一意に決定されない変数が含まれている場合にのみ、型をあいまいであると見なす必要があります。</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">実際に起こるのは、GHCiが式を型チェックし、 &lt;code&gt;IO&lt;/code&gt; 型がない場合は次のように変換することです。式 &lt;code&gt;e&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 型の値を使用して何ができますか？特に、 &lt;code&gt;MkFoo&lt;/code&gt; でパターンマッチングを行うとどうなりますか？</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">xに明示的な型を「提供する」とはどういう意味ですか？パターンタイプシグネチャ（&lt;a href=&quot;#scoped-type-variables&quot;&gt;レキシカルスコープのタイプ変数&lt;/a&gt;）を使用して、xのタイプシグネチャを直接指定することで、次のようになります。</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">安全とはどういう意味ですか？&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; で&lt;/a&gt;コンパイルされたモジュールをインポートしても、モジュールをインポートせずに正常にコンパイルされるコードの意味が変わることはありません。これは、&lt;em&gt;セマンティック整合&lt;/em&gt;性と呼ばれるSafe Haskellプロパティです。</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">型コンストラクタの「ユーザー指定の完全な種類シグネチャ」とは正確に何と見なされますか これらはフォームです：</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">これは&lt;em&gt;実存的&lt;/em&gt;定量化とどのように関係していますか？単にその &lt;code&gt;MkFoo&lt;/code&gt; が（ほぼ）同型のタイプを持っていること</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">私たちは（のようなタイプのコンストラクタを介して、その範囲の一般的なクラスを定義する場合 &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; の、または &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; ）？</target>
        </trans-unit>
        <trans-unit id="52d850cf6e82ee71cba430d22124534321d40e28" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depend&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; の種類は何ですか？ &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; と言う人もいるかもしれません。タイプ-&amp;gt; k-&amp;gt;タイプですが、これは正しくありません。これは、 &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; のような誤ったものを許可するためです。これは、 &lt;code&gt;Int&lt;/code&gt; が &lt;code&gt;Bool&lt;/code&gt; の種類ではないため、拒否する必要があります。重要な観察は、2番目の引数の種類が最初の引数に&lt;em&gt;依存&lt;/em&gt;するということです。 GHCは、 &lt;code&gt;ProxyKVis&lt;/code&gt; の種類に与える構文でこの依存関係を示します。</target>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">結果タイプのこの「 &lt;code&gt;a&lt;/code&gt; 」は何ですか？明らかにこれを意味するものではありません。</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">どのようなスプライスなのか</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">与えられた型パラメーターが持つべき役割は何か？ GHCは役割推論を実行して、すべてのパラメーターの正しい役割を決定します。それはいくつかの基本的な事実から始まります： &lt;code&gt;(-&amp;gt;)&lt;/code&gt; には2つの表現パラメーターがあります。 &lt;code&gt;(~)&lt;/code&gt; 2つの公称パラメーターがあります。すべてのタイプファミリーのパラメーターは公称値です。そして、すべてのGADTのようなパラメーターは公称値です。次に、これらのファクトは、これらのタイプが使用されるすべての場所に伝搬されます。データ型とシノニムのデフォルトの役割はファントムです。クラスのデフォルトの役割は名義です。したがって、データ型とシノニムの場合、右側で使用されていない（またはファントム位置の他のタイプでのみ使用されている）パラメータはファントムになります。パラメーターが表現位置で使用される（つまり、対応する変数がロール表現であるコンストラクターへの型引数として使用される）場合は常に、その役割をファントムから表現に上げます。同様に、パラメーターが公称位置で使用される場合、その役割は公称にアップグレードされます。役割を公称からファントムまたは表現に、または表現からファントムにダウングレードすることはありません。このようにして、各パラメーターの最も一般的な役割を推測します。</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; の役割はどうあるべきですか？最初は赤面しますが、 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; はどちらも右側で使用され、どちらもタイプファミリーに含まれていないため、どちらもロールを表すものである必要があります。ただし、次の例に示すように、これは誤りです。</target>
        </trans-unit>
        <trans-unit id="7201ad0e4b9c4fd0ef63e8c881a6df6e60416a86" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;rsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">&lt;code&gt;Tricky&lt;/code&gt; の役割はどうあるべきですか？一見 &lt;code&gt;a&lt;/code&gt; と、 &lt;code&gt;b&lt;/code&gt; とbの両方が右側で使用され、どちらも型族に関与していないため、aとbの両方が役割を表す必要があるように思われます。ただし、次の例が示すように、これは間違っています。</target>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCiは何をすべきか？厳密に言えば、プログラムがあいまいです。 &lt;code&gt;show (reverse [])&lt;/code&gt; （GHCiがここで計算するもの）にはタイプ &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; あり、その表示方法はタイプ &lt;code&gt;a&lt;/code&gt; によって異なります。例えば：</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">単一のパターンセットに適用される複数の &lt;code&gt;COMPLETE&lt;/code&gt; セットがある場合はどうなりますか？この例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">どのようなヒーププロファイルを集めているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskellコンパイラーが適切に生成するものは、使用されるバックエンドコードジェネレーターによって異なります。詳細については、&lt;a href=&quot;codegens#code-generators&quot;&gt;GHCバックエンド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">インスタンスを導出する際にユーザーが明示的に要求するもの。</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">これでできることは、異種の値を操作する関数の束と一緒にパッケージ化して、そのパッケージの集合を統一的に扱うことです。この方法でかなりオブジェクト指向的なプログラミングを表現することができます。</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">最後に何をするか。</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m2&lt;/code&gt; ではなく &lt;code&gt;m1&lt;/code&gt; のキーをどうするか</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; ではなく &lt;code&gt;m2&lt;/code&gt; のキーをどうするか</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;m1&lt;/code&gt; と &lt;code&gt;m2&lt;/code&gt; の両方のキーをどうするか</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">非オプションに続くオプションをどうするか</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">テキストをどうするか。</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">私たちが示したものは、どの &lt;code&gt;make&lt;/code&gt; でも機能するはずです。</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">何異なるのは、私たちが今使っていることである &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; （にするために使用し、そのパラメータ、パラメータを参照するために）、名前のどこかで明示的に言及されていません。また、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;Tree a&lt;/code&gt; の再帰的な使用を参照しています。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">例外が発生したときにターゲットスレッドが行っていた作業が失われることはありません。</target>
        </trans-unit>
        <trans-unit id="25aaf639f200ab012209ed7c616b7427cf43a690" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;が有効になっている場合は、 &lt;code&gt;anyclass&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">とき&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; が&lt;/a&gt;有効になっている、あいまいなフィールドではなく、トップレベルでのよりも、そのデータ型の一部としてエクスポートする必要があります。たとえば、以下は合法です。</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、タイプおよび種類の変数は、&lt;a href=&quot;#data-instance-declarations&quot;&gt;Dataインスタンス宣言&lt;/a&gt;または&lt;a href=&quot;#type-instance-declarations&quot;&gt;Typeインスタンス宣言&lt;/a&gt;と同じ方法で（および同じ制限付きで）関連データまたはタイプファミリーインスタンスに明示的にバインドできます。たとえば、上記を適用すると、以下が受け入れられます。</target>
        </trans-unit>
        <trans-unit id="dcb444e9dc2c42002165fa1d9f676b2862da1a0d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、左側で使用される型変数と種類変数を明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効になっている場合、左側で使用されるtypeまたはkind変数を明示的にバインドできます。例えば：</target>
        </trans-unit>
        <trans-unit id="9b1b787d1263816e3855c7cfe78d8c359b80a2c3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; が&lt;/a&gt;有効になっていると我々はnewtypeのために導出され、その後、使用 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">とき&lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt;有効になっている、GHCは、印刷し &lt;code&gt;RuntimeRep&lt;/code&gt; の軽さ、ポリモーフィック型の型変数を。そうでない場合、GHCはこれらをデフォルトで &lt;code&gt;LiftedRep&lt;/code&gt; に設定します。例えば、</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;が有効な場合、明示的に数量化された型変数も未使用として識別される場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;が有効な場合、推論された変数は中括弧で出力されます。したがって、前の例のデータコンストラクター &lt;code&gt;Proxy&lt;/code&gt; タイプは、 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; 。GHCiセッションでこの動作を観察できます。</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐには、通常、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; を使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐために、通常は &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; のみを使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐには、通常、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; を使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐために、通常は &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; のみを使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐには、通常、 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; を使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐために、通常は &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; のみを使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐには、通常、 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; を使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトでインライン化されます。過度のインライン化を防ぐために、通常は &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; のみを使用してカスタム結合関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">とき &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は 3つの引数が与えられ、それが呼び出しサイトにインライン化されます。したがって、 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; は、カスタム結合関数を定義する場合にのみ使用する必要があります。たとえば、 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; を次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DeriveAnyClass&lt;/code&gt; が有効な場合は、 &lt;code&gt;anyclass&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; が有効になっていると我々はnewtypeのために導出され、その後、使用 &lt;code&gt;newytype&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">場合 &lt;code&gt;mappend x x = x&lt;/code&gt; 、この定義が好ましいなければならない、それはむしろO（ログN）よりもO（1）で動作するため</target>
        </trans-unit>
        <trans-unit id="385ace8105515b932625b88764546dcae18aded8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\)</source>
          <target state="translated">場合 &lt;code&gt;mappend x x = x&lt;/code&gt; 、この定義が好ましいすべきで、それが動作するために\（\ mathcal {O}（1）\）ではなく\（\ mathcal {O}（Nログ\）\）</target>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">とき &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; がO（1）で動作するので、この定義はなくO（ログn）がより好ましいすべきです。</target>
        </trans-unit>
        <trans-unit id="01dfa1f0b575553478bb02cbc1f8d40024bd7518" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\).</source>
          <target state="translated">とき &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; それはで動作するためではなく、（\ mathcal {O}（1）\）\（\ mathcal {O}（Nログ\ \））、この定義は、\、好まれるべきです。</target>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">GHCがクラスのインスタンスを見つけることができない場合、それはそれが知っているインスタンスのいくつかの短いリストを表示します。このフラグを使用すると、認識している&lt;em&gt;すべて&lt;/em&gt;のインスタンスが出力されます。</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">GHCが、 &lt;code&gt;foreign export&lt;/code&gt; または &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; を使用するモジュール（たとえば &lt;code&gt;M.hs&lt;/code&gt; ）をコンパイルすると、Cプログラムで使用するための &lt;code&gt;M_stub.h&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">GHCが未登録モードでビルドされる場合、LLVMおよびCコードジェネレーターのみが使用可能になります。ネイティブコードジェネレーターはありません。LLVMは通常、未登録モードのCバックエンドよりもパフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">GHCを使用してCファイルをコンパイルする場合、GHCはパッケージのインクルードパスを追加し、 &lt;code&gt;ghcversion.h&lt;/code&gt; を直接インクルードします。コンパイラは、パッケージデータベースの &lt;code&gt;rts&lt;/code&gt; パッケージから &lt;code&gt;ghcversion.h&lt;/code&gt; ファイルのパスを検索します。コンパイラのパッケージデータベースに &lt;code&gt;rts&lt;/code&gt; パッケージが含まれていない場合や、特定の &lt;code&gt;ghcversions.h&lt;/code&gt; を含めるように指定したい場合があります。このオプションを使用して、 &lt;code&gt;ghcversions.h&lt;/code&gt; ファイルへのパスを指定できます。これは主にGHCのビルドシステムで使用されることを意図しています。</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">たとえば、GHCが制約 &lt;code&gt;C Int Bool&lt;/code&gt; を解決しようとすると、インスタンス宣言の先頭をインスタンス化することにより、すべてのインスタンス宣言を制約と照合しようとします。次の宣言を検討してください。</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">GHCiがブレークポイントで停止し、プロンプトで入力された式が2番目のブレークポイントをトリガーすると、新しいブレークポイントが「現在の」ブレークポイントになり、古いブレークポイントがスタックに保存されます。このようにして、任意の数のブレークポイントコンテキストを作成できます。例えば：</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">GC 2011 が開始されると、実行中のすべてのミューテータースレッドは停止して同期しなければなりません。GC 2011 が開始されてからすべてのミューテータースレッドが停止するまでの期間は、 GC 2011 同期フェーズと呼ばれます。このフェーズに長い時間がかかっている場合(1ms 以上は長いと考えられます)、全体的なス ループットに深刻な影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">GHCでコンパイルされたプログラムが&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTSオプションを指定して実行されると、 &lt;code&gt;prog.prof&lt;/code&gt; というファイルが生成されます。この場合、ファイルには次のようなものが含まれます。</target>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">ベアタイプ変数 &lt;code&gt;a&lt;/code&gt; が検出されると、&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; の&lt;/a&gt;両方が、それぞれ &lt;code&gt;fmap&lt;/code&gt; と &lt;code&gt;traverse&lt;/code&gt; 定義の &lt;code&gt;f a&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">特定の行と列にブレークポイントが設定されると、GHCiは、ブレークポイントを設定する場所を囲む最小の部分式を選択します。注：GHCは、TAB文字の幅が1であると見なします。つまり、列ではなく文字をカウントします。これは、一部の編集者が行うことと一致し、他の編集者とは一致しません。最善のアドバイスは、ソースコード内のタブ文字を完全に回避することです（「&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告と&lt;/a&gt;&lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt;性チェック」の-Wtabsを参照）。</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">特定の行にブレークポイントが設定されている場合、GHCiは、その行で始点と終点となる左端の式にブレークポイントを設定します。2つの完全な部分式が同じ列から始まる場合、最も長い方が選ばれます。行上に完全な部分式がない場合は、その行で始まる左端の式が選ばれ、それ以外の場合は、その行を部分的にまたは完全に覆っている右端の式が選ばれます。</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ときにデータ型 &lt;code&gt;T&lt;/code&gt; はすなわち、すべてのコンストラクタでインポートされた &lt;code&gt;T(..)&lt;/code&gt; すなわち、しかし、抽象的にエクスポートされている &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">基礎となるPOSIX関数を呼び出す関数が失敗すると、errnoコードは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; に変換されます。生成される可能性のあるerrnoコードのリストについては、基礎となる関数のPOSIXドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="92c15677526f9dbb76cd2897100c19f8390621db" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">基になるPOSIX関数を呼び出す関数が失敗すると、errnoコードは &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; に変換されます。生成される可能性のあるerrnoコードのリストについては、基礎となる関数のPOSIXドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">hs-bootファイル &lt;code&gt;A.hs-boot&lt;/code&gt; がコンパイルされると、スコープとタイプのエラーがチェックされます。親モジュール &lt;code&gt;A.hs&lt;/code&gt; がコンパイルされると、2つが比較され、2つが矛盾している場合はエラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">両方のマップでキーが見つかった場合は、キーと値に関数を適用し、その結果をマージされたマップで使用することができます。</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">両方のマップでキーが見つかった場合は、キーと値に関数を適用し、その結果をマージされたマップで使用します。</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">両方のマップでキーが見つかった場合は、キーと値に関数を適用してアクションを生成し、その結果をマージされた マップで使用します。</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">両方のマップでキーが見つかった場合は、キーと値に関数を適用し、結果として生じるアクションを実行し、その結果をマージされた マップで使用することができます。</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">現在コンパイルされているパッケージ（「ホーム」パッケージ）によって提供されるモジュールがインポートされたが、ターゲットとしてコマンドラインに明示的にリストされていない場合。CabalがGHCがモジュールをピックアップしないようにするのに役立ちます。exposed &lt;code&gt;exposed-modules&lt;/code&gt; にも &lt;code&gt;other-modules&lt;/code&gt; にもリストされていません。</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">名前やパッケージが範囲内で見つからない場合は、あなたが代わりに意味していたかもしれない名前やパッケージを提案してください。</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">インスタンスが重複しているために特定の型クラスのメソッド呼び出しが安全でないと見なされ、コンパイルされるモジュールが&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;を使用している場合、コンパイルは失敗します。以下のために&lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;、制限は適用されず、かつ安全な推論を使用して、モジュールのために、彼らは危険な推測されます。</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">プログラムがコンパイルおよび実行されると、 &lt;code&gt;getArgs&lt;/code&gt; 関数を使用してコマンドライン引数にアクセスできます。ただし、ghciでテストしている間、 &lt;code&gt;main&lt;/code&gt; 関数は引数を直接受け取らないため、引数を &lt;code&gt;main&lt;/code&gt; 関数に単純に渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">プログラムがコンパイルおよび実行されると、 &lt;code&gt;getArgs&lt;/code&gt; 関数を使用してコマンドライン引数にアクセスできます。ただし、ghciでテストしている間は、 &lt;code&gt;main&lt;/code&gt; 関数が直接引数を取らないため、引数を &lt;code&gt;main&lt;/code&gt; 関数に単純に渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">このフラグに文字列が渡されると、その文字列と接頭辞を共有する名前を持つすべての関数の情報を報告します。</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">型にコンストラクタがない場合、派生 &lt;code&gt;Functor&lt;/code&gt; インスタンスは、&lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; &lt;/a&gt;を使用して引数の（下）値を強制します。</target>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">構文的に等価ではないタイプの場合は、しかし、含まれていないその、遭遇され、&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; は&lt;/a&gt;再帰的に呼び出す &lt;code&gt;fmap&lt;/code&gt; それに。同様に、&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; は&lt;/a&gt;再帰的に呼び出します &lt;code&gt;foldr&lt;/code&gt; と &lt;code&gt;foldMap&lt;/code&gt; を。コンテキストに応じて、 &lt;code&gt;null&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;all null&lt;/code&gt; を再帰的に呼び出す場合があります。たとえば、 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">構文的に等価ではないタイプの場合は、しかし、含まれていないその、遭遇され、&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; は&lt;/a&gt;再帰的に呼び出す &lt;code&gt;fmap&lt;/code&gt; それに。同様に、&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;は再帰的に &lt;code&gt;traverse&lt;/code&gt; を呼び出します。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">型レベルの明示的な &lt;code&gt;forall&lt;/code&gt; が存在する場合、言及されている各型/種類変数もスコープ内にあるか、 &lt;code&gt;forall&lt;/code&gt; によってバインドされている必要があります。特に、Haskellの他のいくつかの場所とは異なり、これは自由種類の変数が暗黙的にバインドされないことを意味します。例えば：</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 表記で値がバインドされている場合、 &lt;code&gt;&amp;lt;-&lt;/code&gt; の左側のパターンが一致しない場合があります。この場合、このクラスは回復する機能を提供します。</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">警告が発生した場合には、それを制御する特定の警告フラグが表示される。</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">ワイルドカードがモノタイプにインスタンス化されていない場合、それは一般化され、例えば、新しい型変数に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 文がエクスポートされていないエンティティを非表示にする場合。</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">関連付けられたデータまたは型の同義語ファミリーインスタンスが型クラスインスタンス内で宣言されている場合、（オプションで） &lt;code&gt;instance&lt;/code&gt; キーワードをファミリーインスタンスにドロップできます。</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">例外がメインプログラムの外に伝播すると、Haskellシステムは関連する &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 値を出力し、プログラムを終了します。</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">例外がメインプログラムの外に伝播すると、Haskellシステムは関連する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 値を出力し、プログラムを終了します。</target>
        </trans-unit>
        <trans-unit id="93856eacf2fadc4b6b312933a4b87e29fb2a120e" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, &lt;em&gt;all&lt;/em&gt; type and kind variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">明示的な &lt;code&gt;forall&lt;/code&gt; が存在する場合、まだスコープ内にない、言及されている&lt;em&gt;すべての&lt;/em&gt;型変数と種類変数は、 &lt;code&gt;forall&lt;/code&gt; によってバインドされる必要があります。</target>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">明示的な &lt;code&gt;forall&lt;/code&gt; が存在する場合、まだスコープ内にない言及されたすべての&lt;em&gt;型&lt;/em&gt;変数は、 &lt;code&gt;forall&lt;/code&gt; によってバインドされる必要があります。種類の変数は、必要に応じて暗黙的にバインドされます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">インスタンスときに &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; のために定義される &lt;code&gt;CT&lt;/code&gt; 、型クラスによって定義されたビット演算は、上のCの対応するビット演算と同様の機能を実現する &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">インスタンス場合 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; ために定義されている &lt;code&gt;CT&lt;/code&gt; の値 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; はと一致 &lt;code&gt;t_MIN&lt;/code&gt; と &lt;code&gt;t_MAX&lt;/code&gt; Cで</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">インスタンス場合 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ために定義されている &lt;code&gt;CT&lt;/code&gt; 、型クラスによって定義された述語は、上のCに対応する述語と同じ関係実装 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">インスタンス場合 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 、またはを &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; のために定義されている &lt;code&gt;CT&lt;/code&gt; 、型クラスによって定義された算術演算は、上のCに対応する演算（利用可能な場合）と同様の機能を実現する &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">該当する場合、ほとんどの場合、この関数の代わりに &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; を使用することをお勧めしますが、特定の病的状況では少し悪い場合もあります。たとえば、文字のリストをナブするには、次を使用します。</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">ソースファイルのコンパイルを依頼された場合、GHCは通常、オブジェクトファイルとインターフェースファイルの2つのファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">データベースの変更を求められると、 &lt;code&gt;ghc-pkg&lt;/code&gt; はデフォルトでグローバルデータベースを変更します。 &lt;code&gt;--user&lt;/code&gt; を指定すると、ユーザーデータベースで動作します。または、 &lt;code&gt;--package-db&lt;/code&gt; を使用して、別のデータベース全体で動作することもできます。これらのオプションが複数指定されている場合、右端のオプションがデータベースとして使用されます。</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">両方のフラグが指定されている場合は、 &lt;code&gt;-&lt;/code&gt; 上書きします &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;+&lt;/code&gt; オーバーライドスペースを。 &lt;code&gt;*&lt;/code&gt; 変換での負の幅指定子は正として扱われますが、左調整フラグを意味します。</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">バインドされた型/種類変数が必要な場合、両方のforallが常に含まれていなければなりませんが、パターン変数が必要ない場合は、2番目のforallは空のままにすることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">パッケージを共有ライブラリとしてビルドする場合、GHCを使用してリンク手順を実行できます。これにより、基礎となるリンカーの詳細の一部が隠され、GHCでサポートされているすべての共有オブジェクトバリアント（DLL、ELF DSO、Mac OS dylib）に共通のインターフェイスが提供されます。共有オブジェクトには、次の2つの理由で特定の方法で名前を付ける必要があります。（1）名前にGHCコンパイラのバージョンが含まれている必要がある呼び出し規約に関しては、（2）静的名とは異なる必要があります。そうしないと、&lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;フラグを機能させるために必要な正確にリンカーを制御できません。&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; の外側、または &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; の内側で呼び出された場合、この関数は効果がありません。</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; の外側、または &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; の内側で呼び出された場合、この関数は効果がありません。</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">呼び出されると、&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt;プリント⟨n⟩ &lt;sup&gt;番目&lt;/sup&gt;に⟨m⟩ &lt;sup&gt;番目&lt;/sup&gt; ⟨type⟩で表さ完了ドメインの部分入力⟨string-literal⟩のための補完候補。現在、入力プロンプトでGHCiによってインタラクティブに提供される種類の補完を示す &lt;code&gt;repl&lt;/code&gt; ドメインのみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">ときに呼び出し &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 、2結合機能 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; ように、Sが作成されます</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">ときに呼び出し &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 、2結合機能 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; ように、Sが作成されます</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">ときに呼び出し &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 、2結合機能 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; ように、Sが作成されます</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">呼び出すとき &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 、2結合機能 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; sが作成され、その結果、</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">呼び出すとき &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; 、2結合機能 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; sが作成され、その結果、</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 値を大文字と小文字に変換するときは、文字列の各文字を個別に &lt;code&gt;map toUpper&lt;/code&gt; と小文字に変換するためにmap toUpperのようなコンビネータを使用しないでください。このモジュールの &lt;code&gt;toUpper&lt;/code&gt; などの文字列全体の大文字小文字変換関数は、正しい大文字小文字変換規則に従います。その結果、これらの関数は1つの入力文字を2つまたは3つの出力文字にマップする場合があります。例については、各関数のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">一対の閉じたタイプのファミリー方程式をチェックするとき、GHCはRHSを統一しようとしました。それらが統一されない場合、この方程式のペアは注入性注釈に違反しません。RHSが何らかの置換（おそらく空）の下で統合できる場合、LHSは同じ置換の下で統合されるか、後者の方程式のLHSは以前の方程式によって包含されます。どちらの条件も満たされない場合、GHCはタイプファミリーが単射ではないと報告します。</target>
        </trans-unit>
        <trans-unit id="4204f66fa3958025c4499fdd95a271a6773f14df" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;と組み合わせると、ユーザーはワイルドカードをクエリに挿入し、インスタンスとの⟨type⟩一致に必要な各ワイルドカードの制約を学習できます。</target>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;を使用してテンプレートHaskellコードをコンパイルする場合、インタープリターでプロファイルされたオブジェクトコードを実行できるため&lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;、&lt;/a&gt;最初に&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;を使用せずにモジュールをコンパイルする必要はありません（プロファイリングでのテンプレートHaskellの使用を参照）。</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;を使用してコンパイルする場合、「n」モジュールを並行してコンパイルします。</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 値のリストを作成する場合、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; を使用してすべての「成功」結果を返すことができます（リストが &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; の結果である場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; の方が適切です）。</target>
        </trans-unit>
        <trans-unit id="d52b75d2fceb888d77bcc4884a089cb376a2d17a" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">リスト構築するときに &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 値を、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; は「成功」の結果（リストの結果である場合のすべてを返すために使用することができ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 、そして &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; がより適切であろう）：</target>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 値のリストを作成する場合、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; を使用してすべての「成功」結果を返すことができます（リストが &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; の結果である場合、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; の方が適切です）。</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">Haskell パッケージ用の共有オブジェクトを作成する際には、このパッケージに対してリンクされたときに GHC が共有オブジェクトを認識するように、共有オブジェクトの名前を適切に付けなければなりません。共有オブジェクトの名前のマングリングを参照してください。</target>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">これが正しいデータ構造かどうかを判断する際には、検討してみてください。</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">GHCiマクロを定義する際に、名前が組み込みコマンドと競合する可能性がある場合、特にタブ補完に関して注意すべき重要な動作があります。</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">Haskellで埋め込みドメイン固有の言語を設計するとき、型レベルで &lt;code&gt;error&lt;/code&gt; ようなものがあると便利です。このように、EDSLデザイナーは、標準のGHCタイプエラーではなく、DSLに固有のタイプエラーを表示する場合があります。</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">&lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; を&lt;/a&gt;使用してリスト表記を脱糖する場合、GHCはモジュール &lt;code&gt;GHC.Exts&lt;/code&gt; の &lt;code&gt;fromList&lt;/code&gt; （etc）メソッドを使用します。これを &lt;code&gt;GHC.Exts&lt;/code&gt; ためにGHC.Extsをインポートする必要はありません。</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">その際、（オプションで）「 &lt;code&gt;family&lt;/code&gt; 」キーワードを削除する場合があります。</target>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">有効にすると、GHCは&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;拡張からのユニコードシンボルを使用してタイプシグネチャを出力します。例えば、</target>
        </trans-unit>
        <trans-unit id="8dbdb2194a992ad2487a00a403a3f21e8db0a4da" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">有効にすると、GHCは&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;拡張機能のUnicode記号を使用して型署名を印刷します。例えば、</target>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">この機能を有効にすると、GHCは警告の中にタイプチェッカーからの余分な情報も表示します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">この機能を有効にすると、GHC は型エラーの中で型同義語で拡張された型も表示します。例えば、この型同義語では</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">有効になっている場合、信頼できるモジュール &lt;code&gt;M&lt;/code&gt; の追加のチェックをオンにします &lt;code&gt;M&lt;/code&gt; 存在するパッケージは信頼できると見なされ、 &lt;code&gt;M&lt;/code&gt; が信頼できると見なされます。</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コードを生成するとき、別のモジュールからインポートされたエンティティが動的にリンクされる可能性があると想定します。このフラグは&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;によって自動的に有効になります。</target>
        </trans-unit>
        <trans-unit id="ca8d6acd6f8e6b72171a8fd88d9e46614a530faf" translate="yes" xml:space="preserve">
          <source>When giving priority to built-in commands, you can use &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt;&lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;::type 3&lt;/code&gt;.</source>
          <target state="translated">組み込みのコマンドを優先する場合は、使用することができます&lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt; &lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt; &lt;/a&gt;、のように &lt;code&gt;::type 3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">複数のソースからパッケージを組み込む場合、複数のパッケージが同じ名前のモジュールを公開する状況になる可能性があります。以前は、これらのモジュールを区別する唯一の方法は、&lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;パッケージ修飾インポート&lt;/a&gt;を使用することでした。ただし、GHC 7.10以降、&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;フラグ（およびそのバリアント）が拡張され、ユーザーがモジュールインポートにアタッチできるインポートリストと同様に、パッケージがスコープに含めるモジュールを明示的に制御できるようになりました。</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内で呼び出されると、マスクされた非同期例外が存在する場合に、それを発生させることができます。これは、割り込み可能な操作（#interruptibleを参照）を実行するのと同じですが、実際のブロックは含まれません。</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt;フラグを指定して呼び出されると、ランタイムは機械可読のJSON形式でコストセンタープロファイルを出力します。このフォーマットの最上位オブジェクトには、次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">&lt;code&gt;-g&lt;/code&gt; フラグを指定して呼び出すと、GHCは標準の&lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt;デバッグ情報を生成します。この形式は、ほとんどすべてのPOSIX準拠のターゲットで使用され、GHCでコンパイルされたプログラムの構造を理解するためにデバッグツールやパフォーマンスツール（ &lt;code&gt;gdb&lt;/code&gt; 、 &lt;code&gt;lldb&lt;/code&gt; 、 &lt;code&gt;perf&lt;/code&gt; など）で使用できます。</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">起動時に、&lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt;フラグが指定されていない限り、GHCiは次のファイルが存在する場合は、この順序でコマンドを読み取って実行します。</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">型を種類チェックするとき、GHCは型の種類を一般化する方法を理解するときに、その型で書かれているものだけを考慮します。</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">バイナリ実行ファイルをリンクする、これは挿入フラグ &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 任意の前に &lt;code&gt;-l&lt;/code&gt; Haskellライブラリのためのフラグ、および &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; その後</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">バイナリ実行可能ファイルをリンクするとき、これはフラグ &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; をHaskellライブラリの &lt;code&gt;-l&lt;/code&gt; フラグの前に挿入し、-Wl、-no-whole-archiveを後で挿入し &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; （OS Xでは、フラグは &lt;code&gt;-Wl,-all_load&lt;/code&gt; 、-Wl、 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 相当するものはありません）。このフラグは、 &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; （OS Xでは-Wl、-dead_strip）の使用を無効にします。</target>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">最終的なプログラムをリンクするときは、GHCを使用してリンクするのが通常最も簡単ですが、これは必須ではありません。GHCを使用する場合は、フラグ&lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; を&lt;/a&gt;忘れないでください。そうしないと、GHCは &lt;code&gt;Main&lt;/code&gt; Haskellモジュールにリンクしようとします。</target>
        </trans-unit>
        <trans-unit id="df717341a67671689dd35a9b3531eb8e0f072f7a" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</source>
          <target state="translated">リンクするとき、リンカは参照されていないセクションを自動的に削除して、より小さな実行ファイルを生成することができます。</target>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">リンクすると、リンカはすべての参照されていないセクションを自動的に削除して、より小さな実行可能ファイルを生成できます。効果は&lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; に&lt;/a&gt;似ていますが、やや効率的です-生成されるライブラリファイルは&lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; を使用する&lt;/a&gt;場合よりも約30％小さくなります。</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">負荷分散を行う場合は、同じノード上の別のCapabilityにスレッドを移行することを好みます。</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;を使用してソースモジュールをロードする場合、GHCiは通常、対応するコンパイル済みオブジェクトファイルを検索し、可能であればソースを解釈するよりも優先して1つ使用します。たとえば、モジュール &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、および &lt;code&gt;D&lt;/code&gt; で構成される4モジュールのプログラムがあるとします。モジュール &lt;code&gt;B&lt;/code&gt; と &lt;code&gt;C&lt;/code&gt; の両方インポート &lt;code&gt;D&lt;/code&gt; のみ、および &lt;code&gt;A&lt;/code&gt; 輸入両方 &lt;code&gt;B&lt;/code&gt; および &lt;code&gt;C&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">プログラム実行のためのプロファイルを見るときには、実行中の特定のポイントやフェーズをマークして、それをプロファイルで視覚的に確認できるようにしたいと思うことがよくあります。</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">一致する場合、GHCはインスタンス宣言のコンテキスト（ &lt;code&gt;context1&lt;/code&gt; など）を考慮しません。</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">クラス宣言をマージするとき、スーパークラスとメソッドが正確に一致する必要があります。ただし、 &lt;code&gt;MINIMAL&lt;/code&gt; プラグマは論理ORされ、デフォルトのシグネチャを持つメソッドは、そうでないものに対して正常にマージされます。</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; で複数のスレッドがブロックされると、それらはFIFOの順序で起動されます。これは、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用して構築された抽象化の公平性プロパティを提供するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="3653488103c6d86e8420d8068c23cf681e601a0f" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; で複数のスレッドがブロックされると、FIFO順にウェイクアップされます。これは、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用して構築された抽象化の公平性プロパティを提供するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; で複数のスレッドがブロックされると、それらはFIFOの順序で起動されます。これは、 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用して構築された抽象化の公平性プロパティを提供するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; で複数のスレッドがブロックされると、それらはFIFOの順序で起動されます。これは、 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用して構築された抽象化の公平性プロパティを提供するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">cfg ベースのブロックレイアウトを使用していない場合、基本ブロックの最後のジャンプか cfg のブロックの最も重い出っ張りによってレイアウトが決定されます。</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">オーバーロードが絡むと、少し逆効果になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="33fd0ba5406a8b9e8e8bedaed530c6c43c6e5581" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="translated">リフトされていない配列型のいずれかを外部C呼び出しへの引数として渡す場合、外部関数は、配列のペイロードを参照するポインターを参照します。それを含む &lt;code&gt;StgArrBytes&lt;/code&gt; / &lt;code&gt;StgMutArrPtrs&lt;/code&gt; / &lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; ヒープオブジェクトは参照しません&lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;。対照的に、 &lt;code&gt;foreign import prim&lt;/code&gt; によって導入された&lt;a href=&quot;#ffi-prim&quot;&gt;外部Cmm呼び出し&lt;/a&gt;は、ペイロードだけでなくヒープオブジェクトも参照します。これは、状況によっては、外部C関数がRTSクロージャタイプの知識を必要としない場合があることを意味します。次の例では、最初の3つのバイト合計 &lt;code&gt;MutableByteArray#&lt;/code&gt; &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt;から何も使用せずに &lt;code&gt;Rts.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">パターンマッチの際、各パターンマッチでは、それぞれの実在型変数に対して、新しい明確な型が導入されます。これらの型は、他の型と統一することはできませんし、パターンマッチの範囲から逃れることもできません。例えば、これらの断片は正しくありません。</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">パターンマッチングの際には、これらの制約を利用可能にして、マッチングの本文で制約を排出するようにしています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">GADTから取得したデータコンストラクターとのパターンマッチングを行う &lt;code&gt;case&lt;/code&gt; たとえば、case式）、次のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">レコード構築でレコードワイルドカードを使用する場合、フィールド &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; がスコープ内にある場合にのみ初期化され、トップレベルでインポートまたはバインドされません。たとえば、 &lt;code&gt;f&lt;/code&gt; は囲みパターンマッチまたはlet / where-bindingによってバインドできます。例えば</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">タイプされた穴を報告するときは、スコープ内にある制約も表示します。例。</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">プログラムに &lt;code&gt;-hr&lt;/code&gt; オプションを指定して保持プロファイルを要求すると、保持セットごとに分類されたグラフが生成されます。保持セットは、コストセンタースタックのセットとして表示されます。これは通常、プロファイルグラフに収まりきらないほど大きいため、各保持セットには番号が付けられ、その番号とともにグラフ上に省略して表示されます。保持セットの完全なリストは、ファイル &lt;code&gt;prog.prof&lt;/code&gt; にダンプされます。</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">対話型のコンソールプロセス（シェル、コンソールベースのテキストエディター、ghciなど）を実行する場合、通常は、そのプロセスがCtl-Cキーボードの割り込みを処理できるようにして、適切に見えるようにします。たとえば、ほとんどのプログラムはCtl-Cで終了するだけですが、特別に処理するプログラムもあります。これを可能にするには、 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; オプションで &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">このファイルの言語オプションを設定する場合には、使用するのが通常望ましい&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;（参照&lt;a href=&quot;#ghci-interactive-options&quot;&gt;のみインタラクティブな評価のための設定オプションが&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">いつSafe Haskell推論を使用し、いつ明示的な&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;フラグを使用する必要がありますか？後者のケースは、モジュールが安全であるという厳しい要件がある場合に使用する必要があります。これは&lt;a href=&quot;#safe-use-cases&quot;&gt;、Safe Haskell&lt;/a&gt;のSafe Haskellの使用、つまり信頼できないコードの実行に最も役立ちます。安全な推論は、通常のHaskellプログラマが使用するためのものです。Safe Haskellを気にしないユーザー。</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">どのフラグが警告を制御しているかを表示する場合は、その警告が含まれているそれぞれの警告グループのフラグも表示します。</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">制約を解くときは、利用可能な辞書を使ってスーパークラスを熱心に解くようにしましょう。</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; プラグマを指定する場合、すべてのパターンの結果タイプは互いに一貫している必要があります。タイプが一貫していない場合、すべてのパターンを照合することは不可能であるため、これは健全性チェックです。</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; でパターンシノニムのタイプを明示的に指定する場合、ユニバーサル、存在、またはそれらのコンテキストのいずれかを空のままにできます。</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; でパターンシノニムのタイプを明示的に指定する場合、ユニバーサル、存在、またはそれらのコンテキストのいずれかを空のままにできます。</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">ブレークポイントまたはシングルステップで停止すると、GHCiは変数 &lt;code&gt;_result&lt;/code&gt; を現在アクティブな式の値にバインドします。値 &lt;code&gt;_result&lt;/code&gt; は型が知られており、showableされている場合、そしてちょうど入る：私たちはその評価を停止したが、それは強制することができますので、おそらく利用できないまだ &lt;code&gt;_result&lt;/code&gt; をプロンプトでそれを表示します。ただし、これを行うには1つの注意点があります &lt;code&gt;_result&lt;/code&gt; を評価すると、現在停止しているブレークポイントから開始して、さらにブレークポイントがトリガーされる可能性があります（&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt;ではなく実際のブレークポイントで停止した場合）。そのため、 &lt;code&gt;_result&lt;/code&gt; を評価するときに&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; を&lt;/a&gt;すぐに発行する必要があるでしょう。。または、ブレークポイントを無視する&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">ブレークポイントで停止したときに、すでに評価中の変数を評価しようとすると、2番目の評価がハングします。その理由は、GHCは変数が評価中であることを知っているため、新しい評価は続行する前に結果を待つだけですが、最初の評価がブレークポイントで停止するため、もちろんこれは起こりません。Control-Cはハングした評価を中断し、プロンプトに戻ることができます。</target>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">とき&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグが有効になっている、モジュールが信頼されているかどうか、特定のパッケージが信頼されている場合に依存します。パッケージの信頼は、GHCを呼び出すクライアントC（つまり、あなた）によって決定されます。</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグを使用すると、次の場合に限り&lt;em&gt;、パッケージPのモジュールMがクライアントCによって信頼されます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">場合 &lt;code&gt;*&lt;/code&gt; が使用されている、GHCiの任意のコンパイル済みオブジェクトコードを無視し、モジュールを解釈します。すでにいくつかのモジュールをオブジェクトコードとしてロードしていて、そのうちの1つを解釈したい場合は、セット全体を再ロードする代わりに、 &lt;code&gt;:add *M&lt;/code&gt; を使用して、 &lt;code&gt;M&lt;/code&gt; を解釈するように指定できます（コンパイルされたモジュールは解釈されたモジュールに依存できないため、これにより他のモジュールも解釈される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">とき &lt;code&gt;GADTSyntax&lt;/code&gt; の拡張機能が有効になっている、GHCは、明示的にコンストラクタの型シグネチャを与えることによって、代数的データ型を宣言することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">とき &lt;code&gt;OverloadedLists&lt;/code&gt; の拡張をオンにし、次のように、前述の7つの表記が脱糖されています。</target>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">コンパイラタイプがソースコードをチェックすると、&lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;テンプレートHaskell&lt;/a&gt;スプライスと&lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;テンプレートHaskell準引用&lt;/a&gt;は、それらから生成された構文ツリーフラグメントに置き換えられます。ただし、ソースコードを操作するツールの場合、コードジェネレーターは通常、生成されたコードよりも興味深いものです。このため、 &lt;code&gt;spliceRunAction&lt;/code&gt; を含めました。このフィールドは、評価される前に各式で呼び出されます。入力はタイプチェックされているため、これらの構文ツリーフラグメントのセマンティック情報を利用できます。別の式を返す場合は、生成されるコードを変更できます。</target>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;0&lt;/code&gt; より大きい &lt;code&gt;n&lt;/code&gt; に設定されている場合、GHCは有効なリファインメントホールフィットのリストを提供します。これは、最大 &lt;code&gt;n&lt;/code&gt; レベルの追加のリファインが必要な有効なホールフィットです。完成させるために、各レベルは、穴埋めの追加穴を表します。この穴は、埋める必要があります。例として、</target>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">フラグ&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;を有効にすると、左側のパターンで言及されているが右側では使用されていないタイプ変数が報告されます。左側で複数回発生する変数も使用されていると見なされます。警告を抑制するには、未使用の変数を置き換えるか、アンダースコアを前に付ける必要があります。それ以外の場合、アンダースコア（ &lt;code&gt;_x&lt;/code&gt; ）で始まる型変数は、通常の型変数として扱われます。</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">最後の型パラメーターにファントムロール（&lt;a href=&quot;#roles&quot;&gt;Rolesを&lt;/a&gt;参照）がある場合、派生 &lt;code&gt;Functor&lt;/code&gt; インスタンスは通常のアルゴリズムを使用して生成されません。代わりに、値全体が強制されます。</target>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">データの型引数または型インスタンス宣言の名前が重要でない場合は、アンダースコア（ &lt;code&gt;_&lt;/code&gt; ）に置き換えることができます。これは、一意の名前で型変数を書き込むのと同じです。</target>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">プログラムが&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;とリンクされている場合、複数のOSスレッドから &lt;code&gt;foreign export&lt;/code&gt; 関数を同時に呼び出すことができます。ランタイムシステムは、通常どおり &lt;code&gt;hs_init()&lt;/code&gt; を呼び出して初期化する必要があり、この呼び出しは、 &lt;code&gt;foreign export&lt;/code&gt; 関数を呼び出す前に完了する必要があります。</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">プログラムが&lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt;オプション（&lt;a href=&quot;phases#options-linker&quot;&gt;リンクに影響するオプション&lt;/a&gt;）でリンクされている場合、ランタイムイベントはいくつかの方法でログに記録できます。</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">洗練度が設定されていない場合は、有効なホールフィットの提案のみを提供します。</target>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 式のステートメントに依存関係があり、 &lt;code&gt;ApplicativeDo&lt;/code&gt; が &lt;code&gt;Applicative&lt;/code&gt; タイプを推測できない場合、ヒューリスティックアルゴリズムを使用して &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; を可能な限り使用しようとします。このアルゴリズムは通常、最良の解決策を見つけますが、まれに複雑なケースでは機会を逸する可能性があります。オプションとして提供される、最適な解を見つけるアルゴリズムがあります。</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">型にコンストラクタがない場合、&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;は可能な最も遅延のあるインスタンスを派生させます。</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">typeパラメータにファントムロール（&lt;a href=&quot;#roles&quot;&gt;Rolesを&lt;/a&gt;参照）がある場合、&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;は簡単なインスタンスを派生させます。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">typeパラメータにファントムロール（&lt;a href=&quot;#roles&quot;&gt;Rolesを&lt;/a&gt;参照）がある場合、&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;はその引数を強制します。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">ユーザーが書き込みをすると</target>
        </trans-unit>
        <trans-unit id="d4658dfa457302ae34d87b52d74dc90d170ae615" translate="yes" xml:space="preserve">
          <source>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of &amp;ldquo;right hand side&amp;rdquo; is played by the class method signatures.</source>
          <target state="translated">右側がある場合、GHCは右側と一致する最も多形の種類を推測します。例：通常のデータ型とGADT宣言、クラス宣言。クラス宣言の場合、「右側」の役割はクラスメソッドの署名によって果たされます。</target>
        </trans-unit>
        <trans-unit id="be3a4c9d83d847239f439fe4b373aabfc9fb18bb" translate="yes" xml:space="preserve">
          <source>When there is no right hand side, GHC defaults argument and result kinds to &lt;code&gt;Type&lt;/code&gt;, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</source>
          <target state="translated">右側がない場合、GHCは、種類の署名によって別の方法で指示された場合を除き、引数と結果の種類を &lt;code&gt;Type&lt;/code&gt; にデフォルト設定します。例：データおよびオープン型族の宣言。</target>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">一連のステートメントに厳密なパターンマッチがある場合、 &lt;code&gt;ApplicativeDo&lt;/code&gt; はそのステートメントとそれに続くステートメントの間に &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; を配置します。シーケンスは他の場所で &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; を使用するように変換できますが、厳密なパターンマッチと次のステートメントは常に &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; に関連付けられ、標準のdo表記と同じ厳密性の意味を保持します。あなたはこれをしたくない場合は、簡単に言えば &lt;code&gt;~&lt;/code&gt; 、それは怠惰にするためにパターンマッチに。</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">このフラグが有効で&lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt;が無効の場合、ブロックレイアウトは8.6以前と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">このフラグが設定されている場合、変数は、 &lt;code&gt;it&lt;/code&gt; もはや以前に評価式の結果に設定されません。</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">この最適化を有効にすると、コードジェネレーターはすべての自己再帰的な飽和テールコールを関数コールではなくローカルジャンプに変えます。</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">このオプションを有効にすると、スレッドアフィニティを設定するためにOSが提供するAPIを使用して、機能\（i \）のOSスレッドがCPUコア\（i \）にバインドされます。例えばLinuxではGHCは &lt;code&gt;sched_setaffinity()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">このオプションを指定すると、中間の浮動小数点値は、最終的な型よりも&lt;em&gt;高い&lt;/em&gt;精度/範囲を持つことができます。通常、これは良いことですが、プログラムによっては、 &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; 値の正確な精度/範囲に依存する可能性があるため、このオプションをコンパイルに使用しないでください。</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">この警告が有効になっている場合、以下の条件が確認されます。</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">オンにすると、&lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; を使用して&lt;/a&gt;モジュールごとに抑制することができます。場合によっては、特にAPIを変更せずに実装を変更する余地を残しておくためなど、関数に必要以上に制約されたシグネチャを持たせたいことがあります。その場合、デッドバインディングの呼び出しを使用して、関数ごとに警告を抑制することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">モジュールを型チェックするとき、GHCは制約の解決が始まる前に &lt;code&gt;tcPluginInit&lt;/code&gt; を一度呼び出します。これにより、プラグインはコンテキスト内で物事を調べたり、変更可能な状態を初期化したり、外部プロセス（外部SMTソルバーなど）への接続を開いたりすることができます。プラグインは好きなタイプの結果を返すことができ、結果は他の2つのフィールドに渡されます。</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">タイプのインスタンス宣言をチェックすると &lt;code&gt;F a&lt;/code&gt; 、我々はスーパークラスのことを確認する必要があります &lt;code&gt;C&lt;/code&gt; の &lt;code&gt;F&lt;/code&gt; を保持しています。したがって &lt;code&gt;C a&lt;/code&gt; 以下を含む理論の下で制約C aを伴うことを試みます。</target>
        </trans-unit>
        <trans-unit id="923ea57be74cff7960655db8399f3a2e74d426e3" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="translated">&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt;と組み合わせて使用する場合、派生のベースとなるインスタンスと定義するインスタンスの順序を入れ替えます。例：</target>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">使用する場合、safeキーワードでインポートされるモジュールは信頼できるモジュールでなければなりません。そうでない場合、コンパイルエラーが発生します。安全なインポート拡張機能は、 &lt;code&gt;-XSafe&lt;/code&gt; 、 &lt;code&gt;-XTrustworthy&lt;/code&gt; 、または &lt;code&gt;-XUnsafe&lt;/code&gt; フラグのいずれかによって有効になります。とき &lt;code&gt;-XSafe&lt;/code&gt; フラグが使用され、 &lt;code&gt;safe&lt;/code&gt; すべてのインポートが安全な輸入として扱われるようキーワードは、許可されたが無意味です。</target>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">使用している場合&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;に（ハッシュ記号のメーク使用することをまたは他の拡張機能）を &lt;code&gt;.hsc&lt;/code&gt; （参照ファイル&lt;a href=&quot;utils#hsc2hs&quot;&gt;Cコードへの書き込みのHaskellインタフェースを：hsc2hs&lt;/a&gt;）、ハッシュ記号は、（書き込み倍増しなければならない &lt;code&gt;##foo&lt;/code&gt; の代わりに、 &lt;code&gt;#foo&lt;/code&gt; それらを避けるために） &lt;code&gt;hsc2hs&lt;/code&gt; ディレクティブとして扱われます。</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">&lt;code&gt;-dynamic-too&lt;/code&gt; を使用する場合、オプション &lt;code&gt;-dyno&lt;/code&gt; 、 &lt;code&gt;-dynosuf&lt;/code&gt; 、および &lt;code&gt;-dynhisuf&lt;/code&gt; は、それぞれ &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-osuf&lt;/code&gt; 、および &lt;code&gt;-hisuf&lt;/code&gt; に相当しますが、動的コンパイルに適用されます。</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">&lt;code&gt;capi&lt;/code&gt; を使用する場合、関数ではなく値をインポートすることもできます。例えば、</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">&lt;code&gt;par&lt;/code&gt; を使用する場合、一般的な経験則では、スパークされた計算は後で必要になりますが、すぐには必要ありません。また、スパークされた計算は小さすぎてはいけません。さもなければ、並列にフォークするコストが、得られる並列処理の量に比べて大きすぎます。これらの要因を正しく理解することは、実際にはトリッキーです。</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">ファイル形式のインタラクションを使用する場合、入力文字の直後に改行がある場合は、改行が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="e3b100300996ccb1d75762df35aa37649891a202" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, consumes a single character from the input which may be non-printable.</source>
          <target state="translated">ファイル形式のインタラクションを使用する場合、印刷不可能な入力から1文字を消費します。</target>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">ファイル形式の相互作用を使用する場合、 &lt;code&gt;EOF&lt;/code&gt; の場合、これらの関数は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します文字が読み込まれる前にが検出されるとます。</target>
        </trans-unit>
        <trans-unit id="4a4385a77afcebb26e3a91b60eea37d30d0eaa80" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">ファイルスタイルのインタラクションを使用する場合、文字が読み取られる前に &lt;code&gt;EOF&lt;/code&gt; が検出された場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">ファイル形式のインタラクションを使用する場合、入力行を読み込んでいる間のエコーをオフにします。</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">レコードを使う場合は、レコードのフィールドと同じ名前の変数をバインドするパターンを書くのが一般的です。</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">ターミナル形式のインタラクションを使用する場合、改行を待たずに文字が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">端末スタイルの対話を使用する場合、ユーザーが &lt;code&gt;Ctrl-D&lt;/code&gt; を押すと、これらの関数は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します場合、入力テキストが空のときにます。</target>
        </trans-unit>
        <trans-unit id="bd410ab3f115e8c24b1b1823fdc91cadf6703bb8" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">ターミナルスタイルのインタラクションを使用する場合、入力テキストが空のときにユーザーが &lt;code&gt;Ctrl-D&lt;/code&gt; を押すと、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="281059d7f6e369f72746883abde7604d2dfc5db0" translate="yes" xml:space="preserve">
          <source>When using the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the &lt;code&gt;utils&lt;/code&gt; directory.</source>
          <target state="translated">フラグ&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;を使用すると、GHCが生成され、パイプを使用して別のプロセスと通信します。ネットワークを介して通信を行うことが望ましいシナリオがあります（クロスコンパイルの場合など）。GHCは、このための2つのユーティリティを提供します。これらは &lt;code&gt;utils&lt;/code&gt; ディレクトリにあります。</target>
        </trans-unit>
        <trans-unit id="efdd57bd1b21cb371408a146a00b6a306e283b88" translate="yes" xml:space="preserve">
          <source>When value is used as argument to FFI call that is</source>
          <target state="translated">値がFFIコールの引数として使用されている場合は、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">しかし、異なるマシン上で実行されている異なるプロセス間で値が通信される場合、各プロセスが与えられた値を格納するために異なるアドレスを使用する可能性があるため、アドレスはもはや有用ではありません。</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">後でレンダリングするときに、このセルが何列または何行にまたがるかがわかり、正しいcolspan/rowspanコマンドを含めることができます。</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オーバーロードされたラベルを書き込むときは、ハッシュ記号と次の識別子の間にスペースがあってはなりません。&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; の&lt;/a&gt;延長は、postfixのハッシュ記号を使用しています。場合&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; は&lt;/a&gt;両方とも、その後有効にしている &lt;code&gt;x#y&lt;/code&gt; 手段を &lt;code&gt;x# y&lt;/code&gt; 、しかし、場合にのみ&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; が&lt;/a&gt;有効になっている、それは意味 &lt;code&gt;x #y&lt;/code&gt; 。&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;拡張可能 &lt;code&gt;(#&lt;/code&gt; ので、単一の語彙素、&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; は&lt;/a&gt;あなたが左括弧とオーバーロードされたラベルの間にスペースを記述する必要があります有効になっている。混乱を避けるためには、あなたは強く使用している場合、ハッシュの前にスペースを入れることが奨励されています&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">あなたが&lt;em&gt;本当に&lt;/em&gt;スピードに必死であり、あなたが「生のビット」にすぐに行きたいと思っているとき。&lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;ボックス化されていない型の&lt;/a&gt;使用については、ボックス化されていない型を参照してください。</target>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">&lt;code&gt;safe&lt;/code&gt; （デフォルト）と注釈が付けられた &lt;code&gt;foreign import&lt;/code&gt; 関数を呼び出し、プログラムが&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;を使用してリンクされた場合、呼び出しは他の実行中のHaskellスレッドと同時に実行されます。プログラムが&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;なしでリンクされた場合、他のHaskellスレッドは、呼び出しが戻るまでブロックされます。</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">テンプレートHaskellスプライスを含むシンプルなモジュールをコンパイルする場合</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">&lt;code&gt;Wibble&lt;/code&gt; をインポートするモジュールをコンパイルすると、GHCは指定されたメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">指定されたエンティティのいずれかをインポートして使用するモジュールをコンパイルすると、GHCは指定されたメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; を使用して抽象型を定義する場合、新しい型がその表現からいくつかのインスタンスを継承するようにしたい場合があります。Haskell 98では、 &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Enum&lt;/code&gt; 、 &lt;code&gt;Bounded&lt;/code&gt; のインスタンスを派生によって継承できますが、他のクラスの場合は、明示的なインスタンス宣言を記述する必要があります。たとえば、次のように定義した場合</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">HaskellソースモジュールをGHCiにロードすると、通常はバイトコードに変換され、インタープリターを使用して実行されます。ただし、解釈されたコードは、GHCiでコンパイルされたコードと一緒に実行することもできます。実際、通常、GHCiの起動時に、 &lt;code&gt;Prelude&lt;/code&gt; を含む &lt;code&gt;base&lt;/code&gt; パッケージのコンパイル済みコピーが読み込まれます。</target>
        </trans-unit>
        <trans-unit id="bae6cc0177e18e9dda3c2fed6840139044a5c6c1" translate="yes" xml:space="preserve">
          <source>When you then compile a module containing the following</source>
          <target state="translated">次に、以下のようなモジュールを含むモジュールをコンパイルした場合</target>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">プロンプトで式を入力すると、GHCiはすぐに評価して結果を表示します。</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">プロンプトで式を入力するとき、どのような識別子と型がスコープに含まれていますか?GHCi は、式のコンテキストがどのように構築されるかを正確に制御する柔軟な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">パターンマッチングを使用すると、バインドされた変数が多相型を持つようになりました。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">あなたは、リソースを取得し、それをいくつかの作業を行うと、そのリソースを解放したいときは、使用することをお勧めし &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ので、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 例外が中に発生した場合に、リソースを解放するために必要な例外ハンドラをインストールします計算。例外が発生した場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; は例外を再発生させます（リリースの実行後）。</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">あなたは、リソースを取得し、それをいくつかの作業を行うと、そのリソースを解放したいときは、使用することをお勧めし &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ので、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 例外が中に発生した場合に、リソースを解放するために必要な例外ハンドラをインストールします計算。例外が発生した場合、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; は例外を再発生させます（リリースの実行後）。</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">ソースコードに関するセマンティック情報を必要とするプラグインを定義する場合は、 &lt;code&gt;typeCheckResultAction&lt;/code&gt; フィールドを使用します。たとえば、プラグインが2つの名前が同じ定義を参照しているかどうかを判断する必要がある場合、またはセマンティック情報を使用して関数のタイプを確認する必要がある場合。この場合、 &lt;code&gt;typeCheckResultAction&lt;/code&gt; または &lt;code&gt;renamedResultAction&lt;/code&gt; を使用して、構文ツリーの名前が変更されたバージョンまたはタイプがチェックされたバージョンにアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">ソースコードの構文ツリーを使用するプラグインを定義する場合は、 &lt;code&gt;parsedResultAction&lt;/code&gt; フィールドをオーバーライドします。このアクセスポイントを使用すると、ソースコード内の字句トークンとコメントに関する情報、およびコンパイル済みモジュールの元の構文ツリーにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">Haskellプログラムが起動すると、RTSは &lt;code&gt;+RTS&lt;/code&gt; と &lt;code&gt;-RTS&lt;/code&gt; で囲まれたコマンドライン引数を独自のものとして抽出します。例えば：</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">式（または厳密には非結合ステートメント）がプロンプトで入力されると、GHCiは暗黙的にその値を変数 &lt;code&gt;it&lt;/code&gt; に結合します。例えば：</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">エクスポート・リストがなく、データ・インスタンスが定義されている場合はいつでも、データ・ファミリーがローカルで定義されているか別のモジュールで定義されているかにかかわらず、対応するデータ・ファミリー型のコンストラクタが新しいデータ・コンストラクタとともにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">ここで、 &lt;code&gt;@Int&lt;/code&gt; は可視型アプリケーション（&lt;a href=&quot;#visible-type-application&quot;&gt;可視型アプリケーション&lt;/a&gt;）を使用して、 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; をインスタンス化します:: forall b。C '=&amp;gt; a-&amp;gt; b-&amp;gt; bです。この型アプリケーションが機能するためには、 &lt;code&gt;bar&lt;/code&gt; のデフォルトの型シグネチャは、デフォルト以外のシグネチャと同じ型変数の順序である必要があります。ただし、 &lt;code&gt;C&lt;/code&gt; と &lt;code&gt;C'&lt;/code&gt; が同じである必要はありません（たとえば、これに依存する上記の &lt;code&gt;Enum&lt;/code&gt; の例を参照してください）。</target>
        </trans-unit>
        <trans-unit id="1e0b35957734f5fe542ba29ec49c8ef55e2f5be3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;TypedHole&lt;/code&gt; contains all the information about the hole available to GHC at error generation.</source>
          <target state="translated">どこ &lt;code&gt;TypedHole&lt;/code&gt; は、エラー発生時GHCに利用できる穴に関するすべての情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="8b355b1ff69acd8ba68909a327dda7911de5cd33" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convencience function provided in the &lt;code&gt;TcHoleErrors&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="translated">どこ &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; で提供convencience機能である &lt;code&gt;TcHoleErrors&lt;/code&gt; の内部状態を必要としないプラグインを定義するため、モジュール。</target>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">ここで、 &lt;code&gt;v&lt;/code&gt; はバイナリエンコードされたデータ構造です。元のデータを再構築するには、 &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="8a5c9769e817dcef676d11da0257e6662b614a31" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="translated">GHCが拡張インスタンス宣言を許可する場合、この新しい形式の &lt;code&gt;class&lt;/code&gt; に対してまったく同じ拡張を許可します。具体的には、&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; を使用&lt;/a&gt;すると、構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">GHCが拡張インスタンス宣言を許可する場合、この新しい形式の &lt;code&gt;class&lt;/code&gt; に対してまったく同じ拡張を許可します。具体的には、&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; を使用すると、構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">可能なアプリケーションでは、代わりに、&lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;などの通常のパブリックインターフェイスモジュールの関数を使用する必要があります。低レベルでByteStringシステムを拡張するパッケージは、このモジュールを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">ユーザー提供のライブラリを見つける場所&amp;hellip;ディレクトリdirをライブラリディレクトリパスの先頭に追加します。</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">各行入力セッションの開始時と終了時の履歴をどこに読み書きするか。</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">ここで、⟨identifier⟩ は、現在 GHCi にロードされているインタプリタモジュール内のトップレベル関数の名前を指定します(修飾名を使用することができます)。ブレークポイントは、完全に適用されたときに、パターンマッチングが行われる前に、関数の本体に設定されます。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; は関数アプリケーションであるのに対し、 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; を介して持ち上げられた関数アプリケーションです。</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; は関数アプリケーションであるのに対し、 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; を介して持ち上げられた関数アプリケーションです。</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; は関数アプリケーションであるのに対し、 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; を介して持ち上げられた関数アプリケーションです。</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">Haskellでは、 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; は値を含むまたは生成するものと考えることができますが、反変ファンクタは、値を&lt;em&gt;消費&lt;/em&gt;するものと考えることができるファンクタです。</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">リストは有限でも無限でもかまいませんが、シーケンスは常に有限です。その結果、シーケンスの長さは厳密になります。効率を無視すると、 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; が定義されていると想像できます</target>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">ハイパースレッディングコアを数えるべきかどうかは未解決の問題です。</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">コストセンターがCAF(Constant Applicative Form)であるかどうか</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">一致が元のデータコンストラクターのセットによるものか、 &lt;code&gt;COMPLETE&lt;/code&gt; プラグマによるものか（前者を後者より優先する）</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">これが保持されるかどうかは、使用している GHC のバージョン、作業しているプラットフォーム、作業しているデータ、使用しているエンコーディングに依存するので、必ず自分自身でテストしてください。</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">この単語の後にスペースやエンドクォートなどをつけるかどうか。</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">プラスの数字にプラスの符号を主張するかどうか。</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">フィールドを左揃えにするかゼロ埋めするか。これらは相互に排他的で、 &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; が優先されます。</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">オリジナルのソースコードのスニペットを表示するかどうか</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; のパターンのカバレッジをチェックするときに、どの &lt;code&gt;COMPLETE&lt;/code&gt; プラグマを使用する必要がありますか？ &lt;code&gt;MkT1&lt;/code&gt; と &lt;code&gt;MkT2&lt;/code&gt; をカバーする &lt;code&gt;COMPLETE&lt;/code&gt; セットを選択すると、 &lt;code&gt;f&lt;/code&gt; は完全になりますが、 &lt;code&gt;MkT1&lt;/code&gt; をカバーする他の &lt;code&gt;COMPLETE&lt;/code&gt; セットを選択するとと &lt;code&gt;MkT2Internal&lt;/code&gt; は、その後、 &lt;code&gt;f&lt;/code&gt; ある&lt;em&gt;ではない&lt;/em&gt;、それが一致しないことから、網羅 &lt;code&gt;MkT2Internal&lt;/code&gt; を。このジレンマを解決する直感的な方法は、以前の &lt;code&gt;COMPLETE&lt;/code&gt; セットを選択すると、カバーされていないパターン句の数が最も少なくなるため、より良い選択であることを認識することです。</target>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">これにより、よりクリーンなスタイルで関数を書き換えることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">どの世代がゴミ回収されているのか</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">これは、穴をたとえば &lt;code&gt;foldl1 _&lt;/code&gt; に置き換えることができることを示しています。穴を修正していませんが、これはユーザーが自分の持っているオプションを理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="27f2f23bcde10c66a5f5e9d8aafa47b4840854e9" translate="yes" xml:space="preserve">
          <source>Which will produce the following compile-time error,</source>
          <target state="translated">これは次のようなコンパイル時エラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="7c1db43b33397020a8ed5957fa5d9d38875398ba" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; will force evaluation of all the list elements:</source>
          <target state="translated">一方で &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; は、すべてのリストの要素の評価を強制します。</target>
        </trans-unit>
        <trans-unit id="8c332ca7e19d20c8fa57c56fd1a11cc1b3adb5fc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; allows using quoting (i.e., convenient escaping of many characters) by having matching sets of single- or double-quotes,&lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; does not use the quoting mechasnism, and thus will always escape any whitespace, quotes, and backslashes.</source>
          <target state="translated">ながら &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; は、単一または二重引用符のマッチングセットを持つことにより、引用（多くの文字のすなわち、便利なエスケープ）を使用可能にする、 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; は引用mechasnismを使用しないため、常に空白、引用符、およびバックスラッシュをエスケープします。</target>
        </trans-unit>
        <trans-unit id="81b625ad3235f180ec5913cc634ab52ecae12b67" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;INLINE&lt;/code&gt; says &amp;ldquo;please inline me&amp;rdquo;, the &lt;code&gt;INLINABLE&lt;/code&gt; says &amp;ldquo;feel free to inline me; use your discretion&amp;rdquo;. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike &lt;code&gt;INLINE&lt;/code&gt;, that decision is made at the &lt;em&gt;call site&lt;/em&gt;, and will therefore be affected by the inlining threshold, optimisation level etc.</source>
          <target state="translated">一方で &lt;code&gt;INLINE&lt;/code&gt; 「私をインライン化してください」と言い、 &lt;code&gt;INLINABLE&lt;/code&gt; は私をインライン化して自由に感じる」と言います。あなたの裁量を使用してください。」言い換えると、選択はGHCに任され、GHCはプラグマフリー関数と同じルールを使用します。 &lt;code&gt;INLINE&lt;/code&gt; とは異なり、その決定は&lt;em&gt;呼び出しサイト&lt;/em&gt;で行われるため、インライン化のしきい値、最適化レベルなどの影響を受けます。</target>
        </trans-unit>
        <trans-unit id="c6ee9afc23b83e42b01663a5ce2d75b90b1d7053" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;a + b&lt;/code&gt; is parsed as &lt;code&gt;(+) a b&lt;/code&gt; and becomes a binding position for the &lt;code&gt;(+)&lt;/code&gt; type operator, &lt;code&gt;a * b&lt;/code&gt; is parsed as &lt;code&gt;a (*) b&lt;/code&gt; and is rejected.</source>
          <target state="translated">ながら &lt;code&gt;a + b&lt;/code&gt; として解析される &lt;code&gt;(+) a b&lt;/code&gt; との結合位置となります &lt;code&gt;(+)&lt;/code&gt; 型演算子、 &lt;code&gt;a * b&lt;/code&gt; として解析され &lt;code&gt;a (*) b&lt;/code&gt; と拒絶されます。</target>
        </trans-unit>
        <trans-unit id="dca826ec4b4920b6625508b06645e0892b105a31" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; uses &lt;code&gt;k&lt;/code&gt; without introducing it and thus violates the rule, it is currently accepted. This is because &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が使用している間 &lt;code&gt;k&lt;/code&gt; はそれを導入することなく、従って、ルールに違反し、それが現在認められています。これは、 &lt;code&gt;n&lt;/code&gt; の &lt;code&gt;k&lt;/code&gt; が種類シグネチャで発生するため、種類変数と見なされるためです。実際には、次の例に示すように、型変数と種類変数の間の線はぼやけています。</target>
        </trans-unit>
        <trans-unit id="89d044abb31d0358bb574168c9340e2f2b315fbc" translate="yes" xml:space="preserve">
          <source>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</source>
          <target state="translated">GHCは関数のインライン化には熱心ですが、やみくもにそれを行うわけではありません。例えば</target>
        </trans-unit>
        <trans-unit id="3add16df5fe36ab800dc2ff2e76070f38ee83e1d" translate="yes" xml:space="preserve">
          <source>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren&amp;rsquo;t explicitly using Safe Haskell. Please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details of this.</source>
          <target state="translated">Safe Haskellは拡張機能ですが、実際にはGHCでのすべてのコンパイルでバックグラウンドで実行されます。Safe Haskellを明示的に使用していない場合でも、モジュールのタイプ違反を追跡して安全性を推測するためにこれを行います。詳細については、セクション「&lt;a href=&quot;#safe-inference&quot;&gt;安全なHaskell推論&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="35b0013a13db3b6fdc98ef77d44fddaaca3cc7cb" translate="yes" xml:space="preserve">
          <source>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn&amp;rsquo;t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</source>
          <target state="translated">Safe Haskellの主なユースケースは信頼できないコードを実行していますが、Safe Haskellはこれを直接提供していません。代わりに、Safe Haskellは厳密な型安全性を提供します。Safe Haskellがない場合、GHCは、抽象化を覆す可能性がある型システムに多くの例外を許可します。厳密な型安全性を提供することにより、Safe Haskellは、開発者が独自のライブラリレベルのサンドボックスメカニズムを構築して、信頼できないコードを実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="def095ee0284bcac4322f43e6852c970ad41b290" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="translated">スタンドアロンの種類シグニチャは型コンストラクタの種類を決定しますが、そのアリティは決定しません。これは、部分的に適用できないため、型族および型同義語にとって特に重要です。アリティの詳細については、&lt;a href=&quot;#type-family-declarations&quot;&gt;型族宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bc21bcd88342a5bb609c83c4f4a251417917aeff" translate="yes" xml:space="preserve">
          <source>While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</source>
          <target state="translated">開発中、コードに型エラーがあってもコンパイルを成功させることが望ましい場合があります。次のような場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="91465cfe2041d24f0183967b4edb1cd4e56225f7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;コマンドを使用してGHCiにロードされたモジュールは、&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;static&lt;/code&gt; 式を使用できますが、REPLに入力されたステートメントは使用できません。これはGHCiの制限です。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;＃12356&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="11d4576ffb50b0fa9daa17cbe0afb23508da41b7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;Issue #12356&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;コマンドでGHCiにロードされたモジュールは&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;static&lt;/code&gt; 式を使用できますが、REPLに入力されたステートメントは使用できません。これはGHCiの制限です。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;問題＃12356&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="97f98250e481ccf0975daf7dab8b3fe176183423" translate="yes" xml:space="preserve">
          <source>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</source>
          <target state="translated">プロファイリングをオンにしてプログラムを実行している間、GHCは裏でコスト中心スタックを維持し、あらゆるコスト(メモリ割り当てと時間)を、コストが発生した時点での現在のコスト中心スタックに属性付けします。</target>
        </trans-unit>
        <trans-unit id="976e206b9026791ffd0e6fb58a4293cf7ea81bb6" translate="yes" xml:space="preserve">
          <source>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with &lt;code&gt;:step qsort [1,3]&lt;/code&gt;. This new evaluation stopped after one step (at the definition of &lt;code&gt;qsort&lt;/code&gt;). The prompt has changed, now prefixed with &lt;code&gt;...&lt;/code&gt;, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt;&lt;code&gt;:show context&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">前に設定した2行目のブレークポイントで停止している間に、 &lt;code&gt;:step qsort [1,3]&lt;/code&gt; を使用して新しい評価を開始しました。この新しい評価は、1ステップ後に停止しました（ &lt;code&gt;qsort&lt;/code&gt; の定義）。プロンプトが変更され、現在のプレフィックスが &lt;code&gt;...&lt;/code&gt; になり、現在のブレークポイントを超えて保存されたブレークポイントがあることを示します。コンテキストのスタックを表示するには、次を使用します&lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt; &lt;code&gt;:show context&lt;/code&gt; をます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b98a4c50da2ca10fa0d38e9a101fe3f3e6126a79" translate="yes" xml:space="preserve">
          <source>While the following definitions are rejected:</source>
          <target state="translated">以下の定義が却下される中</target>
        </trans-unit>
        <trans-unit id="b1966b6c5939a4035f3d998424b60e02fda159f6" translate="yes" xml:space="preserve">
          <source>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details.</source>
          <target state="translated">これらはフラグですが、モジュールが持つことができるSafe Haskellモジュールタイプにも対応しています。これらは、モジュールに必要な明示的なコントラクト（または型）を宣言するものと考えることができます。無効な場合、コンパイルは失敗します。GHCはSafe Haskellの正しいタイプも推測します。詳細については、「&lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskellの推測」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="022ab35cfa47002a4ebdaca07f6e366ba8988d90" translate="yes" xml:space="preserve">
          <source>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter &lt;code&gt;a&lt;/code&gt; occur in &lt;em&gt;contravariant&lt;/em&gt; positions, not covariant ones.</source>
          <target state="translated">これらの例は似ていますが、正常にコンパイルできませんでした。これは、最後のタイプパラメータ &lt;code&gt;a&lt;/code&gt; がすべて出現するためです。共変な位置ではなく&lt;em&gt;反変的な&lt;/em&gt;位置で発生するためです。</target>
        </trans-unit>
        <trans-unit id="75a5eda6c195abd9046975cac318fe63ebb5499d" translate="yes" xml:space="preserve">
          <source>While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse.</source>
          <target state="translated">これらの関数は安定した API を持っており、アプリケーションでこれらの関数を使用することができますが、文書化された事前条件を注意深く考慮してください。</target>
        </trans-unit>
        <trans-unit id="b0aa0a8b0c40d44fe32076b2dde1270dea9d839c" translate="yes" xml:space="preserve">
          <source>While this is rather low level, it provides you with full flexibility in how the data is written out.</source>
          <target state="translated">これはかなり低レベルですが、データをどのように書き出すかについては完全な柔軟性を提供します。</target>
        </trans-unit>
        <trans-unit id="9187e41f7f9137050f5d28dffbf78dde7c993814" translate="yes" xml:space="preserve">
          <source>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use &lt;code&gt;Point&lt;/code&gt;. Precisely the ways in which a normal record constructor can be used.</source>
          <target state="translated">通常のパターンの同義語は2つの方法で使用できますが、7つの方法で使用できます。 &lt;code&gt;Point&lt;/code&gt; 。通常のレコードコンストラクターを正確に使用する方法。</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="83eb1c09c969cd3e57a811f38dd6447b18c3ead5" translate="yes" xml:space="preserve">
          <source>Why did I get a link error?</source>
          <target state="translated">なぜリンクエラーになってしまったのか?</target>
        </trans-unit>
        <trans-unit id="440e86b8976c4e4796fbf85e0f090b3bc6b09cbc" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">なぜ &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; の両方が存在し、なぜGHC は &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; の代わりに派生した &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスに &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; を実装することを選ぶのですか？その理由は、 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; タイプに基づいているためです。 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; Haskell 2010レポートで言及されてますが、非常に効率的なパーサーデータ構造ではありません。</target>
        </trans-unit>
        <trans-unit id="4b3d234dc0251109fb3ebae077fa379bf3b538ac" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">なぜ &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; の両方が存在し、なぜGHC は &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; の代わりに派生した &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスに &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; を実装することを選ぶのですか？その理由は、 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; タイプに基づいているためです。 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; Haskell 2010レポートで言及されてますが、非常に効率的なパーサーデータ構造ではありません。</target>
        </trans-unit>
        <trans-unit id="f3e75c0bb579876ee1ae6f6f75f665c7fa512d6b" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">なぜ &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; の両方が存在し、なぜGHC は &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; の代わりに派生した &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスに &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; を実装することを選ぶのですか？その理由は、 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; タイプに基づいているためです。 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; Haskell 2010レポートで言及されてますが、非常に効率的なパーサーデータ構造ではありません。</target>
        </trans-unit>
        <trans-unit id="86af37585c6c693fdc0ebac6c3d4e275681346c9" translate="yes" xml:space="preserve">
          <source>Why do we need this? Because if a foreign library is called from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, it won't have access to any &lt;em&gt;thread-local state&lt;/em&gt; - state variables that have specific values for each OS thread (see POSIX's &lt;code&gt;pthread_key_create&lt;/code&gt; or Win32's &lt;code&gt;TlsAlloc&lt;/code&gt;). Therefore, some libraries (OpenGL, for example) will not work from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;. They work fine in threads created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; or when called from &lt;code&gt;main&lt;/code&gt; or from a &lt;code&gt;foreign export&lt;/code&gt;.</source>
          <target state="translated">なぜ私たちはこれが必要なのですか？外部ライブラリが &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を使用して作成されたスレッドから呼び出された場合、OS &lt;em&gt;ローカル&lt;/em&gt;スレッドごとに特定の値を持つ状態変数（POSIXの &lt;code&gt;pthread_key_create&lt;/code&gt; またはWin32の &lt;code&gt;TlsAlloc&lt;/code&gt; を参照）にはアクセスできません。したがって、一部のライブラリ（OpenGLなど）は、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を使用して作成されたスレッドからは機能しません。これらは、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; を使用して作成されたスレッドで、または &lt;code&gt;main&lt;/code&gt; または &lt;code&gt;foreign export&lt;/code&gt; から呼び出されたときに正常に動作します。</target>
        </trans-unit>
        <trans-unit id="bbbc60c133dcaa45a637190bca0c68db03dab6c1" translate="yes" xml:space="preserve">
          <source>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</source>
          <target state="translated">なぜこのようなことをしたいのでしょうか?主な理由は、解釈されたコードを実行している RTS が GHC 自体とは異なるフレーバー (プロファイリングや動的にリンクされたもの)になる可能性があるからです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="47b6a914e21ff5813991e6da748b083baff53cd8" translate="yes" xml:space="preserve">
          <source>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren&amp;rsquo;t changing very often, and use the interpreter for the code being actively developed.</source>
          <target state="translated">コンパイルしたコードを実行する必要があるのはなぜですか？まあ、コンパイルされたコードはインタープリターコードよりも約10倍高速ですが、生成に約2倍長くかかります（最適化がオンの場合はおそらくさらに長くなります）。そのため、プログラムの中で頻繁に変更されない部分をコンパイルし、積極的に開発されているコードにインタープリターを使用することは価値があります。</target>
        </trans-unit>
        <trans-unit id="cc7d6ee8236b5733d37003f374fc603c874165c9" translate="yes" xml:space="preserve">
          <source>Width digits can also be used after any modifiers and before the specifier (here marked as &lt;code&gt;z&lt;/code&gt;), for example:</source>
          <target state="translated">幅の数字は、修飾子の後と指定子（ここでは &lt;code&gt;z&lt;/code&gt; とマークされています）の前でも使用できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="6cc81c4740a7ec55686ef91e0c779bca9974a1fc" translate="yes" xml:space="preserve">
          <source>WildCardT</source>
          <target state="translated">WildCardT</target>
        </trans-unit>
        <trans-unit id="9dd4ee310008cd2a0ddc0df60850b2b849a28904" translate="yes" xml:space="preserve">
          <source>WildP</source>
          <target state="translated">WildP</target>
        </trans-unit>
        <trans-unit id="0bad7324dc674391ab667a3facf3ae0df9dc30be" translate="yes" xml:space="preserve">
          <source>Wildcards occurring within the monotype (tau) part of the type signature are &lt;em&gt;type wildcards&lt;/em&gt; (&amp;ldquo;type&amp;rdquo; is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like &lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;Maybe [Bool]&lt;/code&gt;, including functions and higher-kinded types like &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.</source>
          <target state="translated">型シグネチャのモノタイプ（tau）部分内に出現するワイルドカードは、&lt;em&gt;タイプワイルドカードです&lt;/em&gt;（「type」は、これがデフォルトの種類のワイルドカードであるため、多くの場合省略されます）。タイプワイルドカードのような、任意のモノタイプにインスタンス化することができる &lt;code&gt;Bool&lt;/code&gt; または &lt;code&gt;Maybe [Bool]&lt;/code&gt; 機能など高kindedタイプを含む、 &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; または &lt;code&gt;Maybe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9658cea5793b3d031fa20c655bb68dd4c32b903a" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;#11197&lt;/a&gt;.</source>
          <target state="translated">よく型付けされた &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 後に、型が正しくない用語が表示されているにもかかわらず、出力は出力されません。。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;＃11197を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ef392380581e1168eebb15a8a0e18150691c4d57" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Issue #11197&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 型付けされたputStrLn「こんにちは。。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;問題＃11197を&lt;/a&gt;参照。</target>
        </trans-unit>
        <trans-unit id="0a1662f103a3266468f46e63fa2cf2f0cfd01bbf" translate="yes" xml:space="preserve">
          <source>Will raise two warnings because &lt;code&gt;Zero&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; are not written as &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Zero&lt;/code&gt; と &lt;code&gt;Succ&lt;/code&gt; は &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt; と書かれていないため、2つの警告が出されます。</target>
        </trans-unit>
        <trans-unit id="1c5ec9681ce2072b76c270f62f6f9eee48c28bf7" translate="yes" xml:space="preserve">
          <source>WindowClosure</source>
          <target state="translated">WindowClosure</target>
        </trans-unit>
        <trans-unit id="7e26c5824975ae8a63fa3abf0584b4efdb2b248d" translate="yes" xml:space="preserve">
          <source>WindowStyle</source>
          <target state="translated">WindowStyle</target>
        </trans-unit>
        <trans-unit id="9378a46e189b577aaeee3aa3a868039a552854b0" translate="yes" xml:space="preserve">
          <source>WindowStyleEx</source>
          <target state="translated">WindowStyleEx</target>
        </trans-unit>
        <trans-unit id="8a20bdc2dc7d2d8d4e84b9d92b1bb47619b3475f" translate="yes" xml:space="preserve">
          <source>Windows GUI-only programs have no stdin, stdout or stderr so using the ordinary Haskell input/output functions will cause your program to fail with an IO exception, such as:</source>
          <target state="translated">WindowsのGUIのみのプログラムにはstdin、stdout、stderrがないので、通常のHaskellの入出力関数を使用すると、プログラムはIO例外などで失敗します。</target>
        </trans-unit>
        <trans-unit id="5d6f840cad39d9a272a9703b68f0d38fb8222f38" translate="yes" xml:space="preserve">
          <source>Windows only: directory link</source>
          <target state="translated">Windowsのみ:ディレクトリリンク</target>
        </trans-unit>
        <trans-unit id="73d40c03f33c4a3de272ded5007d929ac7019282" translate="yes" xml:space="preserve">
          <source>Windows paths are not all the same. The different kinds of paths each have different meanings. The &lt;code&gt;MAX_PATH&lt;/code&gt; limitation is not a limitation of the operating system nor the file system. It is a limitation of the default namespace enforced by the Win32 API for backwards compatibility.</source>
          <target state="translated">Windowsパスはすべて同じではありません。さまざまな種類のパスにはそれぞれ異なる意味があります。 &lt;code&gt;MAX_PATH&lt;/code&gt; の制限は、オペレーティングシステムやファイルシステムの制限ではありません。これは、下位互換性のためにWin32 APIによって適用されるデフォルトの名前空間の制限です。</target>
        </trans-unit>
        <trans-unit id="48c423f5c542bd757cc0d8148840620479fe1d50" translate="yes" xml:space="preserve">
          <source>Windows systems</source>
          <target state="translated">ウィンドウズシステム</target>
        </trans-unit>
        <trans-unit id="17b0e8d7184831d84e104c44677c17826487591f" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows固有のエラー：ファイルシステムがシンボリックリンクをサポートしていない場合、この操作は &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ae9664fed6d551c4afead4741b8d33a6823b9b7c" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; if the user lacks the privileges to create symbolic links. It may also fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows固有のエラー：シンボリックリンクを作成する権限がユーザーにない場合、この操作は &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; で失敗する可能性があります。ファイルシステムがシンボリックリンクをサポートしていない場合は、 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; で失敗することもあります。</target>
        </trans-unit>
        <trans-unit id="02de5f68b4be14e6f9c02d269cf51b2ebcc4d006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;、GHCは自動的にすべてのデータ型は、型コンストラクタすべき種類とその（値）コンストラクタであることを推進しています。次のタイプ</target>
        </trans-unit>
        <trans-unit id="66de61afd3dce19c1e8432307fd1a6cdbb984d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, Haskell&amp;rsquo;s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;引用接頭辞はいえ、Haskellのリストとタプル型はネイティブの種類に昇格され、タイプレベルで同じ便利な構文を楽しみます：</target>
        </trans-unit>
        <trans-unit id="ad73cf0a187d7c5263c3ed9059162402b019df7e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, the example above can then be rewritten to:</source>
          <target state="translated">&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;、上記の例では、その後に書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="9694f3dae022beb52b1d2eae44907067122df68b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose &lt;a href=&quot;#minimal-pragma&quot;&gt;minimal set&lt;/a&gt; is empty, and especially when writing &lt;a href=&quot;#generic-programming&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;あなたは他のクラスを派生することができます。コンパイラは、明示的に定義されたメソッドを持たないインスタンス宣言を生成するだけです。これは、&lt;a href=&quot;#minimal-pragma&quot;&gt;最小セット&lt;/a&gt;が空のクラスで、特に&lt;a href=&quot;#generic-programming&quot;&gt;ジェネリック関数を&lt;/a&gt;作成するときに特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="05e8935b6c02826df72f7c768e1ec4453e94c14a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt;&lt;code&gt;DeriveDataTypeable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Data&lt;/code&gt;, defined in &lt;code&gt;Data.Data&lt;/code&gt;.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt; &lt;code&gt;DeriveDataTypeable&lt;/code&gt; &lt;/a&gt;、あなたはクラスのインスタンス派生させることができ &lt;code&gt;Data&lt;/code&gt; に定義され、 &lt;code&gt;Data.Data&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="ad9e3a1e0afdec73dafa2b178a39235fdd9bec14" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Foldable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;、一つは得ることができます &lt;code&gt;Foldable&lt;/code&gt; 種類のデータ型のインスタンスを &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="4864b90fc425d7d78346fd4210a107b2e500fb2e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Foldable&lt;/code&gt;, defined in &lt;code&gt;Data.Foldable&lt;/code&gt;.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;、あなたはクラスのインスタンス導出できる &lt;code&gt;Foldable&lt;/code&gt; で定義され、 &lt;code&gt;Data.Foldable&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="671954f0f4d9ee0f1430a6541e8fa3672fbee0d2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Functor&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;、1が導出できる &lt;code&gt;Functor&lt;/code&gt; 種類のデータ型のインスタンス &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="8a9d0c586e9f69c6ba34b372f93f09827c90392d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Functor&lt;/code&gt;, defined in &lt;code&gt;GHC.Base&lt;/code&gt;.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;、あなたはクラスのインスタンスを導き出すことができ &lt;code&gt;Functor&lt;/code&gt; で定義され、 &lt;code&gt;GHC.Base&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="70bde54b16dc89d95935abc8c585ccb864a45328" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;、あなたはクラスのインスタンスを導出することができます &lt;code&gt;Generic&lt;/code&gt; と &lt;code&gt;Generic1&lt;/code&gt; で定義され、 &lt;code&gt;GHC.Generics&lt;/code&gt; を。&lt;a href=&quot;#generic-programming&quot;&gt;総称プログラミングで&lt;/a&gt;説明されているように、これらを使用して総称関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="6e5f52e040d0ae2ddbdd82b0a2735b846ecf5083" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Lift&lt;/code&gt;, defined in the &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; module of the &lt;code&gt;template-haskell&lt;/code&gt; package.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;、あなたはクラスのインスタンスを導き出すことができます &lt;code&gt;Lift&lt;/code&gt; に定義され、 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; ののモジュール &lt;code&gt;template-haskell&lt;/code&gt; パッケージを。</target>
        </trans-unit>
        <trans-unit id="4dc82d6ad448bf5d43bd791bf2a64d65052ded54" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Traversable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;、一つは得ることができます &lt;code&gt;Traversable&lt;/code&gt; の種類のデータ型のインスタンスを &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。たとえば、次の宣言は：</target>
        </trans-unit>
        <trans-unit id="1bd07f0bfee4349fb82f2d04a2759ee937885c23" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Traversable&lt;/code&gt;, defined in &lt;code&gt;Data.Traversable&lt;/code&gt;. Since the &lt;code&gt;Traversable&lt;/code&gt; instance dictates the instances of &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;, you&amp;rsquo;ll probably want to derive them too, so &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">では&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;、あなたはクラスのインスタンス派生させることができ &lt;code&gt;Traversable&lt;/code&gt; の中で定義され、 &lt;code&gt;Data.Traversable&lt;/code&gt; を。以来 &lt;code&gt;Traversable&lt;/code&gt; のインスタンスのおもむくままのインスタンス &lt;code&gt;Functor&lt;/code&gt; と &lt;code&gt;Foldable&lt;/code&gt; よう、あなたはおそらく、あまりにもそれらを導出することをお勧めします&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; は&lt;/a&gt;意味&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="559a00aea3f890980a1f984df90a03d7d63d1ade" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; you can use &lt;em&gt;unqualified&lt;/em&gt; field names even if the corresponding selector is only in scope &lt;em&gt;qualified&lt;/em&gt; For example, assuming the same module &lt;code&gt;M&lt;/code&gt; as in our earlier example, this is legal:</source>
          <target state="translated">では&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;を使用でき&lt;em&gt;、非修飾&lt;/em&gt;対応するセレクタが唯一のスコープ内にある場合でも、フィールド名を&lt;em&gt;修飾&lt;/em&gt;たとえば同じモジュールと仮定すると、 &lt;code&gt;M&lt;/code&gt; が、これは合法である我々の以前の例のように：</target>
        </trans-unit>
        <trans-unit id="d839e1b384cdeb1b20e6abc8876be37df3ce01a5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-MultiWayIf&quot;&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; extension GHC accepts conditional expressions with multiple branches:</source>
          <target state="translated">&lt;a href=&quot;#extension-MultiWayIf&quot;&gt; &lt;code&gt;MultiWayIf&lt;/code&gt; の&lt;/a&gt;拡張GHCは複数の支店を持つ条件式を受け付けます。</target>
        </trans-unit>
        <trans-unit id="a0d6333b42a8531a55b6ff2108e890fa59726fab" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-maxN⟨x⟩&lt;/code&gt;, i.e. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt;, the runtime will choose at most (x), also limited by the number of processors on the system. Omitting (x) is an error, if you need a default use option &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-maxN⟨x⟩&lt;/code&gt; 、すなわち &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt; 、ランタイムは、システム上のプロセッサの数によって制限され、最大で（X）を選択します。デフォルトの使用オプション &lt;code&gt;-N&lt;/code&gt; が必要な場合、（x）を省略するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="bf6c6cd414272ae624ac863540c1eb4369c6d081" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;hpc-tracer&lt;/code&gt;, this is 8 (a tab represents several spaces).</source>
          <target state="translated">&lt;code&gt;hpc-tracer&lt;/code&gt; 、これは8（タブは、いくつかのスペースを表している）です。</target>
        </trans-unit>
        <trans-unit id="cec44f01be85a69c1fd7140d01ffa23f751d8ab9" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;ByteString&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">GHCでは、 &lt;code&gt;ByteString&lt;/code&gt; 表現は&lt;em&gt;固定された&lt;/em&gt;メモリを使用するため、GCで移動することはできません。これは通常、より大きな文字列に対して行うのが正しいことですが、固定されたメモリを使用する小さな文字列に対しては、ヒープの断片化につながり、スペースを浪費する可能性があります。 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; のタイプ（および &lt;code&gt;Text&lt;/code&gt; からタイプ &lt;code&gt;text&lt;/code&gt; パッケージ）を使用し&lt;em&gt;固定されていない&lt;/em&gt;彼らは、ヒープの断片化には寄与しないので、メモリを。さらに、GHCでは、固定されていない小さな文字列は、別の固定された領域ではなく、通常のヒープ割り当てと同じ方法で割り当てられます。</target>
        </trans-unit>
        <trans-unit id="1b24cdcec5afa4ca8ae04f5f805367b2d6db2d4d" translate="yes" xml:space="preserve">
          <source>With GHC, the memory overheads are as follows, expressed in words and in bytes (words are 4 and 8 bytes on 32 or 64bit machines respectively).</source>
          <target state="translated">GHCの場合、メモリオーバーヘッドは以下の通りで、ワードとバイトで表されます(ワードは32ビット、64ビットのマシンではそれぞれ4バイト、8バイト)。</target>
        </trans-unit>
        <trans-unit id="2d06615b16a183cf6330905f8030d63fe75722c8" translate="yes" xml:space="preserve">
          <source>With Unicode text, it is incorrect to use combinators like &lt;code&gt;map
 toUpper&lt;/code&gt; to case convert each character of a string individually. Instead, use the whole-string case conversion functions from this module. For correctness in different writing systems, these functions may map one input character to two or three output characters.</source>
          <target state="translated">Unicodeテキストでは、文字列の各文字を個別に &lt;code&gt;map toUpper&lt;/code&gt; と小文字に変換するためにmap toUpperのようなコンビネーターを使用することは正しくありません。代わりに、このモジュールの文字列全体を変換する関数を使用してください。異なる書記体系での正確さのために、これらの関数は1つの入力文字を2つまたは3つの出力文字にマップする場合があります。</target>
        </trans-unit>
        <trans-unit id="51f3ae84f7608aa013b4484775362a706adc53f0" translate="yes" xml:space="preserve">
          <source>With any luck, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; will be undefined in all other implementations that support C-style pre-processing.</source>
          <target state="translated">運が &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 、C形式の前処理をサポートする他のすべての実装では__GLASGOW_HASKELL__は未定義になります。</target>
        </trans-unit>
        <trans-unit id="c44ed7fc274ccaa822b5b3ccf3ecc3bf7adbae81" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;#2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">依存型の機能を使用すると、より便利になります（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;＃2431を&lt;/a&gt;参照）。たとえば、 &lt;code&gt;absurd&lt;/code&gt; 次の2つの候補定義について考えてみます。</target>
        </trans-unit>
        <trans-unit id="107ef4354dd6e452c7d4441a2e93bd2aacde1ddc" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue #2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">依存型の機能を使用すると、より便利になります（&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;課題＃2431を&lt;/a&gt;参照）。たとえば、次の2つの &lt;code&gt;absurd&lt;/code&gt; 候補の定義を考えてみます。</target>
        </trans-unit>
        <trans-unit id="21e78b74f477258018d7a7870e8af03b21095ae1" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">親切なポリモーフィズムを使用すると、Haskellプログラマーからは見えない可能性のある裏側の処理がかなり行われます。GHCは、エラーメッセージやGHCiプロンプトでのタイプの出力方法を制御するいくつかのフラグをサポートしています。詳細&lt;a href=&quot;using#pretty-printing-types&quot;&gt;については、タイププリティプリントオプション&lt;/a&gt;の説明を参照してください。種多様性を使用していて、GHCがプログラムを拒否（または受け入れ）する理由について混乱している場合は、これらのフラグ、特に&lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;をオンにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="69cd37ef3fe1623579439f2a0ea2d08874630d4e" translate="yes" xml:space="preserve">
          <source>With multiple modules in scope, especially multiple &lt;code&gt;*&lt;/code&gt;-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</source>
          <target state="translated">スコープ内に複数のモジュール、特に複数の &lt;code&gt;*&lt;/code&gt; フォームモジュールがあると、名前の衝突が発生する可能性があります。Haskellは、あいまいな識別子が使用された場合にのみ名前の衝突が報告され、GHCiはプロンプトで入力された式に対して同じように動作することを指定しています。</target>
        </trans-unit>
        <trans-unit id="d0493423cb33f94a9da912db9832c18dcdd8ec9d" translate="yes" xml:space="preserve">
          <source>With only 1 generation (e.g. &lt;code&gt;-G1&lt;/code&gt;, see &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt;&lt;code&gt;-G ⟨generations⟩&lt;/code&gt;&lt;/a&gt;) the &lt;code&gt;-A&lt;/code&gt; option specifies the minimum allocation area, since the actual size of the allocation area will be resized according to the amount of data in the heap (see &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;, below).</source>
          <target state="translated">わずか1世代と（例えば &lt;code&gt;-G1&lt;/code&gt; 、参照&lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt; &lt;code&gt;-G ⟨generations⟩&lt;/code&gt; &lt;/a&gt;） &lt;code&gt;-A&lt;/code&gt; の割当領域の実際のサイズは、ヒープ内のデータの量に応じてリサイズするためのオプションは、最小の割り当て領域を指定する（参照&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;以下の「ファクター」）。</target>
        </trans-unit>
        <trans-unit id="785aea24bc9e99119b7035e19ac075542c979030" translate="yes" xml:space="preserve">
          <source>With some exceptions (see below), the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials, by putting symbolic links (on Unix) in the place where the temporary file is to be created. On Unix the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags are used to prevent this attack, but note that &lt;code&gt;O_EXCL&lt;/code&gt; is sometimes not supported on NFS filesystems, so if you rely on this behaviour it is best to use local filesystems only.</source>
          <target state="translated">一部の例外を除いて（以下を参照）、ファイルは、攻撃者がopenTempFileに資格情報を使用してファイルシステム上の別のファイルを上書きさせることができないという意味で安全に作成されます。一時ファイルが作成されます。 Unixでは、 &lt;code&gt;O_CREAT&lt;/code&gt; フラグと &lt;code&gt;O_EXCL&lt;/code&gt; フラグを使用してこの攻撃を防止していますが、 &lt;code&gt;O_EXCL&lt;/code&gt; はNFSファイルシステムではサポートされない場合があるため、この動作に依存する場合はローカルファイルシステムのみを使用するのが最適です。</target>
        </trans-unit>
        <trans-unit id="a93509c3f999509299ef31391df84499497efcb8" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt;拡張機能により、GHCはこれらのペーパーの2番目で説明されている矢印表記をサポートし、&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;モジュールのコンビネーターを使用して変換します。以下は、表記法の簡単な紹介です。ヒューズの論文を読まない限り、あまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="6b570873f02bd59cb3d75af7817ea6c7ba50ea43" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt;拡張機能により、GHCは、これらのペーパーの2番目で説明されている矢印表記をサポートし、&lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;モジュールのコンビネータを使用して変換します。以下は、表記法の簡単な紹介です。ヒューズの論文を読まない限り、あまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="6f1c52b5955db050f2c09abaaf8b8f9460a4acba" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any &lt;em&gt;type&lt;/em&gt; of the new kind &lt;code&gt;Constraint&lt;/code&gt; can be used as a constraint. The following things have kind &lt;code&gt;Constraint&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#extension-ConstraintKinds&quot;&gt; &lt;code&gt;ConstraintKinds&lt;/code&gt; の&lt;/a&gt;延長、GHCは、それはあなたのプログラムに制約として受け入れるものの中でより自由になります。正確には、このフラグを使用すると、新しい種類の &lt;code&gt;Constraint&lt;/code&gt; の任意の&lt;em&gt;タイプ&lt;/em&gt;を制約として使用できます。次のような種類の &lt;code&gt;Constraint&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e1664518d009a52644be50176a94b39948aa07fe" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; extension, GHC lets you declare a data type with no constructors.</source>
          <target state="translated">&lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; の&lt;/a&gt;延長、GHCはあなたがいないコンストラクタを持つデータ型を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="86f5c1ba9a946fe63d6ee762808ace202ba1df31" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-PackageImports&quot;&gt;&lt;code&gt;PackageImports&lt;/code&gt;&lt;/a&gt; extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-PackageImports&quot;&gt; &lt;code&gt;PackageImports&lt;/code&gt; &lt;/a&gt;延長、GHCはimport宣言は、モジュールがから輸入されるように意図されていることを、パッケージ名で修飾することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="0081b5adf07c359a705bcc01d665e8bd9d05b630" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; の&lt;/a&gt;拡張子（&lt;a href=&quot;#universal-quantification&quot;&gt;字句が型変数をスコープ&lt;/a&gt;）、タイプの先頭以外の場所型の引数を宣言することが可能です。たとえば、 &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; 持つことができます。a-&amp;gt; forall b。b-&amp;gt;（a、b）次に、タイプ &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; &lt;code&gt;pair @Bool True @Char&lt;/code&gt; と言います。</target>
        </trans-unit>
        <trans-unit id="76eee139e346997f5c9c53bbb31187ae5e3574e1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt; extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; の&lt;/a&gt;延長、インスタンスヘッドは型シノニムを使用することができます。いつものように、型シノニムの使用は、型シノニム定義のRHSを記述するための単なる省略形です。例えば：</target>
        </trans-unit>
        <trans-unit id="dd64afd9c5cd942b81bb03eac59d62ba1c9175a3" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; language flags, GHC extends the import declaration syntax to take an optional &lt;code&gt;safe&lt;/code&gt; keyword after the &lt;code&gt;import&lt;/code&gt; keyword. This feature is part of the Safe Haskell GHC extension. For example:</source>
          <target state="translated">で&lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;言語フラグ、GHCはオプションで取るために輸入申告の構文拡張し &lt;code&gt;safe&lt;/code&gt; の後にキーワードを &lt;code&gt;import&lt;/code&gt; キーワードを。この機能は、Safe Haskell GHC拡張の一部です。例えば：</target>
        </trans-unit>
        <trans-unit id="86dce2a8a32edb642a5851fc037f97dda0e2a514" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; option, GHC can generate instances of the &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class automatically. For example, given the declaration</source>
          <target state="translated">&lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; オプション、GHCはのインスタンスを生成することができ &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; を自動的クラスを。たとえば、次の宣言があるとします。</target>
        </trans-unit>
        <trans-unit id="7061af1c2882d04c412d1f683d99f0149d64aa2b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;T&lt;/code&gt; example above, we could bind &lt;code&gt;k&lt;/code&gt;&lt;em&gt;after&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;; doing so would not violate dependency concerns. However, it would violate our general principle, and so &lt;code&gt;k&lt;/code&gt; comes first.</source>
          <target state="translated">上記の &lt;code&gt;T&lt;/code&gt; の例では &lt;code&gt;a&lt;/code&gt; &lt;em&gt;後に&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; をバインドできます。そうすることは依存関係の懸念に違反しません。ただし、これは一般的な原則に違反するため、 &lt;code&gt;k&lt;/code&gt; が最初に来ます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95a87e504b0a793e5fd58318fbc965d5cde726b1" translate="yes" xml:space="preserve">
          <source>With the declaration of &lt;code&gt;(:~~:)&lt;/code&gt; above, it gets kind &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt;. Thus, the type &lt;code&gt;(:~~:) a&lt;/code&gt; has kind &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt;. GHC cannot then &lt;em&gt;regeneralize&lt;/em&gt; this kind to become &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; as desired. Thus, the instance is rejected as ill-kinded.</source>
          <target state="translated">上記の &lt;code&gt;(:~~:)&lt;/code&gt; 宣言により、 &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt; 親切になります。k1-&amp;gt; k2-&amp;gt;タイプ。したがって、タイプ &lt;code&gt;(:~~:) a&lt;/code&gt; 種類は &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt; です。GHCは、することはできません&lt;em&gt;regeneralize&lt;/em&gt;になるために、この種の &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; 必要に応じて入力します。したがって、インスタンスは不適切なものとして拒否されます。</target>
        </trans-unit>
        <trans-unit id="8e9d7ae0964f2c8a37967ebdf7b51ca679bfce71" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</source>
          <target state="translated">&lt;a href=&quot;#constraint-kind&quot;&gt;一種の制約&lt;/a&gt;を追加する拡張機能を使用すると、よりエキゾチックなスーパークラス定義を作成できます。これらの場合、スーパークラスのサイクルチェックはさらに自由です。たとえば、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="c21ffce8c72ae9e80966f7f06bfe16bc1598f575" translate="yes" xml:space="preserve">
          <source>With the goal in mind to make &lt;code&gt;encode&lt;/code&gt; work on &lt;code&gt;Tree&lt;/code&gt; and other datatypes, we now define instances for the representation type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作るために心の中で目標に &lt;code&gt;encode&lt;/code&gt; の作業 &lt;code&gt;Tree&lt;/code&gt; や他のデータ型を、私たちは今、表現型のコンストラクタのインスタンスを定義 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5302a8fcd7027fe5fed3ca73b8eed7f9ceed1e24" translate="yes" xml:space="preserve">
          <source>With the improved kind of &lt;code&gt;Vec&lt;/code&gt;, things like &lt;code&gt;Vec Int Char&lt;/code&gt; are now ill-kinded, and GHC will report an error.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; の改良された種類により、 &lt;code&gt;Vec Int Char&lt;/code&gt; のようなものが不適切になり、GHCはエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="0aed3bcdd45e9d87e9c818064646efdefe64f958" translate="yes" xml:space="preserve">
          <source>With the language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; GHC lifts all restrictions on superclass constraints. If there really &lt;em&gt;is&lt;/em&gt; a loop, GHC will only expand it to finite depth.</source>
          <target state="translated">言語拡張&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; を&lt;/a&gt;使用すると、GHCはスーパークラスの制約に関するすべての制限を解除します。本当にループ&lt;em&gt;が&lt;/em&gt;ある場合、GHCはそれを有限の深さまで拡張するだけです。</target>
        </trans-unit>
        <trans-unit id="881f9aca2cbf94416a15c78d09c89a5e610b3cba" translate="yes" xml:space="preserve">
          <source>With this extension turned on, &lt;code&gt;static&lt;/code&gt; is no longer a valid identifier.</source>
          <target state="translated">この拡張機能をオンにすると、 &lt;code&gt;static&lt;/code&gt; は有効な識別子ではなくなります。</target>
        </trans-unit>
        <trans-unit id="3eae705dd30aa403e3959eddafb73fb5d53a286c" translate="yes" xml:space="preserve">
          <source>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</source>
          <target state="translated">このフラグを有効にすると、ブロック内の最後のジャンプ命令を使用します。このフラグがない場合、古いアルゴリズムでは、最も重い送信エッジも使用されます。</target>
        </trans-unit>
        <trans-unit id="b16f923b2bccb6268626a56190ac266418d2ee9a" translate="yes" xml:space="preserve">
          <source>With this form of the group statement, f is required to simply have the type &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt;, which will be used to group up the comprehension so far directly. An example of this form is as follows:</source>
          <target state="translated">この形式のグループステートメントでは、fは型 &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt; 持つ必要があります。[a]-&amp;gt; [[a]]は、これまでに理解度を直接グループ化するために使用されます。このフォームの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c1ca2feeac1b63c8b0e8b5d863d1efdb6417eb61" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">このマクロを &lt;code&gt;.ghci&lt;/code&gt; ファイルで定義すると、 &lt;code&gt;:source file&lt;/code&gt; を使用してfileからGHCiコマンドを読み取ることができ &lt;code&gt;file&lt;/code&gt; 。このHaskell wikiページで&lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;で &lt;code&gt;.ghci&lt;/code&gt; ファイルに関する他の提案を見つけて（そして貢献してください！）</target>
        </trans-unit>
        <trans-unit id="07b653d1a2bfaa93b0073e542432ee5c0e412c45" translate="yes" xml:space="preserve">
          <source>With typed expressions, the type error occurs when &lt;em&gt;constructing&lt;/em&gt; the Template Haskell expression:</source>
          <target state="translated">型付き式では、TemplateHaskell式を&lt;em&gt;作成&lt;/em&gt;するときに型エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="3c6c0ef956744d9c2875427c6662b77c5a888414" translate="yes" xml:space="preserve">
          <source>With zig-zag cuts.</source>
          <target state="translated">ジグザグカットで</target>
        </trans-unit>
        <trans-unit id="bc2f9125cc8c7112d9ada66985a127ec0ad4e915" translate="yes" xml:space="preserve">
          <source>Within reason, more memory for heap space means less garbage collection for GHC, which means less compilation time. If you use the &lt;code&gt;-Rghc-timing&lt;/code&gt; option, you&amp;rsquo;ll get a garbage-collector report. (Again, you can use the cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; option to send the GC stats straight to standard error.)</source>
          <target state="translated">理由の範囲内で、ヒープスペースのメモリが多いほど、GHCのガベージコレクションが少なくなるため、コンパイル時間が短くなります。 &lt;code&gt;-Rghc-timing&lt;/code&gt; オプションを使用すると、ガベージコレクターレポートが表示されます。（繰り返しになりますが、安価で厄介な &lt;code&gt;+RTS -S -RTS&lt;/code&gt; オプションを使用して、GC統計を標準エラーに直接送信できます。）</target>
        </trans-unit>
        <trans-unit id="8f47805e05322cd599bf35fe9faf060f5e73efd3" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">このモジュール内では、多くの関数が1つ以上の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値から &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; を構築します。これらの関数は、有効なUnicodeスカラー値ではない &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値を置換文字 &quot;&quot;（U + FFFD）に置き換えます。この検査と置換を実行する関数は、「無効なスカラー値で置換を実行する」という句で文書化されています。</target>
        </trans-unit>
        <trans-unit id="7908234217d5fcd634ff01a732e900f1963d7319" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">このモジュール内では、多くの関数が1つ以上の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値から &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; を作成します。これらの関数は、有効なUnicodeスカラー値ではない &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値を置換文字「 」（U + FFFD）に置き換えます。この検査と置換を実行する関数は、「無効なスカラー値で置換を実行する」というフレーズで文書化されています。</target>
        </trans-unit>
        <trans-unit id="dea0da7408cfec1901b2368ef703f2aecf1f6514" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">このモジュール内では、多くの関数が1つ以上の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値から &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; を構築します。これらの関数は、有効なUnicodeスカラー値ではない &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値を置換文字 &quot;&quot;（U + FFFD）に置き換えます。この検査と置換を実行する関数は、「無効なスカラー値で置換を実行する」という句で文書化されています。</target>
        </trans-unit>
        <trans-unit id="d2e478e972382d28cdc4d59b0f5b4e6ab5fe13da" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">このモジュール内では、多くの関数が1つ以上の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値から &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; を作成します。これらの関数は、有効なUnicodeスカラー値ではない &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 値を置換文字「 」（U + FFFD）に置き換えます。この検査と置換を実行する関数は、「無効なスカラー値で置換を実行する」というフレーズで文書化されています。</target>
        </trans-unit>
        <trans-unit id="d9dfb1e2314e140fc44280b93e374d8103a6bd88" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt;, an update mentioning &lt;code&gt;foo&lt;/code&gt; will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</source>
          <target state="translated">なければ&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;、更新言及 &lt;code&gt;foo&lt;/code&gt; がすべてのこれらの定義は、スコープにあった場合は常にあいまいになります。拡張機能が有効な場合、更新を明確にするためのいくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="cf558caacc962a4ce5708595b14947064e9202c7" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;, GHC refuses to generalise over kind variables. It thus defaults kind variables to &lt;code&gt;Type&lt;/code&gt; when possible; when this is not possible, an error is issued.</source>
          <target state="translated">&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; が&lt;/a&gt;ないと、GHCは種類変数を一般化することを拒否します。したがって、可能であれば、kind変数をデフォルトで &lt;code&gt;Type&lt;/code&gt; に設定します。これが不可能な場合、エラーが発行されます。</target>
        </trans-unit>
        <trans-unit id="2a9c3c68ec886ab1a40dbb182885c56e2b6ca831" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;#11679&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt;がない場合、これはリスト内包として解析されます。&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt;これは準引用符として解析されます。ただし、クロージングがないため、この解析は失敗します &lt;code&gt;|]&lt;/code&gt; 。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;＃11679を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5845f382c175f98b7eb91c01c1ee5f311d078978" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Issue #11679&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt;がない場合、これはリスト内包として解析されます。&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt;これは準引用符として解析されます。ただし、この構文解析は、閉じられないために失敗します &lt;code&gt;|]&lt;/code&gt; 。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;課題＃11679を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3f3724a985619b98c0ad7733af9c670b7ea356bd" translate="yes" xml:space="preserve">
          <source>Without a &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, your &lt;code&gt;SCC&lt;/code&gt;s are ignored; so you can compile &lt;code&gt;SCC&lt;/code&gt;-laden code without changing it.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;オプションがない場合、 &lt;code&gt;SCC&lt;/code&gt; は無視されます。したがって、 &lt;code&gt;SCC&lt;/code&gt; を含むコードを変更せずにコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="7b93607420f6e329b78506ca570d35577aad1878" translate="yes" xml:space="preserve">
          <source>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</source>
          <target state="translated">引数を指定しない場合、プロンプトで入力された式やコマンドに適用されるオプションの現在のセットを表示します。</target>
        </trans-unit>
        <trans-unit id="6afd1c5d24d0c6ba28deb9777974788c74c647b1" translate="yes" xml:space="preserve">
          <source>Without lifting a finger, the &lt;code&gt;?cmp&lt;/code&gt; parameter is propagated to become a parameter of &lt;code&gt;least&lt;/code&gt; as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</source>
          <target state="translated">指を &lt;code&gt;?cmp&lt;/code&gt; ことなく、？cmpパラメーターは伝搬され、 &lt;code&gt;least&lt;/code&gt; パラメーターになります。明示的なパラメーターの場合、デフォルトでは、パラメーターは常に明示的に伝搬される必要があります。暗黙的なパラメーターを使用する場合、デフォルトでは常にそれらが伝搬されます。</target>
        </trans-unit>
        <trans-unit id="b0f92d9fa8c76be5e794944834d2ec86a2772775" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;MINIMAL&lt;/code&gt; pragma no warning would be generated for an instance that implements neither method.</source>
          <target state="translated">&lt;code&gt;MINIMAL&lt;/code&gt; プラグマがなければ、どちらのメソッドも実装していないインスタンスに対して警告は生成されません。</target>
        </trans-unit>
        <trans-unit id="50d9f1e1cbc21e6ec9dc165a0f7dae51d3263314" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;forall b&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; would be quantified over the whole instance declaration, which is not what is intended.</source>
          <target state="translated">&lt;code&gt;forall b&lt;/code&gt; がなければ、型変数 &lt;code&gt;b&lt;/code&gt; はインスタンス宣言全体で数量化されますが、これは意図されたものではありません。</target>
        </trans-unit>
        <trans-unit id="d93b93f4b6fa3889a10d8fc5065716508c9b410a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;pattern&lt;/code&gt; prefix, &lt;code&gt;Zero&lt;/code&gt; would be interpreted as a type constructor in the export list.</source>
          <target state="translated">なければ &lt;code&gt;pattern&lt;/code&gt; のプレフィックス、 &lt;code&gt;Zero&lt;/code&gt; エクスポートリストで型コンストラクタとして解釈されるだろう。</target>
        </trans-unit>
        <trans-unit id="8529406902d1abcacd9905fe51002c24837c1b9f" translate="yes" xml:space="preserve">
          <source>Witness for an unboxed &lt;code&gt;Proxy#&lt;/code&gt; value, which has no runtime representation.</source>
          <target state="translated">ランタイム表現がないボックス化されていない &lt;code&gt;Proxy#&lt;/code&gt; 値の目撃者。</target>
        </trans-unit>
        <trans-unit id="610f9340ef73da170fe3d746b635b1e322839287" translate="yes" xml:space="preserve">
          <source>Witness the trail of destruction:</source>
          <target state="translated">破壊の軌跡を目撃してください。</target>
        </trans-unit>
        <trans-unit id="44363ccb8230b892c5ab09c35a02a4ea41ff9976" translate="yes" xml:space="preserve">
          <source>Word</source>
          <target state="translated">Word</target>
        </trans-unit>
        <trans-unit id="d5483c905b6d49a4bb959ca289af138ba2e3974b" translate="yes" xml:space="preserve">
          <source>Word completion</source>
          <target state="translated">ワード補完</target>
        </trans-unit>
        <trans-unit id="ebec3f021b32b6cc5c3702fa2014aacc63a489c8" translate="yes" xml:space="preserve">
          <source>Word#</source>
          <target state="translated">Word#</target>
        </trans-unit>
        <trans-unit id="6a84434113170dd2196183223a37fdceb55ba2fb" translate="yes" xml:space="preserve">
          <source>Word16</source>
          <target state="translated">Word16</target>
        </trans-unit>
        <trans-unit id="47cfcc5721eb7b6a68e503b7664fe5da8cc042b7" translate="yes" xml:space="preserve">
          <source>Word16#</source>
          <target state="translated">Word16#</target>
        </trans-unit>
        <trans-unit id="c3be769dd2ec4a171cda42ade7fe290e55320847" translate="yes" xml:space="preserve">
          <source>Word16ElemRep</source>
          <target state="translated">Word16ElemRep</target>
        </trans-unit>
        <trans-unit id="6e4a4a97ad2c84568dfc9c970956cd5aea4291f3" translate="yes" xml:space="preserve">
          <source>Word16Rep</source>
          <target state="translated">Word16Rep</target>
        </trans-unit>
        <trans-unit id="27d33d7ad79bddbd9198dbf60544ea0a5922ab2d" translate="yes" xml:space="preserve">
          <source>Word16X16#</source>
          <target state="translated">Word16X16#</target>
        </trans-unit>
        <trans-unit id="581ced5045f9589c18eb6b89774a5edb7cf18907" translate="yes" xml:space="preserve">
          <source>Word16X32#</source>
          <target state="translated">Word16X32#</target>
        </trans-unit>
        <trans-unit id="cb0fa55002540cd66201e78dd2a473b775807583" translate="yes" xml:space="preserve">
          <source>Word16X8#</source>
          <target state="translated">Word16X8#</target>
        </trans-unit>
        <trans-unit id="ca9cf535ecc0d6f9c09f163d1eace0c0b75e14df" translate="yes" xml:space="preserve">
          <source>Word32</source>
          <target state="translated">Word32</target>
        </trans-unit>
        <trans-unit id="a933b159a6b2cb61c00b71e8591eb2ee110f8728" translate="yes" xml:space="preserve">
          <source>Word32#</source>
          <target state="translated">Word32#</target>
        </trans-unit>
        <trans-unit id="399b80b5d6a6df00939198146bfa201fbcfcb514" translate="yes" xml:space="preserve">
          <source>Word32ElemRep</source>
          <target state="translated">Word32ElemRep</target>
        </trans-unit>
        <trans-unit id="70a7003c530361b27dbad2666f3119f63d7aa52c" translate="yes" xml:space="preserve">
          <source>Word32Rep</source>
          <target state="translated">Word32Rep</target>
        </trans-unit>
        <trans-unit id="bb69aca3ee85ff65d670de320b3a0722f77e6a2c" translate="yes" xml:space="preserve">
          <source>Word32X16#</source>
          <target state="translated">Word32X16#</target>
        </trans-unit>
        <trans-unit id="8243c948dcd7f5412910c04096e56d0136dac05a" translate="yes" xml:space="preserve">
          <source>Word32X4#</source>
          <target state="translated">Word32X4#</target>
        </trans-unit>
        <trans-unit id="b142d249e87e96429320d524a3b07bd2246dd820" translate="yes" xml:space="preserve">
          <source>Word32X8#</source>
          <target state="translated">Word32X8#</target>
        </trans-unit>
        <trans-unit id="8a1457858cb6a778826be1ec52c62538bb952ff7" translate="yes" xml:space="preserve">
          <source>Word64</source>
          <target state="translated">Word64</target>
        </trans-unit>
        <trans-unit id="8530200a24dcfbd549467b756af592d29de90c98" translate="yes" xml:space="preserve">
          <source>Word64#</source>
          <target state="translated">Word64#</target>
        </trans-unit>
        <trans-unit id="5346b71b27abd762c16882d8503921d915a9b596" translate="yes" xml:space="preserve">
          <source>Word64ElemRep</source>
          <target state="translated">Word64ElemRep</target>
        </trans-unit>
        <trans-unit id="ad9de82091d9f5be6f70404a7f6ea77db4515661" translate="yes" xml:space="preserve">
          <source>Word64Rep</source>
          <target state="translated">Word64Rep</target>
        </trans-unit>
        <trans-unit id="0bf4e17ceba7b29f9db8d40fc30978cabad5b2e3" translate="yes" xml:space="preserve">
          <source>Word64X2#</source>
          <target state="translated">Word64X2#</target>
        </trans-unit>
        <trans-unit id="f30283a81aeb4836e2239aa4b4f88d036171e15d" translate="yes" xml:space="preserve">
          <source>Word64X4#</source>
          <target state="translated">Word64X4#</target>
        </trans-unit>
        <trans-unit id="6df564da800ea9db332a4e4f70ac3b7baee68108" translate="yes" xml:space="preserve">
          <source>Word64X8#</source>
          <target state="translated">Word64X8#</target>
        </trans-unit>
        <trans-unit id="7d4f09dfc217ef6de83fd0a7817a34a9c524f5f8" translate="yes" xml:space="preserve">
          <source>Word8</source>
          <target state="translated">Word8</target>
        </trans-unit>
        <trans-unit id="1026530b7f2b7d11ceed950f769ae8af9db41c6d" translate="yes" xml:space="preserve">
          <source>Word8#</source>
          <target state="translated">Word8#</target>
        </trans-unit>
        <trans-unit id="46fa1330e06c95858d3c751456971104c43240e6" translate="yes" xml:space="preserve">
          <source>Word8ElemRep</source>
          <target state="translated">Word8ElemRep</target>
        </trans-unit>
        <trans-unit id="bb25378aca5d0bf9417565eddafe0c9955fced88" translate="yes" xml:space="preserve">
          <source>Word8Rep</source>
          <target state="translated">Word8Rep</target>
        </trans-unit>
        <trans-unit id="6d9c171610680a48a7e1adce25e5ef2175c1786b" translate="yes" xml:space="preserve">
          <source>Word8X16#</source>
          <target state="translated">Word8X16#</target>
        </trans-unit>
        <trans-unit id="7d2b3864aa2a328b268de16ec90a676d025166df" translate="yes" xml:space="preserve">
          <source>Word8X32#</source>
          <target state="translated">Word8X32#</target>
        </trans-unit>
        <trans-unit id="420bed9409614065e79233ee278151c88a99c07c" translate="yes" xml:space="preserve">
          <source>Word8X64#</source>
          <target state="translated">Word8X64#</target>
        </trans-unit>
        <trans-unit id="84c6a57a62c9a723bc4c3a3bbe6ffc9a885219d9" translate="yes" xml:space="preserve">
          <source>WordPtr</source>
          <target state="translated">WordPtr</target>
        </trans-unit>
        <trans-unit id="68dc8baeafc9a279622fb5e31be3ed83d95357da" translate="yes" xml:space="preserve">
          <source>WordRep</source>
          <target state="translated">WordRep</target>
        </trans-unit>
        <trans-unit id="7ba9e8f41622b0ccfc835a4f2140ab6eea7b7e9b" translate="yes" xml:space="preserve">
          <source>Work left-to-right through the input list of type variables, with a cursor.</source>
          <target state="translated">カーソルを使って、型変数の入力リストを左から右に移動します。</target>
        </trans-unit>
        <trans-unit id="bc1c455e1b31ed1393785a6cdc3045bbb118f243" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell 98インスタンスの &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を使用できるようにするための回避策。</target>
        </trans-unit>
        <trans-unit id="9c02809968c5a04b4bf0b6d24112481a63ca6dca" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Haskell98インスタンスの &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 持つことができるようにするための回避策。</target>
        </trans-unit>
        <trans-unit id="5ab49cd9ef02b20b8f0a395f52a3bac5f961ae20" translate="yes" xml:space="preserve">
          <source>Worker-wrapper removes unused arguments, but usually we do not remove them all, lest it turn a function closure into a thunk, thereby perhaps creating a space leak and/or disrupting inlining. This flag allows worker/wrapper to remove &lt;em&gt;all&lt;/em&gt; value lambdas.</source>
          <target state="translated">Worker-wrapperは未使用の引数を削除しますが、関数のクロージャをサンクに変換しないように、通常はすべてを削除しません。これにより、スペースリークが発生したり、インライン化が中断したりする可能性があります。このフラグにより​​、ワーカー/ラッパーは&lt;em&gt;すべての&lt;/em&gt;値のラムダを削除&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="61f4d4dd918269bf5a5ff69500737f2e3c652d80" translate="yes" xml:space="preserve">
          <source>Working with equality</source>
          <target state="translated">平等に働く</target>
        </trans-unit>
        <trans-unit id="b7851eadac070ddfea609696fdeb164b7899ebe8" translate="yes" xml:space="preserve">
          <source>Would result in a generated &lt;code&gt;Functor&lt;/code&gt; instance like so:</source>
          <target state="translated">結果として、次のような &lt;code&gt;Functor&lt;/code&gt; インスタンスが生成されます。</target>
        </trans-unit>
        <trans-unit id="6ee562876821329b8991ff4daaadbf4f98ef9b98" translate="yes" xml:space="preserve">
          <source>Wrap a BCO in a &lt;code&gt;AP_UPD&lt;/code&gt; thunk which will be updated with the value of the BCO when evaluated.</source>
          <target state="translated">評価時にBCOの値で更新される &lt;code&gt;AP_UPD&lt;/code&gt; サンクにBCOをラップします。</target>
        </trans-unit>
        <trans-unit id="16397dd6317efa9c9836ee42453758565f8d25ed" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; マイクロ秒（1/10 &lt;code&gt;1/10^6&lt;/code&gt; 秒）内に結果が得られない場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算をラップしてタイムアウトし、 &lt;code&gt;Nothing&lt;/code&gt; を返します。タイムアウトになる前に結果が利用できる場合は、 &lt;code&gt;Just a&lt;/code&gt; が返されます。負のタイムアウト間隔は、「無期限に待機する」ことを意味します。長いタイムアウトを指定するときは、 &lt;code&gt;maxBound :: Int&lt;/code&gt; を超えないように注意してください。</target>
        </trans-unit>
        <trans-unit id="298bd3ed150b3f0eda86e3bd26b9d517dfc0dc76" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算をラップしてタイムアウトし、 &lt;code&gt;n&lt;/code&gt; マイクロ秒（1/10 &lt;code&gt;1/10^6&lt;/code&gt; 秒）以内に結果が得られない場合は &lt;code&gt;Nothing&lt;/code&gt; を返します。タイムアウトが切れる前に結果が利用できる場合は、a &lt;code&gt;Just a&lt;/code&gt; が返されます。負のタイムアウト間隔は、「無期限に待機する」ことを意味します。長いタイムアウトを指定するときは、 &lt;code&gt;maxBound :: Int&lt;/code&gt; を超えないように注意してください。</target>
        </trans-unit>
        <trans-unit id="769d436eab4aa870cf748d72592199f75a9fdf28" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; マイクロ秒（1/10 &lt;code&gt;1/10^6&lt;/code&gt; 秒）内に結果が得られない場合は、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算をラップしてタイムアウトし、 &lt;code&gt;Nothing&lt;/code&gt; を返します。タイムアウトになる前に結果が利用できる場合は、 &lt;code&gt;Just a&lt;/code&gt; が返されます。負のタイムアウト間隔は、「無期限に待機する」ことを意味します。長いタイムアウトを指定するときは、 &lt;code&gt;maxBound :: Int&lt;/code&gt; を超えないように注意してください。</target>
        </trans-unit>
        <trans-unit id="052e52e2ec601e51ff67cce14d06f664e23dd732" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;&quot;...&quot;&lt;/code&gt;</source>
          <target state="translated">ドキュメントを &lt;code&gt;&quot;...&quot;&lt;/code&gt; で囲む</target>
        </trans-unit>
        <trans-unit id="3e2463a3964a6d5f90893a0cb4a83e415f58109e" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;'...'&lt;/code&gt;</source>
          <target state="translated">ドキュメントを &lt;code&gt;'...'&lt;/code&gt; で囲む</target>
        </trans-unit>
        <trans-unit id="e11d85c98f81ceac1c15ffeb3554f6ef50d942c9" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;(...)&lt;/code&gt;</source>
          <target state="translated">ドキュメントを &lt;code&gt;(...)&lt;/code&gt; で囲む</target>
        </trans-unit>
        <trans-unit id="fefcdd75b8d3ceac5767fa9ddb3485c2fae7387b" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;[...]&lt;/code&gt;</source>
          <target state="translated">ドキュメントを &lt;code&gt;[...]&lt;/code&gt; で囲む</target>
        </trans-unit>
        <trans-unit id="2d9a81e67b5bd2bc5cede4830f07d4ee5769499a" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;{...}&lt;/code&gt;</source>
          <target state="translated">文書を &lt;code&gt;{...}&lt;/code&gt; で囲む</target>
        </trans-unit>
        <trans-unit id="b5150dc051fd47e830d39a1a10a0d5cede823b6b" translate="yes" xml:space="preserve">
          <source>WrapArrow</source>
          <target state="translated">WrapArrow</target>
        </trans-unit>
        <trans-unit id="c92147ea0c2b0677b7c09751757b19d07bd7b17c" translate="yes" xml:space="preserve">
          <source>WrapMonad</source>
          <target state="translated">WrapMonad</target>
        </trans-unit>
        <trans-unit id="4069d5a8b2d61fc44c53d1d69a1603e75124fe55" translate="yes" xml:space="preserve">
          <source>WrapMonoid</source>
          <target state="translated">WrapMonoid</target>
        </trans-unit>
        <trans-unit id="f72344941ecf4dbf3a6b05f7d128cba499a51fde" translate="yes" xml:space="preserve">
          <source>WrappedArrow</source>
          <target state="translated">WrappedArrow</target>
        </trans-unit>
        <trans-unit id="5424268dd193f61b9e7843ef4109dc2a12bac7a6" translate="yes" xml:space="preserve">
          <source>WrappedMonad</source>
          <target state="translated">WrappedMonad</target>
        </trans-unit>
        <trans-unit id="459140ee141c9d01be26238b973ae1046e530be2" translate="yes" xml:space="preserve">
          <source>WrappedMonoid</source>
          <target state="translated">WrappedMonoid</target>
        </trans-unit>
        <trans-unit id="fb18f208c8e09b8e152ee97be9d763608b85aabc" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">GHCの実装を高速化した &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; のラッパー</target>
        </trans-unit>
        <trans-unit id="f5bae4c947473ab2febca5eb61bfa9da65f60ac7" translate="yes" xml:space="preserve">
          <source>Wrapping an IO action that can throw an error &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">エラー &lt;code&gt;e&lt;/code&gt; をスローする可能性のあるIOアクションをラップする：</target>
        </trans-unit>
        <trans-unit id="0d27d9e2d3a2ad251d4892a773947e707db18720" translate="yes" xml:space="preserve">
          <source>Wrapping documents in delimiters</source>
          <target state="translated">区切り文字での文書のラッピング</target>
        </trans-unit>
        <trans-unit id="48606f4bb9cb6f76c6d45f0aae55cb4f7a999651" translate="yes" xml:space="preserve">
          <source>Write 31-bit character; offset in 4-byte words.</source>
          <target state="translated">31 ビットの文字を書き込む。</target>
        </trans-unit>
        <trans-unit id="132823a14fa0074e9c3549c122a220890e54d9b3" translate="yes" xml:space="preserve">
          <source>Write 8-bit character; offset in bytes.</source>
          <target state="translated">8 ビット文字を書き込む。</target>
        </trans-unit>
        <trans-unit id="6cfb95525e855d3c2fb90f553acacc9ffd9b1afe" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; をバッファに書き込む</target>
        </trans-unit>
        <trans-unit id="a30ef0a4dea3adbd954b944a856f0d73077a7fef" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">&lt;code&gt;.tix&lt;/code&gt; ファイルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="2384eda70bde5fbafcdce06c7083ad1f34fba13d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">ロケールエンコーディングを使用して &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="641fdc517a3a148a3426445c3e2501afc543647f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ビッグエンディアンIEEE-754形式で。</target>
        </trans-unit>
        <trans-unit id="19f5831180b0536c875f7fde0710ba2f6b629a3f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; リトルエンディアンIEEE-754形式で。</target>
        </trans-unit>
        <trans-unit id="993b7cc9e4c74d2721eedc685664742cc7c82795" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">ライト &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; IEEE-754形式とホストエンディアンにネイティブでは。</target>
        </trans-unit>
        <trans-unit id="025b69c4396276807676b294d74b3b70f46bef94" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; ビッグエンディアンIEEE-754形式のを。</target>
        </trans-unit>
        <trans-unit id="2300f23523bc1b33ccbbebf657381c02dd05c86c" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; リトルエンディアンIEEE-754形式のを。</target>
        </trans-unit>
        <trans-unit id="9a6e3e08979b85f7f159802afa8ee51f8a4eedd1" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; IEEE-754形式とホストエンディアンにネイティブでは。</target>
        </trans-unit>
        <trans-unit id="100ddab2dd798658dd4fbb44584d4757dded426e" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">ロケールエンコーディングを使用して &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="34cb939ce09480dcfa16a616504013b186c6decd" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ビッグエンディアンIEEE-754形式で。</target>
        </trans-unit>
        <trans-unit id="17ec2c319cd8c0e2c3a0c3951b37ec1585cee156" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; リトルエンディアンIEEE-754形式で。</target>
        </trans-unit>
        <trans-unit id="545e766b627e659fd52bff3acf015eb9994ae5c5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">ライト &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; IEEE-754形式とホストエンディアンにネイティブでは。</target>
        </trans-unit>
        <trans-unit id="f65b44a7ea8883932f7651be10c9246fc522dca8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; ビッグエンディアンIEEE-754形式のを。</target>
        </trans-unit>
        <trans-unit id="ead3e3f2656945a589c0165356d2eb079e613140" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; リトルエンディアンIEEE-754形式のを。</target>
        </trans-unit>
        <trans-unit id="b2feadbf9adb1a358b7e0093340ebf583af8879d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">書く &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; IEEE-754形式とホストエンディアンにネイティブでは。</target>
        </trans-unit>
        <trans-unit id="59ed5c3f805685b995398b8616a908c0066ad70a" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="ca463eab69a5fff98e0ab2e75dce7ed014b9ab1b" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="3ad21d75c6a544747e2e36fcec12a87a1aebe727" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="a8e6f690eb143ffdbea5335db0be7244660876a2" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="244e830bbe30fb0c3258c35cfc26647f07415c80" translate="yes" xml:space="preserve">
          <source>Write a ByteString to a handle, appending a newline byte</source>
          <target state="translated">ハンドルにByteStringを書き込み、改行バイトを追加します。</target>
        </trans-unit>
        <trans-unit id="a70a82a5347cdeed11b696c9567115f30a6a5296" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout</source>
          <target state="translated">stdoutにByteStringを書き込む</target>
        </trans-unit>
        <trans-unit id="e8ad66b8476a9e49cc072f07250605c906e95e94" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout, appending a newline byte</source>
          <target state="translated">改行バイトを付加した ByteString を標準出力に書き込みます。</target>
        </trans-unit>
        <trans-unit id="c0c3cc8f4573e40e62c43e8422d4118f97ea3fea" translate="yes" xml:space="preserve">
          <source>Write a Int16 in big endian format</source>
          <target state="translated">Int16をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="9d73a70f9f179a81035be58cee26e559014c575a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in little endian format</source>
          <target state="translated">リトルエンディアン形式でInt16を書く</target>
        </trans-unit>
        <trans-unit id="7d8b2b4323c44fde9919abbfb9988c387020100a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">Int16をネイティブホスト順、ホストエンディアンで書き込みます。アラインメントされていない2バイトが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="fb3123d3e54a5bdf6aa5b4391bbf7b28df79fb37" translate="yes" xml:space="preserve">
          <source>Write a Int32 in big endian format</source>
          <target state="translated">Int32をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="7e919ad40c1b9ea38485684cbf74d8a9568b9af7" translate="yes" xml:space="preserve">
          <source>Write a Int32 in little endian format</source>
          <target state="translated">リトルエンディアン形式でInt32を書く</target>
        </trans-unit>
        <trans-unit id="c8c3c578503e8e7468915f61ff1fa6751340cce3" translate="yes" xml:space="preserve">
          <source>Write a Int32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">ホストのネイティブ順、ホストのエンディアンでInt32を書き込みます。アラインメントされていない4バイトが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="b4e181d3a02580a355986a71c12d4507242968cf" translate="yes" xml:space="preserve">
          <source>Write a Int64 in big endian format</source>
          <target state="translated">Int64をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="6a15b266b9877bbd729c40ccb87aa3db359c9f58" translate="yes" xml:space="preserve">
          <source>Write a Int64 in little endian format</source>
          <target state="translated">リトルエンディアン形式でInt64を書く</target>
        </trans-unit>
        <trans-unit id="001b75a9a615fe6648502bcfe94fd2920ba86af5" translate="yes" xml:space="preserve">
          <source>Write a Int64 in native host order. On a 32 bit machine we write two host order Int32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">ネイティブホスト順のInt64を書きます。32ビットマシンでは、2つのホストオーダーのInt32をビッグエンディアン形式で書きます。8 バイトがアラインメントされていない状態で書き込まれます。</target>
        </trans-unit>
        <trans-unit id="50fde014dba0a50360d764d6c2704238d9a9cb90" translate="yes" xml:space="preserve">
          <source>Write a String using UTF-8 encoding.</source>
          <target state="translated">UTF-8エンコーディングで文字列を記述します。</target>
        </trans-unit>
        <trans-unit id="ca1a04969f07426c1e00b1b3766e301003971851" translate="yes" xml:space="preserve">
          <source>Write a Unicode string to the user's standard output.</source>
          <target state="translated">ユーザの標準出力にUnicode文字列を書き込む。</target>
        </trans-unit>
        <trans-unit id="de13c62099cbcafc759fb5510fbb414e0c611d13" translate="yes" xml:space="preserve">
          <source>Write a Word16 in big endian format</source>
          <target state="translated">Word16をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="1d3480abbd86fc7688fd650a23916c935ed2b876" translate="yes" xml:space="preserve">
          <source>Write a Word16 in little endian format</source>
          <target state="translated">Word16をリトルエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="374953a98335b9e84fa5e0a4c035b46b2a892799" translate="yes" xml:space="preserve">
          <source>Write a Word16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">Word16をネイティブホスト順、ホストエンディアンで書き込みます。アラインメントされていない2バイトが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="b1d543a7902bc6e8e15046b66cf37db05811d00c" translate="yes" xml:space="preserve">
          <source>Write a Word32 in big endian format</source>
          <target state="translated">Word32をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="426bab66f99e758605e62a76ce97b5ce1321c0e7" translate="yes" xml:space="preserve">
          <source>Write a Word32 in little endian format</source>
          <target state="translated">リトルエンディアン形式でWord32を書く</target>
        </trans-unit>
        <trans-unit id="22533b04aaf4738c420c7810c743da18ca10d4e0" translate="yes" xml:space="preserve">
          <source>Write a Word32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">Word32をネイティブホスト順、ホストエンディアンで書き込みます。4バイトが書き込まれ、整列されていない状態になります。</target>
        </trans-unit>
        <trans-unit id="d00bd933478ce30ee3627449becbce383505e676" translate="yes" xml:space="preserve">
          <source>Write a Word64 in big endian format</source>
          <target state="translated">Word64をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="1ccded859c25705e9ae2dccba946964f2b4b599e" translate="yes" xml:space="preserve">
          <source>Write a Word64 in little endian format</source>
          <target state="translated">Word64をリトルエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="fe8b5771af7a4fe3ab30f772b71da7013250ca90" translate="yes" xml:space="preserve">
          <source>Write a Word64 in native host order. On a 32 bit machine we write two host order Word32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">Word64をネイティブホスト順で書きます。32ビットマシンでは、2つのホスト順のWord32をビッグエンディアン形式で書きます。8バイトがアラインメントされずに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="d084d0a0a3ee70356c669bbf84781436e439ab8d" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">指定されたオフセットで配列に文字を書き込みます。書き込まれた &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の数を返します。</target>
        </trans-unit>
        <trans-unit id="841f4e3a7f9355477f1154322e4d479f881e0fd9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">指定されたオフセットで配列に文字を書き込みます。書き込まれた &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の数を返します。</target>
        </trans-unit>
        <trans-unit id="824db4935989674b3e285858238d002d124cd8b6" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">標準出力デバイスに文字を書き込みます（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; と同じ）。</target>
        </trans-unit>
        <trans-unit id="f3d825454d2db1c3d3f226a28bb4ebdfec603097" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">標準出力デバイスに文字を書き込みます（ &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; と同じ）。</target>
        </trans-unit>
        <trans-unit id="955d70d1572c0c0ab9646927bdac5ea547ae35f8" translate="yes" xml:space="preserve">
          <source>Write a character using UTF-8 encoding.</source>
          <target state="translated">UTF-8エンコーディングで文字を書く。</target>
        </trans-unit>
        <trans-unit id="0a40d25653018769760da200e171fb69042b97ba" translate="yes" xml:space="preserve">
          <source>Write a floating point value to a &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; に浮動小数点値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="6f0e537457e84f16fbaa39fa0827e8c740824c36" translate="yes" xml:space="preserve">
          <source>Write a lazy ByteString efficiently, simply appending the lazy ByteString chunks to the output buffer</source>
          <target state="translated">遅延ByteStringチャンクを出力バッファに追加するだけで、遅延ByteStringを効率的に書き込みます。</target>
        </trans-unit>
        <trans-unit id="4a5a6f538364d52e8d401c4fc9299b67f51eb2c1" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">保存可能な要素のリストを、新しく割り当てられた、保存可能な値の連続したシーケンスに書き込みます（ &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; と同様ですが、複数の要素に対して）。</target>
        </trans-unit>
        <trans-unit id="cdf3a3bd7d79bb717fec0614e932a3f554e7d129" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values, where the end is fixed by the given end marker</source>
          <target state="translated">格納可能な要素のリストを、新たに割り当てられた格納可能な値の連続したシーケンスに書き込みます。</target>
        </trans-unit>
        <trans-unit id="46dde6be964e98cc511af24b16c6e57e81e0249e" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい値を &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; に書き込む</target>
        </trans-unit>
        <trans-unit id="ded1b880637c536601d5622865a8ac5bee12d73f" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; に新しい値を書き込む</target>
        </trans-unit>
        <trans-unit id="7b15bee858199106a92ca21868dcf92516cce78a" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい値を &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; に書き込む</target>
        </trans-unit>
        <trans-unit id="cfd1ae109907abef00a2e666c2fb353f397524eb" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい値を &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; に書き込む</target>
        </trans-unit>
        <trans-unit id="a0bbd3fd99a0c8ca169dc0a0800f474e5f53bf14" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; に新しい値を書き込む</target>
        </trans-unit>
        <trans-unit id="4a779d08a6f4043a50272816a75acd9ee4cacd4c" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい値を &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; に書き込む</target>
        </trans-unit>
        <trans-unit id="20f4593948df5a33a2e433f875c4b3f08e697cff" translate="yes" xml:space="preserve">
          <source>Write a string the end of a file.</source>
          <target state="translated">ファイルの末尾に文字列を書きます。</target>
        </trans-unit>
        <trans-unit id="c180f2e1d927a73773a56afa0d7e8518dedba44e" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">文字列を &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; に書き込んでから改行します。</target>
        </trans-unit>
        <trans-unit id="f7e8eefc7a202ba520c173df9a961b393fa4acc7" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">文字列を &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="a9f730ea108860688ef12de2017ea9ad535914f4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; に文字列を書き込み、その後に改行を続けます。</target>
        </trans-unit>
        <trans-unit id="45c0c99c259a0bae8a5de169024806ed9278e047" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; に文字列を書き込みます。</target>
        </trans-unit>
        <trans-unit id="7142ba8529e9f3798882070ee18b16fa9830450d" translate="yes" xml:space="preserve">
          <source>Write a string to a file. The file is truncated to zero length before writing begins.</source>
          <target state="translated">ファイルに文字列を書き込む。書き込みを開始する前に、ファイルは長さ0に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="1c2990ff65d290d7bbb87a7564d0e4e76c8f8255" translate="yes" xml:space="preserve">
          <source>Write a string to a handle, followed by a newline.</source>
          <target state="translated">ハンドルに文字列を書き、その後に改行を加えます。</target>
        </trans-unit>
        <trans-unit id="bd7a02731ecdcdf45341edba546df5ac23933c67" translate="yes" xml:space="preserve">
          <source>Write a string to a handle.</source>
          <target state="translated">ハンドルに文字列を書き込みます。</target>
        </trans-unit>
        <trans-unit id="ece9511f02a82892ce27b96dda3476e25a7fbdb9" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">文字列を標準出力デバイスに書き込みます（ &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; と同じ）。</target>
        </trans-unit>
        <trans-unit id="ffa575f023b590cb0185153c4e3bb7bcdf3ca8ca" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">文字列を標準出力デバイスに書き込みます（ &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; と同じ）。</target>
        </trans-unit>
        <trans-unit id="9ddf3308755406ffab4fefd34e1c0f532c36bfca" translate="yes" xml:space="preserve">
          <source>Write a string to the user's standard output, followed by a newline.</source>
          <target state="translated">ユーザーの標準出力に文字列を書き、その後に改行を加えます。</target>
        </trans-unit>
        <trans-unit id="d649865e90fcbff9ffe50b1a59105ee5172bcad2" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; に値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="9bb0e77531d8dd5855a5dee42f98bdfb66dea502" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;; blocks if the queue is full.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; に値を書き込みます。キューがいっぱいの場合はブロックします。</target>
        </trans-unit>
        <trans-unit id="9b880d3a6f95fb0643f6f8cb86d9febe4b457c2d" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; に値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="502f2a89fe6ab954ea36d4a5f5ae4da0588aaadf" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; に値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b003c4b3a259d538a4ba6bcb5c8dd4f54a8c348a" translate="yes" xml:space="preserve">
          <source>Write a value to a memory area regarded as an array of values of the same kind. The following equality holds:</source>
          <target state="translated">同じ種類の値の配列とみなされるメモリ領域に値を書き込む。次の等式が成り立つ。</target>
        </trans-unit>
        <trans-unit id="2278658d6c531603ea71643e435890480712f25e" translate="yes" xml:space="preserve">
          <source>Write a value to a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">ベースアドレスとオフセットで与えられたメモリの場所に値を書き込む。次の等式が成り立ちます。</target>
        </trans-unit>
        <trans-unit id="d2bcb5f72dff224c65e70a09f3049dbb8677df2f" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">スカラーの可変配列の指定されたインデックスにベクトルを書き込みます.</target>
        </trans-unit>
        <trans-unit id="47fbcdcf5427d81f8e800b2a3be52a9b2780f1f2" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array.</source>
          <target state="translated">変形可能な配列の指定されたインデックスにベクトルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="2cbdaab506338b440edffc79752d43d3b372babf" translate="yes" xml:space="preserve">
          <source>Write an Int16 in big endian format</source>
          <target state="translated">Int16をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="a4e76ca260148b04e485fd2b3ab9435bef6ca68d" translate="yes" xml:space="preserve">
          <source>Write an Int16 in little endian format</source>
          <target state="translated">リトルエンディアン形式でInt16を書く</target>
        </trans-unit>
        <trans-unit id="04d7dd93d431136691244f8a8060c6f710b4c9c7" translate="yes" xml:space="preserve">
          <source>Write an Int32 in big endian format</source>
          <target state="translated">Int32をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="ac3eecde6710e67b4fbd62fe5faea7085564b9e9" translate="yes" xml:space="preserve">
          <source>Write an Int32 in little endian format</source>
          <target state="translated">リトルエンディアン形式でInt32を書く</target>
        </trans-unit>
        <trans-unit id="4ecb73c918eeb208591574c27bf43973ceabac8a" translate="yes" xml:space="preserve">
          <source>Write an Int64 in big endian format</source>
          <target state="translated">Int64をビッグエンディアン形式で書く</target>
        </trans-unit>
        <trans-unit id="062b3fd33b7744aa05c8b488aac57bd5719de134" translate="yes" xml:space="preserve">
          <source>Write an Int64 in little endian format</source>
          <target state="translated">リトルエンディアン形式でInt64を書く</target>
        </trans-unit>
        <trans-unit id="f3475a216b60f541f9561999947a42033537d47f" translate="yes" xml:space="preserve">
          <source>Write an element in a mutable array</source>
          <target state="translated">変形可能な配列の要素を書く</target>
        </trans-unit>
        <trans-unit id="3a6dc8d047fec7b46b0233f24f9a28adcd679e26" translate="yes" xml:space="preserve">
          <source>Write an entire list of items to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アイテムのリスト全体を &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="f9599a175165c39f1f29ddd9bb8c7e18497bf06b" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;MutVar#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MutVar#&lt;/code&gt; の内容を書き込みます。</target>
        </trans-unit>
        <trans-unit id="842c4baf59de10dbe1f4228d4e89548eb6cfad90" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;TVar#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TVar#&lt;/code&gt; の内容を書き込みます。</target>
        </trans-unit>
        <trans-unit id="a3de1d04f7bf6af5e972546fb7777d6bafc52d88" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">メモリから &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; にデータを書き込みます。これは、POSIX &lt;code&gt;write&lt;/code&gt; 関数とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="3589adf6c850b011d135abac8239e99774d7263d" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">メモリから &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; にデータを書き込みます。これは、POSIX &lt;code&gt;write&lt;/code&gt; 関数とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="5c15fb50864a59ead622c1afb8db98eae0916f34" translate="yes" xml:space="preserve">
          <source>Write file in UTF-8 encoding. Parent directory will be created if missing.</source>
          <target state="translated">ファイルをUTF-8エンコーディングで書き込みます。見つからない場合は親ディレクトリが作成されます。</target>
        </trans-unit>
        <trans-unit id="b7773c80499d5b3f15854fd0b2e72f86ef50f9e8" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定されたエラーメッセージを &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; に書き込み、 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="4355c147f16522d41a43d5a06119aedec6f7144b" translate="yes" xml:space="preserve">
          <source>Write output from main C-\- pipeline passes to files</source>
          <target state="translated">メインのC-パイプラインからの出力をファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="b96bdb27f817c3c1baec26eb6ded0edc44bb3c99" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された値を指定されたメモリ位置に書き込みます。アラインメントの制限が適用される場合があります。 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="77655bd9fbe731998656fdcf621486c02b0a375a" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された値を指定されたメモリ位置に書き込みます。アラインメントの制限が適用される場合があります。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="babfd98df4815040b9b8feaf92e4a373432b470f" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory</source>
          <target state="translated">リストの要素を連続してメモリに書き込む</target>
        </trans-unit>
        <trans-unit id="c13f0a2faae8bb31701cafde84fa1d469581a021" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory and terminate them with the given marker element</source>
          <target state="translated">連続したリスト要素をメモリに書き込み、与えられたマーカー要素で終了させます。</target>
        </trans-unit>
        <trans-unit id="4bfb3401061c515a5bf897d647437c6e727895e8" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes.</source>
          <target state="translated">指定したバイト数を書き込みます。</target>
        </trans-unit>
        <trans-unit id="7948630f19859069bae4a14e2c76f2c7020b9d2a" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供された値を &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="8756d20514051c6080e747e02c7172e182a101af" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供された値を &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="f27a7a93b6c3f65c763bd60036589804bd7bf721" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供された値を &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="155f12112f4379352bcdee8335e8ff9abd964e75" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the standard output device.</source>
          <target state="translated">端子出力を標準出力装置に書き込む。</target>
        </trans-unit>
        <trans-unit id="2ffb13840f565fd761a331ddc6dc0237d509420b" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; が管理する端末またはファイルに端末出力を書き込みます。</target>
        </trans-unit>
        <trans-unit id="3cd750e768a4d8f40411b104e6eddf083a4f201a" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; によって管理されている端末またはファイルに端末出力を書き込みます。</target>
        </trans-unit>
        <trans-unit id="4bab7a81286ec426207ad20332db127f5e40c79b" translate="yes" xml:space="preserve">
          <source>Write to specified index of mutable array.</source>
          <target state="translated">変形可能な配列の指定されたインデックスに書き込みます。</target>
        </trans-unit>
        <trans-unit id="faa64ad5644001c4c4dc3bee878a933e8c8aac0e" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking. Returns the actual number of bytes written.</source>
          <target state="translated">指定したバイト数までブロッキングせずに書き込みます。実際に書き込まれたバイト数を返します。</target>
        </trans-unit>
        <trans-unit id="74120aff54b3ed793ccfa34d37318c6efb458636" translate="yes" xml:space="preserve">
          <source>Write vector; offset in bytes.</source>
          <target state="translated">ベクトルを書き込み、オフセットをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="fd96182628831a4dab0848bbbb0a8a86256945c3" translate="yes" xml:space="preserve">
          <source>Write vector; offset in scalar elements.</source>
          <target state="translated">ベクトルを書きます;スカラー要素でオフセットします。</target>
        </trans-unit>
        <trans-unit id="e1f97fa6627971c9b0e683428fd5abfab1ecbdb9" translate="yes" xml:space="preserve">
          <source>Write? (False = read-only)</source>
          <target state="translated">書くか?(False=読み取り専用)</target>
        </trans-unit>
        <trans-unit id="09c7377b67eee34defdc1dd0804c879b090650d2" translate="yes" xml:space="preserve">
          <source>WriteBuffer</source>
          <target state="translated">WriteBuffer</target>
        </trans-unit>
        <trans-unit id="3082b1ffe24322eee941ed215c852cffc7410d42" translate="yes" xml:space="preserve">
          <source>WriteHandle</source>
          <target state="translated">WriteHandle</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="60841bf1ad2d01720515c6eb9b3efbeb2e0f7656" translate="yes" xml:space="preserve">
          <source>WriteMode</source>
          <target state="translated">WriteMode</target>
        </trans-unit>
        <trans-unit id="f5ca54e8210ce7deaf5fa1129a91a1f50f08386a" translate="yes" xml:space="preserve">
          <source>WriteOnly</source>
          <target state="translated">WriteOnly</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="a8f135f9c50f7fe5f7a287362386d791fee8800a" translate="yes" xml:space="preserve">
          <source>Writer operations</source>
          <target state="translated">ライター操作</target>
        </trans-unit>
        <trans-unit id="a123ab5d3541d6386c9d34765c7348e78d2bb09e" translate="yes" xml:space="preserve">
          <source>WriterT</source>
          <target state="translated">WriterT</target>
        </trans-unit>
        <trans-unit id="1cccc800c778fc7aea514948aa922ecafd4399e9" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の配列を書き込みます。</target>
        </trans-unit>
        <trans-unit id="d30a3e22fd6539c1c9d94fc5b04d15e2c9f7e725" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の配列を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b2b97a0aaa412174782d8ac6874c3f7cc18e81e9" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongisde regular enterface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">拡張インターフェースファイルを通常のインターフェースファイルと一緒に書き出します。通常のインターフェイスファイルと同様に、GHCには、古い拡張インターフェイスファイルや欠落した拡張インターフェイスファイルを検出するための再コンパイルチェック機能があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
