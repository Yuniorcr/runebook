<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0fea1585aed3010cb59ede80216e1092bd438ce4" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;#5348&lt;/a&gt; for details.</source>
          <target state="translated">The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt; . Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt; . One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;#5348&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">引用符で囲まれた &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 文字列」は、2文字のシーケンス「|]」が最初に出現したところで終了します。エスケープは絶対に行われません。その文字シーケンスを文字列に埋め込む場合は、独自のエスケープ規則を作成し（たとえば、文字列 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 使用するなど）、クォーター関数で &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; を &lt;code&gt;&quot;|]&quot;&lt;/code&gt; として解釈する必要があります。 ] &quot;。これを実装する1つの方法は、エスケープ変換を実行する前処理パスを使用してクオートを作成することです。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;問題＃5348の説明&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">このより保守的な戦略の理論的根拠はで与えられている&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;論文&lt;/a&gt;「レッツが一般化してはならない」と「地元の前提とモジュラー型推論」、および関連する&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;ブログ記事&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46c2ed2757c23fae8b2fbe6c5c9ab4a0e016d4ba" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;blog post&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">このコストセンターに起因する時間の「ティック」の生の数。これから、上記の &lt;code&gt;%time&lt;/code&gt; の数値が得られます。</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">与えられたモナドに読み取り専用の環境を追加するリーダーモナド変換器。</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; がこのトレース名をバックトレース出力に表示しない理由は、デバッグ情報の解釈が不忠実であるためです。これは、Cに保存されている不変条件を想定していますが、Haskellプログラムにはありません。残念ながら、この動作が上流で修正されるまで、手動でこれを回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">後者の制限の理由は、インスタンスのマッチングをチェックする方法がないからです。以下を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="76babb94bd7796eeda34a4c806d3669a17f9540b" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt; . For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">&lt;code&gt;mergeQs&lt;/code&gt; の呼び出しが遅延である理由は、それがキューの最後の要素の下になり、完全にソートされたシーケンスを評価できないためです。</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">信頼をチェックする2つのモードがある理由は、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;によって有効化された追加の要件により、Safe Haskellの設計が侵襲的になるためです。フラグが有効になっているときにSafe Haskellを使用するパッケージは、ユーザーのマシン上の信頼できるパッケージの状態に応じてコンパイルされる場合とコンパイルされない場合があります。これはどちらも脆弱であり、Safe Haskellが提供する保証のいずれかを使用しようとしていない場合でも、全員にコンパイルエラーを引き起こします。デフォルトで&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; を&lt;/a&gt;無効にしてフラグに変換すると、Safe Haskellは常時オンの機能ではなくオプトイン拡張機能になります。</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">再バインド可能な演算子には、上記の表にある「期待されるタイプ」が必要です。これらのタイプは驚くほど一般的です。たとえば、次のタイプのバインド演算子を使用できます</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">小さいパーツからByteStringをアセンブルするための推奨される方法は、Data.ByteString.Builderからのビルダーモノイドを使用すること&lt;a href=&quot;data-bytestring-builder&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">小さい部分から遅延ByteStringをアセンブルするための推奨される方法は、Data.ByteString.Builderからのビルダーモノイドを使用すること&lt;a href=&quot;data-bytestring-builder&quot;&gt;です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">推奨されるチャンクサイズ。現在は4kに設定されていますが、メモリ管理のオーバーヘッドが少なくなります。</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">レコードフィールド &lt;code&gt;f&lt;/code&gt; は、何らかの形でスコープ内にあります（修飾または非修飾のいずれか）。</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; を再帰的に使用すると、2番目の引数の種類が &lt;code&gt;Type&lt;/code&gt; になります。ただし、型推論の場合と同様に、 &lt;code&gt;T&lt;/code&gt; に&lt;em&gt;完全なユーザー指定の種類シグネチャ&lt;/em&gt;（またはCUSK）を与えることにより、多態的な再帰を実現できます。CUSKは、推論を必要とせずに、すべての引数の種類と結果の種類がわかっている場合に存在します。例えば：</target>
        </trans-unit>
        <trans-unit id="dedba55228cde4bbd5f3a4194d8b8dabbf8ef98a" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;standalone kind signature&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt; . However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;standalone kind signature&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">参照は呼び出し元のプロセスで作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">関連する&lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set操作&lt;/a&gt;は、次のように &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; で表すことができます。</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">レンダリングモード。</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">表現 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; ほんの少し違うからである &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 。もう一度例として &lt;code&gt;Tree&lt;/code&gt; を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typの表現は抽象的に保持されており、実装が派手な表現(例えば、共有を管理するためのハッシュ結合)を使用することを可能にします。ビューパターンがなければ、このシグネチャを使うのは少し不便です。</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">外部ファイルやストリームにおける改行の表現。</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; の種類を呼び出すためにGHCによって生成される表現。</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">この表現では、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ）と、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; が再利用されます。（この再利用性が、kind- &lt;code&gt;*&lt;/code&gt; -typesのダミーの型引数を引き継ぐ理由ですが、これらのそれぞれを複製することなく、すでに十分に異なる名前が含まれています。）</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">このモジュールで使用される表現は、高性能な使用や大量のデータのストリーミングに適しています。これは、コンテンツ全体がメモリに常駐していることを必要とせずに、大きなテキストを操作するための手段を提供します。</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">タイプの表現 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 、及び機能 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; の派生インスタンスによって使用さ &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 構築する &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">再スケジュールタイマーはデフォルトで20msの粒度で実行されますが、これは &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTSオプションを使用して変更できます。「ティック」を再スケジュールした後、実行中のスレッドはできるだけ早くプリエンプトされます。</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">解像度 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;getCurrentTime&lt;/code&gt; 、 &lt;code&gt;getPOSIXTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">このセクションの残りの部分では、GADTスタイルのデータ型宣言についてさらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このセクションの残りの部分では、GADTをサポートするGHCの拡張機能の概要を説明します。拡張機能は&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;で有効になります。&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; の&lt;/a&gt;延長も設定&lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">機能の依存関係の制限（&lt;a href=&quot;#functional-dependencies&quot;&gt;機能の依存関係&lt;/a&gt;）は特に厄介です。ヘッドに表示されないコンテキストで型変数を導入するのは魅力的ですが、これは通常のルールでは除外されています。例えば：</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">内包の結果式は &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;最後&lt;/em&gt;であり、NoBindSである必要があり &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">内包の結果式は &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; の&lt;em&gt;最後&lt;/em&gt;であり、NoBindSである必要があり &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f01982d31d372848e4d6802c210759a3354a8278" translate="yes" xml:space="preserve">
          <source>The result is always &lt;code&gt;&amp;gt;= 1&lt;/code&gt; since even zero is encoded with 1 limb.</source>
          <target state="translated">ゼロでも1肢でエンコードされるため、結果は常に &lt;code&gt;&amp;gt;= 1&lt;/code&gt; なります。</target>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">その結果、ホールまたは変数は &lt;code&gt;undefined&lt;/code&gt; のように動作しますが、コンパイル時に警告が表示され、実行時に評価されると同じメッセージが表示されるという追加の利点があります。この動作は、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;を意味する-fdefer-type-errorsオプションの動作に従います。&lt;a href=&quot;#defer-type-errors&quot;&gt;タイプエラーのランタイムへの遅延を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">結果の種類の注釈はオプションであり、省略した場合のデフォルトは（引数の種類と同様に） &lt;code&gt;Type&lt;/code&gt; です。種類別のタイプファミリーは、kindアノテーションのパラメータを使用して宣言できます。</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; の結果は、型が宣言された時点で有効な固定宣言が与えられている場合、定数のみを含む構文的に正しいHaskell式です。データ型、括弧、およびスペースで定義されたコンストラクター名のみが含まれます。ラベル付きコンストラクターフィールドを使用する場合は、中かっこ、コンマ、フィールド名、および等号も使用されます。</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; の結果は、型が宣言された時点で有効な固定宣言が与えられている場合、定数のみを含む構文的に正しいHaskell式です。データ型、括弧、およびスペースで定義されたコンストラクター名のみが含まれます。ラベル付きコンストラクターフィールドを使用する場合は、中かっこ、コンマ、フィールド名、および等号も使用されます。</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; の結果は、型が宣言された時点で有効な固定宣言が与えられている場合、定数のみを含む構文的に正しいHaskell式です。データ型、括弧、およびスペースで定義されたコンストラクター名のみが含まれます。ラベル付きコンストラクターフィールドを使用する場合は、中かっこ、コンマ、フィールド名、および等号も使用されます。</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">最後の継続として &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を使用してCPS計算を実行した結果。</target>
        </trans-unit>
        <trans-unit id="6cddc91b7454e61583af3768c2c69961c994bfc1" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">特定の最終的な継続でCPS計算を実行した結果。（ &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; の逆）</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">特定の最終的な継続でCPS計算を実行した結果。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; の逆）</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">ID を最終的な続きとして CPS 計算を実行した結果。</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">結果の文字列は、入力文字列よりも長い場合があり、 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; を入力文字列に適用する場合とは異なる場合があります。たとえば、アルメニア語の小さな合字「ﬓ」（現在はU + FB13）は、「մ」（男性、U + 0574）の後に「ն」（現在はU + 0576）が続くシーケンスに大文字小文字変換されますが、ギリシャ語「&amp;micro;」（マイクロ記号、U + 00B5）は、それ自体ではなく、「&amp;micro;」（小文字のmu、U + 03BC）に折りたたまれたケースです。</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">結果の文字列は、入力文字列よりも長い場合があり、 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; を入力文字列に適用する場合とは異なる場合があります。たとえば、アルメニア語の小さな合字の男性（U + FB13）は現在バイグラム男性（U + 0574 U + 0576）にケース折りたたまれていますが、マイクロ記号（U + 00B5）はギリシャ小文字のmuにケース折りたたまれています（U + 03BC）それ自体ではなく。</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">結果の文字列は、入力文字列よりも長い場合があり、 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; を入力文字列に適用する場合とは異なる場合があります。たとえば、アルメニア語の小さな合字の男性（U + FB13）は現在バイグラム男性（U + 0574 U + 0576）にケース折りたたまれていますが、マイクロ記号（U + 00B5）はギリシャ小文字のmuにケース折りたたまれています（U + 03BC）それ自体ではなく。</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">結果の文字列は入力文字列よりも長い場合があります。例えば、ラテン語の小字合字ﬂ(U+FB02)は、ラテン語の大文字F(U+0046)の後にラテン語の小字l(U+006C)が続くシーケンスに変換される。</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">結果の文字列は入力文字列よりも長い場合があります。例えば、&quot; İ&quot; (ラテン語の大文字Iの上にドットがある、U+0130)は、&quot;i&quot; (ラテン語の小文字i、U+0069)の後に&quot;̇&quot;が続く配列に対応しています。(上のドットを組み合わせて、U+0307)。</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">結果の文字列は、入力文字列よりも長い場合があります。たとえば、ドイツ語の &quot;&amp;szlig;&quot;（eszett、U + 00DF）は、2文字のシーケンス &quot;SS&quot;にマップされます。</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">結果の文字列は入力文字列よりも長いかもしれません。例えば、ドイツ語の eszett (U+00DF)は 2 文字列の SS に対応しています。</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">結果の文字列は入力文字列よりも長い場合があります。例えば、上にドットがあるラテン語の大文字 I (U+0130)は、ラテン語の小文字 i (U+0069)に続いて上にドットが結合されている (U+0307)というシーケンスに対応します。</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">結果の型は &lt;code&gt;Show&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">結果の型は &lt;code&gt;()&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">結果の型もまた、曖昧さがないものでなければなりません。通常、これは推論できますが、グループ内のすべてのパターン同義語がコンストラクタで多相化されている場合、ユーザーは型署名を提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">各データコンストラクターの結果の型は、定義されている型コンストラクターで始まる必要があります。すべてのコンストラクタの結果の型が &lt;code&gt;T a1 ... an&lt;/code&gt; 形式である場合、 &lt;code&gt;a1 ... an&lt;/code&gt; は特殊型変数であり、データ型は&lt;em&gt;通常&lt;/em&gt;です。それ以外の場合は、&lt;em&gt;一般化された&lt;/em&gt;データ型です（&lt;a href=&quot;#gadt&quot;&gt;一般化代数データ型（GADT）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">結果は、バインディングの（場合によっては）再帰的なセットになり、左側の単純な変数のみがバインディングされます。（Haskellレポートのようにさらに一歩進んで、 &lt;code&gt;fix&lt;/code&gt; を使用して再帰的バインディングを非再帰的にすることもできますが、Coreではそうしていません。問題を難読化するだけなので、ここではそうしません。）</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">結果のブロックは、 &lt;code&gt;compactFixupPointers#&lt;/code&gt; が呼び出されるまでGCに認識されません。アドレスがエスケープされないように、またはメモリがリークしないように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">戻りコードおよび起こり得る障害は、 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">戻りコードおよび起こり得る障害は、 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">戻り値は、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; です（これは &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; である必要がありますが、Haskellの型システムではこれが難しくなっています）。</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; の戻り値は、ガベージコレクターが実行されるタイミングに依存するため、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあります。</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; の戻り値は、ガベージコレクターが実行されるタイミングに依存するため、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあります。</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">逆は必ずしも当てはまりません。2つの安定した名前が等しくない場合でも、それらの名前が付けられているオブジェクトは同じである可能性があります。ことに特に注意 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; が異なる返してもよい &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; をオブジェクトが評価された後。</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">逆は必ずしも当てはまりません。2つの安定した名前が等しくない場合でも、それらの名前が付けられているオブジェクトは同じである可能性があります。ことに特に注意 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; が異なる返してもよい &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; をオブジェクトが評価された後。</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; の逆です。</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">書き換えは、 &lt;code&gt;Control.Exception.assert&lt;/code&gt; のアプリケーションを検出した場合にのみコンパイラーによって実行されるため、必要に応じて独自のバージョンの &lt;code&gt;assert&lt;/code&gt; を定義して使用できます。そうでない場合は、 &lt;code&gt;Control.Exception&lt;/code&gt; をインポートして、コードで &lt;code&gt;assert&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">レコード更新のルールはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">経験則では、 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を使用して遅延値の例外を強制または処理します。一方、効率の理由のみで遅延値を強制し、例外を気にしない場合は、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 使用できます。x。</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">経験則では、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; を使用して遅延値の例外を強制または処理します。一方、効率の理由のみで遅延値を強制し、例外を気にしない場合は、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 使用できます。x。</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">ルールはこれです。</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">エクスポートリストのルール（Haskellレポート&lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;セクション5.2&lt;/a&gt;）では、タイプファミリーの調整が必要です。</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">字句スコープ型変数についての規則は、（参照&lt;a href=&quot;#scoped-type-variables&quot;&gt;字句は、型変数をスコープ&lt;/a&gt;）パターン同義語署名に適用されます。それらのルールが指定するように、パターン同義語の定義に対する明示的で構文的に見える外部の &lt;code&gt;forall&lt;/code&gt; （ユニバーサル）スコープからの型変数のみ。内部のforallによってバインドされた実存はありません。例えば</target>
        </trans-unit>
        <trans-unit id="b99c4ffb314648f355d9f28d0c2cc30bab28737d" translate="yes" xml:space="preserve">
          <source>The rules for solving &lt;code&gt;Typeable&lt;/code&gt; constraints are as follows:</source>
          <target state="translated">The rules for solving &lt;code&gt;Typeable&lt;/code&gt; constraints are as follows:</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">Typeable` 制約を解くためのルールは以下の通りである。</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの制限された型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスに適用されるルール（算術シーケンスを扱うHaskellレポートのセクションを参照）は、ここで定義されているさまざまな &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの制限された型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスを保持するルール（算術シーケンスを扱うHaskellレポートのセクションを参照）は、ここで定義されているさまざまな &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 型の &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; インスタンスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">ランタイムは、&lt;em&gt;機能&lt;/em&gt;と呼ばれる一連の仮想プロセッサを管理します。その数は &lt;code&gt;-N&lt;/code&gt; オプションによって決定されます。各機能は一度に1つのHaskellスレッドを実行できるため、機能の数は、物理的に並行して実行できるHaskellスレッドの数と同じです。機能は、1つ以上のOSスレッドによってアニメーション化されます。ランタイムは各機能のOSスレッドのプールを管理するため、Haskellスレッドが外部呼び出しを行う場合（&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;マルチスレッドとFFIを&lt;/a&gt;参照）、別のOSスレッドがその機能を引き継ぐことができます。</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">ランタイムは、使用可能なワーカーOSスレッドのいずれかを使用してHaskellスレッドを実行します。特定のHaskellスレッドを実行するために使用される特定のOSスレッドを制御する必要がある場合、おそらくOS-thread-local状態を使用する外部ライブラリを呼び出す必要があるため、バインドされたスレッドが必要です（&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrentを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">&lt;code&gt;-v2&lt;/code&gt; と同じですが、さらに、各コンパイルフェーズの完全なコマンドライン（該当する場合）も出力されます。</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">&lt;code&gt;-v3&lt;/code&gt; と同じですが、各コンパイル段階の後の中間プログラム表現も出力されます（前処理済みファイルとC /アセンブリファイルを除く）。</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; と同じですが、非IO計算用です。包むために使用される &lt;code&gt;foreign export&lt;/code&gt; と &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; これらは非IOタイプでHaskellの関数をエクスポートするために使用されている場合。</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; と同じですが、改行文字が追加されます。</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; と同じですが、同じ名前のパッケージがすでにインストールされている場合、新しいパッケージに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">通常のHaskellのペアと同じですが</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">「 &lt;code&gt;Variable out of scope&lt;/code&gt; 」エラーの場合と同じ動作で、デフォルトでコンパイルを終了します。このようなエラーは、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;フラグを使用して延期できます。このフラグは、範囲外の変数によって生成されたエラーを実行時まで延期し、それらをコンパイル時の警告に変換します。これらの警告は、&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;によって完全に抑制できます。</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">モジュールをソースからコンパイルした場合でも、GHCはまだバッチモードであると見なしているため、同じフラグが必要です。</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">同じファンクタですが、要素を逆の順序で処理する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; インスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="da41682db6dc3bc462b3f80ca76ddaa5753e53c9" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">同じファンクターですが、逆の順序でアクションを実行する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; インスタンスがあります。</target>
        </trans-unit>
        <trans-unit id="0aaeaba67e253d52c7d36c2433b481fa76e2e2f2" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">同じ内容をまとめてみました。</target>
        </trans-unit>
        <trans-unit id="c9836bb2774b4fe28e93611c450bce02c5621a1e" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">The same phase-numbering control is available for &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; &lt;/a&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">同じフェーズ番号制御が &lt;code&gt;RULE&lt;/code&gt; （&lt;a href=&quot;#rewrite-rules&quot;&gt;書き換えルール&lt;/a&gt;）で使用できます。</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">同じ洗練された依存関係分析により、相互再帰関数の型シグネチャに異なるコンテキストを設定することもできます。これはHaskell 98では違法です（セクション4.5.2、最後の文）。GHCは、&lt;em&gt;洗練された&lt;/em&gt;グループの型シグネチャが同一の型シグネチャを持っていると主張するだけです。実際には、これは、同じパターンバインディングによってバインドされた変数のみが同じコンテキストを持つ必要があることを意味します。たとえば、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">同じ制限が、 &lt;code&gt;deriving&lt;/code&gt; 句によって生成されたインスタンスにも適用されます。したがって、以下が受け入れられます。</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">ここでのシナリオは、完全なプログラムをリンクするのではなく、Cのライブラリをデプロイするのと同じ方法でデプロイできるHaskellコードからライブラリを作成することを除いて、&lt;a href=&quot;#using-own-main&quot;&gt;独自のmain（）を使用する&lt;/a&gt;場合とほぼ同じです。コード。</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">デフォルトでは、検索パスには単一のディレクトリ「」が含まれています &lt;code&gt;.&lt;/code&gt; 」（つまり、現在のディレクトリ）。次のオプションを使用して、検索パスのコンテンツを追加または変更できます。</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">ソースファイルを見つけるための検索パスは、GHCiコマンドラインの&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;オプションで次のように指定します。</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">2 番目の引数は通常、アプリケーションの名前です。これはパスに統合されるので、有効なパス文字でなければなりません。注意:第二引数が絶対パスの場合、第二引数を返すだけです。</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">2つ目の句はもう少し面白いです。それは、右辺が重なり合う領域で一致していれば、2つの重複する型ファミリーインスタンスが許されると書いています。ここではいくつかの例が役に立ちます。</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2番目のコンストラクターは2つのフィールドで構成されます。それぞれがタイプ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; aの再帰フィールドで &lt;code&gt;Tree a&lt;/code&gt; 、Rec0（Tree a）として表されます。個々のフィールドの表現は、バイナリ型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; を使用して結合されます。</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; が実行する2番目に一般的な手順は、境界プリミティブを使用してバッファーを埋めることです。これは次のように機能します。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の十分なスペースがあるかどうかのチェックは、有界プリミティブを実行するために残しました。存在する場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; はバインドされたプリミティブを実行し、更新されたバッファーで次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を呼び出します。それ以外の場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は新しいバッファーが必要であることをドライバーに通知します。このバッファーは、少なくともプリミティブの境界と同じ大きさでなければなりません。境界プリミティブを使用して、連続する &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; バッファフリーチェックを融合することにより、バッファフリーチェックの数を減らすことができます。s。また、境界プリミティブを使用して、十分なスペースが残っていることを最初に確認してから、特定の値をエンコードする方法を決定することで、バッファーがいっぱいであることを通知するための制御フローを簡略化できます。</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">これらのケースのうち2つ目は、型が型パラメータと不等式であるにもかかわらず型パラメータを含んでいる場合で、意外と厄介なことがあります。例えば、次の例はコンパイルされています。</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">2番目のオプションは、フラグ&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;を追加することです（&lt;a href=&quot;ghci#external-interpreter&quot;&gt;別のプロセスでインタープリター&lt;/a&gt;を実行するを参照）。これは、別のプロセスでインタープリターを実行し、プロファイルされたコードを直接ロードして実行できます。コードを2回コンパイルする必要はありません。&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;を追加するだけで機能します。（このオプションはGHC 8.0.xでは実験的なものですが、将来のリリースではデフォルトになる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">ファイルの2番目の部分は、プログラムで最もコストのかかる関数のコストセンターごとの内訳です。この場合、プログラムには1つの重要な関数、つまり &lt;code&gt;fib&lt;/code&gt; のみがあり、プログラムの時間と割り当てコストの両方を100％担当していました。</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">このマニュアルの種類ポリモーフィズムに関するセクションでは、型宣言とクラス宣言&lt;a href=&quot;#inferring-variable-order&quot;&gt;の変数の順序付け&lt;/a&gt;について説明しています（型/クラス宣言の変数の順序の推測）。</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">環境に適用するセレクタ機能。</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">セレクタの厳密性アノテーション(あれば</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">セレクタのunpackednessアノテーション(あれば)。</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">この場合のセマンティクスは、必要なエンティティのセットはそのエクスポートによって排他的に定義されるということです。この機能の背後にある動機は、ライブラリの作者が誰かが使いたいと思うかもしれないすべての関数の型を含むオムニバス署名を提供することを可能にする一方で、クライアントが実際に必要とするものにエクスポートを絞り込むことができるようにすることです。例えば、文字列のシグネチャを継承していると仮定して、必要なエンティティだけをリストアップしたこの形式のローカルシグネチャを書くかもしれません。</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; のセマンティクスはかなり単純です。GHCが &lt;code&gt;rec&lt;/code&gt; グループを見つけると常に、バインドされた変数のセットを計算し、 &lt;code&gt;MonadFix&lt;/code&gt; クラスに属する基になるモナディック値再帰演算子 &lt;code&gt;mfix&lt;/code&gt; への適切な呼び出しを導入します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskellパターンマッチングのセマンティクスは、Haskellレポートの&lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;セクション3.17.2&lt;/a&gt;で説明されています。この説明に、さらに1つの項目10を追加して、</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">パターンの意味論 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">サーバ側のHaskellテンプレートの状態。これは StartTH メッセージによって作成されます。GHCがタイプチェックするモジュールごとに新しいものが作成されます。</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">スタティックポインタテーブルのスタティックポインタの位置を特定するために使用されるキーのセットは、異なるプログラムバイナリに対して安定していることは保証されていません。言い換えれば、同じプログラムバイナリから起動されたプロセスのみが同じキーセットを使用することが保証されます。</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">既知のエンコーディングのセットはシステムに依存しますが、少なくとも含まれています。</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">プロンプトで現在&lt;em&gt;スコープ内&lt;/em&gt;にあるモジュールのセット。このセットは &lt;code&gt;import&lt;/code&gt; と&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;によって変更され、上記のように&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; の&lt;/a&gt;後に自動的に変更されます。スコープ内のモジュールのセットは、&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; で&lt;/a&gt;表示できます。</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在&lt;em&gt;ロードされ&lt;/em&gt;ているモジュールのセット。このセットは、&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;によって変更され、&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高さは1で、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高さはないため、最後の法則の側面条件が必要です。</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高さは1で、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高さはないため、最後の法則の側面条件が必要です。</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高さは1で、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高さはないため、最後の法則の側面条件が必要です。</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; の左IDであるため、最後の法則のサイド条件が必要です。</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; の左IDであるため、最後の法則のサイド条件が必要です。</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; の左IDであるため、最後の法則のサイド条件が必要です。</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">シグネチャは、パターンバインディングではなく、関数バインディングやむき出しの変数バインディングの型を与えます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; デコーダーを実行するための最も単純なインターフェース。デコーダーでエラーが発生した場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; を呼び出した場合、または入力が不足した場合は、error を呼び出し &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e8c225c01f9faa3800585856cd9e7639c83f852" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; デコーダーを実行するための最も単純なインターフェース。デコーダーでエラーが発生した場合、呼び出しが &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 、または入力が不足した場合は、エラーが呼び出され &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; のサイズは &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="15de436f5ad58966f3fd02d798c87b26a0a4d2de" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; のサイズは &lt;code&gt;maxBound::Int&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; のサイズは &lt;code&gt;maxBound::Int&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合のシーケンスの動作は未定義です。これはほとんどのアプリケーションで発生する可能性は低いですが、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; を特に繰り返し、特に &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; と組み合わせて使用する場合は、いくつかの注意が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="a9c06af16b62ace31432f475d864e0e1ea766afc" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt; . Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; , particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が 2つ以上の異なるキーを同じ新しいキーにマッピングする場合、結果のサイズは小さくなる場合があります。この場合、関連する値は &lt;code&gt;c&lt;/code&gt; を使用して結合されます。</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が 2つ以上の異なるキーを同じ新しいキーにマッピングする場合、結果のサイズは小さくなる場合があります。この場合、関連する値は &lt;code&gt;c&lt;/code&gt; を使用して結合されます。2つの元のキーのうち大きい方の値が &lt;code&gt;c&lt;/code&gt; の最初の引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; が 2つ以上の異なるキーを同じ新しいキーにマッピングする場合、結果のサイズは小さくなる場合があります。この場合、元のキーの最大値が保持されます。</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; によって生成されたバイトシーケンスのサイズ。</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">セットのサイズは &lt;code&gt;maxBound::Int&lt;/code&gt; 超えてはなりません。この条件の違反は検出されず、サイズ制限を超えた場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">バウンディングペアで定義されたサブレンジのサイズ。</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">サイズ付き整数データ型、 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">持っていくことができるハンマーは、 &lt;code&gt;INLINE&lt;/code&gt; プラグマです。</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">解決策としては、インスタンス固有の関数を自分で定義し、それが早くにインライン化されないようにpragmaを付けて、そのためのRULEを与えることです。</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">プログラムのソースファイルがすべて同じディレクトリにある必要はありません。&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;オプションは、（参照、検索パスにディレクトリを追加するために使用することができます&lt;a href=&quot;separate_compilation#search-path&quot;&gt;検索パスを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">ソースの場所</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特別な &lt;code&gt;family&lt;/code&gt; は、ファミリを標準のデータ宣言と区別します。結果の種類の注釈はオプションであり、通常、省略された場合のデフォルトは &lt;code&gt;Type&lt;/code&gt; です。例は</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特別な &lt;code&gt;family&lt;/code&gt; は、ファミリーを標準の型宣言と区別します。結果の種類の注釈はオプションであり、通常、省略された場合のデフォルトは &lt;code&gt;Type&lt;/code&gt; です。例は</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; は、ビルドされている現在のパッケージを参照するために使用できる特別なパッケージ名です。</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">仕様はフォーマット文字で終了します。</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">指定されたファイルは、Cプログラム、コンパイルされたHaskellファイル、およびCヘッダーに組み込まれます。 &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; は自動的に含まれます。</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">用指定子 &lt;code&gt;DiffTime&lt;/code&gt; 、 &lt;code&gt;NominalDiffTime&lt;/code&gt; 、 &lt;code&gt;CalendarDiffDays&lt;/code&gt; 、及び &lt;code&gt;CalendarDiffTime&lt;/code&gt; は、他の種類の意味的に分離されています。負の時間差の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; は一般に負になります（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ではなくremと考えてください）。</target>
        </trans-unit>
        <trans-unit id="509d7b73e79bd7157914844fa1c9246fd5e8d212" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The specifiers for &lt;code&gt;DiffTime&lt;/code&gt; , &lt;code&gt;NominalDiffTime&lt;/code&gt; , &lt;code&gt;CalendarDiffDays&lt;/code&gt; , and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">スプライス &lt;code&gt;$(blah1)&lt;/code&gt; は関数を参照することができない &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; の後宣言基の一部、従って見えない、同様に、ある &lt;code&gt;$(blah1)&lt;/code&gt; の定義を見ることができない &lt;code&gt;h&lt;/code&gt; が同じ宣言グループの一部であるので（ &lt;code&gt;$(blah1)&lt;/code&gt; 。ただし、スプライス &lt;code&gt;$(blah1)&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; の定義を見ることができます（直前の宣言グループにあるため）。</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">スプライス &lt;code&gt;$(blah2)&lt;/code&gt; は、スプライス &lt;code&gt;$(th2 ...)&lt;/code&gt; と同じ定義を参照します（ただし、それによって作成されるバインディング&lt;em&gt;はありません&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">スプライス &lt;code&gt;$(th1 ...)&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; の定義を参照します-スプライスはトップレベルであるため、前の宣言グループ内のすべての定義が表示されます（つまり、モジュール内のすべての定義が含まれますスプライス自体）。</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">スプライス &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;は&lt;/em&gt; &lt;code&gt;D&lt;/code&gt; を参照&lt;em&gt;できません&lt;/em&gt; -同じ宣言グループにあります。</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">スプライス &lt;code&gt;$(th2 ...)&lt;/code&gt; の定義は見るであろう &lt;code&gt;f&lt;/code&gt; は、すべてで作成されたバインディング &lt;code&gt;$(th1 ...)&lt;/code&gt; 、の定義 &lt;code&gt;h&lt;/code&gt; とによって作成されたすべてのバインディング &lt;code&gt;[qq|blah|]&lt;/code&gt; 彼らはすべての前にあります宣言グループ）。</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">走るためのスプライス</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">スタックは、デフォルトではヒーププロファイルでカウントされません。RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">スタックトレースは、多くの場合、 &lt;code&gt;GHC.List.CAF&lt;/code&gt; のような情報のないもので始まる場合があります。これはGHCのオプティマイザのアーティファクトであり、プロファイリングシステムがコストセンター「CAF」に割り当てる例外を最上位に引き上げます。ただし、 &lt;code&gt;+RTS -xc&lt;/code&gt; は現在のスタックを出力するだけでなく、CAFが評価された時点でスタックをより深く表示して報告し、非CAFスタックが見つかるまでさらにスタックを報告する場合があります。上記の例では、次のスタック（ &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 後）には、プログラムが &lt;code&gt;head []&lt;/code&gt; を評価したときに実行していたことに関する多くの情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">スタックオーバーフローメッセージ。</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">スタンドアロン構文は、通常の &lt;code&gt;deriving&lt;/code&gt; 句が一般化されるのとまったく同じ方法で&lt;a href=&quot;#newtype-deriving&quot;&gt;newtypesに対して一般化されます&lt;/a&gt;（newtypesの一般化された派生インスタンス）。例えば：</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">スタンドアロンの派生宣言は、データ型宣言と同じモジュールにある必要はありません。（ただし、孤立したインスタンス（孤立&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;モジュールとインスタンス宣言&lt;/a&gt;）の危険性に注意してください）。</target>
        </trans-unit>
        <trans-unit id="704c3d94002789a8f5e8c50c778edbf18c8986c7" translate="yes" xml:space="preserve">
          <source>The standalone kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">The standalone kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt; , and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">標準のC99 &lt;code&gt;fenv.h&lt;/code&gt; ヘッダーは、浮動小数点ユニットの状態を検査および変更するための操作を提供します。特に、浮動小数点演算で使用される丸めモードを変更でき、例外フラグをテストできます。</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">標準のCPUTimeライブラリ。</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">標準のIOライブラリです。</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS Xの標準的な想定では、ビルド時に動的ライブラリに「インストール名」というスタンプが付けられます。これは、ライブラリファイルの最終的な完全インストールパスです。その後にリンクするライブラリまたは実行可能ファイル（まだインストールされていない場合でも）は、そのパスを実行時検索場所として選択します。 ghcで直接コンパイルする場合、インストール名はデフォルトでビルドされた場所に設定されます。これは、 &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; オプション（ &lt;code&gt;-install_name&lt;/code&gt; をAppleリンカーに渡す）でオーバーライドできます。 Cabalがこれを行います。動的ライブラリのインストール名を、最終的なインストール場所の絶対パスに自動的に設定します。</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">したがって、標準のデフォルトルールが拡張されています。デフォルトは、すべての未解決の制約に標準クラス&lt;em&gt;または&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; が含まれる場合に適用されます。少なくとも1つは数値クラス&lt;em&gt;または&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">標準関数 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; は、安定したポインターテーブルをロックし、指定された安定したポインターを解放してから、安定したポインターテーブルを再度ロック解除します。多くの安定したポインタを一度に解放するときは、通常、テーブルのロックとロック解除を一度だけ行う方が効率的です。</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">テキストをエンコードおよびデコードするための標準関数は厳密です。つまり、無効な入力に対して例外をスローします。これは実際の入力では役に立たないことが多いため、無効な入力を処理するためのカスタムハンドラーを受け入れる代替関数が存在します。これらの &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; ハンドラーは通常のHaskell関数です。このモジュールで提供されている関数の1つを使用するか、独自のカスタムハンドラーを作成できます。</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; で使用される標準のイディオムは、継続に名前を付けるためのラムダ式を提供することです。次に、名前付き継続をそのスコープ内の任意の場所で呼び出すと、ネストされた計算内の多くの層である場合でも、計算からエスケープされます。</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">標準ライブラリはこのデバイスタイプを直接サポートしていませんが、ユーザーの実装では、ディレクトリ内のファイル名のリストを、 &lt;code&gt;&quot;.&quot;&lt;/code&gt; を除く &lt;code&gt;'\0'&lt;/code&gt; 文字で区切って、任意の順序で提供する必要があります。および &lt;code&gt;&quot;..&quot;&lt;/code&gt; 名前。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; も参照してください。シーク操作は、ディレクトリ（ゼロ位置以外）ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">システムローダーの標準ライブラリ検索パス。一部のシステムでは、 &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 環境変数を設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">実行スタックの状態</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">ステートメント &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; -return &lt;code&gt;return 42&lt;/code&gt; は、「 &lt;code&gt;IO&lt;/code&gt; モナドでreturn 42を実行し、結果を &lt;code&gt;x&lt;/code&gt; にバインドする」ことを意味します。その後、たとえば上記のように出力するために、 &lt;code&gt;x&lt;/code&gt; を将来のステートメントで使用できます。</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">ステートメントはバインディングではないか、1つの変数のみをバインドするモナディックバインディング（ &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">保存された値は、怠惰に計算される大きな仮想データ構造を表していません。</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">例外がスローされた時点から処理されるまでの間、バインド関数をバイパスして例外をスローできる計算を組み合わせる戦略。</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; のモナドは破壊的なアップデートが可能になりますが、（IOとは違って）エスケープ対象です。タイプの計算 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 戻り型の値 &lt;code&gt;a&lt;/code&gt; 、および「スレッド」で実行 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; パラメータは、どちらかであります</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; のモナドは破壊的なアップデートが可能になりますが、（IOとは違って）エスケープ対象です。タイプの計算 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 戻り型の値 &lt;code&gt;a&lt;/code&gt; 、および「スレッド」で実行 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; パラメータは、どちらかであります</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; モナド変換プログラム。指定されたモナドに出力（カウントや文字列出力など）のコレクションを追加します。</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; モナド変換プログラム。指定されたモナドに出力（カウントや文字列出力など）のコレクションを追加します。</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 型では、文字列全体が一度にメモリに収まる必要があります。レイジー &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; タイプは、小さなメモリフットプリントを使用して、メモリよりも大きい文字列をストリーミングできます。多くの場合、チャンクストリーミングのオーバーヘッドにより、レイジー &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; タイプは対応する厳密なタイプよりも遅くなりますが、常にそうであるとは限りません。内部構造が異なるため、1つのモジュール内の関数の時間の複雑さが他のモジュールと異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">厳密な &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; モナド。 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; のモナドは破壊的なアップデートが可能になりますが、（IOとは違って）エスケープ対象です。タイプの計算 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 戻り型の値 &lt;code&gt;a&lt;/code&gt; 、および「スレッド」で実行 &lt;code&gt;s&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; パラメータは、どちらかであります</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">厳密性アナライザーは、関数内の引数と変数をいつ「厳密に」処理できるかを計算します（つまり、これらは常に関数内のある時点で評価されます）。これにより、GHCは、遅延引数に適用されるとプログラムのセマンティクスを変更するために適用されないアンボックスなど、特定の最適化を適用できます。</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">ユーザーがソースコードで書いた通りのフィールドの厳しさ。例えば、以下のデータ型では</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">コンパイル中にGHCがフィールドを推測する厳密さ。 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; には9つの異なる組み合わせがありますが、GHCが決定する厳密性は、最終的に遅延、厳密、またはアンパックのいずれかになります。GHCが決定する内容は、ユーザーがソースコードに書き込んだ内容とGHCフラグの両方に影響されます。例として、次のデータ型を考えます。</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">コンパイラがセレクタに対して推論した厳しさは、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">このモジュールの文字列機能は、矢印キーやファンクションキーなどのユーザー入力に対応する文字列です。</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">パッケージ名の後の括弧内の文字列は、インストールされたパッケージIDです。通常、パッケージ名とバージョンで始まり、コンパイルされたパッケージから派生したハッシュ文字列で終わります。パッケージ間の依存関係は、パッケージとバージョンだけでなく、インストール済みのパッケージIDで表現されます。たとえば、 &lt;code&gt;haskell98&lt;/code&gt; パッケージの依存関係を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">有向グラフの強く接続された構成要素を逆トポロジカルにソートしたもの。</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">有向グラフの強く接続されたコンポーネント。トポロジー的にソートされています。この関数は、各ノードに関するすべての情報が保持される &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; を除いて、strongConnComp と同じです。このインターフェースは、 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; の結果（の一部）に &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; を適用する予定がある場合に使用されるため、依存関係情報を失いたくない。</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">グラフの強く接続された構成要素を、逆トポロジー順に並べたもの。</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">&lt;code&gt;n+k&lt;/code&gt; パターンでの減算演算、およびより大きいか等しいテストでは、スコープ内にある &lt;code&gt;(-)&lt;/code&gt; および &lt;code&gt;(&amp;gt;=)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">入力が不十分なためにデコードできなかった &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のサフィックス。</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; を一般化したアクションのコレクションの合計。</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アクションのコレクションの合計 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 一般化します。</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アクションのコレクションの合計 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 一般化します。ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">アクションのコレクションの合計 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 一般化します。ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">スーパークラスのインスタンスは以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">GHC で定義されているシンボルは以下の通りです。お使いのローカルのGHCのインストールでどのシンボルが定義されているかを確認するには、以下のトリックが便利です。</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が受け入れる構文は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; の構文と同じです。</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数が受け入れる構文は、 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; の構文と同じです。</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">パターン同義語の構文とセマンティクスについては、次のサブセクションで詳しく説明します。&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;紙&lt;/a&gt;にはさらに多くの詳細があります。</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">最小限の完全定義の構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">プロンプト &lt;code&gt;*module&lt;/code&gt; の構文は、プロンプトで入力された式のスコープに寄与しているのが「モジュール」の完全な最上位スコープであることを示しています。なければ &lt;code&gt;*&lt;/code&gt; 、モジュールのちょうど輸出が表示されます。</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">構文は</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">構文は、（a）キーワード &lt;code&gt;deriving&lt;/code&gt; 、および（b） &lt;code&gt;where&lt;/code&gt; 部分がないことを除けば、通常のインスタンス宣言の構文と同じです。</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">構文は、選択肢の本体が式ではなくコマンドであることを除いて、 &lt;code&gt;case&lt;/code&gt; 式の場合と同じです。変換は &lt;code&gt;if&lt;/code&gt; コマンドの変換に似ています。</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">式のコストセンターアノテーションの構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCiプロンプトで受け入れられるステートメントの構文は、Haskell &lt;code&gt;do&lt;/code&gt; 式のステートメントの構文とまったく同じです。ただし、ここではモナドのオーバーロードはありません。プロンプトで入力するステートメントは &lt;code&gt;IO&lt;/code&gt; モナドになければなりません。</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">値の構文はフィールドによって異なります。様々なフィールドタイプがあります。</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">以下の表は、各種類のパターンシノニムが使用できる場所をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 作業についても説明した戦術。さらに、次のものが利用可能です。</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">テンプレートファイル(下記参照)。</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">サブ計算が終了すると（通常または例外を介して）一時記憶域は解放されるため、この関数が戻った後、一時記憶域へのポインターを使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">「未登録」という用語は、実際には「バニラC経由でコンパイル」を意味し、GHCがプログラムを高速化するために通常使用するプラットフォーム固有のトリックの一部を無効にします。未登録でコンパイルする場合、GHCは単にgccを介してコンパイルされるCファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">用語レベルの構文も同様です。先行および先行バー（ &lt;code&gt;|&lt;/code&gt; ）は、それがどの代替案であるかを示します。上記のタイプの2つの用語を次に示します。</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">ファイルの3番目と最後のセクションでは、コスト中心スタックごとのプロファイルの内訳が示されます。これは、プログラムの呼び出しツリーのプロファイルです。上記の例では、 &lt;code&gt;fib&lt;/code&gt; へのコストのかかる呼び出しが &lt;code&gt;main&lt;/code&gt; からのものであることは明らかです。</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">第三のインスタンス宣言はカバレッジ条件に従わない。</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">3番目の種類のインスタンスは、すべての &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; 存在し、2つのバリアントがあります。</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">3番目の種類のワイルドカードは、&lt;em&gt;追加制約ワイルドカード&lt;/em&gt;です。追加の制約ワイルドカードの存在は、型チェック中に任意の数の追加の制約が推測され、型シグネチャに追加されることを示しています。以下の例では、追加の制約ワイルドカードを使用して、3つの追加の制約を推測しています。</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">スレッドは &lt;code&gt;MVar&lt;/code&gt; でブロックされていますが、 &lt;code&gt;MVar&lt;/code&gt; への他の参照がないため、続行できません。</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">スレッドはSTMトランザクションの再試行を待機していますが、 &lt;code&gt;TVar&lt;/code&gt; への参照が他にないため、続行できません。</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">外部呼び出しを行うスレッドには、 &lt;code&gt;pthread_kill()&lt;/code&gt; を使用して &lt;code&gt;SIGPIPE&lt;/code&gt; シグナルが送信されます。これは通常、ブロッキングシステムコールが &lt;code&gt;EINTR&lt;/code&gt; で戻るのに十分です（GHCはデフォルトで &lt;code&gt;SIGPIPE&lt;/code&gt; の空のシグナルハンドラーをインストールし、プロセスをすぐに終了するというデフォルトの動作をオーバーライドします）。</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">スレッドランタイムシステムは、以下のようなメリットを提供します。</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">プログラムの特定の部分で発生した時間と割り当ては、このコストセンタースタックだけでカバーされるコードによって発生するコストである「個別」と、すべてで発生するコストを含む「継承」の2つの方法で表示されます。このノードの子。</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">GC中の経過時間</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">GC前の同期中の経過時間</target>
        </trans-unit>
        <trans-unit id="4b330c6f47b52569d23f62fae825fc0e09a81ec0" translate="yes" xml:space="preserve">
          <source>The time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">同時進行の非可動GCのマーク後の一時停止段階での経過時間。</target>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">時間ロケール。</target>
        </trans-unit>
        <trans-unit id="1637c3729549ceeb82c37601b6dec6b827e71006" translate="yes" xml:space="preserve">
          <source>The time profiling mode enabled by &lt;a href=&quot;profiling#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; also emits sample events to the eventlog. At the start of profiling the tick interval is emitted to the eventlog and then on each tick the current cost centre stack is emitted. Together these enable a user to construct an approximate track of the executation of their program.</source>
          <target state="translated">The time profiling mode enabled by &lt;a href=&quot;profiling#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; also emits sample events to the eventlog. At the start of profiling the tick interval is emitted to the eventlog and then on each tick the current cost centre stack is emitted. Together these enable a user to construct an approximate track of the executation of their program.</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">時間値、または指定された形式を使用して入力を解析できなかった場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="806aa42ce85483bc45bf5f50020217f50c8cf737" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">時間値です。</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">プログラムが実行全体に渡って割り当てたバイト数の合計。</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">実行されたゴミ収集の総数。</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">秒単位でのプログラム実行の合計ウォールタイム。</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IOの実行時に、トランザクションがメモリの一貫性のないビューを表示した可能性があります。トランザクションの実装方法が原因で、プログラム全体で真であると予想される不変条件は、トランザクション内では真にならない場合があります。通常、これはプログラマーには見えませんが、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を使用すると公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IOの実行時に、トランザクションがメモリの一貫性のないビューを表示した可能性があります。トランザクションの実装方法が原因で、プログラム全体で真であると予想される不変条件は、トランザクション内では真にならない場合があります。通常、これはプログラマーには見えませんが、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; を使用すると公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">この翻訳は、再帰的バインディングや多相バインディング、また単純な非再帰的バインディングのために、バングパターンを意味のあるものにするために慎重に作られています。</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">このようなフォームの変換では &lt;code&gt;loop&lt;/code&gt; コンビ &lt;code&gt;ArrowLoop&lt;/code&gt; 使用されるため、関係する矢印はArrowLoopクラスに属している必要があります。</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">モナドを等価なモナドにマッピングするトリビアルモナド変換器。</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">孤立の問題は、インスタンスまたはルールが役割を果たす場合に備えて、GHCがすべての孤立したモジュールのインターフェイスファイルを事前に読み取る必要があることです。それ以外の場合は、モジュールのインターフェイスは役に立ちます。詳細については、&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立モジュールとインスタンス宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">後者は型変数をスコープに入れる可能性があることを除いて、2つは同じに扱われます（&lt;a href=&quot;#scoped-type-variables&quot;&gt;字句的にスコープされた型変数を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">2つのコンストラクターには、期待するタイプがあります。</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">2つの関数 &lt;code&gt;comp1&lt;/code&gt; と &lt;code&gt;comp2&lt;/code&gt; は同じセマンティクスを持ってい &lt;code&gt;comp1&lt;/code&gt; が、comp1は&lt;em&gt;2つの&lt;/em&gt;引数に適用されるとインライン化されますが、 &lt;code&gt;comp2&lt;/code&gt; には&lt;em&gt;3つ&lt;/em&gt;必要です。あなたが言うなら、これは大きな違いを生むかもしれません</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">2つのオプションセットは、次のように初期化されます。最初に、両方のオプションセットが、&lt;a href=&quot;#ghci-dot-files&quot;&gt;.ghciおよび.haskelineファイルで&lt;/a&gt;説明されているように初期化されます。次に、インタラクティブオプションが次のように変更されます。</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">オプションの2つのセットは、引数なしでそれぞれ&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;コマンドを使用して検査できます。たとえば、クリーンなGHCiセッションでは次のようになります。</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のいずれかである値のタイプです。 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクタはのみで使用することができます &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; sの、そして &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクタにのみに使用することができます &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （S）</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; は、外国語で維持されるオブジェクトへの参照を表します。つまり、Haskellストレージマネージャーによって通常管理されるデータ構造の一部ではありません。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; とタイプ &lt;code&gt;Ptr a&lt;/code&gt; のバニラメモリ参照の本質的な違いは、前者が&lt;em&gt;ファイナライザ&lt;/em&gt;に関連付けられている可能性があることです。ファイナライザは、HaskellストレージマネージャがHaskellヒープとスタック内で、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を指している参照が残っていないことを検出したときに呼び出されるルーチンです。通常、ファイナライザは次に、外部オブジェクトによってバインドされたリソースを解放する外部言語のルーチンを呼び出します。</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; は、外国語で維持されるオブジェクトへの参照を表します。つまり、Haskellストレージマネージャーによって通常管理されるデータ構造の一部ではありません。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; とタイプ &lt;code&gt;Ptr a&lt;/code&gt; のバニラメモリ参照の本質的な違いは、前者が&lt;em&gt;ファイナライザ&lt;/em&gt;に関連付けられている可能性があることです。ファイナライザは、HaskellストレージマネージャがHaskellヒープとスタック内で、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を指している参照が残っていないことを検出したときに呼び出されるルーチンです。通常、ファイナライザは次に、外部オブジェクトによってバインドされたリソースを解放する外部言語のルーチンを呼び出します。</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; は、外国語で維持されるオブジェクトへの参照を表します。つまり、Haskellストレージマネージャーによって通常管理されるデータ構造の一部ではありません。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; とタイプ &lt;code&gt;Ptr a&lt;/code&gt; のバニラメモリ参照の本質的な違いは、前者が&lt;em&gt;ファイナライザ&lt;/em&gt;に関連付けられている可能性があることです。ファイナライザは、HaskellストレージマネージャがHaskellヒープとスタック内で、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を指している参照が残っていないことを検出したときに呼び出されるルーチンです。通常、ファイナライザは次に、外部オブジェクトによってバインドされたリソースを解放する外部言語のルーチンを呼び出します。</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; のいずれかである値のタイプです。 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; コンストラクタはのみで使用することができます &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; sの、そして &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; コンストラクタにのみに使用することができます &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （S）</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 型には、役割を表すためのパラメーターがあり、これは一般的に最も一般的なケースです。 &lt;code&gt;Simple Age&lt;/code&gt; は &lt;code&gt;Simple Int&lt;/code&gt; と同じ表現になります。一方、 &lt;code&gt;Complex&lt;/code&gt; 型は、 &lt;code&gt;Complex Age&lt;/code&gt; と &lt;code&gt;Complex Int&lt;/code&gt; が同じでは&lt;em&gt;ない&lt;/em&gt;ため、役割名義にパラメーターがあります。最後に、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Bool&lt;/code&gt; は無関係ですが、 &lt;code&gt;Phant Age&lt;/code&gt; と &lt;code&gt;Phant Bool&lt;/code&gt; 表現は同じです。</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">タイプ &lt;code&gt;StreamPermParser s st a&lt;/code&gt; は順列パーサーを示し、 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 関数によって変換されると、ユーザー状態 &lt;code&gt;st&lt;/code&gt; で &lt;code&gt;s&lt;/code&gt; ストリームを解析し、成功 &lt;code&gt;a&lt;/code&gt; とタイプaの値を返します。</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;a&lt;/code&gt; は、マーシャリング操作を提供する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスのインスタンスになることがよくあります。ただし、これは必須ではなく、ポインタにアクセスするための独自の操作を提供できます。たとえば、C &lt;code&gt;struct&lt;/code&gt; フィールドを取得または設定するための小さな外部関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="6120b118bdba0e4c010f34fbf9eb9b4980f33ce0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;a&lt;/code&gt; は、マーシャリング操作を提供する &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスのインスタンスになることがよくあります。ただし、これは必須ではなく、ポインタにアクセスするための独自の操作を提供できます。たとえば、C &lt;code&gt;struct&lt;/code&gt; フィールドを取得または設定するための小さな外部関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">型 &lt;code&gt;t&lt;/code&gt; は任意の型です。</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">型チェッカーは、エラーメッセージに型環境のフラグメントを表示することがありますが、このフラグによって設定される最大数までしかありません。 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; でオフにすると、数に制限はありません。構文的には最上位のバインディングも通常は除外されます（それらは多数になる可能性があるため）が、 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; にも含まれます。</target>
        </trans-unit>
        <trans-unit id="b4f3436c445b81b9b8c7c9be8963efa0b16fdd8a" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; includes them too.</source>
          <target state="translated">The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; includes them too.</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; は、リフトされた型を安全に強制的に型変換できる型です。より具体的には、リフトタイプ &lt;code&gt;t&lt;/code&gt; と値 &lt;code&gt;x :: t&lt;/code&gt; 場合、 &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; のバリアントです。</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">型コンストラクタ &lt;code&gt;Proxy#&lt;/code&gt; は、いくつかの型変数を監視するために使用されます。これは、モデリングタイプのアプリケーションなどを実行するためにプロキシ値を渡したい場合に使用されます。 &lt;code&gt;Proxy#&lt;/code&gt; 唯一のアンボクシングではない、それはまた、多型の種類があり、何の実行時表現を持っていない、完全に無料であること。</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">型コンストラクタ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; はすべて &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; のバリアントです。</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">タイプ関数 &lt;code&gt;Item&lt;/code&gt; は、構造体 &lt;code&gt;l&lt;/code&gt; のアイテムのタイプを返します。</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">内型 &lt;code&gt;SPECIALIZE&lt;/code&gt; のプラグマは、元の関数の種類未満の多型である任意のタイプであってもよいです。具体的には、元の関数が &lt;code&gt;f&lt;/code&gt; の場合、プラグマ</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">もちろん、型にはクラスのコンテキストも含まれています。</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; のタイプは頭痛の種ですが、操作上はリストフォールドの単純な一般化です。</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; の型はHaskell 98では不正です。これは、クラス型変数（この場合は &lt;code&gt;a&lt;/code&gt; ）のみを制約する制約 &lt;code&gt;Eq a&lt;/code&gt; が含まれているためです。この場合 &lt;code&gt;a&lt;/code&gt; ）。より正確には、クラスメソッドシグネチャの制約は、次の場合に拒否されます。</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 選択肢のいずれかで言及されている任意の自由変数のタイプは、厳密でなければなりません。</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; にインデックス、 &lt;code&gt;e&lt;/code&gt; に要素を持つ不変の非厳密（ボックス化）配列のタイプ。</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">空でないストリームの種類</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; メソッドのタイプは &lt;code&gt;[a]&lt;/code&gt; であり、これはデフォルトのメソッドのタイプでもあります。拡張機能&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;を使用して、この制限を解除し、デフォルトのメソッドに別のタイプを与えることができます。あなたはクラスで列挙の一般的な実装を書かれている場合たとえば、 &lt;code&gt;GEnum&lt;/code&gt; 方法と &lt;code&gt;genum&lt;/code&gt; の面で &lt;code&gt;GHC.Generics&lt;/code&gt; 、あなたは用途一般的な実装ということを、デフォルトの方法を指定することができます。</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">&lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; が示すように、引数のタイプは通常どおり、必要なタイプよりも一般的です。（ &lt;code&gt;reverse&lt;/code&gt; は &lt;code&gt;Ord&lt;/code&gt; 制約を必要としません。）</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 式全体の型は厳密でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">更新される式の型は推論されず、制約解決も行われないので、以下は曖昧なものとして却下されます。</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">オブジェクトのタイプは &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; のインスタンスである必要があります。これにより、単相型のオブジェクトのみが &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; に変換されることが保証されます。ポリモーフィックオブジェクトを &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; に変換するには、モノモーフィックな型シグネチャを与えます。例えば：</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">モナド &lt;code&gt;m&lt;/code&gt; 上で状態 &lt;code&gt;u&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; ストリームを処理する字句パーサーを保持するレコードのタイプ。</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">司法書士の種類は厳格なものでなければならない。</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">型パラメーター &lt;code&gt;c_m&lt;/code&gt; は、 &lt;code&gt;T1&lt;/code&gt; から &lt;code&gt;Tk&lt;/code&gt; の型変数のそれぞれに1回出現します。この条件が満たされないクラスを想像してみてください。例えば：</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">typeパラメータは &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; のインスタンスである必要があります。</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">もちろん、型パラメータはすべて型変数でなければなりませんが、そのうちのいくつか(すべてとは限りませんが)はクラスパラメータになります。各クラスのパラメータは,関連する型ごとに最大一度しか使用できませんが,いくつかは省略してもよいし,クラスの先頭以外の順番で使用してもよいでしょう.したがって、以下のような工夫された例が認められます。</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">このペアの型パターンは、 &lt;code&gt;x&lt;/code&gt; がリストの無限の入れ子に置き換えられた場合に等しくなります。これらのようなインスタンスを拒否することは、型の健全性のために必要です。</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の型シグネチャは、明示的な &lt;code&gt;forall&lt;/code&gt; （&lt;a href=&quot;#decl-type-sigs&quot;&gt;宣言型シグネチャ&lt;/a&gt;）のため、型変数 &lt;code&gt;a&lt;/code&gt; をスコープに入れます。付随する値宣言の定義全体で &lt;code&gt;forall&lt;/code&gt; スコープによってバインドされた型変数。この例では、型変数 &lt;code&gt;a&lt;/code&gt; は、 &lt;code&gt;ys&lt;/code&gt; の型シグネチャを含む &lt;code&gt;f&lt;/code&gt; の定義全体にスコープします。 Haskell 98では、 &lt;code&gt;ys&lt;/code&gt; の型を宣言することはできません。スコープ型変数の主な利点は、そうすることが可能になることです。</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">型クラスのデフォルトメソッドの型シグネチャは、対応するメインメソッドの型シグネチャと同じ形式にする必要があります。それ以外の場合、タイプチェッカーはそのクラスの定義を拒否します。「同じ形式をとる」とは、デフォルトの型シグネチャがメインの型シグネチャとはコンテキストが異なるだけであることを意味します。したがって、メソッド &lt;code&gt;bar&lt;/code&gt; がある場合：</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">インスタンス宣言の型シグネチャは、インスタンス型でインスタンス化されたクラス宣言の型シグネチャよりも(または同じ)多相性が高くなければなりません。例えば、これで構いません。</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">型シグネチャには、結果の型には現れない型変数が定量化されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; の型シグネチャは、その正しさが証明されていない推測に依存することをユーザーに通知します。この機能を使用する場合、ユーザーは依存関係を次のように確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">各コンストラクターの型シグニチャーは独立しており、通常どおり暗黙的に普遍的に数量化されます。特に、「 &lt;code&gt;data T a where&lt;/code&gt; 」ヘッダーの型変数にはスコープがなく、コンストラクターごとにユニバーサルに数量化された型変数が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">サイズとサイズの境界に使用されるタイプ。</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">タイプ変数 &lt;code&gt;a&lt;/code&gt; は他の制約に現れません</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">ここで使用されるタイプ変数 &lt;code&gt;e&lt;/code&gt; は要素タイプを表し、 &lt;code&gt;ce&lt;/code&gt; はコンテナー自体のタイプです。このフレームワーク内で、リストまたは特性関数（どちらも任意の等式タイプのコレクションを表すために使用できる）、ビットセット（文字のコレクションを表すために使用できる）、またはハッシュに対してこのクラスのインスタンスを定義することができます。テーブル（要素がハッシュ関数を持つ任意のコレクションを表すために使用できます）。標準の実装の詳細を省略すると、次の宣言になります。</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">型変数は、型シグネチャの &lt;code&gt;forall&lt;/code&gt; の最も外側にある、構文的に可視の単一の要素によって数量化されます。たとえば、GHCは次の例をすべて拒否します。</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">型変数（指定されている場合）は明示的に分類される可能性があるため、次のように &lt;code&gt;Foo&lt;/code&gt; のヘッダーを記述することもできます。</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">型変数 &lt;code&gt;vk+1...vn&lt;/code&gt; は、型 &lt;code&gt;t&lt;/code&gt; 、 &lt;code&gt;s1..sk&lt;/code&gt; 、または &lt;code&gt;t1..tj&lt;/code&gt; では発生しません。</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; の先頭にある型変数、または &lt;code&gt;where&lt;/code&gt; 部分で定義されたメソッドの &lt;code&gt;instance&lt;/code&gt; 宣言スコープ。明示的な &lt;code&gt;forall&lt;/code&gt; は必要ありません（ &lt;code&gt;instance&lt;/code&gt; 宣言で明示的な &lt;code&gt;forall&lt;/code&gt; が許可されています。&lt;a href=&quot;#explicit-foralls&quot;&gt;明示的なユニバーサル数量化（forall）を&lt;/a&gt;参照）。例えば：</target>
        </trans-unit>
        <trans-unit id="1f03bbab3fd03c0f04b9e0c0fedb642fb00b2844" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="translated">The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; language extension, as in the following example:</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">型ファミリー方程式の右辺の型変数は、いつものように、左辺によって明示的に束縛されなければなりません。ただし、右側には暗黙的にバインドされている種類の変数について言及できるため、この制限は&lt;em&gt;種類の&lt;/em&gt;変数に対しては緩和されています。たとえば、これらは正当です。</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">タイプ変数： &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプレベルの &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">タイプセーフキャスト動作</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 、クラス &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 、およびWord32とFloat、およびWord64とDoubleの間のキャスト。</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; は、タイプレベルのプロキシであり、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; のいくつかのバリアントを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 、およびクラス &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">種類だけではこれらの法律を施行していないので、自分で確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">リファインメントホールフィットの追加のホールのタイプが出力に表示されます。たとえば、 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; は、ホールのリファインメント &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; です。このフラグをオフに切り替えると、出力には &lt;code&gt;foldl1 _&lt;/code&gt; のみが表示されます。これは、 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; を必要とせずに、穴の直接の代替として使用できます。</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">ボックス化されていないタプルの一般的な使用法は、単に複数の値を返し、それらの複数の結果を &lt;code&gt;case&lt;/code&gt; 式にバインドすることです。</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">マップのリストの結合操作による結合。</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">組み合わせ操作でマップのリストの和集合、：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d32217b38bffdaa9ca587e9d6a40f750e6e5bfb9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The union of a list of maps, with a combining operation: ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">組み合わせ操作でマップのリストの和集合、：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b99c2dfae5341557cba637c4f3ef989142689dd9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The union of a list of maps, with a combining operation: ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">地図のリストの結合。</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">マップのリストの結合：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="06da55697aaeea01f68121fc5dda49aec58e2fa9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The union of a list of maps: ( &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">マップのリストの結合：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5359b26f8252c95c2fa3287a62d5ed9a07ab46e7" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">The union of a list of maps: ( &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">セットのリストの和。</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Foldable構造内のセットの和集合：（ &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">このグループの一意の数値 ID (gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">ユニットのタイプ &lt;code&gt;()&lt;/code&gt; とリストタイプ &lt;code&gt;[]&lt;/code&gt; は、タイプのデフォルト設定を行うときに試行されるタイプの標準リストの先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">ユーザーがソースコードで書いた通りのフィールドの展開度。例えば、以下のデータ型では</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">この結果、外部呼び出しでブロックされているHaskellスレッドがある場合、呼び出しが戻るまで &lt;code&gt;hs_exit()&lt;/code&gt; がハング（またはビジー待機）する可能性があります。したがって、 &lt;code&gt;hs_exit()&lt;/code&gt; を呼び出すときは、システムにそのようなスレッドがないことを確認することをお勧めします。これには、I / Oを実行するすべてのスレッドが含まれます。これは、I / Oが、ブロッキング外部呼び出しを使用して実装される場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;を使用して &lt;code&gt;Danger&lt;/code&gt; をコンパイルすると、使用できるHaskellの機能が&lt;a href=&quot;#safe-language&quot;&gt;安全なサブセットに&lt;/a&gt;制限されます。これには、 &lt;code&gt;unsafePerformIO&lt;/code&gt; 、テンプレートHaskell、純粋なFFI関数、RULESの禁止、および重複するインスタンスの操作の制限が含まれます。また、&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;フラグは、 &lt;code&gt;Danger&lt;/code&gt; がインポートできるモジュールを、信頼できると見なされるモジュールのみに制限します。信頼できるモジュールは&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;でコンパイルされたモジュールであり、GHCはコードが安全であることを機械的に保証します。または、モジュールの作成者がモジュールが安全であると主張する&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされたモジュール。</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">存在する型の種類を示す &lt;code&gt;*&lt;/code&gt; の使用は、&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;拡張機能に依存しています。これは、将来のリリースではデフォルトでオフになり、削除される可能性があります。この理由と廃止予定は&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC提案＃30に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">使用 &lt;code&gt;?x&lt;/code&gt; の結合のために &lt;code&gt;?y&lt;/code&gt; バインディング「を参照してください」しません &lt;code&gt;?x&lt;/code&gt; の種類ので、 &lt;code&gt;f&lt;/code&gt; があります</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数の使用はかなり様式化されています- &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; な言語定義をインポートし、結果のGenTokenParserから必要な字句パーサーを選択します。</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数の使用はかなり様式化されています- &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; な言語定義をインポートし、結果のGenTokenParserから必要な字句パーサーを選択します。</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">コストセンター・スタックの有用性は、例を少し修正することでよりよく示されます。</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">ユーザーはオプションで、特にコンパイラーが&lt;a href=&quot;#default-deriving-strategy&quot;&gt;デフォルトで&lt;/a&gt;間違ったものを選択した場合に、必要な&lt;a href=&quot;#deriving-stragies&quot;&gt;派生方法を&lt;/a&gt;宣言できます。</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">ユーザーデータベース</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">通常の出力ストリームは &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; です。（stderrのない）Windows GUIアプリケーションの場合、出力はWindowsデバッグコンソールに送られます。これらの関数の実装によっては、出力されている文字列を修飾して、トレースしていることを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">配列の指定されたインデックスの値。</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">メジャーリリース &lt;code&gt;x.y.z&lt;/code&gt; の &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; （「&lt;a href=&quot;phases#c-pre-processor&quot;&gt;Cプリプロセッサに影響するオプション」を&lt;/a&gt;参照）の値は整数「xyy」です（「y」が1桁の場合、先頭にゼロが追加されるため、たとえばバージョン6.8.2の場合）。 GHCの場合、 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">スナップショットリリースの &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; の値は整数「xyy」です。ただし、この値をテストする条件付きコードは決して記述しないでください。インターフェイスは日常的に変化し、 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; の値に細かい粒度がないため、テストを行う述語を使用して条件付きでのみコンパイルする必要があります &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; が特定のメジャーリリースと同じか、それ以降か、それより前か。</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">&lt;code&gt;seq a b&lt;/code&gt; の値は、 &lt;code&gt;a&lt;/code&gt; がボトムの場合はボトム、それ以外の場合は &lt;code&gt;b&lt;/code&gt; と等しくなります。つまり、最初の引数 &lt;code&gt;a&lt;/code&gt; を弱頭正規形（WHNF）として評価します。 &lt;code&gt;seq&lt;/code&gt; は通常、不要な遅延を回避してパフォーマンスを向上させるために導入されます。</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">コンパイル/リンク時のGHCフラグ &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; の値。</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">変数の型は多態性ではなく、is &lt;code&gt;()&lt;/code&gt; ではなく、 &lt;code&gt;Show&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">定義の左側の変数は、右側のパターンに拘束されます。双方向パターン同義語の場合、右辺のすべての変数は左辺にも発生しなければならず、また、ワイルドカードパターンやビューパターンも許されない。一方向性と明示的に双方向性のパターン同義語の場合、右側のパターンには制限はありません。</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">ランタイムのバリアント（「ウェイ」）。最も一般的な値は、 &lt;code&gt;rts_v&lt;/code&gt; （バニラ）、 &lt;code&gt;rts_thr&lt;/code&gt; （スレッド化されたランタイム、つまり&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;オプションを使用してリンクされている）および &lt;code&gt;rts_p&lt;/code&gt; （プロファイリングランタイム、つまり&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;オプションを使用してリンクされている）です。その他のバリアントには、 &lt;code&gt;debug&lt;/code&gt; （&lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt;を使用してリンク）と &lt;code&gt;dyn&lt;/code&gt; （RTSは、実行可能ファイル自体に静的にリンクされるのではなく、動的に、つまり共有ライブラリにリンクされます）が含まれます。これらは組み合わせることができます。たとえば、 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">さまざまな通信プロセスは、スタティックポインタテーブルの値を参照するために使用されるキーについて 合意する必要があるが、そうしないとルックアップが失敗する。同じプログラムバイナリから起動されたプロセスのみが、同じキーセットを使用することが保証される。</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">GHCのコピーのバージョン番号は呼び出すことによって見つけることができる &lt;code&gt;ghc&lt;/code&gt; して &lt;code&gt;--version&lt;/code&gt; する（参照フラグ&lt;a href=&quot;using#options-help&quot;&gt;冗長性オプションを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">プログラムのコンパイルに使用された、または解釈されている &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; のバージョン。</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">このプログラムのコンパイルに使用したGHCのバージョン。</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">強く連結された構成要素のリストの頂点。</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">強く連結された構成要素の頂点。</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">関連するファミリインスタンスの右側にあるクラスパラメータの可視性は、ファミリのパラメータに&lt;em&gt;のみ&lt;/em&gt;依存します。例として、単純なクラス宣言を考えます</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">警告&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; は&lt;/a&gt;、デフォルトではオフになっていますが、&lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt;に含まれていますが、インポートしたモジュールがエクスポートしないものを非表示にすると警告します。</target>
        </trans-unit>
        <trans-unit id="5369ef220638dc82aaace3093ac85be8f6ea055a" translate="yes" xml:space="preserve">
          <source>The warning &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (off by default) reports on any occurrences of imports annotated &lt;code&gt;qualified&lt;/code&gt; using prepositive syntax.</source>
          <target state="translated">The warning &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (off by default) reports on any occurrences of imports annotated &lt;code&gt;qualified&lt;/code&gt; using prepositive syntax.</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">アンダースコアで始まる名前の場合、警告は抑制されます。例えば</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">フィールド名がアンダースコアで始まる場合、警告は抑制されます。</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">警告は、重複した &lt;code&gt;Eq a&lt;/code&gt; 制約を示します。</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">警告は冗長な &lt;code&gt;Eq a&lt;/code&gt; 制約を示します：： &lt;code&gt;f&lt;/code&gt; の定義では使用されません。）</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">警告は、冗長な &lt;code&gt;Eq a&lt;/code&gt; 制約を示します。これは、 &lt;code&gt;Ord a&lt;/code&gt; 制約によって包含されます。</target>
        </trans-unit>
        <trans-unit id="6b81d66b467d23d7422d611d2f4898b0e6c539b7" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt; , to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">予測可能な動作を取得する方法は使用することです&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; の&lt;/a&gt;上で、プラグマ、またはインライン[⟨phase⟩]プラグマを &lt;code&gt;f&lt;/code&gt; 、そのルールが火にチャンスがあったまでそれがインライン化されていないことを保証するために、。警告フラグ&lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（「&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告と&lt;/a&gt;正常性チェック」を参照）は、この状況について警告します。</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">このような状況を特定する方法は、データ型、クラス、および型の同義語の型変数に割り当てられた&lt;em&gt;役割&lt;/em&gt;を持つことです。</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">このライブラリのウィークポインタは、&lt;em&gt;ファイナライズ&lt;/em&gt;と呼ばれる別のアプローチをサポートしています。ウィークポインターによって参照されるキーが無効になると、ストレージマネージャーはプログラマーが指定したファイナライザーを実行するように調整します。たとえば、メモテーブルの場合、ファイナライザはメモテーブルからキーと値のペアを削除できます。</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">回避策は、パッケージを構成する.oファイルを、 &lt;code&gt;base&lt;/code&gt; パッケージが行う方法に沿って、2つ以上の.oに分割することです。</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">ワーキングディルクトリー</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">ラッパーと一般的なデフォルト</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">ジップ： &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">「クォータ」は「 &lt;code&gt;e&lt;/code&gt; 」、「 &lt;code&gt;t&lt;/code&gt; 」、「 &lt;code&gt;d&lt;/code&gt; 」、または「 &lt;code&gt;p&lt;/code&gt; 」にすることはできません。テンプレートHaskellの引用と重複しているためです。</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">⟨quoter⟩は、インポートされたクォータの名前でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">次に、 &lt;code&gt;Foo_stub.h&lt;/code&gt; には次のようなものが含まれます。</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">次に、 &lt;code&gt;Parser&lt;/code&gt; は &lt;code&gt;MonadPlus&lt;/code&gt; のインスタンスです。モナディックシーケンスは、パーサーの連結を実装し、 &lt;code&gt;mplus&lt;/code&gt; は選択肢を提供します。パーサーを使用するには、入力文字列に対して構築されたパーサーを実行するためのプリミティブが必要です。</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">次に、 &lt;code&gt;bar&lt;/code&gt; のデフォルトのメソッドは次の形式を取る必要があります。</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;stdout2&lt;/code&gt; を使用して標準出力に書き込むことができますが、 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; はそうではありません。</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">そして、アプリカティブデシュガーリングは、それを</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">次に、ユーザーが作成した変数が暗黙的に型変数の種類のスコープに組み込まれます。</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">その後、再びそれをコンパイル&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;、さらに使い &lt;code&gt;-osuf p_o&lt;/code&gt; 異なったオブジェクト・ファイルに名前を付けます（ここでは通常のオブジェクトのサフィックスではありません任意のサフィックスを選択することができます）。GHCは、スプライス式を実行するときに、最初のステップで構築されたオブジェクトファイルを自動的にロードします。あなたは省略した場合 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; を構築する際にフラグを&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;とテンプレートHaskellは使用され、GHCはエラーメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">次に、一部のインポートモジュール &lt;code&gt;M&lt;/code&gt; で、制約 &lt;code&gt;(E a Int)&lt;/code&gt; を &lt;code&gt;a = T&lt;/code&gt; に設定して「改善」する必要が&lt;em&gt;あります。ただし&lt;/em&gt;、 &lt;code&gt;M&lt;/code&gt; に &lt;code&gt;T&lt;/code&gt; &lt;em&gt;の明示的な言及はありません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">その後、 &lt;code&gt;HigherEq Option&lt;/code&gt; インスタンスを派生させることが可能になります。唯一の違いは、 &lt;code&gt;(==#)&lt;/code&gt; のデフォルト以外の型シグネチャが &lt;code&gt;Eq a&lt;/code&gt; 制約をもたらすことです。デフォルト以外のタイプシグネチャからの制約は、派生インスタンスコンテキスト自体には表示されませんが、デフォルトのタイプシグネチャによって要求される義務を解放するために使用できます。上記の例では、デフォルトのタイプシグネチャは &lt;code&gt;Eq a&lt;/code&gt; インスタンスを要求し、デフォルト以外のシグネチャはその要求を満たすことができたため、派生インスタンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">すると、その旨のエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">次に、派生した &lt;code&gt;Foo&lt;/code&gt; インスタンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">すると、派生インスタンス宣言は次のような形式になります。</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">次に、パーサーは実行する &lt;code&gt;tick&lt;/code&gt; 追跡します。</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">その後、プログラムの残りの部分は、構築されたフラグのリストを使用して動作を決定します。</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">次に、 &lt;code&gt;args.txt&lt;/code&gt; を使用して &lt;code&gt;foo&lt;/code&gt; を呼び出した結果は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">そうすると、こんな感じでプログラムを実行することができます。</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">その後、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; プリミティブの上に、 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 独自のバージョンを実装できます。</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">あり&lt;em&gt;、多くの&lt;/em&gt; GHCにより生成されたコードの品質に影響するオプションが。ほとんどの人は、「すぐにコンパイルする」または「油を塗ったようにプログラムを実行させる」のような一般的な目標しか持っていません。次の最適化（またはその欠如）の「パッケージ」で十分です。</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将来的に削除されると期待されるいくつかの警告があります：このオプションは現在Windowsでは実装されておらず（何もしない）、外部インタープリターはGHCiデバッガーをサポートしていないため、ブレークポイントとシングルステップドン&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;と一緒に使用しないでください。</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">タイプされた穴に表示されるコンテキスト情報の量を制御するためのフラグがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">他にもいくつかのプロファイリング関連のコンパイルオプションがあります。&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt;に加えて&lt;/em&gt;使用します。これらは、プログラムのすべてのモジュールで一貫して使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">ここで注意すべき点がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">次のような &lt;code&gt;case&lt;/code&gt; コマンドもあります</target>
        </trans-unit>
        <trans-unit id="1279203c2e0d157a8d9dad524a1fc81607cfc8e4" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt;&lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt; &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">現在、有効な穴あけをソートするには2つの方法があります。ソートは &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; で切り替えることができます</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">オブジェクトコードへのコンパイルには欠点があります。たとえば、オブジェクトコードモジュールにブレークポイントを設定することはできません。解釈されたモジュールのようにすべてのトップレベルのバインディングではなく、オブジェクトコードモジュールのエクスポートのみがGHCiに表示されます。</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">（既存の）キーワードによって導入理解予選の5つの新しいフォーム、すべてがあり &lt;code&gt;then&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">RTSのオプションを設定するには4つの方法があります。</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">パラメータである位置と再帰的呼び出しである位置を区別しないデータ型汎用関数が多数存在します。また、データ型やコンストラクタの名前を全く気にしないデータ型汎用関数も数多く存在します。このような状況で汎用関数で考慮すべきケースの数を最小限に抑えるために、上で紹介した型コンストラクタの多くは実際には同義語であり、より小さなコンストラクタのセットの亜種であると定義されていることが判明しました。</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">生成できるプロファイルには、さまざまな RTS オプションで選択された多くの種類があります。この章の残りの部分では、様々な種類のプロファイルについて説明します。いくつかのプロファイルは、プログラムを実行した後、追加のツールを使用してさらに処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">このクラスの定義済みインスタンスはありません。デフォルトではスコープ内にありませんが、&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;をインポートすることでスコープに含めることができます。異なり &lt;code&gt;IsString&lt;/code&gt; 、のための特別な不履行ルールはありません &lt;code&gt;IsLabel&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="70d1d2c96409db371b4aa9bd1644711aa1fc1d7d" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt; , there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">実行可能なスレッドがないため、プログラムはデッドロックしています。 &lt;code&gt;Deadlock&lt;/code&gt; 例外は、メインスレッドだけで育てられています。</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; による&lt;/a&gt;構文の変更はありません。ソースレベルで表示される唯一の方法は、 &lt;code&gt;Monad&lt;/code&gt; 制約を必要としない &lt;code&gt;do&lt;/code&gt; 式を使用できることです。たとえば、GHCiの場合：</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">渡すタイプ &lt;code&gt;V1 p&lt;/code&gt; の値がないため（未定義を除く）、これは実際には不可能です。この場合、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; のインスタンスを定義することがなぜ有用なのかを尋ねることができますか？まあ、空の型は空ではない型の引数として使用でき、それでも結果の型をエンコードしたいかもしれません。少し不自然な例として、空のタイプではなく、空のリストのみが含まれている &lt;code&gt;[Empty]&lt;/code&gt; を考えてみましょう。 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; のインスタンスは、私たちは、このようなタイプに汎用関数を呼び出すことができることを保証します。</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">何らかの例外を本当にキャッチする必要がある場合があります。ただし、ほとんどの場合、これは単にクリーンアップを実行できるようにするためのものです。あなたは実際には例外自体に興味がありません。たとえば、ファイルを開いた場合、ファイルの処理が正常に実行されるか、例外がスローされるかに関係なく、ファイルを再度閉じます。ただし、これらのケースでは、実際には例外を渡さず、適切なポイントでクリーンアップ関数を呼び出すだけの、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; などの関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="68320e8b907613c7782553698755865907bc858f" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags.</source>
          <target state="translated">There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt; flags.</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">表現にアクセスするプラグインを定義するために使用できるいくつかの異なるアクセスポイントがあります。これらのフィールドはすべて、 &lt;code&gt;-fplugin-opt&lt;/code&gt; フラグを使用してコンパイラーに渡される &lt;code&gt;CommandLineOption&lt;/code&gt; 文字列のリストを受け取ります。</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">生成されるヒーププロファイルにはいくつかの異なる種類があります。すべての異なるプロファイルタイプは、時間に対するライブヒープのグラフを生成しますが、ライブヒープをバンドに分解する方法が異なります。以下の RTS オプションは、使用するブレークダウンを選択します。</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">例外をキャッチして調べるための関数がいくつかあります。これらはすべて、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド内からのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">ガベージコレクションを正確に制御するためのオプションがいくつかあります。うまくいけば、通常の操作ではこれらのいずれも必要ありませんが、最大のパフォーマンスを得るために調整できることがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; が提供する他のいくつかのHaskellおよびGHC関連のメーリングリストがあります。完全なリストについては、&lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http：&lt;/a&gt; //www.haskell.org/mailman/listinfo/にアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">ここで注意すべき点がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">実在的に数値化されたコンストラクタを使用する方法には、いくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="93f0614d42022b318b6c7e89cd2bff7336dde820" translate="yes" xml:space="preserve">
          <source>There are some limitations when using this. File and process IO will be executed on the target. As such packages like &lt;code&gt;git-embed&lt;/code&gt;, &lt;code&gt;file-embed&lt;/code&gt; and others might not behave as expected if the target and host do not share the same filesystem.</source>
          <target state="translated">There are some limitations when using this. File and process IO will be executed on the target. As such packages like &lt;code&gt;git-embed&lt;/code&gt; , &lt;code&gt;file-embed&lt;/code&gt; and others might not behave as expected if the target and host do not share the same filesystem.</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">派生 &lt;code&gt;Foldable&lt;/code&gt; インスタンスを持つことができるデータ型には、他にもいくつかの違いがあります。</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">派生 &lt;code&gt;Functor&lt;/code&gt; インスタンスがコンパイルに失敗するシナリオは他にもいくつかあります。</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">プリミティブ型の使用にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">アンボックス化されたタプルの使用にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">ヒーププロファイリングに関連するオプションは、さらに3つあります。</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">3つの新しいキーワードがあります： &lt;code&gt;group&lt;/code&gt; 、 &lt;code&gt;by&lt;/code&gt; 、 &lt;code&gt;using&lt;/code&gt; 。（関数 &lt;code&gt;sortWith&lt;/code&gt; および &lt;code&gt;groupWith&lt;/code&gt; はキーワードではありません。これらは &lt;code&gt;GHC.Exts&lt;/code&gt; によってエクスポートされる通常の関数です。）</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">現在のコールスタックにアクセスするには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="18668df28a2960d99f735bbd24797ff6843bd893" translate="yes" xml:space="preserve">
          <source>There are two access points are bundled together for defining hole fit plugins, namely a candidate plugin and a fit plugin, for modifying the candidates to be checked and fits respectively.</source>
          <target state="translated">ホールフィットプラグインを定義するためのアクセスポイントは2つあり、それぞれチェックする候補を修正するための候補プラグインとフィットプラグインです。</target>
        </trans-unit>
        <trans-unit id="0e7482a52c288e2a6aa7c273bf0bcf1dbfeabe7e" translate="yes" xml:space="preserve">
          <source>There are two classes of event types:</source>
          <target state="translated">イベントタイプには2つのクラスがあります。</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">特殊構文には2つのクラスがあります。</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLLを使用する方法には、2つの異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">このルールには2つの例外があります。</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; には、さらに2つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">このデコーダを実行するには、遅延入力方式と増分入力方式の2種類の方法があります。ここでは遅延入力方式を使用します。</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">シーケンスとリストの違いは大きく分けて2つあります。</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">このカウンターでできることは2つあります。</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">browseコマンドには2つのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">これらのプラグマの使い方には2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">複数のプロセッサでプログラムを実行するには、2つの方法があります。プログラムから&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;を呼び出すか、RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="54084616a21d75658db0216e6ad990b71f0f3457" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt; options.</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">ファイルヘッダープラグマは好きなだけあり、コメントの前にも後にもつけることができます。</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">関連付けられた型のシノニムには、最大1つのデフォルト宣言があります。</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hs_init()&lt;/code&gt; への複数の呼び出しが存在する可能性がありますが、各呼び出しは &lt;code&gt;hs_exit()&lt;/code&gt; への1つ（そして1つだけ）の呼び出しと一致する必要があります。最も外側の &lt;code&gt;hs_exit()&lt;/code&gt; は、実際にはシステムを初期化解除します。現在、GHCのランタイムは、これが発生した後に確実に再初期化できないことに注意してください。&lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;外部関数インターフェイスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">「内訳」オプションは1つしかありません（例：上記の例では&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;）。ただし、適用できる追加の制限の数に制限はありません。1つの例外を除いて、すべてのオプションを組み合わせることが&lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt;ます&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;は現在、-hrオプションと-hbオプションの混在をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">タイプ &lt;code&gt;RtsConfig&lt;/code&gt; の変数を初期化するために使用する必要があるデフォルト値 &lt;code&gt;defaultRtsConfig&lt;/code&gt; があります。間違いなく将来的にはさらに多くのフィールドが &lt;code&gt;RtsConfig&lt;/code&gt; に追加されるため、コードを上位互換に保つためには、上記のコードサンプルのように、 &lt;code&gt;defaultRtsConfig&lt;/code&gt; で初期化してから必要なフィールドを変更するのが最善です。</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;には、コンパイルの安全性に関連する問題といくつかの潜在的な解決策の詳細な議論があります。</target>
        </trans-unit>
        <trans-unit id="7ef9b54093e73b5247e6192453bb1d4451bfc02a" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; を&lt;a href=&quot;control-monad#v:return&quot;&gt;返すことの&lt;/a&gt; 間には微妙な違いがあります！ xは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; の違いに似ています。遅延値 &lt;code&gt;x&lt;/code&gt; が例外をスローした場合、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;返し&lt;/a&gt; ます。 xは &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを返せず、代わりに例外をスローします。一方、 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-exception#v:evaluate&quot;&gt;評価&lt;/a&gt;すると、常に &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが生成されます。そのアクションは、時に例外がスローされます&lt;em&gt;実行&lt;/em&gt;場合に限っ &lt;code&gt;x&lt;/code&gt; 時に例外をスロー&lt;em&gt;評価&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="566104a98981fe95741524bb050f2354c55f9f53" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; を&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;評価して&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; を&lt;a href=&quot;control-monad#v:return&quot;&gt;返すことに&lt;/a&gt; は微妙な違いがあります！ x、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; の違いに類似しています。遅延値 &lt;code&gt;x&lt;/code&gt; が例外をスローした場合は、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;返し&lt;/a&gt; ます。 xは &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを返すことに失敗し、代わりに例外をスローします。一方、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; は、常に &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを生成します。 &lt;code&gt;x&lt;/code&gt; が&lt;em&gt;評価&lt;/em&gt;時に例外をスローする場合、そのアクションは&lt;em&gt;実行&lt;/em&gt;時に例外をスローします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; を&lt;a href=&quot;control-monad#v:return&quot;&gt;返すことの&lt;/a&gt; 間には微妙な違いがあります！ xは、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; の違いに似ています。遅延値 &lt;code&gt;x&lt;/code&gt; が例外をスローした場合、 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;control-monad#v:return&quot;&gt;返し&lt;/a&gt; ます。 xは &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを返せず、代わりに例外をスローします。一方、 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; &lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;評価&lt;/a&gt;すると、常に &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが生成されます。そのアクションは、時に例外がスローされます&lt;em&gt;実行&lt;/em&gt;場合に限っ &lt;code&gt;x&lt;/code&gt; 時に例外をスロー&lt;em&gt;評価&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デッドロック検出とファイナライザ（ &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; または&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;の関数によって作成された）の間には微妙な相互作用があります。スレッドがファイナライザの実行を待機してブロックされている場合、スレッドはデッドロックと見なされ、例外が送信されます。できればこれを行わないでください。ただし、代替手段がない場合は、 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; を指すようにすることで、スレッドがデッドロックと見なされないようにすることができます。後で &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; を解放することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">不正な文字がどのように処理されるかを指定するための追加の記法があります (GNU iconv からの借用)。</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">&lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;スマートコンストラクターの&lt;/a&gt;広範なHaskellフォークアートがあります。本質的には、コンストラクターの周りに検証をラップし、その表現を公開しないようにする関数です。欠点は、基礎となるコンストラクターをマッチャーとして使用できないことです。パターンの同義語は、検証とマッチングの両方で、本当にスマートなコンストラクターとして使用できます。</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">プロファイリング自体のオーバーヘッドがあり、それはプロファイラによって居住地の数値から差し引かれます。このオーバーヘッドは、プロファイリングをサポートしないでコンパイルすれば、もちろんなくなります。スペースのオーバーヘッドは、現在のところ、ヒープオブジェクトごとに2つの余分なワードがあり、おそらく30%程度のオーバーヘッドになります。</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">現在、「スタックトレース」を取得するためのサポートはありませんが、トレースおよび履歴機能は、エラーのコンテキストを確立するのに十分な場合が多い、次善の有用な機能を提供します。たとえば、コンパイルされたコード内から例外がスローされた場合でも、例外がスローされると自動的にブレークすることができます（&lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;例外のデバッグを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; の値は1つだけなので、それをエンコードするための知識は必要ありません。ゼロビットを使用できます。</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ZonedTime&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; インスタンスはありません。現地時間を比較する場合は、 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; を使用します。絶対時間を比較する場合は、 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="19ed2f198aae585d94d8de2a49be348554775e93" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">There is no &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt; . If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; . If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">&lt;code&gt;deRefStableName&lt;/code&gt; オペレーションはありません。安定した名前から元のHaskellオブジェクトに戻すことはできません。この理由は、オブジェクトの安定した名前の存在は、オブジェクト自体の存在を保証するものではないためです。それでもガベージコレクションは可能です。</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">何もありません &lt;code&gt;freeStableName&lt;/code&gt; の操作は異なり、&lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;秒。安定した名前は、不要になったときにランタイムシステムによって再利用されます。</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{-# UNPACK #-}&lt;/code&gt; は{-＃UNPACK＃-}または &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; アノテーションがないため、 &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; でタグ付けされています。</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">読み取る前にクライアントは常に &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; を呼び出すため、読み取りバッファーに対応する操作はありません。</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">既存の型の名前を変更するだけのnewtypesには何の影響もありません。例えば</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">評価の順序についての保証はありません。実装は、構造のコンポーネントを任意の順序または並列で評価できます。評価に実際の順序を課すには、 &lt;code&gt;parallel&lt;/code&gt; パッケージの&lt;a href=&quot;control-parallel&quot;&gt;Control.Parallelの&lt;/a&gt; &lt;code&gt;pseq&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは、任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;安全なポイント&lt;/em&gt;に達したときにのみ例外が発生します。安全なポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは、任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;安全なポイント&lt;/em&gt;に達したときにのみ例外が発生します。安全なポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは、任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;安全なポイント&lt;/em&gt;に達したときにのみ例外が発生します。安全なポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ランタイムは、任意の遅延が発生しないように努めますが、例外が迅速に配信される保証はありません。GHCでは、スレッドが&lt;em&gt;安全なポイント&lt;/em&gt;に達したときにのみ例外が発生します。安全なポイントとは、メモリの割り当てが行われる場所です。一部のループは、ループ内でメモリ割り当てを実行しないため、 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; によって中断できません。</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">遅延の期限が切れたときにスレッドがすぐに再スケジュールされる保証はありませんが、スレッドが指定&lt;em&gt;より&lt;/em&gt;も&lt;em&gt;早く&lt;/em&gt;実行され続けることは決してありません。</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">すべてのソースファイルを &lt;code&gt;ghc -M&lt;/code&gt; コマンドの引数としてリストする必要はありません。 &lt;code&gt;ghc&lt;/code&gt; は、 &lt;code&gt;ghc --make&lt;/code&gt; （GHC 6.4の新機能）と同様に、依存関係をトレースします。</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">ソースには &lt;code&gt;'NoSourceStrictness&lt;/code&gt; （ &lt;code&gt;!&lt;/code&gt; ）またはlaziness（ &lt;code&gt;~&lt;/code&gt; ）アノテーションがないため、'NoSourceStrictnessでタグ付けされています。</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">&lt;code&gt;Danger&lt;/code&gt; がインポートできるモジュールを制限する方法はありません。これにより、 &lt;code&gt;Danger&lt;/code&gt; の作者は非常に大きな攻撃対象となります。基本的に、現在システムにインストールされているすべてのパッケージです。これらのパッケージのいずれかに脆弱性がある場合、 &lt;code&gt;Danger&lt;/code&gt; モジュールがそれを悪用する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">初期データ以外の入力を増やす方法はありません。より多くのデータをインクリメンタルに与えることができるようにするには、インクリメンタル入力インターフェースを参照してください。</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">現在、インポートリストとエクスポートリストにはいくつかの潜在的なあいまいさが存在します。たとえば、 &lt;code&gt;import M( (+) )&lt;/code&gt; と書いた場合、&lt;em&gt;関数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; または&lt;em&gt;タイプコンストラクター&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; を意味しますか？デフォルトは前者ですが、&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;（これは&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;によって暗示されます）を使用すると、GHCはキーワード &lt;code&gt;type&lt;/code&gt; を前に付けることで後者を指定できます。</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">一方のエッジケースがあります： &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 現在、常に空のリスト（何に関係なく生成 &lt;code&gt;tys&lt;/code&gt; 与えられているが）。</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">この一般的な規則には1つの例外があります&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;でプログラムをロードするとき、または &lt;code&gt;ghci&lt;/code&gt; を呼び出すときにそれを指定するときは、モジュール名ではなくファイル名を指定できます。このファイル名が存在する場合はロードされ、好きなモジュールを含むことができます。これは、同じディレクトリにいくつかの &lt;code&gt;Main&lt;/code&gt; モジュールがあり、それらをすべて &lt;code&gt;Main.hs&lt;/code&gt; と呼ぶことができない場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">特にトリッキーなケースがあるので説明しておきます。</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">統語的な曖昧さには一つの問題があります。考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">I / Oアクションを「実行」する方法は、実際には1つだけあります。それをプログラムの &lt;code&gt;Main.main&lt;/code&gt; にバインドします。プログラムが実行されると、I / Oが実行されます。任意の関数からI / Oを実行することはできません。ただし、その関数自体が &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあり、ある時点で直接または間接的に &lt;code&gt;Main.main&lt;/code&gt; から呼び出される場合を除きます。</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">I / Oアクションを「実行」する方法は、実際には1つだけあります。それをプログラムの &lt;code&gt;Main.main&lt;/code&gt; にバインドします。プログラムが実行されると、I / Oが実行されます。任意の関数からI / Oを実行することはできません。ただし、その関数自体が &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあり、ある時点で直接または間接的に &lt;code&gt;Main.main&lt;/code&gt; から呼び出される場合を除きます。</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">I / Oアクションを「実行」する方法は、実際には1つだけあります。それをプログラムの &lt;code&gt;Main.main&lt;/code&gt; にバインドします。プログラムが実行されると、I / Oが実行されます。任意の関数からI / Oを実行することはできません。ただし、その関数自体が &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドにあり、ある時点で直接または間接的に &lt;code&gt;Main.main&lt;/code&gt; から呼び出される場合を除きます。</target>
        </trans-unit>
        <trans-unit id="25f515351416a88c7165a7d23467301f2a1ae98e" translate="yes" xml:space="preserve">
          <source>There is room for extra information in the event type specification, which can be ignored by older tools.</source>
          <target state="translated">イベントタイプの仕様には、古いツールでは無視できるような余分な情報を入れる余地があります。</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCiがプレリュードライブラリと標準ライブラリをロードしている間に短い一時停止が発生する場合があり、その後プロンプトが表示されます。バナーのとおり、次のように入力できます&lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;使用可能なコマンドのリストと、それぞれの半行の説明を表示します。これらのコマンドのほとんどについては、&lt;a href=&quot;#ghci-commands&quot;&gt;順を追って説明します。GHCiコマンドの&lt;/a&gt;すべてのコマンドの完全なドキュメントがあります。</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">同じキーで複数の弱いポインターが存在する場合があります。この場合、これらの弱ポインターのそれぞれのファイナライザは、キーが死んだときに、任意の順序で、あるいはおそらく同時に実行されます。プログラマが、オブジェクトへの唯一の参照を持つと仮定してファイナライザを指定した場合 (例えば、閉じたいファイルなど)、プログラマはそのようなファイナライザが 1 つだけであることを保証しなければなりません。</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">セミコロンで区切られた&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;プラグマには、0個以上のルールがあります（レイアウトルールによって生成される場合があります）。</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">トークンにはスペースを入れてはいけません &lt;code&gt;[quoter|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">値の宣言はあってはなりませんが、値の型のシグネチャを定義することはできます。例えば、シグネチャを定義することができます。</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">値の宣言はあってはなりませんが、値の型署名はあってもかまいません。例えば</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">曖昧な書き換えシステムを定義しないように、型族の方程式には何らかの制限が必要です。したがって,オープンな型族の方程式は互換性があるように制限されている.2つの型パターンは以下の場合に互換性がある.</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">以前は &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; の別のバリアント（つまり &lt;code&gt;Par0&lt;/code&gt; ）がありましたが、それ以降非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;並行&lt;/em&gt;&lt;em&gt;処理&lt;/em&gt;と&lt;em&gt;並列&lt;/em&gt;処理には細かい違いがあります。並列処理とは、複数のプロセッサを同時に使用してプログラムを&lt;em&gt;より高速に&lt;/em&gt;実行することです。一方、並行性は抽象化の手段です。これは、複数の非同期イベントに応答する必要があるプログラムを構築する便利な方法です。</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">RTS にはプリミティブ &lt;code&gt;MVar#&lt;/code&gt; オブジェクトへの &lt;code&gt;StablePtr&lt;/code&gt; が必要であり、それを直接作成することはできないため、 &lt;code&gt;StablePtr&lt;/code&gt; を作成するための特別な関数があります： &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; 。ん&lt;em&gt;ではない&lt;/em&gt;だけに使用 &lt;code&gt;newStablePtr&lt;/code&gt; を上 &lt;code&gt;MVar&lt;/code&gt; ：あなたのプログラムがクラッシュします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">例外があります &lt;code&gt;CYGWIN&lt;/code&gt; 環境変数に &lt;code&gt;tty&lt;/code&gt; が含まれてい&lt;em&gt;ない&lt;/em&gt;場合は、Cygwinシェルを使用できます。このモードでは、CygwinシェルはWindowsコンソールシェルのように動作し、コンソールイベントは子プロセスに伝達されます。Cygwinシェルを開始する&lt;em&gt;前に&lt;/em&gt;、 &lt;code&gt;CYGWIN&lt;/code&gt; 環境変数を設定&lt;em&gt;する&lt;/em&gt;必要があることに注意してください。後で変更しても、シェルには影響しません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">外部ライブラリを使用する際に一つの他の落とし穴は心の中でクマにあります：ライブラリが含まれている場合は &lt;code&gt;main()&lt;/code&gt; 関数を、そしてこれはGHC自身とのリンクの競合になります &lt;code&gt;main()&lt;/code&gt; （機能など。 &lt;code&gt;libf2c&lt;/code&gt; と &lt;code&gt;libl&lt;/code&gt; 、自分の持っている &lt;code&gt;main()&lt;/code&gt; 秒）。</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">関数の &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ファミリの1つへの呼び出しでは、すべての例外ハンドラの周囲に暗黙の &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; があります。これはほとんどの場合それが必要なためです。例外ハンドラがすぐに到着した場合、スタックに別の例外を処理する例外ハンドラがない可能性があるため、例外ハンドラを開始する際の一般的な競合状態が解消されます。ただし、ハンドラに入るときに非同期例外がマスクされている場合は、中断される前に新しい例外ハンドラをインストールする時間があります。これがデフォルトでない場合は、次のように書く必要があります</target>
        </trans-unit>
        <trans-unit id="6b1f8f78c4b21b4ebde0207b0aeba4e07d56d547" translate="yes" xml:space="preserve">
          <source>Therefore, if we run GHC against the following code using the plugin from above:</source>
          <target state="translated">そこで、上記のプラグインを使って以下のコードに対してGHCを実行してみると</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">これらの &lt;code&gt;Names&lt;/code&gt; は、テンプレートHaskellの式、パターン、宣言などを構築するために使用できます &lt;code&gt;reify&lt;/code&gt; 関数への引数として指定することもできます。</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">これらのRTSオプションは、（a）GHCバグを回避するため、（b）「実際に何が起こっているか」を確認するため、または（c）好みに応じて使用できます。日常の使用にはお勧めしません！</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">これらと他の多くの例は、Hongwei XiとTim Sheardによる論文に記載されています。&lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;wikiには&lt;/a&gt;長い紹介があり、Ralf Hinzeの&lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;ファントムタイプ&lt;/a&gt;のFunにも多くの例があります。論文では、GHCで実装されている表記とは異なる表記が使用されている場合があります。</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">これらは、それぞれ &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">これらは、から入手できます&lt;em&gt;信頼できる&lt;/em&gt;モジュール&lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;だけでなく、</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">これらは、データコンストラクターが多態的な引数型を持つ &lt;code&gt;data&lt;/code&gt; および &lt;code&gt;newtype&lt;/code&gt; 宣言の例です。</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">これらは、プログラムを実行するためにコンパイルされたプラットフォームです。</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">これらはGHC自体がコンパイルされたプラットフォームです。ここでも通常はビルドプラットフォームとターゲットプラットフォームと同じです。</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">プログラムが構築されたプラットフォームです。(つまり、GHC自体のターゲットプラットフォームです。)通常はターゲットプラットフォームと同じです。(クロスコンパイルの場合は異なる可能性があります)</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">これらの属性は、すべてのプロパティがオフになっています。</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">これらは、バグやパフォーマンスの問題の調査に役立ちます。量産コードでは使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">これらの機能は、 &lt;code&gt;cub&lt;/code&gt; 、 &lt;code&gt;cud&lt;/code&gt; 、 &lt;code&gt;cub1&lt;/code&gt; 、 &lt;code&gt;cud1&lt;/code&gt; などに直接対応します。</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">これらの文字とは、任意の空白文字、単一引用符、二重引用符、およびバックスラッシュ文字です。バックスラッシュ文字は常に後続の文字をエスケープします(すなわち、それ以上考慮せずに通過します)。文字は、ブロック内で引用符で囲むことでエスケープすることもできます(すなわち、ブロックを、それ自体がエスケープされていないシングルクォートかダブルクォートのいずれかのマッチするペアで囲むこと)。</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じ文書で「レター」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントは、「マーク」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで、「番号」とは何かを定義します。</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントは、「句読点」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで「セパレータ」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">これらのクラスは、Unicode標準の一部であるUnicode &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Character Database&lt;/a&gt;で定義されています。同じドキュメントで、「記号」とは何かを定義しています。</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">これらのクラスは、ポータブルHaskellのトランスフォーマーの引数に対する制約を表現するために必要です。したがって、新しいトランスフォーマー &lt;code&gt;T&lt;/code&gt; の場合、次のようなインスタンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">これらの考察から、オーファンモジュールの定義は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">これらはパラメトリックであることを保証します。</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">これらのイベントは&lt;em&gt;常に&lt;/em&gt; GHCシステムのバグです。報告してください。</target>
        </trans-unit>
        <trans-unit id="588a8548c6363993d22d2b7e86c47e328069a514" translate="yes" xml:space="preserve">
          <source>These events are typically produced during program startup and describe the environment which the program is being run in.</source>
          <target state="translated">これらのイベントは通常、プログラムの起動時に生成され、プログラムが実行されている環境を記述します。</target>
        </trans-unit>
        <trans-unit id="7e9e62a89c4ce54bd1d84649823a3e3080b1425a" translate="yes" xml:space="preserve">
          <source>These events mark various stages of the &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;non-moving collection&lt;/code&gt;&lt;/a&gt; lifecycle. These are enabled with the &lt;code&gt;+RTS -lg&lt;/code&gt; event-set.</source>
          <target state="translated">These events mark various stages of the &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;non-moving collection&lt;/code&gt; &lt;/a&gt; lifecycle. These are enabled with the &lt;code&gt;+RTS -lg&lt;/code&gt; event-set.</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">これらのフラグにより​​、モジュールに「孤立した」インスタンス宣言または書き換えルールが含まれている場合は常に警告が発行されます。インスタンス宣言は、インスタンス化されるクラスもタイプも同じモジュールで宣言されていないモジュールに現れる場合、孤立します。別のモジュールで宣言された関数のルールである場合、そのルールは孤立しています。オーファンを含むモジュールは、オーファンモジュールと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">これらのフラグは、他のバックエンドから様々なビット情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">これらのフラグは、GHCのフロントエンドからさまざまな情報をダンプします。これには、パーサーとインターフェイスファイルリーダーが含まれます。</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">これらのフラグは、GHCのタイプチェッカーとリネーマーからさまざまな情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="2dc9a8e0f094a600546405a33b0a5ef835899c04" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-- pipeline.</source>
          <target state="translated">These flags dump various phases of GHC&amp;rsquo;s C-- pipeline.</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">これらのフラグは、GHCのC-\-パイプラインのさまざまなフェーズをダンプします。</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">これらのフラグは、GHCのコア間パイプラインのさまざまなフェーズをダンプします。これはdesugarerから始まり、単純化、ワーカーラッパー変換、ルールエンジン、スペシャライザ、厳密性/出現分析、および共通の部分式除去パスが含まれます。</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">これらのフラグは、GHCのSTGパイプラインのさまざまなフェーズをダンプします。</target>
        </trans-unit>
        <trans-unit id="50fcdcd1fe44bc0c3ab929a2c58bbb80cb13f620" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-- and produces native assembler.</source>
          <target state="translated">These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-- and produces native assembler.</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">これらのフラグは、C-\-で始まりネイティブアセンブラを生成するネイティブ&lt;a href=&quot;codegens#native-code-gen&quot;&gt;コードジェネレータの&lt;/a&gt;パイプラインのさまざまなステージをダンプします。</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">これらのフラグは、個々の最適化をオンまたはオフにします。デフォルトでonとマークされているフラグは &lt;code&gt;-O&lt;/code&gt; によって有効になるため、明示的に設定する必要はありません。フラグ &lt;code&gt;-fwombat&lt;/code&gt; は、 &lt;code&gt;-fno-wombat&lt;/code&gt; と言って無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">標準タイプのこれらのフォーマッターは、新しいタイプ固有のフォーマッターを作成する際の便宜のために提供されています。一般的なパターンは、 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; にスローして、新しいタイプのほとんどのフォーマット処理を行うことです。</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">これらの4つのプロパティは、安全な言語では型を信頼し、モジュールのエクスポートリストが尊重されていることを信頼し、コンパイルに成功したコードが通常と同じ意味を持つことを信頼できることを保証します。</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">これらの関数は&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;によってもエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">これらの関数は、常にASCIIを想定するのではなく、現在のロケールによって決定されるエンコーディングを使用するという点で、対応する &lt;code&gt;CAString&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">これらの関数は、インスタンス化された型によって異なる結果を返す必要があるため、オーバーロードされています。</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">これらの関数は、シフト量がマシンInt#のビット数よりも大きい場合には定義されません。</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">これらの関数は内部的に様々なエラーを発生させるために使用され、新しい型固有のフォーマッタで使用するためにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">これらの関数を使用して、新しい代数型の &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; インスタンスをアセンブルできます。たとえば、次の定義があるとします。</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">これらの関数はlevityポリモーフィック変数をバインドしないので、受け入れられます。これらのポリモーフィズムにより、ユーザはこれらの関数を便利に使用して、箱から出していない型を返す関数をスタブアウトすることができます。</target>
        </trans-unit>
        <trans-unit id="044a64ee1e082d15f5fc359f3ff870486d8b309f" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="translated">これらの関数は、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; 型クラスのメソッドに基づいていることを除いて、&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exceptionの&lt;/a&gt;関数に従います。APIの使用法については、&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">これらの関数は、ファイナライザーとして任意の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを許可することにより、移植可能な&lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt;モジュールでの名前の一般化を一般化します。これらのファイナライザは、必然的に別のスレッドで実行されます。&lt;em&gt;デストラクタ、ファイナライザ、および同期化&lt;/em&gt;、Hans Boehm、&lt;em&gt;POPL&lt;/em&gt;、2003年。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">これらの関数は,シーケンスの左端または右端から順次検索を行い,一致する要素のインデックスを返します.</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">これらの関数は、はるかに柔軟な &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; よりも前に作成されています。</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">これらの関数は、リスト &lt;code&gt;xs&lt;/code&gt; を0から &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; までの範囲のインデックスを持つインデックス付きコレクションとして扱います。</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">これらの関数は、リスト &lt;code&gt;xs&lt;/code&gt; を0から &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; までの範囲のインデックスを持つインデックス付きコレクションとして扱います。</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">これらのインスタンスは、暗黙のkindパラメーターが異なるため互換性があります。1つ目は &lt;code&gt;Type&lt;/code&gt; を使用し、2つ目は &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">これらのマクロはGHC 7.10.1から利用可能です。</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">これらのマクロは、 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; で提供されるよりも細かい粒度を可能にするために提供されています。ほとんどのAPIはパッチレベルのリリース間で安定していることが予想されるため、通常、これは必要ではありませんが、バグを修正するために内部APIの変更が必要になる場合があります。また、パッチレベルでの条件付きコンパイルは、古いリリースのバグを回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">これらのマクロは、Haskellのモジュール（即ち、から生成されたCソースを含む、前処理HaskellソースとC源の両方が設定されている &lt;code&gt;.hs&lt;/code&gt; 、 &lt;code&gt;.lhs&lt;/code&gt; 、 &lt;code&gt;.c&lt;/code&gt; および &lt;code&gt;.hc&lt;/code&gt; ファイル）。</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">これらのモジュールは、Prelude の関数との名前の衝突を避けるために、修飾された状態でインポートされることを意図しています。</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">これらの操作は、 &lt;code&gt;False&lt;/code&gt; および &lt;code&gt;True&lt;/code&gt; ではなく、それぞれ &lt;code&gt;0#&lt;/code&gt; および &lt;code&gt;1#&lt;/code&gt; を返します。詳細については、&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wikiページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b7ccd9c5b4911eda91ad51529b53aa771bb31514" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">これらの操作は、それぞれ &lt;code&gt;False&lt;/code&gt; と &lt;code&gt;True&lt;/code&gt; ではなく &lt;code&gt;0#&lt;/code&gt; と &lt;code&gt;1#&lt;/code&gt; を返します。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBoolwikiページ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">これらのオプションについては、&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：プラットフォームに依存しないフラグで&lt;/a&gt;詳しく説明しています。フラグが &lt;code&gt;-O&lt;/code&gt; によって暗示されている場合、フラグの説明も &lt;code&gt;-O2&lt;/code&gt; によって暗示されています（フラグの説明で明示的に別の指示がない限り）。フラグが &lt;code&gt;-O0&lt;/code&gt; によってのみ暗示される場合、フラグは &lt;code&gt;-O&lt;/code&gt; および &lt;code&gt;-O2&lt;/code&gt; によって暗示されません。</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">これらのオプションについては、「&lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;最適化（コードの改善）」で&lt;/a&gt;詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">これらのオプションは、どの警告が致命的とみなされ、コンパイルを中止させるかを制御します。</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">これらのオプションは、プログラムの実行とガベージコレクターでの消費時間、割り当てられたメモリの量、ヒープの最大サイズなど、ランタイムシステムの統計を生成します。 3つのバリアントは、さまざまな詳細レベルを提供します。 &lt;code&gt;-T&lt;/code&gt; はデータを収集しますが、出力は生成しません。- &lt;code&gt;-t&lt;/code&gt; は、GHCの &lt;code&gt;-Rghc-timing&lt;/code&gt; オプションと同じ形式で1行の出力を生成します。- &lt;code&gt;-s&lt;/code&gt; は、プログラム、および &lt;code&gt;-S&lt;/code&gt; はさらに、すべてのガベージコレクションに関する情報を生成します。合格- &lt;code&gt;--internal-counters&lt;/code&gt; スレッド化されたランタイムには、実行中に累積されたさまざまな内部カウントを含む詳細なサマリーが生成されます。これらは指定されておらず、リリース間で変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;ByteString&lt;/code&gt; が別のコンストラクターにアンパックされると、これらのオーバーヘッドはすべて1ワード（4または8バイト）削減できます。</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">アローに関するこれらの論文および詳細情報は、&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http：//www.haskell.org/arrows/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらのパターンはGHCバージョン8.0以降でのみ利用可能であり、バージョン8.2はそれらでよりうまく機能します。GHCのように最近のバージョンのために書くとき、パターンの代わりに使用することができ &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">これらはオーバーラップする可能性がありますが、フラグの設定に関係なく、GHCはインスタンス宣言自体について文句を言いません。後で制約 &lt;code&gt;(C Int Char)&lt;/code&gt; を解決しようとすると、最初のインスタンスのみが一致し、すべてが順調です。同様に &lt;code&gt;(C Bool Bool)&lt;/code&gt; を使用します。しかし、 &lt;code&gt;(C Int Bool)&lt;/code&gt; を解決しようとすると、両方のインスタンスが一致し、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">これらのプラグマは、関数定義のインライン化を制御します。</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">これらの制限は簡単に検証され、型推論の終了を保証します。ただし、タイプ変数の再帰的発生がファミリーアプリケーションの下にあり &lt;code&gt;a ~ [F a]&lt;/code&gt; ような、いわゆる「ループ状の等式」が存在する場合、タイプの推論の完全性を保証するのに十分ではありません。データコンストラクターアプリケーション-詳細については、上記のペーパーを参照してください。</target>
        </trans-unit>
        <trans-unit id="9f701b27c6f77c55b38a0a5e6d91357571f66567" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;rsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;rsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt; , where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">これらの制限により、インスタンスの解決が確実に終了します。各削減ステップにより、少なくとも1つのコンストラクターによって問題が小さくなります。これらの制限の理由に関する多くの背景資料は、&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;「制約処理規則による機能の依存関係の理解」&lt;/a&gt;のペーパーにあります。</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">これらのルールは、レコードのワイルドカードを、ユーザーが拡張版を書くことができた状況に限定しています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">これらのタイプは、 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; への引数の処理変数の実装に必要です。それらの実装は、このモジュールから意図的に見えません。適切なクラスのインスタンスではない型の引数を &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; に渡そうとすると、コンパイラーはそれを &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; の欠落インスタンスとして報告します。 （すべての &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; インスタンスは &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; インスタンスです。）</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">これらの型は、HaskellのCライブラリインターフェイスにアクセスするために、C関数プロトタイプを正確に表すために必要です。 Haskellシステムでは、Cとまったく同じようにこれらの型を表す必要はありませんが、Cの型 &lt;code&gt;t&lt;/code&gt; を表すHaskellの型 &lt;code&gt;CT&lt;/code&gt; に関して、次の保証が提供されます。</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">これらのタイプは、次のように表現される &lt;code&gt;newtype&lt;/code&gt; 秒の &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 及び &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 、とのインスタンスである &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; が、 &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 。つまり、 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; の（それぞれ &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; の） &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; のインスタンス &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; （それぞれ &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ）と同じように動作が悪い。</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの型は、基本的な外部型の &lt;code&gt;newtype&lt;/code&gt; として表され、 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの型は、&lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;および&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;で型の &lt;code&gt;newtype&lt;/code&gt; として表され、 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">上記の関数のこれらのバリエーションは、Unicodeを知らないCライブラリで使用するためのものです。これらの関数は、情報が失われる可能性があるので、注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">上記の関数のこれらのバリアントは、システムに依存する方法でCの &lt;code&gt;wchar_t&lt;/code&gt; 型を使用してUnicodeをエンコードするCライブラリで使用するためのものです。サポートされている唯一のエンコーディングは</target>
        </trans-unit>
        <trans-unit id="d4df89c18ae8de17d49ca0683c16ba6bdd50a129" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="translated">入力の終わりに遭遇した場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。すなわち：</target>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">彼らは言う &lt;code&gt;make&lt;/code&gt; のいずれかの場合という &lt;code&gt;Foo.o&lt;/code&gt; 、 &lt;code&gt;Foo.hc&lt;/code&gt; または &lt;code&gt;Foo.s&lt;/code&gt; がより早く更新日時持っ &lt;code&gt;Baz.hi&lt;/code&gt; を、その後、期限切れのファイルを最新の状態にする必要があります。それを最新の状態に &lt;code&gt;make&lt;/code&gt; は、そうするためのルールを探します。前述のサフィックスルールの1つがうまく機能します。これらの依存関係は &lt;code&gt;ghc&lt;/code&gt; によって自動的に生成できます。&lt;a href=&quot;#makefile-dependencies&quot;&gt;依存関係の生成を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">それらはSimon Peyton Jones、Andrew Gordon、Sigbjorn Finneによる論文&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;「Concurrent Haskell」で&lt;/a&gt;紹介されましたが、その後、実装の詳細が一部変更されました（特に、完全な &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を使用するとエラーになりましたが、現在は単なるブロックになっています）。 ）</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">意識しておきたいこと。</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">この「機能」は表面的には &lt;code&gt;unsafePerformIO&lt;/code&gt; と類似していますが、実際には混乱の悪意のあるエージェントです。現実の継ぎ目（および &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナド）を展開して、通常のルールが適用されないようにします。それはあなたがそれが妥当であると考えるようにあなたを落ち着かせます、しかしあなたがそれを見ていないとき、それはあなたを後ろに突き刺し、あなたのすべての可変バッファをエイリアスします。多くの熟練したHaskellプログラマーの死体は、その足元にばらまかれています。</target>
        </trans-unit>
        <trans-unit id="4c6dd831f46ec853aa8fce97c6a2a27a512463cc" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">この「機能」は直観に反する場合があります &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; は、中間のCコードをファイル &lt;code&gt;foo.o&lt;/code&gt; に配置しますが、名前は異なります。</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 等価述語は、文字列に対してパターンマッチをデガガリングするときに使用されます。</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は、Windows以外のプラットフォームでコマンドライン引数と環境変数をデコードおよびエンコードするために使用されます。</target>
        </trans-unit>
        <trans-unit id="c332f21db0753a9ce2e0bf5358f7f0659bb25726" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; は、Windows以外のプラットフォームでコマンドライン引数と環境変数をデコードおよびエンコードするために使用されます。</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">この &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、デフォルトで提供されているもの以外のフォーマットタイプに拡張できます。これは、インスタンス化することによって行われ &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; をして提供する &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; をタイプするために。タイプ固有の修飾子を処理するために &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; を提供することは可能ですが、通常はデフォルトのインスタンスが最適です。</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">この略語により、トップレベルの宣言スライスはより静かで威圧感のないものになります。</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">この抽象データ型は、パースエラーメッセージを表します。メッセージには4種類あります。</target>
        </trans-unit>
        <trans-unit id="ec7860e1d5ebe8e9fc316526773dd3897969d972" translate="yes" xml:space="preserve">
          <source>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</source>
          <target state="translated">これは、プラグマの直後のすべての列番号を42から始まるように調整します。このプラグマの存在は診断の質に影響を与えるだけで、コード自体の構文を変更することはありません。</target>
        </trans-unit>
        <trans-unit id="7a12a7ca1e45d66acaa328bb08f3c374962eb4c1" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">これにより、そのクラスのインスタンスである別のタイプの同等の実行時表現（2つの間に &lt;code&gt;Coercible&lt;/code&gt; インスタンスが存在するように：&lt;a href=&quot;#coercible&quot;&gt;Coercible制約を&lt;/a&gt;参照）を指定することにより、タイプのクラスインスタンスを &lt;code&gt;deriving&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="1fb2d1ad05ed875ea28b9cb5da5c11c1ce3bedd9" translate="yes" xml:space="preserve">
          <source>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field &lt;code&gt;name :: String&lt;/code&gt;:</source>
          <target state="translated">これにより、指定されたフィールドを持つレコードタイプに対して多態的な定義が可能になります。たとえば、次はフィールド &lt;code&gt;name :: String&lt;/code&gt; を持つすべてのレコードタイプで機能します。</target>
        </trans-unit>
        <trans-unit id="ba36681397794a5e83833dc68b57c1526f4be113" translate="yes" xml:space="preserve">
          <source>This allows you to write shorter signatures:</source>
          <target state="translated">これにより、より短い署名を書くことができます。</target>
        </trans-unit>
        <trans-unit id="e8a1d903f792395fe48e068f8423dc24b82157d5" translate="yes" xml:space="preserve">
          <source>This also applies to GADT-style data instances:</source>
          <target state="translated">これはGADTスタイルのデータインスタンスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="7c38964da27b045ec2be9894b1df29221a7ceb88" translate="yes" xml:space="preserve">
          <source>This assumes that the library &lt;code&gt;libfoo.so&lt;/code&gt; is in the current directory and will be able to be found in the same directory as the executable &lt;code&gt;main&lt;/code&gt; once the program is deployed. Similarly it would be possible to use a subdirectory relative to the executable e.g. &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt;.</source>
          <target state="translated">これは、ライブラリ &lt;code&gt;libfoo.so&lt;/code&gt; が現在のディレクトリにあり、プログラムがデプロイされると実行可能 &lt;code&gt;main&lt;/code&gt; と同じディレクトリにあることを前提としています。同様に、実行可能ファイルに関連するサブディレクトリを使用することも可能です（例： &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61fe3a7a67ef0295ed3b813ce3259d063c2d2b72" translate="yes" xml:space="preserve">
          <source>This avoid generating Typeable-related bindings for modules and types. This is useful when debugging because it gives smaller modules and dumps, but the compiler will panic if you try to use Typeable instances of things that you built with this flag.</source>
          <target state="translated">これは、モジュールや型に Typeable 関連のバインディングを生成しないようにします。これはデバッグ時に便利ですが、このフラグを使ってビルドしたものの Typeable インスタンスを使おうとするとコンパイラがパニックになります。</target>
        </trans-unit>
        <trans-unit id="f6f906decfdad529805a16ffec27620b40f24764" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは4.10.0.0で型クラスメソッドになりました。それ以前は、 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; で定義された関数でした。</target>
        </trans-unit>
        <trans-unit id="9638426e03b58cbb0b8529e91d4b2a020cb1636d" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは4.10.0.0で型クラスメソッドになりました。それ以前は、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; で定義された関数でした。</target>
        </trans-unit>
        <trans-unit id="b85692b8edaa0b39863dc7b24b15416769ea56cf" translate="yes" xml:space="preserve">
          <source>This behaves as &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt;, except that a decimal point is always guaranteed, even if not needed.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; と同じように動作しますが、必要がない場合でも小数点は常に保証されます。</target>
        </trans-unit>
        <trans-unit id="04fbb2fc7bba349478476c0924ff7c8bb5aaa853" translate="yes" xml:space="preserve">
          <source>This behavior differs from GHC's built-in Ctrl-C handling, which may immediately terminate the program after the second time that the user presses Ctrl-C.</source>
          <target state="translated">この動作は、GHC に内蔵されている Ctrl-C の扱いとは異なり、ユーザーが Ctrl-C を 2 回目に押した後、プログラムを即座に終了させてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="13f6564d560839ab1b11893b1d1b1073914eb3f0" translate="yes" xml:space="preserve">
          <source>This behavior should suffice for most applications.</source>
          <target state="translated">ほとんどのアプリケーションでは、この動作で十分です。</target>
        </trans-unit>
        <trans-unit id="c633ca838f3fb91b35f5e358bad2a899b13f6caf" translate="yes" xml:space="preserve">
          <source>This behaviour depends on what it means for a key to be reachable. Informally, something is reachable if it can be reached by following ordinary pointers from the root set, but not following weak pointers. We define reachability more precisely as follows.</source>
          <target state="translated">この動作は、キーが到達可能であることの意味に依存します。非公式には、ルート集合から通常のポインタを辿って到達できるが、弱いポインタを辿らない場合、何かが到達可能である。到達可能性をより正確に定義すると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6b2b05c125a4021b12f162035f98b456ef9c82e9" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt;&lt;code&gt;NondecreasingIndentation&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">この動作は、&lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt; &lt;code&gt;NondecreasingIndentation&lt;/code&gt; &lt;/a&gt;拡張機能によって制御されます。</target>
        </trans-unit>
        <trans-unit id="be474662b261fe4c0cfb08eb9d9746ac9b512af6" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;code&gt;NondecreasingIndentation&lt;/code&gt; extension.</source>
          <target state="translated">この動作は、 &lt;code&gt;NondecreasingIndentation&lt;/code&gt; 拡張機能によって制御されます。</target>
        </trans-unit>
        <trans-unit id="6a0488f978e785c4f8524e21bec6ad7590261c4c" translate="yes" xml:space="preserve">
          <source>This behaviour is implemented by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;) when the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option is set. In particular, the &lt;code&gt;SIGINT&lt;/code&gt; signal will be ignored until &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; returns (or &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; returns a non-Nothing result), so it becomes especially important to use &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for every processes created.</source>
          <target state="translated">この動作はによって実装される &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; とき） &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; オプションが設定されています。特に、 &lt;code&gt;SIGINT&lt;/code&gt; シグナルは、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; が戻る（または &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; がNothing以外の結果を返す）まで無視されるため、作成されたすべてのプロセスに対して &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; を使用することが特に重要になります。</target>
        </trans-unit>
        <trans-unit id="551a466ddf545f274fdf0a190213c9133fda55d9" translate="yes" xml:space="preserve">
          <source>This behaviour is occasionally useful when controlling evaluation order. Notably, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; is used in the library definition of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">この動作は、評価順序を制御するときに役立つ場合があります。特に、 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; のライブラリ定義で使用されています。</target>
        </trans-unit>
        <trans-unit id="57d598a924d78189a09779d74b1038fed36775fe" translate="yes" xml:space="preserve">
          <source>This can all be encapsulated in a little script:</source>
          <target state="translated">これはすべて、小さなスクリプトにカプセル化することができます。</target>
        </trans-unit>
        <trans-unit id="416311d652a99e1b78b7cc2405506ab6d471421e" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">これは、一部のモノイドでは、 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; よりも漸近的に高速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="c52286f7e89bb4fb4f3c0e5035332585166c4a33" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">これは、一部のモノイドでは、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; よりも漸近的に高速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="4751eaff9e7b3787ad6b9d21b46ac7636adad9a8" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">これは、一部のモノイドでは、 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; よりも漸近的に高速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="e7d4ce9fe92bac780f0fa78aae700d3bbb629ea6" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">これは、一部のモノイドでは、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; よりも漸近的に高速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="621efad2402b4456bcde1c01e463d327dcf9db65" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">これは、一部のモノイドでは、 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; よりも漸近的に高速になる場合があります。</target>
        </trans-unit>
        <trans-unit id="32f5dfbe5ae69f119a2bb8aa1f207219df30a02e" translate="yes" xml:space="preserve">
          <source>This can be compiled and run with:</source>
          <target state="translated">これをコンパイルして実行することができます。</target>
        </trans-unit>
        <trans-unit id="f7e5132d5805fa0f4b66063054f14a1690215ca6" translate="yes" xml:space="preserve">
          <source>This can be exponential in the arity of the pattern and in the number of guards in some cases. The &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt;&lt;/a&gt; limit makes sure we scale polynomially in the number of patterns, by forgetting refined information gained from a partially successful match. For the above example, if we had a limit of 1, we would continue checking the next clause with the original, unrefined model.</source>
          <target state="translated">これは、パターンのアリティと、場合によっては警備員の数において指数関数的になる可能性があります。&lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt; &lt;/a&gt;制限が部分的に成功した試合から得られた洗練された情報を忘れることで、パターンの数に多項式必ず我々の規模になります。上記の例では、制限が1の場合、元の未精製モデルで次の句を引き続きチェックします。</target>
        </trans-unit>
        <trans-unit id="c46a06f859ec4216c3665e278e7c6dd66a8347dc" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly quantifying over &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;k&lt;/code&gt; を明示的に定量化することで修正できます。</target>
        </trans-unit>
        <trans-unit id="9115da4e5d66f067d2eb0a134175d944d3ff0263" translate="yes" xml:space="preserve">
          <source>This can be particularly useful for debugging: if your program is complaining about a &lt;code&gt;head []&lt;/code&gt; error and you haven&amp;rsquo;t got a clue which bit of code is causing it, compiling with &lt;code&gt;-prof -fprof-auto&lt;/code&gt; (see &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;) and running with &lt;code&gt;+RTS -xc
-RTS&lt;/code&gt; will tell you exactly the call stack at the point the error was raised.</source>
          <target state="translated">これはデバッグに特に役立ちます。プログラムが &lt;code&gt;head []&lt;/code&gt; エラーについて不平を言っていて、どのコードのコードがそれを引き起こしているのか手掛かりがない場合は、 &lt;code&gt;-prof -fprof-auto&lt;/code&gt; （&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; を&lt;/a&gt;参照）でコンパイルして実行します。 &lt;code&gt;+RTS -xc -RTS&lt;/code&gt; エラーが発生した時点では正確にコールスタックを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="96def13c000ed8fdbd0d21e559c3990a32470604" translate="yes" xml:space="preserve">
          <source>This can be used to retarget the standard Handles, for example:</source>
          <target state="translated">これは、例えば標準のハンドルをリターゲットするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="19cecadc905b14f14f3e42e92f83eba13e2b4315" translate="yes" xml:space="preserve">
          <source>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</source>
          <target state="translated">これは、検査対象の式に底値以外の値がないことがわかっている場合に便利です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d47b1d234066b1655177b94f7c3a67f89c058734" translate="yes" xml:space="preserve">
          <source>This can make a difference when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">数値データ型の正と負の範囲が一致しない場合、これにより違いが生じる可能性があります。たとえば、8ビット演算では、-128は表現できますが、+ 128は表現できません。したがって、 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; は、予期しないinteger-literal-overflowメッセージを引き出します。</target>
        </trans-unit>
        <trans-unit id="affbea3b51b202a931e180ff5123d3de0aa30798" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's background color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">この能力は、与えられたテキストの出力中に一時的にターミナルの背景色を設定し、ターミナルをデフォルトの前景色と背景色に戻す。</target>
        </trans-unit>
        <trans-unit id="7049fed78ee7c9e2705eacdcfa8deafff39f6093" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's foreground color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">この機能は、与えられたテキストを出力している間、一時的にターミナルの前景色を設定し、ターミナルをデフォルトの前景色と背景色に戻します。</target>
        </trans-unit>
        <trans-unit id="89a02b3d5ef05f9fc3fd28e4eec451dc3ff86763" translate="yes" xml:space="preserve">
          <source>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</source>
          <target state="translated">これは、テンプレートHaskellコードを含むマルチモジュールプログラムがあり、プロファイリングのためにコンパイルする必要がある場合、GHCはプロファイリングされたオブジェクトコードをロードして、スプライスを実行する際にそれを使用することができないため、困難を引き起こす原因となります。</target>
        </trans-unit>
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">この変更は、メインモジュールにのみ適用されます。他のモジュールは、 &lt;code&gt;-main-is&lt;/code&gt; フラグに関係なく、デフォルトのエクスポートリストから &lt;code&gt;main&lt;/code&gt; をエクスポートします。これは、使用可能 &lt;code&gt;-main-is&lt;/code&gt; エクスポート既存のモジュールと &lt;code&gt;main&lt;/code&gt; 場合でも、デフォルトのエクスポートリストを介し &lt;code&gt;-main-is&lt;/code&gt; （でコンパイルこの例のように、異なるエントリ・ポイントにポイント &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">このクラスには、&lt;em&gt;用語に&lt;/em&gt;含まれる情報から2つの型の等価性を学習できる型が含まれてい&lt;em&gt;ます&lt;/em&gt;。通常、このクラスにはシングルトンタイプのみを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">このクラスは,型レベルの自然数に関連付けられた整数を与えます.0,1,2 などの具象リテラルごとにこのクラスのインスタンスが存在します。</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">このクラスは,型レベルのシンボルに関連付けられた文字列を与えます.具象リテラルごとにこのクラスのインスタンスが存在します。&quot;hello&quot; などです。</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">このクラスは、Haskell98互換性のために必要とされるもので、FlexibleInstancesの欠如を回避するためのものです。</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">このクラスは、GHCとHugsでサポートされている再帰的 &lt;code&gt;do&lt;/code&gt; 表記の変換で使用されます。</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">このクラスは、インスタンスが1つだけなので、具象型としての &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; がタイプクラスインスタンスとして許可されないという事実の回避策として使用されます。 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; は、下位互換性のためにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">このコードは致命的なエラーを発生させるはずですが、そうではありません。</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">このコードは、重要な部分の非同期例外をマスクすることにより、 &lt;code&gt;acquire&lt;/code&gt; が &lt;code&gt;release&lt;/code&gt; とペアになることを保証します。（このコードを自分で書くのではなく、一般的なパターンを抽象化する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; を使用する方が良いでしょう）。</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">このコードは、重要な部分の非同期例外をマスクすることにより、 &lt;code&gt;acquire&lt;/code&gt; が &lt;code&gt;release&lt;/code&gt; とペアになっていることを保証します。（このコードを自分で書くよりも、一般的なパターンを抽象化する &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; を使用する方がよいでしょう）。</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">このコードは、重要な部分の非同期例外をマスクすることにより、 &lt;code&gt;acquire&lt;/code&gt; が &lt;code&gt;release&lt;/code&gt; とペアになることを保証します。（このコードを自分で書くのではなく、一般的なパターンを抽象化する &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; を使用する方が良いでしょう）。</target>
        </trans-unit>
        <trans-unit id="3494ba5905a6ab7393145cd907a3ba47ca64dbf3" translate="yes" xml:space="preserve">
          <source>This code is in the style of both transformers and mtl, and is compatible with them, though doesn't mimic the module structure or offer the complete range of features in those packages.</source>
          <target state="translated">このコードは、transformers と mtl の両方のスタイルであり、それらと互換性がありますが、モジュール構造を模倣したり、それらのパッケージの完全な機能を提供したりはしていません。</target>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このコンビネータは選択を実装します。パーサー &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 最初に &lt;code&gt;p&lt;/code&gt; を適用します。成功した場合、 &lt;code&gt;p&lt;/code&gt; の値が返されます。&lt;em&gt;入力を消費せずに&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; が失敗した場合、パーサー &lt;code&gt;q&lt;/code&gt; が試行されます。このコンビネータは、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; クラスの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; メンバーおよび &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; の（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）メンバーと同等に定義されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このコンビネータは選択を実装します。パーサー &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 最初に &lt;code&gt;p&lt;/code&gt; を適用します。成功すると、 &lt;code&gt;p&lt;/code&gt; の値が返されます。&lt;em&gt;入力を消費せずに&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; が失敗した場合、パーサー &lt;code&gt;q&lt;/code&gt; が試行されます。このコンビネータは、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; クラスの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; メンバーおよび &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; の（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）メンバーと等しく定義されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">このコンビネータは、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; で表現されます。ユーザー定義のトークンストリームを受け入れるために使用されます。たとえば、ソース位置がタプルされた基本トークンのストリームがあるとします。次に、単一のトークンを受け入れるパーサーを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">このコンビネータは、 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; で表現されます。ユーザー定義のトークンストリームを受け入れるために使用されます。たとえば、ソース位置がタプルされた基本トークンのストリームがあるとします。次に、単一のトークンを受け入れるパーサーを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">このコンビネータは、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; で表現されます。ユーザー定義のトークンストリームを受け入れるために使用されます。たとえば、ソース位置がタプルされた基本トークンのストリームがあるとします。次に、単一のトークンを受け入れるパーサーを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">このコンビネータは、任意の先読みが必要な場合に使用されます。 &lt;code&gt;p&lt;/code&gt; が失敗したときに入力を消費していないふりをしているため、（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターは、最初のパーサーが入力の消費中に失敗した場合でも、2番目の選択肢を試します。</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">このコンビネータは、任意の先読みが必要な場合に使用されます。 &lt;code&gt;p&lt;/code&gt; が失敗したときに入力を消費していないふりをしているため、（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）コンビネーターは、最初のパーサーが入力の消費中に失敗した場合でも、2番目の選択肢を試します。</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">このコマンドを使用すると、適切な端末ではなくパイプを介して対話する場合でも、GHCiにコマンドの完了を要求でき、GHCiの完了をテキストエディターやIDEと統合するように設計されています。</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">このコマンドは、エディタや IDE で識別子のすべての用途をハイライトしてナビゲートするのに便利です。</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">このコマンドは、GHCiをテキストエディタやIDEと統合して、ゴト定義機能を提供する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">このコマンドは、GHCiとテキストエディタやIDEを統合して、show-type-under-point機能を提供する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">この計算は、次の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 例外のいずれかで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3a53acc002bbe269420ba165928d4d81ea8f10ab" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">この計算は、次の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 例外のいずれかで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">この計算が失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">これは、外部呼び出しと &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; の相互作用に関係しています。通常、 &lt;code&gt;throwTo&lt;/code&gt; のターゲットが外部呼び出しに関与している場合、呼び出しが戻るまで例外は発生せず、その間、呼び出し元はブロックされます。これにより応答がなくなる可能性があり、ユーザーによる割り込み（例：Control-C）の場合は特に望ましくありません。 Control-C信号を受信したときのデフォルトの動作（UNIXでは &lt;code&gt;SIGINT&lt;/code&gt; ）は、メインスレッドで &lt;code&gt;UserInterrupt&lt;/code&gt; 例外を発生させることです。メインスレッドがその時点で外部呼び出しでブロックされている場合、プログラムはユーザーの割り込みに応答しません。</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">この条件はタイプによってチェックされません。提供された値が有効な合計注文数であることを自分で確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">これは文字列を変換しますが、スペースは改行不可として保持し、入力リストの各文字列の間に改行を追加します。</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">これは文字列を変換しますが、スペースは改行不可として保持します。</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">これは、 &lt;code&gt;base&lt;/code&gt; の&lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;数値&lt;/a&gt;モジュールによって提供される &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作に対応します。</target>
        </trans-unit>
        <trans-unit id="b849491aac2caa06d22e6da0aa56daf804da18ae" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">これは、 &lt;code&gt;base&lt;/code&gt; の&lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt;モジュールによって提供される &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作に対応します。</target>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">これにより、現在では</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">このデータ型は、等価関係を表します。</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">このデータ型は &lt;code&gt;a&lt;/code&gt; 型の値を処理する演算子を指定します。演算子は、バイナリのインフィックスまたは単項のプレフィックスまたはポストフィックスです。二項演算子には関連性も関連付けられています。</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">このデータ型は、演算子の連想性を指定します。</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">このデータ型は、 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; にポイントごとに持ち上がるのを目撃しています。</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">このデータ型 &lt;code&gt;G&lt;/code&gt; は、種類も種類もGADTに似ています。 &lt;code&gt;g :: G a&lt;/code&gt; があるとします。ここで &lt;code&gt;a :: k&lt;/code&gt; です。そして、それを発見するためのパターンマッチング &lt;code&gt;g&lt;/code&gt; 実際にされ &lt;code&gt;GMaybe&lt;/code&gt; はあなたにその両方伝えます &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; と &lt;code&gt;a ~ Maybe&lt;/code&gt; 。 &lt;code&gt;G&lt;/code&gt; の定義では、&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;が有効である必要がありますが、 &lt;code&gt;G&lt;/code&gt; でのパターンマッチングには、&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;以外の拡張は必要ありません。これが機能することは、実際には通常のGADTの単純な拡張であり、種類と型が同じであるという事実の結果です。</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">このデータ型は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; よる &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; バッファごとの実行の共通インターフェースとして機能します。このインタフェースの典型的なユーザーがいる &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; などiterateeスタイルライブラリ &lt;code&gt;enumerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">このデコーダには、返す前にすべての入力を読み込む必要があるという欠点があります。一方で、デコーダエラーなしでデコードできることがわかるまでは、何も返しません。</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">この定義により、オペレーティングシステムに基づいた条件付きコンパイルが可能になります。ここで、「os」は現在のオペレーティングシステムの名前です（例： &lt;code&gt;linux&lt;/code&gt; 、Windowsの &lt;code&gt;mingw32&lt;/code&gt; 、 &lt;code&gt;solaris&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">この定義により、ホストアーキテクチャに基づく条件付きコンパイルが可能になります。ここで、「arch」は現在のアーキテクチャの名前です（たとえば、 &lt;code&gt;i386&lt;/code&gt; 、 &lt;code&gt;x86_64&lt;/code&gt; 、 &lt;code&gt;powerpc&lt;/code&gt; 、 &lt;code&gt;sparc&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">この定義により、 &lt;code&gt;f1&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; で厳密になりますが、強打がなければ、遅延になります。もちろん、Bangパターンはネストすることができます：</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">これは、通常の &lt;code&gt;deriving&lt;/code&gt; 句と同じように、コンテキストが推測される派生 &lt;code&gt;Eq (Foo a)&lt;/code&gt; インスタンスを示します。スタンドアロンの &lt;code&gt;deriving&lt;/code&gt; 宣言でのワイルドカードのその他の使用は禁止されています。</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">この設計は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の実装に &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへの完全なアクセスを提供します。したがって、指定された &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の外側にあるものを上書きしないように細心の注意を払う必要があります。さらに、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; が参照透過であることを保証するために、さらに注意が必要です。詳細については、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 関数のコメントを参照してください。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを使用して &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実装する場合、&lt;em&gt;安全ベルト&lt;/em&gt;は&lt;em&gt;まったくない&lt;/em&gt;ことに注意してください。Haskellサーバーでの次のバッファーオーバーフロー攻撃を可能にする可能性のあるコードを記述しています！</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">この設計により、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の実装に &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへのフルアクセスが提供されます。したがって、指定された &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の外側にあるものを上書きしないように細心の注意を払う必要があります。さらに、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; が参照透過性になるようにさらに注意を払う必要があります。詳細については、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; のコメントと &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 関数を参照してください。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションを使用して &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を実装する場合、&lt;em&gt;安全ベルト&lt;/em&gt;は&lt;em&gt;まったくない&lt;/em&gt;ことに注意してください。Haskellサーバーで次のバッファオーバーフロー攻撃を可能にする可能性のあるコードを記述しています。</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; の&lt;/a&gt;動作方法のため、この区別は重要です。派生 &lt;code&gt;Functor Right&lt;/code&gt; インスタンスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="35e478384f40b7a1e661dbe9f918af72fd276223" translate="yes" xml:space="preserve">
          <source>This distinction is only meaningful for monads which have multiple exit points, such as &lt;code&gt;Except&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt;. For monads that only have a single exit point, there is no difference between &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt;, except that &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; has a more constrained type.</source>
          <target state="translated">この区別は、 &lt;code&gt;Except&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; などの複数の出口点を持つモナドにのみ意味があります。出口点が1つしかないモナドの場合、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; の型がより制約されていることを除いて、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; の間に違いはありません。</target>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">これはランタイムパスを埋め込みません。これは、標準の場所または &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 環境変数で指定されたディレクトリで使用可能な共有ライブラリに依存しています。</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">これはもう機能しません。モジュールと仮定 &lt;code&gt;C&lt;/code&gt; の輸入をモジュール &lt;code&gt;B&lt;/code&gt; を、及び &lt;code&gt;B&lt;/code&gt; の輸入は、モジュール &lt;code&gt;A&lt;/code&gt; を。だから、モジュールに変更 &lt;code&gt;A&lt;/code&gt; はモジュールが必要な場合があります &lt;code&gt;C&lt;/code&gt; の再コンパイルする、とするとき、したがって &lt;code&gt;A.hi&lt;/code&gt; が変化し、我々は、かどうかを確認する必要があります &lt;code&gt;C&lt;/code&gt; は、再コンパイルする必要があります。ただし、 &lt;code&gt;C&lt;/code&gt; の依存関係は &lt;code&gt;B.hi&lt;/code&gt; ではなく &lt;code&gt;A.hi&lt;/code&gt; のみをリストし、 &lt;code&gt;A&lt;/code&gt; への一部の変更（ &lt;code&gt;B&lt;/code&gt; によってエクスポートされた関数のインラインに表示される関数の定義を変更するなど）は &lt;code&gt;B.hi&lt;/code&gt; 変更しない可能性があります。こんにちは。だから今&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">この排除の &lt;code&gt;bad&lt;/code&gt; 変数ので、 &lt;code&gt;x&lt;/code&gt; が表現多型タイプを持っているでしょう。</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">これにより、コード生成器のアセンブリ段階でのショートカットが可能になります。簡単に言えば、ショートカットとは、命令ブロックAが無条件にジャンプだけで構成されている場合、AへのジャンプをすべてAの後継へのジャンプで置き換えることを意味します。</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">このエンコードはどちらの方向に行っても失敗することはありません。しかし、符号化は情報を破棄するので、encodeに続いてdecodeもアイデンティティではありません。</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">このエンコーディングでは、NUL を表すためにバイト列 &quot;xc0x80&quot; を使用し、文字列は NUL で終端する。</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これにより、バイフォールドの各ステップが適用される前に弱いヘッドノーマルフォームに強制され、そうでなければ発生するサンクのコレクションが回避されます。これは、有限構造を厳密に1つのモノリシックな結果（たとえば、 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ）に厳密に削減したい場合です。</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これにより、適用される前に、折り畳みの各ステップが弱いヘッドの通常の形式に強制され、そうでなければ発生するサンクのコレクションが回避されます。これは多くの場合、有限リストを1つのモノリシックな結果（ &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）に厳密に減らしたいものです。</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これにより、適用される前に、折り畳みの各ステップが弱いヘッドの通常の形式に強制され、そうでなければ発生するサンクのコレクションが回避されます。これは多くの場合、有限リストを1つのモノリシックな結果（ &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）に厳密に減らしたいものです。</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">このエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">これにより、モジュールが信頼されていることが確認されますが、保証はモジュールの作成者によって提供されます。次に、このモジュールのクライアントは、モジュールを含むパッケージを信頼することを指定して、モジュールの作成者を信頼することを指定します。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;はモジュールを安全な言語に制限しません。ただし、重複するインスタンスの解決を制限して、&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全な重複インスタンス&lt;/a&gt;のみを許可します。また、safe importキーワードを使用できます。</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">この例では、エスケープの連続がどのように動作するかを説明し、その使用方法の典型的なパターンを示しています。</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">この例は</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">この例は、 &lt;code&gt;Type&lt;/code&gt; コンストラクターを直接使用した場合のより複雑な構成に相当します。</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">この例は &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 変換されるため、 &lt;code&gt;Functor&lt;/code&gt; のみが必要です。より複雑な例では &lt;code&gt;Applicative&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">次の例は、コンストラクターに含まれる値を気にしない場合に、 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; を使用してパターンマッチングを回避する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">次の例は、コンストラクターに含まれる値を気にしない場合に、 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; を使用してパターンマッチングを回避する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">この例では、Microsoft Word の &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 関数を使用していますが、最初の関数の前に &lt;code&gt;HsStart&lt;/code&gt; が呼び出され、最後の関数の後にHsEndが呼び出された場合、 &lt;code&gt;HsEnd&lt;/code&gt; に機能します。</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例は、オリジナルのConcurrent Haskell論文から改変されました。より高レベルの同期プリミティブを構築するために使用される &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; のその他の例については、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">次の例に示すように、この例外はステートメントには適用されません。</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">この例外は、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; を呼び出す別のスレッドによって、または何らかの理由でスレッドを終了する必要がある場合はシステムによって発生します。</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">この例外は、ユーザが通常のメカニズム(コンソールのControl-Cなど)を使ってプログラムを終了するように要求した場合、プログラムのメインスレッドでデフォルトで発生します。</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">この拡張機能により、プログラマはリスト表記法を使用して、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Map&lt;/code&gt; 、 &lt;code&gt;IntMap&lt;/code&gt; 、 &lt;code&gt;Vector&lt;/code&gt; 、 &lt;code&gt;Text&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; などの構造を構築できます。次のコードリストは、いくつかの例を示しています。</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">この拡張により、フォーム &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 制約を書き込むことができます。Eq b =&amp;gt; Eq（fb）、これは &lt;code&gt;(==)&lt;/code&gt; メソッドの2番目の使用法から生じる &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 制約を解決するために必要です。</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">この拡張機能により、&lt;a href=&quot;#data-instance-declarations&quot;&gt;Dataインスタンス宣言&lt;/a&gt;、&lt;a href=&quot;#type-instance-declarations&quot;&gt;Typeインスタンス宣言&lt;/a&gt;、&lt;a href=&quot;#closed-type-families&quot;&gt;Closed型ファミリー&lt;/a&gt;、&lt;a href=&quot;#assoc-inst&quot;&gt;関連インスタンス&lt;/a&gt;、および&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewriteルール&lt;/a&gt;での型変数とkind変数の明示的な数量化も可能になります。</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="translated">この拡張機能は、データファミリインスタンスに関するいくつかの制限も緩和します。特に、&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; を&lt;/a&gt;使用すると、 &lt;code&gt;newtype instance&lt;/code&gt; に、 &lt;code&gt;Type&lt;/code&gt; だけでなく、 &lt;code&gt;TYPE r&lt;/code&gt; 戻り種類を指定できます。たとえば、次の &lt;code&gt;newtype instance&lt;/code&gt; 宣言が許可されます。</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">この拡張機能により、以下の場所での親切署名が可能になります。</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">この拡張は&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; を&lt;/a&gt;一般化します。GND を使用して &lt;code&gt;Num Unicode&lt;/code&gt; を導出するには（ &lt;code&gt;deriving newtype Num&lt;/code&gt; ）、 &lt;code&gt;Num Int&lt;/code&gt; インスタンスを再利用する必要があります。 &lt;code&gt;DerivingVia&lt;/code&gt; 、我々は明示的に表現タイプを指定することができ &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="translated">この拡張機能は、newtypeに完全なユーザー指定の種類の署名（CUSK）があるかどうかの判断に影響を与えます。正確な影響は&lt;a href=&quot;#complete-kind-signatures&quot;&gt;、CUSKのセクションで&lt;/a&gt;指定されています。</target>
        </trans-unit>
        <trans-unit id="9ff362e6ce2b0d8092c35b1a623732b4842ee02e" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">この拡張機能は、GHC 8.6.1以降、&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal（MFP）の&lt;/a&gt;下でデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="db2c878062f2c6f99bf839e6b59f2f657c40d838" translate="yes" xml:space="preserve">
          <source>This extension is temporary, and will be deprecated in a future release.</source>
          <target state="translated">この拡張機能は一時的なもので、将来のリリースでは非推奨となります。</target>
        </trans-unit>
        <trans-unit id="51aed31ab5dc37f8c4c608df090d56016afc9279" translate="yes" xml:space="preserve">
          <source>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</source>
          <target state="translated">この機能はGHC 8.0.xでは実験的なものですが、今後のリリースではデフォルトになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="248986ebd9528e7c25e52eb6e4b4dede26b21415" translate="yes" xml:space="preserve">
          <source>This feature is no longer in GHC, but rewrite rules let you do the same thing:</source>
          <target state="translated">この機能はもうGHCにはありませんが、ルールを書き換えることで同じことができます。</target>
        </trans-unit>
        <trans-unit id="53f2d728a4138ae527fa096fa51af75f94d85b2c" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">この機能は、GHCに付属するコアライブラリ以外での使用を目的としていません。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC開発者wikiを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9ee160906b857c67fe57bb11a964fcfc779b0e3a" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">この機能は、GHCに付属するコアライブラリの外部での使用を目的としたものではありません。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops&quot;&gt;GHC開発者ウィキを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a2a0010dea23f4d2c3a5e18529c4edce4ab678e9" translate="yes" xml:space="preserve">
          <source>This feature was added in GHC 7.4.1.</source>
          <target state="translated">この機能はGHC 7.4.1で追加されました。</target>
        </trans-unit>
        <trans-unit id="55b7950f0dfe4e76a8ae330af2ece8c8a531dce2" translate="yes" xml:space="preserve">
          <source>This flag also enables the printing of &lt;em&gt;inferred&lt;/em&gt; type variables inside braces. See &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;.</source>
          <target state="translated">このフラグは、中括弧内の&lt;em&gt;推定&lt;/em&gt;型変数の出力も有効にします。&lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;推定型変数と指定された型変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b07b2f670bc045df573c1ececcdcb07736068e4d" translate="yes" xml:space="preserve">
          <source>This flag appends a colon-separated list of &lt;code&gt;dirs&lt;/code&gt; to the search path.</source>
          <target state="translated">このフラグは、コロンで区切ったリスト追加 &lt;code&gt;dirs&lt;/code&gt; 検索パスに。</target>
        </trans-unit>
        <trans-unit id="b10d8784b554d32814d37717727898e2e17029f6" translate="yes" xml:space="preserve">
          <source>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</source>
          <target state="translated">このフラグを有効にすると、モジュールの宣言された安全プロパティ (Safe,Unsafe,Trustworthy)を上書きして、これらのフラグが何も指定されていないかのようにコンパイルを進めることができます。これは特にプラグインを使ってコンパイルする場合に便利で、 通常はコンパイルされたモジュールが安全ではないとマークされます。</target>
        </trans-unit>
        <trans-unit id="24dac7bf8e47224079c398a6d277a8612ab70ec9" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</source>
          <target state="translated">こ のフラグは、 有効なホールはめ込み提案の冗長性を減少させるために切り替え る こ と がで き 、 提案の出自や型の適用を表示 し ない よ う にす る こ と がで き ます。</target>
        </trans-unit>
        <trans-unit id="65ce608eee3aba6eebf0d253b9eec2e8fe86f19e" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to turn off the display of valid hole fits entirely.</source>
          <target state="translated">このフラグは、有効なホールフィットの表示を完全にオフにするかどうかを切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="090f73c78c09543d9d38b2c5a37d696699bd497f" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flags, which enables this behaviour for &lt;a href=&quot;#typed-holes&quot;&gt;typed holes&lt;/a&gt; and variables. Should you so wish, it is possible to enable &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; without enabling &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;, by explicitly specifying &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fno-defer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; on the command-line after the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">このフラグは、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;フラグと&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;フラグを暗黙&lt;a href=&quot;#typed-holes&quot;&gt;指定し&lt;/a&gt;、型付きの穴と変数に対してこの動作を有効にします。必要に応じて、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fno-defer-typed-holes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;明示的に指定することにより、&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;を有効にせずに&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;を有効にすることができます。-fdefer- &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;フラグの後のコマンドラインの-defer-out-of-scope-variables</target>
        </trans-unit>
        <trans-unit id="8a419a9746c4cf7f690ae762b4c975fdd0783957" translate="yes" xml:space="preserve">
          <source>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won&amp;rsquo;t be worse with the next release.</source>
          <target state="translated">この旗はハッカーの領土です。このフラグの主な目的は、新しいコードレイアウトアルゴリズムのデバッグと調整を簡単にすることです。より良い結果を与える値が次のリリースで悪化しないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="4f00c8bb7e27cc51ca8b0f0d3dba471e43e3c711" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a definition is not inlined.</source>
          <target state="translated">このフラグは、定義がインライン化されていない理由をデバッグするのに便利です。</target>
        </trans-unit>
        <trans-unit id="259f9f5ba8da11cbb10f0d1540dcc3a2d81b3b63" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a rule you expect to be firing isn&amp;rsquo;t.</source>
          <target state="translated">このフラグは、起動するはずのルールが起動しない理由をデバッグするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="913346e87539751c35ed9c7fbbe9dacd336e394e" translate="yes" xml:space="preserve">
          <source>This flag offers a workaround, albeit a slightly convoluted one. To be able to load an object file outside of the low 2Gb, the object code needs to be compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt;. When the &lt;code&gt;+RTS -xp&lt;/code&gt; flag is passed, the linker will assume that all object files were compiled with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and load them anywhere in the address space. It&amp;rsquo;s up to you to arrange that the object files you load (including all packages) were compiled in the right way. If this is not the case for an object, the linker will probably fail with an error message when the problem is detected.</source>
          <target state="translated">このフラグは、少し複雑なものですが、回避策を提供します。低2Gbの外部でオブジェクトファイルをロードできるようにするには、オブジェクトコードを &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; でコンパイルする必要があります。場合は &lt;code&gt;+RTS -xp&lt;/code&gt; フラグが渡され、リンカは、すべてのオブジェクトファイルがコンパイルされたと仮定します &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; とアドレス空間の任意の場所にそれらをロードします。ロードするオブジェクトファイル（すべてのパッケージを含む）が正しい方法でコンパイルされるように調整するのはあなた次第です。これがオブジェクトに当てはまらない場合、問題が検出されたときにリンカーがエラーメッセージで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0d8510f05be6657462af6908558e01f9535cc7df" translate="yes" xml:space="preserve">
          <source>This flag passes &lt;code&gt;-Wundef&lt;/code&gt; to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the &lt;code&gt;#if&lt;/code&gt; directive on undefined identifiers.</source>
          <target state="translated">このフラグは、 &lt;code&gt;-Wundef&lt;/code&gt; をCプリプロセッサに（使用されている場合）渡し、プリプロセッサが未定義の識別子に対する &lt;code&gt;#if&lt;/code&gt; ディレクティブの使用を警告するようにします。</target>
        </trans-unit>
        <trans-unit id="1da039cc7b4dc5b7877656e448f679fa2aaf620b" translate="yes" xml:space="preserve">
          <source>This flag selects one of a number of modes for finding shared libraries at runtime. See &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;Finding shared libraries at runtime&lt;/a&gt; for a description of each mode.</source>
          <target state="translated">このフラグは、実行時に共有ライブラリを検索するためのいくつかのモードの1つを選択します。各モードの説明については&lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;、実行時の共有ライブラリの検索を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="707ef7038c152a9d95c30f93e519ab392f0434e0" translate="yes" xml:space="preserve">
          <source>This flag sets the size (in bytes) threshold above which the second approach is used. You can disable the second approach entirely by setting the threshold to 0.</source>
          <target state="translated">このフラグは、2 番目のアプローチが使用されるサイズ(バイト数)のしきい値を設定します。しきい値を 0 に設定することで、2 番目のアプローチを完全に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="fd5e5d63941b332238370339bd4abcd493f7faf1" translate="yes" xml:space="preserve">
          <source>This flag specifies that a backspace at column 0 wraps the cursor to the last column of the previous line.</source>
          <target state="translated">このフラグは、0列目のバックスペースがカーソルを前の行の最後の列に折り返すことを指定します。</target>
        </trans-unit>
        <trans-unit id="03626a7094edacd615db3da035980eaa87b66cfc" translate="yes" xml:space="preserve">
          <source>This flag specifies that the cursor wraps automatically from the last column of one line to the first column of the next.</source>
          <target state="translated">このフラグは、カーソルがある行の最後の列から次の行の最初の列へと自動的に折り返されることを指定します。</target>
        </trans-unit>
        <trans-unit id="152fd56bf497fbd287fadf04927a68a1b45161ca" translate="yes" xml:space="preserve">
          <source>This flag specifies that the terminal does not perform &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt;-style wrapping when the character which would cause the wraparound is a control character. This is also known as the &quot;newline glitch&quot; or &quot;magic wrap&quot;.</source>
          <target state="translated">このフラグは、折り返しの原因となる文字が制御文字である場合に、端末が &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt; スタイルの折り返しを実行しないことを指定します。これは「ニューライングリッチ」または「マジックラップ」とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="237ea7657c0749769ad0460f79b1ebe14776910d" translate="yes" xml:space="preserve">
          <source>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt; on how to create them.</source>
          <target state="translated">このフラグは、共有されたHaskellライブラリに対してリンクするようGHCに指示します。このフラグは依存ライブラリの選択にのみ影響し、現在のターゲットの形式には影響しません（-sharedを参照）。&lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;共有ライブラリの&lt;/a&gt;作成方法については、共有ライブラリの使用を参照してください。</target>
        </trans-unit>
        <trans-unit id="548eff16b1f921e7136ec0c8b1d05c12f1aee8db" translate="yes" xml:space="preserve">
          <source>This flag used to be simply &lt;code&gt;-k&lt;/code&gt;, but was renamed to &lt;code&gt;-ki&lt;/code&gt; in GHC 7.2.1. The old name is still accepted for backwards compatibility, but that may be removed in a future version.</source>
          <target state="translated">このフラグは以前は単に &lt;code&gt;-k&lt;/code&gt; でしたが、GHC 7.2.1では &lt;code&gt;-ki&lt;/code&gt; に名前が変更されました。古い名前は下位互換性のために引き続き受け入れられますが、将来のバージョンでは削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="132a6f0fb187f19db841ab54e53adaeca2ba441f" translate="yes" xml:space="preserve">
          <source>This flag warns if you declare a module without declaring an explicit export list. For example</source>
          <target state="translated">このフラグは、明示的なエクスポートリストを宣言せずにモジュールを宣言した場合に警告します。例えば</target>
        </trans-unit>
        <trans-unit id="c9662da7b45b17a0a6428b9dfe5bd157c250c8da" translate="yes" xml:space="preserve">
          <source>This flag warns if you use an unqualified &lt;code&gt;import&lt;/code&gt; declaration that does not explicitly list the entities brought into scope. For example</source>
          <target state="translated">このフラグは、スコープに入れられたエンティティーを明示的にリストしない修飾されていない &lt;code&gt;import&lt;/code&gt; 宣言を使用すると警告します。例えば</target>
        </trans-unit>
        <trans-unit id="164c1b4e302cfd37b98b634159b85132a613d2b3" translate="yes" xml:space="preserve">
          <source>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for information about unlifted types.</source>
          <target state="translated">このフラグは、型が持ち上げられていない変数をバインドするパターンを書き込むときに警告を発しますが、パターンはbangパターンでもベア変数でもありません。unlifted型については、unboxed &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;型&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cae0b42613ae5635daabfb73c1fd1a6fde87c094" translate="yes" xml:space="preserve">
          <source>This flag was not implemented correctly and is now deprecated. It will be removed in a later version of GHC.</source>
          <target state="translated">このフラグは正しく実装されておらず、現在は非推奨となっています。これは GHC の後のバージョンでは削除される予定です。</target>
        </trans-unit>
        <trans-unit id="a0c3352dc95a1207a9c6e17148992da28a73903b" translate="yes" xml:space="preserve">
          <source>This form is intended to catch cases where an imported function that is marked as &lt;code&gt;INLINABLE&lt;/code&gt; (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</source>
          <target state="translated">このフォームは、 &lt;code&gt;INLINABLE&lt;/code&gt; （おそらく特殊化を有効にする）としてマークされたインポートされた関数が、それ自体は特殊化されていない他の関数を呼び出すために特殊化できない場合をキャッチすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="05bd3fd9bbf23e07af768726368e949e8e01172d" translate="yes" xml:space="preserve">
          <source>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;. As you can see from the type, this function lets f &amp;ldquo;project out&amp;rdquo; some information from the elements of the list it is transforming.</source>
          <target state="translated">この形式は前の形式と似ていますが、fの最初の引数として渡される関数を作成できます。結果として、fはタイプ &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 持つ必要があります。（a-&amp;gt; t）-&amp;gt; [a]-&amp;gt; [a]。タイプからわかるように、この関数は、変換しているリストの要素からいくつかの情報を「投影」します。</target>
        </trans-unit>
        <trans-unit id="b210b3ae2d9ae56e35b1c184f6366fb5e908d874" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">この関数は、オプションの先行符号文字と、それに続く少なくとも1つの10進数字を受け入れます。末尾の &lt;code&gt;'.'&lt;/code&gt; 除いて、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 関数で受け入れられるものと同様の構文。または &lt;code&gt;'e'&lt;/code&gt; &lt;em&gt;ではない&lt;/em&gt;数字が続くが消費されません。</target>
        </trans-unit>
        <trans-unit id="5f4a157f15275b0104f4661492b13677fdbb6264" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">この関数は、オプションの先行記号文字とそれに続く少なくとも1つの10進数を受け入れます。末尾の &lt;code&gt;'.'&lt;/code&gt; 除いて、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 関数で受け入れられる構文と同様の構文。または、数字が後に続か&lt;em&gt;ない&lt;/em&gt; &lt;code&gt;'e'&lt;/code&gt; は消費されません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a796cd8e434fa9169ce349d782e3ca0927d44d88" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">この関数は、指定された &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; にファイナライザを追加します。ファイナライザは、すでに登録されている同じオブジェクトの他のすべてのファイナライザの&lt;em&gt;前&lt;/em&gt;に実行されます。</target>
        </trans-unit>
        <trans-unit id="2c44cb1ccf0b7e4784ceeb306a067bdfeb7b206c" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;ForeignPtr&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">この関数は、指定された &lt;code&gt;ForeignPtr&lt;/code&gt; にファイナライザを追加します。ファイナライザは、すでに登録されている同じオブジェクトの他のすべてのファイナライザの&lt;em&gt;前&lt;/em&gt;に実行されます。</target>
        </trans-unit>
        <trans-unit id="f425649d9029247ad78fad40decd5202c4bc27eb" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given foreign object. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">この関数は、指定された外部オブジェクトにファイナライザを追加します。ファイナライザは、すでに登録されている同じオブジェクトの他のすべてのファイナライザの&lt;em&gt;前&lt;/em&gt;に実行されます。</target>
        </trans-unit>
        <trans-unit id="f81d22635890e3a218f1ce58339b1c6ca6b2b5e3" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the current thread's event manager when using the threaded RTS and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">この関数は常に返し &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; RTSとねじ使用した場合、現在のスレッドのイベントマネージャを &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; そう。</target>
        </trans-unit>
        <trans-unit id="1a7ca54d1ebb1f65a298f3f5394187b62319bd58" translate="yes" xml:space="preserve">
          <source>This function behaves as though it was defined as follows:</source>
          <target state="translated">この関数は、以下のように定義されているかのように動作します。</target>
        </trans-unit>
        <trans-unit id="a19a74c60710c427c9a8983f923cfe3116f4e33e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">この関数は、入力領域に事前入力することを除いて、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; とまったく同じように動作します。入力領域にあるテキストは、2つの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を持つ2タプルとして指定されます。タプルの左側の文字列（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; を呼び出すことによって取得される）はカーソルの左側に表示されるものであり、右側の文字列（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; を呼び出すことによって取得される）はカーソルの右側に表示されるものです。</target>
        </trans-unit>
        <trans-unit id="1e7f64006d44420f7d5449007f9ad343dd8f086e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">この関数は、入力領域に事前入力されることを除いて、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; とまったく同じように動作します。入力領域にあるテキストは、2つの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 持つ2タプルとして指定されます。タプルの左側の文字列（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; を呼び出すことによって取得）はカーソルの左側に表示されるものであり、右側の文字列（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; を呼び出すことによって取得される）はカーソルの右側に表示されるものです。</target>
        </trans-unit>
        <trans-unit id="ccadaf8449c87b756fcca9de3051eea76595bb20" translate="yes" xml:space="preserve">
          <source>This function blocks only if there is no data available, and EOF has not yet been reached. Once EOF is reached, this function returns an empty string instead of throwing an exception.</source>
          <target state="translated">この関数は、利用可能なデータがなく、EOFに達していない場合にのみブロックします。EOFに到達すると、この関数は例外を発生させずに空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3727686d1f0656f78fbd676216e6218bba0d8f05" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">この関数は、特にファイル名自体に含まれる可能性がある場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; よりも予測可能です &lt;code&gt;.&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="95f9843654954e98c26a755ad5eb70155e80d09e" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">この関数は、特にファイル名自体に含まれる可能性がある場合、 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; よりも予測可能です &lt;code&gt;.&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="6370e62b7224731eb33323a61cd0cd0212bd73ab" translate="yes" xml:space="preserve">
          <source>This function can be used to parse commandline arguments and return the split up arguments as elements in a list.</source>
          <target state="translated">この関数は、コマンドライン引数を解析し、分割された引数をリストの要素として返すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="7b011ec479c4f18015f65a01a6cb42ad6c894e37" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">この関数は、あるタイプによってパラメーター化された &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を別のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="8455333cef6a211c11d46770009f2e17b149dc91" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">この関数は、あるタイプによってパラメーター化された &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を別のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="4c95a06b11246310d156afc3703af8aa75228ea4" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">この関数は、あるタイプによってパラメーター化された &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; を別のタイプにキャストします。</target>
        </trans-unit>
        <trans-unit id="bae8bc388aa8fda5c095416ea7ccdf604e21a4b9" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="e3b38848479394206747ac44eca6fc387251ec91" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="5db91917bf331211a29772aa52154e422f3f1d5b" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="519eb4a4b4c327867fd23f6eab3128242f48c9bb" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、先行符号文字を処理しません。符号付き入力を処理する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="857206c786beb79b34c3684c023645a579f1bf0a" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">この関数はゼロコピーを実行し、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をラップ解除して &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; として表示します。次の2つの点で&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0c2f12c1f574e8470c8cd228760ee018fd8aa95d" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">この関数は、ゼロコピーを行い、単にアンラップ &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として表示する &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; を。&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="a47c3f2d7d39a2c3b063895b58a717924193e65c" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">この関数はゼロコピーを実行し、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をアンラップして &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; として表示するだけです。それは2つの点で&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="c7536fe5974322621a8dd1f75ea634bfbda36cef" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">この関数はゼロコピーを実行し、 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; をアンラップしてCStringLenとして表示する &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; です。&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="f085bd357a8ba52ec5bf8ea2e8098bb00f21c4f3" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">この関数は、問題の外部オブジェクトがIOアクションのシーケンスの特定の場所で生きていることを保証します。特に &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; はtouchForeignPtrを実行し &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 、それがユーザーのアクションを実行した後。</target>
        </trans-unit>
        <trans-unit id="fb2f540bf09969c8d0c8f8908ba854010bd23f1b" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">この関数は、問題の外部オブジェクトがIOアクションのシーケンスの特定の場所で生きていることを保証します。特に &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; はtouchForeignPtrを実行し &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 、それがユーザーのアクションを実行した後。</target>
        </trans-unit>
        <trans-unit id="2149a9af262bcc49b7038b2f4d5b65dcac58accb" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">この関数は、問題の外部オブジェクトがIOアクションのシーケンスの特定の場所で生きていることを保証します。特に &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; はtouchForeignPtrを実行し &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 、それがユーザーのアクションを実行した後。</target>
        </trans-unit>
        <trans-unit id="826e259566faf8425ada2d502fd2ea8be00aa816" translate="yes" xml:space="preserve">
          <source>This function exists because in order to thread their effects through the execution of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, monad transformers need values to be threaded from &lt;code&gt;use&lt;/code&gt; to &lt;code&gt;release&lt;/code&gt; and from &lt;code&gt;release&lt;/code&gt; to the output value.</source>
          <target state="translated">実行することによりその効果を通すためにので、この関数は存在 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 、モナド変圧器からねじする値を必要 &lt;code&gt;use&lt;/code&gt; に &lt;code&gt;release&lt;/code&gt; とから &lt;code&gt;release&lt;/code&gt; 出力値に。</target>
        </trans-unit>
        <trans-unit id="56e6ded1b8cebed967e3f67bfe07578a6914f462" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">この関数は、外部ポインターのポインターコンポーネントを抽出します。これは、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; への引数が特定の外部ポインターの最後の使用オカレンスであるかのように、潜在的に危険な操作です。そのファイナライザーが実行され、取得したプレーンポインターが無効になる可能性があります。したがって、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; が存在していることが保証されている必要がある場合、つまり別の使用状況が発生している場合は、touchForeignPtrを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="49a9ef9954f7355cd3182b557ae76bf73f873f39" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">この関数は、外部ポインターのポインターコンポーネントを抽出します。これは、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; への引数が特定の外部ポインターの最後の使用オカレンスであるかのように、潜在的に危険な操作です。そのファイナライザーが実行され、取得したプレーンポインターが無効になる可能性があります。したがって、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; が存在していることが保証されている必要がある場合、つまり別の使用状況が発生している場合は、touchForeignPtrを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="297ce1fcde50c3e64b2e180ca7a8295dfe927277" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; の結果と比較するのと同じ答えを返しますますが、文字数が数値よりも多い場合は短絡する可能性があるため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="b9bfe488bf922598761ef0e89e23f74a82ced08d" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number or if the stream can't possibly be as long as the number supplied, and hence be more efficient.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt; の結果と比較するのと同じ答えを返しますますが、文字数が数値よりも大きい場合、またはストリームが指定された数ほど長くなることができない場合は短絡する可能性があるため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="84c6fa989d414314e9aa49500aecc381f432a513" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; の結果と比較するのと同じ答えを返しますますが、文字数が数値よりも多い場合は短絡する可能性があるため、より効率的です。</target>
        </trans-unit>
        <trans-unit id="afb23fb6497a24d6ecb9c3763d5c34edba9c40d0" translate="yes" xml:space="preserve">
          <source>This function has been available from the &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; module for some time, and is part of the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module since version 1.2.1.0.</source>
          <target state="translated">この機能は、より利用されている&lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internalsの&lt;/a&gt;いくつかの時間のためのモジュール、およびの一部であり、&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;、バージョン1.2.1.0以降モジュールの。</target>
        </trans-unit>
        <trans-unit id="a6e9d76dad212825f2ce225dc9cdac55e8d4e959" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt; に移動しました。</target>
        </trans-unit>
        <trans-unit id="be411b927981a56314a00c20ba75fa59b5652a67" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; に移動しました。</target>
        </trans-unit>
        <trans-unit id="2c2e5206205cd6b75d161fb7bfc7299c5bdb8abf" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数はフリーズした &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; には影響しません。</target>
        </trans-unit>
        <trans-unit id="1be0ffbb5619ad9aa9e30d9508745c85fb811ff4" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数はフリーズした &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; には影響しません。</target>
        </trans-unit>
        <trans-unit id="36afc198b9f7118549c1b6104d61dadd4fcd1cd4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt; 2つの点でで。</target>
        </trans-unit>
        <trans-unit id="e2a132e2c97ab0ed1a1b3a90355bbe48b412b6f7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, as there may be other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s referring to the same underlying pages. If you use this, you need to have a proof of some kind that all &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s ever generated from the underlying byte array are no longer live.</source>
          <target state="translated">同じ基本ページを参照している他の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; が存在する可能性があるため、この関数は&lt;em&gt;安全&lt;/em&gt;ではありません。これを使用する場合は、すべての &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; があることを証明する必要があります。、基礎となるバイト配列から生成されたがもはや存在しないです。</target>
        </trans-unit>
        <trans-unit id="bf420b59471bce124dbbd8b697170ee16a0713d7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, it is possible to break referential transparency by modifying the underlying buffer pointed to by the first argument. Any changes to the original buffer will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は&lt;em&gt;安全&lt;/em&gt;ではあり&lt;em&gt;ません&lt;/em&gt;。最初の引数によってポイントされた基礎となるバッファを変更することにより、参照の透過性を壊すことが可能です。元のバッファーへの変更は、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されますます。</target>
        </trans-unit>
        <trans-unit id="3455262f8a39897a50aa39230052cbe6dba0d568" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されます参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="1834d9d84b56bb752c51f02a1d644b2b93d96323" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="e2747e624978d112ce90afa471f172dfb2b9cd31" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されます参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="f0382305dc3450f3e698022f8c72e2ed93bc7c33" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映されます参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="f349071f25d8991d866f99530006dd7090d11a0c" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="e7b49b304d9d1b37bde4bfa9bfeb7383e8f4a58d" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; が後で変更された場合、この変更は結果の &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="4a191d5e90e0d3c89ab168efaec7413d2cd0acb4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; が指すバッファーを変更すると、この変更は結果の &lt;code&gt;ByteString&lt;/code&gt; に反映されます。参照の透過性がます。</target>
        </trans-unit>
        <trans-unit id="ce62a4da0ca7ff6594e5735e96a49ced57bae709" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">この機能は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。元の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; が指すバッファーを変更すると、この変更は結果の &lt;code&gt;ByteString&lt;/code&gt; に反映され、参照透過性が失われます。</target>
        </trans-unit>
        <trans-unit id="c9bb19123a210482015c0eb529407c8c92bd8a9d" translate="yes" xml:space="preserve">
          <source>This function is almost identical to &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;. The only differences are:</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; とほとんど同じです。唯一の違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="127b48d0ce942f2e91014031d7ba1b7c2f584c47" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">この関数は、ファイナライザを2回呼び出して&lt;em&gt;二重解放&lt;/em&gt;エラーが発生する場合、または &lt;code&gt;malloc&lt;/code&gt; で割り当てられていない &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; を渡す場合にも安全ではありません。。</target>
        </trans-unit>
        <trans-unit id="725d98580cd2d533b5eb08b0b83d5983bcb4d0b9" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">この関数は、ファイナライザーを2回呼び出すと、&lt;em&gt;ダブルフリー&lt;/em&gt;エラーが発生する場合や、 &lt;code&gt;malloc&lt;/code&gt; で割り当てられていない &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; を渡す場合にも安全ではありません。</target>
        </trans-unit>
        <trans-unit id="a1352738c1dd68227a434686b430958d3c19705e" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; を使用する</target>
        </trans-unit>
        <trans-unit id="3624112a91081c7d0092b5f7cbbb5f82d405f7c9" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; を使用する。</target>
        </trans-unit>
        <trans-unit id="b637539c4592b1c460f40d32f474fe342dccfe09" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 使用ます。</target>
        </trans-unit>
        <trans-unit id="e297580fc2021dc8c611b1cab7ef8ab0b1a171b6" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d928e0ca94addd99cca4a82d7c03710b0e1ff8e8" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8a7dbf169335c01f89eb6a63ed0156362fcda8c5" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c431a15b17f66529ec0971f021718a3de7606559" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="78dce4476ccaf3b80909ed078582168f3c380495" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0be1b4711ed0b36e7147869439e2d34b0cf4d927" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は削除され、使用できなくなりました。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="13a1297dbe50a5705a1a7b087e24f8f8c0611b79" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; と同等です。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; が端末に接続され、エコーが有効になっている場合は、端末スタイルの対話を使用します。それ以外の場合（たとえば、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; がパイプの場合）、ファイル形式の相互作用を使用します。</target>
        </trans-unit>
        <trans-unit id="925f47def99f594f17042330b2cb3a4074f9cfdc" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; と同等です。 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; が端末に接続されていて、エコーが有効になっている場合は、端末スタイルの対話を使用します。それ以外の場合（たとえば、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; がパイプの場合）、ファイルスタイルの相互作用を使用します。</target>
        </trans-unit>
        <trans-unit id="74b22623dc818147f2c6f57929328997d17b3b24" translate="yes" xml:space="preserve">
          <source>This function is identical to the normal unsafeInterleaveST, but is inlined and hence faster.</source>
          <target state="translated">この関数は通常の unsafeInterleaveST と同じですが、インライン化されているので高速です。</target>
        </trans-unit>
        <trans-unit id="3df65f8bec8d8ab7b43b6ab0ab2e82da15c0ef13" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">この関数は、割り当て戦略との融合を可能にするために、コードサイズが重いにもかかわらずインライン化されています。たとえば、デフォルトの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 実行関数 &lt;code&gt;toLazyByteString&lt;/code&gt; は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="235b6b044bd31212b9719a4b1325277577dea428" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">この関数は、割り当て戦略との融合を可能にするために、コードサイズが重いにもかかわらずインライン化されています。たとえば、デフォルトの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 実行関数 &lt;code&gt;toLazyByteString&lt;/code&gt; は次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5e260df7d73e67cac6b68c2a311d7baa6dc73777" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (also known as case insensitive) string comparisons.</source>
          <target state="translated">この関数は、主に大文字小文字を区別しない(大文字小文字を区別しない)文字列比較を行うのに便利です。</target>
        </trans-unit>
        <trans-unit id="982fe52bf42753f9c092c03c7dda6cf3ea3642ac" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">この関数は、主に大文字小文字を区別しない文字列比較を行うのに便利です。</target>
        </trans-unit>
        <trans-unit id="88a949c7c5b9a60ae7e9844db387f3275f199bc9" translate="yes" xml:space="preserve">
          <source>This function is meant to be invoked from any application level cleanup handler. It terminates the process, and closes any &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle&lt;/code&gt;s.</source>
          <target state="translated">この関数は、アプリケーションレベルのクリーンアップハンドラーから呼び出されることを想定しています。プロセスを終了し、 &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle&lt;/code&gt; すべて閉じます。</target>
        </trans-unit>
        <trans-unit id="00b26bf5c664293ce811e9f9293ca81ecc310513" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">この関数は &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; よりも効率的です。多くの場合、バッファの割り当てを行う必要がないため、toLazyByteString。さらに、短い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; のいくつかの実行の結果は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; バッファーに連結されるため、不要なバッファーのフラッシュが回避されます。</target>
        </trans-unit>
        <trans-unit id="af91de3226aaac03a1110fced423ab247dd1f835" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">この関数は &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; よりも効率的です。多くの場合、バッファ割り当てを行う必要がないため、toLazyByteString。さらに、短い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の複数の実行の結果は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; のバッファーに連結されるため、不要なバッファーのフラッシュを回避できます。</target>
        </trans-unit>
        <trans-unit id="81cef0e8688cdc48d9b9ff9c39a55f003fae9595" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスの操作を使用して、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が指すオブジェクトとの間でデータをマーシャリングするために使用されます。</target>
        </trans-unit>
        <trans-unit id="dcc8eee9cef2591d3719a4001c66eea308bb00b1" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">この関数は通常、 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; クラスの操作を使用して、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; が指すオブジェクトとの間でデータをマーシャリングするために使用されます。</target>
        </trans-unit>
        <trans-unit id="f40048a5f3caebc5fe300ab653bf30f1e2b70070" translate="yes" xml:space="preserve">
          <source>This function is only defined if &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; and &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; (Note: the documentation claims that only &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; is supported, however the actual implementation supports up to base 256).</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; および &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; 場合にのみ定義されます（注：ドキュメントでは、 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; のみがサポートされていると主張していますが、実際の実装では最大256をサポートしています）。</target>
        </trans-unit>
        <trans-unit id="1f0db6399242ab25312fe9ac2fbde674ee7aa2e5" translate="yes" xml:space="preserve">
          <source>This function is runtime-representation polymorphic, but the &lt;code&gt;RuntimeRep&lt;/code&gt; type argument is marked as &lt;code&gt;Inferred&lt;/code&gt;, meaning that it is not available for visible type application. This means the typechecker will accept &lt;code&gt;coerce @Int @Age 42&lt;/code&gt;.</source>
          <target state="translated">この関数は、ランタイム・表現の多型であるが、 &lt;code&gt;RuntimeRep&lt;/code&gt; の型引数は、次のようにマークされている &lt;code&gt;Inferred&lt;/code&gt; ことは目に見えるタイプのアプリケーションのために使用できないことを意味し、。これは、 &lt;code&gt;coerce @Int @Age 42&lt;/code&gt; を受け入れることを意味します。</target>
        </trans-unit>
        <trans-unit id="213dcd0849e6345864ca5752cd6d03ec515775cd" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">この関数は、必要なメモリのサイズがバイト数として明示的に指定されることを除いて、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="7180b41a302c7c04e8da7fd8f83d119c939f7280" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">この関数は、必要なメモリのサイズがバイト数として明示的に指定されることを除いて、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="5f63596c51e12b4f409448cb34c60a65c7a9ca0d" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="4083768355a45fdb0a42de16aa51a3af8c228c66" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="6b1d46b44ea9232c55a861a5d882fa3688f6cd96" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="7672c2399ed76b968a47b4291c113d59075f7990" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; に似ていますが、メモリ領域を解放するファイナライザがアタッチされたメモリ領域を生成します。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と同様に、メモリブロックが &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; によって割り当てられたことは保証されません。</target>
        </trans-unit>
        <trans-unit id="7ff12ee367a6fdd15f0645b4e1ebf055ffe60727" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">この関数は、必要なメモリのサイズがバイト数として明示的に指定されることを除いて、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="b6c52e12f35a2275476d84741c02f0045857af05" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt; に似ていますに、ファイナライザのない内部的に最適化されたForeignPtr表現が使用される点が異なります。ファイナライザを追加しようとすると、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="e8bb381fc113886f37459f57bc0e517e18d58f74" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; に似ていますが、ファイナライザを使用せずに内部的に最適化されたForeignPtr表現が使用される点が異なります。ファイナライザを追加しようとすると、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="3d6f8324541e76c432236c537e2a380f498fdc16" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the size and alignment of the memory required is given explicitly as numbers of bytes.</source>
          <target state="translated">この関数は &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; に似ていますが、必要なメモリのサイズと配置がバイト数として明示的に指定される点が異なります。</target>
        </trans-unit>
        <trans-unit id="c6266d7b17854517fbd86bf34d982e2073442b47" translate="yes" xml:space="preserve">
          <source>This function is strict in &lt;code&gt;needle&lt;/code&gt;, and lazy (as far as possible) in the chunks of &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;needle&lt;/code&gt; では厳密であり、 &lt;code&gt;haystack&lt;/code&gt; のチャンクでは（可能な限り）レイジーです。</target>
        </trans-unit>
        <trans-unit id="f216683cc82aa64de779d88daeaba4d1152d651d" translate="yes" xml:space="preserve">
          <source>This function is strict in its first argument, and lazy in its second.</source>
          <target state="translated">この関数は第一引数が厳密で、第二引数が怠惰です。</target>
        </trans-unit>
        <trans-unit id="b0b32655d3a8d92812d81f5285c18f655d5a3859" translate="yes" xml:space="preserve">
          <source>This function is strict in the computed result and lazy in the writing of the bytes. For example, given</source>
          <target state="translated">この関数は,計算結果には厳密に,バイトの書き込みには怠惰になります.例えば、与えられた</target>
        </trans-unit>
        <trans-unit id="d42e669b72fdf00ca69c1146fbc6cd4f7fd2b0e3" translate="yes" xml:space="preserve">
          <source>This function is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この関数は、純粋なコードでの使用に適しています。IOコンテキストでは &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; を使用します代わりにを。</target>
        </trans-unit>
        <trans-unit id="f3b80efc4be65cc4f7d016d8e9df62478b06cdd3" translate="yes" xml:space="preserve">
          <source>This function is unsafe because the program behavior is undefined if the type of the returned &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; does not match the expected one.</source>
          <target state="translated">返された &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; のタイプが期待されるタイプと一致しない場合、プログラムの動作は未定義であるため、この関数は安全ではありません。</target>
        </trans-unit>
        <trans-unit id="d0ef53dc671c66eb4f726f95bfbceabd2738d518" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">この関数は、 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; リテラルを構築するためにGHCによって使用されます。</target>
        </trans-unit>
        <trans-unit id="5abca3b3eff9479232b2f8880d6591a9960af27b" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">この関数は、GHCが &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; リテラルを構築するために使用します。</target>
        </trans-unit>
        <trans-unit id="a76dc2ebb647a8a46428d99317295ae5c89ee276" translate="yes" xml:space="preserve">
          <source>This function is useful for informing the parent when a child terminates, for example.</source>
          <target state="translated">この機能は、例えば子の終了時に親に通知するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d5042b5be97cdd0d8f13f55579035132f9596b0e" translate="yes" xml:space="preserve">
          <source>This function is useful for using &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; in a safe way in a multithreaded program. If you only have one &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, then using &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; to access and modify it will prevent race conditions.</source>
          <target state="translated">この関数は、マルチスレッドプログラムで &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; を安全に使用するのに役立ちます。 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; が1つしかない場合、 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; を使用してアクセスおよび変更すると、競合状態が回避されます。</target>
        </trans-unit>
        <trans-unit id="78f182126e093e425fc7c58b56f7052d3cc81fd2" translate="yes" xml:space="preserve">
          <source>This function isn't suitable when we want to set the cTRL_C_EVENT handler. If you want to set the cTRL_C_EVENT handler, use &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">この関数は、cTRL_C_EVENTハンドラーを設定する場合には適していません。cTRL_C_EVENTハンドラを設定する場合は、c_SetConsoleCtrlHandlerを使用し &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; 代わりにを。</target>
        </trans-unit>
        <trans-unit id="9871f6366cef22e329fca1bc704e039bd6520451" translate="yes" xml:space="preserve">
          <source>This function maps one exception into another as proposed in the paper &quot;A semantics for imprecise exceptions&quot;.</source>
          <target state="translated">この関数は、論文 &quot;A semantics for imprecise exceptions &quot;で提案されているように、ある例外を別の例外にマッピングします。</target>
        </trans-unit>
        <trans-unit id="1a5ff8da6eff5ff073f1ef4ac1e4757b5f92be33" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">この関数は、の値として使用することができる &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; インスタンス。</target>
        </trans-unit>
        <trans-unit id="626e558e3754f72bcf94652b857bc1fadf635831" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, provided that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is defined. (Using &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instance defined only by &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; will result in infinite recursion.)</source>
          <target state="translated">この関数は、の値として使用することができる &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ことを条件とする、インスタンス &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 定義されています。 （ &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; を、 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; によってのみ定義された &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; インスタンスで使用すると、無限再帰が発生します。）</target>
        </trans-unit>
        <trans-unit id="5b30959a5096a71e3cec93cd57d2e51e397b263e" translate="yes" xml:space="preserve">
          <source>This function may be used to debug Haskeline's input.</source>
          <target state="translated">この関数は、Haskelineの入力をデバッグするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="e58338f4629941ddeb6081adb1d67e46144c1a35" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written and the same value being computed. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, monadic sequencing of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">この関数は参照透過的でなければなりません。つまり、同じサイズの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; で複数回呼び出すと、同じバイトシーケンスが書き込まれ、同じ値が計算される必要があります。変更可能な状態が必要な場合は、この関数を呼び出すたびに変更可能な状態を割り当てる必要があります。 Moroever、この関数は、一度完了したら継続を呼び出す必要があります。そうでない場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; のモナディックシーケンスは機能しません。最後に、この関数は、書き込んだと主張するすべてのバイトに書き込む必要があります。それ以外の場合、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; は参照透過性が保証されず、機密データが漏洩する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d45d9a503757dbc2e079e55bb2d136d8ac259338" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">この関数は参照透過的でなければなりません。つまり、同じサイズの &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; で複数回呼び出すと、同じバイトシーケンスが書き込まれます。変更可能な状態が必要な場合は、この関数を呼び出すたびに変更可能な状態を割り当てる必要があります。Moroever、この関数は、完了したら継続を呼び出す必要があります。そうでない場合、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; の連結は機能しません。最後に、この関数は、書き込んだと主張するすべてのバイトに書き込む必要があります。それ以外の場合、結果の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; は参照透過性が保証されず、機密データが漏洩する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f8b24ee1d1129f69b81aa438d99f4c55ce18780e" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">この関数は、一度にチャンクを読み取り、読み取りごとにチャンクサイズを増やします。次に、最終的な文字列が適切なサイズに再割り当てされます。利用可能なメモリの半分を超えるファイルの場合、これによりメモリが使い果たされる可能性があります。 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; の使用を検討してくださいこの場合は、。</target>
        </trans-unit>
        <trans-unit id="bb38f0c0e138df73f1bb18283100e26479279ef9" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">この関数は、一度にチャンクを読み取り、読み取りごとにチャンクサイズを増やします。次に、最終的な文字列が適切なサイズに再割り当てされます。利用可能なメモリの半分を超えるファイルの場合、これによりメモリが使い果たされる可能性があります。この場合は、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="b96182eaae363b6548da5c4708f3fee19d0eba44" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">この関数は、引数に次の &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; のいずれかがある場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="08b901589b02acf03fdb2c4330ddaefe06ce9626" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">この関数は、引数に次の &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; のいずれかがある場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; を返し、そうでない場合は &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="829c7b2049bce335518e8e6987f223cd44774ac1" translate="yes" xml:space="preserve">
          <source>This function should not be called on a closed or cancelled &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数は、クローズまたはキャンセルされた &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; で呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="4becc58728105fc63f4543e724ceed3d0b38faa9" translate="yes" xml:space="preserve">
          <source>This function takes an adjacency list representing a graph with vertices of type &lt;code&gt;key&lt;/code&gt; labeled by values of type &lt;code&gt;node&lt;/code&gt; and produces a &lt;code&gt;Graph&lt;/code&gt;-based representation of that list. The &lt;code&gt;Graph&lt;/code&gt; result represents the &lt;em&gt;shape&lt;/em&gt; of the graph, and the functions describe a) how to retrieve the label and adjacent vertices of a given vertex, and b) how to retrive a vertex given a key.</source>
          <target state="translated">この関数は、 &lt;code&gt;node&lt;/code&gt; タイプの値でラベル付けされた &lt;code&gt;key&lt;/code&gt; タイプの頂点を持つグラフを表す隣接リストを取り、そのリストの &lt;code&gt;Graph&lt;/code&gt; ベースの表現を生成します。 &lt;code&gt;Graph&lt;/code&gt; 結果が表す&lt;em&gt;形状を&lt;/em&gt;&lt;em&gt;&lt;/em&gt;所与の頂点のラベルと隣接する頂点を取得するために、およびb）どのキー与えられた頂点をretriveする方法）グラフの、および機能が記載されています。</target>
        </trans-unit>
        <trans-unit id="6070795d0875a01577e4829d564fa22e24b1b00c" translate="yes" xml:space="preserve">
          <source>This function takes an extra &lt;code&gt;String&lt;/code&gt; argument to be used in creating error messages.</source>
          <target state="translated">この関数は、エラーメッセージの作成に使用する追加の &lt;code&gt;String&lt;/code&gt; 引数を取ります。</target>
        </trans-unit>
        <trans-unit id="7f0c1ada42e597613fc7e7e6786e2387ef148b77" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">プロセス &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 以外の場合、この関数は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。代わりに &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; を取得したい場合は、readProcessWithExitCodeを使用し &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1318cc2b39b86c3da816e772a9967719bb468613" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">プロセス &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 以外の場合、この関数は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をスローします。代わりに &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; を取得する場合は、readProcessWithExitCodeを使用し &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b8c3042780b1688ac6a3ee1fab2256e1f014dd" translate="yes" xml:space="preserve">
          <source>This function will be invoked at two points in the constraint solving process: after simplification of given constraints, and after unflattening of wanted constraints. The two phases can be distinguished because the deriveds and wanteds will be empty in the first case. In each case, the plugin should either</source>
          <target state="translated">この関数は、与えられた制約の単純化の後と、欲しい制約のフラット化を解除した後の2つの時点で呼び出されます。2つのフェーズは、最初のケースでは導出された制約と欲しい制約が空になるため、区別できます。それぞれのケースで、プラグインは以下のいずれかを実行します。</target>
        </trans-unit>
        <trans-unit id="6467a527fa88959e8823896b96be26bf195128c1" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; which has some implementation pecularities to take into account:</source>
          <target state="translated">この関数は、考慮すべきいくつかの実装特性を持つ &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; をラップします。</target>
        </trans-unit>
        <trans-unit id="80485bdbfd7c212c63fd29a0333499c58e82d6b5" translate="yes" xml:space="preserve">
          <source>This function, like &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt;, has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この機能は、同じよう &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt; 、冷凍には影響ありません &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="842a68272f46af66e4862fdc0bc066609f64b0e0" translate="yes" xml:space="preserve">
          <source>This generalizes the list-based &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">これにより、リストベースの &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 機能が一般化されます。</target>
        </trans-unit>
        <trans-unit id="b2ff47cfc567ef028dcfe716cd26e468cb33a9de" translate="yes" xml:space="preserve">
          <source>This generates one file per Haskell module, and 4 index files, &lt;code&gt;hpc_index.html&lt;/code&gt;, &lt;code&gt;hpc_index_alt.html&lt;/code&gt;, &lt;code&gt;hpc_index_exp.html&lt;/code&gt;, &lt;code&gt;hpc_index_fun.html&lt;/code&gt;.</source>
          <target state="translated">これにより、Haskellモジュールごとに1つのファイルと、4つのインデックスファイル、 &lt;code&gt;hpc_index.html&lt;/code&gt; 、 &lt;code&gt;hpc_index_alt.html&lt;/code&gt; 、 &lt;code&gt;hpc_index_exp.html&lt;/code&gt; 、 &lt;code&gt;hpc_index_fun.html&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="c5344bdf0cc9457503d3d92a9eb3e0f2cb07653d" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;unpinned&lt;/a&gt;&lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">これは、ヒープオブジェクト参照を &lt;code&gt;safe&lt;/code&gt; 外部関数呼び出しに渡すことが安全ではないことを意味するため、ライブラリの作成者を大幅に制約します。たとえば、&lt;a href=&quot;#pinned-byte-arrays&quot;&gt;固定されていない&lt;/a&gt; &lt;code&gt;ByteArray#&lt;/code&gt; をネイティブコードに直接渡して、不要なコピーを作成しないようにすることが望ましい場合がよくあります。ただし、これは、呼び出しの途中でガベージコレクターによって配列が移動されないことが保証されている場合にのみ安全に実行できます。</target>
        </trans-unit>
        <trans-unit id="7c64c30705c50c32c9be3389ffedce10aebc7f56" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an unpinned &lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">これは、ヒープオブジェクト参照を &lt;code&gt;safe&lt;/code&gt; 外部関数呼び出しに渡すことが安全ではないことを意味するため、ライブラリの作成者を大幅に制約します。たとえば、固定されていない &lt;code&gt;ByteArray#&lt;/code&gt; をネイティブコードに直接渡して、それ以外は不要なコピーが作成されないようにすることが望ましい場合がよくあります。ただし、これは、呼び出しの途中でガベージコレクターによって配列が移動されないことが保証されている場合にのみ安全に実行できます。</target>
        </trans-unit>
        <trans-unit id="41834e436d1719d30cabcc4b9b9f363c58c43156" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、呼び出したのと同じ効果がある &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; をして &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; とともに、 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="6ae7b2e29f0249e038dc6f2d5f144f9852f9724a" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、呼び出したのと同じ効果がある &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; をして &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; とともに、 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="74c85cbe0088849b70271ff6b2b4f90df21c84ea" translate="yes" xml:space="preserve">
          <source>This has two effects. The first is to compile the code in such a way that it can be linked against shared library versions of Haskell packages (such as base). The second is when linking, to link against the shared versions of the packages&amp;rsquo; libraries rather than the static versions. Obviously this requires that the packages were built with shared libraries. On supported platforms GHC comes with shared libraries for all the core packages, but if you install extra packages (e.g. with Cabal) then they would also have to be built with shared libraries (&lt;code&gt;--enable-shared&lt;/code&gt; for Cabal).</source>
          <target state="translated">これには2つの効果があります。1つ目は、Haskellパッケージの共有ライブラリバージョン（ベースなど）に対してリンクできるようにコードをコンパイルすることです。2つ目は、リンク時、静的バージョンではなく、パッケージのライブラリの共有バージョンに対してリンクする場合です。明らかに、これにはパッケージが共有ライブラリでビルドされていることが必要です。サポートされているプラ​​ットフォームでは、GHCにはすべてのコアパッケージの共有ライブラリが付属していますが、追加のパッケージをインストールする場合（たとえば、Cabalを使用）、共有ライブラリを使用してビルドする必要があります（Cabalの場合は &lt;code&gt;--enable-shared&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="548fc7aaea96607acee200e9ba71f5d0c6b166be" translate="yes" xml:space="preserve">
          <source>This idea is very old; see Seciton 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable type classes&lt;/a&gt;.</source>
          <target state="translated">このアイデアは非常に古いものです。&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable型クラスの&lt;/a&gt; Seciton 7を参照してください。</target>
        </trans-unit>
        <trans-unit id="9630590333acefa1eb165b1fdb491f1028f3c007" translate="yes" xml:space="preserve">
          <source>This implemenation uses &lt;code&gt;memset(3)&lt;/code&gt;</source>
          <target state="translated">この実装は &lt;code&gt;memset(3)&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="884b09618f3fa095f6ec125ed96fbbf8ccd437a1" translate="yes" xml:space="preserve">
          <source>This implementation is intentionally naive. Instances are expected to provide an optimized implementation for their size.</source>
          <target state="translated">この実装は意図的にナイーブです。インスタンスは、そのサイズに最適化された実装を提供することが期待されています。</target>
        </trans-unit>
        <trans-unit id="621e9b697c58fe612c7eaaea244ee764c09bb5f3" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">これは、たとえ1バイトしか含まれていない場合でも、出力バッファーをフラッシュすることを意味します。したがって、大きな（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に対してのみ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; を使用する必要があります。そうでない場合、生成されたチャンクは断片化されすぎて、後で効率的に処理できません。</target>
        </trans-unit>
        <trans-unit id="ec6a5f5a381024ce57d5b678b6cb847a23f169c1" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">これは、たとえ1バイトしか含まれていない場合でも、出力バッファーをフラッシュすることを意味します。したがって、大きな（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に対してのみ &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; を使用する必要があります。そうでない場合、生成されたチャンクは断片化されすぎて、後で効率的に処理できません。</target>
        </trans-unit>
        <trans-unit id="0f03bf2766810922713f86acfde0e9c886b0e80e" translate="yes" xml:space="preserve">
          <source>This improves efficiency slightly but significantly for most programs, and is bad for only a few. To suppress this bogus &amp;ldquo;optimisation&amp;rdquo; use &lt;code&gt;-fpedantic-bottoms&lt;/code&gt;.</source>
          <target state="translated">これにより、効率はわずかに向上しますが、ほとんどのプログラムで大幅に向上し、ごく一部のプログラムでは問題があります。この偽の「最適化」を抑制するには、 &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0c3ae98027814be110bac171a0407c5649c80296" translate="yes" xml:space="preserve">
          <source>This includes the main thread, so using &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; is a good way to see how much stack space the program is using.</source>
          <target state="translated">これにはメインスレッドが含まれるため、&lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;を使用すると、プログラムが使用しているスタックスペースの量を確認できます。</target>
        </trans-unit>
        <trans-unit id="d6a0e9f59821fc6a5f78b81c882c88a9ce445a90" translate="yes" xml:space="preserve">
          <source>This indicates that there may be more data to write. It gives you the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. You should call that action with an appropriate buffer. The int indicates the &lt;em&gt;minimum&lt;/em&gt; buffer size required by the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. That is, if you call the next action you &lt;em&gt;must&lt;/em&gt; supply it with a buffer length of at least this size.</source>
          <target state="translated">これは、書き込むデータがまだある可能性があることを示しています。次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; アクションを提供します。そのアクションは適切なバッファーで呼び出す必要があります。 intは、次の &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; アクションで必要な&lt;em&gt;最小&lt;/em&gt;バッファーサイズを示します。つまり、次のアクションを呼び出す場合は、少なくともこのサイズのバッファー長を指定する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12dc46ef50110e91a94e6d325a61778b34facf10" translate="yes" xml:space="preserve">
          <source>This inlining occurs regardless of the argument to the call or the size of &lt;code&gt;f&lt;/code&gt;'s definition; it is unconditional. The main caveat is that &lt;code&gt;f&lt;/code&gt;'s definition must be visible to the compiler; it is therefore recommended to mark the function with an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition so that GHC guarantees to record its unfolding regardless of size.</source>
          <target state="translated">このインライン化は、呼び出しの引数や &lt;code&gt;f&lt;/code&gt; の定義のサイズに関係なく行われます。無条件です。主な注意点は、 &lt;code&gt;f&lt;/code&gt; の定義がコンパイラーから見える必要があることです。したがって、GHCがサイズに関係なく展開を記録することを保証できるように、その定義で関数を &lt;code&gt;INLINABLE&lt;/code&gt; プラグマでマークすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1ef01da60f8e50833762de51e88f6f38500b8529" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">これにより、コアからコアへのパスとしてプラグインが挿入されます。 &lt;code&gt;-fplugin=(module)&lt;/code&gt; とは異なり、プラグインモジュールは、&lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePluginを&lt;/a&gt;呼び出すモジュールと同じパッケージに置くことはできません。このようにして、実装は必要なときにプラグインがビルドされることを期待できます。</target>
        </trans-unit>
        <trans-unit id="5ff50fa3f4d1717b720187c6141e26cd711cc26f" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">これにより、プラグインがコアツーコアパスとして挿入されます。 &lt;code&gt;-fplugin=(module)&lt;/code&gt; とは異なり、プラグインモジュールは、&lt;a href=&quot;../libraries/template-haskell-2.16.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePluginを&lt;/a&gt;呼び出すモジュールと同じパッケージに常駐することはできません。このようにして、実装はプラグインが必要になるまでにビルドされることを期待できます。</target>
        </trans-unit>
        <trans-unit id="c72aeeca496ff034d5ed0f5d68c44678b8f30bdc" translate="yes" xml:space="preserve">
          <source>This instance has similar considerations to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instance: it preserves abstraction at the cost of inefficiency.</source>
          <target state="translated">このインスタンスには、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; インスタンスと同様の考慮事項があります。非効率性を犠牲にして抽象化を維持します。</target>
        </trans-unit>
        <trans-unit id="f4e5c9cc750ce5f88a69b78165e5f0f4d42bcbfe" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">このインスタンスは、利便性と &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; との一貫性のためです。これは、WHNFが関数のNFと同等であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="0eaa2be703bfed5db1962bf2e87d773ccbf9e44d" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">このインスタンスは、便宜上、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; との一貫性を保つためのものです。これは、WHNFが関数のNFと同等であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="292d6bb24eb4520bb3e5e03c32ef914fb200aaac" translate="yes" xml:space="preserve">
          <source>This instance is only usable if the constructor &lt;code&gt;MkNT&lt;/code&gt; is in scope.</source>
          <target state="translated">このインスタンスは、コンストラクター &lt;code&gt;MkNT&lt;/code&gt; がスコープ内にある場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f66688755fda8b6fa988624af4229d29f0758a6a" translate="yes" xml:space="preserve">
          <source>This instance preserves data abstraction at the cost of inefficiency. We omit reflection services for the sake of data abstraction.</source>
          <target state="translated">このインスタンスは、非効率性を犠牲にしてもデータの抽象化を維持します。データの抽象化のためにリフレクションサービスを省略しています。</target>
        </trans-unit>
        <trans-unit id="6b584a1a609b62c189a035f58e1f74d23dc48f4f" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. If you feel a mistake has been made, please feel free to submit improvements.</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt; 更新された動作をコピーして作成されました。 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 。間違いがあると思われる場合は、遠慮なく改善を送信してください。</target>
        </trans-unit>
        <trans-unit id="cebbf89c2d62c75612dfe9b00700d435728a9709" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt; 更新された動作をコピーして作成されました。 &lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9547a346372e77b8a94a20c518fb263a9e88db" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; フィールドが削除された場合、 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtypeの派生インスタンスと同等になります。</target>
        </trans-unit>
        <trans-unit id="9d8b5c5a18b4eafeeabf6e2ae459cf6f977e8e46" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; フィールドが削除された場合、 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtypeの派生インスタンスと同等になります。</target>
        </trans-unit>
        <trans-unit id="8f442041027e514839d6c7dbd7ef45f00a4ededa" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、 &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; フィールドが削除された場合、 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtypeの派生インスタンスと同等になります。</target>
        </trans-unit>
        <trans-unit id="d7a50a4b488dfd0ceef47a8a415f99ee744d5ed8" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-ord#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、の導出インスタンスに相当します &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 場合のnewtype &lt;code&gt;&lt;a href=&quot;data-ord#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; のフィールドが削除されました</target>
        </trans-unit>
        <trans-unit id="fe29b722781fc1de8c3cf834abcc1f449fc0a931" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">このインスタンスは、の導出インスタンスに相当します &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 場合のnewtype &lt;code&gt;&lt;a href=&quot;ghc-exts#v:getDown&quot;&gt;getDown&lt;/a&gt;&lt;/code&gt; のフィールドが削除されました</target>
        </trans-unit>
        <trans-unit id="04b4bf75fa251a6d79ae490ffe498133e416deeb" translate="yes" xml:space="preserve">
          <source>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using &lt;code&gt;-optl -rdynamic&lt;/code&gt; on Linux, and &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; on Windows.</source>
          <target state="translated">これは、使用中のシンボルだけでなく、すべてのシンボルを動的シンボルテーブルに追加するようにリンカーに指示します。現在、LinuxおよびWindows / MinGW32のみ。これは、Linuxでは &lt;code&gt;-optl -rdynamic&lt;/code&gt; 、Windowsでは &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; を使用するのと同じです。</target>
        </trans-unit>
        <trans-unit id="d93a8b76f0ddcde6fb04d1a2d2bc4ce8187928c7" translate="yes" xml:space="preserve">
          <source>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt;&lt;code&gt;-fPIE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、位置に依存しない実行可能ファイルを生成するようにリンカーに指示します。このフラグは、実行可能ファイルを生成している間のみ有効であり、リンクされるすべてのオブジェクトコードは&lt;a href=&quot;#ghc-flag--fPIE&quot;&gt; &lt;code&gt;-fPIE&lt;/code&gt; で&lt;/a&gt;生成されている必要があります。</target>
        </trans-unit>
        <trans-unit id="1f3eb5f30b0cea2845a0034105f6b2f42741738e" translate="yes" xml:space="preserve">
          <source>This interface was introduced for parsers by Niklas R&amp;ouml;jemo, because it admits more sharing than the monadic interface. The names here are mostly based on parsing work by Doaitse Swierstra.</source>
          <target state="translated">このインターフェイスは、モナディックインターフェイスよりも多くの共有を許可するため、NiklasR&amp;ouml;jemoによってパーサーのために導入されました。ここでの名前は、ほとんどがDoaitse Swierstraによる解析作業に基づいています。</target>
        </trans-unit>
        <trans-unit id="2193f86cf24477bc6ea98a7a666bf4f097144114" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; with its arguments flipped.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; であり、引数は反転されています。</target>
        </trans-unit>
        <trans-unit id="853ad3fece6dfad54dfa810a5f259b18c1ca92df" translate="yes" xml:space="preserve">
          <source>This is a &quot;secure&quot; variant of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;mpz_powm_sec()&lt;/code&gt; function which is designed to be resilient to side channel attacks and is therefore intended for cryptographic applications.</source>
          <target state="translated">これは、「安全な」変異体である &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;mpz_powm_sec()&lt;/code&gt; サイドチャネル攻撃に弾力的であるように設計され、したがって、暗号アプリケーションのために意図されている機能。</target>
        </trans-unit>
        <trans-unit id="206d2c688e36d3f91786f4ad10d32b3bbd76f245" translate="yes" xml:space="preserve">
          <source>This is a change in behaviour relative to 6.2 and earlier.</source>
          <target state="translated">6.2以前との相対的な行動の変化です。</target>
        </trans-unit>
        <trans-unit id="00558cc92150447e28cfde519a9ac027ba98b199" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt;; ie. it takes the value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, puts it back, and also returns it.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; の組み合わせです。すなわち。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; から値を受け取り、元に戻し、それを返します。</target>
        </trans-unit>
        <trans-unit id="d6388ad09499896ee48a8e46a65f919073bd630f" translate="yes" xml:space="preserve">
          <source>This is a consequence of the requirement that all applications of a type family must be fully saturated with respect to their arity.</source>
          <target state="translated">これは、型ファミリーのすべてのアプリケーションが、そのアリティに関して完全に飽和していなければならないという要件の結果です。</target>
        </trans-unit>
        <trans-unit id="5cf7cdffdf7f677c3d65b226f0158c81eb00adc8" translate="yes" xml:space="preserve">
          <source>This is a good alternative to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; when you are trying to directly link in an object file.</source>
          <target state="translated">これは、オブジェクトファイルに直接リンクする場合に、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; に代わる優れた方法です。</target>
        </trans-unit>
        <trans-unit id="085ff8e3a0f8a72b0a54eeb21ca799400340b070" translate="yes" xml:space="preserve">
          <source>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the &lt;code&gt;-hide-all-packages&lt;/code&gt; flag to GHC, for exactly this reason.</source>
          <target state="translated">これは、プログラムをグローバルに公開されたパッケージの違いから隔離する良い方法であり、パッケージの依存関係を明示することは良いことです。Cabalは常にこの理由で、常に &lt;code&gt;-hide-all-packages&lt;/code&gt; フラグをGHCに渡します。</target>
        </trans-unit>
        <trans-unit id="8027c0b11e662d6e52978de63e39356d25b88d32" translate="yes" xml:space="preserve">
          <source>This is a guide to using the Glasgow Haskell Compiler (GHC): an interactive and batch compilation system for the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; language.</source>
          <target state="translated">これは、グラスゴーのHaskellコンパイラ（GHC）を使用するためのガイドです&lt;a href=&quot;http://www.haskell.org/&quot;&gt;。Haskell2010&lt;/a&gt;言語用のインタラクティブなバッチコンパイルシステムです。</target>
        </trans-unit>
        <trans-unit id="c43f1cd29cf3fbfdaab28a7b865c723e0177f5eb" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by UTC. It has a precision of 10^-12 s.</source>
          <target state="translated">これはUTCで測定した時間の長さです。10^-12秒の精度を持っています。</target>
        </trans-unit>
        <trans-unit id="b188ac0ba94d5b91f8dbb5c660aa1046ae2821a3" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.</source>
          <target state="translated">これは時計で測った時間の長さです。変換関数では秒として扱われます。精度は10^-12秒です。</target>
        </trans-unit>
        <trans-unit id="b931fc8ba0422aa66c49ca99c7502e98ce5770ff" translate="yes" xml:space="preserve">
          <source>This is a library of parser combinators, originally written by Koen Claessen. It parses all alternatives in parallel, so it never keeps hold of the beginning of the input string, a common source of space leaks with other parsers. The &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; choice combinator is genuinely commutative; it makes no difference which branch is &quot;shorter&quot;.</source>
          <target state="translated">これは、もともとKoen Claessenによって書かれたパーサコンビネータのライブラリです。すべての選択肢を並行して解析するため、他のパーサーとのスペースリークの一般的な原因である入力文字列の先頭を保持することはありません。 &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; 選択コンビネータは純粋に可換です。どのブランチが「短い」かは関係ありません。</target>
        </trans-unit>
        <trans-unit id="e42801ec302676ba22f8d444806417ba897f7527" translate="yes" xml:space="preserve">
          <source>This is a lot of information! However, most of it is actually merely meta-information that makes names of datatypes and constructors and more available on the type level.</source>
          <target state="translated">これはたくさんの情報です! しかし、実際にはそのほとんどが、データ型やコンストラクタなどの名前を型レベルで利用可能にするメタ情報にすぎません。</target>
        </trans-unit>
        <trans-unit id="80f7c821c90cd714f631d4e0a4b9d09aa6b02e5d" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Haskell style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">これはHaskellスタイル言語のための最小のトークン定義です。コメントのスタイル、有効な識別子、大文字小文字の区別を定義します。予約語や演算子は定義していません。</target>
        </trans-unit>
        <trans-unit id="7695f0f91603fc6b7578c654d8c907922e492b31" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Java style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">これはJavaスタイル言語のための最小限のトークン定義です。コメントのスタイル、有効な識別子、大文字小文字の区別を定義します。予約語や演算子は定義しない。</target>
        </trans-unit>
        <trans-unit id="fa0a32456a663556dc4c0ba610d08c21985dc005" translate="yes" xml:space="preserve">
          <source>This is a module for efficient stack traces. This stack trace implementation is considered low overhead. Basic usage looks like this:</source>
          <target state="translated">効率的なスタックトレースのためのモジュールです。このスタックトレースの実装は低オーバーヘッドと考えられています。基本的な使い方は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d8d7e87f49a4a49c2284947686e2481c865a646c" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; の非ブロッキングバージョンです。プロセスがまだ実行中の場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; も返されません。プロセスが終了した場合、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; が返されます &lt;code&gt;e&lt;/code&gt; はプロセスの終了コードです。</target>
        </trans-unit>
        <trans-unit id="1f500d4f7fd67c8ad0b3e4a53af642dd0d2ae2b1" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; の非ブロッキングバージョンです。プロセスがまだ実行中の場合、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; も返されません。プロセスが終了した場合は、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; が返されます。ここで、 &lt;code&gt;e&lt;/code&gt; はプロセスの終了コードです。</target>
        </trans-unit>
        <trans-unit id="5bdec4fb766d4e0ba04b6cea6e7ffd45bb020610" translate="yes" xml:space="preserve">
          <source>This is a rather fragile arrangement, as generally a programmer expects &lt;code&gt;(*) a b&lt;/code&gt; to be equivalent to &lt;code&gt;a * b&lt;/code&gt;. With &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt;&lt;code&gt;-Wstar-binder&lt;/code&gt;&lt;/a&gt; we warn when this special treatment of &lt;code&gt;(*)&lt;/code&gt; takes place.</source>
          <target state="translated">これはかなり脆弱な配置であり、一般にプログラマーは &lt;code&gt;(*) a b&lt;/code&gt; が &lt;code&gt;a * b&lt;/code&gt; と同等であることを期待します。&lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt; &lt;code&gt;-Wstar-binder&lt;/code&gt; &lt;/a&gt;のこの特別な処理するとき、私たちは警告する &lt;code&gt;(*)&lt;/code&gt; が行われます。</target>
        </trans-unit>
        <trans-unit id="bfbddac5a335e3a88e1f9114ff2652333aff0d5e" translate="yes" xml:space="preserve">
          <source>This is a slightly involved heuristic, but captures the situation of an imported module &lt;code&gt;N&lt;/code&gt; changing the behaviour of existing code. For example, if the second condition isn&amp;rsquo;t violated, then the module author &lt;code&gt;M&lt;/code&gt; must depend either on a type-class or type defined in &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">これは少し複雑なヒューリスティックですが、インポートされたモジュール &lt;code&gt;N&lt;/code&gt; が既存のコードの動作を変更する状況をキャプチャします。たとえば、2番目の条件に違反していない場合、モジュール作成者 &lt;code&gt;M&lt;/code&gt; は、型クラスまたは &lt;code&gt;N&lt;/code&gt; で定義された型に依存する必要があります。</target>
        </trans-unit>
        <trans-unit id="4721594427df43592a87eef3fe9a7c319440d2ac" translate="yes" xml:space="preserve">
          <source>This is a suitable definition for an &lt;code&gt;mtimes&lt;/code&gt; member of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、適した定義である &lt;code&gt;mtimes&lt;/code&gt; のメンバー &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bec2a1e9f6c0528918f3d75270102aae0235701e" translate="yes" xml:space="preserve">
          <source>This is a tad complicated for our &lt;code&gt;ApplicativeDo&lt;/code&gt; extension which will give it a &lt;code&gt;Monad&lt;/code&gt; constraint. For an &lt;code&gt;Applicative&lt;/code&gt; constraint we write it of the form</source>
          <target state="translated">これは、 &lt;code&gt;Monad&lt;/code&gt; 制約を与える &lt;code&gt;ApplicativeDo&lt;/code&gt; 拡張機能にとっては少し複雑です。以下のため &lt;code&gt;Applicative&lt;/code&gt; 制約我々は、フォームのそれを書きます</target>
        </trans-unit>
        <trans-unit id="9d950f78f6594d495d879d450f50f2aaabfabc86" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは有効な定義です &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; ため &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f7c8d617e149468fb4914e042ce1964608c94f4" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、べき等 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 有効な定義です。</target>
        </trans-unit>
        <trans-unit id="85d5215128cc4957be290b7930eb2a5cf73d213f" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは、べき等 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 有効な定義です。</target>
        </trans-unit>
        <trans-unit id="172ab78ae87f58f1be94549d14a2e6f93c70f4c1" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; の変形で、ファイナライザは任意の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションです。呼び出されると、ファイナライザは新しいスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="b4e325aa9ef040b927e3fb7ef2baa5b6a0f1b819" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;IO&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">これは &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; の変形で、ファイナライザは任意の &lt;code&gt;IO&lt;/code&gt; アクションです。呼び出されると、ファイナライザは新しいスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="371673f71c58c2e9cdb85387820977d33c4caf49" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">これは、異物の中にあるポインタを見る方法です。この関数は、そのポインターに適用される関数を取ります。次に、結果の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが実行されます。異物は、内部で直接使用されていなくても、少なくともアクション全体を通して存続します。アクションからポインタを返して、アクションの完了後に使用することは安全ではないことに注意してください。ポインターのすべての使用は、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; ブラケット内にある必要があります。このunsafeness理由はと同じです &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; コンパイラのみの使用を追跡することができますので、ファイナライザは、予想よりも早く実行することがあります。以下 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; のオブジェクト、いない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; それから作られたオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="1bf47a6eebbbeb1a3756083812189988818bf7bb" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">これは、異物の中にあるポインタを見る方法です。この関数は、そのポインターに適用される関数を取ります。次に、結果の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; アクションが実行されます。異物は、内部で直接使用されていなくても、少なくともアクション全体を通して存続します。アクションからポインタを返して、アクションの完了後に使用することは安全ではないことに注意してください。ポインターのすべての使用は、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; ブラケット内にある必要があります。このunsafeness理由はと同じです &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; コンパイラのみの使用を追跡することができますので、ファイナライザは、予想よりも早く実行することがあります。以下 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; のオブジェクト、いない &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; それから作られたオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="0f341bdd202c5cbf36cfc8ae95ca15781837c676" translate="yes" xml:space="preserve">
          <source>This is a workaround for poor optimisation in GHC 6.8.2. It fails to notice constant-width shifts, and adds a test and branch to every shift. This imposes about a 10% performance hit.</source>
          <target state="translated">これは、GHC 6.8.2 の最適化が不十分な場合の回避策です。これは定数幅のシフトに気づかず、シフトごとにテストとブランチを追加します。これは約 10% のパフォーマンスの低下をもたらします。</target>
        </trans-unit>
        <trans-unit id="8c2b599fbba068d2e3306d55e3da89a6dea9c30d" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt;, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; とほぼ同じですが、オプション引数、非オプションのリスト、認識されないオプションのリスト、およびエラーメッセージのリストで構成される4つの要素を返します。</target>
        </trans-unit>
        <trans-unit id="d0e2442d2a5176acfea0d861dcdf4c526699f651" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt;, except that &lt;code&gt;ghc-pkg dump&lt;/code&gt; is intended for use by tools that parse the results, so for example where &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; will emit an error if it can&amp;rsquo;t find any packages that match the pattern, &lt;code&gt;ghc-pkg dump&lt;/code&gt; will simply emit nothing.</source>
          <target state="translated">これは &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; とほぼ同じですが、 &lt;code&gt;ghc-pkg dump&lt;/code&gt; は結果を解析するツールによる使用を意図しているため、たとえば &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; が可能な場合にエラーを出力します。 tパターンに一致するパッケージを見つけると、 &lt;code&gt;ghc-pkg dump&lt;/code&gt; は何も出力しません。</target>
        </trans-unit>
        <trans-unit id="7792587286beb0c2340a33dbd540974a7aa95716" translate="yes" xml:space="preserve">
          <source>This is also known as the catamorphism on trees.</source>
          <target state="translated">これは、木の上のカタモルフィズムとも呼ばれています。</target>
        </trans-unit>
        <trans-unit id="c1f05073a7db37870040709ee8825ace5ad9e27b" translate="yes" xml:space="preserve">
          <source>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</source>
          <target state="translated">これは、並列ガベージコレクションに参加するスレッドの数でもあります。能力の数は物理プロセッサのコア数よりも大きく設定しないことが強く推奨され、マシン内の他のプロセスとの競合を避けるために、1つ以上のコアを空けておくことが有益な場合もあります。</target>
        </trans-unit>
        <trans-unit id="beec198333c6e916a71dc2007f654bbfb496d115" translate="yes" xml:space="preserve">
          <source>This is always an integral type. Width and signedness are platform specific.</source>
          <target state="translated">これは常に積分型です。幅と符号付きはプラットフォーム固有のものです。</target>
        </trans-unit>
        <trans-unit id="2c94c1e0eafc78c19212557dee894b114bd63e4b" translate="yes" xml:space="preserve">
          <source>This is an alternative backend that uses the &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler to produce executable code. It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector. The penalty is a significant increase in compilation times. Select the LLVM backend with the &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">これは、&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt;コンパイラを使用して実行可能コードを生成する代替バックエンドです。通常、ネイティブコードジェネレーターと同等のパフォーマンスでコードを生成しますが、場合によってははるかに高速なコードを生成できます。これは、ベクトルのようなパッケージを使用した、数値の配列が多いコードに特に当てはまります。ペナルティは、コンパイル時間の大幅な増加です。&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;フラグを使用してLLVMバックエンドを選択します。</target>
        </trans-unit>
        <trans-unit id="b07234aad669def52b50175f945aeebcd045d700" translate="yes" xml:space="preserve">
          <source>This is an experimental feature, please let us know if it causes problems and/or could benefit from further tuning.</source>
          <target state="translated">これは実験的な機能ですので、問題が発生した場合や、さらなるチューニングが必要な場合はお知らせください。</target>
        </trans-unit>
        <trans-unit id="d518bb2db084fc2424d01684cf81e93ef233a006" translate="yes" xml:space="preserve">
          <source>This is an infix alias for &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; のインフィックスエイリアスです。</target>
        </trans-unit>
        <trans-unit id="101923d23a1c0936899b25445ac34361e56b2129" translate="yes" xml:space="preserve">
          <source>This is an infix version of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; with the arguments flipped.</source>
          <target state="translated">これは、引数が反転した &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; のインフィックスバージョンです。</target>
        </trans-unit>
        <trans-unit id="58c0c8b3a56848782113a6355b13f876cdde90db" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;qsort&lt;/code&gt; is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display &lt;code&gt;left&lt;/code&gt; at the prompt, GHCi can&amp;rsquo;t figure out which instance of &lt;code&gt;Show&lt;/code&gt; to use, so it emits the type error above.</source>
          <target state="translated">これは、 &lt;code&gt;qsort&lt;/code&gt; がポリモーフィック関数であり、GHCiは実行時に型情報を保持しないため、型変数が関係する自由変数の実行時型を判別できないためです。したがって、プロンプトで &lt;code&gt;left&lt;/code&gt; に表示するように要求すると、GHCiは使用する &lt;code&gt;Show&lt;/code&gt; のインスタンスを判別できないため、上記のタイプエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9020fa1ceb2a91d141dfe05d47580894b2e14468" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">これは、 &lt;code&gt;Natural&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; で使用される一般的なタイプです。このタイプは、 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; をラップする単一のコンストラクターで構成されているため、解凍できます。</target>
        </trans-unit>
        <trans-unit id="31f122da1e52003fb749b42feb286b289a499229" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">これは、 &lt;code&gt;Natural&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; で使用される一般的なタイプです。この型は &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; をラップする単一のコンストラクターで構成されるため、アンパックできます。</target>
        </trans-unit>
        <trans-unit id="e46c9188c411a7574791b7db9d68e4a5ba400984" translate="yes" xml:space="preserve">
          <source>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</source>
          <target state="translated">これは正しさを維持するために非常に重要です。他のモジュールで定義されているエンティティは、(機能的にも性能的にも)正しさのために怠惰に依存している可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed31266df50c8047adeba9f8ad5ed4814f624b36" translate="yes" xml:space="preserve">
          <source>This is currently only returned by the following operations:</source>
          <target state="translated">これは現在のところ、以下の操作によってのみ返されます。</target>
        </trans-unit>
        <trans-unit id="69022b713a9a3be30ce145d8a3fa9a46d52862c0" translate="yes" xml:space="preserve">
          <source>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</source>
          <target state="translated">しかし、これは危険な領域です。例えば、ここではタイプチェッカをループさせるプログラムを紹介します。</target>
        </trans-unit>
        <trans-unit id="8bef230a1b33fc363b0b8397f3ec27a17fff06b4" translate="yes" xml:space="preserve">
          <source>This is definitely caused by a bug in GHC. Please report it (see &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt;).</source>
          <target state="translated">これは間違いなくGHCのバグが原因です。報告してください（&lt;a href=&quot;intro#bug-reporting&quot;&gt;GHCのバグの報告を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="50509e11fe7ca6ff18f57510c20c4165a78570ab" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;if p then y else x&lt;/code&gt;; that is, one can think of it as an if-then-else construct with its arguments reordered.</source>
          <target state="translated">これは、 &lt;code&gt;if p then y else x&lt;/code&gt; と同じです。つまり、引数を並べ替えたif-then-else構文と考えることができます。</target>
        </trans-unit>
        <trans-unit id="ac94cb7c266f7957cc925f86fcff5b3aa8d29a4c" translate="yes" xml:space="preserve">
          <source>This is essentially a more performant version of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; that always returns the first result, if any. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは基本的に、より最初の結果を常に返す &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; のより高性能なバージョンです。詳細は &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; のドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="62b9a042aea0816af6e299c00f387f0402dcd3d1" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Eq&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">これは基本的に、 &lt;code&gt;data Foo a&lt;/code&gt; 宣言後に &lt;code&gt;deriving Eq&lt;/code&gt; 記述した場合と同じです。この機能を使用するには、&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9595725d43f98726f370669a781ee6935055f745" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Foo&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">これは、 &lt;code&gt;data Foo a&lt;/code&gt; 宣言後に &lt;code&gt;deriving Foo&lt;/code&gt; 記述した場合と本質的に同じです。この機能を使用するには、&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6d6cf1a68093409280369c1b6acf1d281e7ce24d" translate="yes" xml:space="preserve">
          <source>This is expected to improve performance on average, but actual performance difference can vary.</source>
          <target state="translated">平均的な性能向上が期待できますが、実際の性能差は様々です。</target>
        </trans-unit>
        <trans-unit id="9ac537ddcd723a43b8f01589d4e737eed3f70681" translate="yes" xml:space="preserve">
          <source>This is exposed solely for people writing GHC rewrite rules.</source>
          <target state="translated">これはGHCの書き換えルールを書いている人だけが晒されています。</target>
        </trans-unit>
        <trans-unit id="8f87cd084e7f91046e80a5ffa06a25dbafabc73f" translate="yes" xml:space="preserve">
          <source>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren&amp;rsquo;t referenced by any other code linked into the executable. If you&amp;rsquo;re using &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt;, you probably also want &lt;code&gt;-rdynamic&lt;/code&gt;.</source>
          <target state="translated">これは、実行可能ファイルにリンクされた他のコードによって参照されていなくても、実行時にこれらのHaskellライブラリで定義されたシンボルを必要とする可能性のある専門的なアプリケーション用です。 &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt; を使用している場合は、おそらく &lt;code&gt;-rdynamic&lt;/code&gt; も必要です。</target>
        </trans-unit>
        <trans-unit id="bb0b93f1aaeb2183a73344bfad7f37c373c52776" translate="yes" xml:space="preserve">
          <source>This is how to define &lt;code&gt;insertLookup&lt;/code&gt; using &lt;code&gt;insertLookupWithKey&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;insertLookup&lt;/code&gt; WithKeyを使用して &lt;code&gt;insertLookupWithKey&lt;/code&gt; を定義する方法です。</target>
        </trans-unit>
        <trans-unit id="f42e6638d71ed609c1ebc5bfa4f5a4bdde5aa067" translate="yes" xml:space="preserve">
          <source>This is illegal because the use of &lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</source>
          <target state="translated">右側に&lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt;を使用すると、正しい形式にすることができなくなるため、これは違法です。ただし、厳密なパターンシノニムを構築することは、明示的に双方向のパターンシノニムを使用すると非常に可能です。</target>
        </trans-unit>
        <trans-unit id="8c0c93b41bba3d3d671093acebd3b256b511ac64" translate="yes" xml:space="preserve">
          <source>This is internally implemented as count-leading-zeros machine instruction.</source>
          <target state="translated">内部的には、カウント先頭ゼロのマシン命令として実装されています。</target>
        </trans-unit>
        <trans-unit id="852b04a3b6aa2150c763c2710aeb536c17bc4e95" translate="yes" xml:space="preserve">
          <source>This is just a convenience function, it's defined simply as:</source>
          <target state="translated">これはただの便利な機能で、単純に定義されています。</target>
        </trans-unit>
        <trans-unit id="e45e37056992d6af3645dca1e73531419ebe8cab" translate="yes" xml:space="preserve">
          <source>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</source>
          <target state="translated">これは主にCmmパスの時に行われます。しかし、これはコーナーケースを見逃してしまう可能性があります。そこで、-O2では、これらを捕捉するために、ASMの段階で再度パスを実行します。</target>
        </trans-unit>
        <trans-unit id="a5b597ca7719e3d8708a1e507512f84a11523c7d" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">これは通常、可能なすべての文字を返すのではなく、上位レベルの構成体に関してエラーメッセージを返したい代替セットの最後に使用されます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; の例の &lt;code&gt;expr&lt;/code&gt; パーサーが失敗すると、エラーメッセージは次のようになります。なければ &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; あまりフレンドリーである、「『せ』期待や手紙...」コンビネータ、メッセージは次のようになります。</target>
        </trans-unit>
        <trans-unit id="39a3eeed9577807a13413d7d9a4747103d4ba578" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">これは通常、可能なすべての文字を返すのではなく、上位レベルの構成体に関してエラーメッセージを返したい代替セットの最後に使用されます。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; の例の &lt;code&gt;expr&lt;/code&gt; パーサーが失敗すると、エラーメッセージは次のようになります。なければ &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; あまりフレンドリーである、「『せ』期待や手紙...」コンビネータ、メッセージは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c67587857810fc437f5fd2889f14753f716a50b7" translate="yes" xml:space="preserve">
          <source>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</source>
          <target state="translated">これは、出力が長い場合や、非 ASCII 文字を含む文字列を含む場合など、特定のケースでは理想的ではありません。</target>
        </trans-unit>
        <trans-unit id="19107584e7f459839bffc5515c49619c3a279acc" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは特殊文字の場合は処理されません。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; のような特別な文字を理解するため、ユーザー文字列には代わりにstringToHtmlまたはlineToHtmlを使用してください。</target>
        </trans-unit>
        <trans-unit id="9eee7f5de1930e679b3ff1bf2b45247aa3e4891d" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは特別な文字では処理されません。ユーザー文字列には、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; などの特殊な文字を理解するため、代わりにstringToHtmlまたはlineToHtmlを使用してください。</target>
        </trans-unit>
        <trans-unit id="e7fa5f45c008c43283961b6bf73fec56028cc02f" translate="yes" xml:space="preserve">
          <source>This is particularly useful in conjunction with larger &lt;code&gt;-A&lt;/code&gt; values, for example &lt;code&gt;-A64m -n4m&lt;/code&gt; is a useful combination on larger core counts (8+).</source>
          <target state="translated">これは特に、より大きな &lt;code&gt;-A&lt;/code&gt; 値と組み合わせて使用​​すると便利です。たとえば、 &lt;code&gt;-A64m -n4m&lt;/code&gt; は、より大きなコア数（8+）での便利な組み合わせです。</target>
        </trans-unit>
        <trans-unit id="9eda36a1c5f71327f9a1ce36f39f69ceebc7a2ca" translate="yes" xml:space="preserve">
          <source>This is particularly useful with the &lt;code&gt;ViewPatterns&lt;/code&gt; extension to GHC, as follows:</source>
          <target state="translated">これは、次のように、GHC の &lt;code&gt;ViewPatterns&lt;/code&gt; 拡張機能で特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f9953554c74c35663186a90c0246462e6382fb5f" translate="yes" xml:space="preserve">
          <source>This is rather similar to the class &lt;code&gt;IsString&lt;/code&gt; (see &lt;a href=&quot;#overloaded-strings&quot;&gt;Overloaded string literals&lt;/a&gt;), but with an additional type parameter that makes the text of the label available as a type-level string (see &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;). Note that &lt;code&gt;fromLabel&lt;/code&gt; had an extra &lt;code&gt;Proxy# x&lt;/code&gt; argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) can be used instead.</source>
          <target state="translated">これはクラス &lt;code&gt;IsString&lt;/code&gt; に似ていますが（&lt;a href=&quot;#overloaded-strings&quot;&gt;オーバーロードされた文字列リテラルを&lt;/a&gt;参照）、ラベルのテキストをタイプレベルの文字列として使用できるようにする追加のタイプパラメーターがあります（&lt;a href=&quot;#type-level-literals&quot;&gt;タイプレベルリテラルを&lt;/a&gt;参照）。注こと &lt;code&gt;fromLabel&lt;/code&gt; は余分だった &lt;code&gt;Proxy# x&lt;/code&gt; GHC 8.0で引数を、これは（参照型アプリケーションとしてGHC 8.2で削除された&lt;a href=&quot;#visible-type-application&quot;&gt;可視型アプリケーションを&lt;/a&gt;代わりに使用することができます）。</target>
        </trans-unit>
        <trans-unit id="275797ad44149a221def0ee243441fcab463f9bc" translate="yes" xml:space="preserve">
          <source>This is rejected because there is no &amp;ldquo;outermost level&amp;rdquo; for the types on the RHS (it would obviously be terrible to add extra parameters to &lt;code&gt;PackMap&lt;/code&gt;), so no implicit quantification happens, and the declaration is rejected (with &amp;ldquo;&lt;code&gt;f&lt;/code&gt; is out of scope&amp;rdquo;). Solution: use an explicit &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">これは拒否されます &lt;code&gt;PackMap&lt;/code&gt; の型には「最外レベル」がないためです（PackMapにパラメーターを追加するのは明らかにひどいでしょう）。暗黙的な数量化は行われず、宣言は拒否されます（「 &lt;code&gt;f&lt;/code&gt; はスコープ外です」」）。解決策：明示的な &lt;code&gt;forall&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="965462ce779e5c5398c7b7c8822c6fe46cd11f7e" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type is generalised, to get</source>
          <target state="translated">これはHaskell 98では拒否されていますが、ジョーンズのスキームでは、 &lt;code&gt;g&lt;/code&gt; の右側の &lt;code&gt;f&lt;/code&gt; への参照が依存関係分析によって無視されるため、 &lt;code&gt;f&lt;/code&gt; の定義とは別に、 &lt;code&gt;g&lt;/code&gt; の定義が最初にタイプチェックされます。次に &lt;code&gt;g&lt;/code&gt; の型を一般化して、</target>
        </trans-unit>
        <trans-unit id="af9e5e6b5a1471403ba13a39e6cf598e61cc7f1f" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type is generalised, to get</source>
          <target state="translated">これはハスケル98によって拒絶されるが、ジョーンズのスキームの下での定義 &lt;code&gt;g&lt;/code&gt; をするための第1の型検査され、別々にそれから &lt;code&gt;f&lt;/code&gt; を参照するために、 &lt;code&gt;f&lt;/code&gt; で &lt;code&gt;g&lt;/code&gt; 「の右手側は、依存関係分析では無視されます。次に、 &lt;code&gt;g&lt;/code&gt; のタイプを一般化して、</target>
        </trans-unit>
        <trans-unit id="173eae666fe7062188303aaed7c3e9e91b4501ad" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;1&lt;/code&gt; when the compiler supports Template Haskell, and to &lt;code&gt;0&lt;/code&gt; when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</source>
          <target state="translated">コンパイラがテンプレートHaskellをサポートしている場合は &lt;code&gt;1&lt;/code&gt; に設定され、サポートしていない場合は &lt;code&gt;0&lt;/code&gt; に設定されます。後者は、ブートストラップ中のステージ1コンパイラーの場合、またはインタープリターが使用できないアーキテクチャーの場合です。</target>
        </trans-unit>
        <trans-unit id="e2a9fd34e0777a91dc7abb06fe3e0b3098e9ec74" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; の法則は結合性の形式を意味するため、これは抽象型にも適しています。</target>
        </trans-unit>
        <trans-unit id="e5265ef186d0fe504d07549453be769b06cb5de9" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; の法則は結合性の形式を意味するため、これは抽象型にも適しています。</target>
        </trans-unit>
        <trans-unit id="886cde162909e5053a7382858de7970df163c591" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the monoid is assumed to satisfy the monoid laws. Alternatively, one could define &lt;code&gt;foldr&lt;/code&gt;:</source>
          <target state="translated">モノイドはモノイドの法則を満たすと想定されるため、これは抽象型にも適しています。あるいは、 &lt;code&gt;foldr&lt;/code&gt; を定義することもできます。</target>
        </trans-unit>
        <trans-unit id="bbe2ee805fe872cdfa9dad562a94abbdd44ba100" translate="yes" xml:space="preserve">
          <source>This is suitable for datatypes that are exported transparently.</source>
          <target state="translated">透過的にエクスポートされるデータ型に適しています。</target>
        </trans-unit>
        <trans-unit id="fb6774461de6668cb4c86bcd9b2d0f93d1213ac5" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへの「バックドア」であり、いつでも &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算を実行できます。これを安全に行うには、 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算に副作用がなく、その環境に依存しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="e076e79d373c95008b4305220e373d648e1a35dc" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドへの「バックドア」であり、いつでも &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算を実行できます。これを安全に行うには、 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算に副作用がなく、その環境に依存しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="fbf56641bd07ddb82df111a846a14d313459064a" translate="yes" xml:space="preserve">
          <source>This is the analogue of the &lt;code&gt;LINE&lt;/code&gt; pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</source>
          <target state="translated">これは &lt;code&gt;LINE&lt;/code&gt; プラグマに類似しており、同様に自動生成されたHaskellコードでの使用を目的としています。元のコードの列番号を指定できます。例えば</target>
        </trans-unit>
        <trans-unit id="5c9cf33d55e8504f25f0586b2ca2f9cf2d7a74c1" translate="yes" xml:space="preserve">
          <source>This is the defined behaviour of &lt;code&gt;getContents&lt;/code&gt;: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">これは &lt;code&gt;getContents&lt;/code&gt; の定義された動作です。stdinHandleをセミクローズと呼ばれる状態にします。この状態でのそれ以上のI / O操作は禁止されます。I / O状態は計算間で保持されるため、セミクローズ状態は次の&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;コマンドまで持続します。</target>
        </trans-unit>
        <trans-unit id="d59a26993924ddd4622ca180b22b28d96a32273b" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="a8cafe2ab0917d4201e6879d83ae5338339737b2" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="f6167f3d89f3a57f13ddc1cfc30ba818a1c14f35" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="1d382c742dccd9be34f30f4a4585a36c280b6334" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; の基本的な戦術です。</target>
        </trans-unit>
        <trans-unit id="cbc6595af04522c2fde6302bbc4d97ab2ecf3276" translate="yes" xml:space="preserve">
          <source>This is the initial locale encoding: if it has been subsequently changed by &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; this value will not reflect that change.</source>
          <target state="translated">これは初期ロケールエンコーディングです。その後 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; によって変更された場合、この値はその変更を反映しません。</target>
        </trans-unit>
        <trans-unit id="abd17a970d52fd304b594c189a551764634555bd" translate="yes" xml:space="preserve">
          <source>This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won&amp;rsquo;t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</source>
          <target state="translated">これは展開（つまりインライン化）の魔法のカットオフ図です。このサイズより下では、関数定義は呼び出しサイトで展開されますが、それより大きくても展開されません。関数に対して計算されるサイズは、2つの要素に依存します。式の実際のサイズから、式がインライン化されるコンテキストに応じて適用される割引を差し引いたものです。</target>
        </trans-unit>
        <trans-unit id="67b68027f5d62fd3f61a1b54666f56f7507aeca1" translate="yes" xml:space="preserve">
          <source>This is the most basic way to make your program go faster. Compilation time will be slower, especially with &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">これは、プログラムを高速化する最も基本的な方法です。特に &lt;code&gt;-O2&lt;/code&gt; を使用すると、コンパイル時間が遅くなります。</target>
        </trans-unit>
        <trans-unit id="da3c5884261af5d6c5ce2a2fefd25b97aeda4835" translate="yes" xml:space="preserve">
          <source>This is the most general interface for building a weak pointer.</source>
          <target state="translated">これは、弱いポインタを構築するための最も一般的なインタフェースです。</target>
        </trans-unit>
        <trans-unit id="5dbbb7f4bd171d6e5fe3f02c892e785922548729" translate="yes" xml:space="preserve">
          <source>This is the most general of the grouping-type statements. In this form, f is required to have type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt;. As with the &lt;code&gt;then f by e&lt;/code&gt; case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to &lt;em&gt;lists&lt;/em&gt; of possible values, not single values. To help understand this, let&amp;rsquo;s look at an example:</source>
          <target state="translated">これは、最も一般的なグループ化タイプのステートメントです。この形式では、fには &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt; 型が必要です。（a-&amp;gt; t）-&amp;gt; [a]-&amp;gt; [[a]]。上記の &lt;code&gt;then f by e&lt;/code&gt; の場合と同様に、最初の引数は、変換されるリストのすべての要素でeを計算できるようにするコンパイラーによってfに提供される関数です。ただし、非グループ化の場合とは異なり、fはリストをいくつかのサブリストにさらに分割します。つまり、このステートメントの後のすべての時点で、内包でその前に現れるバインダーは、単一の値ではなく、可能な値の&lt;em&gt;リスト&lt;/em&gt;を参照し&lt;em&gt;ます&lt;/em&gt;。これを理解するために、例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="97cacebb8a50334f0aa10455086684215843c90c" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">これは、外部プロセスを生成する最も一般的な方法です。プロセスは、シェルによって実行されるコマンドライン、または引数のリストを含むrawコマンドです。新しいプロセスのstdin、stdout、およびstderrストリームは、新しいパイプ、既存の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; に個別に接続するか、または親から継承することができます（デフォルト）。</target>
        </trans-unit>
        <trans-unit id="11f3ed6859503f000bff2d612fad07f02ba594bf" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">これは、外部プロセスを生成するための最も一般的な方法です。プロセスは、シェルによって実行されるコマンドライン、または引数のリストを含むrawコマンドにすることができます。新しいプロセスのstdin、stdout、およびstderrストリームは、個別に新しいパイプ、既存の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 接続するか、親から継承することができます（デフォルト）。</target>
        </trans-unit>
        <trans-unit id="17c6bc999a6e66cdf70760668583b194f94060fb" translate="yes" xml:space="preserve">
          <source>This is the most minimal token definition. It is recommended to use this definition as the basis for other definitions. &lt;code&gt;emptyDef&lt;/code&gt; has no reserved names or operators, is case sensitive and doesn't accept comments, identifiers or operators.</source>
          <target state="translated">これは最小のトークン定義です。この定義を他の定義の基礎として使用することをお勧めします。 &lt;code&gt;emptyDef&lt;/code&gt; には予約名や演算子はなく、大文字と小文字が区別され、コメント、識別子、または演算子を受け入れません。</target>
        </trans-unit>
        <trans-unit id="28714170914c36c5937fb4d6795c7183bf135afa" translate="yes" xml:space="preserve">
          <source>This is the most primitive combinator for accepting tokens. For example, the &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; parser could be implemented as:</source>
          <target state="translated">これは、トークンを受け入れるための最も原始的なコンビネーターです。たとえば、 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; パーサーは次のように実装できます。</target>
        </trans-unit>
        <trans-unit id="c028e89a3d3ce63ac917bdfc38f641c5b46ea80a" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt;&lt;code&gt;-fvia-C&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">これはGHCで最も古いコードジェネレーターであり、GHC 7.0で廃止されたため、通常は含まれていません。&lt;a href=&quot;#ghc-flag--fvia-C&quot;&gt; &lt;code&gt;-fvia-C&lt;/code&gt; &lt;/a&gt;フラグを付けて選択します。</target>
        </trans-unit>
        <trans-unit id="6b5e00d2ed34cf00eb62f197974c932b271f59b3" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;code&gt;-fvia-C&lt;/code&gt; flag.</source>
          <target state="translated">これはGHCで最も古いコードジェネレーターであり、GHC 7.0で非推奨になったため、通常は含まれていません。 &lt;code&gt;-fvia-C&lt;/code&gt; フラグで選択します。</target>
        </trans-unit>
        <trans-unit id="3ef0a3e02d26e1de4897c94f804fb945f14b00c6" translate="yes" xml:space="preserve">
          <source>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the &quot;handler&quot; is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</source>
          <target state="translated">これは例外キャッチ関数の中で最もシンプルなものです。1つの引数を受け取って実行し、例外が発生した場合には、例外の値を引数として渡した「ハンドラ」が実行されます。そうでなければ、結果は通常通りに返されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="709bbf178e88d31284082a439684f263fe4c4cba" translate="yes" xml:space="preserve">
          <source>This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.</source>
          <target state="translated">これはUTCの最も単純な表現です。これは、日番号と真夜中からの時間オフセットで構成されています。日にうるう秒が追加された場合、86401秒になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4dbe9128e5734a5df9b1f11da3e326916a92167" translate="yes" xml:space="preserve">
          <source>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See &lt;a href=&quot;#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;.</source>
          <target state="translated">これは従来のバッチコンパイラモードで、GHCはソースファイルを一度に1つずつコンパイルしたり、オブジェクトをリンクして実行可能ファイルにしたりできます。&lt;a href=&quot;#options-order&quot;&gt;バッチコンパイラモードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="63579352bd238619f1e8291119e93600ef4a9cde" translate="yes" xml:space="preserve">
          <source>This is the type of a field formatter reified over its argument.</source>
          <target state="translated">これは、フィールドフォーマッタがその引数の上に再定義されたタイプです。</target>
        </trans-unit>
        <trans-unit id="e04da25499a8419831fe5bf0581bda0dfaf2d2e9" translate="yes" xml:space="preserve">
          <source>This is thrown when the user calls &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. The first &lt;code&gt;String&lt;/code&gt; is the argument given to &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, second &lt;code&gt;String&lt;/code&gt; is the location.</source>
          <target state="translated">これは、ユーザーが &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; を呼び出したときにスローされます。最初の &lt;code&gt;String&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; に与えられた引数で、2番目の &lt;code&gt;String&lt;/code&gt; は場所です。</target>
        </trans-unit>
        <trans-unit id="aebf3f40f6a1942ecdd588383580c2939b2e0f04" translate="yes" xml:space="preserve">
          <source>This is unsafe because GHC cannot check for you that the expression really does have the type you claim it has.</source>
          <target state="translated">GHCは、あなたが主張するタイプの表現が本当にあるかどうかを確認できないので、これは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="a3b52992dd96200ef77ecde2d026b069e2b12589" translate="yes" xml:space="preserve">
          <source>This is used for holes or unresolved identifiers in AST quotes. Note that it could either have a variable name or constructor name.</source>
          <target state="translated">これは、ASTの引用符に穴が開いていたり、解決されていない識別子がある場合に使用します。変数名かコンストラクタ名のどちらかを指定することに注意してください。</target>
        </trans-unit>
        <trans-unit id="328c1fbc5f4cd720ec3ec26821113be04b4a5990" translate="yes" xml:space="preserve">
          <source>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type &lt;code&gt;Any&lt;/code&gt; (by way of &lt;code&gt;unsafeCoerce#&lt;/code&gt;) and the result type is allowed to be an unboxed tuple or the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">これは、内部GHC呼び出し規約に従うCmmコードで記述された関数をインポートするために使用されます。引数と結果はボックス化されていない型である必要があります。ただし、引数の型は（ &lt;code&gt;unsafeCoerce#&lt;/code&gt; によって） &lt;code&gt;Any&lt;/code&gt; であり、結果の型はボックス化されていないタプルまたは &lt;code&gt;Any&lt;/code&gt; 型にすることができます。</target>
        </trans-unit>
        <trans-unit id="8b782ef95535f2b46a643a86d5559d4d59530093" translate="yes" xml:space="preserve">
          <source>This is useful for functions parameterized by a monad transformer.</source>
          <target state="translated">これは、モナド変換器によってパラメータ化された関数に便利です。</target>
        </trans-unit>
        <trans-unit id="191eaf7a7c1efa9d12f4d0ead171eac959ffb8bd" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;lsquo;s.</source>
          <target state="translated">これは&lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt;と組み合わせて使用すると、生成されたファイルが &lt;code&gt;Unique&lt;/code&gt; の順序に依存しているかどうかをテストするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="eb2802e19e3cc64605ff63d36592512d32cabe42" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;rsquo;s.</source>
          <target state="translated">これは、&lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt;と組み合わせて、生成されたファイルが &lt;code&gt;Unique&lt;/code&gt; の順序に依存しているかどうかをテストするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="223669d1cce36e8738573bac6e197f3c8162072c" translate="yes" xml:space="preserve">
          <source>This is very similar to &lt;code&gt;&lt;a href=&quot;../mtl-2.2.2/control-monad-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;MonadError&lt;/code&gt;, but based on features of &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;. In particular, it handles the complex case of asynchronous exceptions by including &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; in the typeclass. Note that the extensible exceptions feature relies on the RankNTypes language extension.</source>
          <target state="translated">これは非常によく似ている &lt;code&gt;&lt;a href=&quot;../mtl-2.2.2/control-monad-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;MonadError&lt;/code&gt; が、の機能に基づいて&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。特に、型クラスに &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; を含めることにより、非同期例外の複雑なケースを処理します。拡張可能な例外機能は、RankNTypes言語拡張に依存していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d104180869342bc19c17c8e3619b3cc9055aa1fa" translate="yes" xml:space="preserve">
          <source>This is why the RIO module is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;&amp;gt;, to allow the &lt;code&gt;Danger&lt;/code&gt; module to import it. The &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; flag doesn&amp;rsquo;t place any restrictions on the module like &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; does (expect to restrict overlapping instances to &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</source>
          <target state="translated">これが、 &lt;code&gt;Danger&lt;/code&gt; モジュールがインポートできるように、RIOモジュールが&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; &amp;gt;でコンパイルされている理由です。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;旗のようなモジュール上の任意の制限をかけない&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;（にインスタンスの重複制限するために期待しない&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全なオーバーラップインスタンス&lt;/a&gt;）。代わりに、モジュールの作成者は、コードが内部的に安全でない機能を使用する可能性がある一方で、安全な方法で使用できるAPIしか公開しないと主張しています。</target>
        </trans-unit>
        <trans-unit id="b712b2b82446ae28f73908890d2ef7531e15ac14" translate="yes" xml:space="preserve">
          <source>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension &lt;code&gt;DatatypeContexts&lt;/code&gt;.</source>
          <target state="translated">これは広く誤用と見なされ、言語から削除されます。GHCでは、非推奨の拡張 &lt;code&gt;DatatypeContexts&lt;/code&gt; によって制御されます。</target>
        </trans-unit>
        <trans-unit id="6778bfd500940c8e2d9a62565cee855196c0bd56" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t particularly enlightening. What happened is that &lt;code&gt;left&lt;/code&gt; is bound to an unevaluated computation (a suspension, or thunk), and &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; does not force any evaluation. The idea is that &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; can be used to inspect values at a breakpoint without any unfortunate side effects. It won&amp;rsquo;t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won&amp;rsquo;t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see &lt;a href=&quot;#nested-breakpoints&quot;&gt;Nested breakpoints&lt;/a&gt;). Rather than forcing thunks, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds each thunk to a fresh variable beginning with an underscore, in this case &lt;code&gt;_t1&lt;/code&gt;.</source>
          <target state="translated">これは特に賢明ではありません。何が起こったかというと、 &lt;code&gt;left&lt;/code&gt; は評価されていない計算（一時停止、またはサンク）にバインドされており、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;は評価を強制しません。アイデアは、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;を使用して、不幸な副作用なしにブレークポイントで値を検査できることです。これは、プログラムに通常とは異なる答えを与える原因となる可能性がある評価を強制しません。したがって、例外が発生したり、無限ループが発生したり、さらにブレークポイントがトリガーされたりしません（&lt;a href=&quot;#nested-breakpoints&quot;&gt;ネストされたブレークポイントを&lt;/a&gt;参照）。 。サンクを強制するのではなく、&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;は各サンクをアンダースコアで始まる新しい変数（この場合は &lt;code&gt;_t1&lt;/code&gt; )にバインドします。</target>
        </trans-unit>
        <trans-unit id="a27ce07dfb7b638358503a182b9e384fb7c6d870" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;) for details.</source>
          <target state="translated">これだけではありません。GHCは、パッケージと呼ばれるコンパイル済みライブラリ内のモジュールも検索します。詳細については、パッケージ（&lt;a href=&quot;packages#packages&quot;&gt;パッケージ&lt;/a&gt;）のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="e058359ab2e82e0cac7dd3d00a96ceff57c41dfb" translate="yes" xml:space="preserve">
          <source>This kind is similar to the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;, but with a key difference: the type variables quantified by the &lt;code&gt;forall&lt;/code&gt; are followed by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;), not a dot (&lt;code&gt;.&lt;/code&gt;). This is a visible, dependent quantifier. It is visible in that it the user must pass in a type for &lt;code&gt;k&lt;/code&gt; explicitly, and it is dependent in the sense that &lt;code&gt;k&lt;/code&gt; appears later in the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;. As a counterpart, the &lt;code&gt;k&lt;/code&gt; binder in &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; can be thought of as an &lt;em&gt;invisible&lt;/em&gt;, dependent quantifier.</source>
          <target state="translated">この種のようなものに似ている &lt;code&gt;ProxyKInvis&lt;/code&gt; が、重要な違いで：によって定量化型変数 &lt;code&gt;forall&lt;/code&gt; 矢印が続く（ &lt;code&gt;-&amp;gt;&lt;/code&gt; ）ではなく、ドット（ &lt;code&gt;.&lt;/code&gt; ）。これは、目に見える、依存する数量詞です。ユーザーが &lt;code&gt;k&lt;/code&gt; の型を明示的に渡す必要があることは明らかであり、 &lt;code&gt;k&lt;/code&gt; が後で &lt;code&gt;ProxyKVis&lt;/code&gt; の種類で表示されるという意味で依存しています。カウンターパートとして、 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; &lt;code&gt;k&lt;/code&gt; バインダー。 k-&amp;gt;タイプは、&lt;em&gt;目に見えない&lt;/em&gt;従属数量詞と考えることができます。</target>
        </trans-unit>
        <trans-unit id="a1decd194e9db593e0098385b29579f07d63ab43" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">この種の推論の欠如は、GHC内のエンジニアリングの問題にすぎませんが、それを機能させると、推論インフラストラクチャに大幅な変更が加えられ、その見返りが価値があるかどうかは不明です。上記のインスタンスで &lt;code&gt;b&lt;/code&gt; の種類を制限する場合は、インスタンスヘッドで種類シグネチャを使用します。</target>
        </trans-unit>
        <trans-unit id="35e744da89ea652776d7de1d49ded5a0e6370630" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">この種類の推論の欠如は、GHC内のエンジニアリングの問題にすぎませんが、それを機能させると、推論インフラストラクチャに大幅な変更が加えられ、その見返りに価値があるかどうかは明らかではありません。上記のインスタンスで &lt;code&gt;b&lt;/code&gt; の種類を制限する場合は、インスタンスヘッドで種類の署名を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="9700917da64757c5e788e69e5482f32627c03338" translate="yes" xml:space="preserve">
          <source>This legacy module provides access to the list-specialised operations of &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable/Traversable-in-Prelude Proposal (FTP)&lt;/a&gt;.</source>
          <target state="translated">このレガシーモジュールは、&lt;a href=&quot;data-list&quot;&gt;Data.Listの&lt;/a&gt;リスト専用の操作へのアクセスを提供します。このモジュールは将来のGHCバージョンで再びなくなる可能性があり、&lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable / Traversable-in-Prelude Proposal（FTP）&lt;/a&gt;の実装のために一般化する必要があったリスト専用の操作にアクセスするための移行ツールとして提供されます。</target>
        </trans-unit>
        <trans-unit id="e36c09f207f2c815a09c379dd1fb2c4090b7e037" translate="yes" xml:space="preserve">
          <source>This lets you use a difference list of a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 差分リストを &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="9ae93c187283325d394ffe8b8fa3d56bccb015c1" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">この字句解析器は、浮動小数点値を解析します。数値の値を返します。数値は、Haskellレポートで定義されている文法ルールに従って解析されます。</target>
        </trans-unit>
        <trans-unit id="527289d10a300c5f304dffa89904edeb2b163f3d" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、正当な識別子を解析します。識別子文字列を返します。このパーサーは、予約語である識別子では失敗します。法的識別子（開始）文字と予約語は、 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; に渡される &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;identifier&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="163be1f77c7bb2337562a94b4777b7e5c72dc90c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、正当な識別子を解析します。識別子文字列を返します。このパーサーは、予約語である識別子では失敗します。法的識別子（開始）文字と予約語は、 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; に渡される &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;identifier&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bd0992deca5f231a8e4bc4885419bb1a6bfcba7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、合法的な演算子を解析します。演算子の名前を返します。このパーサーは、予約済みの演算子である場合は失敗します。 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 演算子（開始）文字と予約済み演算子は、makeTokenParserに渡される &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;operator&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76e90133adb94e7c3876b0dc934a4c349e00e9fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この語彙素パーサーは、合法的な演算子を解析します。演算子の名前を返します。このパーサーは、予約済みの演算子である場合は失敗します。 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 演算子（開始）文字と予約済み演算子は、makeTokenParserに渡される &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; で定義されます。 &lt;code&gt;operator&lt;/code&gt; 使用して単一のトークンとして扱われる &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4009cc9448509a74e6a8d7bad513db7193f58fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">この字句解析器は、リテラル文字列を解析します。リテラル文字列の値を返します。このパーサはエスケープシーケンスやギャップを正しく処理します。リテラル文字列は、Haskellレポートで定義されている文法規則に従って解析されます(ほとんどのプログラミング言語と非常に密接に一致しています)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
