<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="a7fc1755b99d460ddf9637e41ae7dfe1a9d17f2f" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHCノート： &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; はGHCで大幅に最適化された実装を持っています。ガベージコレクションされたヒープ内の固定されたメモリを使用するため、 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はメモリを解放するファイナライザを必要としません。使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と関連する機能は強力に優先して推奨され &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; ファイナライザで。</target>
        </trans-unit>
        <trans-unit id="5ae0796132c03a976f52dda473c00aecb4b90673" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHCノート： &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; はGHCで大幅に最適化された実装を持っています。ガベージコレクションされたヒープ内の固定されたメモリを使用するため、 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; はメモリを解放するファイナライザを必要としません。使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; と関連する機能は強力に優先して推奨され &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; ファイナライザで。</target>
        </trans-unit>
        <trans-unit id="24fb1c4b67d287bddf5427dde444bedfc6f05944" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr created with mallocPlainForeignPtr carries no finalizers. It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr. This is useful for ForeignPtrs that will live only inside Haskell (such as those created for packed strings). Attempts to add a finalizer to a ForeignPtr created this way, or to finalize such a pointer, will throw an exception.</source>
          <target state="translated">GHCノート： &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; はGHCで大幅に最適化された実装を持っています。mallocForeignPtrと同様に、ガベージコレクションされたヒープ内の固定されたメモリを使用します。mallocForeignPtrとは異なり、mallocPlainForeignPtrで作成されたForeignPtrはファイナライザーを持ちません。mallocPlainForeignPtrで作成されたForeignPtrにファイナライザを追加することはできません。これは、Haskell内にのみ存在するForeignPtr（パックされた文字列用に作成されたものなど）に役立ちます。この方法で作成されたForeignPtrにファイナライザを追加しようとしたり、そのようなポインタをファイナライズしようとすると、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="d58dcbe271b06625548680cc1dda88780faf7c0e" translate="yes" xml:space="preserve">
          <source>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCでは、代わりに、型変数が明示的にバインドされている場合は&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;、拡張子KindSignaturesを使用して、型変数の種類を直接指定できるようになりました。</target>
        </trans-unit>
        <trans-unit id="c69341d0b595bd8749c9faf56b39f2a229d74154" translate="yes" xml:space="preserve">
          <source>GHC now permits such instances to be derived instead, using the extension &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so one can write</source>
          <target state="translated">GHCは、拡張&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;を使用して、そのようなインスタンスを代わりに派生できるようになりました。</target>
        </trans-unit>
        <trans-unit id="af2ccd36d80a45d87b36d0a6f6c0151c8a23dc7f" translate="yes" xml:space="preserve">
          <source>GHC now supports a new way to coordinate the activities of Concurrent Haskell threads, called Software Transactional Memory (STM). The &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM papers&lt;/a&gt; are an excellent introduction to what STM is, and how to use it.</source>
          <target state="translated">GHCは、ソフトウェアトランザクションメモリ（STM）と呼ばれる、同時Haskellスレッドのアクティビティを調整する新しい方法をサポートするようになりました。&lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STMの論文は&lt;/a&gt;優れたSTMが何であるかを紹介し、その使用方法です。</target>
        </trans-unit>
        <trans-unit id="64f783c1668ce53c92c18c3d1d3894883677132f" translate="yes" xml:space="preserve">
          <source>GHC offers a helping hand here, doing all of this for you. For every use of &lt;code&gt;assert&lt;/code&gt; in the user&amp;rsquo;s source:</source>
          <target state="translated">GHCはここで支援を提供し、これらすべてをあなたのために行います。ユーザーのソースでの &lt;code&gt;assert&lt;/code&gt; のすべての使用について：</target>
        </trans-unit>
        <trans-unit id="fcb7a200658d0d266c01f6180b030b6fa3a1603b" translate="yes" xml:space="preserve">
          <source>GHC only knows about packages that are &lt;em&gt;installed&lt;/em&gt;. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt;.</source>
          <target state="translated">GHCは&lt;em&gt;インストールされ&lt;/em&gt;ているパッケージのみを認識します。インストールされたパッケージは、パッケージデータベースにあります。パッケージデータベースの詳細と、GHCに表示されるパッケージデータベースまたは特定のパッケージセットを制御する方法については、「&lt;a href=&quot;#package-databases&quot;&gt;パッケージデータベース&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="044a66191238583d5e4cb81ccc743141923ed216" translate="yes" xml:space="preserve">
          <source>GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit &lt;code&gt;forall&lt;/code&gt;, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</source>
          <target state="translated">GHCは、次のように暗黙の定量化を実行します。ユーザー作成型の最も外側のレベル（のみ）で、明示的な &lt;code&gt;forall&lt;/code&gt; がない場合に限り、GHCはまだスコープ内にない型で言及されているすべての型変数を見つけ、それらを普遍的に定量化します。たとえば、次のペアは同等です。</target>
        </trans-unit>
        <trans-unit id="e903f8397c8f5bbb60d7d8d13ff6bba05d63b1b1" translate="yes" xml:space="preserve">
          <source>GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt;, one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</source>
          <target state="translated">GHCは、 &lt;code&gt;ExplicitForAll&lt;/code&gt; および &lt;code&gt;PolyKinds&lt;/code&gt; 言語拡張が有効になっている場合に限り、この構文で種類を書き込むことを許可します。目に見えない &lt;code&gt;forall&lt;/code&gt; と同様に、視覚的にバインドされた種類変数に明示的な種類の署名を付けることができるため、構文的には次のようになります。</target>
        </trans-unit>
        <trans-unit id="d06dacacd81451db2de5b66239661a3e25c08242" translate="yes" xml:space="preserve">
          <source>GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</source>
          <target state="translated">GHCが起動されるたびに依存関係を再計算するので、依存関係がソースと同期しなくなることはありません。</target>
        </trans-unit>
        <trans-unit id="176ba65a9c9ed02539731d0438e0a1ebfea8e580" translate="yes" xml:space="preserve">
          <source>GHC relaxes this rule in two ways:</source>
          <target state="translated">GHCはこのルールを2つの方法で緩和しています。</target>
        </trans-unit>
        <trans-unit id="12676104a819fe3298a0f123f390ea42a18a068d" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHCはエラーを報告し、aの種類は &lt;code&gt;Type&lt;/code&gt; ではなく種類変数 &lt;code&gt;k&lt;/code&gt; で &lt;code&gt;a&lt;/code&gt; 必要があると述べています。これは、 &lt;code&gt;forall a. Proxy a&lt;/code&gt; 型シグネチャを調べることによります。プロキシa、GHCは &lt;code&gt;a&lt;/code&gt; の種類を一般化する必要があると想定し、 &lt;code&gt;Type&lt;/code&gt; に限定されません。関数定義は、型シグネチャよりも具体的であるために拒否されます。</target>
        </trans-unit>
        <trans-unit id="5c1031c0bc27b3b9bb273d87c196ba3e6cd2a9cd" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHCはエラーを報告し、aの種類は &lt;code&gt;Type&lt;/code&gt; ではなく種類変数 &lt;code&gt;k&lt;/code&gt; で &lt;code&gt;a&lt;/code&gt; 必要があると述べています。これは、 &lt;code&gt;forall a. Proxy a&lt;/code&gt; のタイプシグネチャを確認することにより、プロキシa、GHCは &lt;code&gt;a&lt;/code&gt; &lt;code&gt;Type&lt;/code&gt; 限定されるのではなく、の種類を一般化する必要があると想定しています。関数定義は、その型シグネチャよりも具体的であるために拒否されます。</target>
        </trans-unit>
        <trans-unit id="3372876691ddf4da952bbb863dd592b0bdfda843" translate="yes" xml:space="preserve">
          <source>GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</source>
          <target state="translated">GHCは、スタンドアロン型の署名がある場合、データ宣言はすべての入力をバインドしなければならないことを要求します。例えば</target>
        </trans-unit>
        <trans-unit id="8ce6db855a940e9d5cc1b17135bac5edb333da21" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHCでは、&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;相互再帰モジュールのコンパイル方法で&lt;/a&gt;説明されているように、相互再帰モジュール間の再帰ループを切断するために &lt;code&gt;hs-boot&lt;/code&gt; ファイルを使用する必要があります。これはバグというよりは不便さです。HaskellReportによると（&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4c0df0543846c60d8bf0811b701c64203f4bb433" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;https://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHCでは、相互再帰モジュール&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;をコンパイルする方法で&lt;/a&gt;説明されているように、 &lt;code&gt;hs-boot&lt;/code&gt; ファイルを使用して相互再帰モジュール間の再帰ループをカットする必要があります。これはバグというよりも不利益です：Haskellレポートによると（&lt;a href=&quot;https://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;セクション5.7&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="879d61f80d5636605c655dddfca637fdc98e1ecb" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHCは &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; の制約を3つのステップで解決します。</target>
        </trans-unit>
        <trans-unit id="d6ca94a0a11ffefc0bfeb9a72c46f7879523913b" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC は3つのステップで &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; の制約を解決します：</target>
        </trans-unit>
        <trans-unit id="0af504294df234353ca10b5e8500115149162959" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;HasCallStack&lt;/code&gt; constraints in two steps:</source>
          <target state="translated">GHCは &lt;code&gt;HasCallStack&lt;/code&gt; の制約を2つのステップで解決します。</target>
        </trans-unit>
        <trans-unit id="5fb168dd0c0c05efa3e7b65980a111be49e483f6" translate="yes" xml:space="preserve">
          <source>GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</source>
          <target state="translated">GHCはタイプされた穴に有効な穴のフィットを提案することがありますが、これはいくつかのフラグで設定できます。</target>
        </trans-unit>
        <trans-unit id="bbd754859d95122a24081dbae7deca815e9a4eb6" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;kind-indexed&lt;/em&gt; type families, where the family matches both on the kind and type. GHC will &lt;em&gt;not&lt;/em&gt; infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</source>
          <target state="translated">GHCは、種類とタイプの両方が一致する&lt;em&gt;種類のインデックスが付けられた&lt;/em&gt;タイプファミリーをサポートし&lt;em&gt;ます&lt;/em&gt;。ユーザー提供の完全な種類シグネチャが&lt;em&gt;ない場合、&lt;/em&gt; GHCはこの動作を推論し&lt;em&gt;ません。&lt;/em&gt;これにより、非プリンシパルタイプが推論される場合があるためです。確かに、種類のインデックス付けは、ポリモーフィックな再帰の形式と見なすことができます。その場合、型は、その定義で最も一般的な種類以外の種類で使用されます。</target>
        </trans-unit>
        <trans-unit id="5c3dfb75078d385b6ef1bb4183e0a2d7abc030a2" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;lexically scoped type variables&lt;/em&gt;, without which some type signatures are simply impossible to write. For example:</source>
          <target state="translated">GHCは&lt;em&gt;レキシカルスコープの型変数を&lt;/em&gt;サポートします。これがないと、一部の型シグネチャを書き込むだけでは不可能です。例えば：</target>
        </trans-unit>
        <trans-unit id="276796f5e524e49d992d91729272ac0e608e0dda" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded labels&lt;/em&gt;, a form of identifier whose interpretation may depend both on its type and on its literal text. When the &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; extension is enabled, an overloaded label can be written with a prefix hash, for example &lt;code&gt;#foo&lt;/code&gt;. The type of this expression is &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHCは、&lt;em&gt;オーバーロードされたラベルを&lt;/em&gt;サポートしています。これは、解釈がそのタイプとそのリテラルテキストの両方に依存する可能性がある識別子の形式です。&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;拡張機能が有効になっている場合、オーバーロードされたラベルは、 &lt;code&gt;#foo&lt;/code&gt; などのプレフィックスハッシュで書き込むことができます。この式のタイプは &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6df65e180903b70882d6d577b9e27d68c01ffd47" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded string literals&lt;/em&gt;. Normally a string literal has type &lt;code&gt;String&lt;/code&gt;, but with overloaded string literals enabled (with &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;) a string literal has type &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHCは&lt;em&gt;オーバーロードされた文字列リテラルを&lt;/em&gt;サポートし&lt;em&gt;ます&lt;/em&gt;。通常、文字列リテラルの型は &lt;code&gt;String&lt;/code&gt; ですが、オーバーロードされた文字列リテラルが有効になっている場合（&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; を使用&lt;/a&gt;）、文字列リテラルの型は &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2ef938ede98487b50d238f507d6fb11faed2c901" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloading of the list notation&lt;/em&gt;. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</source>
          <target state="translated">GHCは&lt;em&gt;リスト表記の多重定義を&lt;/em&gt;サポートしています。リストを作成するための表記を要約してみましょう。Haskellでは、リスト表記は次の7つの方法で使用できます。</target>
        </trans-unit>
        <trans-unit id="a03b404046146b764985d1282deeeddd9a94f050" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHCはデフォルトでConcurrent Haskellをサポートし、特別なオプションや特定の方法でコンパイルされたライブラリーを必要としません。Concurrent Haskellのサポートライブラリにアクセスするには、&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrentを&lt;/a&gt;インポートします。Concurrent Haskellの詳細は、そのモジュールのドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="88817a222e891093a054f7b9fd3592132552247b" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHCは、特別なオプションや特定の方法でコンパイルされたライブラリを必要とせずに、デフォルトでConcurrentHaskellをサポートします。 Concurrent Haskellのサポートライブラリにアクセスするには、&lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrentを&lt;/a&gt;インポートするだけです。 Concurrent Haskellの詳細については、そのモジュールのドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="db233c713810924b12363f8cfb5853ea8a7625d7" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHCは、特別なオプションや特定の方法でコンパイルされたライブラリを必要とせずに、デフォルトでConcurrentHaskellをサポートします。Concurrent Haskellのサポートライブラリにアクセスするには、&lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrentを&lt;/a&gt;インポートするだけです。Concurrent Haskellの詳細については、そのモジュールのドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="87e3cb78467ec8b2b366442091554c58737c171b" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHCは、 &lt;code&gt;!pat&lt;/code&gt; と書かれた&lt;em&gt;bangパターン&lt;/em&gt;と呼ばれるパターンマッチングの拡張をサポートしています。ハスケルプライムでは、バングパターンが検討されています。&lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskellのプライム機能の説明は&lt;/a&gt;以下の材料よりもより多くの議論と例が含まれています。</target>
        </trans-unit>
        <trans-unit id="5ee03e17c3bd4438a62f164c9dbdcc503c5b001f" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHCは、 &lt;code&gt;!pat&lt;/code&gt; と書かれた&lt;em&gt;bangパターン&lt;/em&gt;と呼ばれるパターンマッチングの拡張をサポートします。HaskellPrimeではバンパターンが検討されています。&lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/BangPatterns&quot;&gt;Haskellのプライム機能の説明は&lt;/a&gt;以下の材料よりもより多くの議論と例が含まれています。</target>
        </trans-unit>
        <trans-unit id="1059d9fa9d503ddf0254f07f1659e4736d333d97" translate="yes" xml:space="preserve">
          <source>GHC supports arrays of unboxed elements, for several basic arithmetic element types including &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;: see the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; library for details. These arrays are likely to be much faster than using standard Haskell 98 arrays from the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; library.</source>
          <target state="translated">GHCは、 &lt;code&gt;Int&lt;/code&gt; や &lt;code&gt;Char&lt;/code&gt; を含むいくつかの基本的な算術要素タイプのボックス化されていない要素の配列をサポートします。詳細については、&lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt;ライブラリを参照してください。これらの配列は、&lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt;ライブラリの標準のHaskell 98配列を使用するよりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="3948db87d05dfc40c1f63f054a27ea693124c87e" translate="yes" xml:space="preserve">
          <source>GHC supports both concurrency and parallelism.</source>
          <target state="translated">GHCは並行性と並列性の両方をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a13a7734a043f66e1714f2fd0d2b999f5bd2929a" translate="yes" xml:space="preserve">
          <source>GHC supports multiple backend code generators. This is the part of the compiler responsible for taking the last intermediate representation that GHC uses (a form called Cmm that is a simple, C like language) and compiling it to executable code. The backends that GHC support are described below.</source>
          <target state="translated">GHCは複数のバックエンドコードジェネレータをサポートしています。これは、GHCが使用する最後の中間表現(Cmmと呼ばれる形式で、C言語のようなシンプルな言語です)を取り、実行可能なコードにコンパイルする役割を担うコンパイラの部分です。GHCがサポートしているバックエンドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="30f8743edba346dec74c124074534d3915ad7f3b" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHCは、型レベルで数値および文字列リテラルをサポートし、事前定義された多数の型レベル定数への便利なアクセスを提供します。数値リテラルの種類は &lt;code&gt;Nat&lt;/code&gt; で、文字列リテラルの種類は &lt;code&gt;Symbol&lt;/code&gt; です。この機能は、&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;言語拡張機能によって有効になります。</target>
        </trans-unit>
        <trans-unit id="460bfe239b04444ab072464eae0903da8dac0035" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;data_kinds#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHCは、型レベルで数値リテラルと文字列リテラルをサポートしているため、事前定義された多数の型レベル定数に簡単にアクセスできます。数値リテラルは &lt;code&gt;Nat&lt;/code&gt; の種類であり、文字列リテラルは &lt;code&gt;Symbol&lt;/code&gt; の種類です。この機能は、&lt;a href=&quot;data_kinds#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;言語拡張によって有効になります。</target>
        </trans-unit>
        <trans-unit id="939d5d87113e9124e05b09bd482088142e25e21b" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;exts#ghc-language-features&quot;&gt;Language extensions&lt;/a&gt;.</source>
          <target state="translated">GHCは、同時実行性、外部関数インターフェイス、例外、マルチパラメーター型クラスなどの型システム拡張、ローカルのユニバーサルおよび存在記号、関数従属性、スコープ付き型変数、明示的なボックス化されていない型など、多数の言語拡張をサポートします。これらはすべて&lt;a href=&quot;exts#ghc-language-features&quot;&gt;言語拡張で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="6c771ee603c6b7794f2ea84ef821582ce945de09" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC Language Features&lt;/a&gt;.</source>
          <target state="translated">GHCは、同時実行性、外部関数インターフェース、例外、マルチパラメーター型クラスなどの型システム拡張、ローカルユニバーサルおよび実存数量化、関数依存関係、スコープ型変数、明示的なボックス化されていない型など、多数の言語拡張をサポートしています。これらはすべて&lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC言語機能で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="7dfeb95a50670f1d64eaee09cc2e384aca52156c" translate="yes" xml:space="preserve">
          <source>GHC supports running Haskell programs in parallel on an SMP (symmetric multiprocessor).</source>
          <target state="translated">GHCはHaskellプログラムのSMP(対称型マルチプロセッサ)上での並列実行をサポートしています。</target>
        </trans-unit>
        <trans-unit id="a087224f52d11f82f5a88e556729ad1748a912eb" translate="yes" xml:space="preserve">
          <source>GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don&amp;rsquo;t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</source>
          <target state="translated">GHCは、いくつかのプラグマ、またはソースコードに配置されたコンパイラーへの命令をサポートします。プラグマは通常、プログラムの意味には影響しませんが、生成されたコードの効率に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="64c6177d894ac3ebf6c13eb6a39c9b7bbe9fb3b9" translate="yes" xml:space="preserve">
          <source>GHC supports the compilation of mutually recursive modules. This section explains how.</source>
          <target state="translated">GHCは相互に再帰的なモジュールのコンパイルをサポートしています。ここではその方法を説明します。</target>
        </trans-unit>
        <trans-unit id="2f567fb737ad360d88ce9083ecb2968678a51e95" translate="yes" xml:space="preserve">
          <source>GHC supports these language extensions:</source>
          <target state="translated">GHCはこれらの言語拡張をサポートしています。</target>
        </trans-unit>
        <trans-unit id="b94800f31025b5e612b01265b145926a94da2a20" translate="yes" xml:space="preserve">
          <source>GHC supports these language options:</source>
          <target state="translated">GHCはこれらの言語オプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="376872360d159bedd1e4e2c8ef10c95b85bee963" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHCは、型パラメーターの3つの異なる役割（名義、表現、およびファントム）をサポートします。型パラメーターが名目上の役割を持っている場合、異なる2つの型は実際にはまったく異なっていてはなりません。それらは同じである必要があります（型ファミリーの削減後）。型パラメーターに表現の役割がある場合、2つの型の表現は同じでなければなりません。 （ &lt;code&gt;T&lt;/code&gt; の最初のパラメーターの役割が表現である場合、 &lt;code&gt;T Age Bool c&lt;/code&gt; と &lt;code&gt;T Int Bool c&lt;/code&gt; は同じ表現になります。これは、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; が同じ表現であるためです。）型パラメーターにファントムの役割がある場合、必要はありません。さらに詳しい情報。</target>
        </trans-unit>
        <trans-unit id="739585d733fbd90b635381ce1f62b05fe70f7220" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHCは、タイプパラメータに対して、名義、表現、およびファントムの3つの異なる役割をサポートします。型族パラメーターが名目上の役割を持っている場合、異なる2つの型は、実際にはまったく異なってはなりません。それらは同一である必要があります（型族の削減後）。タイプパラメータに表現の役割がある場合、2つのタイプは同じ表現である必要があります。 （ &lt;code&gt;T&lt;/code&gt; の最初のパラメーターの役割が表現型の場合、 &lt;code&gt;Age&lt;/code&gt; と &lt;code&gt;Int&lt;/code&gt; の表現は同じであるため、 &lt;code&gt;T Age Bool c&lt;/code&gt; と &lt;code&gt;T Int Bool c&lt;/code&gt; 表現は同じになります。）型パラメーターの役割がファントムの場合、必要ありません。さらに詳しい情報。</target>
        </trans-unit>
        <trans-unit id="f0d48f22ae2a3222802a96b3a539281e8893f263" translate="yes" xml:space="preserve">
          <source>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</source>
          <target state="translated">GHCは保守的な立場をとります:最初の2つは受け入れますが、3つ目は受け入れません。ルールは次のとおりです:推論されたインスタンスコンテキスト内の各制約は、型変数のみで構成され、繰り返しはありません。</target>
        </trans-unit>
        <trans-unit id="af1345dfc47c5e1308fe80cc43e2e8fda6407651" translate="yes" xml:space="preserve">
          <source>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</source>
          <target state="translated">次にGHCは、これらのセットのそれぞれを使用してパターンカバレッジをチェックします。これらのセットのいずれかが警告なしでパターン・カバレッジ・チェッカーを通過した場合は、これで終了です。各セットが少なくとも1つの警告を生成する場合、GHCは結果の良し悪しに応じて警告のセットのうちの1つを選択しなければなりません。結果はこの順番で優先順位が付けられます。</target>
        </trans-unit>
        <trans-unit id="4f506a7b6cf4858f54fbbea3adb5c9aafc2629c4" translate="yes" xml:space="preserve">
          <source>GHC tracks a distinction between what we call &lt;em&gt;inferred&lt;/em&gt; and &lt;em&gt;specified&lt;/em&gt; type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</source>
          <target state="translated">GHCは、&lt;em&gt;推論&lt;/em&gt;&lt;em&gt;された&lt;/em&gt;型変数と&lt;em&gt;指定された&lt;/em&gt;型変数との違いを追跡します。指定された型変数のみが、可視型アプリケーションでのインスタンス化に使用できます。例はこれをよく示しています：</target>
        </trans-unit>
        <trans-unit id="b0056c6884fc97fc67e74fdba9e10f40ad69bfb2" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general &lt;a href=&quot;#generic-programming&quot;&gt;support for generic programming&lt;/a&gt;.</source>
          <target state="translated">GHCは、「派生型クラス」のペーパー、ラルフヒンズとサイモンペイトンジョーンズ、Haskell Workshop、モントリオール9月2000、pp。94-105で定義されたジェネリッククラスの実装を使用していました。これらは削除され、&lt;a href=&quot;#generic-programming&quot;&gt;汎用プログラミングの&lt;/a&gt;より一般的なサポートに置き換えられました。</target>
        </trans-unit>
        <trans-unit id="627722a7e95d92b125557fdd357037ba973fedc5" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general support for generic programming.</source>
          <target state="translated">GHCは、論文「Derivable type classes」、RalfHinzeおよびSimonPeyton Jones、Haskell Workshop、モントリオール2000年9月、94〜105ページで定義されているジェネリッククラスの実装を持っていました。これらは削除され、ジェネリックプログラミングのより一般的なサポートに置き換えられました。</target>
        </trans-unit>
        <trans-unit id="6146a11d5bcfee2fd36a56319860854e84371c0e" translate="yes" xml:space="preserve">
          <source>GHC uses a copying garbage collector by default. &amp;ldquo;bytes copied during GC&amp;rdquo; tells you how many bytes it had to copy during garbage collection.</source>
          <target state="translated">GHCはデフォルトでコピーガベージコレクターを使用します。「GC中にコピーされたバイト数」は、ガベージコレクション中にコピーする必要があったバイト数を示します。</target>
        </trans-unit>
        <trans-unit id="b767adcd6d48a9a1db03ff8580662a14fddf6ff9" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHCは&lt;a href=&quot;#instance-termination&quot;&gt;パターソン条件&lt;/a&gt;を使用して、インスタンス解決が確実に終了するようにします。これらのルールは定量化された制約に対してどのように変更されますか？2つの方法で。</target>
        </trans-unit>
        <trans-unit id="2cee95ed1e9454c90ee163ac39effcbe97abffa1" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;instances#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHCは、&lt;a href=&quot;instances#instance-termination&quot;&gt;Paterson条件&lt;/a&gt;を使用して、インスタンスの解決が確実に終了するようにします。これらのルールは、定量化された制約に対してどのように変更されますか？2つの方法で。</target>
        </trans-unit>
        <trans-unit id="edb26ddbc1a23bed4068def6c81bd9036a5beb4d" translate="yes" xml:space="preserve">
          <source>GHC uses the function arrows in a &lt;code&gt;prefix_gadt_body&lt;/code&gt; and &lt;code&gt;prefix_gadt_body&lt;/code&gt; to syntactically demarcate the function and result types. Note that GHC does not attempt to be clever about looking through type synonyms here. If you attempt to do this, for instance:</source>
          <target state="translated">GHCは、 &lt;code&gt;prefix_gadt_body&lt;/code&gt; および &lt;code&gt;prefix_gadt_body&lt;/code&gt; の関数矢印を使用して、関数と結果のタイプを構文的に区別します。GHCは、ここで型の同義語を調べることについて賢くしようとはしないことに注意してください。これを行おうとすると、たとえば次のようになります。</target>
        </trans-unit>
        <trans-unit id="ca01e41132644bdb3e286bc222d38e9f775ccd4e" translate="yes" xml:space="preserve">
          <source>GHC versions before 8.8 defined undocumented functions &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; instead of &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;. Those names are now deprecated.</source>
          <target state="translated">GHCのバージョン8.8定義され文書化されていない関数の前 &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; と &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; の代わりに、 &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; と &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; 。これらの名前は廃止されました。</target>
        </trans-unit>
        <trans-unit id="5b319fddc0f25cd65725db96966305001e0c7f9c" translate="yes" xml:space="preserve">
          <source>GHC will accept &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt;&amp;lsquo;s type signatures. Note that:</source>
          <target state="translated">GHCは、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; 、および &lt;code&gt;k&lt;/code&gt; のタイプ署名を受け入れます。ご了承ください：</target>
        </trans-unit>
        <trans-unit id="cacf2f89c573ae5cc451246033c76335e76b2795" translate="yes" xml:space="preserve">
          <source>GHC will accept any combination of &lt;code&gt;!&lt;/code&gt;/&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;{-# UNPACK #-}&lt;/code&gt;/&lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt;, although GHC will ignore some combinations. For example, GHC will produce a warning if you write &lt;code&gt;{-# UNPACK #-} ~Int&lt;/code&gt; and proceed as if you had written &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">GHCは &lt;code&gt;!&lt;/code&gt; の任意の組み合わせを受け入れます。/ &lt;code&gt;~&lt;/code&gt; および &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; / &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; 、ただしGHCはいくつかの組み合わせを無視します。たとえば、 &lt;code&gt;{-# UNPACK #-} ~Int&lt;/code&gt; と記述して、 &lt;code&gt;Int&lt;/code&gt; と記述したかのように続行すると、GHCは警告を生成します。</target>
        </trans-unit>
        <trans-unit id="60b8a79c38bec7cc0926fc1ac31c53e115e9aa07" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all exported functions not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHCは、INLINEとマークされていないすべてのエクスポートされた関数に &lt;code&gt;SCC&lt;/code&gt; アノテーションを自動的に追加します。INLINE関数のコストセンターが必要な場合は、手動で追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="e90ca342877325f438cbed76b283486d9d43d4bf" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all top-level bindings not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHCはINLINEとマークされていないすべてのトップレベルのバインディングに &lt;code&gt;SCC&lt;/code&gt; アノテーションを自動的に追加します。INLINE関数のコストセンターが必要な場合は、手動で追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b91bde5a658ad123b14fffc8376301c68f7acc1" translate="yes" xml:space="preserve">
          <source>GHC will complain about this, because you might later add</source>
          <target state="translated">GHCは後から追加するかもしれないので、文句を言うでしょう。</target>
        </trans-unit>
        <trans-unit id="888ad4028beff57dc284f4b0b4cb77697614c65e" translate="yes" xml:space="preserve">
          <source>GHC will generate an instance that is equivalent to</source>
          <target state="translated">と同等のインスタンスを生成します。</target>
        </trans-unit>
        <trans-unit id="fd5d18e4a6d13e92f35cab7d827b6e1c50ef7f4c" translate="yes" xml:space="preserve">
          <source>GHC will rewrite this to also include the source location where the assertion was made,</source>
          <target state="translated">GHCはこれを書き換えて、アサーションが行われたソースの場所も含めるようにします。</target>
        </trans-unit>
        <trans-unit id="3b8666db2e1c25642043eb4c9311786ee0fbf20e" translate="yes" xml:space="preserve">
          <source>GHC will successfully compile this module with &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt;, because the default export list will include &lt;code&gt;program&lt;/code&gt; rather than &lt;code&gt;main&lt;/code&gt;, as the Haskell Report typically requires.</source>
          <target state="translated">Haskell Reportが通常必要とするように、デフォルトのエクスポートリストには &lt;code&gt;main&lt;/code&gt; ではなく &lt;code&gt;program&lt;/code&gt; が含まれるため、GHCは &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt; でこのモジュールを正常にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="71826e517742bea19038f247c0110ae19fac4e07" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s &lt;code&gt;-main-is&lt;/code&gt; option can be used to change the name of the top-level entry point from &lt;code&gt;main&lt;/code&gt; to any other variable. When compiling the main module and &lt;code&gt;-main-is&lt;/code&gt; has been used to rename the default entry point, GHC will also use the alternate name in the default export list.</source>
          <target state="translated">GHCの &lt;code&gt;-main-is&lt;/code&gt; オプションを使用すると、トップレベルのエントリポイントの名前を &lt;code&gt;main&lt;/code&gt; から他の変数に変更できます。メインモジュールをコンパイルし、 &lt;code&gt;-main-is&lt;/code&gt; を使用してデフォルトのエントリポイントの名前を変更した場合、GHCはデフォルトのエクスポートリストの代替名も使用します。</target>
        </trans-unit>
        <trans-unit id="b7940b1f55c055977ec4b26434a6019b2252f161" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</source>
          <target state="translated">GHCの動作はオプションによって制御されます。これは、歴史的な理由から、コマンドラインフラグまたは引数と呼ばれることもあります。オプションは次の3つの方法で指定できます。</target>
        </trans-unit>
        <trans-unit id="8e4a533f14309a808a844f31df8d6cfa4f088440" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</source>
          <target state="translated">GHCの動作は、まずモードフラグによって制御されます。これらのフラグの1つだけを指定できますが、必ずしもコマンドラインの最初のオプションである必要はありません。例えば、</target>
        </trans-unit>
        <trans-unit id="bf906368ac038f94bf26ce6b52010381e9b9d4b3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s compiled output normally goes into a &lt;code&gt;.hc&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, etc., file, depending on the last-run compilation phase. The option &lt;code&gt;-o file&lt;/code&gt; re-directs the output of that last-run phase to ⟨file⟩.</source>
          <target state="translated">GHCのコンパイルされた出力は、最後に実行されたコンパイルフェーズに応じて、通常は &lt;code&gt;.hc&lt;/code&gt; 、 &lt;code&gt;.o&lt;/code&gt; などのファイルに入ります。オプション &lt;code&gt;-o file&lt;/code&gt; は、最後に実行されたフェーズの出力を「ファイル」にリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="4eaf5334b602d1dc2d125684f67fbc356d5c1cda" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s default behaviour is that &lt;em&gt;exactly one instance must match the constraint it is trying to resolve&lt;/em&gt;. For example, the constraint &lt;code&gt;C Int Bool&lt;/code&gt; matches instances (A) and (B), and hence would be rejected; while &lt;code&gt;C Int Char&lt;/code&gt; matches only (A) and hence (A) is chosen.</source>
          <target state="translated">GHCのデフォルトの動作では、&lt;em&gt;解決しようとしている制約と1つのインスタンスが一致する必要があります&lt;/em&gt;。たとえば、制約 &lt;code&gt;C Int Bool&lt;/code&gt; はインスタンス（A）および（B）に一致するため、拒否されます。一方、 &lt;code&gt;C Int Char&lt;/code&gt; は（A）のみに一致するため、（A）が選択されます。</target>
        </trans-unit>
        <trans-unit id="c8a2481a78caced9f750c28e9ecbbf9c5b39a8d3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation diverges from the Haskell 98 definition in the sense that Unicode alphabetic characters which are neither upper nor lower case will still be identified as alphabetic by &lt;code&gt;isAlpha&lt;/code&gt;.</source>
          <target state="translated">GHCの実装は、大文字でも小文字でもないUnicodeのアルファベット文字が &lt;code&gt;isAlpha&lt;/code&gt; によってアルファベットとして識別されるという意味で、Haskell 98の定義とは異なります。</target>
        </trans-unit>
        <trans-unit id="0d8ddddf05368a7d9eeb185f0d525cf13f5ca7e5" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of &lt;code&gt;array&lt;/code&gt; takes the value of an array slot from the last (index,value) pair in the list, and does no checking for duplicates. The reason for this is efficiency, pure and simple.</source>
          <target state="translated">GHCの &lt;code&gt;array&lt;/code&gt; の実装は、リストの最後の（インデックス、値）ペアから配列スロットの値を取得し、重複のチェックを行いません。この理由は、効率が高く、純粋でシンプルです。</target>
        </trans-unit>
        <trans-unit id="681323083d71785f12a1d947d44622299b5d2e3b" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of the &lt;code&gt;Read&lt;/code&gt; class for integral types accepts hexadecimal and octal literals (the code in the Haskell 98 report doesn&amp;rsquo;t). So, for example,</source>
          <target state="translated">GHCの整数型の &lt;code&gt;Read&lt;/code&gt; クラスの実装は、16進数と8進数のリテラルを受け入れます（Haskell 98レポートのコードは受け入れません）。したがって、たとえば、</target>
        </trans-unit>
        <trans-unit id="fa910ad711028cf4d2f6aa78f6b468a6abe9cc47" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHCの実装であるmdo表記&lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;は、「Haskellの再帰的な実行」&lt;/a&gt;という論文で説明されている元の翻訳に厳密に従っており&lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;、Monadic ComputationsでのValue Recursionに&lt;/a&gt;基づいています。さらに、次に説明するように、GHCは以前の論文で説明されている構文を、 &lt;code&gt;rec&lt;/code&gt; キーワードでフラグが付けられた下位レベルの構文で拡張します。</target>
        </trans-unit>
        <trans-unit id="fd23acaf9fb3b18e415a0d3277f4326ba07817ca" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;https://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;https://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHCの実装mdo-notationは、論文&lt;a href=&quot;https://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;で説明されているように、元の翻訳に厳密に従います。これは&lt;a href=&quot;https://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;、MonadicComputationsのValueRecursionの&lt;/a&gt;作業に基づいています。さらに、GHCは、次に説明するように、前のペーパーで説明されている構文を、 &lt;code&gt;rec&lt;/code&gt; キーワードでフラグが付けられた低レベルの構文で拡張します。</target>
        </trans-unit>
        <trans-unit id="ed1e2dd4714860c447f66e579db44cd5338ed6ec" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:</source>
          <target state="translated">GHCのインライナーは、データ型を介して再帰をエンコードする標準的な方法を使用して、非終了に説得できます。</target>
        </trans-unit>
        <trans-unit id="1e334d1c16129f459bf78c23f3a1da79aafa9734" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;exts/rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">GHCのオプティマイザーは、終了しない書き換えルール（&lt;a href=&quot;exts/rewrite_rules#rewrite-rules&quot;&gt;書き換えルール&lt;/a&gt;）を記述した場合、またはデータ型を介して再帰をコーディングした場合（&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHCのバグ&lt;/a&gt;）に発散する可能性があります。コンパイラが無限ループに陥るのを防ぐために、オプティマイザは「ティックカウント」を実行し、このカウントを超えると、インライン化と書き換えルールの適用を停止します。制限はプログラムサイズの倍数として設定されているため、プログラムが大きいほどティックが多くなります。 &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; フラグを使用すると、乗数を変更することができます。デフォルトは100です。 100より大きい数値はティックが多く、100より小さい数値はティックが少なくなります。</target>
        </trans-unit>
        <trans-unit id="7270364eb5fb9843c4759fc3f49b280307e959e9" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">GHCのオプティマイザーは、終了しないリライトルール（&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;リライトルール&lt;/a&gt;）を記述した場合、またはデータタイプ（&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHCのバグ&lt;/a&gt;）を介して再帰をコード化した場合（満足度が低い）で分岐する可能性があります。コンパイラーが無限ループに陥らないようにするために、オプティマイザーは「ティックカウント」を保持し、このカウントを超えるとインライン化と書き換えルールの適用を停止します。制限はプログラムサイズの倍数として設定されるため、プログラムが大きくなるほどティックが多くなります。 &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; フラグを使用すると、乗数を変更することができます。デフォルトは100です。 100より大きい数はより多くのティックを与え、100より小さい数はより少ないティックを与えます。</target>
        </trans-unit>
        <trans-unit id="3978a882c19969786036cd225ec74df6cbf83e05" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s parallelism support has improved in 6.12.1 as a result of much experimentation and tuning in the runtime system. We&amp;rsquo;d still be interested to hear how well it works for you, and we&amp;rsquo;re also interested in collecting parallel programs to add to our benchmarking suite.</source>
          <target state="translated">ランタイムシステムでの多くの実験とチューニングの結果として、GHCの並列処理サポートは6.12.1で改善されました。それがどのように機能するかについては、引き続き興味があります。また、ベンチマークスイートに追加する並列プログラムを収集することにも興味があります。</target>
        </trans-unit>
        <trans-unit id="11e3bdec967fe5a92f92f545009ebde19c94ff56" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</source>
          <target state="translated">GHCのプロファイリングシステムは、コストセンターにコストを割り当てます。コストは、式を評価するために必要な時間または空間（メモリ）です。コストセンターは、式に関するプログラムの注釈です。注釈付きの式で発生したすべてのコストは、囲んでいるコストセンターに割り当てられます。さらに、GHCは実行時に任意の式の囲まれたコストセンターのスタックを記憶し、コスト属性の呼び出しツリーを生成します。</target>
        </trans-unit>
        <trans-unit id="c44af933474ed5e269dd484ced236e4d2057d778" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system supports &amp;ldquo;cost centre stacks&amp;rdquo;: a way of seeing the profile of a Haskell program in a call-graph like structure. See &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; for more details.</source>
          <target state="translated">GHCのプロファイリングシステムは、「コストセンタースタック」をサポートしています。これは、Haskellプログラムのプロファイルをコールグラフのような構造で表示する方法です。詳細については、&lt;a href=&quot;profiling#profiling&quot;&gt;プロファイリング&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8705e16011627590f47ff878b246c3728533b3b6" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system has built-in support for collecting stack trace information from a running Haskell program. This currently requires that the &lt;code&gt;libdw&lt;/code&gt; library from the &lt;code&gt;elfutils&lt;/code&gt; package is available. Of course, the backtrace will be of little use unless debug information is available in the executable and its dependent libraries.</source>
          <target state="translated">GHCのランタイムシステムには、実行中のHaskellプログラムからスタックトレース情報を収集するためのサポートが組み込まれています。現在、これには &lt;code&gt;elfutils&lt;/code&gt; パッケージの &lt;code&gt;libdw&lt;/code&gt; ライブラリが利用可能である必要があります。もちろん、実行可能ファイルとその依存ライブラリでデバッグ情報が利用できない限り、バックトレースはほとんど役に立ちません。</target>
        </trans-unit>
        <trans-unit id="34ecd7773e52e6b1108977b176ca3c2b9e8f2456" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHCのランタイムシステムは協調マルチタスクを実装し、プログラムが割り当てたときにのみコンテキスト切り替えが発生する可能性があります。これは、割り当てないプログラムがコンテキストスイッチを行わない可能性があることを意味します。これは、一貫性のない状態を観察した後にデッドロックする可能性があるSTMを使用するプログラムに特に当てはまります。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;＃367&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="edf33651c39771e5da51f29e8aae689306e3130d" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Issue #367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHCのランタイムシステムは、協調的なマルチタスクを実装し、コンテキストの切り替えはプログラムが割り当てられたときにのみ発生する可能性があります。つまり、割り当てを行わないプログラムでは、コンテキストが切り替わらない場合があります。これは特に、STMを使用するプログラムに当てはまります。STMを使用すると、不整合な状態を観察した後にデッドロックが発生する可能性があります。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;問題＃367&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="495b902a4d269ea40b19611761afea825c104875" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s type system supports &lt;em&gt;arbitrary-rank&lt;/em&gt; explicit universal quantification in types. For example, all the following types are legal:</source>
          <target state="translated">GHCの型システムは、型の&lt;em&gt;任意ランクの&lt;/em&gt;明示的普遍的数量化をサポートしています。たとえば、次のタイプはすべて有効です。</target>
        </trans-unit>
        <trans-unit id="82fd95c3a56752e08f77eb38c5bdbdcb6be4a696" translate="yes" xml:space="preserve">
          <source>GHC's &lt;code&gt;DataKinds&lt;/code&gt; language extension lifts data constructors, natural numbers, and strings to the type level. This module provides the primitives needed for working with type-level numbers (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Nat&quot;&gt;Nat&lt;/a&gt;&lt;/code&gt; kind) and strings (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Symbol&quot;&gt;Symbol&lt;/a&gt;&lt;/code&gt;) kind. It also defines the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:TypeError&quot;&gt;TypeError&lt;/a&gt;&lt;/code&gt; type family, a feature that makes use of type-level strings to support user defined type errors.</source>
          <target state="translated">GHCの &lt;code&gt;DataKinds&lt;/code&gt; 言語拡張機能は、データコンストラクター、自然数、および文字列を型レベルに引き上げます。このモジュールは、タイプレベルの数値（ &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Nat&quot;&gt;Nat&lt;/a&gt;&lt;/code&gt; の種類）と文字列（ &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Symbol&quot;&gt;Symbol&lt;/a&gt;&lt;/code&gt; ）の種類を操作するために必要なプリミティブを提供します。また、タイプレベルの文字列を利用してユーザー定義のタイプエラーをサポートする機能である &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:TypeError&quot;&gt;TypeError&lt;/a&gt;&lt;/code&gt; タイプファミリーも定義します。</target>
        </trans-unit>
        <trans-unit id="364440218c4abb707fa15b5beedbc3d1c2676890" translate="yes" xml:space="preserve">
          <source>GHC's Ix typeclass implementation.</source>
          <target state="translated">GHCのIx型クラスの実装。</target>
        </trans-unit>
        <trans-unit id="0afa5da65b91efe9b8ba677184df9d9635364492" translate="yes" xml:space="preserve">
          <source>GHC's array implementation.</source>
          <target state="translated">GHCの配列実装。</target>
        </trans-unit>
        <trans-unit id="76da1a73e21244ea0ab9be4c1d1fee4004005654" translate="yes" xml:space="preserve">
          <source>GHC's implementation of concurrency</source>
          <target state="translated">GHC の並行処理の実装</target>
        </trans-unit>
        <trans-unit id="98be7070373a5168f3480205560843e2f04494b4" translate="yes" xml:space="preserve">
          <source>GHC's implementation of the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; data type.</source>
          <target state="translated">GHCに &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; データ型の実装。</target>
        </trans-unit>
        <trans-unit id="768bc13ad5b2e61fd8fe71e1fff8dfdfc664e459" translate="yes" xml:space="preserve">
          <source>GHC, by default, no longer depends on cygwin, but is a native Windows program. It is built using mingw, and it uses mingw&amp;rsquo;s GHC while compiling your Haskell sources (even if you call it from cygwin&amp;rsquo;s bash), but what matters here is that - just like any other normal windows program - neither GHC nor the executables it produces are aware of Cygwin&amp;rsquo;s pretended unix hierarchy. GHC will happily accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\\&lt;/code&gt; as path separators, but it won&amp;rsquo;t know where to find &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; or &lt;code&gt;/bin/bash&lt;/code&gt; or the like. This causes all kinds of fun when GHC is used from within Cygwin&amp;rsquo;s bash, or in make-sessions running under Cygwin.</source>
          <target state="translated">GHCは、デフォルトでは、もはやcygwinに依存していませんが、ネイティブのWindowsプログラムです。これはmingwを使用して構築されており、（cygwinのbashから呼び出した場合でも）Haskellソースのコンパイル中にmingwのGHCを使用しますが、ここで重要なのは、他の通常のWindowsプログラムと同様に、GHCも実行ファイルも生成しないことです。 CygwinのふりをしたUNIX階層を認識しています。 GHCは &lt;code&gt;/&lt;/code&gt; または &lt;code&gt;\\&lt;/code&gt; のいずれかをパス区切り文字として受け入れますが、/ &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; &lt;code&gt;/bin/bash&lt;/code&gt; joe / Main.hsまたは/ bin / bashなどがどこにあるかはわかりません。 Cygwinのbash内から、またはCygwinの下で実行されているmake-sessionでGHCが使用されると、これはあらゆる種類の楽しみを引き起こします。</target>
        </trans-unit>
        <trans-unit id="ff816e0b81227e703ddb0dfa383d3a101ea7d725" translate="yes" xml:space="preserve">
          <source>GHC, since version 8.4, &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread. Making it safe to pass heap-allocated objects to unsafe functions.</source>
          <target state="translated">GHCは、バージョン8.4以降、&lt;strong&gt;保証&lt;/strong&gt;そのガベージコレクションが中に発生することはありません &lt;code&gt;unsafe&lt;/code&gt; ことをしてもバイトコードインタプリタで呼び出し、さらに保証 &lt;code&gt;unsafe&lt;/code&gt; 呼び出しは呼び出し元のスレッドで実行されます。ヒープに割り当てられたオブジェクトを安全でない関数に安全に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6fb0c28210e389deb1f0d69554122e023c56379f" translate="yes" xml:space="preserve">
          <source>GHC.Arr</source>
          <target state="translated">GHC.Arr</target>
        </trans-unit>
        <trans-unit id="da7f85eb75adadb0e3a66f594e581f331c40d7de" translate="yes" xml:space="preserve">
          <source>GHC.Base</source>
          <target state="translated">GHC.Base</target>
        </trans-unit>
        <trans-unit id="44509152f33f388480bcf9fe3d5b92c807be396b" translate="yes" xml:space="preserve">
          <source>GHC.ByteOrder</source>
          <target state="translated">GHC.ByteOrder</target>
        </trans-unit>
        <trans-unit id="f5b98f829355a95c653079b181f31daa126ed048" translate="yes" xml:space="preserve">
          <source>GHC.Char</source>
          <target state="translated">GHC.Char</target>
        </trans-unit>
        <trans-unit id="5e37af3d561ae073b83498872c71cf34be86dde1" translate="yes" xml:space="preserve">
          <source>GHC.Clock</source>
          <target state="translated">GHC.Clock</target>
        </trans-unit>
        <trans-unit id="8ffe6289544c44961284b55760ff10d112e4541c" translate="yes" xml:space="preserve">
          <source>GHC.Conc</source>
          <target state="translated">GHC.Conc</target>
        </trans-unit>
        <trans-unit id="dda0f595676f0ffb55c5548c6bb829dd285e7a06" translate="yes" xml:space="preserve">
          <source>GHC.Conc.IO</source>
          <target state="translated">GHC.Conc.IO</target>
        </trans-unit>
        <trans-unit id="2746731219cdf08f53175830aa9803d04aec4700" translate="yes" xml:space="preserve">
          <source>GHC.Conc.Sync</source>
          <target state="translated">GHC.Conc.Sync</target>
        </trans-unit>
        <trans-unit id="83fb25acb9eec7e0c6a528766737ddb292ac4508" translate="yes" xml:space="preserve">
          <source>GHC.Enum</source>
          <target state="translated">GHC.Enum</target>
        </trans-unit>
        <trans-unit id="9123ccdd7f945599c7fe10322ef603202538a9aa" translate="yes" xml:space="preserve">
          <source>GHC.Environment</source>
          <target state="translated">GHC.Environment</target>
        </trans-unit>
        <trans-unit id="b529524b0f71b0e58a38870afdf56699c7ebc263" translate="yes" xml:space="preserve">
          <source>GHC.Err</source>
          <target state="translated">GHC.Err</target>
        </trans-unit>
        <trans-unit id="8b82280ee98eb05df4a8965fe52566cac340fb84" translate="yes" xml:space="preserve">
          <source>GHC.Event</source>
          <target state="translated">GHC.Event</target>
        </trans-unit>
        <trans-unit id="bfef2613a1eee5e86773b823620ea75105f3fe39" translate="yes" xml:space="preserve">
          <source>GHC.Event.TimeOut</source>
          <target state="translated">GHC.Event.TimeOut</target>
        </trans-unit>
        <trans-unit id="12dc6472d306520b873a5a7a5654adf7b54689d0" translate="yes" xml:space="preserve">
          <source>GHC.Exception</source>
          <target state="translated">GHC.Exception</target>
        </trans-unit>
        <trans-unit id="c96bbd598503766a9fb6318fd8c79f4a71a78f43" translate="yes" xml:space="preserve">
          <source>GHC.Exception.Type</source>
          <target state="translated">GHC.Exception.Type</target>
        </trans-unit>
        <trans-unit id="90ef3784b2d875dcdf89ad8e658a107594b6af29" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack</source>
          <target state="translated">GHC.ExecutionStack</target>
        </trans-unit>
        <trans-unit id="48bff078e8cb052ebe31cac8d746bbc2937065cb" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack.Internal</source>
          <target state="translated">GHC.ExecutionStack.Internal</target>
        </trans-unit>
        <trans-unit id="740178902f8692cff1b10349f3d117b77680a7ca" translate="yes" xml:space="preserve">
          <source>GHC.Exts</source>
          <target state="translated">GHC.Exts</target>
        </trans-unit>
        <trans-unit id="7252e677664eb73a80122c6cd32aed07da4dcc79" translate="yes" xml:space="preserve">
          <source>GHC.Fingerprint</source>
          <target state="translated">GHC.Fingerprint</target>
        </trans-unit>
        <trans-unit id="15c984e784209d339e39d4b4707e5f0cefa9a13a" translate="yes" xml:space="preserve">
          <source>GHC.Float</source>
          <target state="translated">GHC.Float</target>
        </trans-unit>
        <trans-unit id="58b89be8337bef1dda3eb53785a12275cdc95c37" translate="yes" xml:space="preserve">
          <source>GHC.Float.RealFracMethods</source>
          <target state="translated">GHC.Float.RealFracMethods</target>
        </trans-unit>
        <trans-unit id="d587f40187b4db2d663256a48f3d1af2342efc78" translate="yes" xml:space="preserve">
          <source>GHC.Foreign</source>
          <target state="translated">GHC.Foreign</target>
        </trans-unit>
        <trans-unit id="3a626e20fa6f4e8f1c340c9eb7363e38c3316f5e" translate="yes" xml:space="preserve">
          <source>GHC.ForeignPtr</source>
          <target state="translated">GHC.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="d71c5bdbb27faa86159462f837dd83ea05d16901" translate="yes" xml:space="preserve">
          <source>GHC.GHCi</source>
          <target state="translated">GHC.GHCi</target>
        </trans-unit>
        <trans-unit id="300f938fef529877e36ee6eaa4a48f9f6ec09c20" translate="yes" xml:space="preserve">
          <source>GHC.Generics</source>
          <target state="translated">GHC.Generics</target>
        </trans-unit>
        <trans-unit id="e588603f44d2b51014250aa9f9d2afcfb672ba1d" translate="yes" xml:space="preserve">
          <source>GHC.IO</source>
          <target state="translated">GHC.IO</target>
        </trans-unit>
        <trans-unit id="a7741f8875636325e2148da2b4d2c46725337155" translate="yes" xml:space="preserve">
          <source>GHC.IO.Buffer</source>
          <target state="translated">GHC.IO.Buffer</target>
        </trans-unit>
        <trans-unit id="8823ff4de4c4340532b0cfa4463cf1fbb930f4a4" translate="yes" xml:space="preserve">
          <source>GHC.IO.BufferedIO</source>
          <target state="translated">GHC.IO.BufferedIO</target>
        </trans-unit>
        <trans-unit id="cb68556602bb0930005cd834412eb8de48905349" translate="yes" xml:space="preserve">
          <source>GHC.IO.Device</source>
          <target state="translated">GHC.IO.Device</target>
        </trans-unit>
        <trans-unit id="fbb7b69e98746b76a700b33f458ce5eedeb38078" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding</source>
          <target state="translated">GHC.IO.Encoding</target>
        </trans-unit>
        <trans-unit id="075bca53a743a5950f147684fa2c43f7f4ca0a1b" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Failure</source>
          <target state="translated">GHC.IO.Encoding.Failure</target>
        </trans-unit>
        <trans-unit id="fd2256eb1195a9c0458ef61c670f8ce80ea2ddb6" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Iconv</source>
          <target state="translated">GHC.IO.Encoding.Iconv</target>
        </trans-unit>
        <trans-unit id="00ded5a18e213f9805bc47d5e3787e0e350eb295" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Latin1</source>
          <target state="translated">GHC.IO.Encoding.Latin1</target>
        </trans-unit>
        <trans-unit id="ed9f709b9190c0954fa475c593069d81ded2a81f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF16</source>
          <target state="translated">GHC.IO.Encoding.UTF16</target>
        </trans-unit>
        <trans-unit id="1400abe49cf09bd1d336af6fdf075939f1efe75a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF32</source>
          <target state="translated">GHC.IO.Encoding.UTF32</target>
        </trans-unit>
        <trans-unit id="d878692ff2f4d831a32544a843c5acdc396b31f1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF8</source>
          <target state="translated">GHC.IO.Encoding.UTF8</target>
        </trans-unit>
        <trans-unit id="a84fd41659f18777189c7604f42de55b37d600dc" translate="yes" xml:space="preserve">
          <source>GHC.IO.Exception</source>
          <target state="translated">GHC.IO.Exception</target>
        </trans-unit>
        <trans-unit id="3664164a0a9f493250d7fca47e9c76fc73868ad4" translate="yes" xml:space="preserve">
          <source>GHC.IO.FD</source>
          <target state="translated">GHC.IO.FD</target>
        </trans-unit>
        <trans-unit id="707404689126a6d53ef5f85fb2bd01c00e0a6591" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle</source>
          <target state="translated">GHC.IO.Handle</target>
        </trans-unit>
        <trans-unit id="c4329ea977d1ffef67c80fe9b38f4268fbeb38ba" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.FD</source>
          <target state="translated">GHC.IO.Handle.FD</target>
        </trans-unit>
        <trans-unit id="923ccd81fee0632b161ee012f081f9bec1732ce1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Internals</source>
          <target state="translated">GHC.IO.Handle.Internals</target>
        </trans-unit>
        <trans-unit id="5f3751921c284354cc2714892e3de0248f4d7485" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Lock</source>
          <target state="translated">GHC.IO.Handle.Lock</target>
        </trans-unit>
        <trans-unit id="e9353efafa30350ec1b9fe2d5006dfa9d249cb1f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Text</source>
          <target state="translated">GHC.IO.Handle.Text</target>
        </trans-unit>
        <trans-unit id="0f48b5ff0fc29f2510c5ce2cd8ffb3341bb5b961" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Types</source>
          <target state="translated">GHC.IO.Handle.Types</target>
        </trans-unit>
        <trans-unit id="ccc52eccb2a6780a1feac3b140e02e5ed802441c" translate="yes" xml:space="preserve">
          <source>GHC.IO.IOMode</source>
          <target state="translated">GHC.IO.IOMode</target>
        </trans-unit>
        <trans-unit id="f55b7c8fc75ee721b32bf010f775ce66afba9060" translate="yes" xml:space="preserve">
          <source>GHC.IO.SubSystem</source>
          <target state="translated">GHC.IO.SubSystem</target>
        </trans-unit>
        <trans-unit id="24072f4819afbd54c776518117a1b6955ba52e5a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Unsafe</source>
          <target state="translated">GHC.IO.Unsafe</target>
        </trans-unit>
        <trans-unit id="f02420ddb4478ea0713456e578325339787566cf" translate="yes" xml:space="preserve">
          <source>GHC.IOArray</source>
          <target state="translated">GHC.IOArray</target>
        </trans-unit>
        <trans-unit id="b099c579304d78700a56073579e16c9fb676186b" translate="yes" xml:space="preserve">
          <source>GHC.IORef</source>
          <target state="translated">GHC.IORef</target>
        </trans-unit>
        <trans-unit id="eb37a2aa23ca64e584c27fb9ac978b06a058cc51" translate="yes" xml:space="preserve">
          <source>GHC.Int</source>
          <target state="translated">GHC.Int</target>
        </trans-unit>
        <trans-unit id="0316241109fb8335149365d396b185cfa3658769" translate="yes" xml:space="preserve">
          <source>GHC.Integer</source>
          <target state="translated">GHC.Integer</target>
        </trans-unit>
        <trans-unit id="e484f5e76ac61e9bf4935aeb1f0f874dbb1c3a03" translate="yes" xml:space="preserve">
          <source>GHC.Integer.GMP.Internals</source>
          <target state="translated">GHC.Integer.GMP.Internals</target>
        </trans-unit>
        <trans-unit id="9edc8b73c4df17cdf1c86c03183217a78388cfe5" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms</source>
          <target state="translated">GHC.Integer.Logarithms</target>
        </trans-unit>
        <trans-unit id="788a99d5f2c3235b7c75ab1d70542647afac52ac" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms.Internals</source>
          <target state="translated">GHC.Integer.Logarithms.Internals</target>
        </trans-unit>
        <trans-unit id="cb20764f134c9f093388b799d6edb5c287e142c7" translate="yes" xml:space="preserve">
          <source>GHC.Ix</source>
          <target state="translated">GHC.Ix</target>
        </trans-unit>
        <trans-unit id="ead6a709bdc7b877770a207b97e68a4689718427" translate="yes" xml:space="preserve">
          <source>GHC.List</source>
          <target state="translated">GHC.List</target>
        </trans-unit>
        <trans-unit id="3d57cef545987da93a04e0d694042818f1a1bb34" translate="yes" xml:space="preserve">
          <source>GHC.MVar</source>
          <target state="translated">GHC.MVar</target>
        </trans-unit>
        <trans-unit id="023c57f0497f42e3b02a80cf9d26961f9f6b6620" translate="yes" xml:space="preserve">
          <source>GHC.Maybe</source>
          <target state="translated">GHC.Maybe</target>
        </trans-unit>
        <trans-unit id="164e6fbb161369078c402583c719d0b484bd9cd0" translate="yes" xml:space="preserve">
          <source>GHC.Natural</source>
          <target state="translated">GHC.Natural</target>
        </trans-unit>
        <trans-unit id="ae65dd69d6e330d710167ceb0ad3a94a6e56becc" translate="yes" xml:space="preserve">
          <source>GHC.Num</source>
          <target state="translated">GHC.Num</target>
        </trans-unit>
        <trans-unit id="5f7fc148c0a98a886a6a3bc6e44459e890a898b5" translate="yes" xml:space="preserve">
          <source>GHC.OldList</source>
          <target state="translated">GHC.OldList</target>
        </trans-unit>
        <trans-unit id="219f66845e1b6ccbde2aed8e298fc6202552996a" translate="yes" xml:space="preserve">
          <source>GHC.Profiling</source>
          <target state="translated">GHC.Profiling</target>
        </trans-unit>
        <trans-unit id="5b41899d682d90939969cd71598e1a3c11e49f01" translate="yes" xml:space="preserve">
          <source>GHC.Ptr</source>
          <target state="translated">GHC.Ptr</target>
        </trans-unit>
        <trans-unit id="6c493d68cbbd0903b98d07ddd334636ef44bbad5" translate="yes" xml:space="preserve">
          <source>GHC.RTS.Flags</source>
          <target state="translated">GHC.RTS.Flags</target>
        </trans-unit>
        <trans-unit id="c73e800dcd91edda6a6064deafb3d149d5c87f67" translate="yes" xml:space="preserve">
          <source>GHC.Read</source>
          <target state="translated">GHC.Read</target>
        </trans-unit>
        <trans-unit id="adc72ff9dcbbbacc479bcf7a5fc93c1182110918" translate="yes" xml:space="preserve">
          <source>GHC.Real</source>
          <target state="translated">GHC.Real</target>
        </trans-unit>
        <trans-unit id="6e5b89f9359d5a8bfd2c995515e3c8e2b55f3d6f" translate="yes" xml:space="preserve">
          <source>GHC.Records</source>
          <target state="translated">GHC.Records</target>
        </trans-unit>
        <trans-unit id="0b8521cdcc8c1ef2fd7980f6838d4055504ad2f4" translate="yes" xml:space="preserve">
          <source>GHC.ResponseFile</source>
          <target state="translated">GHC.ResponseFile</target>
        </trans-unit>
        <trans-unit id="3a165be025ea55dd62132f6d49a476a3baddb4bc" translate="yes" xml:space="preserve">
          <source>GHC.ST</source>
          <target state="translated">GHC.ST</target>
        </trans-unit>
        <trans-unit id="592556288d1e596e190164182dec84105b7b17e3" translate="yes" xml:space="preserve">
          <source>GHC.STRef</source>
          <target state="translated">GHC.STRef</target>
        </trans-unit>
        <trans-unit id="c812e3b66e96d4c9aea90e1021417aa178911a2a" translate="yes" xml:space="preserve">
          <source>GHC.Show</source>
          <target state="translated">GHC.Show</target>
        </trans-unit>
        <trans-unit id="22ed618911df1208a7b9b442d70898fc766ec074" translate="yes" xml:space="preserve">
          <source>GHC.Stable</source>
          <target state="translated">GHC.Stable</target>
        </trans-unit>
        <trans-unit id="a20386e520454f3f0f4eb16c34205fd57a4fcb9d" translate="yes" xml:space="preserve">
          <source>GHC.StableName</source>
          <target state="translated">GHC.StableName</target>
        </trans-unit>
        <trans-unit id="d96d568a6576a1e6aecb421974f05a14305bd684" translate="yes" xml:space="preserve">
          <source>GHC.Stack</source>
          <target state="translated">GHC.Stack</target>
        </trans-unit>
        <trans-unit id="021dc0f948747311677c43f8e4143154b011d4e0" translate="yes" xml:space="preserve">
          <source>GHC.Stack.CCS</source>
          <target state="translated">GHC.Stack.CCS</target>
        </trans-unit>
        <trans-unit id="679e7a678858657deeca5fb088d20447dbea9966" translate="yes" xml:space="preserve">
          <source>GHC.Stack.Types</source>
          <target state="translated">GHC.Stack.Types</target>
        </trans-unit>
        <trans-unit id="53710d33b34d9d6d31c7ecc3d9f9075270dc3145" translate="yes" xml:space="preserve">
          <source>GHC.StaticPtr</source>
          <target state="translated">GHC.StaticPtr</target>
        </trans-unit>
        <trans-unit id="7aca1996a3eb2739ab68b28f09387d1bdeef97de" translate="yes" xml:space="preserve">
          <source>GHC.Stats</source>
          <target state="translated">GHC.Stats</target>
        </trans-unit>
        <trans-unit id="52b6bdf52e6d2e6b85bf9394f21a48cc173b0453" translate="yes" xml:space="preserve">
          <source>GHC.TopHandler</source>
          <target state="translated">GHC.TopHandler</target>
        </trans-unit>
        <trans-unit id="a3585409158ac22303c455ac2f18bcd1f244ee48" translate="yes" xml:space="preserve">
          <source>GHC.TypeLits</source>
          <target state="translated">GHC.TypeLits</target>
        </trans-unit>
        <trans-unit id="5f4a237ca09fe1e39f1f4f57427500e3d5dde282" translate="yes" xml:space="preserve">
          <source>GHC.TypeNats</source>
          <target state="translated">GHC.TypeNats</target>
        </trans-unit>
        <trans-unit id="13937217117037ac8a14c5edc72c2b6bb8c575fd" translate="yes" xml:space="preserve">
          <source>GHC.Unicode</source>
          <target state="translated">GHC.Unicode</target>
        </trans-unit>
        <trans-unit id="1fdf724e37267fb3fb33f0dc048df4cee704bb65" translate="yes" xml:space="preserve">
          <source>GHC.Weak</source>
          <target state="translated">GHC.Weak</target>
        </trans-unit>
        <trans-unit id="ad4252ce69afb4d732c694779c89b861201a0b0c" translate="yes" xml:space="preserve">
          <source>GHC.Word</source>
          <target state="translated">GHC.Word</target>
        </trans-unit>
        <trans-unit id="4024a57753a6b7a3c40980a3cd0d4c49ca032099" translate="yes" xml:space="preserve">
          <source>GHCForeignImportPrim</source>
          <target state="translated">GHCForeignImportPrim</target>
        </trans-unit>
        <trans-unit id="f2f693f86b66430c4306b15c72b79c14a03a02ab" translate="yes" xml:space="preserve">
          <source>GHCi</source>
          <target state="translated">GHCi</target>
        </trans-unit>
        <trans-unit id="086bf1fe5e3015b86afe632794f66fe9ce567107" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment that includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;は、インタラクティブデバッガーを含むGHCのインタラクティブ環境です（&lt;a href=&quot;#ghci-debugger&quot;&gt;GHCiデバッガーを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6b49fe46f1283625854f08ffa7ba78c6c9050030" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;はGHCのインタラクティブな環境であり、Haskellの式をインタラクティブに評価し、プログラムを解釈することができます。&lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;に精通している場合は、GHCiをすぐに使用できます。ただし、GHCiは、コンパイルされたコードをインタラクティブにロードすることもサポートしているほか、GHCが提供する&lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2つ&lt;/a&gt;の言語拡張機能すべてをサポートしています。 GHCiには、対話型デバッガーも含まれています（&lt;a href=&quot;#ghci-debugger&quot;&gt;GHCiデバッガーを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cdb6d8296bb43f9daf1bdf2b77da4db467b8f4d7" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;はGHCのインタラクティブな環境で、Haskellの式をインタラクティブに評価し、プログラムを解釈することができます。&lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;に慣れていれば、GHCiをすぐに使用できます。ただし、GHCiは、コンパイルされたコードを対話的にロードするだけでなく、GHCが提供するすべての言語拡張機能&lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;もサポートしています。GHCiには、インタラクティブなデバッガーも含まれています（&lt;a href=&quot;#ghci-debugger&quot;&gt;GHCiデバッガーを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c594049ce431e4e83a8bbd749ab3a0ead79c69f9" translate="yes" xml:space="preserve">
          <source>GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</source>
          <target state="translated">GHCiは、実際にはプロンプトで式だけではなく、ステートメントを受け付けます。つまり、値や関数を名前にバインドして、将来の式やステートメントで使用することができます。</target>
        </trans-unit>
        <trans-unit id="7854b19af27cbb06e171f164ce43770bc4a0b097" translate="yes" xml:space="preserve">
          <source>GHCi actually maintains &lt;em&gt;two&lt;/em&gt; sets of options:</source>
          <target state="translated">GHCiは実際には&lt;em&gt;2&lt;/em&gt;つのオプションセットを保持しています。</target>
        </trans-unit>
        <trans-unit id="7d2a258c616352d17542ccf20713b90940918e9c" translate="yes" xml:space="preserve">
          <source>GHCi can</source>
          <target state="translated">GHCiは</target>
        </trans-unit>
        <trans-unit id="61c86bc68706119b7609650a914602b052655cdc" translate="yes" xml:space="preserve">
          <source>GHCi can also load plain object files (&lt;code&gt;.o&lt;/code&gt; or &lt;code&gt;.obj&lt;/code&gt; depending on your platform) or static archives (&lt;code&gt;.a&lt;/code&gt;) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the &lt;code&gt;big-obj&lt;/code&gt; format.</source>
          <target state="translated">GHCiは、コマンドラインからプレーンオブジェクトファイル（プラットフォームに応じて &lt;code&gt;.o&lt;/code&gt; または &lt;code&gt;.obj&lt;/code&gt; ）または静的アーカイブ（ &lt;code&gt;.a&lt;/code&gt; ）をロードすることもできます。オブジェクトファイルまたはライブラリの名前をコマンドラインに追加するだけです。Windowsでは、GHCiは &lt;code&gt;big-obj&lt;/code&gt; 形式もサポートしています。</target>
        </trans-unit>
        <trans-unit id="07b8d7c354ee687c28dd2a23b15bfd5ced9be453" translate="yes" xml:space="preserve">
          <source>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</source>
          <target state="translated">GHCiはプロファイリングシステムを利用して、解釈されたコードを実行しているときにスタックトレース情報を収集することができます。スタックトレースにアクセスするには、次のようにGHCiを起動します。</target>
        </trans-unit>
        <trans-unit id="189a0097746c2e6bf3ec19ebcd1ad676e7ea5b91" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="translated">GHCiは、ボックス化されていないタプルと合計の存在をやや控えめな方法でチェックします。モジュールが&lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;言語拡張を有効にするかどうかをチェックするだけです。それは可能コードすることを必ずしもそうではありません&lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; が&lt;/a&gt;必要です&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;あなたがそうならば、&lt;em&gt;実際に&lt;/em&gt;コンパイルしたい&lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;バイトコードにコードを-usingを、あなたが可能にすることによって、その明示的に行うことができます&lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt;フラグを。これを行う場合、バイトコードインタープリターが処理できないボックス化されていないタプル/合計関連のコードを検出すると、エラーをスローすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b50b888b5a01174ea88ffe286c7e481b07e9ce3d" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="translated">GHCiは、ボックス化されていないタプルと合計の存在をやや控えめな方法でチェックします。モジュールが&lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;言語拡張を有効にするかどうかをチェックするだけです。それは可能コードすることを必ずしもそうではありません&lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; が&lt;/a&gt;必要です&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;あなたがそうならば、&lt;em&gt;実際に&lt;/em&gt;コンパイルしたい&lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;バイトコードにコードを-usingを、あなたが可能にすることによって、その明示的に行うことができます&lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt;フラグを。これを行う場合、バイトコードインタープリターが処理できないボックス化されていないタプル/合計関連のコードを検出すると、エラーをスローすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f211d1e24170f67686b938b7af0ca37f8a56b146" translate="yes" xml:space="preserve">
          <source>GHCi commands all begin with &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</source>
          <target state="translated">GHCiコマンドはすべて「 &lt;code&gt;:&lt;/code&gt; 」で始まり、単一のコマンド名とそれに続く0個以上のパラメーターで構成されます。コマンド名は省略される場合がありますが、あいまいさは、より一般的に使用されるコマンドを優先して解決されます。</target>
        </trans-unit>
        <trans-unit id="6d0bc0eb39d119d862e834a6402052d747742eb9" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id14&quot; id=&quot;id8&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCiには、変数の値を調べるために実行中の計算を停止できる単純な命令型デバッガーが含まれています。デバッガーはGHCiに統合されており、デフォルトでオンになっています。デバッグ機能を有効にするためにフラグは必要ありません。大きな制限が1つあります。ブレークポイントとシングルステップは、インタープリターされたモジュールでのみ使用できます。コンパイルされたコードはデバッガーには見えません&lt;a href=&quot;#id14&quot; id=&quot;id8&quot;&gt;[5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdeb81402d6c2b81eaa4ac1ca68fa6f4bf53dc3f" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</source>
          <target state="translated">GHCiには、変数の値を調べるために実行中の計算を停止できる単純な命令型デバッガーが含まれています。デバッガーはGHCiに統合されており、デフォルトでオンになっています。デバッグ機能を有効にするためにフラグは必要ありません。大きな制限が1つあります。ブレークポイントとシングルステップは、解釈されたモジュールでのみ使用できます。コンパイルされたコードはデバッガーからは見えません&lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2a469d965ea434ea6094be9ac79416520cda211" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCiには、変数の値を調べるために実行中の計算を停止できる単純な命令型デバッガが含まれています。デバッガーはGHCiに統合されており、デフォルトでオンになっています。デバッグ機能を有効にするためにフラグは必要ありません。大きな制限が1つあります。ブレークポイントとシングルステップは、インタープリターモジュールでのみ使用できます。コンパイルされたコードはデバッガーからは見えません&lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="431b343589f64d92b46f202b4777afcb250c044a" translate="yes" xml:space="preserve">
          <source>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then GHCi &lt;em&gt;executes&lt;/em&gt; it as an IO-computation.</source>
          <target state="translated">GHCiは、プロンプトで単純な式の評価以上のことを行います。一部の &lt;code&gt;a&lt;/code&gt; に対してタイプ &lt;code&gt;IO a&lt;/code&gt; の式を入力&lt;em&gt;する&lt;/em&gt;と、GHCi &lt;em&gt;は&lt;/em&gt;それをIO計算として&lt;em&gt;実行&lt;/em&gt;します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8c6bf6320b5a1d66ecb2b14b4d8bbf578afbaf4" translate="yes" xml:space="preserve">
          <source>GHCi does not respect the &lt;code&gt;default&lt;/code&gt; declaration in the module whose scope you are in. Instead, for expressions typed at the command line, you always get the default default-type behaviour; that is, &lt;code&gt;default(Int,Double)&lt;/code&gt;.</source>
          <target state="translated">GHCiは、現在のスコープを持つモジュールの &lt;code&gt;default&lt;/code&gt; 宣言を尊重しません。代わりに、コマンドラインで入力された式の場合、常にデフォルトのデフォルトタイプの振る舞いを取得します。つまり、 &lt;code&gt;default(Int,Double)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a337aefb4df415fd5ebe89389f3ec26434d221e1" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*Main&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCiのは、ロードされた &lt;code&gt;Main&lt;/code&gt; モジュールを、そしてプロンプトがに変更されました &lt;code&gt;*Main&amp;gt;&lt;/code&gt; プロンプトに入力した式の現在のコンテキストがあることを示すために &lt;code&gt;Main&lt;/code&gt; （私たちは説明します、我々はちょうどロードされたモジュール何 &lt;code&gt;*&lt;/code&gt; 手段以降で&lt;a href=&quot;#ghci-scope&quot;&gt;スコープには本当に何がプロンプトで？&lt;/a&gt;）。これで、 &lt;code&gt;Main.hs&lt;/code&gt; の関数を含む式を入力できるようになりました。</target>
        </trans-unit>
        <trans-unit id="6c07ada5308e7781c1c642740ac4e5f0109c7e27" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*ghci&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCiが &lt;code&gt;Main&lt;/code&gt; モジュールをロードし、プロンプトが &lt;code&gt;*ghci&amp;gt;&lt;/code&gt; に変更されて、プロンプトで入力された式の現在のコンテキストがロードしたばかりの &lt;code&gt;Main&lt;/code&gt; モジュールであることを示します（ &lt;code&gt;*&lt;/code&gt; の意味については後で説明&lt;a href=&quot;#ghci-scope&quot;&gt;します。プロンプトで？&lt;/a&gt;）。これで、 &lt;code&gt;Main.hs&lt;/code&gt; の関数を含む式を入力できるようになりました。</target>
        </trans-unit>
        <trans-unit id="097ef3e6fe8251975966ddc7eaf61adb8ce1daf4" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id15&quot; id=&quot;id9&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCiは、ブレークポイントが配置された式の自由変数&lt;a href=&quot;#id15&quot; id=&quot;id9&quot;&gt;[6]&lt;/a&gt;（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;left&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; ）のバインディングと、さらに式の結果（ &lt;code&gt;_result&lt;/code&gt; ）のバインディングを提供しています。これらの変数は、GHCiで定義する可能性のある他の変数とまったく同じです。プロンプトで入力する式でそれらを使用したり、&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;でタイプを要求したりできます。ただし、重要な違いが1つあります。これらの変数には、部分的な型しかない場合があります。たとえば、 &lt;code&gt;left&lt;/code&gt; の値を表示しようとすると：</target>
        </trans-unit>
        <trans-unit id="7e7e52195cfae2c519c03e23e784d7a20ae2e810" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCiは、ブレークポイントが配置された式の自由変数&lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6の&lt;/a&gt;バインディング（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;left&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; ）と、さらに式の結果のバインディング（ &lt;code&gt;_result&lt;/code&gt; ）を提供しています。これらの変数は、GHCiで定義する可能性のある他の変数とまったく同じです。プロンプトで入力する式でそれらを使用したり、&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;でタイプを要求したりできます。ただし、重要な違いが1つあります。これらの変数には、部分的な型しかない場合があります。たとえば、 &lt;code&gt;left&lt;/code&gt; の値を表示しようとすると：</target>
        </trans-unit>
        <trans-unit id="4760f6a58d8645892518b92f9d2d0455de2f6de1" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCiは、ブレークポイントが置かれた式の自由変数&lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt;のバインディング（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;left&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; ）を提供し、さらに式の結果のバインディング（ &lt;code&gt;_result&lt;/code&gt; ）も提供しています。これらの変数は、GHCiで定義する他の変数と同じです。プロンプトで入力する式でそれらを使用したり、&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;でそれらのタイプを要求したりできます。ただし、重要な違いが1つあります。これらの変数には部分的な型しかない場合があります。たとえば、 &lt;code&gt;left&lt;/code&gt; の値を表示しようとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="d52ffb5498f59a8fef6a199eb895dfb10991a53d" translate="yes" xml:space="preserve">
          <source>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</source>
          <target state="translated">GHCi は、行全体を評価する式として解釈します。Enterキーを押すとすぐに、GHCiはそれを評価しようとします。</target>
        </trans-unit>
        <trans-unit id="d000c11f6d43ecae04979b2322aedc62f59206e3" translate="yes" xml:space="preserve">
          <source>GHCi is invoked with the command &lt;code&gt;ghci&lt;/code&gt; or &lt;code&gt;ghc --interactive&lt;/code&gt;. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said &lt;code&gt;:load modules&lt;/code&gt; at the GHCi prompt (see &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;). For example, to start GHCi and load the program whose topmost module is in the file &lt;code&gt;Main.hs&lt;/code&gt;, we could say:</source>
          <target state="translated">GHCiは、コマンド &lt;code&gt;ghci&lt;/code&gt; または &lt;code&gt;ghc --interactive&lt;/code&gt; で呼び出されます。コマンドラインで1つ以上のモジュールまたはファイル名を指定することもできます。これは、あなたが言っていたかのようにGHCiのは、指定されたモジュールやファイル名（およびすべてのモジュールそれが依存）をロードするよう指示 &lt;code&gt;:load modules&lt;/code&gt; GHCiのプロンプトで（参照&lt;a href=&quot;#ghci-commands&quot;&gt;GHCiのコマンドを&lt;/a&gt;）。たとえば、GHCiを起動し、最上位のモジュールが &lt;code&gt;Main.hs&lt;/code&gt; ファイルにあるプログラムをロードするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="02cd23e6d70f664fac3cadb490523ec73e9c61c9" translate="yes" xml:space="preserve">
          <source>GHCi options may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and unset using &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt;&lt;code&gt;:unset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHCiオプションは、&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;を使用して設定し、&lt;a href=&quot;#ghci-cmd-:unset&quot;&gt; &lt;code&gt;:unset&lt;/code&gt; &lt;/a&gt;を使用して設定解除できます。</target>
        </trans-unit>
        <trans-unit id="23865ba11579e59cab852eaf50893d8f8310f50d" translate="yes" xml:space="preserve">
          <source>GHCi tells us that, among other bindings, &lt;code&gt;f&lt;/code&gt; is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of &lt;code&gt;x&lt;/code&gt;, and its result type is shared with &lt;code&gt;_result&lt;/code&gt;.</source>
          <target state="translated">GHCiは、他のバインディングの中でも、 &lt;code&gt;f&lt;/code&gt; がスコープ内であることを示しています。ただし、その型はまだ完全にはわかっていないため、任意の引数に適用することはできません。それでも、最初の引数の型は &lt;code&gt;x&lt;/code&gt; の型と同じであり、その結果の型は &lt;code&gt;_result&lt;/code&gt; と共有されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3c860feb5ec1b15da2c58750a623feabad614260" translate="yes" xml:space="preserve">
          <source>GHCi uses &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline user preferences&lt;/a&gt;.</source>
          <target state="translated">GHCiは&lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;内部&lt;/a&gt;でHaskelineを使用しています。特に、GHCi履歴から重複をプルーニングするように構成できます。参照：&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskelineユーザー設定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27b5ae81e5a8c6380c3ff5286cbd9fbd01c0708a" translate="yes" xml:space="preserve">
          <source>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; then GHCi will expand it to &lt;code&gt;Just&lt;/code&gt;.</source>
          <target state="translated">GHCiはスコープ内の名前をタブで補完します。たとえば、GHCiを実行して &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; と入力すると、GHCiはそれを &lt;code&gt;Just&lt;/code&gt; に展開します。</target>
        </trans-unit>
        <trans-unit id="912aae042df048a72c9945fa25dfdd84648ce03f" translate="yes" xml:space="preserve">
          <source>GHCi.BinaryArray</source>
          <target state="translated">GHCi.BinaryArray</target>
        </trans-unit>
        <trans-unit id="ebc86550d6d8c6805a075e4ee82223ab44c22f1b" translate="yes" xml:space="preserve">
          <source>GHCi.Message</source>
          <target state="translated">GHCi.Message</target>
        </trans-unit>
        <trans-unit id="b7f4cbe61fcbdf53e726dde698f6d8427d6f6967" translate="yes" xml:space="preserve">
          <source>GHCi.ObjLink</source>
          <target state="translated">GHCi.ObjLink</target>
        </trans-unit>
        <trans-unit id="ef375e610fc95f4a10dd98a324ea900410775563" translate="yes" xml:space="preserve">
          <source>GHCi.RemoteTypes</source>
          <target state="translated">GHCi.RemoteTypes</target>
        </trans-unit>
        <trans-unit id="546802906c4994371bd7abbe6ba80eda19818ed8" translate="yes" xml:space="preserve">
          <source>GHCi.ResolvedBCO</source>
          <target state="translated">GHCi.ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="f0b490ca46daa8f25bfa4855b33e28ba0663f27e" translate="yes" xml:space="preserve">
          <source>GHCi.Signals</source>
          <target state="translated">GHCi.Signals</target>
        </trans-unit>
        <trans-unit id="7899287feb51f897b8a19c276da822182ac21af9" translate="yes" xml:space="preserve">
          <source>GHCi.StaticPtrTable</source>
          <target state="translated">GHCi.StaticPtrTable</target>
        </trans-unit>
        <trans-unit id="bb3d877b385e2643cf85046824f0351addc9a45b" translate="yes" xml:space="preserve">
          <source>GHCi.TH</source>
          <target state="translated">GHCi.TH</target>
        </trans-unit>
        <trans-unit id="1d7f50c80144815a35dcdd8cead270f10c32bacd" translate="yes" xml:space="preserve">
          <source>GHCi.Utils</source>
          <target state="translated">GHCi.Utils</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">ゴミの収集</target>
        </trans-unit>
        <trans-unit id="9adb6994755f905f75af8a5e2ea3803352181ba0" translate="yes" xml:space="preserve">
          <source>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require \(3L\) bytes of memory, where \(L\) is the amount of live data. This is because by default (see the RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; option) we allow the old generation to grow to twice its size (\(2L\)) before collecting it, and we require additionally \(L\) bytes to copy the live data into. When using compacting collection (see the &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option), this is reduced to \(2L\), and can further be reduced by tweaking the &lt;code&gt;-F
⟨factor⟩&lt;/code&gt; option. Also add the size of the allocation area (see &lt;code&gt;-A
⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">ガベージコレクションには、実際の常駐よりも多くのメモリが必要です。この係数は、使用中のガベージコレクションアルゴリズムの種類によって異なります。標準世代のコピーコレクターの主要なGCは通常、\（3L \）バイトのメモリを必要とします。\（L \）はライブデータの量です。これは、デフォルトでは（RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; オプションを参照）、古い世代をサイズの2倍（\（2L \））にしてから収集するため、さらにコピーするために\（L \）バイトが必要になるためです。ライブデータ。圧縮コレクションを使用する場合（&lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;オプションを参照）、これは\（2L \）に削減され、 &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; オプションを調整することでさらに削減できます。また、割り当て領域のサイズを追加します（ &lt;code&gt;-A ⟨size⟩&lt;/code&gt; 参照）。</target>
        </trans-unit>
        <trans-unit id="5ef3a23ff5d0585af5a5a4d93589e0f9057a7a61" translate="yes" xml:space="preserve">
          <source>GenLanguageDef</source>
          <target state="translated">GenLanguageDef</target>
        </trans-unit>
        <trans-unit id="54007d0d2b9f177a727f3b24f2d943df20b8deca" translate="yes" xml:space="preserve">
          <source>GenParser</source>
          <target state="translated">GenParser</target>
        </trans-unit>
        <trans-unit id="9cebabfd017fca2459439f2cdddbfa91800ffe40" translate="yes" xml:space="preserve">
          <source>GenTokenParser</source>
          <target state="translated">GenTokenParser</target>
        </trans-unit>
        <trans-unit id="11d4fb3475a101d8c9ae85b42e237a2007bc5294" translate="yes" xml:space="preserve">
          <source>General Quantity Semaphores</source>
          <target state="translated">一般的な量のセマフォ</target>
        </trans-unit>
        <trans-unit id="5c4940d2f6feb1f80aee808047b0cd3c6532766b" translate="yes" xml:space="preserve">
          <source>General combining function</source>
          <target state="translated">一般的な結合機能</target>
        </trans-unit>
        <trans-unit id="3571f6a92057b6b6050f2f5c27ff1f749bf598bf" translate="yes" xml:space="preserve">
          <source>General combining functions</source>
          <target state="translated">一般的な組み合わせ機能</target>
        </trans-unit>
        <trans-unit id="d43b7ab00d837792990ac04a2a3ceeb8dca84942" translate="yes" xml:space="preserve">
          <source>General definitions for superclass methods</source>
          <target state="translated">スーパークラスメソッドの一般的な定義</target>
        </trans-unit>
        <trans-unit id="51482529c6677f2a5e1536e3abbc044e55d04df8" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一般的な折りたたみは、 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; インスタンスを介して利用できます。</target>
        </trans-unit>
        <trans-unit id="2cb698a6fdef53a2047596be60a1e1ba2d67960a" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一般的な折り畳みは、 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 可能なインスタンスを介して利用できます。</target>
        </trans-unit>
        <trans-unit id="96299832bc0e4cdb2afa17e640eff0b72082e4dd" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一般的な折り畳みは、 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 可能なインスタンスを介して利用できます。</target>
        </trans-unit>
        <trans-unit id="4da0f615e29aa775c1b4d14d76dc1ab67db6f413" translate="yes" xml:space="preserve">
          <source>General marshalling utilities</source>
          <target state="translated">一般的なマーシャルユーティリティ</target>
        </trans-unit>
        <trans-unit id="3e8d2ea2ea48695ac53dc1175beaebda38571966" translate="yes" xml:space="preserve">
          <source>General rendering</source>
          <target state="translated">一般的なレンダリング</target>
        </trans-unit>
        <trans-unit id="b5c117841ab98d064d9ec4fdda7883c977e283c9" translate="yes" xml:space="preserve">
          <source>General-purpose finite sequences.</source>
          <target state="translated">汎用有限数列。</target>
        </trans-unit>
        <trans-unit id="95e3e92034cf70ddc1aa314c5db463429c48b08c" translate="yes" xml:space="preserve">
          <source>GeneralCategory</source>
          <target state="translated">GeneralCategory</target>
        </trans-unit>
        <trans-unit id="588fb85f0da12d2db4af030769a3fe542d141ec2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; の任意のインスタンスへの &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; の一般化</target>
        </trans-unit>
        <trans-unit id="2828c3cdd240b29b7adddd99ced6ba83ae84c8d8" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; の任意のインスタンスへの &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; の一般化</target>
        </trans-unit>
        <trans-unit id="e61a01cc59f938a5a2397118a9603bef23b0e4c2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; の任意のインスタンスへの &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; の一般化</target>
        </trans-unit>
        <trans-unit id="483a67423e4f02af497f083df740c06f787f15ed" translate="yes" xml:space="preserve">
          <source>Generalisations of list functions</source>
          <target state="translated">リスト関数の一般化</target>
        </trans-unit>
        <trans-unit id="9eac298b6aa11d6f17eff26f7546fc361e27b466" translate="yes" xml:space="preserve">
          <source>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</source>
          <target state="translated">一般化された代数データ型は、コンストラクタがより豊富な戻り値型を持つことを可能にすることで、通常の代数データ型を一般化します。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="82396ff476196b610167e5598629b6fdb9407c80" translate="yes" xml:space="preserve">
          <source>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Comprehensive comprehensions: comprehensions with &amp;ldquo;order by&amp;rdquo; and &amp;ldquo;group by&amp;rdquo;&lt;/a&gt;, except that the syntax we use differs slightly from the paper.</source>
          <target state="translated">一般化されたリスト内包表記は、リスト内包表記構文糖度をさらに拡張したもので、SQLでよく知られているソートやグループ化などの操作を可能にします。これらは&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;、「包括的内包：順序による」および「グループによる」による内包で&lt;/a&gt;完全に説明されていますが、使用する構文がこの紙とは少し異なります。</target>
        </trans-unit>
        <trans-unit id="573d76545cf52f17a400f8d78e7b0bd044b970f2" translate="yes" xml:space="preserve">
          <source>Generalizations of Control.Exception</source>
          <target state="translated">Control.Exceptionの一般化</target>
        </trans-unit>
        <trans-unit id="f1955dbc970386d87459b85c65d5689fcd0a3342" translate="yes" xml:space="preserve">
          <source>Generalized abstracted pattern of safe resource acquisition and release in the face of errors. The first action &quot;acquires&quot; some value, which is &quot;released&quot; by the second action at the end. The third action &quot;uses&quot; the value and its result is the result of the &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラーに直面した場合の安全なリソースの取得と解放の一般化された抽象化されたパターン。最初のアクションはある値を「取得」し、最後の2番目のアクションによって「解放」されます。3番目のアクションは値を「使用」し、その結果は &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 結果です。</target>
        </trans-unit>
        <trans-unit id="dce773570cb4c3e2d017c427de373025af29832e" translate="yes" xml:space="preserve">
          <source>Generalized casts for higher-order kinds</source>
          <target state="translated">高次型の一般化キャスト</target>
        </trans-unit>
        <trans-unit id="3389ef31a5ee4e0a49d994e2e340b2c46172d24e" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using propositional equality</source>
          <target state="translated">命題の平等性を用いた一般化された型安全キャストの形式</target>
        </trans-unit>
        <trans-unit id="60044df19e927ec8addc3d0c22ff3af4bc023cc2" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using representational equality</source>
          <target state="translated">表現的等式を用いた一般化された型安全キャストの形式</target>
        </trans-unit>
        <trans-unit id="cdde5c558c7ac937fc8c98638e3ae4ebfda3b764" translate="yes" xml:space="preserve">
          <source>Generalized functions</source>
          <target state="translated">一般化された関数</target>
        </trans-unit>
        <trans-unit id="c4d66c566123a657ae808a9a54c61c6f61296e8e" translate="yes" xml:space="preserve">
          <source>Generalized insertion/deletion</source>
          <target state="translated">一般的な挿入/脱落</target>
        </trans-unit>
        <trans-unit id="5d04310694030c511391766d6d01208fdf93d744" translate="yes" xml:space="preserve">
          <source>Generalized version of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt; 一般化バージョン</target>
        </trans-unit>
        <trans-unit id="e85d5742bf4b934078e0af2ccc4ec3350c42aa66" translate="yes" xml:space="preserve">
          <source>Generalized version of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt; 一般化バージョン</target>
        </trans-unit>
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">一般的に言って、&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;がオンの場合、GHCは宣言の最も一般的な種類を推測しようとします。多くの場合（たとえば、データ型宣言の場合）、定義には親切な推論を通知する右側があります。しかし、常にそうであるとは限りません。検討する</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">通常、&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;プラグマを指定できるのは、同じモジュールで定義された関数のみです。ただし、関数 &lt;code&gt;f&lt;/code&gt; にその定義サイトで&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;プラグマが指定されている場合は、その後、モジュールをインポートすることによって特殊化できます（&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLEプラグマを&lt;/a&gt;参照）。例えば</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">キャプチャ可能な名前を生成します。このような名前の出現は、出現場所でのHaskellのスコープルールに従って解決されます。</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">キャプチャできない新鮮な名前を生成します。</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;ツールへの入力に適した形式で、パッケージの依存関係のグラフを生成します。たとえば、依存関係グラフのPDFを生成するには：</target>
        </trans-unit>
        <trans-unit id="d21a0134adc8de08a084ff41a1de99d42f5f474c" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;https://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">&lt;a href=&quot;https://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;ツールへの入力に適した形式でパッケージの依存関係のグラフを生成します。たとえば、依存関係グラフのPDFを生成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">共有ライブラリの生成 (実行ファイルではなく)</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">スタンドアロンのスタティックライブラリを生成します(実行ファイルではなく)。これは、クロスコンパイルするときに便利です。ライブラリは、すべての依存関係と一緒に単一のスタティック・ライブラリになり、それに対してリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">バイトコードの生成</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">オブジェクトコードの代わりにバイトコードを生成します。これはGHCiのデフォルトです。バイトコードは現在、対話型インタープリターでのみ使用でき、ディスクには保存できません。このオプションは、&lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; の&lt;/a&gt;効果を元に戻す場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">位置に依存しない実行ファイルのコードを生成します。</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">動的ライブラリに対してリンクするためのコードを生成</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">位置に依存しない実行可能ファイルにリンクできるようにコードを生成するこれは現在、Linux x86およびx86-64で動作します。 Windowsでは、位置に依存しないコードは使用されないため、フラグはそのプラットフォームでは何もしません。最終的な実行可能ファイルをリンクするには、&lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">カラー出力を生成します。</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">LaTeXドキュメントに含めるのに適したカプセル化されたPostScriptを生成します。通常、PostScriptグラフは横9インチ &lt;code&gt;hp2ps&lt;/code&gt; 高さ6インチの領域に横長モードで描画され、hp2psはこの領域がa4用紙のほぼ中央に配置されるように調整します。この形式はグラフを詳細に調べるのに便利ですが、LaTeXドキュメントに含めるには適していません。 &lt;code&gt;-e&lt;/code&gt; オプションは、フロートはインチ、ミリメートルまたはポイントの幅（デフォルト）を指定して、ポートレートモードで描画するグラフの原因となります。結果のPostScriptファイルは、Encapsulated PostScript（EPS）規則に準拠しており、Rokickiのdvi-to-PostScriptコンバーター &lt;code&gt;dvips&lt;/code&gt; を使用してLaTeXドキュメントに含めることができます。</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">オブジェクトコードの生成</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">オブジェクトコードを生成します。これはGHCiの外ではデフォルトであり、GHCiを使ってバイトコードではなくオブジェクトコードを生成させることができます。</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">位置に依存しないコード(共有ライブラリに入れられるコード)を生成します。これは現在 Linux x86 と x86-64 で動作します。Windowsでは、位置に依存しないコードは使用されないので、そのプラットフォームではこのフラグは使用されません。</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">位置に依存しないコードを生成する(利用可能な場合</target>
        </trans-unit>
        <trans-unit id="7b85081d19a7d760ce6025f60cc20a50bec6fa8f" translate="yes" xml:space="preserve">
          <source>Generate warnings for Template Haskell splices</source>
          <target state="translated">テンプレートHaskellスプライスの警告を生成する</target>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">元のソースのソース行番号を伝えるためにプリプロセッサによって生成されます。</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">Viスタイルエディター（&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt;）またはEmacsスタイルエディター（&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt;）用の「タグ」ファイルを生成します。ファイル名が指定されていない場合、デフォルトの &lt;code&gt;tags&lt;/code&gt; または &lt;code&gt;TAGS&lt;/code&gt; がそれぞれ使用されます。現在ロードされているモジュール内のすべての関数、コンストラクター、およびタイプのタグが作成されます。これらのコマンドを機能させるには、すべてのモジュールを解釈する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファイル &lt;code&gt;prog.hp&lt;/code&gt; に基本的なヒーププロファイルを生成します。ヒーププロファイルグラフを作成するには、&lt;strong&gt;hp2psを&lt;/strong&gt;使用し&lt;strong&gt;ます&lt;/strong&gt;（&lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash;ヒーププロファイルをPostScriptにレンダリングするを&lt;/a&gt;参照）。基本的なヒーププロファイルは、データコンストラクターによって分解されます。他の種類のクロージャー（関数、 &lt;code&gt;THUNK&lt;/code&gt; など）は、幅広いカテゴリ（例： &lt;code&gt;FUN&lt;/code&gt; 、THUNK）にグループ化されています。より詳細なプロファイルを取得するには、完全なプロファイリングサポート（&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;）を使用してください。&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;に短縮できます。</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">GHCの1回の実行で動的オブジェクトファイルと静的オブジェクトファイルの両方を生成します。このオプションは、GHCを2回実行することと機能的に同等 &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; 回目は-dynamic -osuf dyn_o -hisuf dyn_hiを追加します。</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">以下のインスタンスを生成します。</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">ByteStringsの生成と展開</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">世代と展開</target>
        </trans-unit>
        <trans-unit id="03ba3f9ceb4ba004160e258a483f5fc398019ac0" translate="yes" xml:space="preserve">
          <source>Generative Recursion</source>
          <target state="translated">生成的再帰</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">汎用コンストラクタクラス</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">ジェネリック インスタンス</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gunfold&lt;/code&gt; 観点から定義された一般的な操作</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">GHCのジェネリックプログラミングサポートにより、インスタンス化するときにユーザー指定を必要としないメソッドでクラスを定義できます。メソッド本体はGHCによって自動的に派生します。これは、たとえば &lt;code&gt;Read&lt;/code&gt; や &lt;code&gt;Show&lt;/code&gt; などの標準クラスで何が起こるかと似ていますが、現在はユーザー定義クラスでも行われています。</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">汎用表現型</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">一般的な表現タイプ</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">ジェネリックサポート</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">汎用型クラス</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">NULバイトで終了する遅延ByteStringを取得します。返される文字列には NUL バイトは含まれていません。NUL を見つけられずに入力の最後に到達した場合は失敗します。</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH変数内の &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">$ PATH変数内の &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">ブレークポイントで自由変数への参照を取得する</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">与えられた投影関数を使用して、状態の特定のコンポーネントを取得します。</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">現在の実行スタックの状態を文字列で表現したものを取得します。</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">現在の実行スタックの状態のトレースを取得します。</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">すべての拡張子を取得します。</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">環境値またはデフォルト値を取得します。</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">実行スタックを取得します。</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">現在のランタイムシステムの統計情報を取得します。</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; モナドから状態を取得します。状態は、テンプレートHaskell式が実行されるHaskellモジュールに対してローカルであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取得 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; をの先頭に &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">指定された値に関連付けられている &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">取得 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; をの先頭に &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">指定された値に関連付けられている &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">特定の子午線上のローカルタイムのUT1時間を取得します。</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">タイムゾーン内の現地時間のUTC時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">拡張子やパスを指定せずに、ベースとなる名前を取得します。</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 環境変数の内容を取得します。</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">システムクロックから現在の &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">システムクロックから現在のPOSIX時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">現在の行入力履歴を取得します。</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">現在のタイムゾーンを取得します。</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">現在のスレッドの &lt;code&gt;errno&lt;/code&gt; の現在の値を取得します。</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">端末のデフォルトサイズを取得します。サイズ変更可能な端末（たとえば、 &lt;code&gt;xterm&lt;/code&gt; ）の場合、これらは実際の寸法と一致しない場合があります。</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">ディレクトリ名を取得し、1つ上のレベルに移動します。</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">ファイルパスからドライブを取得します。</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">ターミナルに接続されているハンドルのエコー状態を取得します。</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">ファイルの拡張子を取得し、拡張子がない場合は &lt;code&gt;&quot;&quot;&lt;/code&gt; 、それ以外の場合は &lt;code&gt;.ext&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">ファイル名を取得します。</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">別の文字列の部分文字列の最初のインデックスを取得します。文字列が見つからない場合は &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。 &lt;code&gt;findSubstring p s&lt;/code&gt; は &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="f14dd66fb1e3670e1835aac5f144235035b8e6b1" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">別の文字列の部分文字列の最初のインデックスを取得します。文字列が見つからない場合は &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。 &lt;code&gt;findSubstring p s&lt;/code&gt; は、 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="00312e6da40cecc61aba8aa333ef44ff0591b478" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">別の文字列の部分文字列の最初のインデックスを取得します。文字列が見つからない場合は &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を取得します。 &lt;code&gt;findSubstring p s&lt;/code&gt; は、 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">一日の時間を指定された真夜中からの一日の端数を取得します。</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">ウィンドウのタイトルを使用して、現在のコンソールウィンドウのハンドルを取得します。参照：&lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http&lt;/a&gt; : //support.microsoft.com/kb/124103</target>
        </trans-unit>
        <trans-unit id="960fe0a37606fd52b1bf4fbbc6af3101d8d8466b" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;https://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">ウィンドウのタイトルを使用して、現在のコンソールウィンドウのハンドルを取得します。参照：&lt;a href=&quot;https://support.microsoft.com/kb/124103&quot;&gt;http&lt;/a&gt;：//support.microsoft.com/kb/124103</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">現在のコンソールウィンドウのハンドルを取得します。</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">指定されたキーのラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">特定の子午線上のUT1時間の現地時間を取得します。</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">タイムゾーン内のUTC時間の現地時間を取得します。</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">指定された時間のローカルタイムゾーンを取得します(夏時間の調整に応じて変化します)。</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のモジュールを取得します。</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のモジュールを取得します。</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">削除せずに &lt;code&gt;TBQueue&lt;/code&gt; から次の値を取得し、チャネルが空の場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">削除せずに &lt;code&gt;TChan&lt;/code&gt; から次の値を取得し、チャネルが空の場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">削除せずに &lt;code&gt;TQueue&lt;/code&gt; から次の値を取得し、チャネルが空の場合は再試行します。</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; のピコ秒数を取得します。</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">年の月曜始まりの週の番号と曜日を取得します。最初の月曜日は週1の最初の日で、年のいずれかの早い日は週0です（として &lt;code&gt;%W&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。月曜日は日曜日（7ようで、1 &lt;code&gt;%u&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">その年の日曜日から始まる週数と曜日を取得します。最初の日曜日は、年のいずれかの早い日（として週0で週1の最初の日である &lt;code&gt;%U&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。日曜日は0で、土曜日は（として6 &lt;code&gt;%w&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">ファイルやディレクトリのパーミッションを取得します。</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">固定値の優先順位を取得します。</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">残りのバイトを遅延ByteStringとして取得します。これは、すべての入力を読み込んで文字列をメモリに保持しなければならないため、使用するには高価な関数になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; の秒を取得します。</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のソーススパンを取得します。</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; のソーススパンを取得します。</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">オブジェクトにアタッチされたスタックトレースを取得します。</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">指定されたフォーマット指定子に対応する文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">システム時刻、1970 UTCのエポックスタートを取得し、うるう秒は無視されます。 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; は通常、 &lt;code&gt;getCurrentTime&lt;/code&gt; よりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; の末尾を取得します。</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; の末尾を取得します。</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">深夜0時からの時間を与えられた時刻を取得します。24時間以上の時間は閏秒に変換されます。</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">深夜からの一日の端数を与えられた時間を取得します。</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">指定された時間帯の午前0時からの時間を取得します。</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">この時点までに読み込まれた総バイト数を取得します。</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">ユーザー名を取得します。参照：&lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;、&lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">前景ウィンドウを取得/設定します。</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">与えられたOSハンドルまたはPOSIX fdからGHCハンドルファイルの記述を取得します。</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">指定された投影関数を用いて、状態の特定の要素を取得します。</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">インデックスのコンストラクタを取得する (代数的なデータ型のみ)</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">代数データ型のコンストラクタを取得する.</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">コンストラクタのデータ型を取得します。</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">コンストラクタのフィールドラベルを取得します。ラベルのリストは、元のコンストラクタ宣言で与えられたものと同じ順番で返されます。</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">コンストラクタの固定性を取得します。</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">コンストラクタのインデックスを取得します(代数的なデータ型のみ)。</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">代数データ型の最大コンストラクタインデックスを取得する。</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">コンストラクタ型のモジュールを取得します:take *.*.*.*...before name</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">データ型の公開プレゼンテーションを取得します。</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">コンストラクタの公開プレゼンテーションを取得します。</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">コンストラクタの文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">モジュールを含む型のコンストラクタを取得します。</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">非限定型のコンストラクタを取得します:drop *.*.*.*...before name</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">プラグインモジュールに引数を与えます。moduleは&lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt;指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">プラグインモジュールに引数を与えます。モジュールは &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; 指定する必要があります</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">明示的な型署名を与えます。</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="76d11fa818460b917132ef39c92a210ad06313c6" translate="yes" xml:space="preserve">
          <source>Given a CNF and the address of one its compact blocks, returns the next compact block and its utilized size, or &lt;code&gt;nullAddr#&lt;/code&gt; if the argument was the last compact block in the CNF.</source>
          <target state="translated">CNFとそのコンパクトブロックのアドレスを指定すると、次のコンパクトブロックとその使用サイズを返します。引数がCNFの最後のコンパクトブロックの場合は &lt;code&gt;nullAddr#&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">コンパクトとそのブロックの1つのアドレスが与えられると、次のブロックとそのサイズを、引数がコンパクトの最後のブロックの場合は#nullAddrを返します。</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">パスセグメントのリストを指定して、を展開し &lt;code&gt;.&lt;/code&gt; そして &lt;code&gt;..&lt;/code&gt; .。パスセグメントにパスセパレータを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">文字列のリストが与えられたら、それらを連結して、特定の文字をエスケープし、各文字列の間に改行を追加して1つの文字列にします。エスケープは、空白文字、単一引用符、二重引用符、バックスラッシュ文字の前に一文字のバックスラッシュを追加することで行われるので、このエスケープ文字は削除しなければなりません。エスケープされていない空白(この場合、改行)は、前の文字列の終わりと新しい文字列の始まりを示すために、この &quot;トランスポート &quot;フォーマットの一部となっています。</target>
        </trans-unit>
        <trans-unit id="95bb9fa5760cd6c7244418378ad672bd58d5c738" translate="yes" xml:space="preserve">
          <source>Given a maximum size &lt;code&gt;l&lt;/code&gt; and an action &lt;code&gt;f&lt;/code&gt; that fills the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; starting at the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and returns the actual utilized length, &lt;code&gt;createUpToN` l f&lt;/code&gt; returns the filled &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最大サイズの所与の &lt;code&gt;l&lt;/code&gt; およびアクション &lt;code&gt;f&lt;/code&gt; 充填 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 与えられた始まる &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; と実際の利用長さを返し、 &lt;code&gt;createUpToN` l f&lt;/code&gt; 戻り、充填 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">構造体の要素をリストにマッピングする手段が与えられると,そのようなすべてのリストの連結を順番に計算します.</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">名前またはパスを指定すると、 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; はクエリに &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; を追加し、指定された検索ディレクトリのリストで実行可能ファイルを検索して、すべての出現箇所を返します。</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">形の平行理解を与えられる。</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">フォームのパターン同義語の定義を与えられた</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">プログラム &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; と引数 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; を指定すると、 &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; は、 &lt;code&gt;/bin/sh&lt;/code&gt; （UNIXシステムの場合）または &lt;code&gt;CMD.EXE&lt;/code&gt; （Windowsの場合）に貼り付けるのに適した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">コピー元の配列,コピー元の配列へのオフセット,コピー先の配列,コピー先の配列へのオフセット,コピーする要素の数が指定されている場合,コピー元の配列からコピー先の配列に要素をコピーします.両方の配列が指定された範囲を完全に含む必要がありますが,これはチェックされません.コピー元とコピー先が同じ配列の場合,コピー元の領域とコピー先の領域が重なることがあります.</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">コピー元の配列,コピー元の配列へのオフセット,コピー先の配列,コピー先の配列へのオフセット,コピーする要素の数が指定されている場合,コピー元の配列からコピー先の配列に要素をコピーします.両方の配列は,指定された範囲を完全に含んでいなければなりませんが,これはチェックされません.2 つの配列は,異なる状態の同じ配列であってはいけませんが,これもチェックされません.</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">コピー元の配列,コピー元の配列へのオフセット,コピー先の配列,コピー先の配列へのオフセット,コピーする要素の数が与えられたとき,コピー元の配列からコピー先の配列に要素をコピーします.コピー元配列とコピー先配列は,同じ配列を参照することができます.両方の配列は,指定された範囲を完全に含む必要がありますが,これはチェックされません.領域は重複しても構いませんが,これは送信元と送信先の両方に同じ配列が提供されている場合にのみ可能です.</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">元の配列,元の配列へのオフセット,コピーする要素の数が与えられた場合,元の配列の要素を用いて新しい配列を作成します.指定された配列は、指定された範囲を完全に含む必要がありますが、これはチェックされません。</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">連結された文字列の文字列が与えられた場合、特定の文字の&lt;em&gt;引用&lt;/em&gt;および/または&lt;em&gt;エスケープ&lt;/em&gt;の層を削除することにより、それぞれを区切ります。</target>
        </trans-unit>
        <trans-unit id="db80bf9064baa22164cf6760944ac2e09d91e904" translate="yes" xml:space="preserve">
          <source>Given a structure &lt;code&gt;t&lt;/code&gt; with elements &lt;code&gt;(a, b, ..., w, x, y)&lt;/code&gt;, the result of a fold with an operator function &lt;code&gt;f&lt;/code&gt; is equivalent to:</source>
          <target state="translated">要素 &lt;code&gt;(a, b, ..., w, x, y)&lt;/code&gt; 持つ構造体 &lt;code&gt;t&lt;/code&gt; が与えられた場合、演算子関数 &lt;code&gt;f&lt;/code&gt; を使用したフォールドの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="92ca9d8fe607bde8e742ea61d114d46004740856" translate="yes" xml:space="preserve">
          <source>Given a structure &lt;code&gt;t&lt;/code&gt; with elements &lt;code&gt;(a, b, ..., x, y)&lt;/code&gt;, the result of a fold with operator &lt;code&gt;f&lt;/code&gt; is equivalent to:</source>
          <target state="translated">要素 &lt;code&gt;(a, b, ..., x, y)&lt;/code&gt; 持つ構造体 &lt;code&gt;t&lt;/code&gt; が与えられた場合、演算子 &lt;code&gt;f&lt;/code&gt; を使用したフォールドの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="36e71f3e73c2028c2e375c33d2e51213ee17970d" translate="yes" xml:space="preserve">
          <source>Given a structure &lt;code&gt;t&lt;/code&gt; with elements &lt;code&gt;(a, b, c, ..., x, y)&lt;/code&gt;, the result of a fold with an operator function &lt;code&gt;f&lt;/code&gt; is equivalent to:</source>
          <target state="translated">要素 &lt;code&gt;(a, b, c, ..., x, y)&lt;/code&gt; 持つ構造体 &lt;code&gt;t&lt;/code&gt; が与えられた場合、演算子関数 &lt;code&gt;f&lt;/code&gt; を使用したフォールドの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c3bf1d8801ada8745b533a3c230200cb9cb7fd62" translate="yes" xml:space="preserve">
          <source>Given a structure with elements whose type is a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, combine them via the monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; operator. This fold is right-associative and lazy in the accumulator. When you need a strict left-associative fold, use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` instead, with &lt;code&gt;&lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; as the map.</source>
          <target state="translated">タイプが &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; である要素を持つ構造が与えられた場合、モノイドの &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 演算子を使用してそれらを結合します。このフォールドは、アキュムレータで右結合性で怠惰です。厳密な左結合性の折り畳みが必要な場合は、代わりに &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `を使用し、 &lt;code&gt;&lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; をマップとして使用します。</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Right a&lt;/code&gt; 値が与えられると、GHCはタイプ &lt;code&gt;Right b&lt;/code&gt; の値を生成する必要があります。 &lt;code&gt;Right&lt;/code&gt; コンストラクターの引数は &lt;code&gt;Either Int a&lt;/code&gt; 型であるため、コードはその上で &lt;code&gt;fmap&lt;/code&gt; を再帰的に呼び出し、 &lt;code&gt;Either Int b&lt;/code&gt; 型の値を生成します。これは、 &lt;code&gt;Right b&lt;/code&gt; 型の最終値を構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">年を考えると、正統派キリスト教の伝統に基づいてイースターを見つける</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">年が与えられた場合、グレゴリオ暦の方法でイースターを見つけてください。</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">1年を与えられたとき、正統派キリスト教の伝統に基づいて、大祭の満月を見つけてください。</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">年が与えられたとき、グレゴリオ式の方法で大祭の満月を見つけてください。</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">任意のアドレスとアライメント制約が与えられた場合、 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; は、アライメント制約を満たす次に高いアドレスを生成します。アラインメント制約 &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; で割り切れるアドレスによって満たされます。この操作はべき等です。</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">任意のアドレスとアライメント制約が与えられた場合、 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; は、アライメント制約を満たす次に高いアドレスを生成します。アラインメント制約 &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; で割り切れるアドレスによって満たされます。この操作はべき等です。</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットが Int 単位で与えられているとき、要素を読み込みます。インデックスは範囲内にあるものとします。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットが Int 単位で与えられたとき、要素を書きます。インデックスは境界内にあるものとします。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="92bd8db55a8df2cebbe00df902cea1d4c45498b3" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">機械語で配列とオフセットが与えられたとき,要素を読み込みます.インデックスは範囲内にあると仮定します.完全なメモリバリアを想定しています.</target>
        </trans-unit>
        <trans-unit id="0feba2d471191afd123d35121507798423702da8" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">機械語で配列とオフセットが与えられたとき,要素を書きます.インデックスは境界内にあると仮定します.完全なメモリバリアを意味します.</target>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列と Int 単位のオフセット、期待される古い値と新しい値が与えられた場合、アトミックな比較とスワップ、つまり現在の値が与えられた古い値と一致する場合に新しい値を書き込みます。つまり、現在の値が指定された古い値と一致した場合に新しい値を書き込みます。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="abab7f85bdf29364faddd13dc4b78d374fc5dda4" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in machine words, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列、機械語でのオフセット、期待される古い値、そして新しい値が与えられた場合、アトミックな比較とスワップ、つまり、現在の値が与えられた古い値と一致する場合に新しい値を書き込みます。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="f0a4380d626de6e7a7cb655bd3acb03a426c4955" translate="yes" xml:space="preserve">
          <source>Given an array, an offset, the expected old value, and the new value, perform an atomic compare and swap (i.e. write the new value if the current value and the old value are the same pointer). Returns 0 if the swap succeeds and 1 if it fails. Additionally, returns the element at the offset after the operation completes. This means that on a success the new value is returned, and on a failure the actual old value (not the expected one) is returned. Implies a full memory barrier. The use of a pointer equality on a lifted value makes this function harder to use correctly than &lt;code&gt;casIntArray#&lt;/code&gt;. All of the difficulties of using &lt;code&gt;reallyUnsafePtrEquality#&lt;/code&gt; correctly apply to &lt;code&gt;casArray#&lt;/code&gt; as well.</source>
          <target state="translated">配列、オフセット、予想される古い値、および新しい値を指定して、アトミックコンペアアンドスワップを実行します（つまり、現在の値と古い値が同じポインターである場合は、新しい値を書き込みます）。スワップが成功した場合は0を返し、失敗した場合は1を返します。さらに、操作が完了した後、オフセットで要素を返します。これは、成功すると新しい値が返され、失敗すると実際の古い値（予期された値ではない）が返されることを意味します。完全なメモリバリアを意味します。持ち上げられた値にポインタの等価性を使用すると、この関数を &lt;code&gt;casIntArray#&lt;/code&gt; よりも正しく使用することが難しくなります。使用しての難しさのすべて &lt;code&gt;reallyUnsafePtrEquality#&lt;/code&gt; を正しくに適用さ &lt;code&gt;casArray#&lt;/code&gt; うまくとして。</target>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、ANDに値を指定すると、その要素に原子的にANDを行います。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とInt単位でのオフセット、NANDへの値が与えられた場合、その値を要素に原子的にNANDします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、ORする値を与えられた場合、その値を要素に原子的にORします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、XORする値が与えられた場合、その値を要素に原子的にXORします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをInt単位で指定し、加算する値を指定すると、その値を要素に原子的に加算します。操作前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列と、Int単位でのオフセットと、減算する値が与えられたとき、その値を要素に原子的に減算します。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="a30e79c6cce3e1df46121660ce9f45643cc0eeab" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットを機械語で指定し、ANDに値を指定すると、要素に原子的に値をANDします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="b1a9ceb938d8f49b5b2ea5c52e2126a50123f314" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットをマシンワードで指定し、NANDへの値を与えられた場合、その値を要素に原子的にNANDします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="0e005649850d5d7a3f7b482df99d3f3969f5374d" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列と機械語でのオフセット、そしてORする値が与えられた場合、その値を要素に原子的にORします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="71007d72dc6db74da700d9af9cc75f192be2766a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセット(機械語でのオフセット)、そしてXORする値が与えられた場合、その値を要素に原子的にXORします。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="a20812dbea90228bd71715ad0ffda8d1cecc9bc0" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列とオフセットを機械語で指定し、加算する値を与えられた場合、その値を要素に原子的に加算します。操作前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="b8efe4a9e8663db39594eab24695687808cdd1d9" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列と、機械語でのオフセットと、減算する値が与えられたとき、その値を要素に原子的に減算します。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="a7a09dd75dcd4a6e149b222b65e998985f3f11b1" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to subtract, atomically subtract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">配列、機械語でのオフセット、減算する値が与えられると、原子的にその値を要素に減算します。演算前の要素の値を返します。完全なメモリバリアを意味します。</target>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">ことを考える &lt;code&gt;Int#&lt;/code&gt; のようなものではない &lt;code&gt;Type&lt;/code&gt; 、それはということになる &lt;code&gt;Maybe Int#&lt;/code&gt; 許可されていません。同様に、型変数は種類が &lt;code&gt;Type&lt;/code&gt; になる傾向があるため（たとえば、 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; 、すべての型変数は種類 &lt;code&gt;Type&lt;/code&gt; を持ちます） 、ポリモーフィズムはプリミティブ型では機能しない傾向があります。これは、多態性関数がそのデータへのポインターを操作する必要があり、ほとんどのプリミティブ型がボックス化されていないため、少し前に戻ります。</target>
        </trans-unit>
        <trans-unit id="b7d26f3c3355ef99d3c40e122cda9ae2f46a3685" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">ことを考える &lt;code&gt;Int#&lt;/code&gt; のようなものではない &lt;code&gt;Type&lt;/code&gt; 、ということになる &lt;code&gt;Maybe Int#&lt;/code&gt; 許可されていません。同様に、型変数は種類 &lt;code&gt;Type&lt;/code&gt; である傾向があるため（たとえば、 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; 、すべての型変数は種類 &lt;code&gt;Type&lt;/code&gt; を持ちます） 、ポリモーフィズムはプリミティブ型では機能しない傾向があります。ポリモーフィック関数はデータへのポインターを操作する必要があり、ほとんどのプリミティブ型はボックス化されていないため、一歩下がると、これはある程度意味があります。</target>
        </trans-unit>
        <trans-unit id="997d69bcb3242b4498d781fc27199701d0a45530" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">ことを考える &lt;code&gt;Int#&lt;/code&gt; のようなものではない &lt;code&gt;Type&lt;/code&gt; 、それはということになる &lt;code&gt;Maybe Int#&lt;/code&gt; 許可されていません。同様に、型変数は種類 &lt;code&gt;Type&lt;/code&gt; である傾向があるため（たとえば、 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; 、すべての型変数は種類 &lt;code&gt;Type&lt;/code&gt; を持ちます） 、ポリモーフィズムはプリミティブ型では機能しない傾向があります。多態的な関数はそのデータへのポインターを操作する必要があり、ほとんどのプリミティブ型はボックス化されていないため、一歩下がると、これはある程度意味があります。</target>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">これが &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; で機能する場合、0回以下の繰り返しを要求すると失敗することが許可され、デフォルトの定義でそれが行われます。</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">これが &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; で機能する場合、0回以下の繰り返しを要求すると失敗することが許可され、デフォルトの定義でそれが行われます。</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">ただし、 &lt;code&gt;Collects&lt;/code&gt; の依存関係情報を考慮すると &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は同じ最初のパラメーター &lt;code&gt;c&lt;/code&gt; を持つ &lt;code&gt;Collects&lt;/code&gt; 制約の2番目のパラメーターとして表示されるため、これらは等しい必要があると推定できます。したがって、 &lt;code&gt;f&lt;/code&gt; のより短くて正確な型を推測できます。</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; の例を &lt;code&gt;/directory/file.ext&lt;/code&gt; ます：/directory/file.ext</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; の例を &lt;code&gt;/directory/file.ext&lt;/code&gt; ます：/directory/file.ext</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">GADT（一般化代数データ型）によって提供される機能を考えると、上記のような定義が実現可能であるかのように見える場合があります。ただし、GADTとは対照的に、タイプファミリーは&lt;em&gt;オープンです。&lt;/em&gt;つまり、新しいインスタンスは常に、おそらく他のモジュールに追加できます。異なるデータインスタンス間のパターンマッチングをサポートするには、拡張可能なケースコンストラクトの形式が必要です。</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">必要な最大サイズとByteStringのコンテンツを作成する関数を指定すると、createAndTrimは &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を作成します。生成関数は実際の最終サイズ（&amp;lt;=最大サイズ）を返す必要があり、結果のバイト配列はこのサイズに再割り当てされます。</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">実行可能ファイルの名前またはパスが指定されると、 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; は、システム定義の場所のリストでそのようなファイルを検索します。これには、通常、 &lt;code&gt;PATH&lt;/code&gt; とそれ以上が含まれます。見つかった場合、実行可能ファイルへのフルパスが返されます。たとえば、 &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; は通常、GHCへのパスを提供します。</target>
        </trans-unit>
        <trans-unit id="779a07f028388c39babdff239bfbe6bdbccb0d49" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a CNF and the address of the root object in the old address space, fix up the internal pointers inside the CNF to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized CNF. It returns the new CNF and the new adjusted root address.</source>
          <target state="translated">CNF の最初のブロックへのポインタと、古いアドレス空間のルートオブジェクトのアドレスが与えられた場合、CNF 内部の内部ポインタを修正して、シリアル化されたときとは異なるメモリ上の位置を考慮します。このメソッドは、シリアル化された CNF をインポートした後に 1 回だけ呼び出す必要があります。これは、新しい CNF と新しい修正されたルートアドレスを返します。</target>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">コンパクトの最初のブロックへのポインタと、古いアドレス空間のルートオブジェクトのアドレスが与えられたら、コンパクトの内部ポインタを修正して、シリアル化された時とは異なるメモリ上の位置を考慮します。このメソッドは、シリアル化されたコンパクトをインポートした後に一度だけ呼び出す必要があり、新しいコンパクトと調整された新しいルートアドレスを返します。</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">この宣言を考えると、以下は整形型と不正型の例です。</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">&lt;code&gt;+RTS -?&lt;/code&gt; 与える-？RTSオプションオプションは、プログラムで実際に使用可能なRTSオプションを出力します（コンパイル方法によって異なります）。</target>
        </trans-unit>
        <trans-unit id="5f413ad57cecf7d60a42e57127f29fc85e597553" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">&lt;code&gt;+RTS -?&lt;/code&gt; 与える-？RTSオプションは、プログラムで実際に使用可能なRTSオプションを出力します（コンパイル方法によって異なります）。</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">クラスメソッドにルールを与えるのはよくないことです。</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskellはシステムを変更しているので、バグが確実にあります。見つけた場合は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;このWikiページ&lt;/a&gt;で報告方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="9429e6f82d8b0009815227447cf86510d9540831" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskellは変化するシステムなので、バグがあるはずです。見つけた場合は、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;このwikiページ&lt;/a&gt;で報告方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">TH ASTの外側にバインドされたグローバルな名前。オリジナルの名前 (バインダーではなく、出現のみ)どの名前を付けているかを確認するために名前空間も必要です。</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">行く&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHCのホームページ&lt;/a&gt;やお使いのプラットフォーム用のGHCをダウンロードするには、「ダウンロード」のリンクをたどります。</target>
        </trans-unit>
        <trans-unit id="08e8e9b3019ee086e1029ecba77f974f0254d0ac" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">&lt;a href=&quot;https://www.haskell.org/ghc/&quot;&gt;GHCホームページに&lt;/a&gt;移動し、「ダウンロード」リンクをたどって、プラットフォームにGHCをダウンロードします。</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#disambiguate-fields&quot;&gt;レコードフィールドの明確化を&lt;/a&gt;参照）を超えて、&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;拡張機能を使用すると、単一のモジュールで同じフィールド名を使用して複数のデータ型を宣言できます。たとえば、次のことが可能です。</target>
        </trans-unit>
        <trans-unit id="fd8103b3ca57eba7600e389128ef13b441bfa079" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;disambiguate_record_fields#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">&lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;disambiguate_record_fields#disambiguate-fields&quot;&gt;レコードフィールドの曖昧性解消を&lt;/a&gt;参照）を超えて、&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;拡張機能を使用すると、単一のモジュールで同じフィールド名を使用して複数のデータ型を宣言できます。たとえば、これを許可します。</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">GHCが機能の展開を許可する最大サイズを管理します。（展開には、呼び出しサイトで展開（つまりインライン化）を展開する「コードの膨張」という観点からのコストを反映する「サイズ」があります。より大きな関数にはより大きなコストが割り当てられます。）</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">グラフアルゴリズム</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">グラフ構築</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">グラフのプロパティ</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">グラフの変換</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">グレゴリオ暦</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">グループには実行権限があります。</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">グループは許可を読み取っています。</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">グループは読み取り、書き込み、実行の権限を持っています。</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">グループは書き込み許可を得ています。</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">グループステートメント（&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; と&lt;/a&gt;同様）：</target>
        </trans-unit>
        <trans-unit id="cac48410fc258274c557fde5ca4a451b62496d73" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;generalised_list_comprehensions#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">グループステートメント（&lt;a href=&quot;generalised_list_comprehensions#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; と&lt;/a&gt;同様）：</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">負の結果値をガード</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">ヌルポインタに対するガード</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">ガードは、 &lt;code&gt;MonadPlus&lt;/code&gt; インスタンスを必要とする &lt;code&gt;guard&lt;/code&gt; 機能で変換されます。</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">失敗する可能性のあるIO操作のためのガード</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Guy Blelloch、Daniel Ferizovic、およびYihan Sun、「&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;」、&lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https：&lt;/a&gt; //arxiv.org/abs/1602.02120v3 。</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">HACKER TERRITORY.ハッカー・テリトリー (あなたは警告された)</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">HOWEVER、これは普通はやりたくないことですよね!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPCは、2種類の主要な方法で両方の種類の情報を表示します。要約統計付きのテキストレポート（ &lt;code&gt;hpc report&lt;/code&gt; ）とカラーマークアップ付きのソース（ &lt;code&gt;hpc markup&lt;/code&gt; ）です。ブールカバレッジの場合、ガード、条件、または修飾子ごとに4つの結果が考えられます。TrueとFalseの両方の値が発生します。 Trueのみ。 Falseのみ。評価されることはありません。 hpc-markupの出力で、黄色の背景で強調表示されている場合は、評価されなかったプログラムの一部を示しています。緑の背景はalways-True式を示し、赤い背景はalways-False式を示します。</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPCは &lt;code&gt;.tix&lt;/code&gt; ファイルをロックしようとしないため、同じディレクトリで同時に実行されている複数のバイナリが競合状態を示します。コンパイル時に、生成された &lt;code&gt;.tix&lt;/code&gt; ファイルの名前を変更する方法はありません。実行時に、生成されたの名前 &lt;code&gt;.tix&lt;/code&gt; のファイルを使用して変更することができます&lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; を&lt;/a&gt;。バイナリの名前を変更すると、 &lt;code&gt;.tix&lt;/code&gt; ファイルの名前も変更されます。HPCはGHCiでは機能しません。</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">HPCインスツルメンテーションは、&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt;フラグで有効になります。</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。たとえば、これは1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="bac1ac628be09ebd8c6adfbc13285eba17cc52c5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="d9f958a5f1fbb1d0920397e7b609d3075db90fac" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば、1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。たとえば、これは1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="845da765199169e6dfadc88839ff4b7a816e8285" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="068b852767faab1bbf8c4dbe2494bdadf3a152aa" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば、1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。たとえば、これは1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素、または &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="a95c580c1b1d21bdccf222c58c09aa34cf85bae5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="29c2e8bc1076e2f1cd73c7f4ca38e5a05845ffbf" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTMLは、HTMLタグ内に有効に配置できるもののクラスです。したがって、これは、たとえば、1つ以上の &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 要素または &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="f2e94df7fe8d889e38c12294978e8d4127ac2604" translate="yes" xml:space="preserve">
          <source>Had we omitted &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt;, we would have ended up with this error:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; を省略した場合、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">エラーを処理します。</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">例外を処理します。</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">ファイルディスクリプタ(FD)で実装された操作を扱う</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">ハンドルのプロパティ</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">読み取りハンドル</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; に使用するハンドル（なし=&amp;gt;既存の &lt;code&gt;stderr&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; に使用するハンドル（なし=&amp;gt;既存の &lt;code&gt;stdin&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; に使用するハンドル（なし=&amp;gt;既存の &lt;code&gt;stdout&lt;/code&gt; を使用）</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">書き込み先のハンドル</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">例外が発生した場合に呼び出されるハンドラ</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">タイプ固有の修飾子の取り扱い</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">Win32 APIを使用したハードリンクの取り扱いについて NTFSのみ</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">信号の取り扱い</target>
        </trans-unit>
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="translated">Win32 APIを使用したシンボリックリンクの取り扱いについて。Vista以降のVistaとデスクトップアプリのみ</target>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">取り扱い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 信号を</target>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 信号を処理する</target>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">取り扱い &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 信号を</target>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファリングされたイベントログデータをイベントログライターに渡します。カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; に&lt;/a&gt;必要です。</target>
        </trans-unit>
        <trans-unit id="a2180742f74260bd275e7151aa4ebb625f061aec" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファリングされたイベントログデータをイベントログライターに渡します。成功するとtrueを返します。カスタム&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; に&lt;/a&gt;必要です。</target>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="translated">ハードリンク名</target>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="translated">ハードリンク</target>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="translated">HasCallStack コールスタック</target>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; にハッシュします。2つの &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; が同じ値にハッシュされる場合がありますが、実際にはこれはありそうにありません。 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; が良いハッシュキーを作る返さ。</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="translated">Haskelineには、ユーザーとの対話の方法が2つあります。</target>
        </trans-unit>
        <trans-unit id="5d92a7b159921baa977febb12420c1df0529b818" translate="yes" xml:space="preserve">
          <source>Haskeline's behavior may be modified by editing your &lt;code&gt;~/.haskeline&lt;/code&gt; file. For details, see: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/CustomKeyBindings&quot;&gt;https://github.com/judah/haskeline/wiki/CustomKeyBindings&lt;/a&gt;</source>
          <target state="translated">Haskelineの動作は、 &lt;code&gt;~/.haskeline&lt;/code&gt; ファイルを編集することで変更できます。詳細については、&lt;a href=&quot;https://github.com/judah/haskeline/wiki/CustomKeyBindings&quot;&gt;https&lt;/a&gt;：//github.com/judah/haskeline/wiki/CustomKeyBindingsを参照してください。</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">Haskell 2010およびHaskell 98では、整数リテラルを10進数、8進数（接頭辞 &lt;code&gt;0o&lt;/code&gt; または &lt;code&gt;0O&lt;/code&gt; ）、または16進表記（接頭辞 &lt;code&gt;0x&lt;/code&gt; または &lt;code&gt;0X&lt;/code&gt; ）で指定できます。</target>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Haskell 2010およびHaskell 98は、 &lt;code&gt;1.2e6&lt;/code&gt; という構文で浮動リテラルを定義します。これらのリテラルの型は、 &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="translated">Haskell 2010 の機能</target>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Haskell 98では、プログラマがデータ型宣言に「 &lt;code&gt;deriving( Eq, Ord )&lt;/code&gt; 」を追加して、 &lt;code&gt;deriving&lt;/code&gt; 句で指定されたクラスの標準インスタンス宣言を生成できます。 Haskell 98では、 &lt;code&gt;deriving&lt;/code&gt; 句に現れる可能性のあるクラスは、標準クラスの &lt;code&gt;Eq&lt;/code&gt; 、 &lt;code&gt;Ord&lt;/code&gt; 、 &lt;code&gt;Enum&lt;/code&gt; 、 &lt;code&gt;Ix&lt;/code&gt; 、 &lt;code&gt;Bounded&lt;/code&gt; 、 &lt;code&gt;Read&lt;/code&gt; 、および &lt;code&gt;Show&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="translated">Haskell 98 では、プログラマはデータ型宣言に派生節を追加して、指定されたクラスの標準インスタンス宣言を生成することができます。GHCはこのメカニズムをいくつかの軸に沿って拡張しています。</target>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="translated">Haskell 98では、クラスを宣言する際にデフォルトの実装を定義することができます。</target>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="translated">Haskell 98では、クラスメソッド型がクラス型変数に対する制約について言及することを禁止しています。</target>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="translated">Haskell 98は4つすべてをあいまいと見なしますが、&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;拡張により、GHCは前者2つを受け入れます。ルールは、Haskell 98のインスタンス宣言のルールとまったく同じです。インスタンス宣言のメソッドバインディングの左側にあるメソッド名は、そのクラスのメソッドを明確に指します（スコープ内にある場合）。 、同じ名前のスコープ内に他の変数がある場合でも。これにより、同じフィールド名を使用する異なるモジュールから2つのレコードをインポートするときの修飾名の乱雑さが減少します。</target>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、C printfで使用されるデフォルトの「6桁」の精度を決して使用しません。</target>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、不要なプラス記号なしで、可能な最小桁数でe形式の数値の指数を出力します。</target>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、「精度」指定子を小数点以下の桁数を示すものとして扱います。</target>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; は、可能な場合、小数点の後にゼロを配置します。</target>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="translated">Haskell では、データ型にコンテキストを与えることができます。</target>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="translated">ハスケルコンパイラ</target>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="translated">Haskellは、タイプ &lt;code&gt;Handle&lt;/code&gt; の値によって表される、ファイルから文字を読み書きする操作を定義します。このタイプの各値は&lt;em&gt;ハンドル&lt;/em&gt;です。HaskellランタイムシステムがファイルシステムオブジェクトとのI / O を&lt;em&gt;管理するため&lt;/em&gt;に使用するレコードです。ハンドルには少なくとも次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="translated">プロンプトでHaskell式を入力することができます。</target>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="translated">ハスケルファイル</target>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="translated">Haskell識別子、たとえば &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;Baz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="translated">Haskellは各型変数の種類を推測します。関数に型シグネチャを付けるのと同じように、（マシンチェック済みの）ドキュメントとして明示的に種類を指定できると便利な場合があります。場合によっては、そうすることが不可欠です。たとえば、彼の論文「Haskellの制限付きデータ型」（Haskell Workshop 1999）では、John Hughesがデータ型を定義する必要がありました。</target>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="translated">Haskell lexer:lexemeではなくlexed文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="translated">Haskellライブラリの作者には選択の余地があります。ほとんどの人は安全な推論を使うべきです。言語の安全でない機能を回避したと仮定すると、あなたのモジュールは安全とマークされます。推論と明示的推論には次のようなトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="translated">Haskellは、強力な型システムと、 &lt;code&gt;IO&lt;/code&gt; モナドによる純粋な機能と効果的な機能の分離を提供します。ただし、型システムにはいくつかのループホールがあります。最も明らかなのは、 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; functionです。 Safe Haskellの安全な言語方言は、そのような関数の使用を許可していません。これは、Haskellコードの分析と推論を容易にするため、便利な制限になる場合があります。また、絶対に必要でない限り、危険な機能を回避しようとするHaskellコミュニティの既存の文化を体系化します。したがって、（- &lt;code&gt;-XSafe&lt;/code&gt; フラグを介して）安全な言語を使用することは、 &lt;code&gt;-Wall&lt;/code&gt; の機能と同様に、優れたスタイルを適用する方法と考えることができます。</target>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="translated">Haskellは、インデックス可能な&lt;em&gt;配列を&lt;/em&gt;提供し&lt;em&gt;ます&lt;/em&gt;。これは、ドメインが整数の連続したサブセットに同型である関数と考えることができます。このように制限された機能は効率的に実装できます。特に、プログラマーはコンポーネントへの迅速なアクセスを合理的に期待できます。このような実装の可能性を保証するために、配列は一般的な関数としてではなく、データとして扱われます。</target>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 値のHaskell表現。実装は意図的に公開されており、ユーザーは &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 値の独自の定義を追加できます。</target>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 値のHaskell表現</target>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="translated">Haskellのソースファイルはコマンドラインで名前を指定することができ、対話型モードとまったく同じようにロードされます。式はロードされたモジュールのコンテキストで評価されます。</target>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="translated">Haskellは、モジュール &lt;code&gt;M&lt;/code&gt; をコンパイルするときに、 &lt;code&gt;M&lt;/code&gt; の「下」にあるモジュールのインスタンス宣言がすべて表示されるように指定しています。（モジュール &lt;code&gt;A&lt;/code&gt; は、「下」である &lt;code&gt;M&lt;/code&gt; あれば &lt;code&gt;A&lt;/code&gt; はによって直接輸入された &lt;code&gt;M&lt;/code&gt; 場合、または &lt;code&gt;A&lt;/code&gt; がモジュールを下回っていると &lt;code&gt;M&lt;/code&gt; の直接輸入。）原則的には、GHCは、したがって、以下のすべてのモジュールのインタフェースファイル読まなければなら &lt;code&gt;M&lt;/code&gt; をそれらに含ま念のために、 &lt;code&gt;M&lt;/code&gt; にとって重要なインスタンス宣言。これは実際には災害になるので、GHCは賢くなろうとします。</target>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="translated">Haskellシンボル、例えば &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;:%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="translated">Haskellスレッドとオペレーティングシステムスレッド</target>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="translated">Haskellスレッドは、同期可能な可変変数の一種である &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; を介して通信できます（&lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVarを&lt;/a&gt;参照）。 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; からいくつかの一般的な同時実行抽象化を構築でき、これらは&lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;ライブラリによって提供されます。GHCでは、スレッドは例外を介して通信することもできます。</target>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;FILE&lt;/code&gt; タイプを表すHaskellタイプ。</target>
        </trans-unit>
        <trans-unit id="c52c7986de5b1f1002d0a36e02ab2dcd634cb9aa" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">HaskellはCを表す入力 &lt;code&gt;FILE&lt;/code&gt; タイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;bool&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="79c49075305812472dc2df8b13ecac0efe944296" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;bool&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;char&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="f25580ef2a6155308670fc91ba09e1731599c485" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;char&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;clock_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="be18749c4ec22337441649343d257d0370d5f71d" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cを表すHaskellのタイプ &lt;code&gt;clock_t&lt;/code&gt; のタイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;double&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="b2d34f9c0e00a8d1af686c82fb43c8d820dc5922" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;double&lt;/code&gt; タイプを表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;float&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="1c49950cb050a7da15661bd7e456a284ef08804b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;float&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;fpos_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="ebe2bccc8d0a138a668828ba79fe80867499c2cf" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;fpos_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;int&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="0c7bc99c01a214a0469bc841c3db1a8545153961" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">HaskellはCの表現型 &lt;code&gt;int&lt;/code&gt; 型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3f56417f539bd18bca6bfc77eae899aa9f4a159" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">HaskellはCの表現型 &lt;code&gt;int&lt;/code&gt; 型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ecaafcc8282e441e1b10f5ce390edc54ce196b7b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">HaskellはCの表現型 &lt;code&gt;int&lt;/code&gt; 型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;jmp_buf&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="9f0b2e804cd5163bf59ec18f25ed125a68b853e7" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;jmp_buf&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="5e4fc6d51b08d08bf0bcba3ee05d06de32a72f6f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;long long&lt;/code&gt; タイプを表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="050743a39470101ce4c3aaee27cdf563c19fb3e4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; タイプを表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c697d88169811a5419d372898d0902231691a627" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; タイプを表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b7d113d99751c0327aea4d8129f5aed9f4e0a54" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; タイプを表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="translated">C &lt;code&gt;ptrdiff_t&lt;/code&gt; タイプを表すHaskellタイプ。</target>
        </trans-unit>
        <trans-unit id="dbd3c68fb579759e59f8406834e1d8e6ff601638" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;ptrdiff_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;short&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="5b8524f5a4f304e126b6b8a367dfaecb35880702" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;short&lt;/code&gt; 表すHaskellタイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;sig_atomic_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="f3fa5599c0fc034cd4f240400ef25ab1428a1102" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;sig_atomic_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;signed char&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="81af0438927840f3b83280a00faeb91e716cbe5a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;signed char&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;size_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="178d1b8d5a62b7a3369b736f6da7852035c7e2ba" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cを表すHaskellの型 &lt;code&gt;size_t&lt;/code&gt; 型のタイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;suseconds_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="fe2ceebfe4035ae5db79a948b4348c1b6a632760" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;suseconds_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;time_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="47fddfc3c7f8cfce68e214eb884c6dbf75a02426" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;time_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d3fb605ae26da7c3d0a135bfcd2f78e6e2034da" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;time_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13ec168e35067e10a3716ba2d1e66444d65a0d79" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;time_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned char&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="ba250403e40dc5a5fe395ae550e60698ea8a63db" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned char&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9eb8343caaab2beb4ac0d546b8d967b0cf6d7e9" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned char&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba16416656c8c1c9c85455bf689f834b7cb3e7a3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned char&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned int&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="61828b7780ff4e1e0e7f03ddf27e366de45f4b08" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned int&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned long long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="180a5fcc065de54f77fac57594eab1aba819d926" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">C &lt;code&gt;unsigned long long&lt;/code&gt; longlong型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned long&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="8e9fa8fbdf77f67a6bcf25da092f95906229af86" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned long&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dd0ef50fe966caf58fdafd5fd9a2a9f2c9ca774" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned long&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="388c8c93c58b5915ed0bbd05b942d6bcdbd88ea2" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned long&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;unsigned short&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="0a6c68ad3241c76347c98ebc10b0631bbe19f4b1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned short&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03ce92d4eb17447ddbcf73101965e50898bc48e1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned short&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d9d916e0cff4b8f444a4bb2b23b5595b6e4e0a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cの &lt;code&gt;unsigned short&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;useconds_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="7b0bee0937b5c01758b70e929129631f1bb26b33" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;useconds_t&lt;/code&gt; 型を表すHaskell型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="translated">Cの &lt;code&gt;wchar_t&lt;/code&gt; 型を表すHaskell型。</target>
        </trans-unit>
        <trans-unit id="1342a24a0d486add6662622e572d9396963bb62c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cを表すHaskellのタイプ &lt;code&gt;wchar_t&lt;/code&gt; タイプ。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f93ae47678063b8a45836d467ebed96592553f99" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cを表すHaskellのタイプ &lt;code&gt;wchar_t&lt;/code&gt; タイプ。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f95906d00942f31be1d4b6bbf300429b06aed957" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Cを表すHaskellのタイプ &lt;code&gt;wchar_t&lt;/code&gt; タイプ。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C。Types&lt;/a&gt;の具体的なタイプは、プラットフォーム固有です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="translated">Haskellの型シグネチャは暗黙的に数量化されます。言語オプション&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;を使用する場合、キーワード &lt;code&gt;forall&lt;/code&gt; を使用すると、これが何を意味するかを正確に言うことができます。例えば：</target>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="translated">Haskellの &lt;code&gt;Maybe&lt;/code&gt; 、 &lt;code&gt;[]&lt;/code&gt; （リスト）、 &lt;code&gt;ST&lt;/code&gt; （厳密バージョンと遅延バージョンの両方）、 &lt;code&gt;IO&lt;/code&gt; 、および他の多くのモナドには、 &lt;code&gt;MonadFix&lt;/code&gt; インスタンスがあります。否定的な側面では、署名 &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt; a- &amp;gt; r）-&amp;gt; rをもつ継続モナドはそうではありません。</target>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">Hasloadedのデフォルトメカニズム（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskellレポート、セクション4.3.4&lt;/a&gt;）は、&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;が指定されている場合、文字列リテラルをカバーするように拡張されています。具体的には：</target>
        </trans-unit>
        <trans-unit id="c1f77f60f386e1b60cf61287fb2f0557f2270da6" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;が指定されている場合、Haskellのデフォルトメカニズム（&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskellレポート、セクション4.3.4&lt;/a&gt;）は、文字列リテラルをカバーするように拡張されています。具体的には：</target>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">Haskellのモノモーフィズム制限（Haskellレポートの&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;セクション4.5.5&lt;/a&gt;を参照）は、&lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt;によって完全にオフにすることができます。GHC 7.8.1以降、GHCiの対話型オプションでは、単相性制限がデフォルトでオフになっています（&lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;対話型評価のみのオプションの設定を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5d1fdf6d2d3b7d2e00bf3ab7baeeeb13e6c14542" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;../ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">Haskellの単&lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt;制限（Haskellレポートの&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;セクション4.5.5&lt;/a&gt;を参照）は、NoMonomorphismRestrictionによって完全にオフに切り替えることができます。GHC 7.8.1以降、GHCiのインタラクティブオプションでは、デフォルトで単相制限がオフになっています（&lt;a href=&quot;../ghci#ghci-interactive-options&quot;&gt;インタラクティブ評価のオプションの設定のみを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="translated">Haskellの（型クラスを使用した）オーバーロードは、エレガントで端正なものなどですが、内側のループに残っているとパフォーマンスが低下します。どうやってそれをつぶすことができますか？</target>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="translated">memcpy と memmove のための Haskellish インターフェイス</target>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="translated">コンパイラが型署名の重複制約について警告するようにします。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="translated">エクスポートリストの重複エントリについてコンパイラに警告させます。これは、大きなエクスポートリストを維持していて、エクスポートリストでその定義についての（1つの）言及を削除した後で、定義のエクスポートが続行されないようにする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="translated">型署名の冗長な制約についてコンパイラが警告するようにします。特に</target>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="translated">型署名の冗長な制約についてコンパイラが警告するようにしました。</target>
        </trans-unit>
        <trans-unit id="624af9c99c0374959007cf34d186babd80bc825f" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</source>
          <target state="translated">kind変数が明示的に定量化されていない場合にコンパイラが警告を出すようにしました。例えば、以下のようにすると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="ab484e4e512db8b5ca27e756ef1e8419b9d72451" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">プレリュードが暗黙的にインポートされた場合、コンパイラーに警告させます。これは、Preludeモジュールが &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行で明示的にインポートされるか、この暗黙的なインポートが無効にされていない限り発生します（&lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; プラグマのいずれかによって）。</target>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Preludeが暗黙的にインポートされた場合にコンパイラーに警告させます。これは、Preludeモジュールが &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行で明示的にインポートされるか、この暗黙のインポートが（&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; プラグマによって）無効にされない限り発生します。</target>
        </trans-unit>
        <trans-unit id="27968fc346539074eff95309c304b2956773d765" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">プレリュードが暗黙的にインポートされた場合、コンパイラーに警告させます。これは、Preludeモジュールが &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行で明示的にインポートされるか、この暗黙的なインポートが無効にされていない限り発生します（&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; プラグマのいずれかによって）。</target>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="translated">ソースファイルにタブがある場合は、コンパイラが警告するようにします。</target>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="translated">Haskell 単相性制限が適用されているソースのどこで適用されているかをコンパイラが警告/通知するようにしてください。静かに適用された場合、MRは予期せぬ動作をする可能性があるので、適用されていることを明示的に警告しておくと便利です。</target>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="translated">ソースのどこで数値型のHaskellデフォルトメカニズムが作動するかをコンパイラに警告/通知させます。これは、あるデフォルトを想定するコンテキストから別のデフォルトに変換するときの有用な情報です。たとえば、Haskell 1.4の「デフォルトデフォルト」それ以外の場合は制約されていない値 &lt;code&gt;1&lt;/code&gt; に型 &lt;code&gt;Int&lt;/code&gt; が指定されたのに対し、Haskell 98以降ではデフォルトで &lt;code&gt;Integer&lt;/code&gt; に設定されていました。これは、パフォーマンスと動作の違いにつながる可能性があります。そのため、これについて沈黙しないことが有用です。</target>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="translated">プロファイリング用のプログラムをコンパイルしたら、それを実行してプロファイルを生成する必要があります。たとえば、 &lt;code&gt;+RTS -p&lt;/code&gt; （&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; を&lt;/a&gt;参照）を指定してプログラムを実行することにより、単純な時間プロファイルを生成できます。これにより、 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; という名前のファイルが生成されます。ここで、「&lt;em&gt;prog&lt;/em&gt;」は&lt;em&gt;プログラム&lt;/em&gt;の名前です（拡張子 &lt;code&gt;.exe&lt;/code&gt; なし）。 Windowsを使用している場合）。</target>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="translated">プログラムを実行すると、カバレッジのテキストサマリーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="translated">そうは言っても、浮動小数点の状態に関してGHCが&lt;em&gt;行うことを&lt;/em&gt;正確に文書化&lt;em&gt;できる&lt;/em&gt;ので、実際に &lt;code&gt;fenv.h&lt;/code&gt; を使用する必要がある場合は、落とし穴を完全に理解した上で行うことができます。</target>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="translated">文字列の先頭と末尾が substring で壊れている</target>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="translated">ヒープの断片化</target>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="91941c1b4095a524d9c0188d1f8462dec66fa124" translate="yes" xml:space="preserve">
          <source>Helper function for use with &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;system-win32#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt; で使用するヘルパー関数。 &lt;code&gt;&lt;a href=&quot;system-win32#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="41f533117fa2d214d2d4af0738714b822a616f1a" translate="yes" xml:space="preserve">
          <source>Helper function for use with &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt; で使用するヘルパー関数。 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">ヘルパー機能</target>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 実装として使用するために &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; を完全に評価するヘルパー</target>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;NFData(rnf)&lt;/code&gt; 実装として使用するために &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; を完全に評価するヘルパー</target>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;NFData(rnf)&lt;/code&gt; 実装として使用するために完全に評価するヘルパー</target>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="translated">&lt;code&gt;RealFloat&lt;/code&gt; タイプクラス操作のヘルパー</target>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="translated">ラッパー」関数を定義するためのヘルパー</target>
        </trans-unit>
        <trans-unit id="33e68482b8b4a3fe1a21b55aefcc8006aa58be9d" translate="yes" xml:space="preserve">
          <source>Hence the linearity of type constructors is invisible when &lt;code&gt;-XLinearTypes&lt;/code&gt; is off.</source>
          <target state="translated">したがって、 &lt;code&gt;-XLinearTypes&lt;/code&gt; がオフの場合、型コンストラクターの線形性は見えません。</target>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="translated">したがって、元の式には &lt;code&gt;Show&lt;/code&gt; クラスのインスタンスである型が必要です。そうでない場合、GHCiは文句を言います。</target>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="translated">ここで、 &lt;code&gt;A&lt;/code&gt; は &lt;code&gt;B&lt;/code&gt; をインポートしますが、 &lt;code&gt;B&lt;/code&gt; は &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; プラグマを使用して &lt;code&gt;A&lt;/code&gt; をインポートします。これにより、循環依存が解除されます。モジュールインポートグラフのすべてのループは、 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; インポートによって中断する必要があります。または、 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; インポートが無視される場合、同等に、モジュールインポートグラフは非循環的である必要があります。</target>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="translated">ここで &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;D&lt;/code&gt; の定義があいまいですが、後で型アプリケーションを使用して &lt;code&gt;Int&lt;/code&gt; と指定されています。</target>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;c&lt;/code&gt; と &lt;code&gt;a&lt;/code&gt; はクラスパラメーターですが、型には3番目のパラメーター &lt;code&gt;x&lt;/code&gt; でもインデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="translated">ここで、 &lt;code&gt;f1&lt;/code&gt; はパターン同義語を使用しません。数値パターン &lt;code&gt;42&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;照合&lt;em&gt;するには&lt;/em&gt;、呼び出し元が制約 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; を満たす&lt;em&gt;必要が&lt;/em&gt;あるため、これらは &lt;code&gt;f1&lt;/code&gt; の型に表示されます。 &lt;code&gt;show&lt;/code&gt; を呼び出すと、 &lt;code&gt;(Show b)&lt;/code&gt; 制約が生成されます。ここで、 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;MkT&lt;/code&gt; のパターンマッチによってバインドされた実存型の変数です。しかし、同じパターンマッチは制約 &lt;code&gt;(Show b)&lt;/code&gt; （ &lt;code&gt;MkT&lt;/code&gt; のタイプを参照）も&lt;em&gt;提供&lt;/em&gt;するため、すべて順調です。</target>
        </trans-unit>
        <trans-unit id="4b59b8aee2721ff8de102981e018fa8f69756fd0" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;rsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;rsquo;s type), and so all is well.</source>
          <target state="translated">ここで、 &lt;code&gt;f1&lt;/code&gt; はパターンシノニムを使用しません。数値パターン &lt;code&gt;42&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;照合&lt;em&gt;するには&lt;/em&gt;、呼び出し元が制約 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; を満たす&lt;em&gt;必要が&lt;/em&gt;あるため、 &lt;code&gt;f1&lt;/code&gt; の型で表示されます。 &lt;code&gt;show&lt;/code&gt; を呼び出すと、 &lt;code&gt;(Show b)&lt;/code&gt; 制約が生成されます。ここで、 &lt;code&gt;b&lt;/code&gt; は、 &lt;code&gt;MkT&lt;/code&gt; のパターンマッチによってバインドされた既存の型変数です。ただし、同じパターンマッチでも制約が&lt;em&gt;提供さ&lt;/em&gt;れるため &lt;code&gt;(Show b)&lt;/code&gt; （ &lt;code&gt;MkT&lt;/code&gt; のタイプを参照）、すべて問題ありません。</target>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="translated">ここで、 &lt;code&gt;f&lt;/code&gt; には自由変数がないため一般化されています。そして、その結合グループは、単形性制限の影響を受けません。したがって、 &lt;code&gt;f&lt;/code&gt; は閉じています。同じ理由が &lt;code&gt;g&lt;/code&gt; にも当てはまりますが、1つの閉じた自由変数、つまり &lt;code&gt;f&lt;/code&gt; がある点が異なります。同様に、 &lt;code&gt;h&lt;/code&gt; は&lt;em&gt;、最上位でバインドされていなくても&lt;/em&gt;閉じられ&lt;em&gt;ています。これは&lt;/em&gt;、自由変数 &lt;code&gt;f&lt;/code&gt; だけが閉じているためです。しかし、 &lt;code&gt;k&lt;/code&gt; は閉じられていません。閉じられていない &lt;code&gt;x&lt;/code&gt; について言及しているからです（これは束縛されないためです）。</target>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; も &lt;code&gt;U&lt;/code&gt; も両方のフィールドを持たないため、ここで &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; を更新している必要があります。</target>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">ここで &lt;code&gt;h&lt;/code&gt; の型は &lt;code&gt;b&lt;/code&gt; で曖昧に見えますが、これは正当な呼び出しです：</target>
        </trans-unit>
        <trans-unit id="b246caf870407f889ea8871b1250446e1716fa4c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;rsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">ここで、 &lt;code&gt;h&lt;/code&gt; のタイプは &lt;code&gt;b&lt;/code&gt; であいまいに見えますが、これが合法的な呼び出しです。</target>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">ここでは &lt;code&gt;strange&lt;/code&gt; の型があいまいですが、 &lt;code&gt;(D Bool b)&lt;/code&gt; インスタンスによって可溶化される制約 &lt;code&gt;(D Bool beta)&lt;/code&gt; が発生するため、 &lt;code&gt;foo&lt;/code&gt; での呼び出しはOKです。</target>
        </trans-unit>
        <trans-unit id="49cd73f3d29efb220092644a24b1f6c41bca4225" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;rsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">ここでは、 &lt;code&gt;strange&lt;/code&gt; の型はあいまいですが、 &lt;code&gt;foo&lt;/code&gt; での呼び出しは、 &lt;code&gt;(D Bool b)&lt;/code&gt; インスタンスによって解決可能な制約 &lt;code&gt;(D Bool beta)&lt;/code&gt; を発生させるため、問題ありません。</target>
        </trans-unit>
        <trans-unit id="b6ba1a7dafa5579565589aa356bfba3be0d761be" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. See &lt;a href=&quot;field_selectors_and_type_applications#field-selectors-and-type-applications&quot;&gt;Field selectors and TypeApplications&lt;/a&gt; for a full description of how the types of top-level field selectors are determined.</source>
          <target state="translated">ここで、 &lt;code&gt;tag&lt;/code&gt; はパブリックフィールドであり、適切に型指定されたセレクター関数 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; ます。トップレベルのフィールドセレクターのタイプがどのように決定されるかの完全な説明については、&lt;a href=&quot;field_selectors_and_type_applications#field-selectors-and-type-applications&quot;&gt;フィールドセレクターとTypeApplications&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">ここで、 &lt;code&gt;tag&lt;/code&gt; はパブリックフィールドであり、適切に型指定されたセレクター関数 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; ます。 &lt;code&gt;self&lt;/code&gt; タイプは外部から隠されています。関数として &lt;code&gt;_this&lt;/code&gt; 、 &lt;code&gt;_inc&lt;/code&gt; または &lt;code&gt;_display&lt;/code&gt; を適用しようとすると、コンパイル時エラーが発生します。言い換えると、&lt;em&gt;GHCは、型が実存的に定量化された変数に言及していないフィールドに対してのみ、レコードセレクター関数を定義します&lt;/em&gt;。（この例では、レコードセレクターが定義されないフィールドにアンダースコアを使用しましたが、これはプログラミングスタイルにすぎません。GHCはそれらを無視します。）</target>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="translated">ここで、 &lt;code&gt;x&lt;/code&gt; とパターンバインディング &lt;code&gt;(y,z)&lt;/code&gt; は遅延したままです。理由：最初に使用するまで、強制する良い瞬間はありません。</target>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="translated">ここで、GHCは、その発現を</target>
        </trans-unit>
        <trans-unit id="8aae455f693e348fa5efeaf4591aa259e2a42cf5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;../using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">ここで、GHCはトップレベルインスタンスからの制約 &lt;code&gt;(C c Int)&lt;/code&gt; を解決しません。これは、 &lt;code&gt;g&lt;/code&gt; の特定の呼び出しが、 &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; の両方を同じ型にインスタンス化する可能性があるためです。これにより、制約を別の方法で解決できます。この後者の制限は、主に制約ソルバーを完全にするためのものです。 （興味のある人は、 &lt;code&gt;TcInteract&lt;/code&gt; の &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; を読むことができます。）回避するのは簡単です。型シグネチャでは、トップレベルのインスタンスに一致する制約を回避します。フラグ&lt;a href=&quot;../using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; &lt;/a&gt;、そのようなシグニチャについて警告します。</target>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">ここでGHCは最上位のインスタンスからの制約 &lt;code&gt;(C c Int)&lt;/code&gt; を解決しません。これは、 &lt;code&gt;g&lt;/code&gt; の特定の呼び出しが &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; の両方を同じタイプにインスタンス化し、異なる方法で制約を解決できるためです。この後者の制限は、主に制約ソルバーを完全にすることです。（興味のある人は &lt;code&gt;TcInteract&lt;/code&gt; の &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; を読むことができます。）簡単に回避できます。型シグネチャでは、最上位のインスタンスに一致する制約を回避します。フラグ&lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; は&lt;/a&gt;、このような署名について警告します。</target>
        </trans-unit>
        <trans-unit id="9bff69b808219fe13e775152f4fa8840242e7911" translate="yes" xml:space="preserve">
          <source>Here again, the &lt;code&gt;unsafeCoerce HRefl&lt;/code&gt; is safe, because the two types really are the same -- but the proof of that relies on the complex, trusted implementation of &lt;code&gt;Typeable&lt;/code&gt;.</source>
          <target state="translated">ここでも、 &lt;code&gt;unsafeCoerce HRefl&lt;/code&gt; は安全です。これは、2つのタイプが実際には同じであるためですが、その証明は、 &lt;code&gt;Typeable&lt;/code&gt; の複雑で信頼できる実装に依存しています。</target>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="translated">次に、 &lt;code&gt;filepath&lt;/code&gt; 関数を一緒に使用するいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="translated">ここでは、許容可能なタイプと違法なタイプの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="translated">この翻訳がどのように機能するか、いくつかの例を紹介します。各シーケンスの最初の式はHaskellソースで、それ以降の式はCoreです。</target>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="translated">上記の表現の使用例をいくつか示します。次のようにエンコードされた &lt;code&gt;Type&lt;/code&gt; ユニバースのいくつかのタイプを考えます。</target>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="translated">ここでは、その性質を説明する例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">ここでは、いくつかの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="translated">ここでは、いくつかのエクスポートリストとその意味を紹介します。</target>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="translated">以下、詳細をご紹介します。</target>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="translated">ここでは、再帰的do記法を使用する際の他の重要なポイントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Functor&lt;/code&gt; と &lt;code&gt;Foldable&lt;/code&gt; 用に生成されたコードの違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="translated">それぞれの拡張機能で生成されたコードの違いをご紹介します。</target>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="translated">主な定義は &lt;code&gt;GHC.Exts&lt;/code&gt; とおりです。すべてGHC.Extsから入手できます。</target>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="translated">顕著な特徴は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="translated">ここでは、プロパティに従ってください。</target>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="translated">このファイルの構文を簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="translated">再帰的な場合は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="translated">以下は、ほとんどすべてのメタ情報が削除された &lt;code&gt;Tree&lt;/code&gt; の縮小表現です。ここでは、最も重要な側面のみを保持しています。</target>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="translated">ここでは、簡単な(といっても、工夫された)例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="translated">ここでは、単純な非再帰的なケースを紹介します。</target>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="translated">次に &lt;code&gt;mdo&lt;/code&gt; 式の例と、 &lt;code&gt;rec&lt;/code&gt; ブロックへの変換を示します。</target>
        </trans-unit>
        <trans-unit id="0b2a7e6f45cd62f2ccce2503e6f62a2ed13efd54" translate="yes" xml:space="preserve">
          <source>Here is an example of a constrained kind:</source>
          <target state="translated">制約のある種類の例です。</target>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="translated">ここでは、SCCをいくつか導入したプログラムの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;Lift&lt;/code&gt; を導出する方法の例です。</target>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="translated">これを実際に行った例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="translated">ここでは、型レベルの数値リテラルを使用して、低レベル関数への安全なインタフェースを提供する例を示します。</target>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="translated">ここでは、型レベルの文字列リテラルを使用して単純なレコード操作をシミュレートする例を示します。</target>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">ここでは、カスタムの使用を示す例である &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; とデータ型 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; から例外メカニズム &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; は。この例では、ユーザーが空の文字列または5文字を超える文字列を入力した場合に例外がスローされます。それ以外の場合は、文字列の長さを出力します。</target>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">ここでカスタムエラーデータ型の使用を示す例である &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; から例外メカニズム &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; は。この例では、ユーザーが空の文字列または5文字を超える文字列を入力した場合に例外がスローされます。それ以外の場合は、文字列の長さを出力します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">&lt;a href=&quot;#type-level-literals&quot;&gt;タイプレベルリテラル&lt;/a&gt;のレコードアクセスの例の拡張は、オーバーロードされたラベルをレコードセレクターとして使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b0f4ccad59f2861039a9d7d73c030287198bf734" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;type_literals#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">これは、&lt;a href=&quot;type_literals#type-level-literals&quot;&gt;タイプレベルリテラル&lt;/a&gt;のレコードアクセス例の拡張であり、オーバーロードされたラベルをレコードセレクターとして使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="translated">この例では、このようなことをしています。</target>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="translated">ここで &lt;code&gt;Eq [a]&lt;/code&gt; の最上位インスタンスと署名重複に &lt;code&gt;Eq [a]&lt;/code&gt; 。GHCは前者を使用するためにいくつかの努力をしますが、後者を使用する必要がある場合、それは不溶性の &lt;code&gt;Eq a&lt;/code&gt; 制約を持ちます。代わりに次のように書くことで回避するのが最善です。</target>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="translated">ここで &lt;code&gt;(==)&lt;/code&gt; を呼び出すと、GHCは &lt;code&gt;(Eq a)&lt;/code&gt; 制約が必要であると判断し、警告は発行されません。</target>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="translated">ここでは、タイプ変数 &lt;code&gt;t&lt;/code&gt; がタイプファミリーアプリケーションの下にのみ表示され、あいまいであるため、 &lt;code&gt;id&lt;/code&gt; の定義は拒否されます。しかし、 &lt;code&gt;Id&lt;/code&gt; が単射であることをGHCに伝えれば、このコードは受け入れられます。つまり、引数のタイプから呼び出しサイトで &lt;code&gt;t&lt;/code&gt; を推測することが可能になります。</target>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="translated">ここでは、インスタンス宣言のシグネチャは、インスタンス化されたクラス・メソッドで必要とされるシグネチャよりも多相性が高いです。</target>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="translated">ここでスーパークラスサイクルは終了しますが、終了することを確認することは完全に簡単ではありません。</target>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="translated">ここでは、式の型署名を内側に押し込んで、fの型署名を与えることができます。同様に、より一般的には、関数自体の型署名を与えることができます。</target>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">ここで、型変数 &lt;code&gt;a&lt;/code&gt; はどちらのコンストラクタの結果型にも現れません。それはコンストラクタの型で普遍的に数量化されますが、そのような型変数はしばしば「存在」と呼ばれます。実際、上記の宣言は、&lt;a href=&quot;#existential-quantification&quot;&gt;実存的に定量化されたデータコンストラクターの&lt;/a&gt; &lt;code&gt;data Foo&lt;/code&gt; とまったく同じ型を宣言しています。</target>
        </trans-unit>
        <trans-unit id="23c5e15c682df3cf657d8a315cea937ab5938c48" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;existential_quantification#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">ここで、型変数 &lt;code&gt;a&lt;/code&gt; は、どちらのコンストラクターの結果型にも表示されません。コンストラクターの型で全称記号化されますが、そのような型変数はしばしば「存在」と呼ばれます。実際、上記の宣言は、&lt;a href=&quot;existential_quantification#existential-quantification&quot;&gt;存在記号データコンストラクターの&lt;/a&gt; &lt;code&gt;data Foo&lt;/code&gt; とまったく同じ型を宣言しています。</target>
        </trans-unit>
        <trans-unit id="7055c1ade07b4400baffd8a9bc31bf6ec6a1358e" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on #14998.)</source>
          <target state="translated">ここで、ユニバーサル型変数 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の定義を対象としていますが、実存的 &lt;code&gt;b&lt;/code&gt; は対象外です。（＃14998の議論を参照。）</target>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="translated">ここで、汎用型変数 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の定義にスコープしますが、存在 &lt;code&gt;b&lt;/code&gt; はスコープしません。（Trac＃14998に関する議論を参照してください。）</target>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="translated">ここでは、インスタンス</target>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="translated">ここでは &lt;code&gt;w&lt;/code&gt; に型シグネチャを与える必要はありません。これはコンストラクター &lt;code&gt;T1&lt;/code&gt; の引数であり、GHCに知る必要があるすべてのことを伝えるためです。</target>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="translated">ここでは、2つのデータインスタンス宣言を示しています。1つは最後のパラメーターが &lt;code&gt;[v]&lt;/code&gt; で、もう1つは &lt;code&gt;Int&lt;/code&gt; です。 &lt;code&gt;(GMap Flob ...)&lt;/code&gt; の&lt;em&gt;後続の&lt;/em&gt;インスタンスを与えることはできないため、この機能は、空きインデックス付きパラメーターが（ &lt;code&gt;Type&lt;/code&gt; とは異なり）有限数の選択肢を持つ種類である場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="translated">ここでは、ランタイムシステムの &lt;code&gt;-V0&lt;/code&gt; オプションを使用して、デバッグセッションに干渉する可能性のあるRTSの定期タイマーを無効にしています。プログラムに侵入すると、 &lt;code&gt;gdb&lt;/code&gt; は、現在の実行ポイントに対応するソースプログラム内の場所を示します。</target>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="translated">ここでは、 &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; インスタンスを使用します。</target>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="translated">ここで、スタックトレースの最初のビットに、アドレス &lt;code&gt;0x006eb0c0&lt;/code&gt; にある不明なスタックフレームが多数あることがわかります。この場所について &lt;code&gt;gdb&lt;/code&gt; に尋ねると、これらのフレームは実際にはSTG更新クロージャであることがわかります。</target>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">ここでは、 &lt;code&gt;calculateLength&lt;/code&gt; を使用して、結果を &lt;code&gt;print&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="translated">ここでは、&lt;a href=&quot;#class-default-signatures&quot;&gt;デフォルトの署名&lt;/a&gt;を使用して、インスタンス化する型の &lt;code&gt;Generic&lt;/code&gt; インスタンスがある限り、ユーザーが &lt;code&gt;put&lt;/code&gt; の実装を提供する必要がないことを指定します。たとえば、 &lt;code&gt;UserTree&lt;/code&gt; タイプの場合、ユーザーは次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="translated">ここでは、生成されたバイナリにデバッグ情報を追加する必要があることをGHCに通知するために &lt;code&gt;-g&lt;/code&gt; オプションを使用しました。デバッグ出力には3つのレベルがあります。 &lt;code&gt;-g0&lt;/code&gt; （デバッグ情報なし、デフォルト）、- &lt;code&gt;-g1&lt;/code&gt; （基本的なバックトレースには十分）、- &lt;code&gt;-g2&lt;/code&gt; （または単に &lt;code&gt;-g&lt;/code&gt; だけ、GHCが知っているすべてを出力）。このデバッグ情報は、GHCによって実行される最適化には影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">引数を取るコマンドの例を次に示します。&lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; の&lt;/a&gt;再実装です：</target>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="translated">ここでは、どのキャッチスタイルの機能を使うかを決めるための経験則をご紹介します。</target>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="translated">ここで、 &lt;code&gt;(!:)&lt;/code&gt; はタイプ &lt;code&gt;Arr e&lt;/code&gt; の配列にインデックスを付ける再帰関数です。タイプ &lt;code&gt;(Int,Int)&lt;/code&gt; での &lt;code&gt;(!:)&lt;/code&gt; の呼び出しを考えます。 2番目の特殊化が実行され、特殊化された関数がインライン化されます。 &lt;code&gt;(!:)&lt;/code&gt; への2つの呼び出しがあり、どちらも &lt;code&gt;Int&lt;/code&gt; 型です。これらの呼び出しは両方とも、本体もインライン化された最初のスペシャライゼーションを起動します。結果は、型に基づいたインデックス関数の展開です。</target>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="translated">ここで、 &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; は、整数を &lt;code&gt;Bool&lt;/code&gt; にマップする関数 &lt;code&gt;even&lt;/code&gt; で整数をパッケージ化します。そして &lt;code&gt;MkFoo 'c' isUpper&lt;/code&gt; 互換性のある機能を持つキャラクターをパッケージ化します。これら2つはそれぞれ &lt;code&gt;Foo&lt;/code&gt; タイプであり、リストに入れることができます。</target>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="translated">ここで、 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; は値が関連付けられていないタイプレベルのプロキシです。</target>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="translated">ここで、 &lt;code&gt;Adder&lt;/code&gt; はモジュールツリー内のルートモジュールの名前です（上記のように、単一のルートモジュールが存在する必要があるため、DLLには単一のモジュールツリーが必要です）。すべてをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="translated">ここで、 &lt;code&gt;C&lt;/code&gt; はのスーパークラスである &lt;code&gt;D&lt;/code&gt; が、それは、クラスの操作のためにOKです &lt;code&gt;op&lt;/code&gt; の &lt;code&gt;C&lt;/code&gt; に言及する &lt;code&gt;D&lt;/code&gt; を。（ &lt;code&gt;D&lt;/code&gt; が &lt;code&gt;C&lt;/code&gt; のスーパークラスであっても問題ありません。）</target>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="translated">ここでは、 &lt;code&gt;a&lt;/code&gt; がインポートされ、 &lt;code&gt;c&lt;/code&gt; が最上位にバインドされているため、「 &lt;code&gt;..&lt;/code&gt; 」の拡張には寄与しません。ここでの動機は、「 &lt;code&gt;..&lt;/code&gt; 」が何に展開されるかを読者が簡単に理解できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="translated">ここで、 &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;g1&lt;/code&gt; はランク1の型であり、標準のHaskellで記述できます（例： &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt; ）。 &lt;code&gt;forall&lt;/code&gt; 暗黙のうちにハスケルによって追加された明示的な普遍的な定量化を行います。</target>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;f2&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; では厳密ですが、 &lt;code&gt;y&lt;/code&gt; では厳密ではありません。</target>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="translated">ここで、 &lt;code&gt;f3&lt;/code&gt; と &lt;code&gt;f4&lt;/code&gt; は同じです。とにかく評価を強制するパターンの前に強打を置いても何も起こりません。</target>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;g&lt;/code&gt; にはあいまいな型があり、拒否されますが、 &lt;code&gt;f&lt;/code&gt; は問題ありません。 &lt;code&gt;f&lt;/code&gt; の呼び出しサイトでの &lt;code&gt;?x&lt;/code&gt; のバインディングは非常に明確であり、タイプ &lt;code&gt;a&lt;/code&gt; を修正します。</target>
        </trans-unit>
        <trans-unit id="1bce2925ca8d4f31f00ac8bdae65f0eb431772ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;g&lt;/code&gt; はあいまいな型であり、拒否されますが、 &lt;code&gt;f&lt;/code&gt; は問題ありません。 &lt;code&gt;f&lt;/code&gt; の呼び出しサイトでの &lt;code&gt;?x&lt;/code&gt; のバインドは非常に明確であり、タイプ &lt;code&gt;a&lt;/code&gt; を修正します。</target>
        </trans-unit>
        <trans-unit id="18c00320ffe8585a72819af79238d88877a38e42" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;k&lt;/code&gt; is brought into scope by &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;k&lt;/code&gt; は &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt; によってスコープに入れられます。</target>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="translated">ここでは、 &lt;code&gt;lookup&lt;/code&gt; は&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;と宣言されていますが、その定義サイトではタイプ &lt;code&gt;T&lt;/code&gt; に特化できません。そのタイプがまだ存在しないためです。代わりに、クライアントモジュールは &lt;code&gt;T&lt;/code&gt; を定義して、その型での &lt;code&gt;lookup&lt;/code&gt; を専門化できます。</target>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;m x&lt;/code&gt; は最初のステートメントによって生成された &lt;code&gt;x&lt;/code&gt; の値に依存するため、式は &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; を使用して変換できません。</target>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="translated">ここで、タイプ &lt;code&gt;NumInst a&lt;/code&gt; aの値は、明示的な &lt;code&gt;(Num a)&lt;/code&gt; 辞書と同等です。</target>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="translated">GHCは、身体のインライン後にここで、 &lt;code&gt;foldl&lt;/code&gt; のを呼び出し場所に、それは非常に積極的にコールパターン特殊化を実行します &lt;code&gt;foldl_loop&lt;/code&gt; によるの使用に &lt;code&gt;SPEC&lt;/code&gt; ループ本体の引数インチ &lt;code&gt;SPEC&lt;/code&gt; から &lt;code&gt;GHC.Types&lt;/code&gt; は、具体的コンパイラによって認識されています。</target>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="translated">ここで、右側 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; は左側では発生しない種類変数 &lt;code&gt;a&lt;/code&gt; について言及していますが、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の種類パターンによって&lt;em&gt;暗黙的に&lt;/em&gt;バインドされているため、これは許容されます。</target>
        </trans-unit>
        <trans-unit id="3f03837283c8b527b9aef380941c96008f2bd16a" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s kind pattern.</source>
          <target state="translated">ここで、右側 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; は、左側では発生しない種類変数 &lt;code&gt;a&lt;/code&gt; について言及していますが、 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; の種類パターンによって&lt;em&gt;暗黙的に&lt;/em&gt;バインドされているため、これは許容されます。</target>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">ここでは、 &lt;code&gt;T Loop&lt;/code&gt; 型のループを使用しようとすると、その定義が無限に再帰するため、型チェッカーが無限ループにスローされることは明らかです。他の場合では、生成されたコードが&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;ループに入れなくても、UndecidableInstancesを有効にする必要があるかもしれません。例えば：</target>
        </trans-unit>
        <trans-unit id="3aa5a0145374631657afb97bb375856b1234f1ba" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">ここで、タイプ &lt;code&gt;T Loop&lt;/code&gt; を使用しようとすると、その定義が無限に繰り返されるため、タイプチェッカーが無限ループに陥ることは明らかです。その他の場合、生成されたコードが&lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;ループに入れない場合でも、UndecidableInstancesを有効にする必要がある場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="translated">ここでは、 &lt;code&gt;D&lt;/code&gt; も &lt;code&gt;T&lt;/code&gt; も &lt;code&gt;Orphan&lt;/code&gt; モジュールで宣言されていません。このようなモジュールを「孤立モジュール」と呼びます。GHCは孤立モジュールを識別し、コンパイルされているモジュールの下のすべての孤立モジュールのインターフェースファイルにアクセスします。これは通常無駄な作業ですが、回避することはできません。したがって、孤立したモジュールをできるだけ少なくするように最善を尽くす必要があります。</target>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="translated">ここでは、 &lt;code&gt;b&lt;/code&gt; のみがレビティ多態性です。levity-polymorphic型の変数はありません。そしてコードジェネレーターはこれで問題ありません。実際、これはGHCの &lt;code&gt;$&lt;/code&gt; 演算子の真のタイプであり、Haskell 98バージョンよりも少し一般的です。</target>
        </trans-unit>
        <trans-unit id="e4fa6e7e82de32b187a53fa81558ae736ecfa4c2" translate="yes" xml:space="preserve">
          <source>Here, the kind signature is hidden inside &lt;code&gt;'Just&lt;/code&gt;, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</source>
          <target state="translated">ここでは、種類の署名は &lt;code&gt;'Just&lt;/code&gt; の内部に隠されており、最も外側の種類の署名はありません。この例は、最も外側の種類の署名を提供することで修正できます。</target>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="translated">ここでは、 &lt;code&gt;ys&lt;/code&gt; と &lt;code&gt;zs&lt;/code&gt; のパターンシグネチャは問題ありませんが、 &lt;code&gt;b&lt;/code&gt; はスコープ内にないため、 &lt;code&gt;v&lt;/code&gt; のパターンシグネチャはそうではありません。</target>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="translated">ここで、パターンタイプシグネチャ &lt;code&gt;[t::a]&lt;/code&gt; は、まだスコープ内にないレキシカルタイプ変数について言及しています。実際、パターンマッチによってバインドされているため、スコープに含まれていては&lt;em&gt;なりません&lt;/em&gt;。その効果は、実在的にバインドされた型変数を表す、スコープにそれをもたらすことです。</target>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="translated">ここでは、 &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; の定量化された制約です。（Eq b）=&amp;gt; Eq（fb）はローカルインスタンス宣言のように動作し、インスタンスを型指定可能にします。</target>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="translated">ここで、データインスタンスの右側は、左側では発生しない型変数 &lt;code&gt;d&lt;/code&gt; について言及しています。型の安全性を損なう可能性があるため、そのようなデータインスタンスは認められません。</target>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="translated">ここでは、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;f1&lt;/code&gt; の結果であるため、 &lt;code&gt;MkFoo&lt;/code&gt; によってバインドされた型は「エスケープ」します。これが間違っている理由を確認する1つの方法は、 &lt;code&gt;f1&lt;/code&gt; のタイプを尋ねることです。</target>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;forall s. ST s Bool&lt;/code&gt; 型のシグネチャです。ST s Boolは、注釈付き式 &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt; 型変数 &lt;code&gt;s&lt;/code&gt; をスコープに入れます。</target>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="2f2e79d74e1610058532c363754e327e415fd68b" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="bd739f1c73011a1d448318bcfa789ba656618089" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="91d7f9927e5a55d877174d8d404732deead30952" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="807a40d7e8f0a1f48786149c90e1e7c0cd76acce" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="b74ea0e4e3ddeac5ecbd3ecbed85a2f70045728a" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="86634275ef317fd3fe952799b1bb3df615c7ddc1" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="1edcf669da9e6fb06ad045baef462cf32a3c26a6" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="8c8afb214d0c0a6607affe28247998085762d4c8" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="0d621456539c621761dd4c63fca78f9b42a61fd6" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="9c7acd6abb2dd44172bbfe5d9b17a04fe120a9e6" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; の16進エンコーディング。</target>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="translated">十六進数</target>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="translated">非表示のパッケージ（ &lt;code&gt;exposed&lt;/code&gt; フラグが &lt;code&gt;False&lt;/code&gt; のパッケージ）は、パッケージのリストの括弧内に表示されます。</target>
        </trans-unit>
        <trans-unit id="a918c16fef0fbb900dc7f98f2cd8d6d81c7d52c8" translate="yes" xml:space="preserve">
          <source>Hidden:</source>
          <target state="translated">Hidden:</target>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="translated">デフォルトですべてのパッケージを非表示にする</target>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="translated">デフォルトでプラグインのすべてのパッケージを非表示にする</target>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="translated">パッケージを隠す ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; コンストラクターで許可されている最高の演算子の優先順位（答え：9）</target>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; コンストラクターで許可されている最高の演算子の優先順位（答え：9）</target>
        </trans-unit>
        <trans-unit id="e0b0bb84453552196a9b41ee3bcc312c62a89de7" translate="yes" xml:space="preserve">
          <source>Highly, terribly dangerous coercion from one representation type to another. Misuse of this function can invite the garbage collector to trounce upon your data and then laugh in your face. You don't want this function. Really.</source>
          <target state="translated">非常に危険な、ある表現型から別の表現型への強制変換です。この関数を誤って使用すると、ガベージコレクタがあなたのデータを踏みにじり、あなたの顔を見て笑うことになります。この関数は必要ありません。本当に。</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="31865f8541bac972726284192e08ce45f0bca25b" translate="yes" xml:space="preserve">
          <source>Historical note. Earlier versions of GHC allowed these now-rejected applications, by inserting automatic eta-expansions, as described in Section 4.6 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/&quot;&gt;Practical type inference for arbitrary-aank types&lt;/a&gt;, where it is called &amp;ldquo;deep skolemisation&amp;rdquo;. But these automatic eta-expansions may silently change the semantics of the user&amp;rsquo;s program, and deep skolemisation was removed from the language by &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0287-simplify-subsumption.rst&quot;&gt;GHC Proposal #287&lt;/a&gt;. This proposal has many more examples.</source>
          <target state="translated">歴史的なメモ。以前のバージョンのGHCでは、「ディープスコーレミゼーション」と呼ばれる、&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/&quot;&gt;任意のバンク型&lt;/a&gt;の実用的な型推論のセクション4.6で説明されているように、自動eta-expansionsを挿入することにより、これらの現在拒否されているアプリケーションを許可していました。しかし、これらの自動eta-expansionは、ユーザーのプログラムのセマンティクスを黙って変更する可能性があり、&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0287-simplify-subsumption.rst&quot;&gt;GHC提案＃287&lt;/a&gt;によって言語から深いスコーレミゼーションが削除されました。この提案にはさらに多くの例があります。</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">歴史的には、 &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; イディオムの安全な代替手段です。</target>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">歴史的には、 &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; イディオムの安全な代替手段です。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="translated">一方、 &lt;code&gt;Weak ThreadId&lt;/code&gt; 保持しても、スレッドが &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 例外を受信することは妨げられません。それでも &lt;code&gt;Weak ThreadId&lt;/code&gt; に例外をスローすることは可能ですが、呼び出し側はまず &lt;code&gt;deRefWeak&lt;/code&gt; を使用して、スレッドがまだ存在するかどうかを判断する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a0d96a8a98d1e4dce5ef0782487ab394c743475" translate="yes" xml:space="preserve">
          <source>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</source>
          <target state="translated">Hole-fitプラグインは、タイプされた穴のエラーメッセージが生成されているときに呼び出されるプラグインで、コンパイル時にタイプされた穴に関する情報にアクセスすることができ、有効な穴フィットの提案をカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="translated">ホームディレクトリ (pw_dir)</target>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="translated">ホストエンディアン、非整列デコーディング</target>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="translated">ホストエンディアン、アラインメントされていない書き込み</target>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="translated">ホスト固有のバイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="translated">12時間目</target>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="translated">時間ゼロ</target>
        </trans-unit>
        <trans-unit id="a818d61d2efd55899d957cbb2415e5325cda9990" translate="yes" xml:space="preserve">
          <source>How can these goals be accomplished? Goal 1 suggests that weak references and finalizers (via &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Weak-35-&quot;&gt;Weak#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-exts#v:mkWeak-35-&quot;&gt;mkWeak#&lt;/a&gt;&lt;/code&gt;) are necessary. But how should they be used and what should their key be? Certainly not &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtrContents&quot;&gt;ForeignPtrContents&lt;/a&gt;&lt;/code&gt;. See the warning in &lt;a href=&quot;ghc-weak&quot;&gt;GHC.Weak&lt;/a&gt; about weak pointers with lifted (non-primitive) keys. The two finalizer-supporting data constructors of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; have an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt; &lt;a href=&quot;ghc-foreignptr#t:Finalizers&quot;&gt;Finalizers&lt;/a&gt;&lt;/code&gt; (backed by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutVar-35-&quot;&gt;MutVar#&lt;/a&gt;&lt;/code&gt;) field. This gets used in two different ways depending on the kind of finalizer:</source>
          <target state="translated">これらの目標はどのように達成できますか？目標1は、弱い参照とファイナライザー（ &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Weak-35-&quot;&gt;Weak#&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-exts#v:mkWeak-35-&quot;&gt;mkWeak#&lt;/a&gt;&lt;/code&gt; を介して）が必要であることを示しています。しかし、それらはどのように使用されるべきであり、それらの鍵は何であるべきですか？確かに &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtrContents&quot;&gt;ForeignPtrContents&lt;/a&gt;&lt;/code&gt; ではありません。&lt;a href=&quot;ghc-weak&quot;&gt;GHC&lt;/a&gt;の警告を参照してください。持ち上げられた（非プリミティブ）キーを持つ弱いポインターについては弱いです。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; の2つのファイナライザーをサポートするデータコンストラクターには、 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt; &lt;a href=&quot;ghc-foreignptr#t:Finalizers&quot;&gt;Finalizers&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutVar-35-&quot;&gt;MutVar#&lt;/a&gt;&lt;/code&gt; に基づく）フィールドがあります。これは、ファイナライザーの種類に応じて2つの異なる方法で使用されます。</target>
        </trans-unit>
        <trans-unit id="15c0121c842d34d2a7ecde10e9dc07dbbc682c4a" translate="yes" xml:space="preserve">
          <source>How do &lt;code&gt;Traversable&lt;/code&gt; functors manage to construct a new container of the same shape by sequencing effects over their elements? Well, left-to-right traversal with sequencing of effects suggests induction from a base case, so the first question is what is the base case? A &lt;code&gt;Traversable&lt;/code&gt; container with elements of type &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; generally has some minimal form that is either &quot;empty&quot; or has just a single element (think &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; vs. &lt;a href=&quot;data-list-nonempty&quot;&gt;Data.List.Nonempty&lt;/a&gt;).</source>
          <target state="translated">どうか &lt;code&gt;Traversable&lt;/code&gt; のファンクタは、その要素の上に影響を配列決定することにより、同一形状の新しいコンテナを構築するために管理しますか？さて、効果の順序付けを伴う左から右へのトラバーサルは、基本ケースからの誘導を示唆しているので、最初の質問は基本ケースは何ですか？ A &lt;code&gt;Traversable&lt;/code&gt; ののタイプの要素を有する容器は、一般的にのいずれかである「空」または単に単一の要素を（思う有する何らかの最小限の形態を有する&lt;a href=&quot;data-list&quot;&gt;Data.Listを&lt;/a&gt;対&lt;a href=&quot;data-list-nonempty&quot;&gt;Data.List.Nonempty&lt;/a&gt;）。&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="translated">ヒーププロファイラーによって報告されたヒープ常駐は、プログラムを実行したときのプログラムの実際のメモリ常駐とどのように関連していますか？ヒーププロファイラによって報告された常駐と、システムのツールによって報告された常駐（たとえば、UNIXでは &lt;code&gt;ps&lt;/code&gt; または &lt;code&gt;top&lt;/code&gt; 、Windowsではタスクマネージャ）の間に大きな不一致が見られる場合があります。これにはいくつかの理由があります。</target>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="translated">コンパイラはどれだけインライン辞書に熱心になればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="translated">コンパイラはどれだけインライン関数に熱心になればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="translated">プログラムの実行時間(CPU時間と経過したウォールクロック時間)。</target>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="translated">このゴミ収集にかかった時間(CPU時間と経過した壁のクロック時間)。</target>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="translated">現在何バイトが生きているか。</target>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="translated">このコスト・センター内でプログラムは何バイトを割り当てましたか?これには、子コストセンター内での割り当ては含まれていません。</target>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="translated">読み出すバイト数</target>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="translated">このガベージコレクションに何バイト割り当てたか。</target>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="translated">このガベージコレクションを何バイトコピーしたか</target>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="translated">プログラムが開始された機能の数（たとえば、 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; オプションを使用）。機能の数は、 &lt;code&gt;setNumCapabilities&lt;/code&gt; 関数が原因で、実行中に変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="translated">最後のガベージコレクションの終了後、何件のページフォルトが発生したか。</target>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="translated">このガベージコレクションで発生したページフォルトの数。</target>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="translated">プログラムの実行中に経過したプロファイラーの「ティック」の数。</target>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">指定された &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt; 内のスタックフレームの数</target>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="translated">このコストセンター内でのプログラムの実行は何ティックですか。これには、児童経費は含まれません。</target>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="translated">このコストセンターは何回目に入ったのでしょうか?</target>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="translated">プロファイラーの刻みの間の時間。</target>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="translated">標準エラーの判定方法</target>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="translated">標準入力を決定する方法</target>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="translated">標準出力の決定方法</target>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">数値フィールドの符号を処理する方法。これらは相互に排他的であり、 &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; が優先されます。</target>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;を使用する場合、GHCは &lt;code&gt;toList&lt;/code&gt; 、 &lt;code&gt;fromList&lt;/code&gt; 、 &lt;code&gt;fromListN&lt;/code&gt; の名前を持つスコープ内のものを代わりに使用します。つまり、これらの関数は再バインド可能です。cf &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable構文と暗黙のPreludeインポート&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ae296daca1b508d7fb4c3a47911474c376befa0" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;rebindable_syntax#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">ただし、&lt;a href=&quot;rebindable_syntax#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;を使用する場合、GHCは代わりに、 &lt;code&gt;toList&lt;/code&gt; 、 &lt;code&gt;fromList&lt;/code&gt; 、および &lt;code&gt;fromListN&lt;/code&gt; の名前を持つスコープ内のすべてのものを使用します。つまり、これらの関数は再バインド可能です。cf&lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;再バインド可能な構文と暗黙のプレリュードインポート&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="702dc86214fe1989c12ea91b2f8f3061394aa70f" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;../ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">ただし、GHCiのオーバーラップルールについては、&lt;a href=&quot;../ghci#ghci-decls&quot;&gt;タイプ、クラス、およびその他の宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">ただし、GHCiの重複ルールについては、&lt;a href=&quot;ghci#ghci-decls&quot;&gt;タイプ、クラス、およびその他の宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="translated">ただし、生成された定義が &lt;code&gt;typeCheckResultAction&lt;/code&gt; の入力に含まれていることに注意してください。タイプチェックされた入力のフィルタリングに注意を払わないと、ツールの動作に一貫性がなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">ただし、モナド &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; は次のとおりではありません。</target>
        </trans-unit>
        <trans-unit id="75d85dddd307adff786f4e64b0c8bb94a7e37fed" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">ただし、モナド &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; は次のとおりではありません。</target>
        </trans-unit>
        <trans-unit id="02bc960b7c0ef000cda26acf0b2dd0c7e0c24942" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">ただし、モナド &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; は次のとおりではありません。</target>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;stderr&lt;/code&gt; ではなくWindowsデバッグ出力サポートを使用するため、Debug.Trace.traceを使用しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; は&lt;em&gt;バインドされた&lt;/em&gt;スレッドを作成します。これは、OpenGLなどのスレッドローカル状態を利用する外部（非Haskell）ライブラリを呼び出す必要がある場合に必要です（&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrentを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="translated">ただし、let / whereパターンバインディングの&lt;em&gt;ネストされた&lt;/em&gt;前髪は、他のすべてのパターンマッチングと同じように動作します。例えば</target>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="translated">しかし、これらの制限とは別に、完全に評価されない式を含む多くのことが許可されています! アノテーション式は、テンプレートHaskellのスプライスがそうであるように、コンパイラによって評価されます。なので、このアノテーションは問題ありません。</target>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="translated">ただし、GHC は型の一部が&lt;em&gt;省略され&lt;/em&gt;た場合に型を&lt;em&gt;推測する&lt;/em&gt;必要がある&lt;em&gt;ため&lt;/em&gt;、ポリモーフィックな再帰を使用することはできません。型シグネチャが完全に省略されている場合も、同じ制限が発生します。</target>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">ただし、Haskellの型クラスシステムを単純に拡張することで、動的バインディングをサポートできます。基本的に、動的にバインドされた変数の使用を型の制約として表現します。これらの制約により、 &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt; という形式の型が生じます。これは、「この関数は、型が &lt;code&gt;t'&lt;/code&gt; の動的にバインドされた変数 &lt;code&gt;?x&lt;/code&gt; を使用する」ことを示しています。たとえば、以下はソート関数のタイプを表しており、 &lt;code&gt;cmp&lt;/code&gt; という名前の比較関数によって暗黙的にパラメーター化されています。</target>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">しかし、次のような例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;拡張機能を有効にすると、モジュールをコンパイルできます。同様のエラーは、次のようなさまざまな拡張機能で発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="71c8649194e9a3d90eb4aa0b5d79e25f92dac745" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">ただし、&lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;拡張機能を有効にすると、モジュールをコンパイルできます。同様のエラーは、次のようなさまざまな拡張機能で発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="translated">ただし、GADTには次の追加の制約があります。フィールド &lt;code&gt;f&lt;/code&gt; を持つすべてのコンストラクターは同じ結果タイプ（モジュロアルファ変換）でなければなりません。したがって、上記の例では、上記の &lt;code&gt;num&lt;/code&gt; フィールドと &lt;code&gt;arg&lt;/code&gt; フィールドを単一の名前にマージできません。フィールドタイプはどちらも &lt;code&gt;Term Int&lt;/code&gt; ですが、セレクター関数には実際には異なるタイプがあります。</target>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="translated">ただし、ほとんどのアプリケーションでは、 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; フラグと &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; フラグを使用するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="translated">ただし、 &lt;code&gt;CProv&lt;/code&gt; が空でない場合、CReqは空 &lt;code&gt;CReq&lt;/code&gt; が、上記の &lt;code&gt;P&lt;/code&gt; のパターン型シグネチャは次のように指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="translated">ただし、 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; が区切り文字で終わる場合、デフォルトのデータベース（つまり、ユーザーパッケージデータベースとグローバルパッケージデータベースがこの順序で）がパスに追加されます。たとえば、通常のパッケージセットに独自のデータベースを追加するには、次のようにします（UNIXの場合）。</target>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、プログラムがオペレーティングシステム提供のスレッドパッケージを使用することを期待する外部ライブラリとやり取りしたい場合は、 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; を使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="translated">しかし、全てのパターンに&lt;em&gt;他の&lt;/em&gt;パターンバインディングよりも、パターン型シグネチャは、スコープ内にないタイプの変数を挙げることができます。この場合、&lt;em&gt;シグネチャはその型変数をスコープに入れます&lt;/em&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="translated">ただし、行の最後にスペースを追加すると、 &lt;code&gt;cpp&lt;/code&gt; （少なくともGNU &lt;code&gt;cpp&lt;/code&gt; と他の &lt;code&gt;cpp&lt;/code&gt; s）はバックスラッシュとスペースのペアをそのままにし、文字列のギャップは期待どおりに機能するようです。</target>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="translated">ただし、少し「後方」評価を実行することは可能です。たとえば、これはGHCに型レベルで任意の対数を計算させる方法です。</target>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="translated">ただし、ユーザーがタイプを指定する必要があるのは面倒なので、GHCiはHaskellのタイプデフォルトルール（Haskell 2010レポートのセクション4.3.4）を次のように拡張します。標準規則 &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; 型変数 &lt;code&gt;a&lt;/code&gt; ごとに制約の各グループ（C1 a、C2 a、...、Cn a）を取得し、次の場合に型変数をデフォルト設定します。</target>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="translated">しかし、すべてが失われたわけではありません。私たちにはまだできることがあります。</target>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="translated">ただし、モジュール &lt;code&gt;Main&lt;/code&gt; を &lt;code&gt;foo.hs&lt;/code&gt; という名前のファイルに含めることは妥当ですが、これはGHCがモジュール &lt;code&gt;Main&lt;/code&gt; のインターフェースを検索する必要がないためにのみ機能することに注意してください（インポートされないため）。したがって、同じディレクトリの別々のソースファイルに複数の &lt;code&gt;Main&lt;/code&gt; モジュールを置くことが可能であり、GHCは混乱しません。</target>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="translated">ただし、フラグの設定に関わらず、このような状況下では定量器が印刷されます。</target>
        </trans-unit>
        <trans-unit id="90b773fc14f9910a6800428a873985b0da62bdbd" translate="yes" xml:space="preserve">
          <source>However, reuse of an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; obtained in this way will typically memoise the underlying element sequence. Instead, we can define &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; terms directly:</source>
          <target state="translated">ただし、この方法で取得した&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; を&lt;/strong&gt;再利用すると、通常、基になる要素シーケンスがメモ化されます。代わりに、&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; の&lt;/strong&gt;用語を直接定義できます。</target>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="translated">ただし、バージョン8.4以降これはもはやケースではありません：GHCは&lt;strong&gt;保証&lt;/strong&gt;そのガベージコレクションが中に発生することはありません &lt;code&gt;unsafe&lt;/code&gt; ことを呼び出し、でも、バイトコードインタプリタで、さらに保証 &lt;code&gt;unsafe&lt;/code&gt; 呼び出しは呼び出し元のスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="translated">しかし、そのような呼び出しがない場合もあります。</target>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="translated">ただし、スタンドアロンの派生は、いくつかの重要な点で &lt;code&gt;deriving&lt;/code&gt; 句とは異なります。</target>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="translated">ただし、 &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt; 以降、デフォルトの実装は &lt;code&gt;DefaultSignatures&lt;/code&gt; に基づいており、より正確な自動派生 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; インスタンスを可能にします。以前に使用した正確なデフォルトの &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; メソッド実装セマンティクスが必要な場合は、</target>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="translated">ただし、 &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; および &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 公理はどちらも必要な制約 &lt;code&gt;C a&lt;/code&gt; に一致します。これらの重複するローカル公理を処理するには、いくつかの可能なアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="translated">ただし、インスタンス宣言はインスタンス終了のルールに準拠している必要があり&lt;a href=&quot;#instance-termination&quot;&gt;ます&lt;/a&gt;。インスタンス終了ルールを参照してください。</target>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="translated">しかし、実際の実装では memcmp を使用して文字列の末尾のみを比較し、逆引きは必要ありません。</target>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="translated">しかし、未定義の演算子の存在下では、第2法則に違反する。</target>
        </trans-unit>
        <trans-unit id="63bdcc6dcc86cc03d19b2829a81c1ef6b447e031" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;exts/parallel#lang-parallel&quot;&gt;Parallel and Concurrent&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">ただし、2つの用語は確かに関連しています。複数のCPUを利用することにより、並行スレッドを並行して実行することが可能であり、これはまさにGHCのSMP並列処理サポートが行うことです。ただし、並行性を使用しないプログラムでは、並列処理によってパフォーマンスを向上させることもできます。このセクションでは、GHCを使用して並列プログラムをコンパイルおよび実行する方法について説明します。&lt;a href=&quot;exts/parallel#lang-parallel&quot;&gt;並列および並行&lt;/a&gt;では、並列処理に影響を与える言語機能について説明します。</target>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">ただし、2つの用語は確かに関連しています。複数のCPUを利用することにより、並行スレッドを並列に実行することが可能であり、これはまさにGHCのSMP並列処理サポートが行うことです。ただし、並行性を使用しないプログラムで並列処理を行うと、パフォーマンスが向上する場合もあります。このセクションでは、GHCを使用して並列プログラムをコンパイルおよび実行する方法について説明します。&lt;a href=&quot;parallel#lang-parallel&quot;&gt;並行および並列Haskell&lt;/a&gt;では、並列処理に影響を与える言語機能について説明します。</target>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="translated">しかし、無制限の使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;、任意のモジュールとして問題が信頼できるとして自分自身をマークするために使用することができ、まだある&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;異なり、モジュールに関するすべての保証を提供していない&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;。信頼できるモジュールの使用を制御するには、&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;フラグを使用することをお勧めします。このフラグは、信頼できるモジュールの信頼チェックに追加の要件を追加します。信頼できるモジュールを信頼できると見なし、&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;で使用できるようにする必要があります。コンパイルされたコード、コードをコンパイルするクライアントCは、信頼できるモジュールが存在するパッケージを信頼することをGHCに通知する必要があります。これは基本的にCが言う方法ですが、このパッケージには、&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; で&lt;/a&gt;コンパイルされた信頼できないモジュールが使用できる信頼できるモジュールが含まれています、このパッケージの作成者を信頼し、モジュールが安全なAPIのみを公開することを信頼します。パッケージの信頼はいつでも変更できるため、パッケージに脆弱性が見つかった場合、Cはそのパッケージを信頼できないと宣言して、そのパッケージに対する今後のコンパイルが失敗するようにすることができます。このメカニズムのより詳細な概要については、&lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="translated">ただし、このアプローチにはいくつかの問題があります。1つ目は、2つの例外ハンドラーを持つことは非効率的です。ただし、より深刻な問題は、 &lt;code&gt;handleArith&lt;/code&gt; が &lt;code&gt;IOException&lt;/code&gt; 例外をキャッチすることです。 IOExceptionを、2番目の例外ハンドラーがそれをキャッチします。</target>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。参照： &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22293f9f5fdf9be0f89ee2fe6ac2c9f85e6c4fa" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="37661dc7c27dbb41dea8ca8af0a138bd14b9b454" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。参照： &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; で常に安全に呼び出すことができるトランザクション変数を作成するための関数があります。参照： &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">ただし、これを一部の非UNIX OSに実装することは不可能ではないため、代わりに、最大限の移植性のために、呼び出されたプログラムのリーフ名を返すだけです。それでも、プラットフォーム間にはいくつかの違いがあります。たとえば、Windowsでは、fooとして呼び出されたプログラムはおそらく実際には &lt;code&gt;FOO.EXE&lt;/code&gt; であり、それが &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">ただし、これを一部の非UNIX OSに実装することは不可能ではないため、代わりに、最大限の移植性のために、呼び出されたプログラムのリーフ名を返すだけです。それでも、プラットフォーム間にはいくつかの違いがあります。たとえば、Windowsでは、fooとして呼び出されたプログラムはおそらく実際には &lt;code&gt;FOO.EXE&lt;/code&gt; であり、それが &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="6557c18e96aa511c7a8a12a0376a7cadff35e893" translate="yes" xml:space="preserve">
          <source>However, this is not terribly efficient, because we pay the cost of reconstructing the entire structure as a side effect of validation. It is generally cheaper to just check all the elements and then use the original structure if it is valid. This can be done via the methods of the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; superclass, which perform only the side effects without generating a new structure:</source>
          <target state="translated">ただし、検証の副作用として構造全体を再構築するコストを支払うため、これはそれほど効率的ではありません。一般に、すべての要素をチェックして、有効な場合は元の構造を使用する方が安価です。これは、新しい構造を生成せずに副作用のみを実行する &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; スーパークラスのメソッドを介して実行できます。</target>
        </trans-unit>
        <trans-unit id="1658f0cedb643d19abc9a3eb383bd3c50a7ac313" translate="yes" xml:space="preserve">
          <source>However, this is not true. On the contrary, similarly to the above implementations of &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; has a &quot;step size&quot; of &lt;code&gt;10^-12&lt;/code&gt;. Hence, the list &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; has the form</source>
          <target state="translated">しかし、これは真実ではありません。逆に、上記と同様の実装に &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; 及び &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt; が、 &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; の「ステップサイズ」は &lt;code&gt;10^-12&lt;/code&gt; 。したがって、リスト &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; の形式は</target>
        </trans-unit>
        <trans-unit id="f86459604cdb799db006c4886698519f85f63218" translate="yes" xml:space="preserve">
          <source>However, this is not true. On the contrary, similarly to the above implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; has a &quot;step size&quot; of &lt;code&gt;10^-12&lt;/code&gt;. Hence, the list &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; has the form</source>
          <target state="translated">しかし、これは真実ではありません。逆に、上記と同様の実装に &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; 及び &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt; が、 &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; の「ステップサイズ」は &lt;code&gt;10^-12&lt;/code&gt; 。したがって、リスト &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; の形式は</target>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="translated">しかし、複数の節を持つ関数や、相互に再帰的な関数のグループを定義する場合は、レイアウトの代わりに明示的なセミコロンを使用して、完全な定義を1行で記述しなければならないため、これはすぐに面倒になってしまいます。</target>
        </trans-unit>
        <trans-unit id="321449b209a4a3d9b8a213d15a63e5983b737e5b" translate="yes" xml:space="preserve">
          <source>However, this restriction can be relaxed by enabling &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unlifted-newtypes&quot;&gt;section on unlifted newtypes&lt;/a&gt; details the behavior of such types.</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;を有効にすることで、この制限を緩和できます。&lt;a href=&quot;#unlifted-newtypes&quot;&gt;unlifted newtypes上のセクションでは&lt;/a&gt;、このような種類の行動を詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="translated">ただし、 &lt;code&gt;x&lt;/code&gt; はあいまいであるため、これは許可されません。</target>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="translated">しかし、データファミリーのインスタンスの型クラスインスタンスは、他のデータ型と同じように定義することができます。例えば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="translated">しかし、データ型を決定するために引数の型を推論したり、制約ソルバーに選択を委ねる方法はありません。したがって、以下は曖昧です。</target>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="translated">ただし、&lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt;を例えば &lt;code&gt;1&lt;/code&gt; に設定すると、この場合、さらに、リファインメントホールフィットのリストが表示されます。</target>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="translated">Html の略語</target>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="translated">Html の色</target>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="f5351a72db878f5f365bfd63650ac9345f429fc2" translate="yes" xml:space="preserve">
          <source>Hybrid folds</source>
          <target state="translated">ハイブリッドはフォールド</target>
        </trans-unit>
        <trans-unit id="2f70612bc16437d395e71287782bb6fd9cb7cf34" translate="yes" xml:space="preserve">
          <source>I can&amp;rsquo;t use</source>
          <target state="translated">使えない</target>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="translated">プログラマ定義のI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="translated">引数の 1 つが既に存在するために操作が失敗した I/O エラー。</target>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="translated">引数の1つが存在しないために操作が失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="translated">引数の 1 つが既に使用中の単一使用リソースであるため、操作が失敗した I/O エラー。</target>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="translated">デバイスが満杯のため、操作に失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="translated">ファイルの終端に達したため、操作に失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="82239ba587720ead23fb3ec489cdc8f072db7a33" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. See &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リソースが消失したために操作が失敗したI / Oエラー。 &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="53e0ff159cdede7a57ee03fa0daa909d8ace6979" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. This happens when, for example, attempting to write to a closed socket or attempting to write to a named pipe that was deleted.</source>
          <target state="translated">リソースが消えたために操作が失敗した I/O エラー。これは、例えば、閉じたソケットへの書き込みを試みたり、削除された名前付きパイプへの書き込みを試みたりした場合に発生します。</target>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">ユーザーがその操作を実行するのに十分なオペレーティングシステムの特権を持っていないために操作が失敗したI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="translated">操作ができないI/Oエラー。</target>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="translated">入出力エラー</target>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; の実装に必要なI / O操作。</target>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">I / Oとの &lt;code&gt;ByteString&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="translated">ハンドル付きI/O</target>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="translated">グループのIDです。</target>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="translated">所有者のIDです。</target>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="translated">このファイルが存在するデバイスのID。</target>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="translated">シリアル化のためのIO関数</target>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="translated">IO関連の例外の種類と関数</target>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
        <trans-unit id="268db2ac8f4f524b89d42b5ab6cac600af62f822" translate="yes" xml:space="preserve">
          <source>IORefs</source>
          <target state="translated">IORefs</target>
        </trans-unit>
        <trans-unit id="4c3aab79c94196e8852e03490d73a55b7f5049e7" translate="yes" xml:space="preserve">
          <source>IOUArray</source>
          <target state="translated">IOUArray</target>
        </trans-unit>
        <trans-unit id="e10a87d05825ac01e14764ed94abba63697418fb" translate="yes" xml:space="preserve">
          <source>IQList</source>
          <target state="translated">IQList</target>
        </trans-unit>
        <trans-unit id="820a25194dff0d9c02f82ba8b6ba428cf8fc6422" translate="yes" xml:space="preserve">
          <source>IQNil</source>
          <target state="translated">IQNil</target>
        </trans-unit>
        <trans-unit id="7567d31e648220ce233abc256ecdab6241e5ddca" translate="yes" xml:space="preserve">
          <source>ISO 8601 Ordinal Date format</source>
          <target state="translated">ISO 8601 序数日付形式</target>
        </trans-unit>
        <trans-unit id="f822119fe2f0a8362181618c06cbbe9eb1102060" translate="yes" xml:space="preserve">
          <source>ISO 8601 Week Date format</source>
          <target state="translated">ISO 8601 週の日付のフォーマット</target>
        </trans-unit>
        <trans-unit id="ce553dbefd4b35500c8adfaf562f347bd1cffaf1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.3. Omit hyphens and colons. &quot;The basic format should be avoided in plain text.&quot;</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.3.ハイフン及びコロンを省略する。&quot;平文では基本的な書式は避けることが望ましい&quot;</target>
        </trans-unit>
        <trans-unit id="5b73e3fe248bf6961ea567329e7f53034196b781" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.4. Use hyphens and colons.</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.4.ハイフンとコロンを使用する。</target>
        </trans-unit>
        <trans-unit id="ea6af556d4876a2b89f040fff7abb59f4dd0f4c1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.2</target>
        </trans-unit>
        <trans-unit id="65fa90d60515a8ea4b8b6bba5111ddac2a89a577" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(a)</target>
        </trans-unit>
        <trans-unit id="b8e6c45635e6a6c7b99751a00199842c95a39f56" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(b)</target>
        </trans-unit>
        <trans-unit id="9b6b8fd39d751d5c0fc381e79557a67b538bd22a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.3(c)</target>
        </trans-unit>
        <trans-unit id="c7d58b1b77840944ae450aa457ab0e6e3c750344" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(a)</target>
        </trans-unit>
        <trans-unit id="50049f60c0a8e8cd5b1d15d9787aba4c4ae639f0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(b)</target>
        </trans-unit>
        <trans-unit id="d06f9cca67b57ce453f249d30d73e9c7f581681a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(c)</target>
        </trans-unit>
        <trans-unit id="813aaac22f2045f777c991dc639bff2d89abd533" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(d)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.2.4(d)</target>
        </trans-unit>
        <trans-unit id="72acd19bfc93f68e206e6c0d34917114a1fccd3e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.3.2</target>
        </trans-unit>
        <trans-unit id="3f13144d5ece5d74d8b6f96aa24edc61eeacd8ad" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.3.3</target>
        </trans-unit>
        <trans-unit id="9b6b94afc9edd9404ea266217015cf416121eae0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.4.2</target>
        </trans-unit>
        <trans-unit id="a87736cb0c925b16cdeae6f6fe9b3e015c30590f" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.1.4.3</target>
        </trans-unit>
        <trans-unit id="bbcf342f586bebce46006d4c12d16ad8863024f4" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.2, 4.2.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2,4.2.2.4(a)</target>
        </trans-unit>
        <trans-unit id="b6b37624da200ed73cebb71eb0a89339f3a4fba3" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(a), 4.2.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2.3(a)、4.2.2.2.4(b)</target>
        </trans-unit>
        <trans-unit id="c55ad86d1327285d355a307898cd0bcedc64b2e7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(b), 4.2.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.2.3(b)、4.2.2.2.4(c)</target>
        </trans-unit>
        <trans-unit id="8f67d771cf395b85785ef48de67f6dffa701c036" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.5</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.2.5</target>
        </trans-unit>
        <trans-unit id="07b435b23d42540df0b1bc985f1fa5204e769f0b" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.4</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.4</target>
        </trans-unit>
        <trans-unit id="4fcc52df4b38af082287f6513b315a63598a3982" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.1</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.5.1</target>
        </trans-unit>
        <trans-unit id="5787fbc9eed85c23b6ba6c14fc91c92443851aa7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.2.5.2</target>
        </trans-unit>
        <trans-unit id="12305998507260debe9c8d6034797acfcba06193" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.3.2</target>
        </trans-unit>
        <trans-unit id="c5f903f7dfa61fd47c40e96852ca4df55e2a3b30" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.3.3</target>
        </trans-unit>
        <trans-unit id="9bfa7627b1b505b0fc50fefcc1d485389c084e49" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.2</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.3.2</target>
        </trans-unit>
        <trans-unit id="2f0c4ca61d383b42003623a59e3a979e5caa4b98" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.3</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.3.3</target>
        </trans-unit>
        <trans-unit id="fafc36b5bb91f4fa0ee5d27ebce4e786ca51d48d" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.4.1</source>
          <target state="translated">ISO 8601:2004(E)sec.4.4.4.1</target>
        </trans-unit>
        <trans-unit id="bbb017422d2f8d4d41f4efb11d499f43cec2368e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.5</source>
          <target state="translated">ISO 8601:2004(E)sec.4.5</target>
        </trans-unit>
        <trans-unit id="0844a2bf2289652fa3443d5285683e93680df727" translate="yes" xml:space="preserve">
          <source>ISO/IEC 8859-1 (Char8)</source>
          <target state="translated">ISO/IEC 8859-1 (Char8)</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="c9cf1dd8147dc5d22c7365bdaa07b0903f6de420" translate="yes" xml:space="preserve">
          <source>ITQList</source>
          <target state="translated">ITQList</target>
        </trans-unit>
        <trans-unit id="45da9c6dee9536772c435a75e794212cc011b4e4" translate="yes" xml:space="preserve">
          <source>ITQNil</source>
          <target state="translated">ITQNil</target>
        </trans-unit>
        <trans-unit id="9a1703cf287a1d482c0b2abbe3bb64675ffdbe02" translate="yes" xml:space="preserve">
          <source>Ideally, this type would not exist at all and we would just fix the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">理想的には、このタイプはまったく存在せず、 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; インスタンスを修正するだけです。 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; のです。</target>
        </trans-unit>
        <trans-unit id="ce1ef819f32725331a936d8af228a9ef343e2ecc" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt;, except that the return value does not include the function which maps keys to vertices. This version of &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; is for backwards compatibility.</source>
          <target state="translated">戻り値にキーを頂点にマップする関数が含まれていないことを除いて、 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; と同じです。このバージョンの &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; は、下位互換性のためのものです。</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">アイデンティティ機能。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
