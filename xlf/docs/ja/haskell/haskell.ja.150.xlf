<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c16541def5ea587ac69bfcc99daad84a959043da" translate="yes" xml:space="preserve">
          <source>Another valid monoid instance of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; It is defined by multiplication and `1` as neutral element:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; の別の有効なモノイドインスタンスは &lt;code&gt;&lt;a href=&quot;data-monoid#t:Product&quot;&gt;Product&lt;/a&gt;&lt;/code&gt; Itです。これは乗算によって定義され、 `1`は中立要素として定義されます。</target>
        </trans-unit>
        <trans-unit id="988994d9ba9baaa058f970931250d478f9f37dc1" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">呼び出しサイトのあいまいさを取り除く別の方法は、 &lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;拡張機能をてタイプを指定することです。例えば：</target>
        </trans-unit>
        <trans-unit id="94b8325dc71ed2de396f171eb6cf1fb19dcc26f3" translate="yes" xml:space="preserve">
          <source>Another way of getting rid of the ambiguity at the call site is to use the &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension to specify the types. For example:</source>
          <target state="translated">呼び出しサイトのあいまいさを取り除く別の方法は、&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;拡張機能を使用してタイプを指定することです。例えば：</target>
        </trans-unit>
        <trans-unit id="c9ca1d00f2ba6c9bdc216ddca02e1e03260d4bda" translate="yes" xml:space="preserve">
          <source>Another way to manipulate the scope is to use the &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command, whose syntax is this:</source>
          <target state="translated">スコープを操作する別の方法は、 &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;は、次の構文の：moduleコマンドです。</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="55329b02c1416b447df48dea23b5ad00b5ee2f0a" translate="yes" xml:space="preserve">
          <source>Any -On where n &amp;gt; 2 is the same as -O2.</source>
          <target state="translated">Any -On where n &amp;gt; 2 is the same as -O2.</target>
        </trans-unit>
        <trans-unit id="aed001ecb885bcbc05312253a4102a733b569260" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">に渡されるすべての &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; には、すぐに閉じた状態になります。</target>
        </trans-unit>
        <trans-unit id="bcbdf5a60ce9ec92529281711b09ee9755999301" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">どれ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 秒に渡さ &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; は、閉じた状態ですぐに配置されます。</target>
        </trans-unit>
        <trans-unit id="796335e1acfa34e32b875adacaa05c0d73b8aa9f" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s passed to &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; are placed immediately in the closed state.</source>
          <target state="translated">どれ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 秒に渡さ &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; は、閉じた状態ですぐに配置されます。</target>
        </trans-unit>
        <trans-unit id="e91b45192e9b0774cf7aefe77d4d40c0d29cd8a2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;COMPLETE&lt;/code&gt; sets of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">すべて &lt;code&gt;COMPLETE&lt;/code&gt; タイプ &lt;code&gt;T&lt;/code&gt; のセット</target>
        </trans-unit>
        <trans-unit id="5dfb3cd648c868b374f6e2677fac36fbe2978a3c" translate="yes" xml:space="preserve">
          <source>Any GHC command-line option that is designated as dynamic (see the table in &lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;), may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. To unset an option, you can set the reverse option:</source>
          <target state="translated">動的として指定されているGHCコマンドラインオプション（&lt;a href=&quot;flags#flag-reference&quot;&gt;フラグリファレンス&lt;/a&gt;の表を参照）は、次のコマンドを使用して設定できます。&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 設定でき&lt;/a&gt;ます。オプションの設定を解除するには、逆のオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="6f5306564b28b058683860c0dbb58f6e1ae386c4" translate="yes" xml:space="preserve">
          <source>Any I/O errors encountered while a handle is semi-closed are simply discarded.</source>
          <target state="translated">ハンドルがセミクローズされている間に発生したI/Oエラーは、単純に破棄されます。</target>
        </trans-unit>
        <trans-unit id="0c84ffa38e0d42fe1e3c4aafd67e2a273e5029ca" translate="yes" xml:space="preserve">
          <source>Any arbitrary string, no interpretation or parsing is done.</source>
          <target state="translated">任意の文字列、解釈や解析は行われません。</target>
        </trans-unit>
        <trans-unit id="0452f2ab13ab3b0881a1a304cec756faecd5a100" translate="yes" xml:space="preserve">
          <source>Any data type that can be declared in standard Haskell 98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</source>
          <target state="translated">標準のHaskell 98構文で宣言できるデータ型はすべて、GADTスタイルの構文を使用して宣言することができます。この選択は主に様式的なものですが、GADTスタイルの宣言は1つの重要な点で異なります。それは、データ・コンストラクタのクラス制約の扱いが異なるという点です。具体的には、コンストラクタに型クラスのコンテキストが与えられている場合、そのコンテキストはパターン・マッチングによって利用可能になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7d3011ab0c7b5aa4a9a177dbc0ce024f6e055225" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">ステートメントの評価または実行中に発生した例外はすべて、GHCiコマンドラインインターフェースによってキャッチおよび出力されます（例外の詳細については、モジュールを参照してください） &lt;a href=&quot;../libraries/base-4.13.0.0/control-exception&quot;&gt;&lt;/a&gt;、ライブラリドキュメントのControl.Exception。</target>
        </trans-unit>
        <trans-unit id="d671ba93c9259d42fd317ba91ce67c391a4d8b7f" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</target>
        </trans-unit>
        <trans-unit id="f719b6e6c5e275dbf8e07842f21a8f48fe1636e8" translate="yes" xml:space="preserve">
          <source>Any exceptions raised during the evaluation or execution of the statement are caught and printed by the GHCi command line interface (for more information on exceptions, see the module &lt;a href=&quot;../libraries/base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; in the libraries documentation.</source>
          <target state="translated">ステートメントの評価または実行中に発生した例外は、GHCiコマンドラインインターフェイスによってキャッチおよび出力されます（例外の詳細については、ライブラリドキュメントのモジュール&lt;a href=&quot;../libraries/base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fb34342e0a6715040492745b6bae6bc125156350" translate="yes" xml:space="preserve">
          <source>Any expression that has both &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances may be attached to a top-level value binding using an &lt;code&gt;ANN&lt;/code&gt; pragma. In particular, this means you can use &lt;code&gt;ANN&lt;/code&gt; to annotate data constructors (e.g. &lt;code&gt;Just&lt;/code&gt;) as well as normal values (e.g. &lt;code&gt;take&lt;/code&gt;). By way of example, to annotate the function &lt;code&gt;foo&lt;/code&gt; with the annotation &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; you would do this:</source>
          <target state="translated">&lt;code&gt;Typeable&lt;/code&gt; インスタンスと &lt;code&gt;Data&lt;/code&gt; インスタンスの両方を持つ式は、 &lt;code&gt;ANN&lt;/code&gt; プラグマを使用してトップレベルの値バインディングにアタッチできます。特に、これは &lt;code&gt;ANN&lt;/code&gt; を使用してデータコンストラクター（ &lt;code&gt;Just&lt;/code&gt; など）および通常の値（ &lt;code&gt;take&lt;/code&gt; など）に注釈を付けることができることを意味します。例として、関数に注釈を付けるには &lt;code&gt;foo&lt;/code&gt; に &lt;code&gt;Just &quot;Hello&quot;&lt;/code&gt; という注釈次のようにします。</target>
        </trans-unit>
        <trans-unit id="01212113a76fa0770e6b80bde8974e88d8560b27" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</target>
        </trans-unit>
        <trans-unit id="b4b940cc0f6bd9befa4dc2cd571bce369cc78d6f" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">拡張機能からの任意の拡張 &lt;code&gt;Extension&lt;/code&gt; &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extensionで&lt;/a&gt;定義されてタイプの使用できます。リクエストされた拡張機能のいずれかがサポートされていない場合、GHCはエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="6fe084339688200f9007406f9182c723678a61f9" translate="yes" xml:space="preserve">
          <source>Any extension from the &lt;code&gt;Extension&lt;/code&gt; type defined in &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extension&lt;/a&gt; may be used. GHC will report an error if any of the requested extensions are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Language-Haskell-Extension.html&quot;&gt;Language.Haskell.Extensionで&lt;/a&gt;定義された &lt;code&gt;Extension&lt;/code&gt; タイプの任意の拡張機能を使用できます。要求された拡張機能のいずれかがサポートされていない場合、GHCはエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="45294fce8a408e067f71fcddc66e44fa9a3aa925" translate="yes" xml:space="preserve">
          <source>Any field width is followed optionally by a precision:</source>
          <target state="translated">任意のフィールド幅の後には、任意の精度が続きます。</target>
        </trans-unit>
        <trans-unit id="ca99cdb1b6224c8f2acca56e49dc80e277ef33e9" translate="yes" xml:space="preserve">
          <source>Any flags are followed optionally by a field width:</source>
          <target state="translated">任意のフラグの後には、オプションでフィールド幅が続きます。</target>
        </trans-unit>
        <trans-unit id="fe6292886945b8678502b2eed862908e6596bec8" translate="yes" xml:space="preserve">
          <source>Any flags not recognized by runghc are automatically passed to GHC. If a flag is recognized by both runghc and GHC but you want to pass it to GHC then you can place it after a &lt;code&gt;--&lt;/code&gt; separator. Flags after the separator are treated as GHC only flags. Alternatively you can use the runghc option &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass any flag or argument directly to GHC.</source>
          <target state="translated">runghcで認識されないフラグは自動的にGHCに渡されます。フラグがrunghcとGHCの両方で認識されているが、それをGHCに渡したい場合は、次のように配置できます &lt;code&gt;--&lt;/code&gt; セパレータの。セパレータの後のフラグは、GHCのみのフラグとして扱われます。あるいは、runghcオプション &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; を使用して、任意のフラグまたは引数をGHCに直接渡すことができます。</target>
        </trans-unit>
        <trans-unit id="d3a24acb0ed73105a63c6aa8b83c5ce57f71ebe7" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; can be made into an instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; by defining &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; = &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; の任意のインスタンスは、 &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; =を定義することで &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowChoice&quot;&gt;ArrowChoice&lt;/a&gt;&lt;/code&gt; のインスタンスにすることができます。 &lt;code&gt;&lt;a href=&quot;control-arrow#v:leftApp&quot;&gt;leftApp&lt;/a&gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="c46287c62f0868214d45f152801a23db51bd59d4" translate="yes" xml:space="preserve">
          <source>Any instance should be subject to the following laws:</source>
          <target state="translated">どのようなインスタンスであっても、以下の法律の適用を受けるべきです。</target>
        </trans-unit>
        <trans-unit id="b4adffce07a1e96f7b4aa9f3335793d174570cf6" translate="yes" xml:space="preserve">
          <source>Any modifiers found.</source>
          <target state="translated">すべての修飾子が見つかりました。</target>
        </trans-unit>
        <trans-unit id="5cecd2c65d9c46eca630a92c4797e911edc247d7" translate="yes" xml:space="preserve">
          <source>Any number of source file names or module names may be specified; GHC will figure out all the modules in the program by following the imports from these initial modules. It will then attempt to compile each module which is out of date, and finally, if there is a &lt;code&gt;Main&lt;/code&gt; module, the program will also be linked into an executable.</source>
          <target state="translated">ソースファイル名またはモジュール名はいくつでも指定できます。GHCは、これらの初期モジュールからのインポートに従って、プログラム内のすべてのモジュールを把握します。次に、古くなっている各モジュールをコンパイルしようとし、最後に、 &lt;code&gt;Main&lt;/code&gt; モジュール、プログラムも実行可能ファイルにリンクされます。</target>
        </trans-unit>
        <trans-unit id="8a7ee0a6d4ed7c475e886db91c9ca4af5ab7c3c0" translate="yes" xml:space="preserve">
          <source>Any of the command-line options described in the rest of this chapter can be used with &lt;code&gt;--make&lt;/code&gt;, but note that any options you give on the command line will apply to all the source files compiled, so if you want any options to apply to a single source file only, you&amp;rsquo;ll need to use an &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma (see &lt;a href=&quot;#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt;).</source>
          <target state="translated">この章の残りの部分で説明するコマンドラインオプションは &lt;code&gt;--make&lt;/code&gt; で使用できますが、コマンドラインで指定したオプションはコンパイルされたすべてのソースファイルに適用されるため、オプションを適用する場合は注意してください。単一のソースファイルのみに &lt;code&gt;OPTIONS_GHC&lt;/code&gt; するには、OPTIONS_GHCプラグマを使用する必要があり&lt;a href=&quot;#source-file-options&quot;&gt;ます（ソースファイルのコマンドラインオプションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4fcac47fb48917b29ef16b080f9169cd49dcd808" translate="yes" xml:space="preserve">
          <source>Any operation that fails because a handle is closed, also fails if a handle is semi-closed. The only exception is &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt;. A semi-closed handle becomes closed:</source>
          <target state="translated">ハンドルが閉じているために失敗した操作は、ハンドルが半閉じている場合にも失敗します。唯一の例外は &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; です。セミクローズハンドルがクローズされます。</target>
        </trans-unit>
        <trans-unit id="74cf8930fe96c667f6ee4ecd6012b01ea066396e" translate="yes" xml:space="preserve">
          <source>Any orphan instances which are brought into scope by an import from a signature are unconditionally considered in scope, even if the eventual implementing module doesn&amp;rsquo;t actually import the same orphans.</source>
          <target state="translated">最終的な実装モジュールが実際に同じ孤立をインポートしない場合でも、シグネチャからのインポートによってスコープに含まれる孤立インスタンスは、無条件にスコープと見なされます。</target>
        </trans-unit>
        <trans-unit id="2fbfab23f62ec3e48e80e1e5422619cb69668f7f" translate="yes" xml:space="preserve">
          <source>Any other exceptions which are not matched by the predicate are re-raised, and may be caught by an enclosing &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">述語と一致しないその他の例外は再発生し、囲んでいる &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; によってキャッチされる場合があります。など。</target>
        </trans-unit>
        <trans-unit id="a712b26d1cb0416ca0ddd0555d9306a2c267be27" translate="yes" xml:space="preserve">
          <source>Any precision is followed optionally for Integral types by a width modifier; the only use of this modifier being to set the implicit size of the operand for conversion of a negative operand to unsigned:</source>
          <target state="translated">この修飾子の唯一の用途は、負のオペランドを符号なしに変換するためのオペランドの暗黙のサイズを設定することです。</target>
        </trans-unit>
        <trans-unit id="d8c91f9f9f6e75c41b02098e931d3439ddcf440f" translate="yes" xml:space="preserve">
          <source>Any real interval contains a unique simplest rational; in particular, note that &lt;code&gt;0/1&lt;/code&gt; is the simplest rational of all.</source>
          <target state="translated">実際の区間には、一意で最も単純な有理数が含まれています。特に、 &lt;code&gt;0/1&lt;/code&gt; は最も単純な有理数である。</target>
        </trans-unit>
        <trans-unit id="bd6fa11933cdfcdc743d92e3ae1b1b26d19d69a2" translate="yes" xml:space="preserve">
          <source>Any single-constructor data is eligible for unpacking; for example</source>
          <target state="translated">シングルコンストラクタのデータはすべてアンパックの対象となります。</target>
        </trans-unit>
        <trans-unit id="a18603a852f4e4b843d8b21962152ae0dc60595e" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; を介してファイル記述子でブロックされているスレッドは、IO例外がスローされることでブロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="769148ddf54673e79970f08b70786bcc3aab11e0" translate="yes" xml:space="preserve">
          <source>Any threads that are blocked on the file descriptor via &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; will be unblocked by having IO exceptions thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; を介してファイル記述子でブロックされているスレッドは、IO例外がスローされることでブロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="87c36f7b926ac2fbec6f667eb5439c00c637c3ef" translate="yes" xml:space="preserve">
          <source>Any type that you wish to throw or catch as an exception must be an instance of the &lt;code&gt;Exception&lt;/code&gt; class. The simplest case is a new exception type directly below the root:</source>
          <target state="translated">例外としてスローまたはキャッチしたい型はすべて、 &lt;code&gt;Exception&lt;/code&gt; クラスのインスタンスでなければなりません。最も単純なケースは、ルートのすぐ下にある新しい例外タイプです。</target>
        </trans-unit>
        <trans-unit id="b1bd8e562d1fefda868c7d1ff0cda571db4a02aa" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">「exp」の変数はすべてバインドされたオカレンスですが、パターンの「左側」にバインドされた変数はスコープ内にあります。この機能により、たとえば、関数の1つの引数を別の引数のビューで使用できます。たとえば、&lt;a href=&quot;#pattern-guards&quot;&gt;パターンガードの&lt;/a&gt; &lt;code&gt;clunky&lt;/code&gt; 関数は、次のようにビューパターンを使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="5be3f3400c369b3d8251c242743fa27338956055" translate="yes" xml:space="preserve">
          <source>Any variables in ⟨exp⟩ are bound occurrences, but variables bound &amp;ldquo;to the left&amp;rdquo; in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function &lt;code&gt;clunky&lt;/code&gt; from &lt;a href=&quot;pattern_guards#pattern-guards&quot;&gt;Pattern guards&lt;/a&gt; can be written using view patterns as follows:</source>
          <target state="translated">⟨exp⟩内の変数はすべてバインドされたオカレンスですが、パターンの「左側」にバインドされた変数はスコープ内にあります。この機能により、たとえば、関数の1つの引数を別の引数のビューで使用できます。たとえば、&lt;a href=&quot;pattern_guards#pattern-guards&quot;&gt;パターンガードの&lt;/a&gt; &lt;code&gt;clunky&lt;/code&gt; 関数は、次のようにビューパターンを使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="b0f483f182aa56813d1000ce4df4790bcbe905f1" translate="yes" xml:space="preserve">
          <source>Any whitespace which appears outside of either of the quoting and escaping mechanisms, is interpreted as having been added by this special concatenation process to designate where the boundaries are between the original, un-concatenated list of strings. These added whitespace characters are removed from the output.</source>
          <target state="translated">クォーティングおよびエスケープ機構のいずれかの外側に現れる空白文字は、元の文字列の連結されていないリストの間の境界がどこにあるかを指定するために、この特別な連結処理によって追加されたものと解釈されます。これらの追加された空白文字は出力から削除されます。</target>
        </trans-unit>
        <trans-unit id="86fba8724925018bcafcede041fc92c898e3eb9b" translate="yes" xml:space="preserve">
          <source>AnyclassStrategy</source>
          <target state="translated">AnyclassStrategy</target>
        </trans-unit>
        <trans-unit id="2d219c6ebc1efaae092effbbdcf3fa6d485c6699" translate="yes" xml:space="preserve">
          <source>Anything else throws an exception:</source>
          <target state="translated">それ以外のものは例外をスローします。</target>
        </trans-unit>
        <trans-unit id="036d8f7bd31769453184842860e1d5ca8c639fff" translate="yes" xml:space="preserve">
          <source>Anything which is already valid as a constraint without the flag: saturated applications to type classes, implicit parameter and equality constraints.</source>
          <target state="translated">フラグのない制約として既に有効なもの:型クラスへの飽和アプリケーション、暗黙のパラメータ制約、等値制約。</target>
        </trans-unit>
        <trans-unit id="ad26f77e74f38dbef3399b317d10c13e53d32aa2" translate="yes" xml:space="preserve">
          <source>Anything whose form is not yet known, but the user has declared to have kind &lt;code&gt;Constraint&lt;/code&gt; (for which they need to import it from &lt;code&gt;Data.Kind&lt;/code&gt;). So for example &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; is allowed, as well as examples involving type families:</source>
          <target state="translated">フォームはまだ不明ですが、ユーザーが種類の &lt;code&gt;Constraint&lt;/code&gt; （ &lt;code&gt;Data.Kind&lt;/code&gt; からインポートする必要がある）を持つことを宣言したもの。したがって、たとえば &lt;code&gt;type Foo (f :: Type -&amp;gt; Constraint) = forall b. f b =&amp;gt; b -&amp;gt; b&lt;/code&gt; と、タイプファミリーを含む例を使用できます。</target>
        </trans-unit>
        <trans-unit id="b920fb3adf34d73af2cb7b5c93d8efbc94cd36f7" translate="yes" xml:space="preserve">
          <source>Ap</source>
          <target state="translated">Ap</target>
        </trans-unit>
        <trans-unit id="53d21ca24e640bdf8e7b761f501faaae7e4e72fb" translate="yes" xml:space="preserve">
          <source>Apart from removing intermediate data-structures, encodings can be optimized further by fine-tuning their execution parameters using the functions in &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt; and their &quot;inner loops&quot; using the functions in &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;.</source>
          <target state="translated">別に中間データ構造体を除去することから、エンコーディングは、の関数を使用して微調整するそれらの実行パラメータによってさらに最適化することができる&lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;との関数を使用して「内側ループ」&lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14dc219def5159ae2ab7cfd4d71881c1c3903e70" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;code&gt;:{ ... :}&lt;/code&gt; syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by &lt;code&gt;:set +m&lt;/code&gt;, &lt;code&gt;:set +m&lt;/code&gt; in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. For example:</source>
          <target state="translated">上記の複数行入力の &lt;code&gt;:{ ... :}&lt;/code&gt; 構文とは別に、GHCiには複数行モードもあり、 &lt;code&gt;:set +m&lt;/code&gt; 、 &lt;code&gt;:set +m&lt;/code&gt; によって有効になります、現在のステートメントが完了していないときにGHCiが自動的に検出して許可します追加する行を追加します。複数行入力は空行で終了します。例えば：</target>
        </trans-unit>
        <trans-unit id="fc4a695f02a8a53a129dcb9ace91e91ee1e7feb9" translate="yes" xml:space="preserve">
          <source>App</source>
          <target state="translated">App</target>
        </trans-unit>
        <trans-unit id="c607b075485b6dc8c400c818769a9c892ea0ffc4" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">追加 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のファイルに。</target>
        </trans-unit>
        <trans-unit id="f664580544f7f0aa77f101d16e0efbbe807fa6e5" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">追加 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のファイルに。</target>
        </trans-unit>
        <trans-unit id="e26661dc8c698ec289349a6aeecab4d0a5e5ec82" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">追加 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のファイルに。</target>
        </trans-unit>
        <trans-unit id="345b0c25bf20f673449b84d7d686b5c70bebf7c2" translate="yes" xml:space="preserve">
          <source>Append a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">追加 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のファイルに。</target>
        </trans-unit>
        <trans-unit id="4ebc23e4c1b65a48a70d373d483fafb1ccae8ba3" translate="yes" xml:space="preserve">
          <source>Append two lists, i.e.,</source>
          <target state="translated">2つのリストを追加します。</target>
        </trans-unit>
        <trans-unit id="3e0bf0178a1d360f27255c9a7f025fc03359dcd5" translate="yes" xml:space="preserve">
          <source>AppendHandle</source>
          <target state="translated">AppendHandle</target>
        </trans-unit>
        <trans-unit id="374c012a038cea614a313e941a993048c6cf1210" translate="yes" xml:space="preserve">
          <source>AppendMode</source>
          <target state="translated">AppendMode</target>
        </trans-unit>
        <trans-unit id="3916a3175dfaa3fd999b22f53277fe454f6b7b38" translate="yes" xml:space="preserve">
          <source>AppendOnWrite</source>
          <target state="translated">AppendOnWrite</target>
        </trans-unit>
        <trans-unit id="dbe098d861d9a244dfef0444bcf8ab0f87546a7d" translate="yes" xml:space="preserve">
          <source>AppendSymbol</source>
          <target state="translated">AppendSymbol</target>
        </trans-unit>
        <trans-unit id="b67fd654b8abfbeb1a717ca3d11ec607e6526062" translate="yes" xml:space="preserve">
          <source>Applicability</source>
          <target state="translated">Applicability</target>
        </trans-unit>
        <trans-unit id="d311231658a1b3353cd77d4859248f1e061c4cc1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">アプリケーションオペレーター。通常のアプリケーション &lt;code&gt;(f x)&lt;/code&gt; は &lt;code&gt;(f &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; と同じであるため、この演算子は冗長です。ただし、 &lt;code&gt;&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; には低い右結合の優先順位があるため、括弧を省略できる場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="43dbefc4fd00eee5d8e84d6de5dadb9d229d56a1" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">アプリケーションオペレーター。通常のアプリケーション &lt;code&gt;(f x)&lt;/code&gt; は &lt;code&gt;(f &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; と同じであるため、この演算子は冗長です。ただし、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; には低い右結合の優先順位があるため、括弧を省略できる場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="f58752dc50f3a1aa349659b655c647ebed7f8f30" translate="yes" xml:space="preserve">
          <source>Application operator. This operator is redundant, since ordinary application &lt;code&gt;(f x)&lt;/code&gt; means the same as &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; has low, right-associative binding precedence, so it sometimes allows parentheses to be omitted; for example:</source>
          <target state="translated">アプリケーションオペレーター。通常のアプリケーション &lt;code&gt;(f x)&lt;/code&gt; は &lt;code&gt;(f &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; x)&lt;/code&gt; と同じであるため、この演算子は冗長です。ただし、 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; には低い右結合の優先順位があるため、括弧を省略できる場合があります。例えば：</target>
        </trans-unit>
        <trans-unit id="4bf898ba305639dbde7f1d71fe68cf723d6796d1" translate="yes" xml:space="preserve">
          <source>Application-specific customizations to the user interface.</source>
          <target state="translated">ユーザーインターフェースへのアプリケーション固有のカスタマイズ。</target>
        </trans-unit>
        <trans-unit id="0b8a1b21fc212c72c3e7976ca547d1f598c5e314" translate="yes" xml:space="preserve">
          <source>Applicative</source>
          <target state="translated">Applicative</target>
        </trans-unit>
        <trans-unit id="c42b346f9e6450034a0b493919801528c343e948" translate="yes" xml:space="preserve">
          <source>Applicative actions</source>
          <target state="translated">適用行動</target>
        </trans-unit>
        <trans-unit id="98c9a7602c91954ae00f88c84bb4db90472de9d3" translate="yes" xml:space="preserve">
          <source>Applicative do-notation desugaring preserves the original semantics, provided that the &lt;code&gt;Applicative&lt;/code&gt; instance satisfies &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; and &lt;code&gt;pure = return&lt;/code&gt; (these are true of all the common monadic types). Thus, you can normally turn on &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; without fear of breaking your program. There is one pitfall to watch out for; see &lt;a href=&quot;#applicative-do-pitfall&quot;&gt;Things to watch out for&lt;/a&gt;.</source>
          <target state="translated">応用的には、ものとするジャムオリジナルセマンティクス、脱糖表記行う &lt;code&gt;Applicative&lt;/code&gt; のインスタンスを満たす &lt;code&gt;&amp;lt;*&amp;gt; = ap&lt;/code&gt; と &lt;code&gt;pure = return&lt;/code&gt; （これらは全て共通のモナドの種類の真です）。したがって、通常はプログラムを壊すことを恐れずに&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;をオンにすることができます。注意すべき落とし穴が1つあります。&lt;a href=&quot;#applicative-do-pitfall&quot;&gt;注意すべきことを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3040a310341680e034eec3985152bc5a9e486ec2" translate="yes" xml:space="preserve">
          <source>Applicative functor formed by adding pure computations to a given applicative functor.</source>
          <target state="translated">与えられたアプリカティブ・ファンクタに純粋な計算を加えて形成されたアプリカティブ・ファンクタ。</target>
        </trans-unit>
        <trans-unit id="65f268e6aa6cb1e22480a2a575f39395d4e90f10" translate="yes" xml:space="preserve">
          <source>Applicative functors</source>
          <target state="translated">応用ファンクタ</target>
        </trans-unit>
        <trans-unit id="e1507c25dc6a64376527010df0e4de108198887a" translate="yes" xml:space="preserve">
          <source>Applicative general combining function</source>
          <target state="translated">応用的な一般的な結合機能</target>
        </trans-unit>
        <trans-unit id="ba83691e2c1dcc5de53cc3e4b25ca28fcf3f9a3b" translate="yes" xml:space="preserve">
          <source>Applicative merge tactic types</source>
          <target state="translated">応用的なマージ戦術のタイプ</target>
        </trans-unit>
        <trans-unit id="3bb211f1db0886c20dbcbe3aec098bfa4c51a870" translate="yes" xml:space="preserve">
          <source>ApplicativeDo</source>
          <target state="translated">ApplicativeDo</target>
        </trans-unit>
        <trans-unit id="a3e4a569ead07c8bc4d8de675cfd615c69dad24a" translate="yes" xml:space="preserve">
          <source>Applied</source>
          <target state="translated">Applied</target>
        </trans-unit>
        <trans-unit id="919e6fc623e0dc282b30825056bd5dda3c4e6c46" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">述語と &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に適用され、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のすべての要素かどうかを決定します述語を満たします。</target>
        </trans-unit>
        <trans-unit id="637b1e1d5c8efd54c8949c6a43abe4555350a327" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">述語と &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; に適用され、 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; のすべての要素かどうかを決定します述語を満たします。</target>
        </trans-unit>
        <trans-unit id="9e82bc67b89a4b9e5b1ef1666971641ffcc4ec35" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">述語とByteStringに適用され、 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の要素があるかどうかを決定しますを満たす述語。</target>
        </trans-unit>
        <trans-unit id="bbb6d3ed7b10d0b6c91c1b6b6102c1501910cf5b" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">述語とByteStringに適用され、 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の要素があるかどうかを決定しますを満たす述語。</target>
        </trans-unit>
        <trans-unit id="b1b160142b2aab409abf2571e6a42ee896b8231e" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; は述語とリストに適用され、リストのすべての要素が述語を満たすかどうかを決定します。結果が &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; になるためには、リストが有限でなければなりません。 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; から、しかし、結果 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の述語の値は有限または無限リストの有限インデックスにある要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="1bb3df1dee5942308d7549a4ff4e6623460c1a98" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; は述語とリストに適用され、リストのいずれかの要素が述語を満たすかどうかを決定します。結果が &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; になるには、リストが有限でなければなりません。 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; から、しかし、結果は &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 述語の値は有限または無限リストの有限インデックスにある要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="649319403532f404d1828c385726fa18cf17318d" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the list satisfy the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; は述語とリストに適用され、リストのすべての要素が述語を満たすかどうかを決定します。結果が &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; になるためには、リストが有限でなければなりません。 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; から、しかし、結果 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の述語の値は有限または無限リストの有限インデックスにある要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="96fd46ee7a807ee87c60e5d0b9ca946dc3e911cb" translate="yes" xml:space="preserve">
          <source>Applied to a predicate and a list, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the list satisfies the predicate. For the result to be &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, the list must be finite; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, however, results from a &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; value for the predicate applied to an element at a finite index of a finite or infinite list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; は述語とリストに適用され、リストのいずれかの要素が述語を満たすかどうかを決定します。結果が &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; になるには、リストが有限でなければなりません。 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; から、しかし、結果は &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 述語の値は有限または無限リストの有限インデックスにある要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="be0613a1194858373863a5914ef44b595dda15fa" translate="yes" xml:space="preserve">
          <source>Applies a type to a function type. Returns: &lt;code&gt;Just u&lt;/code&gt; if the first argument represents a function of type &lt;code&gt;t -&amp;gt; u&lt;/code&gt; and the second argument represents a function of type &lt;code&gt;t&lt;/code&gt;. Otherwise, returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">型を関数型に適用します。戻り値： &lt;code&gt;Just u&lt;/code&gt; 最初の引数は型の関数で表す場合 &lt;code&gt;t -&amp;gt; u&lt;/code&gt; と2番目の引数が型の機能を表す &lt;code&gt;t&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;Nothing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fee4a02d62b3b562a9c374f2e31932813920bd3d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;(+1)&lt;/code&gt; to a list, a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">適用 &lt;code&gt;(+1)&lt;/code&gt; リストに &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7560eee7a783d22baf2bd6d4444f64f9c9a496fc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; to the second element of a pair:</source>
          <target state="translated">ペアの2番目の要素に &lt;code&gt;&lt;a href=&quot;prelude#v:even&quot;&gt;even&lt;/a&gt;&lt;/code&gt; 適用します。</target>
        </trans-unit>
        <trans-unit id="11040b63f3921092eab408bc2b85dc0c41f9e594" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">&lt;code&gt;Maybe Int&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; を適用します。 &lt;code&gt;Just n&lt;/code&gt; がある場合、基礎となる &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; を表示したいとします。しかし、 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; がある場合、（たとえば） &quot;Nothing&quot;の代わりに空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="615a1ddaf7551b2a4174858609db8c4f030df5a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;Maybe Int&lt;/code&gt;. If we have &lt;code&gt;Just n&lt;/code&gt;, we want to show the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;. But if we have &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, we return the empty string instead of (for example) &quot;Nothing&quot;:</source>
          <target state="translated">&lt;code&gt;Maybe Int&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; を適用します。 &lt;code&gt;Just n&lt;/code&gt; がある場合、基礎となる &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; を表示したいとします。しかし、 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; がある場合、（たとえば） &quot;Nothing&quot;の代わりに空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="edd6c71ec52ff9bccf29d84188bba0b21ce69446" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; 適用ブール値がtrueの場合。</target>
        </trans-unit>
        <trans-unit id="b6b9c8416c76cb38545167e06e3308ec9286dc30" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="6ad84cd5aa8118e1f8b36881b3b884a1d00f4857" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="9745cca7883787ea648c32cd3f515d25f4cb991e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="96e48ba2760c93e4e34b159d49c1dbbc56799681" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="9854504f7be6e574e7bfe679f44b4ee0c6be89cc" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:braces&quot;&gt;braces&lt;/a&gt;&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="1f46147f015f62456e6f042fc1fdd0a4e456ff05" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:brackets&quot;&gt;brackets&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="d053cfa4369b1863e68c118fa964a1a17e42f125" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:doubleQuotes&quot;&gt;doubleQuotes&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="21bdb9c521d1c7d41257920a997db5a1c432b4d7" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:parens&quot;&gt;parens&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に適用します。</target>
        </trans-unit>
        <trans-unit id="83bd5f5c6340c2876e03bdf5c78f42f0045fcd17" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; if boolean is true.</source>
          <target state="translated">ブール値がtrueの場合、 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#t:Doc&quot;&gt;Doc&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:quotes&quot;&gt;quotes&lt;/a&gt;&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="b00536f11c69e40c7baa6a53f5c52fe55c8806e5" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;f&lt;/code&gt;-actions in the reverse order.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; アクションを逆の順序で適用します。</target>
        </trans-unit>
        <trans-unit id="a7fd738556716f25c4a33b181a4727d226b4c919" translate="yes" xml:space="preserve">
          <source>Apply a function to a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; token. When manually applying a function to &lt;code&gt;realWorld#&lt;/code&gt;, it is necessary to use &lt;code&gt;NOINLINE&lt;/code&gt; to prevent semantically undesirable floating. &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; is inlined, but only very late in compilation after all floating is complete.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:State-35-&quot;&gt;State#&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; トークンに関数を適用します。関数を手動で &lt;code&gt;realWorld#&lt;/code&gt; に適用する場合、意味的に望ましくないフローティングを防ぐために &lt;code&gt;NOINLINE&lt;/code&gt; を使用する必要があります。 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:runRW-35-&quot;&gt;runRW#&lt;/a&gt;&lt;/code&gt; はインライン化されていますが、すべてのフローティングが完了してからコンパイルが非常に遅くなります。</target>
        </trans-unit>
        <trans-unit id="15923e60f19aafe01135e2792144867deb99400e" translate="yes" xml:space="preserve">
          <source>Apply a function to the first element of an optional pair.</source>
          <target state="translated">オプションのペアの最初の要素に関数を適用します。</target>
        </trans-unit>
        <trans-unit id="a5aee8e5a78690a96a71ac571dd01657b03993bb" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the continuation passed to a CPS computation.</source>
          <target state="translated">CPS計算に渡された継続を変換する関数を適用します。</target>
        </trans-unit>
        <trans-unit id="35e3f909c25395866110729633dad59aecf7af3c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation.</source>
          <target state="translated">関数を適用して、連続パス計算の結果を変換します。</target>
        </trans-unit>
        <trans-unit id="4ff89ef704740fc048b9ba990998fdecd8670f9c" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">関数を適用して、継続渡し計算の結果を変換します。これは、 &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; がモナドのカテゴリでファンクタを定義しないため、他のモナドトランスフォーマーの &lt;code&gt;map&lt;/code&gt; 操作よりも制限されたタイプです。</target>
        </trans-unit>
        <trans-unit id="d4993fc434940195f4b64a80d66593316a376d43" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a continuation-passing computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">関数を適用して、継続渡し計算の結果を変換します。これは、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#t:ContT&quot;&gt;ContT&lt;/a&gt;&lt;/code&gt; がモナドのカテゴリでファンクタを定義しないため、他のモナドトランスフォーマーの &lt;code&gt;map&lt;/code&gt; 操作よりも制限されたタイプです。</target>
        </trans-unit>
        <trans-unit id="b51211dea86c79bd6e381cda63ad155fa030e446" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation.</source>
          <target state="translated">選択範囲の計算結果を変換する関数を適用します。</target>
        </trans-unit>
        <trans-unit id="119d0767fcb8340ed73d84a60d5eb57b7349f3e5" translate="yes" xml:space="preserve">
          <source>Apply a function to transform the result of a selection computation. This has a more restricted type than the &lt;code&gt;map&lt;/code&gt; operations for other monad transformers, because &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; does not define a functor in the category of monads.</source>
          <target state="translated">関数を適用して、選択計算の結果を変換します。これは、 &lt;code&gt;&lt;a href=&quot;control-monad-trans-select#t:SelectT&quot;&gt;SelectT&lt;/a&gt;&lt;/code&gt; のため、他のモナド変換子の &lt;code&gt;map&lt;/code&gt; 操作よりも制限されたタイプです。はモナドのカテゴリにファンクタを定義していないため、ています。</target>
        </trans-unit>
        <trans-unit id="90c1bc3308702f2e877e752823a6f576e30aa537" translate="yes" xml:space="preserve">
          <source>Apply a transformation to the other computation.</source>
          <target state="translated">他の計算に変換を適用します。</target>
        </trans-unit>
        <trans-unit id="6b6f2a899229fc5c6cb94a1a620e95652b86a4f6" translate="yes" xml:space="preserve">
          <source>Apply one equality to another, respectively</source>
          <target state="translated">1つの平等を別の平等にそれぞれ適用する</target>
        </trans-unit>
        <trans-unit id="3db4052527debed305ed7ac76b5af4b0792839fc" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">無限構造への &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; の適用は、演算子が2番目の引数で遅延しているときに終了します（この場合、最初のアキュムレータは使用されないため、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; することができますが、 &lt;code&gt;[]&lt;/code&gt; の方が明確です）。</target>
        </trans-unit>
        <trans-unit id="afeb81f9b8e9e1466027165d488925a56b444f58" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">無限構造への &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; の適用は、演算子が2番目の引数で遅延しているときに終了します（この場合、最初のアキュムレータは使用されないため、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; することができますが、 &lt;code&gt;[]&lt;/code&gt; の方が明確です）。</target>
        </trans-unit>
        <trans-unit id="5136f3e3a8f7d04f3c546ad5ab418d3fbab0caa7" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; to infinite structures terminates when the operator is lazy in its second argument (the initial accumulator is never used in this case, and so could be left &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;[]&lt;/code&gt; is more clear):</source>
          <target state="translated">無限構造への &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; の適用は、演算子が2番目の引数で遅延しているときに終了します（この場合、最初のアキュムレータは使用されないため、 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; することができますが、 &lt;code&gt;[]&lt;/code&gt; の方が明確です）。</target>
        </trans-unit>
        <trans-unit id="3915aaeccbb6370f41a8ba795caff78447316b72" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;mask&lt;/code&gt; to an exception handler</source>
          <target state="translated">例外ハンドラーへの &lt;code&gt;mask&lt;/code&gt; 適用</target>
        </trans-unit>
        <trans-unit id="7940fbb624b272a2fc9b14574cab25dadfa00758" translate="yes" xml:space="preserve">
          <source>Applying functions of dynamic type</source>
          <target state="translated">動的型の関数の適用</target>
        </trans-unit>
        <trans-unit id="753097d2ed6ee6ae143b40cc67535412f863e165" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度の整数。 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの固定サイズの整数型とは対照的に、 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 型は整数の無限範囲全体を表します。</target>
        </trans-unit>
        <trans-unit id="cea6baf5bc9c5798e19b6c91c89563fb63949b9d" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度の整数。 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの固定サイズの整数型とは対照的に、 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 型は整数の無限範囲全体を表します。</target>
        </trans-unit>
        <trans-unit id="8d3c6b448377adca963a9a043ce17ad5b59ebdc9" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度の整数。 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの固定サイズの整数型とは対照的に、 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 型は整数の無限範囲全体を表します。</target>
        </trans-unit>
        <trans-unit id="78c0f892889dcc2a8ebf1f6c5901067143d19b65" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度の整数。 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの固定サイズの整数型とは対照的に、 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 型は整数の無限範囲全体を表します。</target>
        </trans-unit>
        <trans-unit id="c4918ddd1f06d48d8245e6c5a8235cc03f138f53" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integers. In contrast with fixed-size integral types such as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type represents the entire infinite range of integers.</source>
          <target state="translated">任意精度の整数。 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; などの固定サイズの整数型とは対照的に、 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 型は整数の無限範囲全体を表します。</target>
        </trans-unit>
        <trans-unit id="48a6b0961bc685e7241bda505e193149b1b6e1e7" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">2つの &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 値の比率として表される任意精度の有理数。有理数は、 &lt;code&gt;&lt;a href=&quot;data-ratio#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 演算子を使用して作成できます。</target>
        </trans-unit>
        <trans-unit id="2f570f682fb6c172cde8b33c6dce79b95de7ed61" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision rational numbers, represented as a ratio of two &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values. A rational number may be constructed using the &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">2つの &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 値の比率として表される任意精度の有理数。有理数は、 &lt;code&gt;&lt;a href=&quot;ghc-real#v:-37-&quot;&gt;%&lt;/a&gt;&lt;/code&gt; 演算子を使用して作成できます。</target>
        </trans-unit>
        <trans-unit id="29a35ec82756568480404c0269911333a81119f5" translate="yes" xml:space="preserve">
          <source>Arbitrary-sized tuples</source>
          <target state="translated">任意サイズのタプル</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="9932a4cb0405a0729daea0726dad5bca21f86edb" translate="yes" xml:space="preserve">
          <source>ArgDescr</source>
          <target state="translated">ArgDescr</target>
        </trans-unit>
        <trans-unit id="ffc2c4751c406dfe729e68e12fca79cd5235bbd5" translate="yes" xml:space="preserve">
          <source>ArgMax</source>
          <target state="translated">ArgMax</target>
        </trans-unit>
        <trans-unit id="ff6dd3f82d1ef3b64409b1d48173a3489bd3a0de" translate="yes" xml:space="preserve">
          <source>ArgMin</source>
          <target state="translated">ArgMin</target>
        </trans-unit>
        <trans-unit id="33b3818348e9a7abc5ad4f8c9119835de808618f" translate="yes" xml:space="preserve">
          <source>ArgMin, ArgMax</source>
          <target state="translated">ArgMin,ArgMax</target>
        </trans-unit>
        <trans-unit id="24257e1e26a78c97f1a7d50aeb70e00749ebb9e9" translate="yes" xml:space="preserve">
          <source>ArgOrder</source>
          <target state="translated">ArgOrder</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">引数の種類</target>
        </trans-unit>
        <trans-unit id="6e753ec7f8245ae5fdc7a8b075baae341353e5ea" translate="yes" xml:space="preserve">
          <source>ArgumentLimit</source>
          <target state="translated">ArgumentLimit</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="41c35f0b16b9faa92a29f4ed3edbe5f0ea7a74af" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the executable</source>
          <target state="translated">実行ファイルに渡す引数</target>
        </trans-unit>
        <trans-unit id="e1cbb100861b9948d58a53b976c856c97d398433" translate="yes" xml:space="preserve">
          <source>Arguments which look like &lt;code&gt;@foo&lt;/code&gt; will be replaced with the contents of file &lt;code&gt;foo&lt;/code&gt;. A gcc-like syntax for response files arguments is expected. This must re-constitute the argument list by doing an inverse of the escaping mechanism done by the calling-program side.</source>
          <target state="translated">&lt;code&gt;@foo&lt;/code&gt; のような引数は、ファイル &lt;code&gt;foo&lt;/code&gt; の内容に置き換えられます。応答ファイルの引数にはgccのような構文が必要です。これは、呼び出し側プログラム側で行われるエスケープメカニズムの逆を行うことにより、引数リストを再構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4a70a3f41d906934cb39fa13410a07666b58dc9" translate="yes" xml:space="preserve">
          <source>ArithException</source>
          <target state="translated">ArithException</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="bb08cbe0a6134017a6f7cf472ab8010209d07a2f" translate="yes" xml:space="preserve">
          <source>Arithmetic exceptions.</source>
          <target state="translated">算術の例外。</target>
        </trans-unit>
        <trans-unit id="a9d7caa767383fc4926cd95d59576ba33ee0a3dc" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflow &lt;code&gt;Int&lt;/code&gt; , so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</target>
        </trans-unit>
        <trans-unit id="202699f8498d7982cc53b20732251548a363465a" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;Int&lt;/code&gt; is unchecked for overflowoverflow&lt;code&gt;Int&lt;/code&gt;, so all operations on &lt;code&gt;Int&lt;/code&gt; happen modulo 2&lt;sup&gt;⟨n⟩&lt;/sup&gt; where ⟨n⟩ is the size in bits of the &lt;code&gt;Int&lt;/code&gt; type.</source>
          <target state="translated">上の演算 &lt;code&gt;Int&lt;/code&gt; overflowoverflowためにオフになって &lt;code&gt;Int&lt;/code&gt; 上のすべての操作に、 &lt;code&gt;Int&lt;/code&gt; モジュロ2起こる&lt;sup&gt;⟨n⟩&lt;/sup&gt; ⟨n⟩は、ビットでのサイズである &lt;code&gt;Int&lt;/code&gt; タイプ。</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算術演算</target>
        </trans-unit>
        <trans-unit id="3fecae258b41570e5190fa75b10edfa2c67f433e" translate="yes" xml:space="preserve">
          <source>Arithmetic shift-right operation</source>
          <target state="translated">算術シフト右演算</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="a070934e81973445b297f3e432a70f43cd9eb647" translate="yes" xml:space="preserve">
          <source>Array classes</source>
          <target state="translated">配列クラス</target>
        </trans-unit>
        <trans-unit id="1f72bc74b6f28918205f9e6e811785a34a99cae8" translate="yes" xml:space="preserve">
          <source>Array construction</source>
          <target state="translated">配列構築</target>
        </trans-unit>
        <trans-unit id="b9be2aa72950b9c68024a84de0f4b74e90523e2c" translate="yes" xml:space="preserve">
          <source>Array in which to place the values</source>
          <target state="translated">値を配置する配列</target>
        </trans-unit>
        <trans-unit id="35664ac437e521792c86de2c050b2b9616ad2f9b" translate="yes" xml:space="preserve">
          <source>Array to resize</source>
          <target state="translated">リサイズするための配列</target>
        </trans-unit>
        <trans-unit id="55f55ab0f2f0b52c9ee209db3b03b78882aa29c9" translate="yes" xml:space="preserve">
          <source>Array to write from</source>
          <target state="translated">書き込み元の配列</target>
        </trans-unit>
        <trans-unit id="2dfdceb734024f39f314a3c0b8391586228fb921" translate="yes" xml:space="preserve">
          <source>Array#</source>
          <target state="translated">Array#</target>
        </trans-unit>
        <trans-unit id="898837d96f33bff85a3be5478164cfc6afd0eadc" translate="yes" xml:space="preserve">
          <source>ArrayArray#</source>
          <target state="translated">ArrayArray#</target>
        </trans-unit>
        <trans-unit id="592acb75a6da231d0a2a2173d588c93486db96f4" translate="yes" xml:space="preserve">
          <source>ArrayException</source>
          <target state="translated">ArrayException</target>
        </trans-unit>
        <trans-unit id="93c35e8fd0d3491f05295cbaa9fc1ec445fdc9e3" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;Storable&lt;/code&gt; things.</source>
          <target state="translated">&lt;code&gt;Storable&lt;/code&gt; なものの配列。</target>
        </trans-unit>
        <trans-unit id="6f11fdf73ec1f7aec4ea144e79eb109ff942b709" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements</source>
          <target state="translated">箱から出していない要素を持つ配列</target>
        </trans-unit>
        <trans-unit id="9d7392dc546e184e07e6daaacd277a5d43a5c7da" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">ボックス化されていない要素を持つ配列。インスタンス &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; にするために設けられている &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 特定の要素型で（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; など;参照 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; の完全なリストについては、クラス）。</target>
        </trans-unit>
        <trans-unit id="641e7befb70fe85093114258ec0852dc24a766bf" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types ( &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</target>
        </trans-unit>
        <trans-unit id="fa4ab058d3a73e22b09d2ccc980d2abebbfa6f13" translate="yes" xml:space="preserve">
          <source>Arrays with unboxed elements. Instances of &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; are provided for &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; with certain element types (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, etc.; see the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; class for a full list).</source>
          <target state="translated">ボックス化されていない要素を持つ配列。インスタンス &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; にするために設けられている &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 特定の要素型で（ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; など;参照 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; の完全なリストについては、クラス）。</target>
        </trans-unit>
        <trans-unit id="3a4758c3cc8dac2d76026d0733816741f9b21d43" translate="yes" xml:space="preserve">
          <source>Arrow</source>
          <target state="translated">Arrow</target>
        </trans-unit>
        <trans-unit id="4a7111dcaf1b4237c13ed045e218a14996e9fbe6" translate="yes" xml:space="preserve">
          <source>Arrow application</source>
          <target state="translated">矢印のアプリケーション</target>
        </trans-unit>
        <trans-unit id="e65665c0319750f55e0fe69874130a1cf6d4ed0a" translate="yes" xml:space="preserve">
          <source>Arrow keys</source>
          <target state="translated">矢印キー</target>
        </trans-unit>
        <trans-unit id="a6216e2bed8396214323ababdee0bc0041b0726d" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">矢印表記（参照&lt;a href=&quot;#arrow-notation&quot;&gt;矢印表記&lt;/a&gt;）どんな用途 &lt;code&gt;arr&lt;/code&gt; 、 &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; 、 &lt;code&gt;first&lt;/code&gt; 、 &lt;code&gt;app&lt;/code&gt; 、 &lt;code&gt;(|||)&lt;/code&gt; と &lt;code&gt;loop&lt;/code&gt; 機能が範囲内にあります。ただし、他の構成要素とは異なり、これらの関数の型はPreludeの型と非常によく一致している必要があります。詳細は流動的です。これを使用したい場合は、質問してください！</target>
        </trans-unit>
        <trans-unit id="55386b3ae61f88d0f525742d799552dd74e88c99" translate="yes" xml:space="preserve">
          <source>Arrow notation (see &lt;a href=&quot;arrows#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;) uses whatever &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;(|||)&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt; functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</source>
          <target state="translated">矢印表記（参照&lt;a href=&quot;arrows#arrow-notation&quot;&gt;矢印表記&lt;/a&gt;）どんな用途 &lt;code&gt;arr&lt;/code&gt; 、 &lt;code&gt;(&amp;gt;&amp;gt;&amp;gt;)&lt;/code&gt; 、 &lt;code&gt;first&lt;/code&gt; 、 &lt;code&gt;app&lt;/code&gt; 、 &lt;code&gt;(|||)&lt;/code&gt; と &lt;code&gt;loop&lt;/code&gt; 機能が範囲内にあります。ただし、他の構成とは異なり、これらの関数のタイプはプレリュードタイプと非常に厳密に一致する必要があります。詳細は流動的です。これを使いたいなら聞いてください！</target>
        </trans-unit>
        <trans-unit id="8f1f0db1f62fbb0e92d1c7e980a5aefb808bd919" translate="yes" xml:space="preserve">
          <source>ArrowApply</source>
          <target state="translated">ArrowApply</target>
        </trans-unit>
        <trans-unit id="3c11beff8b02b8f9cbaa16ca3ab20327c65da1ba" translate="yes" xml:space="preserve">
          <source>ArrowChoice</source>
          <target state="translated">ArrowChoice</target>
        </trans-unit>
        <trans-unit id="47595fe84f8dd1e9405b5200e89860454330a77e" translate="yes" xml:space="preserve">
          <source>ArrowLoop</source>
          <target state="translated">ArrowLoop</target>
        </trans-unit>
        <trans-unit id="e45164f39602039a081dfdb414a58cdcb90fce01" translate="yes" xml:space="preserve">
          <source>ArrowMonad</source>
          <target state="translated">ArrowMonad</target>
        </trans-unit>
        <trans-unit id="31cc2db65fb67d75aaa03855c6522bc61f0c5f08" translate="yes" xml:space="preserve">
          <source>ArrowPlus</source>
          <target state="translated">ArrowPlus</target>
        </trans-unit>
        <trans-unit id="a6cef6a13748337ec64d72cbbfdef1e1d56c28ba" translate="yes" xml:space="preserve">
          <source>ArrowT</source>
          <target state="translated">ArrowT</target>
        </trans-unit>
        <trans-unit id="c5b3adde056c0b01047cb4ee63a6ade2f14b6bf6" translate="yes" xml:space="preserve">
          <source>ArrowZero</source>
          <target state="translated">ArrowZero</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="c27973de6a30851ee83300e482ede863a41f7f94" translate="yes" xml:space="preserve">
          <source>Arrows are a generalisation of monads introduced by John Hughes. For more details, see</source>
          <target state="translated">矢印は、John Hughesによって導入されたモナドの一般化です。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="50de5e9983b77e93c151fa7abf423177ee062d7f" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; と同じですが、各ステップのリダクション関数の結果は厳密です。</target>
        </trans-unit>
        <trans-unit id="192565b6bc1ac3ccf6bc1023c2ebb1325b5351f9" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;, but strict in the result of the reduction functions at each step.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; と同じですが、各ステップのリダクション関数の結果は厳密です。</target>
        </trans-unit>
        <trans-unit id="5af372b8d1d974d76bfe10c942fe9d73af03dd9b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;, but with the structure as the primary argument. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; が、主要引数として構造を持ちます。結果を無視しないバージョンについては、 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="fa8707f2ab83f8daca8094457adcacefc1dfcf09" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; are just binary operators, one might ask what happens if the datatype has more than two constructors, or a constructor with more than two fields. The answer is simple: the operators are used several times, to combine all the constructors and fields as needed. However, users /should not rely on a specific nesting strategy/ for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; being used. The compiler is free to choose any nesting it prefers. (In practice, the current implementation tries to produce a more-or-less balanced nesting, so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; ちょうどバイナリ演算子である、一つはデータ型が二つ以上のコンストラクタ、または二つ以上のフィールドを持つコンストラクタを持っている場合、何が起こるか尋ねるかもしれません。答えは簡単です。演算子は数回使用され、必要に応じてすべてのコンストラクターとフィールドを結合します。ただし、ユーザーは/ &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; が使用されているため、/特定のネスト方法に依存すべきではありません。コンパイラーは、好みのネストを自由に選択できます。 （実際には、現在の実装では、データ型の構造のルートから特定のコンポーネントへのトラバーサルを線形時間ではなく対数で実行できるように、多かれ少なかれバランスの取れたネストを生成しようとします。）</target>
        </trans-unit>
        <trans-unit id="d1abb43b60664f44000bb7f5a55f0ee83b119b80" translate="yes" xml:space="preserve">
          <source>As GHC&amp;rsquo;s compilation products don&amp;rsquo;t map perfectly onto DWARF constructs, GHC takes advantage of the extensibility of the DWARF standard to provide additional information.</source>
          <target state="translated">GHCのコンパイル製品はDWARF構造に完全にマッピングされないため、GHCはDWARF標準の拡張性を利用して追加情報を提供します。</target>
        </trans-unit>
        <trans-unit id="e35067b51e094e56d5ae4f8f876dfb483b8f92fd" translate="yes" xml:space="preserve">
          <source>As a binary semaphore &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt;, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as wait and signal.</source>
          <target state="translated">バイナリセマフォ &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt; ()&lt;/code&gt; として、 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を待機およびシグナルとして使用します。</target>
        </trans-unit>
        <trans-unit id="86cdad137d8956982af57685ad5fdd7f0b7b6c9c" translate="yes" xml:space="preserve">
          <source>As a consequence of the &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;levity-polymorphic binder restriction&lt;/a&gt;, levity-polymorphic fields are disallowed in data constructors of data types declared using &lt;code&gt;data&lt;/code&gt;. However, since &lt;code&gt;newtype&lt;/code&gt; data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a &lt;code&gt;newtype&lt;/code&gt; data constructor. Thus, the type checker accepts</source>
          <target state="translated">As a consequence of the &lt;a href=&quot;#levity-polymorphic-restrictions&quot;&gt;levity-polymorphic binder restriction&lt;/a&gt;, levity-polymorphic fields are disallowed in data constructors of data types declared using &lt;code&gt;data&lt;/code&gt; . However, since &lt;code&gt;newtype&lt;/code&gt; data constructor application is implemented as a coercion instead of as function application, this restriction does not apply to the field inside a &lt;code&gt;newtype&lt;/code&gt; data constructor. Thus, the type checker accepts</target>
        </trans-unit>
        <trans-unit id="e1bbfcb820033011b427f73f5d8e7b567bf9a401" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">これらの法則の結果として、 &lt;code&gt;f&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスは、</target>
        </trans-unit>
        <trans-unit id="f93309e1645a680e5a41f639c6d8007d29bdfd58" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">これらの法則の結果として、 &lt;code&gt;f&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスは、</target>
        </trans-unit>
        <trans-unit id="80b0e3a1e8c000dc891586ccc71861ad6328cf11" translate="yes" xml:space="preserve">
          <source>As a consequence of these laws, the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;f&lt;/code&gt; will satisfy</source>
          <target state="translated">これらの法則の結果として、 &lt;code&gt;f&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; インスタンスは、</target>
        </trans-unit>
        <trans-unit id="243016489dff72f5ede560d16315ebcafa404bd9" translate="yes" xml:space="preserve">
          <source>As a consequence, zero is represented with a WordArray# whose size is 0.</source>
          <target state="translated">そのため、0はサイズが0のWordArray#で表現されます。</target>
        </trans-unit>
        <trans-unit id="429a16b965fd947d5a1e23ea21fc9c7acb81cf44" translate="yes" xml:space="preserve">
          <source>As a constructor</source>
          <target state="translated">コンストラクタとして</target>
        </trans-unit>
        <trans-unit id="5d801d83cd9e0b19d834377699e0695ddc3ca42e" translate="yes" xml:space="preserve">
          <source>As a constructor with record syntax</source>
          <target state="translated">レコード構文を持つコンストラクタとして</target>
        </trans-unit>
        <trans-unit id="495b629e3096b9e923e5d90d66fa536008c4f084" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;../using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">便宜上、GHCでは、名前が明確な場合は引用符を省略できます。ただし、私たちの経験では、引用符はコードを読みやすくし、エラーが発生しにくくするのに役立ちます。したがって、GHCは&lt;a href=&quot;../using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt;をサポートしており、引用符を前に付けずにプロモートされたデータコンストラクターを使用すると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="9189865da8d3692a10ab79cac723aaeb6eea7be7" translate="yes" xml:space="preserve">
          <source>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports &lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt;&lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt;&lt;/a&gt; that will warn you if you use a promoted data constructor without a preceding quote mark.</source>
          <target state="translated">便宜上、GHCでは名前が明確な場合に引用符を省略できます。ただし、私たちの経験では、引用符はコードを読みやすくし、エラーを起こしにくくするのに役立ちます。したがって、GHCは&lt;a href=&quot;using-warnings#ghc-flag--Wunticked-promoted-constructors&quot;&gt; &lt;code&gt;-Wunticked-promoted-constructors&lt;/code&gt; &lt;/a&gt;をサポートしており、先行する引用符なしで昇格されたデータコンストラクターを使用した場合に警告します。</target>
        </trans-unit>
        <trans-unit id="ce1486ef373f517210a834efa7f6eeb842e7f926" translate="yes" xml:space="preserve">
          <source>As a general rule, if a data type has a derived &lt;code&gt;Functor&lt;/code&gt; instance and its last type parameter occurs on the right-hand side of the data declaration, then either it must (1) occur bare (e.g., &lt;code&gt;newtype Id a = Id a&lt;/code&gt;), or (2) occur as the last argument of a type constructor (as in &lt;code&gt;Right&lt;/code&gt; above).</source>
          <target state="translated">一般的なルールとして、データ型に派生 &lt;code&gt;Functor&lt;/code&gt; インスタンスがあり、その最後の型パラメーターがデータ宣言の右側にある場合、それは（1）裸である必要があります（たとえば、 &lt;code&gt;newtype Id a = Id a&lt;/code&gt; ） （同様に、または（2）型コンストラクタの最後の引数として生じる &lt;code&gt;Right&lt;/code&gt; 上記）。</target>
        </trans-unit>
        <trans-unit id="e5b650f5b24353725153d71d0ace5287fade8a17" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">Parsecパーサーをデバッグするためのより包括的な代替手段として、&lt;a href=&quot;http://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt;パッケージもあります。</target>
        </trans-unit>
        <trans-unit id="77de548b67c5a91d54fca9a27ff2e0d7ee04de4b" translate="yes" xml:space="preserve">
          <source>As a more comprehensive alternative for debugging Parsec parsers, there's also the &lt;a href=&quot;https://hackage.haskell.org/package/parsec-free&quot;&gt;parsec-free&lt;/a&gt; package.</source>
          <target state="translated">Parsecパーサーをデバッグするためのより包括的な代替手段として、&lt;a href=&quot;https://hackage.haskell.org/package/parsec-free&quot;&gt;parsecフリー&lt;/a&gt;パッケージもあります。</target>
        </trans-unit>
        <trans-unit id="826ab8729c5c6b675ee7477d0a06b532fb5de96a" translate="yes" xml:space="preserve">
          <source>As a more substantial example of the rules in action, consider</source>
          <target state="translated">より実質的なルールの例として、次のことを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="8478fed6cf150b0bde8267af58280dff83b3ef83" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a frontend plugin that prints the arguments that were passed to it, and then exits.</source>
          <target state="translated">簡単な例として、渡された引数を表示して終了するフロントエンドプラグインを以下に示します。</target>
        </trans-unit>
        <trans-unit id="991de1e28384a51531170b3384f7afcc4d87ef71" translate="yes" xml:space="preserve">
          <source>As a quick example, here is a simple plugin that just does nothing and just returns the original compilation pipeline, unmodified, and says &amp;lsquo;Hello&amp;rsquo;:</source>
          <target state="translated">簡単な例として、何もせずに元のコンパイルパイプラインを変更せずに返し、「Hello」と言う単純なプラグインを次に示します。</target>
        </trans-unit>
        <trans-unit id="85bb4cc8874a7fe78368b1f43fbe3cade8bd0615" translate="yes" xml:space="preserve">
          <source>As a result of this extension, all derived instances in newtype declarations are treated uniformly (and implemented just by reusing the dictionary for the representation type), &lt;em&gt;except&lt;/em&gt;&lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt;, which really behave differently for the newtype and its representation.</source>
          <target state="translated">この拡張の結果、newtypeとその表現で実際に異なる動作をする &lt;code&gt;Show&lt;/code&gt; と &lt;code&gt;Read&lt;/code&gt; を&lt;em&gt;除いて&lt;/em&gt;、newtype宣言のすべての派生インスタンスは均一に扱われます（そして、表現型の辞書を再利用するだけで実装されます）。</target>
        </trans-unit>
        <trans-unit id="2f623b893d4cdf977b1e0a124c17974b2bd70476" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;inst_top&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;.</source>
          <target state="translated">その結果、 &lt;code&gt;inst_top&lt;/code&gt; は、すべての数量化と制約を &lt;code&gt;opt_forall&lt;/code&gt; と &lt;code&gt;opt_context&lt;/code&gt; で前もって配置します。</target>
        </trans-unit>
        <trans-unit id="b46bedb78774bd2cc4f8ff31c4366eaf33f5bd61" translate="yes" xml:space="preserve">
          <source>As a result, it requires approximately twice as much memory as its result to construct its result. For files more than a half of available RAM in size, this may result in memory exhaustion.</source>
          <target state="translated">その結果、その結果を構築するためには、その結果の約2倍のメモリを必要とします。利用可能なRAMの半分以上のサイズのファイルの場合、これはメモリを使い果たしてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="23608896f360a0680014f0f847570a9754d15267" translate="yes" xml:space="preserve">
          <source>As a result, traversal with a function &lt;strong&gt;&lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt;&lt;/strong&gt;, over an input container &lt;strong&gt;&lt;code&gt;t a&lt;/code&gt;&lt;/strong&gt;, yields a list &lt;strong&gt;&lt;code&gt;[t b]&lt;/code&gt;&lt;/strong&gt;, whose length is the product of the lengths of the lists that the function returns for each element of the input container! The individual elements &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; of the container are replaced by each element of &lt;strong&gt;&lt;code&gt;f a&lt;/code&gt;&lt;/strong&gt; in turn:</source>
          <target state="translated">その結果、入力コンテナ&lt;strong&gt; &lt;code&gt;t a&lt;/code&gt; &lt;/strong&gt;上で関数&lt;strong&gt; &lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt; &lt;/strong&gt;トラバースすると、リスト&lt;strong&gt; &lt;code&gt;[t b]&lt;/code&gt; &lt;/strong&gt;が生成されます。このリストの長さは、関数がの各要素に対して返すリストの長さの積です。入力コンテナ！コンテナの個々の要素&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;は、&lt;strong&gt; &lt;code&gt;f a&lt;/code&gt; &lt;/strong&gt;各要素に順番に置き換えられます。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e9d8d378558658c4bde3d6e6c2d01732f382a26" translate="yes" xml:space="preserve">
          <source>As a simple example of an encoding implementation, we show how to efficiently convert the following representation of mixed-data tables to an UTF-8 encoded Comma-Separated-Values (CSV) table.</source>
          <target state="translated">エンコード実装の簡単な例として、以下のような混合データテーブルの表現をUTF-8エンコードされたカンマ区切り値(CSV)テーブルに効率的に変換する方法を示します。</target>
        </trans-unit>
        <trans-unit id="ca12c18463b6879d5a860720c0092cdccee7f627" translate="yes" xml:space="preserve">
          <source>As a single extra-constraints wildcard is enough to infer any number of constraints, only one is allowed in a type signature and it should come last in the list of constraints.</source>
          <target state="translated">1つの余分な制約ワイルドカードだけでいくつでも制約を推論することができるので、型署名では1つだけが許され、それは制約のリストの最後に来るべきです。</target>
        </trans-unit>
        <trans-unit id="ba8ae9d2e67cab36cf8dbfe80e256d78b5863ef7" translate="yes" xml:space="preserve">
          <source>As a workaround, we allow to bind &lt;code&gt;(*)&lt;/code&gt; in prefix form:</source>
          <target state="translated">回避策として、接頭辞形式で &lt;code&gt;(*)&lt;/code&gt; をバインドできます。</target>
        </trans-unit>
        <trans-unit id="b52875799ff2828c6eeb24db51f51ce6b5d35654" translate="yes" xml:space="preserve">
          <source>As always, for RTS options that take ⟨size⟩s: If the last character of ⟨size⟩ is a K or k, multiply by 1000; if an M or m, by 1,000,000; if a G or G, by 1,000,000,000. (And any wraparound in the counters is &lt;em&gt;your&lt;/em&gt; fault!)</source>
          <target state="translated">いつものように、「サイズ」をとるRTSオプションの場合：「サイズ」の最後の文字がKまたはkの場合、1000を掛けます。Mまたはmの場合、1,000,000; GまたはGの場合、1,000,000,000。（そして、カウンターの回り込みは&lt;em&gt;あなたの&lt;/em&gt;責任です！）</target>
        </trans-unit>
        <trans-unit id="99567f4b6e834794323885b782256cd2c328ea5e" translate="yes" xml:space="preserve">
          <source>As always, type synonyms must be fully applied. You cannot, for example, write:</source>
          <target state="translated">いつものように、型の同義語は完全に適用されなければなりません。例えば、次のように書くことはできません。</target>
        </trans-unit>
        <trans-unit id="13c3594421b98bd2bf10cd954eb77cee53d78c7c" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通り &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; ない &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; はエラー処理をバイパス &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のモナドをしてによって傍受することはできません &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; からの&lt;a href=&quot;prelude&quot;&gt;前奏曲&lt;/a&gt;。ただし、これは &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; であり、&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;の関数を使用してキャッチできます。これは、（&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;から） &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 追加されたクリーンアップ計算も &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; で適切に実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="9a64b93c54367f32283d34b8466c83c540d04226" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通り &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; ない &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; はエラー処理をバイパス &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のモナドをしてによって傍受することはできません &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; からの&lt;a href=&quot;prelude&quot;&gt;前奏曲&lt;/a&gt;。ただし、これは &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; であり、&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;の関数を使用してキャッチできます。これは、 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 追加されたクリーンアップ計算（&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;から）も &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; で適切に実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="39edd1cc6e94c784b4f7e11ad121c08ce0f9db79" translate="yes" xml:space="preserve">
          <source>As an &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is not an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; bypasses the error handling in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and cannot be intercepted by &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;. However it is a &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;, and can be caught using the functions of &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;. This means that cleanup computations added with &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; (from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) are also executed properly on &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通り &lt;code&gt;&lt;a href=&quot;system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; ない &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; はエラー処理をバイパス &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; のモナドをしてによって傍受することはできません &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; からの&lt;a href=&quot;prelude&quot;&gt;前奏曲&lt;/a&gt;。ただし、これは &lt;code&gt;&lt;a href=&quot;control-exception#v:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; であり、&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;の関数を使用してキャッチできます。これは、（&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;から） &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 追加されたクリーンアップ計算もexitWithで適切に実行されることを意味します。</target>
        </trans-unit>
        <trans-unit id="7a4cafca22cd8d1a307b13e29242f4d26666e5a9" translate="yes" xml:space="preserve">
          <source>As an example of signaling an error in the error monad &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, consider a safe division function &lt;code&gt;safeDiv x y&lt;/code&gt; that returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the denominator &lt;code&gt;y&lt;/code&gt; is zero and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div`
 y)&lt;/code&gt; otherwise. For example:</source>
          <target state="translated">エラーモナド &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; でエラーを通知する例として、分母 &lt;code&gt;y&lt;/code&gt; がゼロの場合は &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x `div` y)&lt;/code&gt; （x `div` y）を返す安全な除算関数 &lt;code&gt;safeDiv x y&lt;/code&gt; 考えます。例えば：</target>
        </trans-unit>
        <trans-unit id="c06e5fe5eaba60d194f35398d388c5324d3e8468" translate="yes" xml:space="preserve">
          <source>As an example which does &lt;em&gt;not&lt;/em&gt; work, consider</source>
          <target state="translated">ない例として&lt;em&gt;ではない&lt;/em&gt;仕事、考えます</target>
        </trans-unit>
        <trans-unit id="6347b158715a28dac26c8c73ed1a2953999b56f9" translate="yes" xml:space="preserve">
          <source>As an example, consider a simple pretty-printer class &lt;code&gt;SPretty&lt;/code&gt;, which outputs pretty strings:</source>
          <target state="translated">例として、きれいな文字列を出力する単純なプリティプリンタークラス &lt;code&gt;SPretty&lt;/code&gt; を考えます。</target>
        </trans-unit>
        <trans-unit id="522dfa47c182924ecba88bb21606211e4b6f02fd" translate="yes" xml:space="preserve">
          <source>As an example, consider the following pipeline:</source>
          <target state="translated">例として、次のようなパイプラインを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="42d246ca4c667eae440bdea085741dec65a2d440" translate="yes" xml:space="preserve">
          <source>As an example, consider the type of predicate functions &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt;. One such predicate might be &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt;, which classifies integers as to whether they are negative. However, given this predicate, we can re-use it in other situations, providing we have a way to map values &lt;em&gt;to&lt;/em&gt; integers. For instance, we can use the &lt;code&gt;negative&lt;/code&gt; predicate on a person's bank balance to work out if they are currently overdrawn:</source>
          <target state="translated">例として、述語関数のタイプ &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt; 考えます。そのような述語の1つは &lt;code&gt;negative x = x &amp;lt; 0&lt;/code&gt; であり、整数が負かどうかを分類します。ただし、この述語が与えられれば、値&lt;em&gt;を&lt;/em&gt;整数にマッピングする方法があれば、他の状況でそれを再利用できます。たとえば、人の銀行残高の &lt;code&gt;negative&lt;/code&gt; 述語を使用して、現在それらが過剰に引き出されているかどうかを調べることができます。</target>
        </trans-unit>
        <trans-unit id="9c76375fc08b8bec18373864d63325042996901b" translate="yes" xml:space="preserve">
          <source>As an example, in order to load the plugin exported by &lt;code&gt;Foo.Plugin&lt;/code&gt; in the package &lt;code&gt;foo-ghc-plugin&lt;/code&gt;, and give it the parameter &amp;ldquo;baz&amp;rdquo;, we would invoke GHC like this:</source>
          <target state="translated">例として、 &lt;code&gt;Foo.Plugin&lt;/code&gt; によってエクスポートされたプラグインをパッケージ &lt;code&gt;foo-ghc-plugin&lt;/code&gt; にロードし、それにパラメーター「baz」を与えるには、次のようにGHCを呼び出します。</target>
        </trans-unit>
        <trans-unit id="362dc967d86ad4ea9a7d9c73fea6acc2cbd89dbf" translate="yes" xml:space="preserve">
          <source>As an example, let us look at a function &lt;code&gt;encode&lt;/code&gt; that produces a naive, but lossless bit encoding of values of various datatypes. So we are aiming to define a function</source>
          <target state="translated">例として、さまざまなデータ型の値の素朴ではあるが損失のないビット &lt;code&gt;encode&lt;/code&gt; を生成する関数エンコードを見てみましょう。したがって、関数を定義することを目指しています</target>
        </trans-unit>
        <trans-unit id="33852151126c630432f1fdab8e0ba978ca5481a5" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s define an interface for a plugin system where the plugin authors are untrusted, possibly malicious third-parties. We do this by restricting the plugin interface to pure functions or to a restricted &lt;code&gt;IO&lt;/code&gt; monad that we have defined. The restricted &lt;code&gt;IO&lt;/code&gt; monad will only allow a safe subset of &lt;code&gt;IO&lt;/code&gt; actions to be executed. We define the plugin interface so that it requires the plugin module, &lt;code&gt;Danger&lt;/code&gt;, to export a single computation, &lt;code&gt;Danger.runMe&lt;/code&gt;, of type &lt;code&gt;RIO ()&lt;/code&gt;, where &lt;code&gt;RIO&lt;/code&gt; is a monad defined as follows:</source>
          <target state="translated">例として、プラグインの作成者が信頼されていない、おそらく悪意のあるサードパーティであるプラグインシステムのインターフェースを定義してみましょう。これを行うには、プラグインインターフェイスを純粋な関数または定義した制限付き &lt;code&gt;IO&lt;/code&gt; モナドに制限します。制限付き &lt;code&gt;IO&lt;/code&gt; モナドでは、 &lt;code&gt;IO&lt;/code&gt; アクションの安全なサブセットのみを実行できます。プラグインインターフェイスを定義して、プラグインモジュール &lt;code&gt;Danger&lt;/code&gt; がタイプ &lt;code&gt;RIO ()&lt;/code&gt; 単一の計算 &lt;code&gt;Danger.runMe&lt;/code&gt; をエクスポートする必要があるようにします。ここで、 &lt;code&gt;RIO&lt;/code&gt; は次のように定義されたモナドです。</target>
        </trans-unit>
        <trans-unit id="70582809de8cd9e89c6a9bd154c02621c8e3fe1c" translate="yes" xml:space="preserve">
          <source>As an example, suppose we have following special printing module:</source>
          <target state="translated">例えば、以下のような特殊な印刷モジュールがあるとします。</target>
        </trans-unit>
        <trans-unit id="6adf45b29a6631ff6d424f3a35e51b0c62f84184" translate="yes" xml:space="preserve">
          <source>As an example, suppose you read a large string, of which you need only a small portion. If you do not use &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt;, the entire original array will be kept alive in memory by the smaller string. Making a copy &quot;breaks the link&quot; to the original array, allowing it to be garbage collected if there are no other live references to it.</source>
          <target state="translated">例として、ほんの一部しか必要としない大きな文字列を読み取るとします。 &lt;code&gt;&lt;a href=&quot;data-text#v:copy&quot;&gt;copy&lt;/a&gt;&lt;/code&gt; を使用しない場合は、元の配列全体が小さい文字列によってメモリに保持されます。コピーを作成すると、元の配列への「リンクが解除され」、他のライブ参照がない場合にガベージコレクションが可能になります。</target>
        </trans-unit>
        <trans-unit id="d63ea3a1b75b9abed859b37118efd2bdfeda9979" translate="yes" xml:space="preserve">
          <source>As an example, this data declaration:</source>
          <target state="translated">例として、このデータ宣言。</target>
        </trans-unit>
        <trans-unit id="490082850527086dedfac3775659ee1738c0ae5d" translate="yes" xml:space="preserve">
          <source>As another example, this is the layout for the unboxed version of &lt;code&gt;Maybe a&lt;/code&gt; type, &lt;code&gt;(# (# #) | a #)&lt;/code&gt;:</source>
          <target state="translated">別の例として、これはボックス化されていないバージョンの &lt;code&gt;Maybe a&lt;/code&gt; タイプのレイアウトです &lt;code&gt;(# (# #) | a #)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="18151bc795d27e140f421a3a96b2c553b0826f0d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">別の例として、我々はタイプが考えることができます &lt;code&gt;Set a&lt;/code&gt; によると、データのセットを表すことを命じたの &lt;code&gt;Ord&lt;/code&gt; インスタンス。 &lt;code&gt;a&lt;/code&gt; がロールを表すものであると考えることは一般にタイプセーフですが、 &lt;code&gt;newtype&lt;/code&gt; とその基本タイプは、それぞれの &lt;code&gt;Ord&lt;/code&gt; インスタンスで&lt;em&gt;異なる&lt;/em&gt;順序付けがエンコードされている可能性があります。これにより、実行時に誤動作が発生します。そのため、 &lt;code&gt;Set&lt;/code&gt; データ型の作成者は、そのパラメーターを名目上の役割にしたいと考えています。これは宣言で行われます &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e081e131ffbc4e13afc7b95b1192b51f216cb4d" translate="yes" xml:space="preserve">
          <source>As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</source>
          <target state="translated">As another example, we can consider a type &lt;code&gt;Set a&lt;/code&gt; that represents a set of data, ordered according to &lt;code&gt;a&lt;/code&gt; &amp;rsquo;s &lt;code&gt;Ord&lt;/code&gt; instance. While it would generally be type-safe to consider &lt;code&gt;a&lt;/code&gt; to be at role representational, it is possible that a &lt;code&gt;newtype&lt;/code&gt; and its base type have &lt;em&gt;different&lt;/em&gt; orderings encoded in their respective &lt;code&gt;Ord&lt;/code&gt; instances. This would lead to misbehavior at runtime. So, the author of the &lt;code&gt;Set&lt;/code&gt; datatype would like its parameter to be at role nominal. This would be done with a declaration</target>
        </trans-unit>
        <trans-unit id="971f3c8e7fa04aa11b176990e12b0d8a905825b5" translate="yes" xml:space="preserve">
          <source>As before, only one selector function is generated here, that for &lt;code&gt;tag&lt;/code&gt;. Nevertheless, you can still use all the field names in pattern matching and record construction.</source>
          <target state="translated">前と同じように、ここでは &lt;code&gt;tag&lt;/code&gt; 用の1つのセレクター関数のみが生成されます。それでも、パターンマッチングやレコード構築ですべてのフィールド名を使用できます。</target>
        </trans-unit>
        <trans-unit id="aa864a2dee7d7cdb239046ddc338c3e2554307a5" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;base&lt;/code&gt; package. &lt;a href=&quot;phases#ghc-flag--flink-rts&quot;&gt;&lt;code&gt;-flink-rts&lt;/code&gt;&lt;/a&gt; additionally links against the shared library version of the &lt;code&gt;rts&lt;/code&gt; package (linking against the &lt;code&gt;rts&lt;/code&gt; package is not enabled by default when building shared libraries). You may also omit &lt;code&gt;-flink-rts&lt;/code&gt; and link the RTS library into your final executable.</source>
          <target state="translated">以前と同様に、&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;フラグは、このライブラリが &lt;code&gt;base&lt;/code&gt; パッケージの共有ライブラリバージョンに対してリンクすることを指定します。&lt;a href=&quot;phases#ghc-flag--flink-rts&quot;&gt; &lt;code&gt;-flink-rts&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;rts&lt;/code&gt; パッケージの共有ライブラリバージョンに対して追加でリンクします（共有ライブラリを構築する場合、 &lt;code&gt;rts&lt;/code&gt; パッケージに対するリンクはデフォルトでは有効になっていません）。 &lt;code&gt;-flink-rts&lt;/code&gt; を省略して、RTSライブラリを最終的な実行可能ファイルにリンクすることもできます。</target>
        </trans-unit>
        <trans-unit id="1b294469f3600688f3c16a9375ab450bd92e329f" translate="yes" xml:space="preserve">
          <source>As before, the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag specifies that this library links against the shared library versions of the &lt;code&gt;rts&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; package. The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">前と同様に、&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;フラグは、このライブラリが &lt;code&gt;rts&lt;/code&gt; および &lt;code&gt;base&lt;/code&gt; パッケージの共有ライブラリバージョンに対してリンクすることを指定します。&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;フラグは、共有ライブラリになってしまいますすべてのコードのために必要とされます。&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;フラグ指定は共有ライブラリではなく、プログラムを作成します。これをより明確にするために、これを個別のコンパイルとリンクのステップに分解できます。</target>
        </trans-unit>
        <trans-unit id="7075fa9b7f0c6ece6ef586ef8232718a3c4e1adf" translate="yes" xml:space="preserve">
          <source>As channels, with &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as receive and send, and</source>
          <target state="translated">チャネルとして、 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を送受信として使用し、</target>
        </trans-unit>
        <trans-unit id="5f8a308216057de51dc8e2d87492c599832235ef" translate="yes" xml:space="preserve">
          <source>As described above, the way in which a file is processed by GHC depends on its suffix. This behaviour can be overridden using the &lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-x ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">上記のように、GHCによるファイルの処理方法は、その拡張子によって異なります。この動作は、&lt;a href=&quot;#ghc-flag--x%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-x ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;オプションを使用してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="ac41a6f7a2ba794206a1881f72e83bfc76ecc4c5" translate="yes" xml:space="preserve">
          <source>As discussed earlier, use &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to disambiguate GHC flags when needed. For example, &lt;code&gt;-f&lt;/code&gt; is recognized by runghc, therefore to pass &lt;code&gt;-fliberate-case&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">前に説明したように、 &lt;code&gt;--&lt;/code&gt; または &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; を使用して、必要に応じてGHCフラグを明確にします。たとえば、 &lt;code&gt;-f&lt;/code&gt; はrunghcによって認識されるため、 &lt;code&gt;-fliberate-case&lt;/code&gt; をGHC に渡すには、次のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="67cc7c655699a8e4a2e0b555a8afa1e30261d029" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">このライブラリ内のすべての分割関数に関して、この関数は部分文字列をコピーせず、元のスライスである新しい &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を作成するだけです。</target>
        </trans-unit>
        <trans-unit id="8991e65b25a1268c5578c175657da1832d9cb512" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">このライブラリ内のすべての分割関数に関して、この関数は部分文字列をコピーせず、元のスライスである新しい &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を作成するだけです。</target>
        </trans-unit>
        <trans-unit id="78cc6104aca9fb1ec54052832ddebd0c39befee4" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">このライブラリ内のすべての分割関数に関して、この関数は部分文字列をコピーせず、元のスライスである新しい &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を作成するだけです。</target>
        </trans-unit>
        <trans-unit id="47a4bb98e7bde318e0428ee9df25a1247392901b" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s that are slices of the original.</source>
          <target state="translated">このライブラリ内のすべての分割関数に関して、この関数は部分文字列をコピーせず、元のスライスである新しい &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; を作成するだけです。</target>
        </trans-unit>
        <trans-unit id="fe90224af19846dad1a17ef9f898f327403d732c" translate="yes" xml:space="preserve">
          <source>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new &lt;code&gt;ByteStrings&lt;/code&gt; that are slices of the original.</source>
          <target state="translated">このライブラリのすべての分割関数については、この関数は部分文字列をコピーせず、元のスライスである新しい &lt;code&gt;ByteStrings&lt;/code&gt; を構築するだけです。</target>
        </trans-unit>
        <trans-unit id="66418d326af7c7178dbcf345c383fa758cb34200" translate="yes" xml:space="preserve">
          <source>As for type signatures, implicit quantification happens for non-overloaded types too. So if you write this:</source>
          <target state="translated">型のシグネチャに関しては、オーバーロードされていない型でも暗黙の定量化が行われます。だから、こう書けば</target>
        </trans-unit>
        <trans-unit id="131c4ed80f84ad7adaad005b0b251d5561f2e9bd" translate="yes" xml:space="preserve">
          <source>As iconv is missing in some minimal environments (e.g. #10298), this checks to ensure that iconv is working properly before returning the encoding, returning &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if not.</source>
          <target state="translated">一部の最小限の環境（＃10298など）ではiconvが欠落しているため、これは、エンコーディングを返す前にiconvが適切に動作していることを確認し、そうでない場合は &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9a094fb6c3fac4ea42a5b01e068a43a07a1612b8" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#define&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">適切な &lt;code&gt;#define&lt;/code&gt; ディレクティブがソースに配置されているかのように。</target>
        </trans-unit>
        <trans-unit id="0b3a2a9b0861349d1000eb5c63f5fe83939ea7af" translate="yes" xml:space="preserve">
          <source>As if the appropriate &lt;code&gt;#include&lt;/code&gt; directive was placed in the source.</source>
          <target state="translated">適切な &lt;code&gt;#include&lt;/code&gt; ディレクティブがソースに配置されているかのように。</target>
        </trans-unit>
        <trans-unit id="beaf430a25d7c8a7463fc714eeb5bef652c1ca18" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;2&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="098c067155c3928cc8e309c0b70434dda18ac150" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;[2]&lt;/a&gt;, the FFI is not actually needed for this. &lt;code&gt;GHC.Exts&lt;/code&gt; includes primitives for reading from on &lt;code&gt;ArrayArray#&lt;/code&gt;.</source>
          <target state="translated">以下のように&lt;a href=&quot;#id6&quot; id=&quot;id8&quot;&gt;、[2]&lt;/a&gt;、FFIは、実際にはこのために必要とされていません。 &lt;code&gt;GHC.Exts&lt;/code&gt; には、 &lt;code&gt;ArrayArray#&lt;/code&gt; から読み取るためのプリミティブが含まれています。</target>
        </trans-unit>
        <trans-unit id="3704be0b1f85ea495e4739ed1a37ef32e604634f" translate="yes" xml:space="preserve">
          <source>As in Haskell 98, the class hierarchy must be acyclic. However, the definition of &amp;ldquo;acyclic&amp;rdquo; involves only the superclass relationships. For example, this is okay:</source>
          <target state="translated">Haskell 98と同様に、クラス階層は非循環でなければなりません。ただし、「非循環」の定義には、スーパークラスの関係のみが含まれます。たとえば、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="a18ecf9c948be4e27d139d19b812430b86052cfe" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">Haskell-98のようなレコード構文（&lt;a href=&quot;#existential-records&quot;&gt;レコードコンストラクター&lt;/a&gt;）を使用して宣言された実在性の場合と同様に、レコードセレクター関数は、適切に型指定されたセレクターを持つフィールドに対してのみ生成されます。以下は、GADTスタイルの構文でのそのセクションの例です。</target>
        </trans-unit>
        <trans-unit id="92ba8fd84c6bd0e839142f8b7eca6e02c9f392cc" translate="yes" xml:space="preserve">
          <source>As in the case of existentials declared using the Haskell-98-like record syntax (&lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</source>
          <target state="translated">Haskell-98のようなレコード構文（&lt;a href=&quot;existential_quantification#existential-records&quot;&gt;レコードコンストラクター&lt;/a&gt;）を使用して宣言された存在の場合と同様に、レコードセレクター関数は、適切に型指定されたセレクターを持つフィールドに対してのみ生成されます。GADTスタイルの構文でのそのセクションの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="e3cd19795acf719bdbdadfeb240558bb97933bfa" translate="yes" xml:space="preserve">
          <source>As kinds and types are the same, kinds can (with &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt;) contain type constraints. However, only equality constraints are supported.</source>
          <target state="translated">As kinds and types are the same, kinds can (with &lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt;) contain type constraints. However, only equality constraints are supported.</target>
        </trans-unit>
        <trans-unit id="b688c040bfb0b19971fb0ce773edf49cba5c5c6c" translate="yes" xml:space="preserve">
          <source>As long as a type variable is constrained by one of these classes, defaulting will occur, as outlined above.</source>
          <target state="translated">型変数がこれらのクラスのいずれかによって制約されている限り、上で説明したようにデフォルト化が行われます。</target>
        </trans-unit>
        <trans-unit id="44161a74606a6af43d39c349f3c26f8c14875c50" translate="yes" xml:space="preserve">
          <source>As long as you are happy to only be able to link to the DLL using &lt;code&gt;GetProcAddress&lt;/code&gt; and friends, you can supply the &lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt;&lt;code&gt;-fno-shared-implib&lt;/code&gt;&lt;/a&gt; flag to disable the creation of the import library entirely.</source>
          <target state="translated">&lt;code&gt;GetProcAddress&lt;/code&gt; などを使用してDLLにのみリンクできることに満足している限り、&lt;a href=&quot;#ghc-flag--fno-shared-implib&quot;&gt; &lt;code&gt;-fno-shared-implib&lt;/code&gt; &lt;/a&gt;フラグを指定して、インポートライブラリの作成を完全に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="2e315249f68fda8aaff176e296d66a05a6132ca0" translate="yes" xml:space="preserve">
          <source>As mapFile, but returns ByteString</source>
          <target state="translated">mapFile と同じですが、ByteString を返します。</target>
        </trans-unit>
        <trans-unit id="a545221512e878619258ca5f17df48cfac240523" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">上記のように、GHCの派生 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; を実装します。 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （およびそのいとこ、 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）のデフォルトの実装は、内部では単に &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; を使用します。あなたが書いている場合は &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 手でインスタンスを、そうのようにそれを書くことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6e1afd64bce824d5669c2abf1ae7f5ca39a54331" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">上記のように、GHCの派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; を実装します。 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （およびそのいとこ、 &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）のデフォルトの実装は、内部では単に &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; を使用します。あなたが書いている場合は &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 手でインスタンスを、そうのようにそれを書くことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6a668f275f9aa656c990c93f68c69e117d56a6a9" translate="yes" xml:space="preserve">
          <source>As mentioned above, derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances in GHC will implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;. The default implementations of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; (and its cousin, &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt;) will simply use &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; under the hood. If you are writing a &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance by hand, it is recommended to write it like so:</source>
          <target state="translated">上記のように、GHCの派生 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; インスタンスは、 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; を実装します。 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; （およびそのいとこ、 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; ）のデフォルトの実装は、内部では単に &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; を使用します。あなたが書いている場合は &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 手でインスタンスを、そうのようにそれを書くことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f65b46df8fe6c264c596a4ee57c977d2fcd44935" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">「&lt;a href=&quot;#gadt-style&quot;&gt;明示的なコンストラクターシグネチャを使用したデータ型の宣言」で&lt;/a&gt;述べたように、レコード構文がサポートされています。例えば：</target>
        </trans-unit>
        <trans-unit id="9f2d8d704ce406fdcf65da6dff1ef0084db00f7c" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;, record syntax is supported. For example:</source>
          <target state="translated">&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;明示的なコンストラクター署名を使用したデータ型の宣言で説明した&lt;/a&gt;ように、レコード構文がサポートされています。例えば：</target>
        </trans-unit>
        <trans-unit id="180500d2c123f41ae24d4c741a0e7e11617119d4" translate="yes" xml:space="preserve">
          <source>As observed in the &lt;a href=&quot;#leftright&quot;&gt;above description&lt;/a&gt; of left and right folds, there are three general ways in which a structure can be reduced to a summary value:</source>
          <target state="translated">&lt;a href=&quot;#leftright&quot;&gt;上記の&lt;/a&gt;左右の折り目の説明で観察されたように、構造を要約値に縮小する一般的な方法は3つあります。</target>
        </trans-unit>
        <trans-unit id="2b20aa3bf540201cc843068062611e2c68e78f44" translate="yes" xml:space="preserve">
          <source>As of 1.3.5.0, the environment variable is ignored if set to a relative path, per revised XDG Base Directory Specification. See &lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;#100&lt;/a&gt;.</source>
          <target state="translated">1.3.5.0以降、改訂されたXDGベースディレクトリ仕様に従って、相対パスに設定されている環境変数は無視されます。&lt;a href=&quot;https://github.com/haskell/directory/issues/100&quot;&gt;＃100を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="66155d480946b24160dbc04cb1009ec185e9eb15" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">とおり &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 置き換えられています &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d54fac1ed5477bc40ff0f48a11003303f605712" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">とおり &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Strict&quot;&gt;Strict&lt;/a&gt;&lt;/code&gt; 置き換えられています &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Bang&quot;&gt;Bang&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68bb1e4d347f7e14f0730566cfe86c41cf0cf621" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">とおり &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:StrictType&quot;&gt;StrictType&lt;/a&gt;&lt;/code&gt; は置き換えられてい &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:BangType&quot;&gt;BangType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="431c3d0f7612a40f6ff5eb1278e282741242a19d" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; has been replaced by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">とおり &lt;code&gt;template-haskell-2.11.0.0&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarStrictType&quot;&gt;VarStrictType&lt;/a&gt;&lt;/code&gt; は置き換えられてい &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:VarBangType&quot;&gt;VarBangType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="165ec2af84cd6d6f877d1e69014b6333343144ea" translate="yes" xml:space="preserve">
          <source>As of GHC 8.0.1 you may also &amp;ldquo;bundle&amp;rdquo; pattern synonyms with an exported type constructor, making that pattern appear as a data constructor of that type. To bundle a pattern synonym, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">GHC 8.0.1以降では、エクスポートされた型コンストラクターとパターン同義語を「バンドル」して、そのパターンをその型のデータコンストラクターとして表示することもできます。パターンシノニムをバンドルするために、型コンストラクターをエクスポートするモジュールのエクスポートリストにパターンシノニムをリストします。たとえば、 &lt;code&gt;Zero&lt;/code&gt; を &lt;code&gt;MyNum&lt;/code&gt; にバンドルするには、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="ff725c4e2000e4c32e7a70322b85a55a85f4f248" translate="yes" xml:space="preserve">
          <source>As of GHC version 6.8, we have adopted the following policy for numbering GHC versions:</source>
          <target state="translated">GHCバージョン6.8より、GHCのバージョン番号付けについては、以下の方針を採用しています。</target>
        </trans-unit>
        <trans-unit id="6667e67a30d7295682c9410cb1e7f0f855d9f77a" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;control-monad#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化した &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; にすぎません。</target>
        </trans-unit>
        <trans-unit id="189b02d51b70039f2bb98397c33331f99f38f72e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="3ffe502c088313295fc8544881ef2e7de642be25" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;control-monad#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化した、単に &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4755017eb545075e257326e642258214d89957c4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化した &lt;code&gt;&lt;a href=&quot;data-foldable#v:for_&quot;&gt;for_&lt;/a&gt;&lt;/code&gt; にすぎません。</target>
        </trans-unit>
        <trans-unit id="0be1d09e17e8e02c7031393483495ad5d61f69b4" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="7f37649ade650085aa0f65cecdda074623b0b69e" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化した、単に &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="995d3e4e58500aa9b1bd3701177a6dbe6d9b1cb8" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ベース4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化しています。</target>
        </trans-unit>
        <trans-unit id="0137e920b69fe62239fad821757f41940234bff2" translate="yes" xml:space="preserve">
          <source>As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">base 4.8.0.0以降、 &lt;code&gt;&lt;a href=&quot;prelude#v:sequence_&quot;&gt;sequence_&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; に特化した、単に &lt;code&gt;&lt;a href=&quot;data-foldable#v:sequenceA_&quot;&gt;sequenceA_&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="63452b7c7f465acb4dded12e10643c0a80c59e1c" translate="yes" xml:space="preserve">
          <source>As of bytestring 0.9.0.3, this function is stricter than its list cousin.</source>
          <target state="translated">bytestring 0.9.0.0.3 以降、この関数はリストよりも厳しくなっています。</target>
        </trans-unit>
        <trans-unit id="039bbe9675865514fb60ebed364f1df32b98df77" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; data structures, which have one variety of element on which an action can be performed, &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; data structures have two such varieties of elements.</source>
          <target state="translated">アクションを実行できる要素の種類が1 &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; データ構造とは対照的に、Bitraversableデータ構造には、このような2種類の要素があります。</target>
        </trans-unit>
        <trans-unit id="1ae607bddf78967e412e95f44ed5f98b62257887" translate="yes" xml:space="preserve">
          <source>As part of the same extension, you can put kind annotations in types as well. Thus:</source>
          <target state="translated">同じ拡張機能の一部として、型にも kind アノテーションを付けることができます。以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7699c90ab29019673b3fd8db1b1767ae9771115b" translate="yes" xml:space="preserve">
          <source>As soon as GHC plus its &amp;ldquo;fellow citizens&amp;rdquo; (other processes on your machine) start using more than the &lt;em&gt;real memory&lt;/em&gt; on your machine, and the machine starts &amp;ldquo;thrashing,&amp;rdquo; &lt;em&gt;the party is over&lt;/em&gt;. Compile times will be worse than terrible! Use something like the csh builtin &lt;strong&gt;time&lt;/strong&gt; command to get a report on how many page faults you&amp;rsquo;re getting.</source>
          <target state="translated">GHCとその「仲間の市民」（マシン上の他のプロセス）がマシン上の&lt;em&gt;実際のメモリ&lt;/em&gt;より多くを使用し始め、マシンが「スラッシング」を開始するとすぐに&lt;em&gt;、パーティーは終了し&lt;/em&gt;ます。コンパイル時間はひどいものより悪くなります！csh builtin &lt;strong&gt;time&lt;/strong&gt;コマンドのようなものを使用して、取得しているページフォールトの数に関するレポートを取得します。</target>
        </trans-unit>
        <trans-unit id="5c65dae701ef99ffffbad1ccc118a5d026621cac" translate="yes" xml:space="preserve">
          <source>As such, &lt;code&gt;purePlugin&lt;/code&gt; is defined as a function which always returns &lt;code&gt;NoForceRecompile&lt;/code&gt;.</source>
          <target state="translated">そのため、 &lt;code&gt;purePlugin&lt;/code&gt; は常に &lt;code&gt;NoForceRecompile&lt;/code&gt; を返す関数として定義されています。</target>
        </trans-unit>
        <trans-unit id="83c27882ec4f84c2b1c7547fee6d29bef6299680" translate="yes" xml:space="preserve">
          <source>As synchronized mutable variables,</source>
          <target state="translated">同期化された変異可能な変数として</target>
        </trans-unit>
        <trans-unit id="8c68344402c4c848cd9948b1b997a6cdee8b6472" translate="yes" xml:space="preserve">
          <source>As text to standard output, for debugging purposes.</source>
          <target state="translated">デバッグ目的で、標準出力へのテキストとして。</target>
        </trans-unit>
        <trans-unit id="181b02f4903ccd97fffcaf58addb10482aefc450" translate="yes" xml:space="preserve">
          <source>As the argument of a constructor, or type of a field, in a data type declaration. For example, any of the &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; above would be valid field type signatures.</source>
          <target state="translated">データ型宣言のコンストラクタの引数、またはフィールドの型として。たとえば、上記の &lt;code&gt;f1, f2, f3, g1, g2&lt;/code&gt; いずれも有効なフィールドタイプシグネチャになります。</target>
        </trans-unit>
        <trans-unit id="2c75efee694fce1348012a0f71a5ff8152fe1dea" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; の双対として、現在の文字が指定された文字リスト &lt;code&gt;cs&lt;/code&gt; に&lt;em&gt;ない&lt;/em&gt;場合、 &lt;code&gt;noneOf cs&lt;/code&gt; は成功します。解析された文字を返します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ccb0b2bddb73f4bc8b6273e372d5253cba90fe8b" translate="yes" xml:space="preserve">
          <source>As the dual of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;noneOf cs&lt;/code&gt; succeeds if the current character &lt;em&gt;not&lt;/em&gt; in the supplied list of characters &lt;code&gt;cs&lt;/code&gt;. Returns the parsed character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:oneOf&quot;&gt;oneOf&lt;/a&gt;&lt;/code&gt; の双対として、現在の文字が指定された文字リスト &lt;code&gt;cs&lt;/code&gt; に&lt;em&gt;ない&lt;/em&gt;場合、 &lt;code&gt;noneOf cs&lt;/code&gt; は成功します。解析された文字を返します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="595d79d9d63a7ad5c2be3b061e3dc58b00a5d260" translate="yes" xml:space="preserve">
          <source>As the type of an implicit parameter</source>
          <target state="translated">暗黙のパラメータの型として</target>
        </trans-unit>
        <trans-unit id="d153cbf6806b7b35bd0413a66f8a99b8d11cec38" translate="yes" xml:space="preserve">
          <source>As this suggests, each occurrence is replaced exactly once. So if &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;replacement&lt;/code&gt;, that occurrence will &lt;em&gt;not&lt;/em&gt; itself be replaced recursively:</source>
          <target state="translated">これが示唆するように、各オカレンスは正確に1回置き換えられます。したがって、 &lt;code&gt;replacement&lt;/code&gt; で &lt;code&gt;needle&lt;/code&gt; が発生した場合、その発生自体は再帰的に置換され&lt;em&gt;ません&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e53867775e4428028623be9fceee714ed0171be0" translate="yes" xml:space="preserve">
          <source>As usual, for every constructor that has a field &lt;code&gt;f&lt;/code&gt;, the type of field &lt;code&gt;f&lt;/code&gt; must be the same (modulo alpha conversion). The &lt;code&gt;Child&lt;/code&gt; constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the &amp;ldquo;type&amp;rdquo; that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A &amp;ldquo;type&amp;rdquo; of this form can appear only in a constructor signature.)</source>
          <target state="translated">いつものように、フィールド持つすべてのコンストラクタのための &lt;code&gt;f&lt;/code&gt; 、フィールドのタイプ &lt;code&gt;f&lt;/code&gt; 同じでなければならない（アルファ変換を法）。上記の &lt;code&gt;Child&lt;/code&gt; コンストラクターは、非レコードの場合と同様に、シグニチャーにコンテキスト、実存的に定量化された変数、および厳密性アノテーションが含まれる可能性があることを示しています。（注意：ダブルコロンに続く「タイプ」は、レコードの構文と厳格な注釈のため、実際にはタイプではありません。この形式の「タイプ」は、コンストラクターシグニチャーにのみ現れることができます。）</target>
        </trans-unit>
        <trans-unit id="424c7f952d5ac1aa74645c5f27a67eda13f56e6f" translate="yes" xml:space="preserve">
          <source>As usual, the meta-variables &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; etc., can be arbitrary patterns. In general, the statement &lt;code&gt;rec ss&lt;/code&gt; is desugared to the statement</source>
          <target state="translated">いつものように、メタ変数 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; などは任意のパターンにすることができます。一般に、 &lt;code&gt;rec ss&lt;/code&gt; というステートメントは、ステートメントに脱糖化されます</target>
        </trans-unit>
        <trans-unit id="3cf1bb90d2a6c5267034d92cb3db4ce82d1bfdff" translate="yes" xml:space="preserve">
          <source>As we demonstrated earlier (&lt;a href=&quot;#breakpoints&quot;&gt;Breakpoints and inspecting variables&lt;/a&gt;), the debugger has some intelligence built-in to update the type of &lt;code&gt;f&lt;/code&gt; whenever the types of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;_result&lt;/code&gt; are discovered. So what we do in this scenario is force &lt;code&gt;x&lt;/code&gt; a bit, in order to recover both its type and the argument part of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">前に説明したように（&lt;a href=&quot;#breakpoints&quot;&gt;ブレークポイントと変数の検査&lt;/a&gt;）、デバッガーには、 &lt;code&gt;x&lt;/code&gt; または &lt;code&gt;_result&lt;/code&gt; の型が検出されるたびに &lt;code&gt;f&lt;/code&gt; の型を更新するための組み込みのインテリジェンスがあります。したがって、このシナリオでは、タイプと &lt;code&gt;f&lt;/code&gt; の引数部分の両方を復元するために、少し &lt;code&gt;x&lt;/code&gt; を強制します。</target>
        </trans-unit>
        <trans-unit id="480449ae21e88b5153c176f83519328d5843ab58" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;re seen, arrow notation provides constructs, modelled on those for expressions, for sequencing, value recursion and conditionals. But suitable combinators, which you can define in ordinary Haskell, may also be used to build new commands out of existing ones. The basic idea is that a command defines an arrow from environments to values. These environments assign values to the free local variables of the command. Thus combinators that produce arrows from arrows may also be used to build commands from commands. For example, the &lt;code&gt;ArrowPlus&lt;/code&gt; class includes a combinator</source>
          <target state="translated">これまで見てきたように、矢印表記は、式、シーケンス、値の再帰、および条件式用に構築された構造を提供します。ただし、通常のHaskellで定義できる適切なコンビネーターを使用して、既存のコマンドから新しいコマンドを作成することもできます。基本的な考え方は、コマンドは環境から値への矢印を定義するということです。これらの環境は、コマンドの空きローカル変数に値を割り当てます。したがって、矢印から矢印を生成するコンビネータを使用して、コマンドからコマンドを作成することもできます。たとえば、 &lt;code&gt;ArrowPlus&lt;/code&gt; クラスにはコンビネータが含まれています</target>
        </trans-unit>
        <trans-unit id="22cabbc3d4e2b43e627bd00b9475f0bf29950d8f" translate="yes" xml:space="preserve">
          <source>As well as in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">タイプシグニチャと同様に、インスタンス宣言で明示的な &lt;code&gt;forall&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="196191205f2b62c541cf8a5ff3836b4bc01787da" translate="yes" xml:space="preserve">
          <source>As well avoid unnecessary pattern matching it also helps avoid unnecessary allocation. This applies when a argument is strict in the recursive call to itself but not on the initial entry. As strict recursive branch of the function is created similar to the above example.</source>
          <target state="translated">不必要なパターンマッチングを避けるだけでなく、不必要な割り当てを避けるのにも役立ちます。これは、引数がそれ自身への再帰的な呼び出しでは厳密であっても、最初のエントリでは厳密でない場合に適用されます。厳密な再帰的分岐は上記の例と同様に作成されます。</target>
        </trans-unit>
        <trans-unit id="8c16e4471532afea529c20b4ff2e8a8a16601be0" translate="yes" xml:space="preserve">
          <source>As well in type signatures, you can also use an explicit &lt;code&gt;forall&lt;/code&gt; in an instance declaration:</source>
          <target state="translated">型シグネチャと同様に、インスタンス宣言で明示的な &lt;code&gt;forall&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="ead26c4f8d8b65c7691881f1d8045e494c57debb" translate="yes" xml:space="preserve">
          <source>As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command line flags or language pragmas. By default GHC understands the most recent Haskell version it supports, plus a handful of extensions.</source>
          <target state="translated">すべての既知のHaskellシステムと同様に、GHCは標準のHaskell言語にいくつかの拡張を実装しています。これらはすべて、コマンドラインフラグや言語プラグマによって有効にしたり無効にしたりすることができます。デフォルトでは、GHC はサポートしている最新の Haskell バージョンと、いくつかの拡張機能を理解しています。</target>
        </trans-unit>
        <trans-unit id="fcd43e9a7f0adbd4e1cdcb63a469dbf86f84b840" translate="yes" xml:space="preserve">
          <source>As with ordinary variable bindings, later definitions shadow earlier ones, so you can re-enter a declaration to fix a problem with it or extend it. But there&amp;rsquo;s a gotcha: when a new type declaration shadows an older one, there might be other declarations that refer to the old type. The thing to remember is that the old type still exists, and these other declarations still refer to the old type. However, while the old and the new type have the same name, GHCi will treat them as distinct. For example:</source>
          <target state="translated">通常の変数バインディングと同様に、後の定義は前の変数バインディングを覆い隠すため、宣言を再入力して問題を修正するか、拡張することができます。しかし、落とし穴があります。新しい型の宣言が古い型の宣言を隠すとき、古い型を参照する他の宣言が存在する可能性があります。覚えておかなければならないのは、古い型がまだ存在しており、これらの他の宣言は依然として古い型を参照しているということです。ただし、古いタイプと新しいタイプは同じ名前ですが、GHCiはそれらを別個のものとして扱います。例えば：</target>
        </trans-unit>
        <trans-unit id="637fa52fc6437e00230d9db2fe6b3adca8d89276" translate="yes" xml:space="preserve">
          <source>As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;:</source>
          <target state="translated">他の型シグネチャと同様に、複数のデータコンストラクターに単一のシグネチャを与えることができます。この例では、 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; に単一の署名を与えます。</target>
        </trans-unit>
        <trans-unit id="9a5d0276624512bf5b98fc03c361aa6bea31b80c" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; function, if any two associations in the list have the same index, the value at that index is implementation-dependent. (In GHC, the last value specified for that index is used. Other implementations will also do this for unboxed arrays, but Haskell 98 requires that for &lt;code&gt;Array&lt;/code&gt; the value at such indices is bottom.)</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; リスト内の任意の2つの団体が同一のインデックスを持っている場合、関数、そのインデックスの値は実装依存です。（GHCでは、そのインデックスに指定された最後の値が使用されます。他の実装でもボックス化されていない配列に対してこれを行いますが、Haskell 98では、 &lt;code&gt;Array&lt;/code&gt; の場合、そのようなインデックスの値が下であることを要求しています。）</target>
        </trans-unit>
        <trans-unit id="290e57760e517898d7b9efcc098bc5d22f645f5f" translate="yes" xml:space="preserve">
          <source>As you can guess &lt;code&gt;justOnes&lt;/code&gt; will evaluate to &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt;.</source>
          <target state="translated">ご &lt;code&gt;justOnes&lt;/code&gt; は &lt;code&gt;Just [-1,-1,-1,...&lt;/code&gt; 評価されます。</target>
        </trans-unit>
        <trans-unit id="44e503436bbd1b51c2f4671a6a4bc6e7cfdbb40d" translate="yes" xml:space="preserve">
          <source>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</source>
          <target state="translated">ご覧のように、この方法で演算子を使うのはあまり便利ではありませんし、Haskell 98 では infix を書くことすらできません。</target>
        </trans-unit>
        <trans-unit id="2b751c77c03006544a696243e4f9983a43fa624e" translate="yes" xml:space="preserve">
          <source>As-patterns must not be surrounded by whitespace on either side:</source>
          <target state="translated">As-patternは、その両側をホワイトスペースで囲んではいけません。</target>
        </trans-unit>
        <trans-unit id="67dc44d97f00c988807bcf67aa9d1c8f84fff7c6" translate="yes" xml:space="preserve">
          <source>Ascii Drawings</source>
          <target state="translated">アスキー図面</target>
        </trans-unit>
        <trans-unit id="cca21e0df87aca3b913734b67e2e333b718bae99" translate="yes" xml:space="preserve">
          <source>Ashley Yakeley &amp;lt;ashley@semantic.org&amp;gt;</source>
          <target state="translated">Ashley Yakeley &amp;lt;ashley@semantic.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7f327535400c99b415e9d1ddaa6d9904d1bfafa2" translate="yes" xml:space="preserve">
          <source>Ask that GHC specialize a polymorphic value to a particular type.</source>
          <target state="translated">GHCに多相値を特定の型に特化してもらう。</target>
        </trans-unit>
        <trans-unit id="bc24cd3c8b6ddb112a336c5966d0506d3b2fd9ca" translate="yes" xml:space="preserve">
          <source>Assembly language (.s)</source>
          <target state="translated">アセンブリ言語 (.s)</target>
        </trans-unit>
        <trans-unit id="4ffedc04e994a9aefd97d00e379f2d4f383ff9bc" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">アサーションの失敗をキャッチできます。詳細については、&lt;a href=&quot;../../libraries/base-4.15.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt;ライブラリのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d8e00d7a54a273c595978f5b3e92d75c8e0981a9" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">アサーションエラーをキャッチできます。詳細については、&lt;a href=&quot;../libraries/base-4.13.0.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt;ライブラリのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cde31a8393d46785fc228979a73996dac43391ba" translate="yes" xml:space="preserve">
          <source>Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</source>
          <target state="translated">Assertion failures can be caught, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control#t:Exception&quot;&gt;Control.Exception&lt;/a&gt; library for the details.</target>
        </trans-unit>
        <trans-unit id="74319d6a5a4eb02ecd1401e7a9faed7d9660ea69" translate="yes" xml:space="preserve">
          <source>AssertionFailed</source>
          <target state="translated">AssertionFailed</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e8ddc914ca09e8e31648b53bc077284126a4cbdc" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">アサーションは通常、コンパイラフラグを使用してオンまたはオフにできます（GHCの場合、アサーションは、 &lt;code&gt;-O&lt;/code&gt; または &lt;code&gt;-fignore-asserts&lt;/code&gt; オプションが指定されていない限り、通常オンです）。アサーションがオフの場合、 &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; の最初の引数は無視され、2番目の引数が結果として返されます。</target>
        </trans-unit>
        <trans-unit id="492da7da6121915584e059d74109845fdbc2bb99" translate="yes" xml:space="preserve">
          <source>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with &lt;code&gt;-O&lt;/code&gt; or the &lt;code&gt;-fignore-asserts&lt;/code&gt; option is given). When assertions are turned off, the first argument to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; is ignored, and the second argument is returned as the result.</source>
          <target state="translated">アサーションは通常、コンパイラフラグを使用してオンまたはオフにできます（GHCの場合、アサーションは、 &lt;code&gt;-O&lt;/code&gt; または &lt;code&gt;-fignore-asserts&lt;/code&gt; オプションが指定されていない限り、通常オンです）。アサーションがオフの場合、 &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; の最初の引数は無視され、2番目の引数が結果として返されます。</target>
        </trans-unit>
        <trans-unit id="2a67c621ce56962ea20451247e4968660972fdfe" translate="yes" xml:space="preserve">
          <source>Assoc</source>
          <target state="translated">Assoc</target>
        </trans-unit>
        <trans-unit id="68b22545bb595a6b43f06bac583241d8e11a31a0" translate="yes" xml:space="preserve">
          <source>AssocLeft</source>
          <target state="translated">AssocLeft</target>
        </trans-unit>
        <trans-unit id="aa2f28d5f211bc5ecef78542598f880f8e318baa" translate="yes" xml:space="preserve">
          <source>AssocNone</source>
          <target state="translated">AssocNone</target>
        </trans-unit>
        <trans-unit id="56894dfcf0b1ff176191c0989a9045db04e81fe2" translate="yes" xml:space="preserve">
          <source>AssocRight</source>
          <target state="translated">AssocRight</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">関連するタイプ</target>
        </trans-unit>
        <trans-unit id="28d556f025319f64419ff88734b119ab1b87004b" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">関連する型およびデータインスタンスの宣言は、囲んでいるインスタンスで指定されたコンテキストを継承しません。型インスタンス宣言の場合、コンテキストの意味が明確ではありません。データインスタンス宣言の場合、ユーザーがすべてのデータコンストラクターに対してコンテキストを繰り返すことを望みません。コンテキストが役立つ可能性が高い唯一の場所は、関連するデータインスタンスの &lt;code&gt;deriving&lt;/code&gt; 句内です。ただし、ここでも、外部インスタンスコンテキストの役割はあいまいです。したがって、明確にするために、上のルールに固執します。囲んでいるインスタンスコンテキストは無視されます。派生インスタンスで重要なコンテキストを使用する必要がある場合は、&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt;句（トップレベル）を使用します。</target>
        </trans-unit>
        <trans-unit id="9d29f80f6f8aff1ac6afd29591fc1ab7479bcba6" translate="yes" xml:space="preserve">
          <source>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a &lt;code&gt;deriving&lt;/code&gt; clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;standalone deriving&lt;/code&gt;&lt;/a&gt; clause (at the top level).</source>
          <target state="translated">関連する型とデータインスタンスの宣言は、囲んでいるインスタンスで指定されたコンテキストを継承しません。型インスタンス宣言の場合、コンテキストが何を意味するかは不明です。データインスタンス宣言の場合、ユーザーがすべてのデータコンストラクターに対してコンテキストを繰り返すことを望む可能性はほとんどありません。コンテキストが役立つ可能性がある唯一の場所は、関連するデータインスタンスの &lt;code&gt;deriving&lt;/code&gt; 句です。ただし、ここでも、外部インスタンスコンテキストの役割はあいまいです。したがって、わかりやすくするために、上記のルールに固執します。囲んでいるインスタンスコンテキストは無視されます。派生インスタンスで重要なコンテキストを使用する必要がある場合は、&lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;standalone deriving&lt;/code&gt; &lt;/a&gt;句（トップレベル）を使用します。</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="1c3f48563bf3394a3a3f951813cae0818e684494" translate="yes" xml:space="preserve">
          <source>Associativity is not used to reduce the occurrence of parentheses, although precedence may be.</source>
          <target state="translated">連想性は、優先順位はあっても、括弧の発生を減らすためには使われません。</target>
        </trans-unit>
        <trans-unit id="6b99ff8f8291b4b50e3921986b0bce0e781dbc7e" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; to write a very simple error-reporting function that does absolutely nothing in the case of success, and outputs &quot;ERROR&quot; if any error occurred.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 値がある種のエラーを示していると仮定すると、 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; を使用して、成功した場合は何もせず、エラーが発生した場合は「ERROR」を出力する非常に単純なエラー報告関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="d055592ad02200007ba459bbee0ab4e26e918369" translate="yes" xml:space="preserve">
          <source>Assuming a &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value signifies some sort of error, we can use &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; to write a very simple reporting function that only outputs &quot;SUCCESS&quot; when a computation has succeeded.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 値がある種のエラーを示していると仮定すると、 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; を使用して、計算が成功したときにのみ「SUCCESS」を出力する非常に単純なレポート関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="483f89adba9ea9c40c941cf4a83fdac02ee4e4a5" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; has already been defined on the partially built structure:</source>
          <target state="translated">部分的に構築された構造で &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; がすでに定義されていると仮定します。</target>
        </trans-unit>
        <trans-unit id="1c834581788562362bcf330136a30982991522f6" translate="yes" xml:space="preserve">
          <source>Assumption: Integer is strictly positive</source>
          <target state="translated">前提。整数は厳密に正</target>
        </trans-unit>
        <trans-unit id="77fd17f027574bb2f7df35f4ef90ead2e9b60836" translate="yes" xml:space="preserve">
          <source>AsyncException</source>
          <target state="translated">AsyncException</target>
        </trans-unit>
        <trans-unit id="603f73055272502639dd306a8bca156dc618be89" translate="yes" xml:space="preserve">
          <source>AsyncIOAvailable</source>
          <target state="translated">AsyncIOAvailable</target>
        </trans-unit>
        <trans-unit id="e1aac0f84af1ee48fafd058955607776e453cc9b" translate="yes" xml:space="preserve">
          <source>Asynchronous Exceptions</source>
          <target state="translated">非同期の例外</target>
        </trans-unit>
        <trans-unit id="1fde34ce4b1dca7f44eebcbaf7ae6171e5ddd42a" translate="yes" xml:space="preserve">
          <source>Asynchronous exception control</source>
          <target state="translated">非同期例外制御</target>
        </trans-unit>
        <trans-unit id="90e8f43c2f265d7e22350697496f72118afa53f2" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions are so-called because they arise due to external influences, and can be raised at any point during execution. &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; are two examples of system-generated asynchronous exceptions.</source>
          <target state="translated">非同期例外は、外部の影響によって発生するため、いわゆる例外であり、実行中の任意の時点で発生する可能性があります。 &lt;code&gt;&lt;a href=&quot;control-exception#v:StackOverflow&quot;&gt;StackOverflow&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;control-exception#v:HeapOverflow&quot;&gt;HeapOverflow&lt;/a&gt;&lt;/code&gt; は、システム生成の非同期例外の2つの例です。</target>
        </trans-unit>
        <trans-unit id="e9087c26270e45969905025ed0c6876268b8e459" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">マスクされたスレッドが特定の方法で&lt;em&gt;ブロック&lt;/em&gt;すると、マスクされた状態でも非同期例外が受信されることがあります。&lt;a href=&quot;../base-4.13.0.0/control-exception#interruptible&quot;&gt;Control.Exceptionを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="303a11aed286b513643b565c89072a6a7aa3770b" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.14.1.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cedca602451f983242010d922a6b8f21df9fe142" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;../base-4.15.0.0/control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">マスクされたスレッドが特定の方法で&lt;em&gt;ブロック&lt;/em&gt;した場合、マスクされた状態でも非同期例外が受信される可能性があります。&lt;a href=&quot;../base-4.15.0.0/control-exception#interruptible&quot;&gt;Control.Exceptionを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4c6f92d83ff3d5f34604121aadc15840ac708368" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions may still be received while in the masked state if the masked thread &lt;em&gt;blocks&lt;/em&gt; in certain ways; see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">マスクされたスレッドが特定の方法で&lt;em&gt;ブロック&lt;/em&gt;すると、マスクされた状態でも非同期例外が受信されることがあります。&lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exceptionを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="631cd36315ff03e677e0243fa4a94f4335edad65" translate="yes" xml:space="preserve">
          <source>Asynchronous exceptions.</source>
          <target state="translated">非同期の例外。</target>
        </trans-unit>
        <trans-unit id="de23bf55d43f3cb1369402e7877d3faa61f2949f" translate="yes" xml:space="preserve">
          <source>At a function call, GHC takes the stack stored in the function being called (which for a top-level function will be empty), and &lt;em&gt;appends&lt;/em&gt; it to the current stack, ignoring any prefix that is identical to a prefix of the current stack.</source>
          <target state="translated">関数呼び出しでは、GHCは呼び出されている関数に格納されているスタック（最上位の関数の場合は空になります）を&lt;em&gt;取得&lt;/em&gt;して現在のスタックに&lt;em&gt;追加&lt;/em&gt;し、現在のスタックのプレフィックスと同じプレフィックスを無視します。</target>
        </trans-unit>
        <trans-unit id="bb19257a1286f9e500a61c5dfeacaecfe019ec79" translate="yes" xml:space="preserve">
          <source>At any time you can use the command &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt; to get a list of the modules currently loaded into GHCi:</source>
          <target state="translated">いつでも&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;コマンドを使用して、GHCiに現在ロードされているモジュールのリストを取得できます。</target>
        </trans-unit>
        <trans-unit id="3461cf3addc608aea10037826585d0df504e072e" translate="yes" xml:space="preserve">
          <source>At definition site, the arity determines what inputs can be matched on:</source>
          <target state="translated">定義サイトでは、どのような入力がマッチするかは arity で決まります。</target>
        </trans-unit>
        <trans-unit id="cc7e513d6fe875bf90b4a728f124a7f9ff012de2" translate="yes" xml:space="preserve">
          <source>At first blush, &lt;code&gt;UnEx&lt;/code&gt; seems poorly-kinded. The return kind &lt;code&gt;k&lt;/code&gt; is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of &lt;code&gt;k&lt;/code&gt;&lt;em&gt;for any&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, this is not the case. The type family &lt;code&gt;UnEx&lt;/code&gt; is a kind-indexed type family. The return kind &lt;code&gt;k&lt;/code&gt; is an implicit parameter to &lt;code&gt;UnEx&lt;/code&gt;. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</source>
          <target state="translated">&lt;code&gt;UnEx&lt;/code&gt; と、UnExは親切ではないようです。戻り値の種類 &lt;code&gt;k&lt;/code&gt; は、引数で言及されていないので、インスタンスがメンバー返す必要があろうと思われる &lt;code&gt;k&lt;/code&gt; は&lt;em&gt;任意のため&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 。ただし、これは当てはまりません。タイプファミリー &lt;code&gt;UnEx&lt;/code&gt; は、種類インデックス付きのタイプファミリーです。戻りの種類 &lt;code&gt;k&lt;/code&gt; は &lt;code&gt;UnEx&lt;/code&gt; への暗黙的なパラメーターです。詳細な定義は次のとおりです（暗黙のパラメーターは中括弧で示されます）。</target>
        </trans-unit>
        <trans-unit id="082a6d8510562c71bea9da704521358ac4884d2e" translate="yes" xml:space="preserve">
          <source>At least one of the classes &lt;code&gt;Ci&lt;/code&gt; is numeric.</source>
          <target state="translated">クラス &lt;code&gt;Ci&lt;/code&gt; の少なくとも1つは数値です。</target>
        </trans-unit>
        <trans-unit id="da4d3ab8aa4bf1c457aa64eadbb0f7599f12c862" translate="yes" xml:space="preserve">
          <source>At least one overlapped instance, &lt;code&gt;Iy&lt;/code&gt;, is both:</source>
          <target state="translated">少なくとも1つの重複するインスタンス &lt;code&gt;Iy&lt;/code&gt; は両方です。</target>
        </trans-unit>
        <trans-unit id="95b0afae80408c0a928a6ff24b58dae9588bff21" translate="yes" xml:space="preserve">
          <source>At present, &lt;code&gt;-O2&lt;/code&gt; is nearly indistinguishable from &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">現在、 &lt;code&gt;-O2&lt;/code&gt; は &lt;code&gt;-O&lt;/code&gt; とほとんど区別できません。</target>
        </trans-unit>
        <trans-unit id="2d06e4b175297e1faf1e01c3741923b7d7eb11e9" translate="yes" xml:space="preserve">
          <source>At present, GHC is quite limited in its reasoning about arithmetic: it will only evaluate the arithmetic type functions and compare the results&amp;mdash; in the same way that it does for any other type function. In particular, it does not know more general facts about arithmetic, such as the commutativity and associativity of &lt;code&gt;(+)&lt;/code&gt;, for example.</source>
          <target state="translated">現在、GHCは算術についての推論がかなり限られています。それは、算術型関数を評価し、結果を比較するだけです-他の型関数の場合と同じように。特に、たとえば &lt;code&gt;(+)&lt;/code&gt; の可換性や結合性など、算術に関するより一般的な事実は知りません。</target>
        </trans-unit>
        <trans-unit id="14a75af6823b475d201cdaf02b67cfc7b30f5d3d" translate="yes" xml:space="preserve">
          <source>At runtime, whenever a term containing a type error would need to be evaluated, the error is converted into a runtime exception of type &lt;code&gt;TypeError&lt;/code&gt;. Note that type errors are deferred as much as possible during runtime, but invalid coercions are never performed, even when they would ultimately result in a value of the correct type. For example, given the following code:</source>
          <target state="translated">実行時に、型エラーを含む用語を評価する必要がある場合は常に、エラーは &lt;code&gt;TypeError&lt;/code&gt; 型の実行時例外に変換されます。型エラーは実行時に可能な限り延期されますが、最終的に正しい型の値になる場合でも、無効な強制は決して実行されないことに注意してください。たとえば、次のコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="3b1e7a17deca9b74f37ec0a39800ad357611600d" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt you can also enter any top-level Haskell declaration, including &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;newtype&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;, &lt;code&gt;deriving&lt;/code&gt;, and &lt;code&gt;foreign&lt;/code&gt; declarations. For example:</source>
          <target state="translated">GHCiプロンプトでは、 &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;type&lt;/code&gt; 、 &lt;code&gt;newtype&lt;/code&gt; 、 &lt;code&gt;class&lt;/code&gt; 、 &lt;code&gt;instance&lt;/code&gt; 、 &lt;code&gt;deriving&lt;/code&gt; 、および &lt;code&gt;foreign&lt;/code&gt; 宣言を含む、最上位のHaskell宣言を入力することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="cd0949a6c29925c12d1d048d17633d245e1a3ebf" translate="yes" xml:space="preserve">
          <source>At the GHCi prompt, or with GHC if the &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; flag is given, the types are instead resolved with the following method:</source>
          <target state="translated">GHCiプロンプトで、またはGHCで&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;フラグが指定されている場合、タイプは代わりに次のメソッドで解決されます。</target>
        </trans-unit>
        <trans-unit id="faae2aa7c10c0885466c17a8edd2f6d0318681f4" translate="yes" xml:space="preserve">
          <source>At the end of the sample period the &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; event if emitted. This is useful to properly delimit the sampling period and to record the total time spent profiling.</source>
          <target state="translated">At the end of the sample period the &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_END&lt;/code&gt; event if emitted. This is useful to properly delimit the sampling period and to record the total time spent profiling.</target>
        </trans-unit>
        <trans-unit id="4d062db617e8b184eee773ae86e765aa598c88a3" translate="yes" xml:space="preserve">
          <source>At the moment GHCi supports most of GHC&amp;rsquo;s language extensions.</source>
          <target state="translated">現在、GHCiはGHCの言語拡張のほとんどをサポートしています。</target>
        </trans-unit>
        <trans-unit id="af7cac97440198fcc962770e0f96df4e013c2492" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command doesn&amp;rsquo;t support any kind of quoting in its arguments: quotes will not be removed and cannot be used to group words together. For example, &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; will not do what you expect.</source>
          <target state="translated">現時点では、&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;コマンドは引数での引用をサポートしていません。引用は削除されず、単語をグループ化するために使用することはできません。たとえば、 &lt;code&gt;:set -DFOO='BAR BAZ'&lt;/code&gt; は期待どおりに動作しません。</target>
        </trans-unit>
        <trans-unit id="82ba5640e0de386d6cc85d3de209bb9cdb633f12" translate="yes" xml:space="preserve">
          <source>At the moment, the only way to specify a dependency on a plugin in Cabal is to put it in &lt;code&gt;build-depends&lt;/code&gt; (which uses the conventional &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flag); however, in the future there will be a separate field for specifying plugin dependencies specifically.</source>
          <target state="translated">現時点では、Cabalでプラグインへの依存関係を指定する唯一の方法は、それを &lt;code&gt;build-depends&lt;/code&gt; に配置することです（従来の &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; フラグを使用します）。ただし、将来的にはプラグインの依存関係を具体的に指定するための別のフィールドが存在するようになります。</target>
        </trans-unit>
        <trans-unit id="36f6fc6a8b5e23e239eeef3e4a0f085a44f79d37" translate="yes" xml:space="preserve">
          <source>At use sites, the arity determines if the definition can be used in a higher-rank scenario:</source>
          <target state="translated">使用サイトでは、より高いランクのシナリオで定義を使用できるかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="7f078fc66826e48322f51a990469bfd247658746" translate="yes" xml:space="preserve">
          <source>Atomic blocks.</source>
          <target state="translated">アトミックブロック。</target>
        </trans-unit>
        <trans-unit id="92c10450c672866027afd2c75b1a19f1a5daa4db" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is forced.</source>
          <target state="translated">関数を &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; の内容に原子的に適用し、古い値と新しい値を返します。関数の結果は強制されます。</target>
        </trans-unit>
        <trans-unit id="2e8c029e8fddf8615e7bdb4f7438b3feba64ae42" translate="yes" xml:space="preserve">
          <source>Atomically apply a function to the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; and return the old and new values. The result of the function is not forced. As this can lead to a memory leak, it is usually better to use &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">関数を &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; の内容に原子的に適用し、古い値と新しい値を返します。関数の結果は強制されません。これによりメモリリークが発生する可能性があるため、通常は &lt;code&gt;&lt;a href=&quot;ghc-ioref#v:atomicModifyIORef-39-_&quot;&gt;atomicModifyIORef'_&lt;/a&gt;&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="420f4999cbf62263237bdbe7d15cefd4576bc583" translate="yes" xml:space="preserve">
          <source>Atomically modifies the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; の内容を原子的に変更します。</target>
        </trans-unit>
        <trans-unit id="5976845b8f84b952ac2fc7192f0a75f69d2927f0" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; の内容を原子的に読み取ります。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; が現在空の場合、readMVarは &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; なるまで待機します。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; は、次の &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を受け取ることが保証されています。</target>
        </trans-unit>
        <trans-unit id="4cee328d42a656c88f81a24f4db1782769f19c73" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; . If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="184b9dc038e8a43ed0e8ffb796e5fef400df0150" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; の内容を原子的に読み取ります。 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; が現在空の場合、readMVarは &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; なるまで待機します。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; は、次の &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を受信することが保証されています。</target>
        </trans-unit>
        <trans-unit id="be6bc09ee654abc40df66bc414fa4a9c12171cb5" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; の内容を原子的に読み取ります。 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; が現在空の場合、readMVarは &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; なるまで待機します。 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; は、次の &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を受け取ることが保証されています。</target>
        </trans-unit>
        <trans-unit id="23386c18719208e0c4d15b8720f6d737027a0291" translate="yes" xml:space="preserve">
          <source>Atomically read the contents of an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is currently empty, &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; will wait until it is full. &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; is guaranteed to receive the next &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; の内容を原子的に読み取ります。 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; が現在空の場合、readMVarは &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; なるまで待機します。 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; は、次の &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; を受け取ることが保証されています。</target>
        </trans-unit>
        <trans-unit id="6d13722b70b72345abf719add29b1a51d34aad57" translate="yes" xml:space="preserve">
          <source>Atomically replace the contents of an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, returning the old contents.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; の内容を原子的に置き換え、古い内容を返します。</target>
        </trans-unit>
        <trans-unit id="2ab5a0a6f732e3010e4b8d4b1f44a6fc68552e9b" translate="yes" xml:space="preserve">
          <source>Attach a timeout event to arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">任意の &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 計算にタイムアウトイベントをアタッチします。</target>
        </trans-unit>
        <trans-unit id="cb303f555c293bc6ebb398fedf551b67ed2ee6e1" translate="yes" xml:space="preserve">
          <source>Attach an annotation to a document.</source>
          <target state="translated">ドキュメントに注釈を添付します。</target>
        </trans-unit>
        <trans-unit id="83a56249e5cff48f561d2d725143f1fc2eb3228c" translate="yes" xml:space="preserve">
          <source>Attachment</source>
          <target state="translated">Attachment</target>
        </trans-unit>
        <trans-unit id="6771ade6e8965a499bc298107ffb52e9a18dd7e3" translate="yes" xml:space="preserve">
          <source>Attachments</source>
          <target state="translated">Attachments</target>
        </trans-unit>
        <trans-unit id="358b4cc5015b0aa8d923e59ec8734cadaa58c21f" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the capacity (in bytes) given by the first argument. The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous compact block of the CNF or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new CNF with a single compact block.</source>
          <target state="translated">最初の引数で指定された容量（バイト単位）でコンパクトブロックを割り当てようとします。 &lt;code&gt;Addr#&lt;/code&gt; CNFまたは以前のコンパクトなブロックへのポインタである &lt;code&gt;nullAddr#&lt;/code&gt; 単一のコンパクトなブロックで新しいCNFを作成します。</target>
        </trans-unit>
        <trans-unit id="14c3e18c8fd88ff49a30c3e7b04045a40e92e438" translate="yes" xml:space="preserve">
          <source>Attempt to allocate a compact block with the given size (in bytes, given by the first argument). The &lt;code&gt;Addr#&lt;/code&gt; is a pointer to previous block of the compact or &lt;code&gt;nullAddr#&lt;/code&gt; to create a new compact.</source>
          <target state="translated">指定されたサイズ（最初の引数で指定されたバイト単位）のコンパクトブロックを割り当てようとします。 &lt;code&gt;Addr#&lt;/code&gt; コンパクトまたはの前のブロックへのポインタである &lt;code&gt;nullAddr#&lt;/code&gt; 新しいコンパクトを作成します。</target>
        </trans-unit>
        <trans-unit id="7aa6f2a111a7ae3d1c85ad97bb0176dbe687d1c3" translate="yes" xml:space="preserve">
          <source>Attempt to convert an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;a&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; type &lt;code&gt;b&lt;/code&gt; using the size of the types as measured by &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; methods.</source>
          <target state="translated">変換しようと &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 型 &lt;code&gt;a&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 型 &lt;code&gt;b&lt;/code&gt; によって測定されるようなタイプのサイズを使用して &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="eb6ccc5388b3a3515cdd4a9fde980934200b5b13" translate="yes" xml:space="preserve">
          <source>Attempt to ignore and recover if an illegal sequence is encountered</source>
          <target state="translated">不正なシーケンスに遭遇した場合、無視して回復を試みます。</target>
        </trans-unit>
        <trans-unit id="1dd801e8dde9f614ee3cf534bfcd9bf71825677c" translate="yes" xml:space="preserve">
          <source>Attempt to lock the semaphore without blocking. Immediately return False if it is not available.</source>
          <target state="translated">セマフォをブロッキングせずにロックしようとする。利用できない場合は直ちに False を返します。</target>
        </trans-unit>
        <trans-unit id="5ce185b0aec3184ea8d85cd399f6b27591eecf61" translate="yes" xml:space="preserve">
          <source>Attempt to perform the given action, silencing any IO exception thrown by it.</source>
          <target state="translated">与えられたアクションを実行しようとし、それによってスローされた IO 例外を消音します。</target>
        </trans-unit>
        <trans-unit id="1c903a1acb600fe485f2c4a45d92c0ad8eff63d5" translate="yes" xml:space="preserve">
          <source>Attempting to use of linear types in Template Haskell will probably not work.</source>
          <target state="translated">Template Haskellで線形の型を使おうとしても、おそらくうまくいかないでしょう。</target>
        </trans-unit>
        <trans-unit id="95eba1f265744c575faabec4b145e9a698745932" translate="yes" xml:space="preserve">
          <source>Attempts to reload the current target set (see &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;) if any of the modules in the set, or any dependent module, has changed. Note that this may entail loading new modules, or dropping modules which are no longer indirectly required by the target.</source>
          <target state="translated">セット内のモジュールのいずれか、または依存するモジュールが変更された場合、現在のターゲットセット（&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; を&lt;/a&gt;参照）の再ロードを試みます。これには、新しいモジュールのロード、またはターゲットが間接的に必要としなくなったモジュールの削除が伴う場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="db06067c8f8d76e8b68fa4b9186a9b50479a85d3" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the specified process. This function should not be used under normal circumstances - no guarantees are given regarding how cleanly the process is terminated. To check whether the process has indeed terminated, use &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定されたプロセスの終了を試みます。この関数は、通常の状況では使用しないでください。プロセスがどの程度正常に終了したかについては保証されません。プロセスが実際に終了したかどうかを確認するには、 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="c4b6f77c88d20ca04f9a50aec205f45262f5d7ab" translate="yes" xml:space="preserve">
          <source>Attributes in XHTML Strict</source>
          <target state="translated">XHTMLの属性 Strict</target>
        </trans-unit>
        <trans-unit id="16128ba0c9d08bb0dde15482b5b394897473b886" translate="yes" xml:space="preserve">
          <source>Attributes of I/O errors</source>
          <target state="translated">I/Oエラーの属性</target>
        </trans-unit>
        <trans-unit id="1360a6d5f84dba15e5314081238a2fd3066ee932" translate="yes" xml:space="preserve">
          <source>Attributes with name and value.</source>
          <target state="translated">名前と値を持つ属性。</target>
        </trans-unit>
        <trans-unit id="993065bb1a56fd21869c669ca617b04976cb0030" translate="yes" xml:space="preserve">
          <source>Author: Ben Gamari</source>
          <target state="translated">著者:ベン・ガマリ ベン・ガマリ</target>
        </trans-unit>
        <trans-unit id="75c4b805a306f8a99221f82ad1e776dcaee1276b" translate="yes" xml:space="preserve">
          <source>Authors importing this module are expected to track development closely.</source>
          <target state="translated">このモジュールをインポートする著者は、開発を綿密に追跡することが期待されています。</target>
        </trans-unit>
        <trans-unit id="ac440c0ee95ad46797ff526e4fa32c25032310cf" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all CAFs</source>
          <target state="translated">&lt;code&gt;SCC&lt;/code&gt; をすべてのCAFに自動追加</target>
        </trans-unit>
        <trans-unit id="3e6d90a8087bfbc9d56637d926baaee06bb11b50" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all bindings not marked INLINE</source>
          <target state="translated">INCCとマークされていないすべてのバインディングに &lt;code&gt;SCC&lt;/code&gt; を自動追加します</target>
        </trans-unit>
        <trans-unit id="926781921f42c31bb0687106a4a150bb577b974e" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all call sites</source>
          <target state="translated">&lt;code&gt;SCC&lt;/code&gt; をすべての呼び出しサイトに自動追加</target>
        </trans-unit>
        <trans-unit id="aba3425843f29781a7a8d03a07af127ba3b7b9b2" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all exported bindings not marked INLINE</source>
          <target state="translated">INCCとマークされていないすべてのエクスポートされたバインディングに &lt;code&gt;SCC&lt;/code&gt; を自動追加します</target>
        </trans-unit>
        <trans-unit id="f39d1b641099009478c941384a7ddb92d9adc118" translate="yes" xml:space="preserve">
          <source>Auto-add &lt;code&gt;SCC&lt;/code&gt;\ s to all top-level bindings not marked INLINE</source>
          <target state="translated">INCCとマークされていないすべてのトップレベルのバインディングに &lt;code&gt;SCC&lt;/code&gt; を自動追加します</target>
        </trans-unit>
        <trans-unit id="fc392ab09cabed566e31abcea7714e1a9fbd59f8" translate="yes" xml:space="preserve">
          <source>AutoDeriveTypeable</source>
          <target state="translated">AutoDeriveTypeable</target>
        </trans-unit>
        <trans-unit id="0f3997661b5230a1d4a29603d354a226f203caa0" translate="yes" xml:space="preserve">
          <source>Automatically enable compacting collection when the live data exceeds ⟨n⟩% of the maximum heap size (see the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; option). Note that the maximum heap size is unlimited by default, so this option has no effect unless the maximum heap size is set with &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ライブデータが最大ヒープサイズの「n」％を超えると、圧縮収集を自動的に有効にします（&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;「サイズ」オプションを参照）。最大ヒープサイズはデフォルトで無制限であるため、最大ヒープサイズが&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;設定されていない限り、このオプションは効果がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6deb87b596d87ecee88f79fe651652c552010dcc" translate="yes" xml:space="preserve">
          <source>Available on &lt;code&gt;base &amp;gt;=4.9&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;base &amp;gt;=4.9&lt;/code&gt; 利用可能</target>
        </trans-unit>
        <trans-unit id="5e4e7aa329cbbf38ad0669fe65c87a2d764ac59f" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.13.0.0/prelude#t:Read&quot;&gt;Prelude.Readを&lt;/a&gt;避けます。</target>
        </trans-unit>
        <trans-unit id="3ace826e18102f6899794ad3ef89b5a4cafb9c1c" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">Avoid &lt;a href=&quot;../libraries/base-4.14.1.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d046fd0eedb33417414a7f1c2d12f68e0c748ad0" translate="yes" xml:space="preserve">
          <source>Avoid &lt;a href=&quot;../libraries/base-4.15.0.0/prelude#t:Read&quot;&gt;Prelude.Read&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../libraries/base-4.15.0.0/prelude#t:Read&quot;&gt;Prelude.Readを&lt;/a&gt;避けてください。</target>
        </trans-unit>
        <trans-unit id="b6bcda3182218ed04e058e2a3e7f3b82979718dc" translate="yes" xml:space="preserve">
          <source>Avoid using Bytes constructor directly as it is likely to change in the future. Use helpers such as &lt;code&gt;mkBytes&lt;/code&gt; in Language.Haskell.TH.Lib instead.</source>
          <target state="translated">Bytesコンストラクターは将来変更される可能性があるため、直接使用しないでください。代わりに、Language.Haskell.TH.Libの &lt;code&gt;mkBytes&lt;/code&gt; などのヘルパーを使用してください。</target>
        </trans-unit>
        <trans-unit id="be332d307b7edd783371ed9722af4d2891b5ddd8" translate="yes" xml:space="preserve">
          <source>Avoiding multi-pass folds</source>
          <target state="translated">マルチパスフォールドの回避</target>
        </trans-unit>
        <trans-unit id="ca874deaab16366191c7957785eea44d50d3a744" translate="yes" xml:space="preserve">
          <source>B0</source>
          <target state="translated">B0</target>
        </trans-unit>
        <trans-unit id="8fa6afc648cb35f98b314ec87af904a1320a565f" translate="yes" xml:space="preserve">
          <source>B110</source>
          <target state="translated">B110</target>
        </trans-unit>
        <trans-unit id="69983106476a1baa3e173eb0da9525d4e05a1e94" translate="yes" xml:space="preserve">
          <source>B115200</source>
          <target state="translated">B115200</target>
        </trans-unit>
        <trans-unit id="63db1d5e1025a5dca03dde90aaee4ab1689048ef" translate="yes" xml:space="preserve">
          <source>B1200</source>
          <target state="translated">B1200</target>
        </trans-unit>
        <trans-unit id="e74b06339c34831ce0b9ab483e8c8a61a8068208" translate="yes" xml:space="preserve">
          <source>B134</source>
          <target state="translated">B134</target>
        </trans-unit>
        <trans-unit id="a9905f37be71ad27b06428c2ae3de56996c96c7e" translate="yes" xml:space="preserve">
          <source>B150</source>
          <target state="translated">B150</target>
        </trans-unit>
        <trans-unit id="966d5ab4ced9ae0785e30c1280734e03950b8b43" translate="yes" xml:space="preserve">
          <source>B1800</source>
          <target state="translated">B1800</target>
        </trans-unit>
        <trans-unit id="e535913533dad54a5814041ea8ecb91d9eeccbc1" translate="yes" xml:space="preserve">
          <source>B19200</source>
          <target state="translated">B19200</target>
        </trans-unit>
        <trans-unit id="559bc674c0bef2843ad28f3b0807a3bc8c3a905e" translate="yes" xml:space="preserve">
          <source>B200</source>
          <target state="translated">B200</target>
        </trans-unit>
        <trans-unit id="8b9d4b133283a998a17790c5482a1a7e5ea5ef89" translate="yes" xml:space="preserve">
          <source>B2400</source>
          <target state="translated">B2400</target>
        </trans-unit>
        <trans-unit id="1100370c026795a2ba481e6ed685267255662a5a" translate="yes" xml:space="preserve">
          <source>B300</source>
          <target state="translated">B300</target>
        </trans-unit>
        <trans-unit id="967e9e4821f80944c4a011159dea85581127b02d" translate="yes" xml:space="preserve">
          <source>B38400</source>
          <target state="translated">B38400</target>
        </trans-unit>
        <trans-unit id="3e5bbebbfb2d76d5eb4a77c12b899a53cb0e824b" translate="yes" xml:space="preserve">
          <source>B4800</source>
          <target state="translated">B4800</target>
        </trans-unit>
        <trans-unit id="70e67f1d5a37cf067a56baf4ce16e1420d5e3b02" translate="yes" xml:space="preserve">
          <source>B50</source>
          <target state="translated">B50</target>
        </trans-unit>
        <trans-unit id="763970e59e7e204186ab4318ebc79d0aad573df8" translate="yes" xml:space="preserve">
          <source>B57600</source>
          <target state="translated">B57600</target>
        </trans-unit>
        <trans-unit id="e41fa1e36cc5ce5485a1da88669ebf6c181b64fc" translate="yes" xml:space="preserve">
          <source>B600</source>
          <target state="translated">B600</target>
        </trans-unit>
        <trans-unit id="0a96b59160d52c4d3a94a14b630cd642e970d726" translate="yes" xml:space="preserve">
          <source>B75</source>
          <target state="translated">B75</target>
        </trans-unit>
        <trans-unit id="38ed67ee58867b1ed339e07a0a0e350aefba9899" translate="yes" xml:space="preserve">
          <source>B9600</source>
          <target state="translated">B9600</target>
        </trans-unit>
        <trans-unit id="d9004f19dea2dc973e0d147f71242cc2bebca3f3" translate="yes" xml:space="preserve">
          <source>BCO#</source>
          <target state="translated">BCO#</target>
        </trans-unit>
        <trans-unit id="d387e5e412686186588f12198f87a79c11ecf2f3" translate="yes" xml:space="preserve">
          <source>BLACK STAR</source>
          <target state="translated">ブラックスター</target>
        </trans-unit>
        <trans-unit id="ed7592b91885c70d24cf8681c067a4604fe9f9a7" translate="yes" xml:space="preserve">
          <source>BN#</source>
          <target state="translated">BN#</target>
        </trans-unit>
        <trans-unit id="292c7af4fff95bcd09dba6dcdd4b5f6d636b95c8" translate="yes" xml:space="preserve">
          <source>BOOL</source>
          <target state="translated">BOOL</target>
        </trans-unit>
        <trans-unit id="42c5e705983ae56cd93e4c5f6314e815eb160593" translate="yes" xml:space="preserve">
          <source>BSD-style</source>
          <target state="translated">BSD-style</target>
        </trans-unit>
        <trans-unit id="9332433de0ed1632f2bcc6d0a44e38c2f119263d" translate="yes" xml:space="preserve">
          <source>BSD-style (see LICENSE)</source>
          <target state="translated">BSD スタイル (ライセンス参照)</target>
        </trans-unit>
        <trans-unit id="44f04e5b329f5940c142f534423ac2c4e47a1a2d" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file in the distribution)</source>
          <target state="translated">BSD-style (ディストリビューションのLICENSEファイルを参照)</target>
        </trans-unit>
        <trans-unit id="c6ca990beea2501ec303342859beced421c42eb6" translate="yes" xml:space="preserve">
          <source>BSD-style (see the LICENSE file)</source>
          <target state="translated">BSD スタイル (LICENSE ファイルを参照)</target>
        </trans-unit>
        <trans-unit id="965d82d9479d90e4c8debb630580bf0a1b1ba92f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE in this distribution)</source>
          <target state="translated">BSD スタイル (このディストリビューションの LICENSE ファイルを参照してください)</target>
        </trans-unit>
        <trans-unit id="768626facad260a6f891ec7130589a5f3309d501" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file LICENSE)</source>
          <target state="translated">BSD スタイル (LICENSE ファイルを参照)</target>
        </trans-unit>
        <trans-unit id="81e1671a0b4eeb6f499727101f56c68023874e7f" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/base/LICENSE)</source>
          <target state="translated">BSD スタイル (ライブラリ/ベース/LICENSE ファイルを参照)</target>
        </trans-unit>
        <trans-unit id="ef57f6a3a070b95b64e77f5a36de3561ef544d65" translate="yes" xml:space="preserve">
          <source>BSD-style (see the file libraries/parsec/LICENSE)</source>
          <target state="translated">BSD スタイル (ライブラリ/parsec/LICENSE ファイルを参照)</target>
        </trans-unit>
        <trans-unit id="19a47f35c441c8dd2576f588079955402fb90b82" translate="yes" xml:space="preserve">
          <source>BSD3</source>
          <target state="translated">BSD3</target>
        </trans-unit>
        <trans-unit id="7f9c1e64342b8d68000ad605b095d79dad9a02d3" translate="yes" xml:space="preserve">
          <source>BSD3-style (see LICENSE)</source>
          <target state="translated">BSD3-style (ライセンス参照)</target>
        </trans-unit>
        <trans-unit id="1d7caa593761d5e9b3a933c7c28bf276e5fe0725" translate="yes" xml:space="preserve">
          <source>BYTE</source>
          <target state="translated">BYTE</target>
        </trans-unit>
        <trans-unit id="c6d4a87dd731399addc42bfa4639f9363a8c4260" translate="yes" xml:space="preserve">
          <source>BY_HANDLE_FILE_INFORMATION</source>
          <target state="translated">BY_HANDLE_FILE_INFORMATION</target>
        </trans-unit>
        <trans-unit id="80ed9fd98b57c91f78562ce126c39ae7b67ed567" translate="yes" xml:space="preserve">
          <source>Back-quotes work as for expressions, both for type constructors and type variables; e.g. &lt;code&gt;Int `Either` Bool&lt;/code&gt;, or &lt;code&gt;Int `a` Bool&lt;/code&gt;. Similarly, parentheses work the same; e.g. &lt;code&gt;(:*:) Int Bool&lt;/code&gt;.</source>
          <target state="translated">逆引用符は、型コンストラクターと型変数の両方に対して式と同様に機能します。例： &lt;code&gt;Int `Either` Bool&lt;/code&gt; 、または &lt;code&gt;Int `a` Bool&lt;/code&gt; 。同様に、括弧は同じように機能します。例 &lt;code&gt;(:*:) Int Bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe2ff7fc27afe7d547b5eb980ad60a5d316a61a8" translate="yes" xml:space="preserve">
          <source>Background: some systems have a Non-Uniform Memory Architecture, whereby main memory is split into banks which are &amp;ldquo;local&amp;rdquo; to specific CPU cores. Accessing local memory is faster than accessing remote memory. The OS provides APIs for allocating local memory and binding threads to particular CPU cores, so that we can ensure certain memory accesses are using local memory.</source>
          <target state="translated">背景：一部のシステムには非均一メモリアーキテクチャがあり、メインメモリは特定のCPUコアに「ローカル」なバンクに分割されます。ローカルメモリへのアクセスは、リモートメモリへのアクセスよりも高速です。OSは、ローカルメモリを割り当て、スレッドを特定のCPUコアにバインドするためのAPIを提供するため、特定のメモリアクセスがローカルメモリを使用していることを確認できます。</target>
        </trans-unit>
        <trans-unit id="72bac718669114015a5f4f323dbfd19315cc9c1e" translate="yes" xml:space="preserve">
          <source>BackgroundWriteInterrupt</source>
          <target state="translated">BackgroundWriteInterrupt</target>
        </trans-unit>
        <trans-unit id="95e848a0c727105f2393d59e2c3843e625c17c16" translate="yes" xml:space="preserve">
          <source>Backwards</source>
          <target state="translated">Backwards</target>
        </trans-unit>
        <trans-unit id="13be7afef8413dabb18fb208bcddc8487eccc989" translate="yes" xml:space="preserve">
          <source>Bang</source>
          <target state="translated">Bang</target>
        </trans-unit>
        <trans-unit id="8c8ebd2c416a792dfc576bb10ca4e468125c1a6e" translate="yes" xml:space="preserve">
          <source>Bang patterns (&lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;) makes pattern matching and let bindings stricter.</source>
          <target state="translated">Bangパターン（&lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt;）は、パターンマッチングを行い、バインディングをより厳密にします。</target>
        </trans-unit>
        <trans-unit id="5ec90a9a17a2969ccda25430595be20a569e3fe9" translate="yes" xml:space="preserve">
          <source>Bang patterns and strict matching do not affect the type system in any way.</source>
          <target state="translated">バングパターンや厳密なマッチングは、型システムには何ら影響を与えません。</target>
        </trans-unit>
        <trans-unit id="4331913421f3f413f4d723cb7bf92c5118afdbaf" translate="yes" xml:space="preserve">
          <source>Bang patterns work in &lt;code&gt;case&lt;/code&gt; expressions too, of course:</source>
          <target state="translated">もちろん、Bangパターンは &lt;code&gt;case&lt;/code&gt; 式でも機能します。</target>
        </trans-unit>
        <trans-unit id="50466cee465187abc9af9cab7155eae9f7c01b4f" translate="yes" xml:space="preserve">
          <source>BangPatterns</source>
          <target state="translated">BangPatterns</target>
        </trans-unit>
        <trans-unit id="23753b97b7d02a9e0370366e9fbeda13137a82c9" translate="yes" xml:space="preserve">
          <source>BangQ</source>
          <target state="translated">BangQ</target>
        </trans-unit>
        <trans-unit id="48d652eba9b41d0c825ca713155f565dc1ca77d2" translate="yes" xml:space="preserve">
          <source>BangType</source>
          <target state="translated">BangType</target>
        </trans-unit>
        <trans-unit id="b5159683817a7c6e14cfc2ce8186bac739ef41b1" translate="yes" xml:space="preserve">
          <source>BangTypeQ</source>
          <target state="translated">BangTypeQ</target>
        </trans-unit>
        <trans-unit id="b97a50336dc10f904675fe44fbb4e1e0f9f62610" translate="yes" xml:space="preserve">
          <source>Bart Massey &amp;lt;bart@cs.pdx.edu&amp;gt;</source>
          <target state="translated">バートマッセイ&amp;lt;bart@cs.pdx.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="15c502386eb41ec778f48f0426dd044e61902a8f" translate="yes" xml:space="preserve">
          <source>Based on the original Text.Html library by Andy Gill. See &lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;http://www.cse.ogi.edu/~andy/html/intro.htm&lt;/a&gt; for an introduction to that library.</source>
          <target state="translated">Andy GillによるオリジナルのText.Htmlライブラリに基づいています。ライブラリの&lt;a href=&quot;http://www.cse.ogi.edu/~andy/html/intro.htm&quot;&gt;概要&lt;/a&gt;については、http：//www.cse.ogi.edu/~andy/html/intro.htmを参照してください。</target>
        </trans-unit>
        <trans-unit id="f2140f37579f36362da3719562444661d727afe4" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">基本的な &lt;code&gt;Integer&lt;/code&gt; 演算</target>
        </trans-unit>
        <trans-unit id="ee73c6548371a6788caa59207b82400814c02764" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Monad&lt;/code&gt; functions</source>
          <target state="translated">基本的な &lt;code&gt;Monad&lt;/code&gt; 関数</target>
        </trans-unit>
        <trans-unit id="c88db86b8d674e03dbcad77f83787a7e61a8e034" translate="yes" xml:space="preserve">
          <source>Basic Input and output</source>
          <target state="translated">基本的な入出力</target>
        </trans-unit>
        <trans-unit id="f9b3e5bd963e2b38618aa474b3e7102fc295adcc" translate="yes" xml:space="preserve">
          <source>Basic UTF-8 validation and character manipulation.</source>
          <target state="translated">基本的なUTF-8の検証と文字操作</target>
        </trans-unit>
        <trans-unit id="9568da19057c26bab59b9243581c623c02943b7f" translate="yes" xml:space="preserve">
          <source>Basic arrow definitions, based on</source>
          <target state="translated">に基づく基本的な矢印の定義</target>
        </trans-unit>
        <trans-unit id="6a1b59604dd8bf31bed9746b89fda90c3467c9aa" translate="yes" xml:space="preserve">
          <source>Basic concurrency operations</source>
          <target state="translated">基本的な同時実行操作</target>
        </trans-unit>
        <trans-unit id="0c54046043ce73859746be9b39ba7b190dacdaf6" translate="yes" xml:space="preserve">
          <source>Basic concurrency stuff.</source>
          <target state="translated">基本的な並行処理のこと。</target>
        </trans-unit>
        <trans-unit id="a7e69e7791ed667a403de47b04497c349887deca" translate="yes" xml:space="preserve">
          <source>Basic data types</source>
          <target state="translated">基本データ型</target>
        </trans-unit>
        <trans-unit id="c9d432205b7dc1b2af1472a1dcd6e06b2740bef0" translate="yes" xml:space="preserve">
          <source>Basic data types and classes.</source>
          <target state="translated">基本的なデータ型とクラス。</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">基本機能</target>
        </trans-unit>
        <trans-unit id="b9548c7037e25b8bf7a7572126d2cc1b16e01f80" translate="yes" xml:space="preserve">
          <source>Basic interface</source>
          <target state="translated">基本インターフェース</target>
        </trans-unit>
        <trans-unit id="ea133ee8187b37bb71d85236dac3108829ef4b40" translate="yes" xml:space="preserve">
          <source>Basic kinds</source>
          <target state="translated">基本的な種類</target>
        </trans-unit>
        <trans-unit id="50a832ade293f6e2e4b29e68fbed8adbb4f5292b" translate="yes" xml:space="preserve">
          <source>Basic non-strict arrays.</source>
          <target state="translated">厳密でない基本的な配列。</target>
        </trans-unit>
        <trans-unit id="5f012dfa959f01c06a8f22651163550a83550e42" translate="yes" xml:space="preserve">
          <source>Basic numeric class.</source>
          <target state="translated">基本的な数値クラス。</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">基本操作</target>
        </trans-unit>
        <trans-unit id="25c075b5afd0fa65abaa64881721f9e82dad1e33" translate="yes" xml:space="preserve">
          <source>Basic operations on type-level Booleans.</source>
          <target state="translated">型レベルのブール値の基本的な操作</target>
        </trans-unit>
        <trans-unit id="ce2e8249a9c31f9132666369cb296c36dc8cbe0d" translate="yes" xml:space="preserve">
          <source>Basic type classes</source>
          <target state="translated">基本的な型クラス</target>
        </trans-unit>
        <trans-unit id="5f5e9b287612ac50252f03aed2ec4f912c26ab6b" translate="yes" xml:space="preserve">
          <source>Basic types for the implementation of IO Handles.</source>
          <target state="translated">IOハンドルを実装するための基本的な型です。</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">基本的な使い方です。</target>
        </trans-unit>
        <trans-unit id="57869d5cb688abb53fb6a3ccefe136c430873b62" translate="yes" xml:space="preserve">
          <source>BasicFormat</source>
          <target state="translated">BasicFormat</target>
        </trans-unit>
        <trans-unit id="edd76f36427e0be6ee4ea72fcc2b48f9dc5f829a" translate="yes" xml:space="preserve">
          <source>BaudRate</source>
          <target state="translated">BaudRate</target>
        </trans-unit>
        <trans-unit id="13b75e02d46b87821b8e6bb2e907caf22536eaeb" translate="yes" xml:space="preserve">
          <source>Be aware of that &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; do require filenames containing spaces to be escaped using quotes:</source>
          <target state="translated">&lt;code&gt;ghc&lt;/code&gt; と &lt;code&gt;ghci&lt;/code&gt; では、スペースを含むファイル名を引用符でエスケープする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2a750147c0b7e7b2524f6f876a3edd09786994a4" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList。toList = id 'は、凍結されていない &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に対してのみです。 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; は、toListが凍結情報を削除するためです。</target>
        </trans-unit>
        <trans-unit id="833fbd733b968c1c689e377b206c44a8ba2c1393" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList。toList = id 'は、凍結されていない &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に対してのみです。 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; は、toListが凍結情報を削除するためです。</target>
        </trans-unit>
        <trans-unit id="8b4f2dc8bf0c5571de02a483e44a0efdc7eb624d" translate="yes" xml:space="preserve">
          <source>Be aware that 'fromList . toList = id' only for unfrozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;s, since &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; removes frozenness information.</source>
          <target state="translated">'fromList。toList = id 'は、凍結されていない &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; に対してのみです。 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; は、toListが凍結情報を削除するためです。</target>
        </trans-unit>
        <trans-unit id="4dc420edbf82aa0a2fac0909c5f04bacaae0ad94" translate="yes" xml:space="preserve">
          <source>Be careful not to recompile any packages that GHC itself depends on, as this may render the &lt;code&gt;ghc&lt;/code&gt; package itself broken, and &lt;code&gt;ghc&lt;/code&gt; cannot be simply recompiled. The only way to recover from this would be to re-install GHC.</source>
          <target state="translated">GHC自体が依存する、これはレンダリングしてもよいように、すべてのパッケージを再コンパイルしないように注意してください &lt;code&gt;ghc&lt;/code&gt; 自体が壊れたパッケージを、そして &lt;code&gt;ghc&lt;/code&gt; 単純に再コンパイルすることはできません。これから回復する唯一の方法は、GHCを再インストールすることです。</target>
        </trans-unit>
        <trans-unit id="6e58b8e7a7708dab3c9a2bfb9884abe1e3e42613" translate="yes" xml:space="preserve">
          <source>Be careful when using all the processors in your machine: if some of your processors are in use by other programs, this can actually harm performance rather than improve it. Asking GHC to create more capabilities than you have physical threads is almost always a bad idea.</source>
          <target state="translated">マシン内のすべてのプロセッサを使用する際には注意が必要です:プロセッサの一部が他のプログラムで使用されている場合、これはパフォーマンスを向上させるどころか、実際には害となることがあります。GHC に物理的なスレッドの数よりも多くの機能を作成するように求めるのは、ほとんどの場合、悪い考えです。</target>
        </trans-unit>
        <trans-unit id="030ba515acd2d25ee94d7a99ab66ba47851bdf13" translate="yes" xml:space="preserve">
          <source>Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; to check that the called foreign function is prepared to deal with the consequences of the call being interrupted. On Unix it is considered good practice to always check for &lt;code&gt;EINTR&lt;/code&gt; after system calls, so you can expect it not to crash (but in that case &lt;code&gt;interruptible&lt;/code&gt; will not work as intended unless the code then returns all the way up to Haskell as described above). But on Windows it is not typically common practice to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">呼び出された外部関数が、呼び出しが中断された結果に対処する準備ができていることを確認するために、 &lt;code&gt;interruptible&lt;/code&gt; を使用する場合は特に注意してください。 Unixでは、システムコール後に常に &lt;code&gt;EINTR&lt;/code&gt; をチェックすることをお勧めします。そのため、クラッシュしないことが期待できます（ただし、その場合、コードが上記のようにHaskellに戻るまで、 &lt;code&gt;interruptible&lt;/code&gt; は意図したとおりに機能しません） 。ただし、Windowsでは、通常、 &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; を処理することは一般的ではありません。</target>
        </trans-unit>
        <trans-unit id="2e6215070ac7ba503783ef4dcd9847d43461c01e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldom uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; は関数を厳密に適用しないことに注意してください。これは、プログラムが &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; を何度も呼び出すが、その値をほとんど使用しない場合、サンクがメモリに蓄積され、スペースリークが発生することを意味します。これは、IORefをカウンターとして使用するときによくある間違いです。たとえば、次の場合、スタックオーバーフローが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e632134338b9cc24cdcec9c2ad59ac6cbe767e2" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an IORef as a counter. For example, the following will likely produce a stack overflow:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; は関数を厳密に適用しないことに注意してください。これは、プログラムが &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef&quot;&gt;modifyIORef&lt;/a&gt;&lt;/code&gt; を何度も呼び出すが、めったに値を使用しない場合、サンクがメモリに蓄積され、スペースリークが発生することを意味します。これは、IORefをカウンターとして使用するときによくある間違いです。たとえば、次の場合はスタックオーバーフローが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="55340cb5b344cb0896b46c3e02107cead57c765e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldom uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; は関数を厳密に適用しないことに注意してください。これは、プログラムが &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; を何度も呼び出すが、その値をほとんど使用しない場合、サンクがメモリに蓄積され、スペースリークが発生することを意味します。これは、 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; をカウンターとして使用するときによくある間違いです。たとえば、次の場合、メモリリークが発生し、スタックオーバーフローが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9146268e3a870b89574a63d603a9a4c2b804fc8e" translate="yes" xml:space="preserve">
          <source>Be warned that &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; does not apply the function strictly. This means if the program calls &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; many times, but seldomly uses the value, thunks will pile up in memory resulting in a space leak. This is a common mistake made when using an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; as a counter. For example, the following will leak memory and may produce a stack overflow:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; が関数を厳密に適用しないことに注意してください。これは、プログラムが何度も &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef&quot;&gt;modifySTRef&lt;/a&gt;&lt;/code&gt; を呼び出しても、その値をほとんど使用しない場合、サンクがメモリに蓄積され、スペースリークが発生することを意味します。これは、 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; をカウンターとして使用するときによくある間違いです。たとえば、次はメモリリークを起こし、スタックオーバーフローを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="1ac5eb692c23fe608a9eb6b4fa5f11c0d62b8835" translate="yes" xml:space="preserve">
          <source>Be warned, these functions can be used to construct ill-kinded type representations.</source>
          <target state="translated">これらの関数は、気の弱い型表現を構築するために使用することができるので注意してください。</target>
        </trans-unit>
        <trans-unit id="7554aac55bd08ae4a1829bdc1657e239450fe1f9" translate="yes" xml:space="preserve">
          <source>Be warned: this is an experimental facility, with fewer checks than usual. Use &lt;code&gt;-dcore-lint&lt;/code&gt; to typecheck the desugared program. If Core Lint is happy you should be all right.</source>
          <target state="translated">注意してください：これは実験的な機能であり、通常よりもチェックが少なくなっています。 &lt;code&gt;-dcore-lint&lt;/code&gt; を使用して、desugaredプログラムをタイプチェックします。Core Lintが幸せであれば、大丈夫です。</target>
        </trans-unit>
        <trans-unit id="fdd46744a0edc96d38a6d8119838b4d615e82dd7" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">関連するファミリーインスタンスの&lt;em&gt;右側&lt;/em&gt;に、（&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;拡張機能を使用して）&lt;em&gt;種類の&lt;/em&gt;パラメーターを含めることもできます。たとえば、このクラスとインスタンスは完全に許容されます：</target>
        </trans-unit>
        <trans-unit id="0e4123c9a7cc2c0e3ec676685e293b58dd27e565" translate="yes" xml:space="preserve">
          <source>Bear in mind that it is also possible for the &lt;em&gt;right&lt;/em&gt;-hand side of an associated family instance to contain &lt;em&gt;kind&lt;/em&gt; parameters (by using the &lt;a href=&quot;poly_kinds#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; extension). For instance, this class and instance are perfectly admissible:</source>
          <target state="translated">関連付けられたファミリインスタンスの&lt;em&gt;右側&lt;/em&gt;に、（&lt;a href=&quot;poly_kinds#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;拡張機能を使用して）&lt;em&gt;種類&lt;/em&gt;パラメータを含めることもできることに注意してください。たとえば、このクラスとインスタンスは完全に許容されます。</target>
        </trans-unit>
        <trans-unit id="7efc4e2f9d66a82f758a773da6630b93a7985e7a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; はHaskell文法で特別に扱われるため、 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; はセクションではなく、接頭辞の否定の適用です。ただし、 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; は許可されていないセクションと同等です。</target>
        </trans-unit>
        <trans-unit id="5c608a2b36ee0d8fe295adfc9f68da466a5a7382" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-&lt;/code&gt; is treated specially in the Haskell grammar, &lt;code&gt;(-&lt;/code&gt;&lt;em&gt;e&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is not a section, but an application of prefix negation. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exp&lt;/em&gt;&lt;code&gt;)&lt;/code&gt; is equivalent to the disallowed section.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; はHaskell文法で特別に扱われるため、 &lt;code&gt;(-&lt;/code&gt; &lt;em&gt;e &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; はセクションではなく、接頭辞の否定の適用です。ただし、 &lt;code&gt;(&lt;a href=&quot;prelude#v:subtract&quot;&gt;subtract&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exp &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; は許可されていないセクションと同等です。</target>
        </trans-unit>
        <trans-unit id="8b2c5ca5dad541aa7265cf458075ac55886113df" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; is the only field of &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; depending on &lt;code&gt;m&lt;/code&gt;, the expression &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; leads to a type error from being too general. This function works around that issue, and may become unnecessary if another field depending on &lt;code&gt;m&lt;/code&gt; is added.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:complete&quot;&gt;complete&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;m&lt;/code&gt; に依存する &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Settings&quot;&gt;Settings&lt;/a&gt;&lt;/code&gt; の唯一のフィールドであるため、式 &lt;code&gt;defaultSettings {completionFunc = f}&lt;/code&gt; は、一般的すぎて型エラーを引き起こします。この機能はその問題を回避し、 &lt;code&gt;m&lt;/code&gt; に依存する別のフィールドが追加されると不要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="8b457de1c6b2d821b49b86e8b76d929d48f11800" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">ので &lt;code&gt;~&lt;/code&gt; より一般的な平等の関係があり、GHCはプリントアウトし &lt;code&gt;~~&lt;/code&gt; のように &lt;code&gt;~&lt;/code&gt; しない限り、&lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="b5e7e24ec7e3c0fdbaa3e27a95a2858ab8e68585" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;~&lt;/code&gt; is the more common equality relation, GHC prints out &lt;code&gt;~~&lt;/code&gt; like &lt;code&gt;~&lt;/code&gt; unless &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is set.</source>
          <target state="translated">ので &lt;code&gt;~&lt;/code&gt; より一般的な平等の関係があり、GHCはプリントアウトし &lt;code&gt;~~&lt;/code&gt; のように &lt;code&gt;~&lt;/code&gt; しない限り、&lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="a7118064a4d44aa8f245264afef0d428f57c57f6" translate="yes" xml:space="preserve">
          <source>Because Haskell objects and libraries tend to be large, it can take many real seconds to slurp the bits to/from a remote filesystem.</source>
          <target state="translated">Haskell のオブジェクトやライブラリは大きくなる傾向があるため、リモートファイルシステムとの間でビットをスラスプするのに何秒もかかることがあります。</target>
        </trans-unit>
        <trans-unit id="72e3d53125a21f513cc7ad6223feeb5607db810b" translate="yes" xml:space="preserve">
          <source>Because bounded primitives are the more general case, in this documentation we only refer to fixed size primitives where it matters that the resulting sequence of bytes is of a fixed length. Otherwise, we just refer to bounded size primitives.</source>
          <target state="translated">拘束されたプリミティブはより一般的なケースなので、このドキュメントでは、結果として得られるバイト列の長さが固定されていることが重要な場合にのみ、固定サイズのプリミティブを参照します。それ以外の場合は、制限付きサイズのプリミティブのみを参照します。</target>
        </trans-unit>
        <trans-unit id="b5fdc31bfd5809c4f1c4e511c746ab15cfe4b9d1" translate="yes" xml:space="preserve">
          <source>Because local fixity declarations are technically Haskell 98, no extension is necessary to enable them.</source>
          <target state="translated">ローカル固定性宣言は技術的にはHaskell 98なので、それを有効にするための拡張は必要ありません。</target>
        </trans-unit>
        <trans-unit id="de8ee7dd4338a2055669c56f86b3139945bd3682" translate="yes" xml:space="preserve">
          <source>Because of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; is unclear name, we use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; for alias of &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">であるため &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; 不明の名前である、我々は使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:decodeMultiByteIO&quot;&gt;decodeMultiByteIO&lt;/a&gt;&lt;/code&gt; をのエイリアス &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:stringToUnicode&quot;&gt;stringToUnicode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fcb8636cfa970f434fa5b94db2cb53e2de61b75" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;#12971&lt;/a&gt; for more.</source>
          <target state="translated">Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;#12971&lt;/a&gt; for more.</target>
        </trans-unit>
        <trans-unit id="5fbf59b2f9a8d04abba49afed510bca079acda23" translate="yes" xml:space="preserve">
          <source>Because of a toolchain limitation we are unable to support full Unicode paths on Windows. On Windows we support up to Latin-1. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;Issue #12971&lt;/a&gt; for more.</source>
          <target state="translated">ツールチェーンの制限により、Windowsでは完全なUnicodeパスをサポートできません。Windowsでは、Latin-1までサポートしています。詳細については、&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12971&quot;&gt;問題＃12971&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c1351fede99f7574d382011519c832e48e2febe1" translate="yes" xml:space="preserve">
          <source>Because of the aggressive optimization that GHC performs to the programs it compiles it is quite difficult to pin-point exactly which point in the source program a given machine instruction should be attributed to. In fact, internally GHC associates each instruction with a &lt;strong&gt;set&lt;/strong&gt; of source locations. When emitting the standard debug information used by &lt;code&gt;gdb&lt;/code&gt; and other language-agnostic debugging tools, GHC is forced to heuristically choose one location from among this set.</source>
          <target state="translated">GHCがコンパイルするプログラムに対してGHCが実行する積極的な最適化のため、特定の機械語命令がソースプログラムのどのポイントに属するかを正確に特定することは非常に困難です。実際、GHCは内部的に各命令を&lt;strong&gt;一連&lt;/strong&gt;のソースロケーションに関連付けています。 &lt;code&gt;gdb&lt;/code&gt; およびその他の言語に依存しないデバッグツールで使用される標準のデバッグ情報を出力する場合、GHCはこのセットの中から1つの場所を発見的に選択することを強制されます。</target>
        </trans-unit>
        <trans-unit id="526af66ce39268b28da886109bb8d1f1638720be" translate="yes" xml:space="preserve">
          <source>Because of the lack of an outermost &lt;code&gt;forall&lt;/code&gt; in the type of &lt;code&gt;MkT&lt;/code&gt;, the &lt;code&gt;b&lt;/code&gt; would be implicitly quantified. In effect, it would be as if one had written &lt;code&gt;MkT :: forall b. (forall a. a -&amp;gt; b -&amp;gt; T)&lt;/code&gt;, which contains nested &lt;code&gt;forall&lt;/code&gt;s. See &lt;a href=&quot;gadt_syntax#formal-gadt-syntax&quot;&gt;Formal syntax for GADTs&lt;/a&gt;.</source>
          <target state="translated">そのため、最も外側の不足の &lt;code&gt;forall&lt;/code&gt; のタイプ &lt;code&gt;MkT&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; が暗黙的に定量化されるだろう。事実上、 &lt;code&gt;MkT :: forall b. (forall a. a -&amp;gt; b -&amp;gt; T)&lt;/code&gt; を書いたかのようになります。（foralla。a-&amp;gt; b-&amp;gt; T）、ネストされた &lt;code&gt;forall&lt;/code&gt; が含まれます。&lt;a href=&quot;gadt_syntax#formal-gadt-syntax&quot;&gt;GADTの正式な構文を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d22c87e1c1a19e64881fa0a5c29ea8d152160afd" translate="yes" xml:space="preserve">
          <source>Because of the sad state of most UNIX linkers, the order of such options does matter. If library ⟨foo⟩ requires library ⟨bar⟩, then in general &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; should come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;-l ⟨bar⟩&lt;/code&gt; on the command line.</source>
          <target state="translated">ほとんどのUNIXリンカーの悲しい状態のため、そのようなオプションの順序は重要です。ライブラリ⟨foo⟩ライブラリ⟨bar⟩が必要な場合は、一般的に &lt;code&gt;-l ⟨foo⟩&lt;/code&gt; 来る必要があります&lt;em&gt;前に、&lt;/em&gt; &lt;code&gt;-l ⟨bar⟩&lt;/code&gt; コマンドラインで。</target>
        </trans-unit>
        <trans-unit id="aefb27d5d1f818fec24e956de3be5cc43a462d50" translate="yes" xml:space="preserve">
          <source>Because of this, unlike &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, explicit binding of type/kind variables in default declarations is not permitted by &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このため、&lt;a href=&quot;#assoc-inst&quot;&gt;Associatedインスタンス&lt;/a&gt;とは異なり、デフォルト宣言での型/種類変数の明示的なバインドは、&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;では許可されていません。</target>
        </trans-unit>
        <trans-unit id="f47acccf5b190df69b3205bc25cdf837d4bc4d64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;IArray&lt;/code&gt; interface provides operations overloaded on the type of the array, it should be possible to just change the array type being used by a program from say &lt;code&gt;Array&lt;/code&gt; to &lt;code&gt;UArray&lt;/code&gt; to get the benefits of unboxed arrays (don't forget to import &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; instead of &lt;a href=&quot;data-array&quot;&gt;Data.Array&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;IArray&lt;/code&gt; インターフェイスは、配列の型にオーバーロードされた操作を提供するため、プログラムで使用されている配列の型を、たとえば &lt;code&gt;Array&lt;/code&gt; から &lt;code&gt;UArray&lt;/code&gt; に変更するだけで、ボックス化されていない配列の利点を得ることができます（&lt;a href=&quot;data-array-unboxed&quot;&gt;データの&lt;/a&gt;インポートを忘れないでください。 Data.Arrayではなく&lt;a href=&quot;data-array&quot;&gt;Array.Unboxed&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="73825efb186a67ab4235b4b330529ec46440f89c" translate="yes" xml:space="preserve">
          <source>Because the code generator must store and move arguments as well as variables, the logic above applies equally well to function arguments, which may not be levity-polymorphic.</source>
          <target state="translated">コード生成器は変数と同様に引数を格納したり移動したりしなければならないので、上記のロジックは関数引数にも同様に適用されますが、レヴィティポリモーフィックではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="0b922e23af5d396ea51043a6f5495cb7265ef575" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">これらのエラーについてインデックスをチェックする必要があるため、 &lt;code&gt;&lt;a href=&quot;data-array#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; は境界引数と関連リストのインデックスでは厳密ですが、値では厳密ではありません。したがって、次のような再発が可能です。</target>
        </trans-unit>
        <trans-unit id="744b8a2e53d06a3c0594d327e50d361273a6ea66" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list. Whether &lt;code&gt;array&lt;/code&gt; is strict or non-strict in the elements depends on the array type: &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; is a non-strict array type, but all of the &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; arrays are strict. Thus in a non-strict array, recurrences such as the following are possible:</source>
          <target state="translated">これらのエラーについてインデックスをチェックする必要があるため、 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; は境界引数と連想リストのインデックスで厳密です。かどうかを &lt;code&gt;array&lt;/code&gt; 要素に厳密または非厳密なことは、アレイタイプに依存する： &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 、非厳密な配列型であるが、すべての &lt;code&gt;&lt;a href=&quot;data-array-unboxed#v:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; のアレイが厳しいです。したがって、非厳密な配列では、次のような繰り返しが可能です。</target>
        </trans-unit>
        <trans-unit id="1ead8ebe60edd2b98db40ca3daeca484e250542a" translate="yes" xml:space="preserve">
          <source>Because the indices must be checked for these errors, &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; is strict in the bounds argument and in the indices of the association list, but non-strict in the values. Thus, recurrences such as the following are possible:</source>
          <target state="translated">これらのエラーについてインデックスをチェックする必要があるため、 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:array&quot;&gt;array&lt;/a&gt;&lt;/code&gt; は境界引数と関連リストのインデックスでは厳密ですが、値では厳密ではありません。したがって、次のような再発が可能です。</target>
        </trans-unit>
        <trans-unit id="3877a6244217b5631d19062ad9620975d2dde55e" translate="yes" xml:space="preserve">
          <source>Because the preprocessor targets Haskell (rather than Core), &lt;code&gt;let&lt;/code&gt;-bound variables are monomorphic.</source>
          <target state="translated">プリプロセッサーは（Coreではなく）Haskellをターゲットにしているため、 &lt;code&gt;let&lt;/code&gt; バインド変数は単相です。</target>
        </trans-unit>
        <trans-unit id="808844f69c7e9605bc105a4ad20ea2d366849e5a" translate="yes" xml:space="preserve">
          <source>Because there is no unboxed unit tuple, the following expression</source>
          <target state="translated">アンボックス化された単位タプルが存在しないため、次の式</target>
        </trans-unit>
        <trans-unit id="76fec9d9feb8d4cfd75fa0cf83ef0298228be150" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">ticky-tickyプロファイリングにはGHC内部についてある程度の知識が必要であるため、ドキュメントをGHC開発者wikiに移動しました。そのご覧ください&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Profiling&quot;&gt;プロファイリングオプションの概要&lt;/a&gt; ticky-tickyプロファイルページへのリンクをincludeds、。</target>
        </trans-unit>
        <trans-unit id="50cb7c0b41fc81c206b893c65bdf7993f9032da2" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</source>
          <target state="translated">Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includeds a link to the ticky-ticky profiling page.</target>
        </trans-unit>
        <trans-unit id="0697b298a873826983783cd5e687ae37a97dd6a7" translate="yes" xml:space="preserve">
          <source>Because ticky-ticky profiling requires a certain familiarity with GHC internals, we have moved the documentation to the GHC developers wiki. Take a look at its &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;overview of the profiling options&lt;/a&gt;, which includes a link to the ticky-ticky profiling page.</source>
          <target state="translated">ちっぽけなプロファイリングにはGHCの内部にある程度精通している必要があるため、ドキュメントをGHC開発者wikiに移動しました。そのご覧ください&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/profiling&quot;&gt;プロファイリングオプションの概要&lt;/a&gt;ticky-tickyプロファイルページへのリンクが含まれ、。</target>
        </trans-unit>
        <trans-unit id="2d85fe57284106ee9c63c6a96e2335fd4a4543d3" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in a polymorphic datatype. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">ボックス化されていない型はポインタを使用せずに表されるため、ポリモーフィックデータ型に格納することはできません。例えば、 &lt;code&gt;Just&lt;/code&gt; のノード &lt;code&gt;Just 42#&lt;/code&gt; とは異なるでなければならない &lt;code&gt;Just&lt;/code&gt; ノード &lt;code&gt;Just 42&lt;/code&gt; 。前者は整数を直接格納し、後者はポインタを格納します。GHCは現在、この種類の &lt;code&gt;Just&lt;/code&gt; ノードをサポートしていません（他のデータ型もサポートしていません）。従って、&lt;em&gt;種類&lt;/em&gt;非ボックス化型は、ボックス化型の種類は異なっています。</target>
        </trans-unit>
        <trans-unit id="f3d41195121db8c561952d390998012e5adf5323" translate="yes" xml:space="preserve">
          <source>Because unboxed types are represented without the use of pointers, we cannot store them in use a polymorphic datatype at an unboxed type. For example, the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42#&lt;/code&gt; would have to be different from the &lt;code&gt;Just&lt;/code&gt; node of &lt;code&gt;Just 42&lt;/code&gt;; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of &lt;code&gt;Just&lt;/code&gt; nodes (nor for any other datatype). Accordingly, the &lt;em&gt;kind&lt;/em&gt; of an unboxed type is different from the kind of a boxed type.</source>
          <target state="translated">ボックス化されていない型はポインタを使用せずに表現されるため、ボックス化されていない型で多態性データ型を使用中に格納することはできません。例えば、 &lt;code&gt;Just&lt;/code&gt; のノード &lt;code&gt;Just 42#&lt;/code&gt; とは異なるでなければならない &lt;code&gt;Just&lt;/code&gt; ノード &lt;code&gt;Just 42&lt;/code&gt; 。前者は整数を直接格納し、後者はポインタを格納します。GHCは現在、このさまざまな &lt;code&gt;Just&lt;/code&gt; ノードをサポートしていません（他のデータ型についてもサポートしていません）。従って、&lt;em&gt;種類&lt;/em&gt;非ボックス化型は、ボックス化型の種類は異なっています。</target>
        </trans-unit>
        <trans-unit id="fe6fce85b24f15b5d65932c379eeca8ae6b18466" translate="yes" xml:space="preserve">
          <source>Becomes this:</source>
          <target state="translated">これになります。</target>
        </trans-unit>
        <trans-unit id="0ef17ad67edcf83107e1af3022c4061c85509f1d" translate="yes" xml:space="preserve">
          <source>Before data is written, it is first encoded as UTF-8.</source>
          <target state="translated">データが書き込まれる前に、まず UTF-8 でエンコードされます。</target>
        </trans-unit>
        <trans-unit id="595c4c743cb61dcc0704188c65ab1109a331f426" translate="yes" xml:space="preserve">
          <source>Before going into the Safe Haskell details, let&amp;rsquo;s point out some of the reasons this security mechanism would fail without Safe Haskell:</source>
          <target state="translated">Safe Haskellの詳細に入る前に、このセキュリティメカニズムがSafe Haskellなしで失敗する理由のいくつかを指摘しましょう。</target>
        </trans-unit>
        <trans-unit id="74554fdf503e2d7e6e96019d0ebd03e229b9e50a" translate="yes" xml:space="preserve">
          <source>Before resorting to explicit unboxed types, try using strict constructor fields and &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; first (see above). That way, your code stays portable.</source>
          <target state="translated">明示的なボックス化されていない型に頼る前に、最初にstrictコンストラクターフィールドと&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;を使用してみてください（上記を参照）。これにより、コードの移植性が維持されます。</target>
        </trans-unit>
        <trans-unit id="c505eb2064aacbd9cf542da06128d3e808f292b7" translate="yes" xml:space="preserve">
          <source>Before using the Continuation monad, be sure that you have a firm understanding of continuation-passing style and that continuations represent the best solution to your particular design problem. Many algorithms which require continuations in other languages do not require them in Haskell, due to Haskell's lazy semantics. Abuse of the Continuation monad can produce code that is impossible to understand and maintain.</source>
          <target state="translated">継続モナドを使用する前に、継続パスのスタイルをしっかりと理解し、継続が設計上の問題に対する最良の解決策であることを確認してください。他の言語では継続を必要とするアルゴリズムの多くは、Haskellでは継続を必要としませんが、HaskellではそれはHaskellの怠惰なセマンティクスのためです。継続モナドを悪用すると、理解や保守が不可能なコードが生成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2da8e18ee240f54f494c1090de6f01f19305fb9e" translate="yes" xml:space="preserve">
          <source>Before you get too carried away working at the lowest level (e.g., sloshing &lt;code&gt;MutableByteArray#&lt;/code&gt;s around your program), you may wish to check if there are libraries that provide a &amp;ldquo;Haskellised veneer&amp;rdquo; over the features you want. The separate &lt;a href=&quot;../libraries/index&quot;&gt;libraries documentation&lt;/a&gt; describes all the libraries that come with GHC.</source>
          <target state="translated">最下位レベルでの作業に夢中になってしまう前に（たとえば、プログラムの周りの &lt;code&gt;MutableByteArray#&lt;/code&gt; s）、必要な機能に「Haskellisedベニア」を提供するライブラリがあるかどうかを確認することをお勧めします。個別の&lt;a href=&quot;../libraries/index&quot;&gt;ライブラリのドキュメントに&lt;/a&gt;は、GHCに付属するすべてのライブラリが記載されています。</target>
        </trans-unit>
        <trans-unit id="6e79eaaaac969988bacd211dc7719f705249b6b2" translate="yes" xml:space="preserve">
          <source>Begin or end a multi-line GHCi command block.</source>
          <target state="translated">複数行のGHCiコマンドブロックを開始または終了します。</target>
        </trans-unit>
        <trans-unit id="aaa2d30b9548c8c6360214c67d65f8f2b43a2ef2" translate="yes" xml:space="preserve">
          <source>Beginning offset of file to lock</source>
          <target state="translated">ロックするファイルの先頭オフセット</target>
        </trans-unit>
        <trans-unit id="a88e403def4a0ef34fb4cbdd6fb4234e3d4de40f" translate="yes" xml:space="preserve">
          <source>Beginning offset of file to unlock</source>
          <target state="translated">ロック解除するファイルの先頭オフセット</target>
        </trans-unit>
        <trans-unit id="a603260088041becc44147197033a240091e8107" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 6.12, text I/O is performed using the system or handle's current locale and line ending conventions.</source>
          <target state="translated">GHC 6.12 以降、 テ キ ス ト I/O は、 シ ス テ ムま たはハン ド ルのカ レ ン ト ロ ケール と 行末の規則を用いて実行 さ れます。</target>
        </trans-unit>
        <trans-unit id="f3aa22597a1e0633e605134fce9271b6f0ab9592" translate="yes" xml:space="preserve">
          <source>Beginning with GHC 7.2, it is possible to use binary serialization without writing any instance boilerplate code.</source>
          <target state="translated">GHC 7.2からは、インスタンスのボイラプレートコードを書かずにバイナリシリアライズを使用することが可能になりました。</target>
        </trans-unit>
        <trans-unit id="70cb647a88bd7c9c17d225eecdaf0f898261eb60" translate="yes" xml:space="preserve">
          <source>Behavior</source>
          <target state="translated">Behavior</target>
        </trans-unit>
        <trans-unit id="3b615d319efe934d18d838650aea75dd222232f9" translate="yes" xml:space="preserve">
          <source>Behaviors</source>
          <target state="translated">Behaviors</target>
        </trans-unit>
        <trans-unit id="198a78dbe4628d2be1564fc1b18cd50856f7b448" translate="yes" xml:space="preserve">
          <source>Behind all these special cases there is a simple guiding principle. Consider</source>
          <target state="translated">これらの特殊なケースの背後には、シンプルな指針となる原則があります。次のようなことを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="9927980f0adf7f518791c8284a901dec62d24eaf" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;オプショングループの一部であるため、この警告はデフォルトでオフになっていますが、&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal（MFP）の&lt;/a&gt;一部として、将来のGHCリリースでオンになる予定です。</target>
        </trans-unit>
        <trans-unit id="7b666df63b130afff3eedd81208b2e0a7a134951" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;オプショングループの一部であるため、この警告はデフォルトでオフになっていますが、GHCの今後のリリースでオンになる予定です。</target>
        </trans-unit>
        <trans-unit id="2dc8c83454270735d86a9e3ef3fee23e1a680d7a" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;オプショングループの一部であるため、この警告はデフォルトでオフになっていますが、&lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal（MFP）の&lt;/a&gt;一部として、将来のGHCリリースでオンになります。</target>
        </trans-unit>
        <trans-unit id="f03e9e7f99ad75ac4d7551b349bf9316b17b8429" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release, as part of the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e424286d0dd9624ae70bbdecffd2b0043a24233e" translate="yes" xml:space="preserve">
          <source>Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</source>
          <target state="translated">Being part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; option group, this warning is off by default, but will be switched on in a future GHC release.</target>
        </trans-unit>
        <trans-unit id="9c04a6e766fbff8072acd4912e7880d5f0b4d39b" translate="yes" xml:space="preserve">
          <source>Being strict by being lazy</source>
          <target state="translated">怠けることで厳しくなる</target>
        </trans-unit>
        <trans-unit id="969fbe69d4fd12dcb8cd78548a9408fd636a4a1d" translate="yes" xml:space="preserve">
          <source>Bell alerts</source>
          <target state="translated">ベルアラート</target>
        </trans-unit>
        <trans-unit id="36c94be5c6badc8ef160f60b3f9d24d9b2c8db30" translate="yes" xml:space="preserve">
          <source>Below are two examples showing a definition of a reusable less-polymorphic &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and a one-off in-line specialisation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">以下は、再利用可能な多形性の少ない &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 定義と、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 1回限りのインライン特殊化を示す2つの例です。</target>
        </trans-unit>
        <trans-unit id="9405867e098bc21ea37caa6071fbd884463207a3" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下は、&lt;a href=&quot;../debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; の&lt;/a&gt;出力例です。</target>
        </trans-unit>
        <trans-unit id="631e6a2e29c9e7487b85c9d3fda8e1229ccc3cd2" translate="yes" xml:space="preserve">
          <source>Below is a sample output of &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下は&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; の&lt;/a&gt;出力例です</target>
        </trans-unit>
        <trans-unit id="b2041b4df1603971cd99daa2131b9173fce20a5d" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下は、&lt;a href=&quot;../debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;を使用した同じサンプルの出力です。</target>
        </trans-unit>
        <trans-unit id="7895436348a83297630a392863829501eafbcaec" translate="yes" xml:space="preserve">
          <source>Below is the output of the same sample using &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">以下は、&lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;を使用した同じサンプルの出力です</target>
        </trans-unit>
        <trans-unit id="9dafb52c45cfdbf863160a686861b97310393d60" translate="yes" xml:space="preserve">
          <source>Below we construct a &lt;code&gt;Foldable&lt;/code&gt; instance for a data type representing a (finite) binary tree with depth-first traversal.</source>
          <target state="translated">以下では、深さ優先走査の（有限）二分木を表すデータ型の &lt;code&gt;Foldable&lt;/code&gt; インスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="a29d5a1f385485805511ac832659c0faf4251bd6" translate="yes" xml:space="preserve">
          <source>Below we implement an analogous data structure using a representation based on &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This is an example of &lt;em&gt;Church encoding&lt;/em&gt; (named after Alonzo Church, inventor of the lambda calculus).</source>
          <target state="translated">以下では、 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; に基づく表現を使用して類似のデータ構造を実装します。これは&lt;em&gt;チャーチエンコーディングの&lt;/em&gt;例です（ラムダ計算の発明者であるアロンゾチャーチにちなんで名付けられました）。</target>
        </trans-unit>
        <trans-unit id="98ad2d7635fc111746d76bbebe8290141e95c77d" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;を他のディクショナリ実装と比較するベンチマークは、&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https：//github.com/haskell-perf/dictionariesにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="accf09ba43e68b9c38f3e58c7eda4b805b21f104" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;を他のディクショナリ実装と比較するベンチマークは、&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https：//github.com/haskell-perf/dictionariesにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8166d1f6f68785d8abaf21c7a0c48450cb6c1c1e" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt;を他のディクショナリ実装と比較するベンチマークは、&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https：//github.com/haskell-perf/dictionariesにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c3dee153b5361c9c8871a11980becccab3e42dc" translate="yes" xml:space="preserve">
          <source>Benchmarks comparing &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; with other dictionary implementations can be found at &lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https://github.com/haskell-perf/dictionaries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt;を他のディクショナリ実装と比較するベンチマークは、&lt;a href=&quot;https://github.com/haskell-perf/dictionaries&quot;&gt;https：//github.com/haskell-perf/dictionariesにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ffe14aeb84cb87ee3186a9571b06e8928ba55d3" translate="yes" xml:space="preserve">
          <source>Beside</source>
          <target state="translated">Beside</target>
        </trans-unit>
        <trans-unit id="fe92499c572ca34751830e44318f456f3cef3984" translate="yes" xml:space="preserve">
          <source>Beside, separated by space</source>
          <target state="translated">空間で区切られた横</target>
        </trans-unit>
        <trans-unit id="788b6f6586539d7fc47b8fcc55c19730cea68d99" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、引数の1つが &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; でない限り、スペースで区切られます。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; は関連性があり、IDは &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8e330d7aca54bde1e02fdeabed64fcc133a6401a" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、引数の1つが &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; でない限り、スペースで区切られます。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; は関連性があり、IDは &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e618be55395d8238a159850eddcfbe3ac7a7c273" translate="yes" xml:space="preserve">
          <source>Beside, separated by space, unless one of the arguments is &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、引数の1つが &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; でない限り、スペースで区切られます。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; は関連性があり、IDは &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="624607c86787dd5201e891b5c7bb38bfd2a78db7" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">横に。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; は関連付けられており、IDは &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d88ff324bd9ae359aacf25e29a3916a4ff7c3758" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">横に。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; は関連付けられており、IDは &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d384f6b4d5525841d1e0cf79b191835355e54bd2" translate="yes" xml:space="preserve">
          <source>Beside. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">横に。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; は関連付けられており、IDは &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="85ed1a12122824af84b077aa03948e1d13a22d0d" translate="yes" xml:space="preserve">
          <source>Besides an extra-constraints wildcard (see &lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;Extra-Constraints Wildcard&lt;/a&gt;), only named wildcards can occur in the constraints, e.g. the &lt;code&gt;_x&lt;/code&gt; in &lt;code&gt;Show _x&lt;/code&gt;.</source>
          <target state="translated">余分な制約が（参照ワイルドカードのほかに&lt;a href=&quot;#extra-constraints-wildcard&quot;&gt;エクストラ制約ワイルドカードを&lt;/a&gt;）、唯一の名前のワイルドカードは、例えば、制約に発生する可能性があります &lt;code&gt;_x&lt;/code&gt; で &lt;code&gt;Show _x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26a472de725e2ab48d4de069fd18a472bb691f2e" translate="yes" xml:space="preserve">
          <source>Besides the stock approach to deriving instances by generating all method definitions, GHC supports two additional deriving strategies, which can derive arbitrary classes:</source>
          <target state="translated">すべてのメソッド定義を生成してインスタンスを導出するストック・アプローチの他に、GHCは任意のクラスを導出できる2つの導出戦略をサポートしています。</target>
        </trans-unit>
        <trans-unit id="bf2ddad2d8faffde93e2583147aba1ed84271cf8" translate="yes" xml:space="preserve">
          <source>Beware that for many monads (those for which the &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict) this instance will &lt;em&gt;not&lt;/em&gt; satisfy the right-tightening law required by the &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">多くのモナド（ &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 演算が厳密なモナド）では、このインスタンスは &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowLoop&quot;&gt;ArrowLoop&lt;/a&gt;&lt;/code&gt; クラスに必要な右締めの法則を満たさ&lt;em&gt;ない&lt;/em&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d549c234ccdd45fa67e66fd17e9aa5b7f98bef5" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">場合によっては、この機能を使用するために&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;拡張機能を有効にする必要があることに注意してください。これがなぜ起こるかを説明する病理学的なケースはここにあります：</target>
        </trans-unit>
        <trans-unit id="e7c1558fc208f9daac585e394451c0ebdd033dbc" translate="yes" xml:space="preserve">
          <source>Beware that in some cases, you may need to enable the &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension in order to use this feature. Here&amp;rsquo;s a pathological case that illustrates why this might happen:</source>
          <target state="translated">この機能を使用するには、場合によっては&lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;拡張機能を有効にする必要があることに注意してください。これが発生する理由を説明する病理学的ケースは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="653c3c82d14b666acef082f6f19dc453202cc92e" translate="yes" xml:space="preserve">
          <source>Beware that this function allocates a new file descriptor. A consequence of this is that calling &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; on the standard Windows handles will not give you &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For example, if you run this code:</source>
          <target state="translated">この関数は新しいファイル記述子を割り当てることに注意してください。この結果、標準のWindowsハンドルで &lt;code&gt;&lt;a href=&quot;system-win32-types#v:hANDLEToHandle&quot;&gt;hANDLEToHandle&lt;/a&gt;&lt;/code&gt; を呼び出しても、 &lt;code&gt;&lt;a href=&quot;io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; は提供されません。たとえば、次のコードを実行すると、</target>
        </trans-unit>
        <trans-unit id="7827a30613f0ebab2ac4ede20720ab2ad59250c6" translate="yes" xml:space="preserve">
          <source>Beware: &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#v:fromString&quot;&gt;fromString&lt;/a&gt;&lt;/code&gt; truncates multi-byte characters to octets. e.g. &quot;枯朶に烏のとまりけり秋の暮&quot; becomes �6k�nh~�Q��n�</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#v:fromString&quot;&gt;fromString&lt;/a&gt;&lt;/code&gt; は、マルチバイト文字をオクテットに切り捨てます。例：「枯朶に烏のと並けりありか」は「6k」nh〜「Q」になります。</target>
        </trans-unit>
        <trans-unit id="2d677a45c1242d143f2da8c0235a4156fc9aed39" translate="yes" xml:space="preserve">
          <source>Bidirectional</source>
          <target state="translated">Bidirectional</target>
        </trans-unit>
        <trans-unit id="03af5d044e78c5ca2a87b11a0cd3ee30426faaa4" translate="yes" xml:space="preserve">
          <source>Bifoldable</source>
          <target state="translated">Bifoldable</target>
        </trans-unit>
        <trans-unit id="6148a7120e3e6bee1841037a0e66edba57f2b59d" translate="yes" xml:space="preserve">
          <source>Bifunctor</source>
          <target state="translated">Bifunctor</target>
        </trans-unit>
        <trans-unit id="a1ec611991374940381b1e25467f733adcf02bbc" translate="yes" xml:space="preserve">
          <source>Big-endian</source>
          <target state="translated">Big-endian</target>
        </trans-unit>
        <trans-unit id="f84c8cdd20adeb4d710d8f5e51b3ed37c2ffc31f" translate="yes" xml:space="preserve">
          <source>Big-endian decoding</source>
          <target state="translated">ビッグエンディアン復号化</target>
        </trans-unit>
        <trans-unit id="a75e84204fb542f8fffbe1d93f24c4127709d703" translate="yes" xml:space="preserve">
          <source>Big-endian primitives</source>
          <target state="translated">ビッグエンディアンプリミティブ</target>
        </trans-unit>
        <trans-unit id="d80f000c501b0702089f0a6d5d685b3b13d95ab4" translate="yes" xml:space="preserve">
          <source>Big-endian writes</source>
          <target state="translated">ビッグエンディアンの書き込み</target>
        </trans-unit>
        <trans-unit id="b092fd4b540ba704e7eab5010e33d073c85baa3e" translate="yes" xml:space="preserve">
          <source>BigEndian</source>
          <target state="translated">BigEndian</target>
        </trans-unit>
        <trans-unit id="4a103563aecb5d07999bf55551e2840da08dea6b" translate="yes" xml:space="preserve">
          <source>BigNat</source>
          <target state="translated">BigNat</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="ca596333bdb84d8c57915427010182cfc758ccf1" translate="yes" xml:space="preserve">
          <source>Binary encodings</source>
          <target state="translated">バイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="b7a0b74a0efeea7a4ae51a1506822c7ba3cdfd5b" translate="yes" xml:space="preserve">
          <source>Binary input and output</source>
          <target state="translated">バイナリ入出力</target>
        </trans-unit>
        <trans-unit id="977f362d04f5411618935479aa90d3c2cbbc8fc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation</source>
          <target state="translated">バイナリ直列化</target>
        </trans-unit>
        <trans-unit id="e899d0e0bf36df2f1e4a7c2fa0c0833fc062acdf" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">Haskell値と遅延 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; の間のバイナリシリアル化。Binaryライブラリは、Haskell値をバイトストリームとしてメモリに直接エンコードするメソッドを提供します。結果の &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; は、ディスクに書き込んだり、ネットワーク経由で送信したり、さらに処理（たとえば、gzipで圧縮）したりできます。</target>
        </trans-unit>
        <trans-unit id="21a20ed9e4ba0673faa9314d967e4c8a18a9ddc9" translate="yes" xml:space="preserve">
          <source>Binary serialisation of Haskell values to and from lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. The Binary library provides methods for encoding Haskell values as streams of bytes directly in memory. The resulting &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; can then be written to disk, sent over the network, or further processed (for example, compressed with gzip).</source>
          <target state="translated">怠惰な &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; との間のHaskell値のバイナリシリアル化。バイナリライブラリは、Haskell値をメモリ内のバイトストリームとして直接エンコードするためのメソッドを提供します。結果の &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; は、ディスクに書き込んだり、ネットワーク経由で送信したり、さらに処理したりできます（たとえば、gzipで圧縮）。</target>
        </trans-unit>
        <trans-unit id="4f05e0ce4c49719ca18e235c0a5338e6c9f82d92" translate="yes" xml:space="preserve">
          <source>Binary-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s do no newline translation at all.</source>
          <target state="translated">Binary-Mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; は改行変換をまったく行いません。</target>
        </trans-unit>
        <trans-unit id="4e65c3b7cae6dd45ee04f43d6dc7e91ad9857ed8" translate="yes" xml:space="preserve">
          <source>BinaryLiterals</source>
          <target state="translated">BinaryLiterals</target>
        </trans-unit>
        <trans-unit id="ef29ec8d1db838c8e1a48ba8918f31da08b74947" translate="yes" xml:space="preserve">
          <source>BinaryType</source>
          <target state="translated">BinaryType</target>
        </trans-unit>
        <trans-unit id="6bc6b5d113e80feddce377fd7a1ee8583e9b656f" translate="yes" xml:space="preserve">
          <source>Bind worker threads on a capability to the appropriate node.</source>
          <target state="translated">ケイパビリティ上のワーカースレッドを適切なノードにバインドします。</target>
        </trans-unit>
        <trans-unit id="250887693e686f9b9bf4bfdc01f65dbe05d0a943" translate="yes" xml:space="preserve">
          <source>Binding a function to a monadic value creates a new continuation which uses the function as the continuation of the monadic computation.</source>
          <target state="translated">関数を単項値にバインドすると、単項演算の継続として関数を使用する新しい継続が作成されます。</target>
        </trans-unit>
        <trans-unit id="df37671abb2b5d29837d448a150784288f14c591" translate="yes" xml:space="preserve">
          <source>Binding strategy:</source>
          <target state="translated">装丁戦略。</target>
        </trans-unit>
        <trans-unit id="f86ed004f3a732d1f540de4195d20a7e54011bbe" translate="yes" xml:space="preserve">
          <source>Bindings are translated with the &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; functions to the usual do-notation:</source>
          <target state="translated">バインディングがで翻訳されて &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; と &lt;code&gt;return&lt;/code&gt; 通常のdo記法の機能：</target>
        </trans-unit>
        <trans-unit id="c5508d22bc8524cbfc21537e7df0e0da3d89023d" translate="yes" xml:space="preserve">
          <source>Bindings:</source>
          <target state="translated">Bindings:</target>
        </trans-unit>
        <trans-unit id="d77c376e13dda253679750f2f2a4005705a750a7" translate="yes" xml:space="preserve">
          <source>Binds &lt;code&gt;response&lt;/code&gt; to the result of the following &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; block, binds &lt;code&gt;exit&lt;/code&gt; to the continuation.</source>
          <target state="translated">&lt;code&gt;response&lt;/code&gt; を次の &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; ブロックの結果にバインドし、 &lt;code&gt;exit&lt;/code&gt; を継続にバインドします。</target>
        </trans-unit>
        <trans-unit id="2fe1387ba65691c262469ad0ad878d77f589b9fd" translate="yes" xml:space="preserve">
          <source>Biographical profiling samples start with the &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; event. These events also include a timestamp which indicates when the sample was taken. This is because all these samples will appear at the end of the eventlog due to how the biographical profiling mode works. You can use the timestamp to reorder the samples relative to the other events.</source>
          <target state="translated">Biographical profiling samples start with the &lt;code&gt;EVENT_HEAP_BIO_PROF_SAMPLE_BEGIN&lt;/code&gt; event. These events also include a timestamp which indicates when the sample was taken. This is because all these samples will appear at the end of the eventlog due to how the biographical profiling mode works. You can use the timestamp to reorder the samples relative to the other events.</target>
        </trans-unit>
        <trans-unit id="1bca52e9cf05fd2b526ca79883fe209959fdb0eb" translate="yes" xml:space="preserve">
          <source>Bit reversal</source>
          <target state="translated">ビット反転</target>
        </trans-unit>
        <trans-unit id="bd55858742523f8eb1bcf4b2ff338846c79cd3cf" translate="yes" xml:space="preserve">
          <source>Bit-operations</source>
          <target state="translated">Bit-operations</target>
        </trans-unit>
        <trans-unit id="3bb87577cfbf6b194391f9fd2449d3a6daeb5a6e" translate="yes" xml:space="preserve">
          <source>BitMap</source>
          <target state="translated">BitMap</target>
        </trans-unit>
        <trans-unit id="792ac9c6e86cf4159b4253d880e8d576591cad45" translate="yes" xml:space="preserve">
          <source>BitQueue</source>
          <target state="translated">BitQueue</target>
        </trans-unit>
        <trans-unit id="16859195f5f61ebc3eeb05fc2fd6fe7e5753102f" translate="yes" xml:space="preserve">
          <source>BitQueueB</source>
          <target state="translated">BitQueueB</target>
        </trans-unit>
        <trans-unit id="b3f2f3df0a3eb7ef036e378ae33aea93f8400b62" translate="yes" xml:space="preserve">
          <source>Bitraversable</source>
          <target state="translated">Bitraversable</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="f4eecb0837ac1302da3d67883bc955eb28db73ff" translate="yes" xml:space="preserve">
          <source>Bits are numbered from 0 with bit 0 being the least significant bit.</source>
          <target state="translated">ビットは0から順に番号が付けられ、ビット0が最下位ビットとなります。</target>
        </trans-unit>
        <trans-unit id="51a3d80c1096a062a320e452d30389dbba6e7b2e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;</source>
          <target state="translated">ビット単位の「と</target>
        </trans-unit>
        <trans-unit id="c00a3cca6e0ab63567c09149e3d79bf22145be8a" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;and&quot;.</source>
          <target state="translated">ビット単位の「と」。</target>
        </trans-unit>
        <trans-unit id="0762de2cf0c6e6b77d828208804bb630467f8b11" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;not&quot;, also known as the binary complement.</source>
          <target state="translated">ビット単位の「しない」、二進補語としても知られています。</target>
        </trans-unit>
        <trans-unit id="2ddacb26a9c51fdf4ca8a56ff66cbb76c9340f8f" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;</source>
          <target state="translated">ビット単位の「または</target>
        </trans-unit>
        <trans-unit id="c4b3b9bbde6c754b04ce738f6f2d6bfaa36d025e" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;or&quot;.</source>
          <target state="translated">ビット単位の「または」。</target>
        </trans-unit>
        <trans-unit id="06ae84f662f3c26c21557288d7b8b92876ca8dee" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;</source>
          <target state="translated">ビット単位の「xor</target>
        </trans-unit>
        <trans-unit id="e3c7281d1f961f980af39f221c595b00177f9020" translate="yes" xml:space="preserve">
          <source>Bitwise &quot;xor&quot;.</source>
          <target state="translated">ビット単位の「xor」。</target>
        </trans-unit>
        <trans-unit id="1aa01b99c6c9acf5a48b2725a9ba94e0bfd7f80c" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;code&gt;NOT&lt;/code&gt; operation</source>
          <target state="translated">ビットごとの &lt;code&gt;NOT&lt;/code&gt; 演算</target>
        </trans-unit>
        <trans-unit id="683d2fe77a00a83b71f7046b5e0207bef8f8b05e" translate="yes" xml:space="preserve">
          <source>Bitwise AND operation</source>
          <target state="translated">ビットごとのAND演算</target>
        </trans-unit>
        <trans-unit id="812234cb7852ab2e4152ebfeecff0e34bbc8f331" translate="yes" xml:space="preserve">
          <source>Bitwise OR operation</source>
          <target state="translated">ビットごとのOR演算</target>
        </trans-unit>
        <trans-unit id="566da620243c869eb9093b1d9109361f7deab173" translate="yes" xml:space="preserve">
          <source>Bitwise XOR operation</source>
          <target state="translated">ビットごとのXOR演算</target>
        </trans-unit>
        <trans-unit id="b406fb57b29fc76f71864fbb37f0238045f84d9d" translate="yes" xml:space="preserve">
          <source>Black</source>
          <target state="translated">Black</target>
        </trans-unit>
        <trans-unit id="8f231bba8956b90d7be7998e87d3ff0f36931637" translate="yes" xml:space="preserve">
          <source>Blackholing is the act of marking a thunk (lazy computation) as being under evaluation. It is useful for three reasons: firstly it lets us detect certain kinds of infinite loop (the &lt;code&gt;NonTermination&lt;/code&gt; exception), secondly it avoids certain kinds of space leak, and thirdly it avoids repeating a computation in a parallel program, because we can tell when a computation is already in progress.</source>
          <target state="translated">ブラックホーリングは、サンク（遅延計算）を評価中としてマークする行為です。これは3つの理由で役立ちます &lt;code&gt;NonTermination&lt;/code&gt; は特定の種類の無限ループ（NonTermination例外）を検出できること、2つ目は特定の種類のスペースリークを回避すること、3つ目は並列プログラムでの計算の繰り返しを回避することです。計算はすでに進行中です。</target>
        </trans-unit>
        <trans-unit id="574a76735e33bbd57fb0a916028cacc6070b3973" translate="yes" xml:space="preserve">
          <source>Block size</source>
          <target state="translated">ブロックサイズ</target>
        </trans-unit>
        <trans-unit id="8b9a1d81d5887c9c67a6b20d2df16d43fe81caa7" translate="yes" xml:space="preserve">
          <source>Block the current thread until data can be written to the given file descriptor (GHC only).</source>
          <target state="translated">与えられたファイルディスクリプタにデータを書き込めるようになるまで、現在のスレッドをブロックします(GHCのみ)。</target>
        </trans-unit>
        <trans-unit id="7065922fead5956b30a4880d4db36fbe6025cd84" translate="yes" xml:space="preserve">
          <source>Block the current thread until data is available to read on the given file descriptor (GHC only).</source>
          <target state="translated">指定されたファイルディスクリプタでデータが読み込めるようになるまで、現在のスレッドをブロックします(GHC のみ)。</target>
        </trans-unit>
        <trans-unit id="2032cada98db5faaa0692223c8180668544f801d" translate="yes" xml:space="preserve">
          <source>Block until input is available on specified file descriptor.</source>
          <target state="translated">指定されたファイルディスクリプタで入力が可能になるまでブロックする。</target>
        </trans-unit>
        <trans-unit id="37d7b821bc5d453b65c16db21a1b548c820c28a2" translate="yes" xml:space="preserve">
          <source>Block until output is possible on specified file descriptor.</source>
          <target state="translated">指定されたファイルディスクリプタ上で出力可能になるまでブロックする。</target>
        </trans-unit>
        <trans-unit id="9ba5e142177e718c386fc68a7e5656d6003bdbf3" translate="yes" xml:space="preserve">
          <source>BlockArguments</source>
          <target state="translated">BlockArguments</target>
        </trans-unit>
        <trans-unit id="21ee9c95fd5afb5bc56f8da9452091ffececfb39" translate="yes" xml:space="preserve">
          <source>BlockReason</source>
          <target state="translated">BlockReason</target>
        </trans-unit>
        <trans-unit id="bc1ab004ab80487da68b0fe585fadda53b1d746e" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnMVar</source>
          <target state="translated">BlockedIndefinitelyOnMVar</target>
        </trans-unit>
        <trans-unit id="69236e61bca3edecfc65ca8a204134ba0de3fd74" translate="yes" xml:space="preserve">
          <source>BlockedIndefinitelyOnSTM</source>
          <target state="translated">BlockedIndefinitelyOnSTM</target>
        </trans-unit>
        <trans-unit id="45dfab9fc5bfc0e525595e3313ce2a25dd4d7faa" translate="yes" xml:space="preserve">
          <source>BlockedOnBlackHole</source>
          <target state="translated">BlockedOnBlackHole</target>
        </trans-unit>
        <trans-unit id="93c9452da95239560e86200369ac0d634e21fb28" translate="yes" xml:space="preserve">
          <source>BlockedOnException</source>
          <target state="translated">BlockedOnException</target>
        </trans-unit>
        <trans-unit id="b61c27531d4d77cf1630fbca19ceced64a349e39" translate="yes" xml:space="preserve">
          <source>BlockedOnForeignCall</source>
          <target state="translated">BlockedOnForeignCall</target>
        </trans-unit>
        <trans-unit id="f3b3ba940976333504078cae62e2eabe3bbf8432" translate="yes" xml:space="preserve">
          <source>BlockedOnIOCompletion</source>
          <target state="translated">BlockedOnIOCompletion</target>
        </trans-unit>
        <trans-unit id="53d58631b450ca365b0ba176488a8441b143b2c2" translate="yes" xml:space="preserve">
          <source>BlockedOnMVar</source>
          <target state="translated">BlockedOnMVar</target>
        </trans-unit>
        <trans-unit id="895bd85890de6d5092a051ca56773fa4f0cd0c75" translate="yes" xml:space="preserve">
          <source>BlockedOnOther</source>
          <target state="translated">BlockedOnOther</target>
        </trans-unit>
        <trans-unit id="3804172b29d85f99db9a290a3dd685ef7d5c8d84" translate="yes" xml:space="preserve">
          <source>BlockedOnSTM</source>
          <target state="translated">BlockedOnSTM</target>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="7d44bc449c2a26374800a503f10f3d8949505f40" translate="yes" xml:space="preserve">
          <source>Blue</source>
          <target state="translated">Blue</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="0120b648baeefab9ba6ebfa6450b325f6a60cba8" translate="yes" xml:space="preserve">
          <source>BodyQ</source>
          <target state="translated">BodyQ</target>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="3f8b6ea3af3c50fa9d094ce543d63a1358584bcf" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;</source>
          <target state="translated">ブーリアン「と</target>
        </trans-unit>
        <trans-unit id="04332ab31b7691eb315a3b0e8934a864c9ebacfa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;and&quot;, lazy in the second argument</source>
          <target state="translated">ブール値 &quot;and&quot;、第2引数の遅延</target>
        </trans-unit>
        <trans-unit id="69265825ad6d4c4d64bf7e08030ff39e70a968fa" translate="yes" xml:space="preserve">
          <source>Boolean &quot;not&quot;</source>
          <target state="translated">ブーリアン &quot;not&quot;</target>
        </trans-unit>
        <trans-unit id="b22b4e8199107440fbfe7d97c6a6e57037c7151d" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;</source>
          <target state="translated">ブーリアン</target>
        </trans-unit>
        <trans-unit id="0266fdeda44ec514d099d2f8107813680104acda" translate="yes" xml:space="preserve">
          <source>Boolean &quot;or&quot;, lazy in the second argument</source>
          <target state="translated">ブール値 &quot;or&quot;、第2引数の遅延</target>
        </trans-unit>
        <trans-unit id="eb9c2517131e28267052868fb04f87dd8cb84e01" translate="yes" xml:space="preserve">
          <source>Boolean monoid under conjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">論理積の下のブールモノイド（ &lt;code&gt;&lt;a href=&quot;data-bool#v:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c181263cf12be8452e7085b87f90b355a0cc7ef9" translate="yes" xml:space="preserve">
          <source>Boolean monoid under disjunction (&lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">分離（ &lt;code&gt;&lt;a href=&quot;data-bool#v:-124--124-&quot;&gt;||&lt;/a&gt;&lt;/code&gt; ）でのブールモノイド。</target>
        </trans-unit>
        <trans-unit id="8ee67baf0a124b81be7277cfa2a8ff919c8c8724" translate="yes" xml:space="preserve">
          <source>Boolean predicate folds. These functions examine elements strictly until a condition is met, but then return a result ignoring the rest (lazy in the tail). These may loop forever given an unbounded input where no elements satisy the termination condition.</source>
          <target state="translated">ブール式述語の折り返し。これらの関数は、ある条件が満たされるまで要素を厳密に調べ、残りを無視して結果を返します(末尾が遅延)。これらの関数は、終了条件を満たす要素がない非束縛的な入力を与えられると、永遠にループする可能性があります。</target>
        </trans-unit>
        <trans-unit id="2732eeea43125f2e843ab5f5666a8d163b3d9289" translate="yes" xml:space="preserve">
          <source>Boolean type-level equality</source>
          <target state="translated">ブール型レベルの等式</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="98b4ea6bcdbb948d8cbe34481cd1c0a07bd194e0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">両方 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; はに設けられたインターフェースと一致するように存在する &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 型クラスを、それを実現するために推奨される &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 使用してインスタンスを &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; のとは対照的に &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec&quot;&gt;liftReadsPrec&lt;/a&gt;&lt;/code&gt; 前者が後者よりも効率的であるので、。例えば：</target>
        </trans-unit>
        <trans-unit id="3f34f496978794b63af2a314d45c261e70ec11ca" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; exist to match the interface provided in the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; type class, but it is recommended to implement &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; as opposed to &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt;, since the former is more efficient than the latter. For example:</source>
          <target state="translated">両方 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; はに設けられたインターフェースと一致するように存在する &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 型クラスを、それを実現するために推奨される &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; 使用してインスタンスを &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; のとは対照的に &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadsPrec2&quot;&gt;liftReadsPrec2&lt;/a&gt;&lt;/code&gt; 前者が後者よりも効率的であるので、。例えば：</target>
        </trans-unit>
        <trans-unit id="5b731e5f2cccb2521565e021975320c572150ee8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;, and pick an arbitrary one if multiple choices are available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; の両方で、複数の選択肢が利用可能な場合は任意のものを選択します。</target>
        </trans-unit>
        <trans-unit id="4d60c7bb83c292da504a6719a69ebefefdf4659e" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlapping&quot;&gt;Overlapping&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:Overlappable&quot;&gt;Overlappable&lt;/a&gt;&lt;/code&gt; 両方</target>
        </trans-unit>
        <trans-unit id="2b44c00c13cb83fe026cbd5b8d4d766f125c9858" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F0&lt;/code&gt; have kind &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but their arity differs.</source>
          <target state="translated">Both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F0&lt;/code&gt; have kind &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; , but their arity differs.</target>
        </trans-unit>
        <trans-unit id="c5124f48e35e2fbfeb662d20bdb90a9e2a8cb8e0" translate="yes" xml:space="preserve">
          <source>Both module &lt;code&gt;Class&lt;/code&gt; and module &lt;code&gt;Dangerous&lt;/code&gt; will compile under &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; without issue. However, in module &lt;code&gt;TCB_Runner&lt;/code&gt;, we must check if the call to &lt;code&gt;op&lt;/code&gt; in function &lt;code&gt;f&lt;/code&gt; is safe.</source>
          <target state="translated">モジュール &lt;code&gt;Class&lt;/code&gt; とモジュール &lt;code&gt;Dangerous&lt;/code&gt; はどちらも&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;で問題なくコンパイルされます。ただし、モジュール &lt;code&gt;TCB_Runner&lt;/code&gt; では、関数 &lt;code&gt;f&lt;/code&gt; の &lt;code&gt;op&lt;/code&gt; の呼び出しが安全かどうかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="49ffa16e1c07272dd28d622d9dbdc1c18ed54d66" translate="yes" xml:space="preserve">
          <source>Both of these hold:</source>
          <target state="translated">両方ともホールドします。</target>
        </trans-unit>
        <trans-unit id="2bafd70b5ada2ef0c84297ccc53777ff415bca1e" translate="yes" xml:space="preserve">
          <source>Both the type &lt;code&gt;Ex&lt;/code&gt; and the data constructor &lt;code&gt;MkEx&lt;/code&gt; get promoted, with the polymorphic kind &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt;. Somewhat surprisingly, you can write a type family to extract the member of a type-level existential:</source>
          <target state="translated">タイプ &lt;code&gt;Ex&lt;/code&gt; とデータコンストラクター &lt;code&gt;MkEx&lt;/code&gt; の両方が昇格され、ポリモーフィックな種類 &lt;code&gt;'MkEx :: forall k. k -&amp;gt; Ex&lt;/code&gt; 。少し意外なことに、型ファミリーを作成して、型レベルの存在のメンバーを抽出できます。</target>
        </trans-unit>
        <trans-unit id="361b42712506425fdcf2b1ea50a51aa8dea82ef8" translate="yes" xml:space="preserve">
          <source>Both upper- and lower-case &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'F'&lt;/code&gt; are converted as well, to &lt;code&gt;10..15&lt;/code&gt;.</source>
          <target state="translated">大文字と小文字の両方の &lt;code&gt;'A'&lt;/code&gt; から &lt;code&gt;'F'&lt;/code&gt; も &lt;code&gt;10..15&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="ecb0b65529079a3af9e45a8098a612b9728453e3" translate="yes" xml:space="preserve">
          <source>BothQueues</source>
          <target state="translated">BothQueues</target>
        </trans-unit>
        <trans-unit id="403591682693529ea8d764be443089ceac85ad97" translate="yes" xml:space="preserve">
          <source>Bound Threads</source>
          <target state="translated">バウンドスレッド</target>
        </trans-unit>
        <trans-unit id="60da7217d44bdc40c1eb907204fa54294872b81f" translate="yes" xml:space="preserve">
          <source>Bound threads can be created using the &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; function below. All foreign exported functions are run in a bound thread (bound to the OS thread that called the function). Also, the &lt;code&gt;main&lt;/code&gt; action of every Haskell program is run in a bound thread.</source>
          <target state="translated">バインドされたスレッドは、以下の &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 関数を使用して作成できます。すべての外部エクスポート関数は、バインドされたスレッド（関数を呼び出したOSスレッドにバインドされた）で実行されます。また、すべてのHaskellプログラムの &lt;code&gt;main&lt;/code&gt; アクションは、バインドされたスレッドで実行されます。</target>
        </trans-unit>
        <trans-unit id="1bb360f4682f39da897d5087bec41a43fcf97967" translate="yes" xml:space="preserve">
          <source>Bounded</source>
          <target state="translated">Bounded</target>
        </trans-unit>
        <trans-unit id="5cf53f246d50f6260632d008d2b6db3a49861eea" translate="yes" xml:space="preserve">
          <source>Bounded-size builder primitives</source>
          <target state="translated">境界サイズビルダープリミティブ</target>
        </trans-unit>
        <trans-unit id="67c8c593c7bd9a6879a0fe1147f8534d16210197" translate="yes" xml:space="preserve">
          <source>Bounded-size primitives</source>
          <target state="translated">境界サイズプリミティブ</target>
        </trans-unit>
        <trans-unit id="1d198c2728b2ed26f54e7cf85c8fe977ccb9dc30" translate="yes" xml:space="preserve">
          <source>BoundedPrim</source>
          <target state="translated">BoundedPrim</target>
        </trans-unit>
        <trans-unit id="b95a97052e20a036c292b97a8ef02a42631be78d" translate="yes" xml:space="preserve">
          <source>Bounds</source>
          <target state="translated">Bounds</target>
        </trans-unit>
        <trans-unit id="c32b8e824fbf6eb465582d1de11fcd8513bd5c9c" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">境界 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; などによって与えられます。</target>
        </trans-unit>
        <trans-unit id="dd273039c19f3757a5b2fd1fd257892b02f8e2dc" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">境界 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-map-strict#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; などによって与えられます。</target>
        </trans-unit>
        <trans-unit id="c07a1483ae52efde58c537e9e0e90f76af8d10c2" translate="yes" xml:space="preserve">
          <source>Bounds for &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; are as given by</source>
          <target state="translated">境界 &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; などによって与えられます。</target>
        </trans-unit>
        <trans-unit id="f69cf141b98e3135d46e5dad39602462872e7538" translate="yes" xml:space="preserve">
          <source>BoxLabel</source>
          <target state="translated">BoxLabel</target>
        </trans-unit>
        <trans-unit id="2ede889b135cd77a1e71ca9eac7d985ad2849d48" translate="yes" xml:space="preserve">
          <source>Boxed arrays</source>
          <target state="translated">箱型配列</target>
        </trans-unit>
        <trans-unit id="b252e3099c6de97ebf23d4d3dad230e7eb5f4d7a" translate="yes" xml:space="preserve">
          <source>Break a string on a substring, returning a pair of the part of the string prior to the match, and the rest of the string.</source>
          <target state="translated">文字列を部分文字列上でブレークし、マッチする前の文字列の部分と残りの文字列のペアを返します。</target>
        </trans-unit>
        <trans-unit id="48c9c26fa469922bae1a8d989dbc3283a3056b99" translate="yes" xml:space="preserve">
          <source>Break on any exception thrown</source>
          <target state="translated">投げられた例外でブレーク</target>
        </trans-unit>
        <trans-unit id="a3c2a397d9584ae0b3fce8742f96600f8f4f3b73" translate="yes" xml:space="preserve">
          <source>Break on uncaught exceptions and errors</source>
          <target state="translated">捕まえられなかった例外やエラーでのブレーク</target>
        </trans-unit>
        <trans-unit id="5255e26cd5c57de2f55fb7938271f8fe86a6ef18" translate="yes" xml:space="preserve">
          <source>Breaking into lines and words</source>
          <target state="translated">セリフや言葉に慣れる</target>
        </trans-unit>
        <trans-unit id="e436763b8c5113cc5e50ec031996d87ced4c8b9f" translate="yes" xml:space="preserve">
          <source>Breaking into many substrings</source>
          <target state="translated">多くの部分文字列への分割</target>
        </trans-unit>
        <trans-unit id="9572241e9e3834b00e85795597b97e3ac3c0330f" translate="yes" xml:space="preserve">
          <source>Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on.</source>
          <target state="translated">例外でブレークすることは、プログラムが無限ループに入っているときに何をしていたかを調べるのに特に便利です。Control-Cを叩いて履歴を調べれば、何が起こっていたのかがわかります。</target>
        </trans-unit>
        <trans-unit id="9ef5f02e366bdd5b1bc2750710d3b437ec6c866e" translate="yes" xml:space="preserve">
          <source>Breaking strings</source>
          <target state="translated">弦を切る</target>
        </trans-unit>
        <trans-unit id="9462db075d64fc4a3db967b37fffd444976427cc" translate="yes" xml:space="preserve">
          <source>Breakpoints can also be set by line (and optionally column) number:</source>
          <target state="translated">ブレークポイントは、行番号(および任意で列番号)で設定することもできます。</target>
        </trans-unit>
        <trans-unit id="60a59cc6fc01f63be8e198f2fd5dd150495e86da" translate="yes" xml:space="preserve">
          <source>Breakpoints can be set in various ways. Perhaps the easiest way to set a breakpoint is to name a top-level function:</source>
          <target state="translated">ブレークポイントは様々な方法で設定できます。おそらく、ブレークポイントを設定する最も簡単な方法は、トップレベルの関数に名前を付けることです。</target>
        </trans-unit>
        <trans-unit id="f3e8df33a1deb2bc938e5368fcc9fe73e94b3bdd" translate="yes" xml:space="preserve">
          <source>Breakpoints can be set on arbitrarily deeply nested functions, but the whole chain of nested function names must be specified.</source>
          <target state="translated">ブレークポイントは、任意の深さのネストされた関数に設定できますが、ネストされた関数名のチェーン全体を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5d7429ed06486112488321794f766798e806ffe7" translate="yes" xml:space="preserve">
          <source>Breaks down the graph by heap closure type.</source>
          <target state="translated">グラフをヒープ閉鎖タイプで分解します。</target>
        </trans-unit>
        <trans-unit id="b6426715004373ae21dcdb366f81839cc52b183c" translate="yes" xml:space="preserve">
          <source>Bringing type variables into scope is particularly important for existential data constructors. For example:</source>
          <target state="translated">型変数をスコープに入れることは、特に実在性データのコンストラクタでは重要です。例えば</target>
        </trans-unit>
        <trans-unit id="a676d7117cb70fed108c464413db56b7582a1b58" translate="yes" xml:space="preserve">
          <source>Broadcast a scalar to all elements of a vector.</source>
          <target state="translated">ベクトルの全要素にスカラをブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="63915c89cc9540e39b93d3bbb0389bf834c12179" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</source>
          <target state="translated">バッファ割り当て機能。 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; が指定されている場合は、新しい最初のバッファーを割り当てる必要があります。場合 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; 与えられ、その後、最小サイズのバッファ &lt;code&gt;minSize&lt;/code&gt; 返さなければなりません。この参照は透過的になり、 &lt;code&gt;oldBuffer&lt;/code&gt; が十分な大きさであることを保証できる場合、戦略は &lt;code&gt;oldBuffer&lt;/code&gt; を再利用できます。</target>
        </trans-unit>
        <trans-unit id="3ffb5bb34208049e05e2848a2a464b9554b0c581" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</source>
          <target state="translated">Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuffer&lt;/code&gt; , if it can guarantee that this referentially transparent and &lt;code&gt;oldBuffer&lt;/code&gt; is large enough.</target>
        </trans-unit>
        <trans-unit id="2421eb366ac457d20e3b2bf63b1d22adfd90f3a8" translate="yes" xml:space="preserve">
          <source>Buffer allocation function. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is given, then a new first buffer should be allocated. If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; is given, then a buffer with minimal size &lt;code&gt;minSize&lt;/code&gt; must be returned. The strategy may reuse the &lt;code&gt;oldBuf&lt;/code&gt;, if it can guarantee that this referentially transparent and &lt;code&gt;oldBuf&lt;/code&gt; is large enough.</source>
          <target state="translated">バッファ割り当て機能。 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; も指定されていない場合は、新しい最初のバッファを割り当てる必要があります。場合 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (oldBuf, minSize)&lt;/code&gt; 与えられ、その後、最小サイズのバッファ &lt;code&gt;minSize&lt;/code&gt; 返さなければなりません。この参照透過性と &lt;code&gt;oldBuf&lt;/code&gt; が十分に大きいことを保証できる場合、戦略は &lt;code&gt;oldBuf&lt;/code&gt; を再利用できます。</target>
        </trans-unit>
        <trans-unit id="d1511aac3b884d36da1f7bb8a91d1b07265d2d60" translate="yes" xml:space="preserve">
          <source>Buffer allocation strategy to use</source>
          <target state="translated">使用するバッファの割り当て方法</target>
        </trans-unit>
        <trans-unit id="efe38e877d87cf3a601574f61e8c6112056e7eb0" translate="yes" xml:space="preserve">
          <source>Buffer management</source>
          <target state="translated">バッファ管理</target>
        </trans-unit>
        <trans-unit id="9824aaadc3118ca3339cc9676a3f0f7e0217d736" translate="yes" xml:space="preserve">
          <source>Buffer range to fill.</source>
          <target state="translated">埋めるバッファの範囲を指定します。</target>
        </trans-unit>
        <trans-unit id="07882a47335e43d38370ae44c05618c4c0286951" translate="yes" xml:space="preserve">
          <source>BufferCodec</source>
          <target state="translated">BufferCodec</target>
        </trans-unit>
        <trans-unit id="a9ae0ebad1f560c0b01d474fcf8a1259da2e45b3" translate="yes" xml:space="preserve">
          <source>BufferList</source>
          <target state="translated">BufferList</target>
        </trans-unit>
        <trans-unit id="85c84c25d56fc13d452000134b60f28ba5e1e022" translate="yes" xml:space="preserve">
          <source>BufferListNil</source>
          <target state="translated">BufferListNil</target>
        </trans-unit>
        <trans-unit id="f7f013f67bedbafe6a6a6713f8fba0341a8b5915" translate="yes" xml:space="preserve">
          <source>BufferMode</source>
          <target state="translated">BufferMode</target>
        </trans-unit>
        <trans-unit id="107a37d237e86ecf0a07109468ec7abb99d1adfa" translate="yes" xml:space="preserve">
          <source>BufferRange</source>
          <target state="translated">BufferRange</target>
        </trans-unit>
        <trans-unit id="322e5d09d79c6009f5674e7117a1114889fbffad" translate="yes" xml:space="preserve">
          <source>BufferState</source>
          <target state="translated">BufferState</target>
        </trans-unit>
        <trans-unit id="4e850fb4754d7daddef54b1081f53c061e2277d2" translate="yes" xml:space="preserve">
          <source>BufferWriter</source>
          <target state="translated">BufferWriter</target>
        </trans-unit>
        <trans-unit id="f000f6a3275f9800597ad7f1ac98d43bdd868368" translate="yes" xml:space="preserve">
          <source>BufferedIO</source>
          <target state="translated">BufferedIO</target>
        </trans-unit>
        <trans-unit id="9639fd1e6014e384d9b0d21001270a4532eabd44" translate="yes" xml:space="preserve">
          <source>Buffering operations</source>
          <target state="translated">バッファリング操作</target>
        </trans-unit>
        <trans-unit id="1705358c6a0b24af297b254b2108454741ff4557" translate="yes" xml:space="preserve">
          <source>Buffers of any element</source>
          <target state="translated">任意の要素のバッファ</target>
        </trans-unit>
        <trans-unit id="aec7810cb2c876e23b0033e46aae5289ebf0c07c" translate="yes" xml:space="preserve">
          <source>Buffers used in the IO system</source>
          <target state="translated">IOシステムで使用されるバッファ</target>
        </trans-unit>
        <trans-unit id="0c6dee2a7b5942268d8c231ef297e7abf881535b" translate="yes" xml:space="preserve">
          <source>Buggle only imports &lt;code&gt;Prelude&lt;/code&gt;, which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt;&amp;lsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt;, and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</source>
          <target state="translated">Buggle は、&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;でコンパイルされた &lt;code&gt;Prelude&lt;/code&gt; のみをインポートします。 &lt;code&gt;Prelude&lt;/code&gt; は、 &lt;code&gt;C&lt;/code&gt; が信頼する &lt;code&gt;base&lt;/code&gt; パッケージにあり、 &lt;code&gt;Prelude&lt;/code&gt; のインポートはすべて信頼されます。したがって、 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;Prelude&lt;/code&gt; を信頼し、 &lt;code&gt;C&lt;/code&gt; はBuggleも信頼します。（ &lt;code&gt;Prelude&lt;/code&gt; は通常暗黙的にインポートされますが、それでもここで概説されているのと同じルールに従います）。</target>
        </trans-unit>
        <trans-unit id="dab94f662adaf1659e7f05eebbac08d52174fe85" translate="yes" xml:space="preserve">
          <source>Buggle only imports &lt;code&gt;Prelude&lt;/code&gt;, which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt;&amp;rsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt;, and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</source>
          <target state="translated">Buggle only imports &lt;code&gt;Prelude&lt;/code&gt; , which is compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;. &lt;code&gt;Prelude&lt;/code&gt; resides in the &lt;code&gt;base&lt;/code&gt; package, which &lt;code&gt;C&lt;/code&gt; trusts, and (we&amp;rsquo;ll assume) all of &lt;code&gt;Prelude&lt;/code&gt; &amp;rsquo;s imports are trusted. So &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;Prelude&lt;/code&gt; , and so &lt;code&gt;C&lt;/code&gt; also trusts Buggle. (While &lt;code&gt;Prelude&lt;/code&gt; is typically imported implicitly, it still obeys the same rules outlined here).</target>
        </trans-unit>
        <trans-unit id="8081798290cefd3d54a8b9c792ffff9da0c521f1" translate="yes" xml:space="preserve">
          <source>Build a (possibly infinite) forest from a list of seed values in breadth-first order.</source>
          <target state="translated">種の値のリストから(無限になる可能性のある)森を幅優先で構築します。</target>
        </trans-unit>
        <trans-unit id="4bf90ac98bb2341a2075164c532c21f819b14548" translate="yes" xml:space="preserve">
          <source>Build a (possibly infinite) tree from a seed value in breadth-first order.</source>
          <target state="translated">種の値から(無限の可能性のある)木を幅第一次で構築します。</target>
        </trans-unit>
        <trans-unit id="c1d9cde7a54b308063f3fd73d9babe621683dd31" translate="yes" xml:space="preserve">
          <source>Build a function type.</source>
          <target state="translated">関数型を構築します。</target>
        </trans-unit>
        <trans-unit id="884c3b47e0ba76cd8f3c27d14e011d3bd05577da" translate="yes" xml:space="preserve">
          <source>Build a graph from a list of edges.</source>
          <target state="translated">辺のリストからグラフを作成します。</target>
        </trans-unit>
        <trans-unit id="a94df834fcc88712c4822652bc46a21adf37eec8" translate="yes" xml:space="preserve">
          <source>Build a graph from a list of nodes uniquely identified by keys, with a list of keys of nodes this node should have edges to.</source>
          <target state="translated">キーによって一意に識別されるノードのリストからグラフを構築し、このノードがエッジを持つべきノードのキーのリストを使用します。</target>
        </trans-unit>
        <trans-unit id="2fea8f78ed97ff98cabd9dfcff293718197383f4" translate="yes" xml:space="preserve">
          <source>Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt;; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt; for details.</source>
          <target state="translated">マルチモジュールのHaskellプログラムをビルドし、依存関係を自動的に把握します。 &lt;code&gt;make&lt;/code&gt; を使用するよりもはるかに簡単で高速です。詳細については、&lt;a href=&quot;using#make-mode&quot;&gt;ghc -makeの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3a5960117b6ce95230aee2dd05eee4a451e3faba" translate="yes" xml:space="preserve">
          <source>Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt;; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc --make&lt;/a&gt; for details.</source>
          <target state="translated">Build a multi-module Haskell program, automatically figuring out dependencies. Likely to be much easier, and faster, than using &lt;code&gt;make&lt;/code&gt; ; see &lt;a href=&quot;using#make-mode&quot;&gt;Using ghc --make&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="ecfe54531e239227dfe711c2483b41196f665224" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;control-concurrent-qsem#t:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; with a supplied initial quantity. The initial quantity must be at least 0.</source>
          <target state="translated">指定された初期数量で新しい &lt;code&gt;&lt;a href=&quot;control-concurrent-qsem#t:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; を構築します。初期数量は少なくとも0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="0dbc0898ffb2401cdf281b35699fcbe7978e4839" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;control-concurrent-qsemn#t:QSemN&quot;&gt;QSemN&lt;/a&gt;&lt;/code&gt; with a supplied initial quantity. The initial quantity must be at least 0.</source>
          <target state="translated">指定された初期数量で新しい &lt;code&gt;&lt;a href=&quot;control-concurrent-qsemn#t:QSemN&quot;&gt;QSemN&lt;/a&gt;&lt;/code&gt; を構築します。初期数量は少なくとも0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="70552251bfc019f0a6642059f0e75968472b7607" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="203ae674b4968ad5dbc66e2600cec2ba9f05797f" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; in the current state thread</source>
          <target state="translated">現在の状態のスレッドで新しい &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="b2ccc32e3940757246852fc694480f4189287bca" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="2300e21cc0d85b3217ced13fe2e4d327643182d7" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="82733393c21fc1714245da66647bbf83f8a411fd" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; in the current state thread</source>
          <target state="translated">現在の状態のスレッドで新しい &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="c48c92907a18be455e4e537a0232ec22e0c8bf45" translate="yes" xml:space="preserve">
          <source>Build a new &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">新しい &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; を構築する</target>
        </trans-unit>
        <trans-unit id="97fae16599eb28b19c06553bf02629e165abbc5e" translate="yes" xml:space="preserve">
          <source>Build a term and use a generic function for subterms</source>
          <target state="translated">用語を構築し、サブタームに汎用機能を使用する</target>
        </trans-unit>
        <trans-unit id="cdf22117ef668c1724b6471862c994146899c2a2" translate="yes" xml:space="preserve">
          <source>Build a term skeleton</source>
          <target state="translated">用語の骨格を構築する</target>
        </trans-unit>
        <trans-unit id="6e114d1f641bd96174ecb4be857124ba1201641c" translate="yes" xml:space="preserve">
          <source>Build and return a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; の新しいインスタンスを作成して返す</target>
        </trans-unit>
        <trans-unit id="3ec1bed141573c1c17cf02d6a5d0bb6f437db403" translate="yes" xml:space="preserve">
          <source>Build and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; の新しいインスタンスをビルドして返します。</target>
        </trans-unit>
        <trans-unit id="35be25a421fa9ce73459655bf04e9204af3809b5" translate="yes" xml:space="preserve">
          <source>Build and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; の新しいインスタンスを作成して返します</target>
        </trans-unit>
        <trans-unit id="e8370129f628872766fbc00d3f80875610f346b1" translate="yes" xml:space="preserve">
          <source>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;#10352&lt;/a&gt;.</source>
          <target state="translated">Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;#10352&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="81f76d0f10c8f6fc4b46e538ab3beeacb47b224a" translate="yes" xml:space="preserve">
          <source>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining &lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; with this flag relating to linking in the RTS under Linux. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;Issue #10352&lt;/a&gt;.</source>
          <target state="translated">動的リンク用のコードを作成します。これによりコードサイズを大幅に削減できますが、インライン化されていない関数のクロスモジュール呼び出しが遅くなる可能性があります。LinuxでのRTSでのリンクに関連するこのフラグと&lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;を組み合わせると、いくつかの複雑な問題が発生する可能性があります。&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10352&quot;&gt;問題＃10352を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a5add7a5a63c06d485a23e304e415303fa124ca5" translate="yes" xml:space="preserve">
          <source>Build dynamic object files &lt;em&gt;as well as&lt;/em&gt; static object files during compilation</source>
          <target state="translated">コンパイル中に動的オブジェクトファイル&lt;em&gt;と&lt;/em&gt;静的オブジェクトファイルをビルドする</target>
        </trans-unit>
        <trans-unit id="4d3910a254eaafd1fc8455fdeef9fbad4ea46494" translate="yes" xml:space="preserve">
          <source>Build dynamically-linked object files and executables</source>
          <target state="translated">動的にリンクされたオブジェクトファイルと実行ファイルの構築</target>
        </trans-unit>
        <trans-unit id="eacb633fef8080b6f0e8a1849d462864fe4d86c5" translate="yes" xml:space="preserve">
          <source>Build signals and steps</source>
          <target state="translated">信号とステップを構築する</target>
        </trans-unit>
        <trans-unit id="0b5df5cd9791079aa609e1eaab6f8fc1c1ffdb8d" translate="yes" xml:space="preserve">
          <source>Build step to use for filling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; の塗りつぶしに使用するビルドステップ。</target>
        </trans-unit>
        <trans-unit id="333dc9940206cf3fadb3fab2461dac23ee93f097" translate="yes" xml:space="preserve">
          <source>BuildSignal</source>
          <target state="translated">BuildSignal</target>
        </trans-unit>
        <trans-unit id="801f513654150879c914869a1ad18da56a51311a" translate="yes" xml:space="preserve">
          <source>BuildStep</source>
          <target state="translated">BuildStep</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="364a8a9074eaff8c9a4b742aefb97068ac895a25" translate="yes" xml:space="preserve">
          <source>Builder construction</source>
          <target state="translated">ビルダー工事</target>
        </trans-unit>
        <trans-unit id="9bb1e848b4810eae4e0aa47509b87fbea136f359" translate="yes" xml:space="preserve">
          <source>Builder primitives are contravariant so it's like the normal fmap, but backwards (look at the type). (If it helps to remember, the operator symbol is like (&lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt;) but backwards.)</source>
          <target state="translated">ビルダープリミティブは反変であるため、通常のfmapに似ていますが、後方にあります（型を見てください）。（覚えておくと、演算子記号は（&lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt;）に似ていますが逆です。）</target>
        </trans-unit>
        <trans-unit id="080b4431eac6064309a77089493ad982c5492b9a" translate="yes" xml:space="preserve">
          <source>Builder primitives come in two forms: fixed-size and bounded-size.</source>
          <target state="translated">ビルダーのプリミティブには、固定サイズとバウンドサイズの2つの形式があります。</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="69f74097b2a4cac8d5c3948fa9f727f1ceca5558" translate="yes" xml:space="preserve">
          <source>Building ByteStrings</source>
          <target state="translated">バイト文字列の構築</target>
        </trans-unit>
        <trans-unit id="e7a886492e100281858af7babfd3d1560f1a0fa1" translate="yes" xml:space="preserve">
          <source>Building Haskell code into a shared library is a good way to include Haskell code in a larger mixed-language project. While with static linking it is recommended to use GHC to perform the final link step, with shared libraries a Haskell library can be treated just like any other shared library. The linking can be done using the normal system C compiler or linker.</source>
          <target state="translated">Haskell コードを共有ライブラリにビルドすることは、より大きな混合言語プロジェクトに Haskell コードをインクルードする良い方法です。スタティックリンクでは最終的なリンクステップを実行するためにGHCを使用することを推奨しますが、共有ライブラリではHaskellライブラリを他の共有ライブラリと同じように扱うことができます。リンクは通常のシステムCコンパイラやリンカを使って行うことができます。</target>
        </trans-unit>
        <trans-unit id="c345d8576de571b12d40732f130fe8f621f52549" translate="yes" xml:space="preserve">
          <source>Building a static library is done by using the &lt;strong&gt;ar&lt;/strong&gt; tool, like so:</source>
          <target state="translated">静的ライブラリの構築は、次のように&lt;strong&gt;ar&lt;/strong&gt;ツールを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="8152d2ec7d17304f7305d9df262ac39349bac99f" translate="yes" xml:space="preserve">
          <source>Building and using shared libraries is slightly more complicated than building and using static libraries. When using Cabal much of the detail is hidden, just use &lt;code&gt;--enable-shared&lt;/code&gt; when configuring a package to build it into a shared library, or to link it against other packages built as shared libraries. The additional complexity when building code is to distinguish whether the code will be used in a shared library or will use shared library versions of other packages it depends on. There is additional complexity when installing and distributing shared libraries or programs that use shared libraries, to ensure that all shared libraries that are required at runtime are present in suitable locations.</source>
          <target state="translated">共有ライブラリの構築と使用は、静的ライブラリの構築と使用よりも少し複雑です。 Cabalを使用すると、詳細の多くが非表示になります。共有ライブラリにビルドするパッケージを構成するとき、または共有ライブラリとしてビルドされた他のパッケージにリンクするときに、 &lt;code&gt;--enable-shared&lt;/code&gt; 使用します。コードをビルドする際の複雑さは、コードが共有ライブラリで使用されるか、依存する他のパッケージの共有ライブラリバージョンを使用するかを区別することです。実行時に必要なすべての共有ライブラリが適切な場所に存在することを保証するために、共有ライブラリまたは共有ライブラリを使用するプログラムをインストールして配布する場合は、さらに複雑になります。</target>
        </trans-unit>
        <trans-unit id="d2d47db5b33b51c402bdb2a8a2fb36f1133fc85e" translate="yes" xml:space="preserve">
          <source>Building computations from sequences of functions that may fail or using exception handling to structure error handling.</source>
          <target state="translated">失敗する可能性のある関数のシーケンスから計算を構築したり、例外処理を使用してエラー処理を構造化したりします。</target>
        </trans-unit>
        <trans-unit id="5c9c803f9e45294cd3c242c8eff2a73203984f1b" translate="yes" xml:space="preserve">
          <source>Building lists</source>
          <target state="translated">リストの構築</target>
        </trans-unit>
        <trans-unit id="59b3ac6a1ebc1aa3f0dee53bb672cdabad274ba4" translate="yes" xml:space="preserve">
          <source>Building streams</source>
          <target state="translated">流れを構築する</target>
        </trans-unit>
        <trans-unit id="f2136c9449e4d2207252445899311ca019c571b7" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">独自のパッケージの構築も非常に簡単です。パッケージの構成、構築、インストール、配布のプロセスを自動化する&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;インフラストラクチャを提供します。簡単な構成ファイルを作成し、適切な場所にいくつかのファイルを配置するだけで、パッケージが完成します。詳細については、&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabalのドキュメント&lt;/a&gt;、およびCabalライブラリ（&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;など）を参照してください。</target>
        </trans-unit>
        <trans-unit id="468ffacf83b540eb8029fa77183ff7a6bbbe4845" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">独自のパッケージの構築も非常に簡単です。パッケージの構成、構築、インストール、および配布のプロセスを自動化する&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;インフラストラクチャを提供します。簡単な設定ファイルを書き、いくつかのファイルを適切な場所に置くだけで、パッケージを作成できます。詳細については、&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabalのドキュメント&lt;/a&gt;と、Cabalライブラリ（たとえば、&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;）を参照してください。</target>
        </trans-unit>
        <trans-unit id="08e50fabbac322297c0380dab80b06348335688e" translate="yes" xml:space="preserve">
          <source>Building your own packages is also quite straightforward: we provide the &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt; infrastructure which automates the process of configuring, building, installing and distributing a package. All you need to do is write a simple configuration file, put a few files in the right places, and you have a package. See the &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal documentation&lt;/a&gt; for details, and also the Cabal libraries (&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;, for example).</source>
          <target state="translated">独自のパッケージの構築も非常に簡単です。パッケージの構成、構築、インストール、および配布のプロセスを自動化する&lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;インフラストラクチャを提供します。簡単な構成ファイルを作成し、適切な場所にいくつかのファイルを配置するだけで、パッケージが完成します。詳細については、&lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabalのドキュメント&lt;/a&gt;、およびCabalライブラリ（&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/Cabal-3.4.0.0/Distribution-Simple.html&quot;&gt;Distribution.Simple&lt;/a&gt;など）を参照してください。</target>
        </trans-unit>
        <trans-unit id="327fc0c96310e3524acc6da1fe01e6c67634802c" translate="yes" xml:space="preserve">
          <source>Builds a new array, with every element initialised to an undefined value. In a monadic context in which operations must be deterministic (e.g. the ST monad), the array elements are initialised to a fixed but undefined value, such as zero.</source>
          <target state="translated">すべての要素を未定義の値に初期化した状態で、新しい配列を構築します。演算が決定論的でなければならないモナドコンテキスト(STモナドなど)では,配列の要素は,固定ではあるが未定義の値,例えばゼロなどに初期化されます.</target>
        </trans-unit>
        <trans-unit id="9185529c0692a9b618d7cbf93f4568e19c94d3ee" translate="yes" xml:space="preserve">
          <source>Builds a new array, with every element initialised to the supplied value.</source>
          <target state="translated">すべての要素を指定した値で初期化した新しい配列を作成します。</target>
        </trans-unit>
        <trans-unit id="8214ecb33cfb7974c4f39c8c9d05735a2e2c8271" translate="yes" xml:space="preserve">
          <source>Builds a sequence from a seed value. Takes time linear in the number of generated elements. &lt;em&gt;WARNING:&lt;/em&gt; If the number of generated elements is infinite, this method will not terminate.</source>
          <target state="translated">シード値からシーケンスを構築します。生成される要素の数に比例して時間がかかります。&lt;em&gt;警告：&lt;/em&gt;生成された要素の数が無限の場合、このメソッドは終了しません。</target>
        </trans-unit>
        <trans-unit id="7b20d8714b6e61b13e739bc27b8ce588d42b92f5" translate="yes" xml:space="preserve">
          <source>Builds a time value from a parsed input string. If the input does not include all the information needed to construct a complete value, any missing parts should be taken from 1970-01-01 00:00:00 +0000 (which was a Thursday). In the absence of &lt;code&gt;%C&lt;/code&gt; or &lt;code&gt;%Y&lt;/code&gt;, century is 1969 - 2068.</source>
          <target state="translated">解析された入力文字列から時間値を作成します。入力に完全な値を作成するために必要なすべての情報が含まれていない場合、欠落している部分は1970-01-01 00:00:00 +0000（木曜日）から取得する必要があります。 &lt;code&gt;%C&lt;/code&gt; または &lt;code&gt;%Y&lt;/code&gt; がない場合、世紀は1969〜2068です。</target>
        </trans-unit>
        <trans-unit id="0e8e2b2ccd17965cacc18d35e9f5403a32e7112a" translate="yes" xml:space="preserve">
          <source>Builds and returns a new instance of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; の新しいインスタンスを作成して返します。</target>
        </trans-unit>
        <trans-unit id="76ca7a4e55fa9d29e200dbea08886efb9fb74322" translate="yes" xml:space="preserve">
          <source>Built-in names</source>
          <target state="translated">ビルトイン名</target>
        </trans-unit>
        <trans-unit id="e2f8f611e0d7e4911d6a941a4fb69322eea24213" translate="yes" xml:space="preserve">
          <source>Built-in rule ensures that applications of this function to literal Word# are lifted into Natural literals.</source>
          <target state="translated">組み込みのルールにより、この関数のリテラルWord#への適用がNaturalリテラルに持ち越されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="396f77e795df5a4def2612076c16d77e30f3c69e" translate="yes" xml:space="preserve">
          <source>Bundled Patterns</source>
          <target state="translated">バンドルパターン</target>
        </trans-unit>
        <trans-unit id="26b720e58894a51047c1c6e9ca37a4f1f3595b00" translate="yes" xml:space="preserve">
          <source>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym &lt;code&gt;P&lt;/code&gt; can not be bundled with a type constructor &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s type is visibly incompatible with &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">バンドルされたパターンシノニムは、タイプチェックされて、それらがバンドルされているタイプコンストラクターと同じタイプであることを確認します。 &lt;code&gt;P&lt;/code&gt; の型が明らかに &lt;code&gt;T&lt;/code&gt; と互換性がない場合、パターン同義語 &lt;code&gt;P&lt;/code&gt; を型コンストラクタ &lt;code&gt;T&lt;/code&gt; にバンドルすることはできません。</target>
        </trans-unit>
        <trans-unit id="9bbc0ee622ef87f959fb1f6a96e0d378e9dec049" translate="yes" xml:space="preserve">
          <source>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym &lt;code&gt;P&lt;/code&gt; can not be bundled with a type constructor &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s type is visibly incompatible with &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">バンドルされたパターンシノニムは、バンドルされている型コンストラクターと同じ型であることを確認するために型チェックされます。 &lt;code&gt;P&lt;/code&gt; の型が &lt;code&gt;T&lt;/code&gt; と明らかに互換性がない場合、パターン同義語 &lt;code&gt;P&lt;/code&gt; を型コンストラクター &lt;code&gt;T&lt;/code&gt; にバンドルすることはできません。</target>
        </trans-unit>
        <trans-unit id="4464772fd83cffa489cd2cb879896c855ed166d2" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have distinct types, and so can&amp;rsquo;t be compared. It&amp;rsquo;s just about possible to imagine examples in which the derived instance would make sense, but it seems altogether simpler simply to prohibit such declarations. Define your own instances!</source>
          <target state="translated">ただし &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; には異なるタイプがあるため、比較できません。派生インスタンスが理にかなっている例を想像するのはほぼ可能ですが、そのような宣言を禁止するほうが簡単なようです。独自のインスタンスを定義してください！</target>
        </trans-unit>
        <trans-unit id="b6ef53f84ff5027bc07ac3842944ad3414ad9d1f" translate="yes" xml:space="preserve">
          <source>But Haskell programmers can safely think of the ordinary &lt;em&gt;universally&lt;/em&gt; quantified type given above, thereby avoiding adding a new existential quantification construct.</source>
          <target state="translated">しかし、Haskellプログラマーは、上記の通常の&lt;em&gt;普遍的に&lt;/em&gt;数量化されたタイプを安全に考えることができるため、新しい存在数量化構成を追加する必要がありません。</target>
        </trans-unit>
        <trans-unit id="1a5eaf2134b45ec93619a779aa721cc224a4fe25" translate="yes" xml:space="preserve">
          <source>But because &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; are enabled, the &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; string literal would now be of type &lt;code&gt;Text&lt;/code&gt;, not &lt;code&gt;String&lt;/code&gt;, which &lt;code&gt;showString&lt;/code&gt; doesn&amp;rsquo;t accept! This causes the generated &lt;code&gt;Show&lt;/code&gt; instance to fail to typecheck. It&amp;rsquo;s hard to imagine any scenario where it would be desirable have &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; behavior within derived code, so GHC simply ignores &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; entirely when checking derived code.</source>
          <target state="translated">しかし、&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;が有効になっているため、 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 文字列リテラルは、 &lt;code&gt;String&lt;/code&gt; ではなく &lt;code&gt;Text&lt;/code&gt; 型になり、 &lt;code&gt;showString&lt;/code&gt; では受け入れられません。これにより、生成された &lt;code&gt;Show&lt;/code&gt; インスタンスはタイプチェックに失敗します。派生コード内で&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; の&lt;/a&gt;動作が望ましいシナリオを想像するのは難しいので、GHCは派生コードをチェックするときに&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; を&lt;/a&gt;完全に無視するだけです。</target>
        </trans-unit>
        <trans-unit id="a148ffd04c373d017a1eeb4091389373b44c4def" translate="yes" xml:space="preserve">
          <source>But because &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;overloaded_strings#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; are enabled, the &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; string literal would now be of type &lt;code&gt;Text&lt;/code&gt;, not &lt;code&gt;String&lt;/code&gt;, which &lt;code&gt;showString&lt;/code&gt; doesn&amp;rsquo;t accept! This causes the generated &lt;code&gt;Show&lt;/code&gt; instance to fail to typecheck. It&amp;rsquo;s hard to imagine any scenario where it would be desirable have &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; behavior within derived code, so GHC simply ignores &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; entirely when checking derived code.</source>
          <target state="translated">ただし、&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;overloaded_strings#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;が有効になっているため、 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 文字列リテラルは、 &lt;code&gt;showString&lt;/code&gt; が受け入れない &lt;code&gt;String&lt;/code&gt; ではなく &lt;code&gt;Text&lt;/code&gt; 型になります。これにより、生成された &lt;code&gt;Show&lt;/code&gt; インスタンスはタイプチェックに失敗します。派生コード内で&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; の&lt;/a&gt;動作が望ましいシナリオを想像するのは難しいため、GHCは派生コードをチェックするときに&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; を&lt;/a&gt;完全に無視します。</target>
        </trans-unit>
        <trans-unit id="513f043a73b80db70c830181c526df028997f561" translate="yes" xml:space="preserve">
          <source>But it is not clear what GHC would fill in for &lt;code&gt;???&lt;/code&gt;, as each data family instance must generate fresh data constructors.</source>
          <target state="translated">しかし、GHCが何を記入するのかは明らかではありません &lt;code&gt;???&lt;/code&gt; 、各データファミリインスタンスは新しいデータコンストラクタを生成する必要があるため。</target>
        </trans-unit>
        <trans-unit id="35278e742589993fb14c61a18c5b5d7e9aec1d0d" translate="yes" xml:space="preserve">
          <source>But more efficiently than using length on the intermediate list.</source>
          <target state="translated">しかし、中間リストで長さを使うよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="5845751806ebabdf9499df5449f17bf8fdf1e9d2" translate="yes" xml:space="preserve">
          <source>But not on lists with more than one element:</source>
          <target state="translated">しかし、複数の要素を持つリストではそうではありません。</target>
        </trans-unit>
        <trans-unit id="1747f875a6f39afa8ae9cf4d467a26e849fc8649" translate="yes" xml:space="preserve">
          <source>But not this (since the free variable &lt;code&gt;a&lt;/code&gt; is in the wrong place):</source>
          <target state="translated">しかし、これはありません（自由変数 &lt;code&gt;a&lt;/code&gt; が間違った場所にあるため）：</target>
        </trans-unit>
        <trans-unit id="65daa9e4b1075dc22f97b5e99c95b67c30d85438" translate="yes" xml:space="preserve">
          <source>But note that doing this will cause all currently loaded modules to be unloaded, and you&amp;rsquo;ll be dumped back into the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">ただし、これを行うと、現在ロードされているすべてのモジュールがアンロードされ、 &lt;code&gt;Prelude&lt;/code&gt; にダンプされます。</target>
        </trans-unit>
        <trans-unit id="5f500af96a3dd31762b3cd040fbfe22ac1abfff8" translate="yes" xml:space="preserve">
          <source>But some more exotic characters are (like HTML's &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt;):</source>
          <target state="translated">しかし、よりエキゾチックな文字がいくつかあります（HTMLの &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; など）：</target>
        </trans-unit>
        <trans-unit id="7a9f84020f58d91882dbfc0db953fb2f507004d2" translate="yes" xml:space="preserve">
          <source>But sometimes you really do need to catch any exception, and actually see what the exception is. One example is at the very top-level of a program, you may wish to catch any exception, print it to a logfile or the screen, and then exit gracefully. For these cases, you can use &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; (or one of the other exception-catching functions) with the &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">ただし、例外をキャッチして、実際に例外を確認する必要がある場合もあります。1つの例はプログラムの最上位にあり、例外をキャッチしてログファイルまたは画面に出力し、正常に終了することができます。これらの場合、 &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; タイプで &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; （または他の例外キャッチ関数の1つ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="8e72f01b86fcf7d8b9f975c29c3a1117f8ed8c6a" translate="yes" xml:space="preserve">
          <source>But superclass constraints like these are sometimes useful, and the conservative check is annoying where no actual recursion is involved.</source>
          <target state="translated">しかし、これらのようなスーパークラス制約は時に有用であり、実際の再帰が関与していないところでは、保守的なチェックは迷惑です。</target>
        </trans-unit>
        <trans-unit id="73f40a957f0eafaef43b7412e6b7eae8ca1629e4" translate="yes" xml:space="preserve">
          <source>But suppose we made a slight adjustment to the order of the instance context, putting &lt;code&gt;E a&lt;/code&gt; before &lt;code&gt;D a&lt;/code&gt;:</source>
          <target state="translated">しかし、インスタンスコンテキストの順序を少し調整して、 &lt;code&gt;E a&lt;/code&gt; を &lt;code&gt;D a&lt;/code&gt; の前に配置するとします。</target>
        </trans-unit>
        <trans-unit id="cfea8bf40fe32a0b6ae6eb32e50457a3bbe00861" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">ただし、以下はすべて &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7731812692d70803e0e0e350c8da86a84a0c20be" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">しかし、以下はすべて &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="a8d348a97b3765db0e297f4b99bd3286d0a14a90" translate="yes" xml:space="preserve">
          <source>But the following are all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">しかし、以下はすべて &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="91df2416d261e941ac64542c14e564e449aadd62" translate="yes" xml:space="preserve">
          <source>But the following doesn't terminate:</source>
          <target state="translated">しかし、以下のように終了しません。</target>
        </trans-unit>
        <trans-unit id="7717e46be083515ecb72e392ec90c5060d7fc5a3" translate="yes" xml:space="preserve">
          <source>But the following should fail overall, since the first operation where we attempt to parse &lt;code&gt;'m'&lt;/code&gt; as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; will fail:</source>
          <target state="translated">しかし、 &lt;code&gt;'m'&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; として解析しようとする最初の操作は失敗するため、以下は全体的に失敗するはずです。</target>
        </trans-unit>
        <trans-unit id="1a58bd6d5d0e7ba62e5be7b51f024f151d484faf" translate="yes" xml:space="preserve">
          <source>But the following should fail overall, since the first operation where we attempt to parse &lt;code&gt;'m'&lt;/code&gt; as an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; will fail:</source>
          <target state="translated">しかし、 &lt;code&gt;'m'&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; として解析しようとする最初の操作は失敗するため、以下は全体的に失敗するはずです。</target>
        </trans-unit>
        <trans-unit id="8f2d73619f8d796daeb72fd392f5ed8f12263a1e" translate="yes" xml:space="preserve">
          <source>But there is one exception: free variables mentioned in the outermost kind signature on the right hand side are quantified implicitly. Thus, in the following example the variables &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are all in scope on the right hand side of &lt;code&gt;S&lt;/code&gt;:</source>
          <target state="translated">ただし、例外が1つあります。右側の最も外側の種類の署名に記載されている自由変数は、暗黙的に定量化されます。したがって、次の例では、変数 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;k&lt;/code&gt; はすべて &lt;code&gt;S&lt;/code&gt; の右側のスコープ内にあります。</target>
        </trans-unit>
        <trans-unit id="4ca875b680fdb97fc74f9300d7be351d9a268b49" translate="yes" xml:space="preserve">
          <source>But these are not:</source>
          <target state="translated">しかし、これらはそうではありません。</target>
        </trans-unit>
        <trans-unit id="808cb3b77f5d26da60e12a8c2e267fb2361422db" translate="yes" xml:space="preserve">
          <source>But this instantiation and re-generalisation happens only at the top level of a type. In particular, none of this happens if the foralls are underneath an arrow. For example:</source>
          <target state="translated">しかし、このようなインスタンス化や再一般化は、型のトップレベルでしか起こりません。特に、forallsが矢印の下にある場合は、このようなことは起こりません。例えば</target>
        </trans-unit>
        <trans-unit id="7e7307e0fa3f238675a94c67154f45c09774348d" translate="yes" xml:space="preserve">
          <source>But this is unsound:</source>
          <target state="translated">しかし、これは根拠のないことです。</target>
        </trans-unit>
        <trans-unit id="032c3ace0e924d44f9ac3686950012f6f9c642b4" translate="yes" xml:space="preserve">
          <source>But when pattern matching on &lt;code&gt;Baz1&lt;/code&gt; the matched values can be compared for equality, and when pattern matching on &lt;code&gt;Baz2&lt;/code&gt; the first matched value can be converted to a string (as well as applying the function to it). So this program is legal:</source>
          <target state="translated">ただし、 &lt;code&gt;Baz1&lt;/code&gt; でのパターンマッチングでは、一致した値が等しいかどうかを比較でき、 &lt;code&gt;Baz2&lt;/code&gt; でのパターンマッチングでは、最初に一致した値を文字列に変換できます（それに関数を適用できます）。したがって、このプログラムは合法です：</target>
        </trans-unit>
        <trans-unit id="48b6f05d33c295f64d2c3b6836ca407ebef98238" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;Maybe&amp;rdquo; we mean that the usual heuristic inlining rules apply (if the function body is small, or it is applied to interesting-looking arguments etc). Another way to understand the semantics is this:</source>
          <target state="translated">「たぶん」とは、通常のヒューリスティックインラインルールが適用されることを意味します（関数本体が小さい場合、または興味深い外観の引数に適用される場合など）。セマンティクスを理解する別の方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e5e954f010734bc63857acf7253cb96bcc09c253" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;ambiguous&amp;rdquo; we mean that there is a type variable &lt;code&gt;e&lt;/code&gt; that appears on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, but not on the right. The problem with this is that, according to the theoretical foundations of Haskell overloading, we cannot guarantee a well-defined semantics for any term with an ambiguous type.</source>
          <target state="translated">「あいまい」とは、 &lt;code&gt;=&amp;gt;&lt;/code&gt; 記号の左側にあるが右側にはない型変数 &lt;code&gt;e&lt;/code&gt; があることを意味します。これの問題は、Haskellオーバーロードの理論的根拠によれば、あいまいな型の用語に対して明確に定義されたセマンティクスを保証できないことです。</target>
        </trans-unit>
        <trans-unit id="a9626f1ba2bf1f860641df5bd3f3382835b801df" translate="yes" xml:space="preserve">
          <source>By contrast, &lt;a href=&quot;https://hackage.haskell.org/package/lifted-base&quot;&gt;lifted-base&lt;/a&gt;'s version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; always discards all of &lt;code&gt;g&lt;/code&gt;'s non-IO effects, and &lt;code&gt;g&lt;/code&gt; never sees any of &lt;code&gt;f&lt;/code&gt;'s non-IO effects, regardless of the layer ordering and regardless of whether &lt;code&gt;f&lt;/code&gt; throws an error. This is not the result of interacting effects, but a consequence of &lt;code&gt;MonadBaseControl&lt;/code&gt;'s approach.</source>
          <target state="translated">対照的に、&lt;a href=&quot;https://hackage.haskell.org/package/lifted-base&quot;&gt;lifted-base&lt;/a&gt;のバージョンの &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; は、常に &lt;code&gt;g&lt;/code&gt; の非IO効果をすべて破棄し、レイヤーの順序や &lt;code&gt;f&lt;/code&gt; がエラーをスローするかどうかに関係なく、 &lt;code&gt;g&lt;/code&gt; は &lt;code&gt;f&lt;/code&gt; の非IO効果をまったく認識しません。。これは相互作用する効果の結果ではなく、 &lt;code&gt;MonadBaseControl&lt;/code&gt; のアプローチの結果です。</target>
        </trans-unit>
        <trans-unit id="9f8fa066b62ce9de7834b32b1ffd79abe4903ede" translate="yes" xml:space="preserve">
          <source>By convention, overloaded functions have a non-overloaded counterpart whose name is suffixed with `&lt;code&gt;By&lt;/code&gt;'.</source>
          <target state="translated">慣例により、オーバーロードされた関数には、名前の末尾に「 &lt;code&gt;By&lt;/code&gt; 」が付いた非オーバーロードの対応物があります。</target>
        </trans-unit>
        <trans-unit id="896bbb1ee06a6fe71b9beeaa9d18f1143bc8c3b4" translate="yes" xml:space="preserve">
          <source>By default (when &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; is not specified), GHC exposes only one version of a package, all other versions become hidden. If &lt;code&gt;-package&lt;/code&gt; option is specified multiple times for the same package the last one overrides the previous ones. On the other hand, if &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; is used, GHC allows you to expose multiple versions of a package by using the &lt;code&gt;-package&lt;/code&gt; option multiple times with different versions of the same package.</source>
          <target state="translated">デフォルトでは（&lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; &lt;/a&gt;が指定されていない場合）、GHCはパッケージの1つのバージョンのみを公開し、他のすべてのバージョンは非表示になります。同じパッケージに対して &lt;code&gt;-package&lt;/code&gt; オプションが複数回指定されている場合、最後のパッケージが以前のパッケージをオーバーライドします。一方、&lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; &lt;/a&gt;が使用されている場合、GHCでは、同じパッケージの異なるバージョンで &lt;code&gt;-package&lt;/code&gt; オプションを複数回使用して、パッケージの複数のバージョンを公開できます。</target>
        </trans-unit>
        <trans-unit id="c08f7a94109584e7aa0e6d79a4e77ce07a68fae9" translate="yes" xml:space="preserve">
          <source>By default Ctl-C will generate a &lt;code&gt;SIGINT&lt;/code&gt; signal, causing a &lt;code&gt;UserInterrupt&lt;/code&gt; exception to be sent to the main Haskell thread of your program, which if not specially handled will terminate the program. Normally, this is exactly what is wanted: an orderly shutdown of the program in response to Ctl-C.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;UserInterrupt&lt;/code&gt; -Cは &lt;code&gt;SIGINT&lt;/code&gt; シグナルを生成し、UserInterrupt例外がプログラムのメインHaskellスレッドに送信されるようにします。特別に処理しないと、プログラムが終了します。通常、これはまさに求められていることです。Ctl-Cに応答してプログラムを正常にシャットダウンすることです。</target>
        </trans-unit>
        <trans-unit id="85da6991904e0f3fd3e4bbad20cbc4f4be16d997" translate="yes" xml:space="preserve">
          <source>By default GHC builds applications that open a console window when they start. If you want to build a GUI-only application, with no console window, use the flag &lt;code&gt;-optl-mwindows&lt;/code&gt; in the link step.</source>
          <target state="translated">デフォルトでは、GHCは起動時にコンソールウィンドウを開くアプリケーションをビルドします。コンソールウィンドウなしでGUIのみのアプリケーションを構築する場合は、リンク手順でフラグ &lt;code&gt;-optl-mwindows&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="e8d919b56909f1bc95e959f98255a58354f13898" translate="yes" xml:space="preserve">
          <source>By default GHC will be very quiet about what it is doing, only printing error messages. If you want to see in more detail what&amp;rsquo;s going on behind the scenes, add &lt;a href=&quot;#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; to the command line.</source>
          <target state="translated">デフォルトでは、GHCはそれが何をしているかについて非常に静かで、エラーメッセージを出力するだけです。舞台裏で何が行われているのかを詳しく知りたい場合は、コマンドラインに&lt;a href=&quot;#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;を追加します。</target>
        </trans-unit>
        <trans-unit id="188b3edf5485565e6e6ef6439aa7adfb9f3f40c8" translate="yes" xml:space="preserve">
          <source>By default only type class methods and methods marked &lt;code&gt;INLINABLE&lt;/code&gt; or &lt;code&gt;INLINE&lt;/code&gt; are specialised. This flag will specialise any overloaded function regardless of size if its unfolding is available. This flag is not included in any optimisation level as it can massively increase code size. It can be used in conjunction with &lt;a href=&quot;#ghc-flag--fexpose-all-unfoldings&quot;&gt;&lt;code&gt;-fexpose-all-unfoldings&lt;/code&gt;&lt;/a&gt; if you want to ensure all calls are specialised.</source>
          <target state="translated">デフォルトでは、タイプクラスメソッドと &lt;code&gt;INLINABLE&lt;/code&gt; または &lt;code&gt;INLINE&lt;/code&gt; とマークされたメソッドのみが特殊化されています。このフラグは、展開が可能な場合、サイズに関係なくオーバーロードされた関数を特殊化します。このフラグはコードサイズを大幅に増加させる可能性があるため、どの最適化レベルにも含まれていません。すべての呼び出しを特殊化したい場合は、&lt;a href=&quot;#ghc-flag--fexpose-all-unfoldings&quot;&gt; &lt;code&gt;-fexpose-all-unfoldings&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​できます。</target>
        </trans-unit>
        <trans-unit id="624e8cce7ea7cdb4e472abd23a004063a0206d28" translate="yes" xml:space="preserve">
          <source>By default the valid hole fits are sorted to show the most relevant hole fits at the top of the list of valid hole fits. This can be toggled off with this flag.</source>
          <target state="translated">デフォルトでは、有効なホールフィットはソートされ、最も関連性の高いホールフィットが有効なホールフィットのリストの一番上に表示されます。これは、このフラグでオフに切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="c1764f7c7473b983f83b4e96209c1fd4c0ad4af0" translate="yes" xml:space="preserve">
          <source>By default this module is set up to parse character data. If you'd like to parse the result of your own tokenizer you should start with the following imports:</source>
          <target state="translated">デフォルトでは、このモジュールは文字データをパースするように設定されています。独自のトークナイザーの結果を解析したい場合は、以下のインポートから始めなければなりません。</target>
        </trans-unit>
        <trans-unit id="0ce3ebf665bc95b496362425218966d039437681" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ghc -M&lt;/code&gt; generates all the dependencies, and then concatenates them onto the end of &lt;code&gt;makefile&lt;/code&gt; (or &lt;code&gt;Makefile&lt;/code&gt; if &lt;code&gt;makefile&lt;/code&gt; doesn&amp;rsquo;t exist) bracketed by the lines &amp;ldquo;&lt;code&gt;# DO NOT DELETE: Beginning of Haskell dependencies&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;# DO NOT DELETE: End of Haskell dependencies&lt;/code&gt;&amp;rdquo;. If these lines already exist in the &lt;code&gt;makefile&lt;/code&gt;, then the old dependencies are deleted first.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;ghc -M&lt;/code&gt; すべての依存関係を生成し、その後の最後にそれらを連結して &lt;code&gt;makefile&lt;/code&gt; （または &lt;code&gt;Makefile&lt;/code&gt; の場合は &lt;code&gt;makefile&lt;/code&gt; 存在しない）「の線で囲ま &lt;code&gt;# DO NOT DELETE: Beginning of Haskell dependencies&lt;/code&gt; 」と「 &lt;code&gt;# DO NOT DELETE: End of Haskell dependencies&lt;/code&gt; 」。これらの行が &lt;code&gt;makefile&lt;/code&gt; にすでに存在する場合、古い依存関係が最初に削除されます。</target>
        </trans-unit>
        <trans-unit id="a1836101dccd7400532d625ffcce0904ab5ebfa5" translate="yes" xml:space="preserve">
          <source>By default, GHC (as the Haskell 2010 standard prescribes) parses identifiers starting with an underscore in a type as type variables. To treat them as named wildcards, the &lt;a href=&quot;#extension-NamedWildCards&quot;&gt;&lt;code&gt;NamedWildCards&lt;/code&gt;&lt;/a&gt; extension should be enabled. The example below demonstrated the effect.</source>
          <target state="translated">デフォルトでは、GHCは（Haskell 2010標準で規定されているように）、アンダースコアで始まる型の識別子を型変数として解析します。それらを名前付きワイルドカードとして扱うには、&lt;a href=&quot;#extension-NamedWildCards&quot;&gt; &lt;code&gt;NamedWildCards&lt;/code&gt; &lt;/a&gt;拡張機能を有効にする必要があります。以下の例はその効果を示しています。</target>
        </trans-unit>
        <trans-unit id="375ba54e7f496ec128d1b7ef8611af8553668782" translate="yes" xml:space="preserve">
          <source>By default, GHC ignores Haddock comments (&lt;code&gt;-- | ...&lt;/code&gt; and &lt;code&gt;-- ^ ...&lt;/code&gt;) and does not check that they&amp;rsquo;re associated with a valid term, such as a top-level type-signature. With this flag GHC will parse Haddock comments and include them in the interface file it produces.</source>
          <target state="translated">デフォルトでは、GHCはHaddockコメント（ &lt;code&gt;-- | ...&lt;/code&gt; および &lt;code&gt;-- ^ ...&lt;/code&gt; ）を無視し、それらがトップレベルのタイプ署名などの有効な用語に関連付けられているかどうかをチェックしません。このフラグを使用すると、GHCはHaddockコメントを解析し、生成するインターフェイスファイルに含めます。</target>
        </trans-unit>
        <trans-unit id="5545ec84b6af100d02a17fdcb1293a391503367a" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;a href=&quot;exts/control#extension-Haskell98&quot;&gt;&lt;code&gt;Haskell98&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exts/control#extension-Haskell2010&quot;&gt;&lt;code&gt;Haskell2010&lt;/code&gt;&lt;/a&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">デフォルトでは、GHCは主にあなたが持つ言語の特定のバージョンのように動作しようと、それを伝えることができますが、（主に）Haskellの2010コンパイラのように動作することを目指し&lt;a href=&quot;exts/control#extension-Haskell98&quot;&gt; &lt;code&gt;Haskell98&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;exts/control#extension-Haskell2010&quot;&gt; &lt;code&gt;Haskell2010&lt;/code&gt; &lt;/a&gt;フラグ。標準からの既知の逸脱を以下に説明します。特に明記されていない限り、偏差はHaskell 98、Haskell 2010、およびデフォルトモードに適用されます。</target>
        </trans-unit>
        <trans-unit id="12df8ed1e15edda69c0c572579814ea973c3f99c" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;a href=&quot;glasgow_exts#extension-Haskell98&quot;&gt;&lt;code&gt;Haskell98&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;glasgow_exts#extension-Haskell2010&quot;&gt;&lt;code&gt;Haskell2010&lt;/code&gt;&lt;/a&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">デフォルトでは、GHCは主にあなたが持つ言語の特定のバージョンのように動作しようと、それを伝えることができますが、（主に）Haskellの2010コンパイラのように動作することを目指し&lt;a href=&quot;glasgow_exts#extension-Haskell98&quot;&gt; &lt;code&gt;Haskell98&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;glasgow_exts#extension-Haskell2010&quot;&gt; &lt;code&gt;Haskell2010&lt;/code&gt; &lt;/a&gt;フラグ。標準からの既知の逸脱を以下に説明します。特に明記されていない限り、偏差はHaskell 98、Haskell 2010、およびデフォルトモードに適用されます。</target>
        </trans-unit>
        <trans-unit id="9abdae9b40906f9cfda31d516ba3c096c45e1e1a" translate="yes" xml:space="preserve">
          <source>By default, GHC mainly aims to behave (mostly) like a Haskell 2010 compiler, although you can tell it to try to behave like a particular version of the language with the &lt;code&gt;-XHaskell98&lt;/code&gt; and &lt;code&gt;-XHaskell2010&lt;/code&gt; flags. The known deviations from the standards are described below. Unless otherwise stated, the deviation applies in Haskell 98, Haskell 2010 and the default modes.</source>
          <target state="translated">デフォルトでは、GHCは主にHaskell 2010コンパイラーのように動作することを目的としていますが、 &lt;code&gt;-XHaskell98&lt;/code&gt; および &lt;code&gt;-XHaskell2010&lt;/code&gt; フラグを使用して特定のバージョンの言語のように動作するように指示することもできます。標準からの既知の逸脱を以下に示します。特に明記しない限り、偏差はHaskell 98、Haskell 2010、およびデフォルトのモードに適用されます。</target>
        </trans-unit>
        <trans-unit id="ec779fb59a0c807c306278944368725099b24555" translate="yes" xml:space="preserve">
          <source>By default, GHC will automatically link in the &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages. This flag disables that behaviour.</source>
          <target state="translated">デフォルトでは、GHCは自動的に &lt;code&gt;base&lt;/code&gt; および &lt;code&gt;rts&lt;/code&gt; パッケージにリンクします。このフラグはその動作を無効にします。</target>
        </trans-unit>
        <trans-unit id="df55ad44f83f85e9c4e4f4d6d779d38193eb5c3e" translate="yes" xml:space="preserve">
          <source>By default, GHCi compiles Haskell source code into byte-code that is interpreted by the runtime system. GHCi can also compile Haskell code to object code: to turn on this feature, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; flag either on the command line or with &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (the option &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; restores byte-code compilation again). Compiling to object code takes longer, but typically the code will execute 10-20 times faster than byte-code.</source>
          <target state="translated">デフォルトでは、GHCiはHaskellのソースコードを、ランタイムシステムによって解釈されるバイトコードにコンパイルします。GHCiはHaskellコードをオブジェクトコードにコンパイルすることもできます。この機能をオンにするには、コマンドラインまたは&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; で&lt;/a&gt;&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;フラグを使用します（オプション&lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt;はバイトコードコンパイルを再び復元します）。オブジェクトコードへのコンパイルには時間がかかりますが、通常、コードはバイトコードよりも10〜20倍速く実行されます。</target>
        </trans-unit>
        <trans-unit id="5e88504b814b1fec26bf7b42a2f12aaadb66f2cc" translate="yes" xml:space="preserve">
          <source>By default, GHCi keeps global history in &lt;code&gt;~/.ghc/ghci_history&lt;/code&gt; or &lt;code&gt;%APPDATA%/&amp;lt;app&amp;gt;/ghci_history&lt;/code&gt;, but you can use current directory, e.g.:</source>
          <target state="translated">デフォルトでは、GHCiはグローバル履歴を &lt;code&gt;~/.ghc/ghci_history&lt;/code&gt; または &lt;code&gt;%APPDATA%/&amp;lt;app&amp;gt;/ghci_history&lt;/code&gt; に保持しますが、現在のディレクトリを使用できます。例：</target>
        </trans-unit>
        <trans-unit id="fdbafe643d46838671b1a066fee2f9329338669e" translate="yes" xml:space="preserve">
          <source>By default, all exposed packages in the normal, source import namespace are also available for plugins. This causes those packages to be hidden by default. If you use this flag, then any packages with plugins you require need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">デフォルトでは、通常のソースインポート名前空間で公開されているすべてのパッケージもプラグインで使用できます。これにより、これらのパッケージはデフォルトで非表示になります。このフラグを使用する場合、必要なプラグインを含むパッケージは、&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;オプションを使用して明示的に公開する必要があります。</target>
        </trans-unit>
        <trans-unit id="82625d74a09e8d4b74d07dfbe3c657128326ccf1" translate="yes" xml:space="preserve">
          <source>By default, all fields in algebraic data types are linear (even if &lt;code&gt;-XLinearTypes&lt;/code&gt; is not turned on). Given</source>
          <target state="translated">デフォルトでは、代数的データ型のすべてのフィールドは線形です（ &lt;code&gt;-XLinearTypes&lt;/code&gt; がオンになっていない場合でも）。与えられた</target>
        </trans-unit>
        <trans-unit id="46539ad051a890125fb96d050b762a5dd85eaf9d" translate="yes" xml:space="preserve">
          <source>By default, all of the capabilities participate in parallel garbage collection. If we want to use a very large &lt;code&gt;-N&lt;/code&gt; value, however, this can reduce the performance of the GC. For this reason, the &lt;code&gt;-qn&lt;/code&gt; flag can be used to specify a lower number for the threads that should participate in GC. During GC, if there are more than this number of workers active, some of them will sleep for the duration of the GC.</source>
          <target state="translated">デフォルトでは、すべての機能が並列ガベージコレクションに参加します。ただし、非常に大きな &lt;code&gt;-N&lt;/code&gt; 値を使用する場合は、GCのパフォーマンスが低下する可能性があります。このため、 &lt;code&gt;-qn&lt;/code&gt; フラグを使用して、GCに参加する必要のあるスレッドの数を小さくすることができます。GCの実行中に、アクティブなワーカーの数がこの数を超える場合、一部のワーカーはGCの期間中スリープします。</target>
        </trans-unit>
        <trans-unit id="dff65f59491f27c9a1b1f59bb08671c0847e3677" translate="yes" xml:space="preserve">
          <source>By default, each hole fit shows the provenance information of its hole fit, i.e. where it was bound or defined, and what module it was originally defined in if it was imported. This can be toggled off using the reverse of this flag.</source>
          <target state="translated">デフ ォル ト では、 各ホールはめ込みは、そのホールはめ込みの実績情報、すなわち、どこでバインドされたか定義されたか、インポートされた場合には元々どのモジュールで定義されたかを表示します。こ れは、 こ の フ ラ グの逆を用いて無効にす る こ と がで き ます。</target>
        </trans-unit>
        <trans-unit id="40b07e5a3f0d5d2adc75edc52198eb4a7127369d" translate="yes" xml:space="preserve">
          <source>By default, if idle GC is enabled in the threaded runtime, a major GC will be performed every time the process goes idle for a sufficiently long duration (see &lt;a href=&quot;#rts-flag--I%20%E2%9F%A8seconds%E2%9F%A9&quot;&gt;&lt;code&gt;-I ⟨seconds⟩&lt;/code&gt;&lt;/a&gt;). For large server processes accepting regular but infrequent requests (e.g., once per second), an expensive, major GC may run after every request. As an alternative to shutting off idle GC entirely (with &lt;code&gt;-I0&lt;/code&gt;), a minimum wait time between idle GCs can be specified with this flag. For example, &lt;code&gt;-Iw60&lt;/code&gt; will ensure that an idle GC runs at most once per minute.</source>
          <target state="translated">デフォルトでは、スレッドランタイムでアイドルGCが有効になっている場合、プロセスが十分に長い時間アイドル状態になるたびにメジャーGCが実行されます（&lt;a href=&quot;#rts-flag--I%20%E2%9F%A8seconds%E2%9F%A9&quot;&gt; &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; &lt;/a&gt;参照）。定期的ではあるがまれな要求（たとえば、1秒に1回）を受け入れる大規模なサーバープロセスの場合、すべての要求の後に高価なメジャーGCが実行されることがあります。アイドル状態のGCを完全にシャットオフする代わりに（ &lt;code&gt;-I0&lt;/code&gt; を使用）、アイドル状態のGC間の最小待機時間をこのフラグで指定できます。たとえば、 &lt;code&gt;-Iw60&lt;/code&gt; は、アイドル状態のGCが最大で1分に1回実行されることを保証します。</target>
        </trans-unit>
        <trans-unit id="00e1d7b164983ad889522ed53190607d61c4610f" translate="yes" xml:space="preserve">
          <source>By default, modules compiled with plugins are always recompiled even if the source file is unchanged. This most conservative option is taken due to the ability of plugins to perform arbitrary IO actions. In order to control the recompilation behaviour you can modify the &lt;code&gt;pluginRecompile&lt;/code&gt; field in &lt;code&gt;Plugin&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、プラグインでコンパイルされたモジュールは、ソースファイルが変更されていなくても、常に再コンパイルされます。この最も保守的なオプションは、任意のIOアクションを実行するプラグインの機能により採用されています。再コンパイルの動作を制御するために、 &lt;code&gt;Plugin&lt;/code&gt; の &lt;code&gt;pluginRecompile&lt;/code&gt; フィールドを変更できます。</target>
        </trans-unit>
        <trans-unit id="eb82d4dffabcd57e78239ea2df207ce6d76727da" translate="yes" xml:space="preserve">
          <source>By default, the compiler will warn you if a set of patterns are overlapping, e.g.,</source>
          <target state="translated">デフォルトでは、コンパイラは一連のパターンが重複している場合に警告を出します。</target>
        </trans-unit>
        <trans-unit id="069c263ac2190411cc9526082fc8f4fd76502131" translate="yes" xml:space="preserve">
          <source>By default, the compiler will warn you if types make a branch inaccessible. This generally requires GADTs or similar extensions.</source>
          <target state="translated">デフォルトでは、タイプによってブランチにアクセスできない場合、コンパイラは警告を発します。これには一般的に GADT などの拡張機能が必要です。</target>
        </trans-unit>
        <trans-unit id="42ececaa43e2537fc3e254dd2078e6ca5e31deaf" translate="yes" xml:space="preserve">
          <source>By default, the entry points of all the object files will be exported from the DLL when using &lt;code&gt;-shared&lt;/code&gt;. Should you want to constrain this, you can specify the &lt;em&gt;module definition file&lt;/em&gt; to use on the command line as follows:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;-shared&lt;/code&gt; を使用すると、すべてのオブジェクトファイルのエントリポイントがDLLからエクスポートされます。これを制限したい場合は、次のようにコマンドラインで使用する&lt;em&gt;モジュール定義ファイル&lt;/em&gt;を指定できます。</target>
        </trans-unit>
        <trans-unit id="8cda497389193e1649e303cab4fabec282743541" translate="yes" xml:space="preserve">
          <source>By default, the flag will cause a warning to be emitted to stderr when the sync time exceeds the specified time. This behaviour can be overridden, however: the &lt;code&gt;longGCSync()&lt;/code&gt; hook is called when the sync time is exceeded during the sync period, and the &lt;code&gt;longGCSyncEnd()&lt;/code&gt; hook at the end. Both of these hooks can be overridden in the &lt;code&gt;RtsConfig&lt;/code&gt; when the runtime is started with &lt;code&gt;hs_init_ghc()&lt;/code&gt;. The default implementations of these hooks (&lt;code&gt;LongGcSync()&lt;/code&gt; and &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; respectively) print warnings to stderr.</source>
          <target state="translated">デフォルトでは、同期時間が指定された時間を超えると、フラグによってstderrに警告が発行されます。 ：この動作はしかし、上書きすることができます &lt;code&gt;longGCSync()&lt;/code&gt; の同期時刻が同期期間中に超過したときフックが呼び出され、そして &lt;code&gt;longGCSyncEnd()&lt;/code&gt; 最後にフック。ランタイムが &lt;code&gt;hs_init_ghc()&lt;/code&gt; で開始されると、これらのフックは両方とも &lt;code&gt;RtsConfig&lt;/code&gt; でオーバーライドできます。これらのフックのデフォルトの実装 &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; それぞれ &lt;code&gt;LongGcSync()&lt;/code&gt; とLongGCSyncEnd（））は、stderrに警告を出力します。</target>
        </trans-unit>
        <trans-unit id="9fe9a2f0fe153f620abcfa8682464add226d1fdb" translate="yes" xml:space="preserve">
          <source>By default, the flag will cause a warning to be emitted to stderr when the sync time exceeds the specified time. This behaviour can be overriden, however: the &lt;code&gt;longGCSync()&lt;/code&gt; hook is called when the sync time is exceeded during the sync period, and the &lt;code&gt;longGCSyncEnd()&lt;/code&gt; hook at the end. Both of these hooks can be overriden in the &lt;code&gt;RtsConfig&lt;/code&gt; when the runtime is started with &lt;code&gt;hs_init_ghc()&lt;/code&gt;. The default implementations of these hooks (&lt;code&gt;LongGcSync()&lt;/code&gt; and &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; respectively) print warnings to stderr.</source>
          <target state="translated">デフォルトでは、このフラグにより​​、同期時間が指定された時間を超えたときにstderrに警告が発行されます。 ：この動作はしかし、上書きすることができ &lt;code&gt;longGCSync()&lt;/code&gt; の同期時刻が同期期間中に超過したときフックが呼び出され、そして &lt;code&gt;longGCSyncEnd()&lt;/code&gt; 最後にフック。これらのフックはどちらも、ランタイムが &lt;code&gt;hs_init_ghc()&lt;/code&gt; で開始されたときに &lt;code&gt;RtsConfig&lt;/code&gt; でオーバーライドできます。これらのフックのデフォルト実装 &lt;code&gt;LongGCSyncEnd()&lt;/code&gt; それぞれ &lt;code&gt;LongGcSync()&lt;/code&gt; およびLongGCSyncEnd（））は、警告をstderrに出力します。</target>
        </trans-unit>
        <trans-unit id="7ddee701400360fbf24135d74284e1d2f92e56f8" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt;, &lt;code&gt;mempty :: Monoid a =&amp;gt; a&lt;/code&gt; is a hole fit with &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt;. This flag toggles whether to show &lt;code&gt;a ~ (Int -&amp;gt; [Int])&lt;/code&gt; instead of &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; in the where clause of the valid hole fit message.</source>
          <target state="translated">デフォルトでは、穴あけは、この穴 &lt;code&gt;mempty :: Monoid a =&amp;gt; a&lt;/code&gt; 穴のタイプに合わせるために必要なタイプアプリケーションを示します。たとえば、穴 &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt; Int- &amp;gt; [Int]）、mempty ::モノイドa =&amp;gt; aは穴です &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; 適合します。このフラグは、有効なホールフィットメッセージのwhere句に、 &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; &lt;code&gt;a ~ (Int -&amp;gt; [Int])&lt;/code&gt; ではなく〜（Int- &amp;gt; [Int]）を表示するかどうかを切り替えます。</target>
        </trans-unit>
        <trans-unit id="d54e2c2c7ff09cca548a7181b38ba4eb543ff3ab" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt;, &lt;code&gt;mempty&lt;/code&gt; is a hole fit with &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt;. This can be toggled off with the reverse of this flag.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;mempty&lt;/code&gt; は、この穴あてを穴のタイプに合わせるために必要なタイプアプリケーションを示します。たとえば、穴 &lt;code&gt;(_ :: Int -&amp;gt; [Int])&lt;/code&gt; Int- &amp;gt; [Int]）の場合、memptyは &lt;code&gt;mempty @(Int -&amp;gt; [Int])&lt;/code&gt; 。これは、このフラグの逆でオフに切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="35d5a2ec055ae5d603afdd7b0fe5afae1fc6be21" translate="yes" xml:space="preserve">
          <source>By default, the hole fits show the type of the hole fit. This can be turned off by the reverse of this flag.</source>
          <target state="translated">デフォルトでは、ホールフィットの種類が表示されます。これは、このフラグを逆にすることでオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="98a6c6abf4876ada1cf384346f6c09b294c533e7" translate="yes" xml:space="preserve">
          <source>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the &lt;a href=&quot;../using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt;&lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">デフォルトでは、タイプチェッカーは部分的なタイプシグニチャの各ホールのエラーメッセージを報告し、推測されたタイプをプログラマに通知します。場合&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; の&lt;/a&gt;拡張が有効になっている、タイプチェッカー代わりにエラーの警告を生成し、各穴のための推論型を受け入れます。さらに、これらの警告は、&lt;a href=&quot;../using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt; &lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt; &lt;/a&gt;フラグを使用して消音することができます。</target>
        </trans-unit>
        <trans-unit id="5f832c954f21105383f315f5795a3f1e4b92e9c8" translate="yes" xml:space="preserve">
          <source>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the &lt;a href=&quot;using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt;&lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">デフォルトでは、タイプチェッカーは部分的な型シグネチャの各ホールについてエラーメッセージを報告し、推定された型をプログラマに通知します。場合&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; の&lt;/a&gt;拡張が有効になっている、タイプチェッカー代わりにエラーの警告を生成し、各穴のための推論型を受け入れます。さらに、これらの警告は、&lt;a href=&quot;using-warnings#ghc-flag--Wpartial-type-signatures&quot;&gt; &lt;code&gt;-Wno-partial-type-signatures&lt;/code&gt; &lt;/a&gt;フラグを使用して非表示にすることができます。</target>
        </trans-unit>
        <trans-unit id="73c75d191039b62d5631ea3a5a9bfa7631f5b38e" translate="yes" xml:space="preserve">
          <source>By default, this means that everything from the module &lt;code&gt;Prelude&lt;/code&gt; is currently in scope. Should the prompt be set to &lt;code&gt;%s&amp;gt;&lt;/code&gt; in the &lt;code&gt;.ghci&lt;/code&gt; configuration file, we would be seeing &lt;code&gt;Prelude&amp;gt;&lt;/code&gt; displayed. However, it is not the default mechanism due to the large space the prompt can take if more imports are done.</source>
          <target state="translated">デフォルトでは、これはモジュール &lt;code&gt;Prelude&lt;/code&gt; のすべてが現在スコープ内にあることを意味します。 &lt;code&gt;.ghci&lt;/code&gt; 構成ファイルでプロンプトが &lt;code&gt;%s&amp;gt;&lt;/code&gt; に設定されている場合、 &lt;code&gt;Prelude&amp;gt;&lt;/code&gt; 表示されます。ただし、さらにインポートが行われるとプロンプトが取ることができるスペースが大きいため、これはデフォルトのメカニズムではありません。</target>
        </trans-unit>
        <trans-unit id="bbc06aef5e5a39593988fb4a13a30427cfe33d3b" translate="yes" xml:space="preserve">
          <source>By default, when a module is compiled with plugins, it will be marked as unsafe. With this flag passed, all plugins are treated as trustworthy and the safety inference will no longer be affected.</source>
          <target state="translated">デフォルトでは、モジュールがプラグインでコンパイルされると、安全でないとマークされます。このフラグが渡されると、すべてのプラグインが信頼できるものとして扱われ、安全性の推論に影響を与えなくなります。</target>
        </trans-unit>
        <trans-unit id="174e61791c2af8c07db7989b5f30fdc0a9f3888b" translate="yes" xml:space="preserve">
          <source>By default, you get a standard set of warnings which are generally likely to indicate bugs in your program. These are:</source>
          <target state="translated">デフォルトでは、一般的にプログラムのバグを示す可能性の高い警告の標準セットを取得します。これらは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="46283cfe9b92cf9ced3d37e5a425538fb2879a38" translate="yes" xml:space="preserve">
          <source>By feeding the ghc compiler driver the option &lt;code&gt;-shared&lt;/code&gt;, it will build a DLL rather than produce an executable. The DLL will consist of all the object files and archives given on the command line.</source>
          <target state="translated">ghcコンパイラー・ドライバーにオプション &lt;code&gt;-shared&lt;/code&gt; を与えることにより、実行可能ファイルを生成するのではなくDLLを構築します。DLLは、コマンドラインで指定されたすべてのオブジェクトファイルとアーカイブで構成されます。</target>
        </trans-unit>
        <trans-unit id="8504674d3abb04bdd53121c5e1c8cc5547351f38" translate="yes" xml:space="preserve">
          <source>By including dependencies in a class declaration, we provide a mechanism for the programmer to specify each multiple parameter class more precisely. The compiler, on the other hand, is responsible for ensuring that the set of instances that are in scope at any given point in the program is consistent with any declared dependencies. For example, the following pair of instance declarations cannot appear together in the same scope because they violate the dependency for &lt;code&gt;D&lt;/code&gt;, even though either one on its own would be acceptable:</source>
          <target state="translated">クラス宣言に依存関係を含めることにより、プログラマーが各複数のパラメータークラスをより正確に指定するためのメカニズムを提供します。一方、コンパイラーは、プログラムの任意の時点でスコープ内にあるインスタンスのセットが、宣言された依存関係と整合していることを確認する責任があります。たとえば、次のインスタンス宣言のペアは、 &lt;code&gt;D&lt;/code&gt; の依存関係に違反しているため、同じスコープ内に一緒に表示できません。どちらか一方だけでも許容されます。</target>
        </trans-unit>
        <trans-unit id="a31672cadecf688e7c40679abceb4f7169dc8697" translate="yes" xml:space="preserve">
          <source>By inspecting the example &lt;code&gt;plugin&lt;/code&gt; defined above, we can see that it is pure. This means that if the two modules have the same fingerprint then the plugin will always return the same result. Declaring a plugin as pure means that the plugin will never cause a module to be recompiled.</source>
          <target state="translated">上記で定義したサンプル &lt;code&gt;plugin&lt;/code&gt; を調べると、純粋であることを確認できます。つまり、2つのモジュールのフィンガープリントが同じ場合、プラグインは常に同じ結果を返します。プラグインを純粋として宣言すると、プラグインによってモジュールが再コンパイルされることはありません。</target>
        </trans-unit>
        <trans-unit id="85fd7daebedfdd6804e24888c9b0949a47ff5308" translate="yes" xml:space="preserve">
          <source>By making this a member of the class, idempotent semigroups and monoids can upgrade this to execute in O(1) by picking &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;stimes =
 &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">これをクラスのメンバーにすることにより、べき等半グループとモノイドは、それぞれ &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; することにより、O（1）で実行するようにこれをアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="280d0ae1e53ec0807b301a1828edbb266fb95f7c" translate="yes" xml:space="preserve">
          <source>By making this a member of the class, idempotent semigroups and monoids can upgrade this to execute in \(\mathcal{O}(1)\) by picking &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;stimes =
 &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">これをクラスのメンバーにすることで、べき等の半群とモノイドは、 &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotent&quot;&gt;stimesIdempotent&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;stimes = &lt;a href=&quot;data-semigroup#v:stimesIdempotentMonoid&quot;&gt;stimesIdempotentMonoid&lt;/a&gt;&lt;/code&gt; それぞれ選択することにより、これをアップグレードして\（\ mathcal {O}（1）\）で実行できます。</target>
        </trans-unit>
        <trans-unit id="60b0706ea95c7ca522f1b094a7d6011fac8bf09b" translate="yes" xml:space="preserve">
          <source>By overriding the &lt;code&gt;renamedResultAction&lt;/code&gt; field we can modify each &lt;code&gt;HsGroup&lt;/code&gt; after it has been renamed. A source file is separated into groups depending on the location of template haskell splices so the contents of these groups may not be intuitive. In order to save the entire renamed AST for inspection at the end of typechecking you can set &lt;code&gt;renamedResultAction&lt;/code&gt; to &lt;code&gt;keepRenamedSource&lt;/code&gt; which is provided by the &lt;code&gt;Plugins&lt;/code&gt; module. This is important because some parts of the renamed syntax tree (for example, imports) are not found in the typechecked one.</source>
          <target state="translated">&lt;code&gt;renamedResultAction&lt;/code&gt; フィールドをオーバーライドすることにより、名前が変更された後に各 &lt;code&gt;HsGroup&lt;/code&gt; を変更できます。ソースファイルは、テンプレートのhaskellスプライスの場所に応じてグループに分けられるため、これらのグループの内容は直感的でない場合があります。あなたが設定できる型チェックの終了時に検査のための全体の名前を変更したASTを節約するために &lt;code&gt;renamedResultAction&lt;/code&gt; に &lt;code&gt;keepRenamedSource&lt;/code&gt; によって提供される &lt;code&gt;Plugins&lt;/code&gt; モジュールを。名前が変更された構文ツリーの一部（インポートなど）がタイプチェック済みの構文ツリーに見つからないため、これは重要です。</target>
        </trans-unit>
        <trans-unit id="96c953756e6001b89332797e663898838e62a7c0" translate="yes" xml:space="preserve">
          <source>By replacing &lt;code&gt;Str.hs&lt;/code&gt; with a signature &lt;code&gt;Str.hsig&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; (and any other modules in this package) are now parametrized by a string implementation:</source>
          <target state="translated">&lt;code&gt;Str.hs&lt;/code&gt; を署名 &lt;code&gt;Str.hsig&lt;/code&gt; に置き換えることにより、 &lt;code&gt;A&lt;/code&gt; （およびこのパッケージ内の他のモジュール）は文字列実装によってパラメーター化されます。</target>
        </trans-unit>
        <trans-unit id="4177c241d143fa0a5ca33741ceb19186757ef74e" translate="yes" xml:space="preserve">
          <source>By using qualified names, one can set breakpoints on all functions (top-level and nested) in every loaded and interpreted module:</source>
          <target state="translated">修飾された名前を使うことで、ロードされ解釈されたすべてのモジュールのすべての関数(トップレベルとネスト)にブレークポイントを設定することができます。</target>
        </trans-unit>
        <trans-unit id="bd2c213b8e4781cce6dcf36530ac2526d2c7bb34" translate="yes" xml:space="preserve">
          <source>By using them, you are telling GHC that you are willing to suffer longer compilation times for better-quality code.</source>
          <target state="translated">それらを使用することで、より良い品質のコードのために、より長いコンパイル時間に苦しむことを望んでいることをGHCに伝えているのです。</target>
        </trans-unit>
        <trans-unit id="fc6baee463471fde1ecec97642f1d1ca74590180" translate="yes" xml:space="preserve">
          <source>Byte ordering.</source>
          <target state="translated">バイト注文。</target>
        </trans-unit>
        <trans-unit id="a2e0dbd8b1ab09bde4319780f72a4d81435a048c" translate="yes" xml:space="preserve">
          <source>Byte swapping</source>
          <target state="translated">バイト交換</target>
        </trans-unit>
        <trans-unit id="67ce106b074a2dd010e2ed6cebb15426f65787d3" translate="yes" xml:space="preserve">
          <source>ByteArray#</source>
          <target state="translated">ByteArray#</target>
        </trans-unit>
        <trans-unit id="b2ba0861bb06ea1a63c71749689a7beb9ea6b729" translate="yes" xml:space="preserve">
          <source>ByteCount</source>
          <target state="translated">ByteCount</target>
        </trans-unit>
        <trans-unit id="53bc4f0faf53dfa905efcd2b3b1d6b5236b29f9b" translate="yes" xml:space="preserve">
          <source>ByteOffset</source>
          <target state="translated">ByteOffset</target>
        </trans-unit>
        <trans-unit id="8a45cdc61d443f1d99e6a8e08a1a5cac63e13810" translate="yes" xml:space="preserve">
          <source>ByteOrder</source>
          <target state="translated">ByteOrder</target>
        </trans-unit>
        <trans-unit id="c237250b1379824c1dbf827faf23519fe09b6f29" translate="yes" xml:space="preserve">
          <source>ByteString</source>
          <target state="translated">ByteString</target>
        </trans-unit>
        <trans-unit id="f4fdba4ce7955a359ebc54c3d8b75dced1a5bcb3" translate="yes" xml:space="preserve">
          <source>ByteString I/O uses binary mode, without any character decoding or newline conversion. The fact that it does not respect the Handle newline mode is considered a flaw and may be changed in a future version.</source>
          <target state="translated">ByteString I/O はバイナリモードを使用し、文字のデコードや改行変換は一切行いません。Handle改行モードを尊重しないという事実は欠陥とみなされ、将来のバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="141ecf8c9b6b748576d6f030e689b5ac01081c26" translate="yes" xml:space="preserve">
          <source>ByteStrings</source>
          <target state="translated">ByteStrings</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="f8cd96f16d9102cf1ed4d9be9ee1b34e6dca04ee" translate="yes" xml:space="preserve">
          <source>C compiler (opt.)</source>
          <target state="translated">Cコンパイラ</target>
        </trans-unit>
        <trans-unit id="f4f28ebdbc8eb0a109bc7de54e138a24cbdfbe50" translate="yes" xml:space="preserve">
          <source>C file</source>
          <target state="translated">シーファイル</target>
        </trans-unit>
        <trans-unit id="8db42ba5780c0869ea2cc63ca7f695f38e31b373" translate="yes" xml:space="preserve">
          <source>C functions are normally declared using prototypes in a C header file. Earlier versions of GHC (6.8.3 and earlier) &lt;code&gt;#include&lt;/code&gt;d the header file in the C source file generated from the Haskell code, and the C compiler could therefore check that the C function being called via the FFI was being called at the right type.</source>
          <target state="translated">C関数は通常、Cヘッダーファイルのプロトタイプを使用して宣言されます。GHCの以前のバージョン（6.8.3以前） &lt;code&gt;#include&lt;/code&gt; d Haskellコードから生成されたCソースファイルにヘッダーファイルが含まれているため、CコンパイラはFFI経由で呼び出されているC関数が右側で呼び出されていることを確認できましたタイプ。</target>
        </trans-unit>
        <trans-unit id="f30e8dc9993cbcb352b6de3b6f306c76123830fc" translate="yes" xml:space="preserve">
          <source>C header</source>
          <target state="translated">Cヘッダ</target>
        </trans-unit>
        <trans-unit id="e0a32b6cde92a02c4d0079b04d003ea26b8c8425" translate="yes" xml:space="preserve">
          <source>C pre-processor (opt.)</source>
          <target state="translated">Cプリプロセッサ</target>
        </trans-unit>
        <trans-unit id="05da97e8f671dc8e81bb497ab7d0b559bb48f35f" translate="yes" xml:space="preserve">
          <source>C strings</source>
          <target state="translated">Cストリングス</target>
        </trans-unit>
        <trans-unit id="a19e3f51c16c6cf9751d0517111b9e9046598db1" translate="yes" xml:space="preserve">
          <source>C strings with a configurable encoding</source>
          <target state="translated">設定可能なエンコーディングを持つ C 文字列</target>
        </trans-unit>
        <trans-unit id="2a2bdbc5a70792af2d724997593731718b21fae4" translate="yes" xml:space="preserve">
          <source>C wide strings</source>
          <target state="translated">C幅弦</target>
        </trans-unit>
        <trans-unit id="9389a51d4da82d4389a58627b6e1618412013bd7" translate="yes" xml:space="preserve">
          <source>C&amp;rsquo;s command-line flags say to trust &lt;code&gt;P&lt;/code&gt; regardless of what is recorded in the package database.</source>
          <target state="translated">Cのコマンドラインフラグは、パッケージデータベースに何が記録されているかに関係なく、 &lt;code&gt;P&lt;/code&gt; を信頼することを示しています。</target>
        </trans-unit>
        <trans-unit id="be8c54d411949b31b40add83f394cd96144642ba" translate="yes" xml:space="preserve">
          <source>C&amp;rsquo;s package database records that &lt;code&gt;P&lt;/code&gt; is trusted (and no command-line arguments override this)</source>
          <target state="translated">Cのパッケージデータベースは、 &lt;code&gt;P&lt;/code&gt; が信頼されていることを記録します（これをオーバーライドするコマンドライン引数はありません）</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2db6df68dc5acc80ecf8fc1e995baa397dbbfd10" translate="yes" xml:space="preserve">
          <source>C-- representation</source>
          <target state="translated">C--表現</target>
        </trans-unit>
        <trans-unit id="4c91c2588a480fcaf1c89f77c993a5b28cde7c85" translate="yes" xml:space="preserve">
          <source>C-\- pass sanity checking</source>
          <target state="translated">C-pass sanity checking</target>
        </trans-unit>
        <trans-unit id="53224a3fe23d089d17e25bc63ef74d76f7140e70" translate="yes" xml:space="preserve">
          <source>C-\- representation</source>
          <target state="translated">C-表現</target>
        </trans-unit>
        <trans-unit id="31a8186414085b899b97c056b647bb5d6f3812d1" translate="yes" xml:space="preserve">
          <source>C-specific Marshalling support: Handling of C &quot;errno&quot; error codes.</source>
          <target state="translated">C 固有のマーシャルのサポート。C の &quot;errno&quot; エラーコードの取り扱い。</target>
        </trans-unit>
        <trans-unit id="28c27031fe7162d732a1c2e209a40bbfcb5fef90" translate="yes" xml:space="preserve">
          <source>C1</source>
          <target state="translated">C1</target>
        </trans-unit>
        <trans-unit id="6c0a03c4460fb3c0c00906dce789ea44d2c84225" translate="yes" xml:space="preserve">
          <source>CAF representing the value &lt;code&gt;0 :: BigNat&lt;/code&gt;</source>
          <target state="translated">値 &lt;code&gt;0 :: BigNat&lt;/code&gt; 表すCAF :: BigNat</target>
        </trans-unit>
        <trans-unit id="5d21200844f499d2358206dede07cd8324f4fd8d" translate="yes" xml:space="preserve">
          <source>CAF representing the value &lt;code&gt;1 :: BigNat&lt;/code&gt;</source>
          <target state="translated">値 &lt;code&gt;1 :: BigNat&lt;/code&gt; 表すCAF :: BigNat</target>
        </trans-unit>
        <trans-unit id="3398da44f9b46eb47c2133df1dbc8f8ae4577ac5" translate="yes" xml:space="preserve">
          <source>CApi</source>
          <target state="translated">CApi</target>
        </trans-unit>
        <trans-unit id="121fd037efff290f65a5321e272862e0f357c01b" translate="yes" xml:space="preserve">
          <source>CApiFFI</source>
          <target state="translated">CApiFFI</target>
        </trans-unit>
        <trans-unit id="14db2db50b91a19fe259904927c84450dabfbabc" translate="yes" xml:space="preserve">
          <source>CBlkCnt</source>
          <target state="translated">CBlkCnt</target>
        </trans-unit>
        <trans-unit id="d700620d461bc690688d590b78ff1f6451076bc9" translate="yes" xml:space="preserve">
          <source>CBlkSize</source>
          <target state="translated">CBlkSize</target>
        </trans-unit>
        <trans-unit id="b7c2df6676202033e6f4b96ba59aff64b6a29f29" translate="yes" xml:space="preserve">
          <source>CBool</source>
          <target state="translated">CBool</target>
        </trans-unit>
        <trans-unit id="c5a976de7b5231fa616fbeac8a2d2805c1e84ee2" translate="yes" xml:space="preserve">
          <source>CC</source>
          <target state="translated">CC</target>
        </trans-unit>
        <trans-unit id="893cefd4dd78167c7a5a4ac0d06beb7f83dd928c" translate="yes" xml:space="preserve">
          <source>CCFlags</source>
          <target state="translated">CCFlags</target>
        </trans-unit>
        <trans-unit id="6042f4ccd2b35f8dec9caec98fc66b65acdc25f3" translate="yes" xml:space="preserve">
          <source>CCall</source>
          <target state="translated">CCall</target>
        </trans-unit>
        <trans-unit id="66f04a168f55eebf1080c6abb4c6b95b7048c658" translate="yes" xml:space="preserve">
          <source>CCc</source>
          <target state="translated">CCc</target>
        </trans-unit>
        <trans-unit id="0eaec9bae149e37a5ce9a0a7cb18d3a0521a4365" translate="yes" xml:space="preserve">
          <source>CChar</source>
          <target state="translated">CChar</target>
        </trans-unit>
        <trans-unit id="b922d01dfb7fbf4c7d572d9c0a302d24875c9465" translate="yes" xml:space="preserve">
          <source>CClock</source>
          <target state="translated">CClock</target>
        </trans-unit>
        <trans-unit id="00ffad0ad9d13dcd921b4ce8556a4127a2a6d9dd" translate="yes" xml:space="preserve">
          <source>CClockId</source>
          <target state="translated">CClockId</target>
        </trans-unit>
        <trans-unit id="058ca29cc6039cd32a619c31a884582dd9b365d7" translate="yes" xml:space="preserve">
          <source>CDev</source>
          <target state="translated">CDev</target>
        </trans-unit>
        <trans-unit id="a33f47bafc89a737517d547138493e904caede4a" translate="yes" xml:space="preserve">
          <source>CDouble</source>
          <target state="translated">CDouble</target>
        </trans-unit>
        <trans-unit id="a13df1b410bce84da0245d90f1b68f47e714bb5d" translate="yes" xml:space="preserve">
          <source>CFile</source>
          <target state="translated">CFile</target>
        </trans-unit>
        <trans-unit id="7207a00980deab52aac4c426e769595a330ba71f" translate="yes" xml:space="preserve">
          <source>CFloat</source>
          <target state="translated">CFloat</target>
        </trans-unit>
        <trans-unit id="f87722cf9f18251ddb2f5f220f7d782de8cb027d" translate="yes" xml:space="preserve">
          <source>CFpos</source>
          <target state="translated">CFpos</target>
        </trans-unit>
        <trans-unit id="3245250fcffb641fa52b5fc6b60ab78d806ce5a2" translate="yes" xml:space="preserve">
          <source>CFsBlkCnt</source>
          <target state="translated">CFsBlkCnt</target>
        </trans-unit>
        <trans-unit id="668bc46de7dfe8a5a87b82b4a14b2a9b3c2c4f39" translate="yes" xml:space="preserve">
          <source>CFsFilCnt</source>
          <target state="translated">CFsFilCnt</target>
        </trans-unit>
        <trans-unit id="9008ca0ab2fa0b88a1f9335f80a8e41eaf69719f" translate="yes" xml:space="preserve">
          <source>CGid</source>
          <target state="translated">CGid</target>
        </trans-unit>
        <trans-unit id="976337a037dec864a10c701cda46660bf59430a9" translate="yes" xml:space="preserve">
          <source>CHANGEATTRS</source>
          <target state="translated">CHANGEATTRS</target>
        </trans-unit>
        <trans-unit id="9573cfe4003d4063018bfabe8baccabc5dec5643" translate="yes" xml:space="preserve">
          <source>CHANGEATTRS is a more expressive alternative to ADDATTRS</source>
          <target state="translated">CHANGEATTRSはADDATTRSよりも表現力の高い代替品です。</target>
        </trans-unit>
        <trans-unit id="4ddd94dd247fbf76059144dff88c2354f6004d0e" translate="yes" xml:space="preserve">
          <source>CId</source>
          <target state="translated">CId</target>
        </trans-unit>
        <trans-unit id="e7be63b330aaa816ff99dddf52aa901f13c3fabc" translate="yes" xml:space="preserve">
          <source>CIno</source>
          <target state="translated">CIno</target>
        </trans-unit>
        <trans-unit id="a00ab8ccad7bd52aaf161686d6fb6af78b9d90cb" translate="yes" xml:space="preserve">
          <source>CInt</source>
          <target state="translated">CInt</target>
        </trans-unit>
        <trans-unit id="afbea4a00e3b8d5fbee852694e9f0dbcb7b1e070" translate="yes" xml:space="preserve">
          <source>CIntMax</source>
          <target state="translated">CIntMax</target>
        </trans-unit>
        <trans-unit id="47afa26f3dfaeef25e893b6e001325c1745aac45" translate="yes" xml:space="preserve">
          <source>CIntPtr</source>
          <target state="translated">CIntPtr</target>
        </trans-unit>
        <trans-unit id="ac426a11e5deca23d2c52eb810c979f96bbedb83" translate="yes" xml:space="preserve">
          <source>CJmpBuf</source>
          <target state="translated">CJmpBuf</target>
        </trans-unit>
        <trans-unit id="3ed41ed1d90695511c38d0a153baab3b0aab617d" translate="yes" xml:space="preserve">
          <source>CKey</source>
          <target state="translated">CKey</target>
        </trans-unit>
        <trans-unit id="1966141ca85782abdda851368b2a0b7057d80562" translate="yes" xml:space="preserve">
          <source>CLLong</source>
          <target state="translated">CLLong</target>
        </trans-unit>
        <trans-unit id="a354353db32e9f98dfeeb3d33b8aaf84b8a163c2" translate="yes" xml:space="preserve">
          <source>CLong</source>
          <target state="translated">CLong</target>
        </trans-unit>
        <trans-unit id="689f2f5b3b386fc3317fb8b3163fa80d82e58f86" translate="yes" xml:space="preserve">
          <source>CMode</source>
          <target state="translated">CMode</target>
        </trans-unit>
        <trans-unit id="c0b6232c6ae7abd7cbb0bae2c172830f28afe3d7" translate="yes" xml:space="preserve">
          <source>CNlink</source>
          <target state="translated">CNlink</target>
        </trans-unit>
        <trans-unit id="2da5c4d5231433ed47b22851a4f34135c562f535" translate="yes" xml:space="preserve">
          <source>CONSOLE_SCREEN_BUFFER_INFO</source>
          <target state="translated">CONSOLE_SCREEN_BUFFER_INFO</target>
        </trans-unit>
        <trans-unit id="f3139171b06d99e21e1e6c0b43a55ca7d2c6d843" translate="yes" xml:space="preserve">
          <source>COORD</source>
          <target state="translated">COORD</target>
        </trans-unit>
        <trans-unit id="49131fde8c7035d6dfd1fe50ce9178a13516766e" translate="yes" xml:space="preserve">
          <source>COff</source>
          <target state="translated">COff</target>
        </trans-unit>
        <trans-unit id="bb1b5dc31671aeff27893044e2275fa0f92d166f" translate="yes" xml:space="preserve">
          <source>CPid</source>
          <target state="translated">CPid</target>
        </trans-unit>
        <trans-unit id="885b63c2b62001411024f3d2c731364c5cee99eb" translate="yes" xml:space="preserve">
          <source>CPtrdiff</source>
          <target state="translated">CPtrdiff</target>
        </trans-unit>
        <trans-unit id="1e7cf4b3318228689b092ee37835b9eb42f41fcc" translate="yes" xml:space="preserve">
          <source>CRLF</source>
          <target state="translated">CRLF</target>
        </trans-unit>
        <trans-unit id="546a33567885515078f7a87477637b76336d1419" translate="yes" xml:space="preserve">
          <source>CRLim</source>
          <target state="translated">CRLim</target>
        </trans-unit>
        <trans-unit id="a28d95e9ceb07c9c8e7449a2375eb3ec11044c2f" translate="yes" xml:space="preserve">
          <source>CSChar</source>
          <target state="translated">CSChar</target>
        </trans-unit>
        <trans-unit id="75d3d4d8267acfcf111594d3887d3a5dd6134eae" translate="yes" xml:space="preserve">
          <source>CSUSeconds</source>
          <target state="translated">CSUSeconds</target>
        </trans-unit>
        <trans-unit id="ac8f56e35ed11b15a2832f15b0cb2a46ae988850" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSVは、テーブルの文字ベースの表現です。最大限のモジュール性を実現するために、最初に &lt;code&gt;Table&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; としてレンダリングし、次にこの &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; を何らかのUnicode文字エンコーディングを使用してエンコードします。ただし、中間の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表現が作成されてすぐに破棄されるため、これはパフォーマンスを犠牲にします。文字エンコードをUTF-8に修正し、 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;Table&lt;/code&gt; を直接、遅延 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; として表されるUTF-8エンコードされたCSVテーブルに変換することにより、この中間の &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表現を取り除きます。</target>
        </trans-unit>
        <trans-unit id="e46e637d7bf291d892a2acd0c0be182fc2c433c5" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSVは、テーブルの文字ベースの表現です。モジュール性を最大にするために、最初に &lt;code&gt;Table&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; としてレンダリングしてから、Unicode文字エンコードを使用してこの &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; をエンコードすることができます。ただし、これは、中間の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表現が作成され、直後に破棄されるため、パフォーマンスが犠牲になります。私たちは、この中間を取り除く &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; をUTF-8に文字コードを固定して使用して表現 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; に変換するのを &lt;code&gt;Table&lt;/code&gt; 怠け者のように表さsの直接UTF-8にエンコードされたCSVテーブル &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="c147f801a4e20b0c854dee13ad8a1089c996075a" translate="yes" xml:space="preserve">
          <source>CSV is a character-based representation of tables. For maximal modularity, we could first render &lt;code&gt;Table&lt;/code&gt;s as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s and then encode this &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; using some Unicode character encoding. However, this sacrifices performance due to the intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation being built and thrown away right afterwards. We get rid of this intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; representation by fixing the character encoding to UTF-8 and using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s to convert &lt;code&gt;Table&lt;/code&gt;s directly to UTF-8 encoded CSV tables represented as lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">CSVは、テーブルの文字ベースの表現です。モジュール性を最大にするために、最初に &lt;code&gt;Table&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; としてレンダリングしてから、Unicode文字エンコードを使用してこの &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; をエンコードすることができます。ただし、これは、中間の &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表現が作成され、直後に破棄されるため、パフォーマンスが犠牲になります。私たちは、この中間を取り除く &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; をUTF-8に文字コードを固定して使用して表現 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; に変換するのを &lt;code&gt;Table&lt;/code&gt; 怠け者のように表さsの直接UTF-8にエンコードされたCSVテーブル &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="794f1cc6fcdf266910baaaaa86b4abed6174089f" translate="yes" xml:space="preserve">
          <source>CShort</source>
          <target state="translated">CShort</target>
        </trans-unit>
        <trans-unit id="27cb76e132d99689a39828e8481058f89da270b5" translate="yes" xml:space="preserve">
          <source>CSigAtomic</source>
          <target state="translated">CSigAtomic</target>
        </trans-unit>
        <trans-unit id="066363f762e399c732848700263a21650f470940" translate="yes" xml:space="preserve">
          <source>CSize</source>
          <target state="translated">CSize</target>
        </trans-unit>
        <trans-unit id="3646574cc19c0a235322672991f1d68d3e2b739a" translate="yes" xml:space="preserve">
          <source>CSpeed</source>
          <target state="translated">CSpeed</target>
        </trans-unit>
        <trans-unit id="f87d0c18f3d1185d116c56fd0a55a68efac638e7" translate="yes" xml:space="preserve">
          <source>CSsize</source>
          <target state="translated">CSsize</target>
        </trans-unit>
        <trans-unit id="10fdabde5da32be8abb7d3568067d963d8ef529e" translate="yes" xml:space="preserve">
          <source>CString</source>
          <target state="translated">CString</target>
        </trans-unit>
        <trans-unit id="a23c591d96bc64ebb3bf49374a09dbdd388bf154" translate="yes" xml:space="preserve">
          <source>CStringLen</source>
          <target state="translated">CStringLen</target>
        </trans-unit>
        <trans-unit id="9b2eea83d1e0429c7833e421b94919e2cf388ec0" translate="yes" xml:space="preserve">
          <source>CTcflag</source>
          <target state="translated">CTcflag</target>
        </trans-unit>
        <trans-unit id="5f2bbbe0349a800c3f616f598f975d6fd04867c5" translate="yes" xml:space="preserve">
          <source>CTime</source>
          <target state="translated">CTime</target>
        </trans-unit>
        <trans-unit id="18430e50761b0e842a393b19db9ce285e6cc8054" translate="yes" xml:space="preserve">
          <source>CTimer</source>
          <target state="translated">CTimer</target>
        </trans-unit>
        <trans-unit id="dcb42bcafe594e90af67676c9e8c052fd5a939f5" translate="yes" xml:space="preserve">
          <source>CUChar</source>
          <target state="translated">CUChar</target>
        </trans-unit>
        <trans-unit id="d4a2582d6c16b4ba5d2c635b012416934740d9a4" translate="yes" xml:space="preserve">
          <source>CUInt</source>
          <target state="translated">CUInt</target>
        </trans-unit>
        <trans-unit id="bd076efc1995c3ed275a187edc0ef066f25ea188" translate="yes" xml:space="preserve">
          <source>CUIntMax</source>
          <target state="translated">CUIntMax</target>
        </trans-unit>
        <trans-unit id="e074910606a6a0a7045029bb34df02fd731ab117" translate="yes" xml:space="preserve">
          <source>CUIntPtr</source>
          <target state="translated">CUIntPtr</target>
        </trans-unit>
        <trans-unit id="5486c3338e80ad8846379dc8e8efd520cc4bb304" translate="yes" xml:space="preserve">
          <source>CULLong</source>
          <target state="translated">CULLong</target>
        </trans-unit>
        <trans-unit id="5a6a6d18d4f6db0b3cd3cb3ee6e11d2b638b36ea" translate="yes" xml:space="preserve">
          <source>CULong</source>
          <target state="translated">CULong</target>
        </trans-unit>
        <trans-unit id="14f5959d3f206903fe812b4714e3e8212c8b6cb1" translate="yes" xml:space="preserve">
          <source>CUSKs</source>
          <target state="translated">CUSKs</target>
        </trans-unit>
        <trans-unit id="897002c69b6a884ea8eefcb5421db84ebdef160d" translate="yes" xml:space="preserve">
          <source>CUSeconds</source>
          <target state="translated">CUSeconds</target>
        </trans-unit>
        <trans-unit id="5c8ed628cb7e45bc705eead76f1cbbebd239bed4" translate="yes" xml:space="preserve">
          <source>CUShort</source>
          <target state="translated">CUShort</target>
        </trans-unit>
        <trans-unit id="92c2830bba441303faf6bab856a7cb069b95ea73" translate="yes" xml:space="preserve">
          <source>CUid</source>
          <target state="translated">CUid</target>
        </trans-unit>
        <trans-unit id="418cbde1ba91d0f1d2a07615c5e0090662363499" translate="yes" xml:space="preserve">
          <source>CWString</source>
          <target state="translated">CWString</target>
        </trans-unit>
        <trans-unit id="8057975ee7505b53300ea225f8ab98d9c485a979" translate="yes" xml:space="preserve">
          <source>CWStringLen</source>
          <target state="translated">CWStringLen</target>
        </trans-unit>
        <trans-unit id="e1b7eb195fb8e47d10f92245d40ce0a83001bfc2" translate="yes" xml:space="preserve">
          <source>CWchar</source>
          <target state="translated">CWchar</target>
        </trans-unit>
        <trans-unit id="f28b182fd6c1e7864bf4df566f792efa2f287d19" translate="yes" xml:space="preserve">
          <source>Calculate the disjoint union of two sets.</source>
          <target state="translated">2つの集合の不連続和を計算します。</target>
        </trans-unit>
        <trans-unit id="4f4058eb0d05059b00bf8670b35dee8225ccc810" translate="yes" xml:space="preserve">
          <source>Calculate the integer base 2 logarithm of an &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. The calculation is more efficient than for the general case, on platforms with 32- or 64-bit words much more efficient.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; の 2を底とする整数の対数を計算します。計算は一般的な場合よりも効率的です。32ビットまたは64ビットワードのプラットフォームでははるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="6b1934e0c8bea85b670349912e862bb717885de1" translate="yes" xml:space="preserve">
          <source>Calculate the integer logarithm for an arbitrary base.</source>
          <target state="translated">任意の基底に対する整数対数を計算します。</target>
        </trans-unit>
        <trans-unit id="fb6671b4faab4d9f68221ca795a7d987f6a0b011" translate="yes" xml:space="preserve">
          <source>Calculate the power set of a set: the set of all its subsets.</source>
          <target state="translated">集合の力集合を計算する:そのすべての部分集合の集合。</target>
        </trans-unit>
        <trans-unit id="64d88731a775170b2c2441d20c5626fd611990f4" translate="yes" xml:space="preserve">
          <source>Calculating length of a list continuation-style:</source>
          <target state="translated">リストの継続スタイルの長さを計算します。</target>
        </trans-unit>
        <trans-unit id="d8643951a671cd22c32e5119288ea47182a9cfcf" translate="yes" xml:space="preserve">
          <source>Calendar Duration</source>
          <target state="translated">カレンダーの期間</target>
        </trans-unit>
        <trans-unit id="17b81c9701f67a03dd57e8dd0dc487ffc9b431f1" translate="yes" xml:space="preserve">
          <source>CalendarDiffDays</source>
          <target state="translated">CalendarDiffDays</target>
        </trans-unit>
        <trans-unit id="7409b1c71c8750958b11afbc94ff9c16ede064de" translate="yes" xml:space="preserve">
          <source>CalendarDiffTime</source>
          <target state="translated">CalendarDiffTime</target>
        </trans-unit>
        <trans-unit id="eb7dce9cb4dc86ccc09e9d78fd32dae9732b4f0b" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible</source>
          <target state="translated">カレンドリカルな違い、できるだけ多くの全月で</target>
        </trans-unit>
        <trans-unit id="7768352cae2cf4a9e8a3254eb24cd7bb701e58be" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible. Same as &lt;code&gt;&lt;a href=&quot;data-time-calendar#v:diffGregorianDurationClip&quot;&gt;diffGregorianDurationClip&lt;/a&gt;&lt;/code&gt; for positive durations.</source>
          <target state="translated">可能な限り全体の月数を持つ、暦の違い。正の期間の場合は &lt;code&gt;&lt;a href=&quot;data-time-calendar#v:diffGregorianDurationClip&quot;&gt;diffGregorianDurationClip&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="c553a4bbbf5e7eabf268248210393cf922adb6b0" translate="yes" xml:space="preserve">
          <source>Calendrical difference, with as many whole months as possible. Same as &lt;code&gt;&lt;a href=&quot;data-time-calendar-julian#v:diffJulianDurationClip&quot;&gt;diffJulianDurationClip&lt;/a&gt;&lt;/code&gt; for positive durations.</source>
          <target state="translated">可能な限り全体の月数を持つ、暦の違い。正の期間の場合は &lt;code&gt;&lt;a href=&quot;data-time-calendar-julian#v:diffJulianDurationClip&quot;&gt;diffJulianDurationClip&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="f49baea1e6b905de58ea91679cca46b40b81f9d9" translate="yes" xml:space="preserve">
          <source>Call frame information (CFI) necessary for stack unwinding to produce a call stack trace.</source>
          <target state="translated">コールスタックトレースを生成するためのスタックアンワインドに必要なコールフレーム情報(CFI)。</target>
        </trans-unit>
        <trans-unit id="3812f07ff31cb5f1c7a312c2a62d7b06b2a82122" translate="yes" xml:space="preserve">
          <source>Call stacks</source>
          <target state="translated">コールスタック</target>
        </trans-unit>
        <trans-unit id="369931f908b5d62b0161c02a5b22a7cc6f5cac8f" translate="yes" xml:space="preserve">
          <source>CallCC</source>
          <target state="translated">CallCC</target>
        </trans-unit>
        <trans-unit id="c880ae2dae683608578f800194affe123789856b" translate="yes" xml:space="preserve">
          <source>CallStack</source>
          <target state="translated">CallStack</target>
        </trans-unit>
        <trans-unit id="0056e80c1c5d28940be39ffae2973568ce16898b" translate="yes" xml:space="preserve">
          <source>Callback invoked on I/O events.</source>
          <target state="translated">I/Oイベントで呼び出されるコールバック。</target>
        </trans-unit>
        <trans-unit id="daaca2c7f2ff8d9519d665fa41b06b2d69fccb29" translate="yes" xml:space="preserve">
          <source>Callback invoked on timeout events.</source>
          <target state="translated">タイムアウトイベントでコールバックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bab9ef2996e7c7cd612ef756aaf74e75bf66e857" translate="yes" xml:space="preserve">
          <source>Callconv</source>
          <target state="translated">Callconv</target>
        </trans-unit>
        <trans-unit id="f2709480559f8e1ebfe51f5f922070ee5a0b317e" translate="yes" xml:space="preserve">
          <source>Called when event logging is about to stop. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">イベントロギングが停止しようとしているときに呼び出されます。これは &lt;code&gt;NULL&lt;/code&gt; にすることができます。</target>
        </trans-unit>
        <trans-unit id="c0e54dd6b0d6f06132a5ac9efba16065ebcb80fc" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hs_free_fun_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hs_free_fun_ptr&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="f93440ac09595da765dfd7fce3c043e1340ddc7c" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hs_thread_done()&lt;/code&gt; is entirely optional. You can call it as often or as little as you like. It is safe to call it from a thread that has never called any Haskell functions, or one that never will. If you forget to call it, the worst that can happen is that some memory remains allocated until &lt;code&gt;hs_exit()&lt;/code&gt; is called. If you call it too often, the worst that can happen is that the next call to a Haskell function incurs some extra overhead.</source>
          <target state="translated">&lt;code&gt;hs_thread_done()&lt;/code&gt; の呼び出しは完全にオプションです。あなたはそれを好きなだけ頻繁に、または少し呼び出すことができます。Haskell関数を一度も呼び出さなかったスレッド、または呼び出さないスレッドから呼び出すのが安全です。呼び出すのを忘れた場合、最悪の場合、 &lt;code&gt;hs_exit()&lt;/code&gt; が呼び出されるまでメモリが割り当てられたままになります。頻繁に呼び出す場合、起こりうる最悪の事態は、Haskell関数への次の呼び出しで余分なオーバーヘッドが発生することです。</target>
        </trans-unit>
        <trans-unit id="e8f8b83a7a11f59a3ed11ede1f3d1bacf0e929ec" translate="yes" xml:space="preserve">
          <source>Calling a foreign export has a lot of overhead: it creates a complete new Haskell thread, for example.</source>
          <target state="translated">外国からのエクスポートを呼び出すと、多くのオーバーヘッドが発生します。</target>
        </trans-unit>
        <trans-unit id="ff08cba20a67e3d5df6255f93d1d83290d3ee9d5" translate="yes" xml:space="preserve">
          <source>Calling any FFI function that deals with the stable pointer table except for arbitrarily many calls to &lt;code&gt;hs_free_stable_ptr_unsafe&lt;/code&gt; and the final call to &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;.</source>
          <target state="translated">任意の多くのコールを除き、安定したポインタテーブルを扱っていることを任意のFFI関数を呼び出す &lt;code&gt;hs_free_stable_ptr_unsafe&lt;/code&gt; との最後の呼び出し &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9df609505c881df29223a688771547c8554de6d3" translate="yes" xml:space="preserve">
          <source>Calling any Haskell function, whether or not that function manipulates stable pointers.</source>
          <target state="translated">その関数が安定ポインタを操作するかどうかに関わらず、任意のHaskell関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ed557244b4a9e349a3c322cb0a77503f0c82e38a" translate="yes" xml:space="preserve">
          <source>Calling it as a function and using the result exactly once in the same fashion.</source>
          <target state="translated">それを関数として呼び出し、その結果を同じように一度だけ使う。</target>
        </trans-unit>
        <trans-unit id="9e7c37f4b93e87283ca9f6dfdb888042f1b6baeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;ghci-ffi#v:prepareForeignCall&quot;&gt;prepareForeignCall&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-ffi#v:prepareForeignCall&quot;&gt;prepareForeignCall&lt;/a&gt;&lt;/code&gt; を呼び出す</target>
        </trans-unit>
        <trans-unit id="5b8a9e246fa76764839ff44eb2f103e773afd472" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate an unknown format letter for a given type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; を呼び出して、指定されたタイプの不明なフォーマット文字を示します。</target>
        </trans-unit>
        <trans-unit id="bbeabbfe431946986773f5b91e4e429276bde50e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that the format string ended early.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; を呼び出して、フォーマット文字列が早期に終了したことを示します。</target>
        </trans-unit>
        <trans-unit id="d4d742c7c0092a147431c7f726520a71e74c9a5c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that there is a missing argument in the argument list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; を呼び出して、引数リストに欠落している引数があることを示します。</target>
        </trans-unit>
        <trans-unit id="8f43ec8fc4303b258e938941fa0c2345e526a41e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; to indicate that there is a type error or similar in the given argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; を呼び出して、指定された引数に型エラーまたは類似のエラーがあることを示します。</target>
        </trans-unit>
        <trans-unit id="070d4130edcaf66aaea470ab76abbaddcd88f8ef" translate="yes" xml:space="preserve">
          <source>Calls to wrapper stubs like &lt;code&gt;mkCompare&lt;/code&gt; allocate storage, which should be released with &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:freeHaskellFunPtr&quot;&gt;freeHaskellFunPtr&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">&lt;code&gt;mkCompare&lt;/code&gt; などのラッパースタブを呼び出すと、ストレージが割り当てられます。ストレージは、不要になったときに &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:freeHaskellFunPtr&quot;&gt;freeHaskellFunPtr&lt;/a&gt;&lt;/code&gt; で解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="f880e789e2f3915fa404c71994dee3260cf66e4f" translate="yes" xml:space="preserve">
          <source>Can be combined by allowing the first function to fail:</source>
          <target state="translated">最初の機能を失敗させることで、組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="08a5398c4ef4368084de9b377c7ea4fe19382c35" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:bitDefault&quot;&gt;bitDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用して実装することができ &lt;code&gt;&lt;a href=&quot;data-bits#v:bitDefault&quot;&gt;bitDefault&lt;/a&gt;&lt;/code&gt; を場合ものインスタンスである &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d3a970cf23a4db5acc2dcd82f2ea1d2d3114348" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:popCountDefault&quot;&gt;popCountDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; のインスタンスでもある場合、 &lt;code&gt;&lt;a href=&quot;data-bits#v:popCountDefault&quot;&gt;popCountDefault&lt;/a&gt;&lt;/code&gt; を使用して実装できます。</target>
        </trans-unit>
        <trans-unit id="77df886f88f5ac11d91e40af1a385d5cf0c476b4" translate="yes" xml:space="preserve">
          <source>Can be implemented using &lt;code&gt;&lt;a href=&quot;data-bits#v:testBitDefault&quot;&gt;testBitDefault&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is also an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用して実装することができ &lt;code&gt;&lt;a href=&quot;data-bits#v:testBitDefault&quot;&gt;testBitDefault&lt;/a&gt;&lt;/code&gt; を場合ものインスタンスである &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfff1eba5fd5e0ee04fd5ffa74f4d0a27cee0119" translate="yes" xml:space="preserve">
          <source>Cancel and clean up the user interaction session. Does not block on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザー操作セッションをキャンセルしてクリーンアップします。 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; への既存の呼び出しをブロックしません。</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="79fd1355be5e5c3a2d4b8536cbbd16e2b9043764" translate="yes" xml:space="preserve">
          <source>Capability</source>
          <target state="translated">Capability</target>
        </trans-unit>
        <trans-unit id="54d8a47a1e0d806a4cdef71377794d92327dfe08" translate="yes" xml:space="preserve">
          <source>Capability set</source>
          <target state="translated">能力セット</target>
        </trans-unit>
        <trans-unit id="47decb03a85edffa821a50bbfb0d437fdc807e88" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; type. &lt;code&gt;&lt;a href=&quot;data-bool#v:bool&quot;&gt;bool&lt;/a&gt; x y p&lt;/code&gt; evaluates to &lt;code&gt;x&lt;/code&gt; when &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and evaluates to &lt;code&gt;y&lt;/code&gt; when &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; タイプのケース分析。 &lt;code&gt;&lt;a href=&quot;data-bool#v:bool&quot;&gt;bool&lt;/a&gt; x y p&lt;/code&gt; 評価さへ &lt;code&gt;x&lt;/code&gt; とき &lt;code&gt;p&lt;/code&gt; はある &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; の、と評価さ &lt;code&gt;y&lt;/code&gt; のとき &lt;code&gt;p&lt;/code&gt; ある &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd61e6da694c7005c3bf09a8d6c6175a2aa43e8f" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type. If the value is &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt;, apply the first function to &lt;code&gt;a&lt;/code&gt;; if it is &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;, apply the second function to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; タイプのケース分析。値がされている場合は &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; への最初の関数適用。それがある場合は &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; Bに第2の機能を適用し &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98c9b70590f3abe192e52616a49d1ce1c95797d5" translate="yes" xml:space="preserve">
          <source>Case analysis for the &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type. If the value is &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt;, apply the first function to &lt;code&gt;a&lt;/code&gt;; if it is &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;, apply the second function to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; タイプのケース分析。値がされている場合は &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; への最初の関数適用。それがある場合は &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; Bに第2の機能を適用し &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="475bc2fca6cb658692cd146b77f3134683e44d4e" translate="yes" xml:space="preserve">
          <source>Case conversion</source>
          <target state="translated">ケース変換</target>
        </trans-unit>
        <trans-unit id="c384f0bd4de15126a4e648ecdb43ed85f0f9788d" translate="yes" xml:space="preserve">
          <source>Cast over &lt;code&gt;k1 -&amp;gt; k2 -&amp;gt; k3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k1 -&amp;gt; k2 -&amp;gt; k3&lt;/code&gt; キャスト</target>
        </trans-unit>
        <trans-unit id="9b0c1cec3779c67b5a4198434044b6479333cc3b" translate="yes" xml:space="preserve">
          <source>Cast over &lt;code&gt;k1 -&amp;gt; k2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k1 -&amp;gt; k2&lt;/code&gt; キャスト</target>
        </trans-unit>
        <trans-unit id="418d5136974671468558a366b7adf4e1745babd1" translate="yes" xml:space="preserve">
          <source>Casting &lt;code&gt;Any&lt;/code&gt; back to the real type</source>
          <target state="translated">キャスティング &lt;code&gt;Any&lt;/code&gt; 実数型に背を</target>
        </trans-unit>
        <trans-unit id="14eaff82dc32a3dd06fbb2120fb55390d7aff2b7" translate="yes" xml:space="preserve">
          <source>Casting an unboxed type to another unboxed type of the same size. (Casting between floating-point and integral types does not work. See the &lt;code&gt;GHC.Float&lt;/code&gt; module for functions to do work.)</source>
          <target state="translated">ボックス化されていないタイプを同じサイズの別のボックス化されていないタイプにキャストする。（浮動小数点型と整数型の間のキャストは機能しません。機能する関数については、 &lt;code&gt;GHC.Float&lt;/code&gt; モジュールを参照してください。）</target>
        </trans-unit>
        <trans-unit id="a77a280b66f17718ca45f364c2549ea59ee231d5" translate="yes" xml:space="preserve">
          <source>Casting any lifted type to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">リフトされたタイプを &lt;code&gt;Any&lt;/code&gt; にキャストする</target>
        </trans-unit>
        <trans-unit id="8239393d85a3d2b20d80ac50aa2077b6cb2bbff9" translate="yes" xml:space="preserve">
          <source>Casting between two types that have the same runtime representation. One case is when the two types differ only in &quot;phantom&quot; type parameters, for example &lt;code&gt;Ptr Int&lt;/code&gt; to &lt;code&gt;Ptr Float&lt;/code&gt;, or &lt;code&gt;[Int]&lt;/code&gt; to &lt;code&gt;[Float]&lt;/code&gt; when the list is known to be empty. Also, a &lt;code&gt;newtype&lt;/code&gt; of a type &lt;code&gt;T&lt;/code&gt; has the same representation at runtime as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">同じランタイム表現を持つ2つのタイプ間のキャスト。1つのケースは、2つのタイプが「ファントム」タイプのパラメーターのみが異なる場合です。たとえば、 &lt;code&gt;Ptr Int&lt;/code&gt; から &lt;code&gt;Ptr Float&lt;/code&gt; 、またはリストが空であることがわかっている場合は &lt;code&gt;[Int]&lt;/code&gt; から &lt;code&gt;[Float]&lt;/code&gt; です。また、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;newtype&lt;/code&gt; は、実行時に &lt;code&gt;T&lt;/code&gt; と同じ表現になります。</target>
        </trans-unit>
        <trans-unit id="817c5fda8cf761e409f0573537fe831f98dcc235" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; of a different type.</source>
          <target state="translated">キャスト &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 異なるタイプのを。</target>
        </trans-unit>
        <trans-unit id="3b87674433c2d83df21e90e5d30bb6ad8b8917b3" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キャスト &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; へ &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a333b32a76b5f0846b0b562e4e374f98aa285d13" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キャスト &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95e8d467482a948856e848cedf6d867c0805e0eb" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; of a different type.</source>
          <target state="translated">キャスト &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 異なるタイプのを。</target>
        </trans-unit>
        <trans-unit id="b06ed4465a78c5cb3d6a85f1cc01b4e8f6b31063" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キャスト &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; へ &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19d6f9a00c0c2cabff3ad4bdfb625dab782fe4d7" translate="yes" xml:space="preserve">
          <source>Casts a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">キャスト &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2924698e10e606808fa245512e94c5f68ae0c26" translate="yes" xml:space="preserve">
          <source>Casts an &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; with one element type into one with a different element type. All the elements of the resulting array are undefined (unless you know what you're doing...).</source>
          <target state="translated">1つの要素タイプの &lt;code&gt;&lt;a href=&quot;data-array-io#t:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; を別の要素タイプの1つにキャストします。結果の配列のすべての要素は未定義です（何をしているのかわからない場合は...）。</target>
        </trans-unit>
        <trans-unit id="a08750b8b38605ce21952c72bb767d5301c2b939" translate="yes" xml:space="preserve">
          <source>Casts an &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; with one element type into one with a different element type. All the elements of the resulting array are undefined (unless you know what you're doing...).</source>
          <target state="translated">1つの要素タイプを持つ &lt;code&gt;&lt;a href=&quot;data-array-st#t:STUArray&quot;&gt;STUArray&lt;/a&gt;&lt;/code&gt; を、異なる要素タイプを持つものにキャストします。結果の配列のすべての要素は未定義です（何をしているのかわからない場合は...）。</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="55968d8a1379a4b67fddecc8e9883f837526266e" translate="yes" xml:space="preserve">
          <source>Catch all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt;) exceptions. Still somewhat too general, but better than using &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; for an easy way of catching specific &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s based on the predicates in &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">すべてキャッチ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （当量。 &lt;code&gt;IOException&lt;/code&gt; ）の例外を。まだやや一般的すぎますが、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt; を使用するよりはましです。&lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;の述語に基づいて特定の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をキャッチする簡単な方法については、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b0491a3ba40c7aae2ac43311b82cc5e386de0f0" translate="yes" xml:space="preserve">
          <source>Catch all &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (eqv. &lt;code&gt;IOException&lt;/code&gt;) exceptions. Still somewhat too general, but better than using &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; for an easy way of catching specific &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s based on the predicates in &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">すべてキャッチ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （当量。 &lt;code&gt;IOException&lt;/code&gt; ）の例外を。まだやや一般的すぎますが、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt; を使用するよりはましです。&lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;の述語に基づいて特定の &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をキャッチする簡単な方法については、 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="be3e0797dab02a979f34001bfab69a509009b77c" translate="yes" xml:space="preserve">
          <source>Catch an exception in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドで例外をキャッチします。</target>
        </trans-unit>
        <trans-unit id="dd822d9ac25676eae90dbd5e34d62a0eba9fb936" translate="yes" xml:space="preserve">
          <source>Catch and handle an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; の例外をキャッチして処理します。</target>
        </trans-unit>
        <trans-unit id="a0396fc2c6cc0de592c078776391d5b4c38fa9d0" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドで任意の &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; タイプをキャッチします。</target>
        </trans-unit>
        <trans-unit id="bb4abdda83b18367b6738ca6670fbc64a522dd00" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドの &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; タイプをキャッチします。</target>
        </trans-unit>
        <trans-unit id="e8a05dab529be35078b57b35e09c9396125ad8d1" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; type in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; モナドで任意の &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; タイプをキャッチします。</target>
        </trans-unit>
        <trans-unit id="85fb57b50b7c396aea28d0563de6686ac25936f8" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; that occurs in the computation and throw a modified version.</source>
          <target state="translated">計算で発生する &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をキャッチし、変更されたバージョンをスローします。</target>
        </trans-unit>
        <trans-unit id="3e8b90383da6530dd9f0567fb4058dd0c3408fd5" translate="yes" xml:space="preserve">
          <source>Catch any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; that occurs in the computation and throw a modified version.</source>
          <target state="translated">計算で発生する &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; をキャッチし、変更されたバージョンをスローします。</target>
        </trans-unit>
        <trans-unit id="e00ca112629f0bbeddd0eaf128d45287b724c7a1" translate="yes" xml:space="preserve">
          <source>Catch exceptions only if they pass some predicate. Often useful with the predicates for testing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; values in &lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">いくつかの述語を渡す場合にのみ例外をキャッチします。多くの場合、&lt;a href=&quot;../base-4.14.1.0/system-io-error&quot;&gt;System.IO.Errorの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 値をテストするための述語で役立ちます。</target>
        </trans-unit>
        <trans-unit id="cc1d9a1fb694c15418a8f0478bbfd7cc9e0ccce4" translate="yes" xml:space="preserve">
          <source>Catch exceptions only if they pass some predicate. Often useful with the predicates for testing &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; values in &lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Error&lt;/a&gt;.</source>
          <target state="translated">いくつかの述語を渡す場合にのみ例外をキャッチします。多くの場合、&lt;a href=&quot;../base-4.15.0.0/system-io-error&quot;&gt;System.IO.Errorの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 値をテストするための述語で役立ちます。</target>
        </trans-unit>
        <trans-unit id="27e1a543d61fbc5ef22c14a662c04bfa3f8494dd" translate="yes" xml:space="preserve">
          <source>CatchT</source>
          <target state="translated">CatchT</target>
        </trans-unit>
        <trans-unit id="4faa50ac1aedb089ef7ad23c0ec14c4788d3fa93" translate="yes" xml:space="preserve">
          <source>Catchable failure</source>
          <target state="translated">キャッチ可能な故障</target>
        </trans-unit>
        <trans-unit id="3ad467bb02d631ca180aaff8b3eb2bb11449bd34" translate="yes" xml:space="preserve">
          <source>Catches all exceptions, and somewhat defeats the purpose of the extensible exception system. Use sparingly.</source>
          <target state="translated">すべての例外を捕捉し、拡張可能な例外システムの目的をやや損ないます。控えめに使用してください。</target>
        </trans-unit>
        <trans-unit id="ab50d7d0a8e10c25d0254d43e62f4208eacd6ea8" translate="yes" xml:space="preserve">
          <source>Catches different sorts of exceptions. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">さまざまな種類の例外をキャッチします。&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 参照してください</target>
        </trans-unit>
        <trans-unit id="f142aa11175cc4bb725dba420c092ca4007c7b66" translate="yes" xml:space="preserve">
          <source>Catches different sorts of exceptions. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">さまざまな種類の例外をキャッチします。&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;の &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 参照してください</target>
        </trans-unit>
        <trans-unit id="db9f1e35bd8bc054c14a57bda1390e0ea6c3de74" translate="yes" xml:space="preserve">
          <source>Catches exceptions from the base monad.</source>
          <target state="translated">ベースモナドからの例外をキャッチします。</target>
        </trans-unit>
        <trans-unit id="cbf0eb43a0f74729b670cb70ee447e8dafe2ae8e" translate="yes" xml:space="preserve">
          <source>Catching Exceptions</source>
          <target state="translated">例外のキャッチ</target>
        </trans-unit>
        <trans-unit id="7c24a071f68091fc4b6c70d3a203d55c0991236d" translate="yes" xml:space="preserve">
          <source>Catching all exceptions</source>
          <target state="translated">すべての例外をキャッチ</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="24116b77a8f36e799ebb282f0b37aa98b99674d4" translate="yes" xml:space="preserve">
          <source>Cause GHC to spew a long usage message to standard output and then exit.</source>
          <target state="translated">GHC が長い使用法メッセージを標準出力に吐き出して終了するようにしました。</target>
        </trans-unit>
        <trans-unit id="cd4f2174d5c74263e2692df318af63043a136f0a" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to ignore missing dependencies, directories and libraries when registering a package, and just go ahead and add it anyway. This might be useful if your package installation system needs to add the package to GHC before building and installing the files.</source>
          <target state="translated">原因 &lt;code&gt;ghc-pkg&lt;/code&gt; パッケージを登録するときに行方不明の依存関係、ディレクトリとライブラリを無視し、単に先に行くと、とにかくそれを追加します。これは、ファイルをビルドしてインストールする前にパッケージインストールシステムがGHCにパッケージを追加する必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="51d690ac870a757a43255d7f87f9ba95fdebc250" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as installed package IDs (e.g., an identifier like &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt;). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</source>
          <target state="translated">原因 &lt;code&gt;ghc-pkg&lt;/code&gt; インストールパッケージID（例えば、のような識別子として引数を解釈するために &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt; ）。これは、パッケージ名とバージョンのみを提供することで曖昧な場合に役立ちます（GHCの古いバージョンでは、一意であることが保証されていましたが、この不変条件は必ずしも成り立たなくなりました）。</target>
        </trans-unit>
        <trans-unit id="6668ddc9a0b8030af8f071d3c72c96b34a4f1919" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as installed unit IDs (e.g., an identifier like &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt;). This is useful if providing just the package name and version are ambiguous (in old versions of GHC, this was guaranteed to be unique, but this invariant no longer necessarily holds).</source>
          <target state="translated">原因 &lt;code&gt;ghc-pkg&lt;/code&gt; インストールユニットID（例えば、のような識別子として引数を解釈するために &lt;code&gt;unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240&lt;/code&gt; ）。これは、パッケージ名とバージョンだけを指定することがあいまいな場合に役立ちます（GHCの古いバージョンでは、これは一意であることが保証されていましたが、この不変条件は必ずしも当てはまりません）。</target>
        </trans-unit>
        <trans-unit id="6c8b9bf99ddcbd146b3c845f7be476ec85530046" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;ghc-pkg&lt;/code&gt; to interpret arguments as unit IDs (e.g., an identifier like &lt;code&gt;I5BErHzyOm07EBNpKBEeUv&lt;/code&gt;). Package keys are used to prefix symbol names GHC produces (e.g., &lt;code&gt;6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info&lt;/code&gt;), so if you need to figure out what package a symbol belongs to, use &lt;code&gt;ghc-pkg&lt;/code&gt; with this flag.</source>
          <target state="translated">原因 &lt;code&gt;ghc-pkg&lt;/code&gt; ユニットID（例えば、のような識別子として引数を解釈する &lt;code&gt;I5BErHzyOm07EBNpKBEeUv&lt;/code&gt; ）。パッケージキーは、GHCが生成するシンボル名にプレフィックスを付けるために使用されます（たとえば、 &lt;code&gt;6VWy06pWzzJq9evDvK2d4w6_DataziByteStringziInternal_unsafePackLenChars_info&lt;/code&gt; ）。そのため、シンボルが属するパッケージを特定する必要がある場合は、このフラグを指定して &lt;code&gt;ghc-pkg&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="00ace62f72694d4200557c472f90977b55426b58" translate="yes" xml:space="preserve">
          <source>Causes GHC to continue the compilation if a module has an error. Any reverse dependencies are pruned immediately and the whole compilation is still flagged as an error. This option has no effect if parallel compilation (&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt;) is in use.</source>
          <target state="translated">モジュールにエラーがある場合、GHCはコンパイルを続行します。逆依存関係はすぐに削除され、コンパイル全体にエラーのフラグが付けられます。並列コンパイル（&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;）が使用されている場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="8e4e5c6ceb6d8c45565db992a2558a62eccda222" translate="yes" xml:space="preserve">
          <source>Causes GHC to display error messages with colors. To do this, the terminal must have support for ANSI color codes, or else garbled text will appear. The default value is &lt;code&gt;auto&lt;/code&gt;, which means GHC will make an attempt to detect whether terminal supports colors and choose accordingly.</source>
          <target state="translated">GHCに色付きのエラーメッセージを表示させます。これを行うには、端末がANSIカラーコードをサポートしている必要があります。そうしないと、文字化けしたテキストが表示されます。デフォルト値は &lt;code&gt;auto&lt;/code&gt; です。これは、GHCが端末が色をサポートしているかどうかを検出し、それに応じて選択しようとすることを意味します。</target>
        </trans-unit>
        <trans-unit id="20d2d68914c6346c2e95cbf24b6ec67960b9eecf" translate="yes" xml:space="preserve">
          <source>Causes GHC to emit the full source span of the syntactic entity relating to an error message. Normally, GHC emits the source location of the start of the syntactic entity only.</source>
          <target state="translated">エラーメッセージに関連する構文エンティティの完全なソーススパンを GHC が出力するようにする。通常、GHC は構文エンティティの開始点のソース位置のみを出力する。</target>
        </trans-unit>
        <trans-unit id="d576e350cd2aa7e7096854355ee66b60b92ba0b0" translate="yes" xml:space="preserve">
          <source>Causes GHC to group diagnostic messages by severity and output them after other messages when building a multi-module Haskell program. This flag can make diagnostic messages more visible when used in conjunction with &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt;. Otherwise, it can be hard to find the relevant errors or likely to ignore the warnings when they are mixed with many other messages.</source>
          <target state="translated">マルチモジュールHaskellプログラムを構築するときに、GHCが診断メッセージを重大度別にグループ化し、他のメッセージの後に出力するようにします。このフラグは、&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​すると、診断メッセージをより見やすくすることができます。そうしないと、関連するエラーを見つけるのが難しいか、他の多くのメッセージと混在しているときに警告を無視する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d70d25285a51eb0c30b7f813f53d107d40395ccf" translate="yes" xml:space="preserve">
          <source>Causes GHC to ignore uses of the function &lt;code&gt;Exception.assert&lt;/code&gt; in source code (in other words, rewriting &lt;code&gt;Exception.assert p e&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (see &lt;a href=&quot;exts/assert#assertions&quot;&gt;Assertions&lt;/a&gt;).</source>
          <target state="translated">GHCがソースコードでの関数 &lt;code&gt;Exception.assert&lt;/code&gt; の使用を無視するようにします（つまり、 &lt;code&gt;Exception.assert p e&lt;/code&gt; を &lt;code&gt;e&lt;/code&gt; に書き換えます（&lt;a href=&quot;exts/assert#assertions&quot;&gt;アサーションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="acca7ff63d9b6e41e528844003c34ddbdde2ee3a" translate="yes" xml:space="preserve">
          <source>Causes GHC to ignore uses of the function &lt;code&gt;Exception.assert&lt;/code&gt; in source code (in other words, rewriting &lt;code&gt;Exception.assert p e&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (see &lt;a href=&quot;glasgow_exts#assertions&quot;&gt;Assertions&lt;/a&gt;).</source>
          <target state="translated">GHCに、ソースコードでの関数 &lt;code&gt;Exception.assert&lt;/code&gt; の使用を無視させます（つまり、 &lt;code&gt;Exception.assert p e&lt;/code&gt; を &lt;code&gt;e&lt;/code&gt; に書き換えます（&lt;a href=&quot;glasgow_exts#assertions&quot;&gt;アサーションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a5c37beba2bad256ebd9f62113525cc50cf13289" translate="yes" xml:space="preserve">
          <source>Causes GHC to output errors in reverse line-number order, so that the errors and warnings that originate later in the file are displayed first.</source>
          <target state="translated">GHC がエラーを行番号順に逆順に出力するようにして、ファイル内で後から発生したエラーや警告を最初に表示するようにします。</target>
        </trans-unit>
        <trans-unit id="c74c8c8a50a946a1eb069af532c3b41c65914fde" translate="yes" xml:space="preserve">
          <source>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt; breaks on only those exceptions which would otherwise be uncaught.</source>
          <target state="translated">例外が発生すると、GHCiに評価を中止させ、対話型プロンプトに戻ります。&lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; &lt;/a&gt;は、他の方法ではキャッチされない例外でのみブレークします。</target>
        </trans-unit>
        <trans-unit id="09fceabf67429fb54f490834d66c90cb5b2d87e7" translate="yes" xml:space="preserve">
          <source>Causes GHCi to halt evaluation and return to the interactive prompt in the event of an exception. &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; breaks on all exceptions.</source>
          <target state="translated">例外が発生すると、GHCiに評価を中止させ、対話型プロンプトに戻ります。&lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; &lt;/a&gt;はすべての例外で中断します。</target>
        </trans-unit>
        <trans-unit id="e7e4317b2c3f6f72a82cfdcbcf16addd4832d7ce" translate="yes" xml:space="preserve">
          <source>Causes a specific warning to be treated as normal warning, not fatal error.</source>
          <target state="translated">特定の警告が致命的なエラーではなく、通常の警告として扱われるようにする。</target>
        </trans-unit>
        <trans-unit id="9013a7a5dd4b02050c445d6c8d02f8c9a5659e8f" translate="yes" xml:space="preserve">
          <source>Causes a the finalizer associated with a weak pointer to be run immediately.</source>
          <target state="translated">弱いポインタに関連付けられたファイナライザを直ちに実行させます。</target>
        </trans-unit>
        <trans-unit id="d660793220cce4be870d303d08ede77e598c4e8a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted for foreign declarations that use unsupported calling conventions. In particular, if the &lt;code&gt;stdcall&lt;/code&gt; calling convention is used on an architecture other than i386 then it will be treated as &lt;code&gt;ccall&lt;/code&gt;.</source>
          <target state="translated">サポートされていない呼び出し規約を使用する外部宣言に対して警告を発します。特に、 &lt;code&gt;stdcall&lt;/code&gt; 呼び出し規約がi386以外のアーキテクチャで使用されている場合、それは &lt;code&gt;ccall&lt;/code&gt; として扱われます。</target>
        </trans-unit>
        <trans-unit id="d9231b916d8fb538801ceb6978b5f7d56d89c46a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted for foreign imports of the following form:</source>
          <target state="translated">外国からの輸入品に対して、以下のような形で警告を出す。</target>
        </trans-unit>
        <trans-unit id="e98a3a30d7733ed9dedcbabc936490c757372801" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted if a literal will overflow, e.g. &lt;code&gt;300 :: Word8&lt;/code&gt;.</source>
          <target state="translated">リテラルがオーバーフローすると警告が &lt;code&gt;300 :: Word8&lt;/code&gt; ます（例：300 :: Word8）。</target>
        </trans-unit>
        <trans-unit id="0cd1c01a0d1fd759549d7f5a255d840e89eea8c9" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted if an enumeration is empty, e.g. &lt;code&gt;[5 .. 3]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[5 .. 3]&lt;/code&gt; ように、列挙が空の場合に警告を発します。</target>
        </trans-unit>
        <trans-unit id="2b03d60a421fef989bdabe6f59af3aafb863a3a2" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted in the following cases:</source>
          <target state="translated">以下の場合に警告を発します。</target>
        </trans-unit>
        <trans-unit id="54a2ce2dcdf3de95961e4a84c06a6eb991218b3a" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a datatype &lt;code&gt;T&lt;/code&gt; is exported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but is it just a type synonym.</source>
          <target state="translated">データ型 &lt;code&gt;T&lt;/code&gt; がすべてのコンストラクター、つまり &lt;code&gt;T(..)&lt;/code&gt; でエクスポートされるときに警告が発行されますが、これは単なる型の同義語です。</target>
        </trans-unit>
        <trans-unit id="5850209be2276082816894ad46c9d27f472d8244" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a deprecated command-line flag is used.</source>
          <target state="translated">非推奨のコマンドラインフラグが使用されている場合に警告を発します。</target>
        </trans-unit>
        <trans-unit id="1559b656d4f4ada2377537a03c55fbff0cb2ceb8" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; または &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 持つモジュール、関数、またはタイプが使用されると、警告が発行されます。参照してください。&lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNINGおよび非推奨のプラグマ&lt;/a&gt;プラグマの詳細については、を。</target>
        </trans-unit>
        <trans-unit id="e8a0d32c9e37c86534bf9a681300a1caae49d88d" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas. An alias for &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wwarnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; または &lt;code&gt;DEPRECATED pragma&lt;/code&gt; 持つモジュール、関数、またはタイプが使用されると、警告が発行されます。参照してください。&lt;a href=&quot;exts/pragmas#warning-deprecated-pragma&quot;&gt;WARNINGおよび非推奨のプラグマ&lt;/a&gt;プラグマの詳細については、を。&lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wwarnings-deprecations&lt;/code&gt; &lt;/a&gt;のエイリアス。</target>
        </trans-unit>
        <trans-unit id="b17effd9a3e5c7c9e87b6669a7b23b62923d60da" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; または &lt;code&gt;DEPRECATED pragma&lt;/code&gt; あるモジュール、関数、またはタイプが使用されたときに警告が発行されます。参照してください。&lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNINGおよび非推奨のプラグマ&lt;/a&gt;プラグマの詳細については、を。</target>
        </trans-unit>
        <trans-unit id="ae2b17da3f31748cf6562bc1e9f9fc0eea07082f" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a module, function or type with a &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;DEPRECATED pragma&lt;/code&gt; is used. See &lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNING and DEPRECATED pragmas&lt;/a&gt; for more details on the pragmas. An alias for &lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wwarnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;WARNING&lt;/code&gt; または &lt;code&gt;DEPRECATED pragma&lt;/code&gt; あるモジュール、関数、またはタイプが使用されたときに警告が発行されます。参照してください。&lt;a href=&quot;glasgow_exts#warning-deprecated-pragma&quot;&gt;WARNINGおよび非推奨のプラグマ&lt;/a&gt;プラグマの詳細については、を。&lt;a href=&quot;#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wwarnings-deprecations&lt;/code&gt; &lt;/a&gt;のエイリアス。</target>
        </trans-unit>
        <trans-unit id="98e20c4585a176d469e30cd83022bf0c8a9dc06c" translate="yes" xml:space="preserve">
          <source>Causes a warning to be emitted when a pragma that GHC doesn&amp;rsquo;t recognise is used. As well as pragmas that GHC itself uses, GHC also recognises pragmas known to be used by other tools, e.g. &lt;code&gt;OPTIONS_HUGS&lt;/code&gt; and &lt;code&gt;DERIVE&lt;/code&gt;.</source>
          <target state="translated">GHCが認識しないプラグマが使用されたときに警告を発行します。GHC自体が使用するプラグマだけでなく、GHCは、 &lt;code&gt;OPTIONS_HUGS&lt;/code&gt; や &lt;code&gt;DERIVE&lt;/code&gt; などの他のツールで使用されることが知られているプラ​​グマも認識します。</target>
        </trans-unit>
        <trans-unit id="a825494d23788ab82b5c459198f152d6a42195e6" translate="yes" xml:space="preserve">
          <source>Causes a warning to be reported when a type error is deferred until runtime. See &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;</source>
          <target state="translated">タイプエラーが実行時まで延期されると、警告が報告されます。&lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;タイプエラーのランタイムへの延期を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="79d06a9df074ba808cc5468d12706017603b0286" translate="yes" xml:space="preserve">
          <source>Causes a warning to be reported when a type error is deferred until runtime. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;</source>
          <target state="translated">型エラーが実行時まで延期されると、警告が報告されます。&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;タイプエラーのランタイムへの遅延を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5a66456e97d3e5c82a2e7e50ed6cce45f40a3e24" translate="yes" xml:space="preserve">
          <source>Causes a warning when both &lt;a href=&quot;exts/derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exts/newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</source>
          <target state="translated">&lt;a href=&quot;exts/derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;exts/newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; の&lt;/a&gt;両方が有効で、明示的な派生戦略が使用されていない場合に警告を発生させます。たとえば、これは警告になります。</target>
        </trans-unit>
        <trans-unit id="cd293507c41778581d65d30e7291dca340df36ce" translate="yes" xml:space="preserve">
          <source>Causes a warning when both &lt;a href=&quot;glasgow_exts#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;glasgow_exts#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</source>
          <target state="translated">&lt;a href=&quot;glasgow_exts#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;glasgow_exts#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; の&lt;/a&gt;両方が有効で、明示的な派生戦略が使用されていない場合に警告を発生させます。たとえば、これは警告になります。</target>
        </trans-unit>
        <trans-unit id="7b795c3c145457a6b91186e97358df9a2b6dccc0" translate="yes" xml:space="preserve">
          <source>Causes all files following this option on the command line to be processed as if they had the suffix ⟨suffix⟩. For example, to compile a Haskell module in the file &lt;code&gt;M.my-hs&lt;/code&gt;, use &lt;code&gt;ghc -c -x hs M.my-hs&lt;/code&gt;.</source>
          <target state="translated">コマンドラインでこのオプションに続くすべてのファイルに、「suffix」のサフィックスがあるかのように処理されます。たとえば、Haskellモジュールをファイル &lt;code&gt;M.my-hs&lt;/code&gt; でコンパイルするには、 &lt;code&gt;ghc -c -x hs M.my-hs&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8292d38b8a6403c2a334f06412c37889687b00ef" translate="yes" xml:space="preserve">
          <source>Causes the compiler to behave as if package ⟨pkg⟩, and any packages that depend on ⟨pkg⟩, are not installed at all.</source>
          <target state="translated">⟨pkg⟩ パッケージ、および ⟨pkg⟩ に依存するすべてのパッケージがインストールされていないかのように コンパイラを動作させます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
