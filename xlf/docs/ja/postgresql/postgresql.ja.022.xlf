<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="a096978b727394f0a665fb7212a971c3ee9889e1" translate="yes" xml:space="preserve">
          <source>The implemented SASL mechanisms at the moment are &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; and its variant with channel binding &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt;. They are described in detail in RFC 7677 and RFC 5802.</source>
          <target state="translated">現在実装されているSASLメカニズムは、 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; と、チャネルバインディング &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; を備えたそのバリアントです。それらはRFC 7677およびRFC 5802で詳細に説明されています。</target>
        </trans-unit>
        <trans-unit id="3994c1cc646c4ef5a61a7d412fe3e39d9a284414" translate="yes" xml:space="preserve">
          <source>The index access costs should be computed using the parameters used by &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt;: a sequential disk block fetch has cost &lt;code&gt;seq_page_cost&lt;/code&gt;, a nonsequential fetch has cost &lt;code&gt;random_page_cost&lt;/code&gt;, and the cost of processing one index row should usually be taken as &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt;. In addition, an appropriate multiple of &lt;code&gt;cpu_operator_cost&lt;/code&gt; should be charged for any comparison operators invoked during index processing (especially evaluation of the indexquals themselves).</source>
          <target state="translated">インデックスアクセスコストは、 &lt;code&gt;src/backend/optimizer/path/costsize.c&lt;/code&gt; で使用されるパラメーターを使用して計算する必要があります。シーケンシャルディスクブロックフェッチにはコスト &lt;code&gt;seq_page_cost&lt;/code&gt; があり、非シーケンシャルフェッチにはコスト &lt;code&gt;random_page_cost&lt;/code&gt; があり、1つのインデックス行を処理するコストは通常 &lt;code&gt;cpu_index_tuple_cost&lt;/code&gt; として取得されます。さらに、インデックスの処理中に呼び出される比較演算子（特に、indexquals自体の評価）に対して、cpu_operator_costの適切な倍数を &lt;code&gt;cpu_operator_cost&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="6fef8227d6c9875a9adfc4cf6467a2aea1121c60" translate="yes" xml:space="preserve">
          <source>The index access path being considered. All fields except cost and selectivity values are valid.</source>
          <target state="translated">考慮されるインデックスアクセスパス。コストと選択性の値を除くすべてのフィールドが有効です。</target>
        </trans-unit>
        <trans-unit id="47ab406c0502c2ff0920580c5626f87c7d3ac514" translate="yes" xml:space="preserve">
          <source>The index automatically uses the collation of the underlying column. So a query of the form</source>
          <target state="translated">インデックスは自動的に基礎となるカラムの照合を使用します。そのため、次のような形式のクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="d40d5a355329bb21744bf91012270d4b7eadd19f" translate="yes" xml:space="preserve">
          <source>The index cannot have expression columns nor be a partial index. Also, it must be a b-tree index with default sort ordering. These restrictions ensure that the index is equivalent to one that would be built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command.</source>
          <target state="translated">インデックスに式列を含めることも、部分インデックスにすることもできません。また、デフォルトのソート順のBツリーインデックスである必要があります。これらの制限により、インデックスは通常の &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; または &lt;code&gt;ADD UNIQUE&lt;/code&gt; コマンドで作成されるインデックスと同等になります。</target>
        </trans-unit>
        <trans-unit id="78493f3623537c9a38e59ae58540f722627b962f" translate="yes" xml:space="preserve">
          <source>The index construction and maintenance functions that an index access method must provide in &lt;code&gt;IndexAmRoutine&lt;/code&gt; are:</source>
          <target state="translated">インデックスアクセスメソッドが &lt;code&gt;IndexAmRoutine&lt;/code&gt; で提供する必要があるインデックス構築およびメンテナンス関数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3039446ce33001ce11d9ef4cc9e239f9e80ff013" translate="yes" xml:space="preserve">
          <source>The index is being built by the access method-specific code. In this phase, access methods that support progress reporting fill in their own progress data, and the subphase is indicated in this column. Typically, &lt;code&gt;blocks_total&lt;/code&gt; and &lt;code&gt;blocks_done&lt;/code&gt; will contain progress data, as well as potentially &lt;code&gt;tuples_total&lt;/code&gt; and &lt;code&gt;tuples_done&lt;/code&gt;.</source>
          <target state="translated">インデックスは、アクセス方法固有のコードによって構築されています。このフェーズでは、進行状況レポートをサポートするアクセスメソッドが独自の進行状況データを入力し、サブフェーズがこの列に示されます。典型的には、 &lt;code&gt;blocks_total&lt;/code&gt; と &lt;code&gt;blocks_done&lt;/code&gt; は、進捗データを含むことになる、ならびに潜在 &lt;code&gt;tuples_total&lt;/code&gt; と &lt;code&gt;tuples_done&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8974784c29c6386bf1253069fdf16bf07fbf780" translate="yes" xml:space="preserve">
          <source>The index is created with a signature length of 80 bits, with attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have omitted the &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;col1&lt;/code&gt;, and &lt;code&gt;col2&lt;/code&gt; specifications since those have the default values.</source>
          <target state="translated">インデックスは、80ビットの署名長で作成され、属性i1およびi2は2ビットにマッピングされ、属性i3は4ビットにマッピングされます。 &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;col1&lt;/code&gt; 、および &lt;code&gt;col2&lt;/code&gt; の指定にはデフォルト値があるため、これらを省略することもできます。</target>
        </trans-unit>
        <trans-unit id="f53b14842204c3afdf4a8da34fde71ed13d02632" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator class.</source>
          <target state="translated">演算子クラスに関連付けられた演算子のインデックスメソッドのストラテジー番号。</target>
        </trans-unit>
        <trans-unit id="62c3a3b1a4517180b23038b6d08f465908556b8b" translate="yes" xml:space="preserve">
          <source>The index method's strategy number for an operator associated with the operator family.</source>
          <target state="translated">演算子ファミリーに関連付けられた演算子のインデックスメソッドのストラテジー番号。</target>
        </trans-unit>
        <trans-unit id="4a128fb2d5e95c4a7976acace79bbc58b6fb276b" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator class.</source>
          <target state="translated">演算子クラスに関連付けられた関数のインデックスメソッドのサポート関数番号。</target>
        </trans-unit>
        <trans-unit id="8c74967c2b0a4ae3a48c94ba4d59d1361af52eba" translate="yes" xml:space="preserve">
          <source>The index method's support function number for a function associated with the operator family.</source>
          <target state="translated">演算子ファミリに関連付けられた関数のインデックスメソッドのサポート関数番号。</target>
        </trans-unit>
        <trans-unit id="dfbc9f2ec43f190a4f4b92d5261f2d63618ce86e" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the regular expression and then looking these up in the index. The more trigrams that can be extracted from the regular expression, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">インデックス検索は、正規表現からトリグラムを抽出し、それらをインデックスで検索することで機能します。正規表現から抽出できるトリグラムが多ければ多いほど、インデックス検索はより効果的です。B-treeベースの検索とは異なり、検索文字列は左アンカーである必要はありません。</target>
        </trans-unit>
        <trans-unit id="76d1075d790db56a70c52b9e9529c4e67b5fd660" translate="yes" xml:space="preserve">
          <source>The index search works by extracting trigrams from the search string and then looking these up in the index. The more trigrams in the search string, the more effective the index search is. Unlike B-tree based searches, the search string need not be left-anchored.</source>
          <target state="translated">インデックス検索は、検索文字列からトリグラムを抽出し、インデックスで検索することで機能します。検索文字列に含まれるトリグラムの数が多ければ多いほど、インデックス検索はより効果的です。B-treeベースの検索とは異なり、検索文字列は左アンカーである必要はありません。</target>
        </trans-unit>
        <trans-unit id="2ef045e734746214c8ad4568acd243c24cf2fcf6" translate="yes" xml:space="preserve">
          <source>The index supporting a unique, primary key, referential integrity, or exclusion constraint</source>
          <target state="translated">一意、主キー、参照整合性、または除外制約をサポートするインデックス。</target>
        </trans-unit>
        <trans-unit id="b1f015828c180dda3ed4f3bdc55e0086cb7fcc71" translate="yes" xml:space="preserve">
          <source>The index supporting this constraint, if it's a unique, primary key, foreign key, or exclusion constraint; else 0</source>
          <target state="translated">この制約をサポートするインデックス、それが一意、主キー、外部キー、または除外制約の場合。</target>
        </trans-unit>
        <trans-unit id="6c3b8559bb8c83cd05e198719da39b30d3fb1043" translate="yes" xml:space="preserve">
          <source>The index type must support index-only scans. B-tree indexes always do. GiST and SP-GiST indexes support index-only scans for some operator classes but not others. Other index types have no support. The underlying requirement is that the index must physically store, or else be able to reconstruct, the original data value for each index entry. As a counterexample, GIN indexes cannot support index-only scans because each index entry typically holds only part of the original data value.</source>
          <target state="translated">インデックスタイプは、インデックスのみのスキャンをサポートしている必要があります。B-treeインデックスは常にサポートしています。GiSTとSP-GISTインデックスは、いくつかの演算子クラスに対してインデックスのみのスキャンをサポートしますが、他の演算子クラスに対してはサポートしません。他のインデックス・タイプはサポートしていません。基本的な要件は、インデックスが各インデックス項目の元のデータ値を物理的に保存しなければならないか、あるいは再構築できなければならないということです。逆の例として、GINインデックスはインデックスのみのスキャンをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="a6836c640c52510a0b02e594ca8bbfc9b8103067" translate="yes" xml:space="preserve">
          <source>The indicated database user name was not found.</source>
          <target state="translated">指定されたデータベースのユーザー名が見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="20e3988dff010547d05b25cba96f92a2ac547dbd" translate="yes" xml:space="preserve">
          <source>The individual elements of a &lt;code&gt;CUBE&lt;/code&gt; or &lt;code&gt;ROLLUP&lt;/code&gt; clause may be either individual expressions, or sublists of elements in parentheses. In the latter case, the sublists are treated as single units for the purposes of generating the individual grouping sets. For example:</source>
          <target state="translated">&lt;code&gt;CUBE&lt;/code&gt; または &lt;code&gt;ROLLUP&lt;/code&gt; 句の個々の要素は、個々の式、または括弧内の要素のサブリストのいずれかです。後者の場合、個々のグループ化セットを生成するために、サブリストは単一のユニットとして扱われます。例えば：</target>
        </trans-unit>
        <trans-unit id="478f53ba771627a25e2c5229ba6d54c52bd271c5" translate="yes" xml:space="preserve">
          <source>The individual tables can be added and removed dynamically using &lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;. Both the &lt;code&gt;ADD TABLE&lt;/code&gt; and &lt;code&gt;DROP TABLE&lt;/code&gt; operations are transactional; so the table will start or stop replicating at the correct snapshot once the transaction has committed.</source>
          <target state="translated">個々のテーブルは、&lt;a href=&quot;sql-alterpublication&quot;&gt;ALTER PUBLICATION&lt;/a&gt;を使用して動的に追加および削除できます。 &lt;code&gt;ADD TABLE&lt;/code&gt; 操作と &lt;code&gt;DROP TABLE&lt;/code&gt; 操作はどちらもトランザクションです。したがって、トランザクションがコミットされると、テーブルは正しいスナップショットで複製を開始または停止します。</target>
        </trans-unit>
        <trans-unit id="55f0b3e0f4002ca62cb368b92a46147d06514b6c" translate="yes" xml:space="preserve">
          <source>The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.</source>
          <target state="translated">通知イベントのためにクライアントに渡される情報には、通知チャネル名、通知セッションのサーバプロセスPID、ペイロード文字列(指定されていない場合は空文字列)が含まれます。</target>
        </trans-unit>
        <trans-unit id="044f2cd515098f5f363f2857b2c2afc07209265a" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">情報スキーマ（&lt;a href=&quot;https://www.postgresql.org/docs/12/information-schema.html&quot;&gt;第36章&lt;/a&gt;）は、システムビューの機能と重複するビューの代替セットを提供します。ここで説明するビューはPostgreSQL固有であるのに対し、情報スキーマはSQL標準であるため、必要なすべての情報を提供する場合は通常、情報スキーマを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0c18c9f5485d75a93a8e5be63c2bfb9df98cb595" translate="yes" xml:space="preserve">
          <source>The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</source>
          <target state="translated">The information schema (&lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) provides an alternative set of views which overlap the functionality of the system views. Since the information schema is SQL-standard whereas the views described here are PostgreSQL-specific, it's usually better to use the information schema if it provides all the information you need.</target>
        </trans-unit>
        <trans-unit id="1f201ea8f38230c6e8acfb095bb89803ef41bb1b" translate="yes" xml:space="preserve">
          <source>The information to implement this module was collected from several sites, including:</source>
          <target state="translated">このモジュールを実装するための情報は、以下のようないくつかのサイトから収集しました。</target>
        </trans-unit>
        <trans-unit id="8ffbbc2df15378d40a94e42b70d5fb5af1458af3" translate="yes" xml:space="preserve">
          <source>The initial access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">最初のアクセス権限。詳細については、&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="8a1054b1ac592ae44e2cf9b51ca38fb26634ef49" translate="yes" xml:space="preserve">
          <source>The initial data in existing subscribed tables are snapshotted and copied in a parallel instance of a special kind of apply process. This process will create its own temporary replication slot and copy the existing data. Once existing data is copied, the worker enters synchronization mode, which ensures that the table is brought up to a synchronized state with the main apply process by streaming any changes that happened during the initial data copy using standard logical replication. Once the synchronization is done, the control of the replication of the table is given back to the main apply process where the replication continues as normal.</source>
          <target state="translated">既存のサブスクライブされたテーブルの初期データは、特殊な種類の適用プロセスの並列インスタンスでスナップショットされ、コピーされます。このプロセスは、それ自身の一時的なレプリケーション スロットを作成し、既存のデータをコピーします。既存のデータがコピーされると、ワーカーは同期モードに入り、標準の論理レプリケーションを使用して初期データコピー中に起こった変更をストリーミングすることで、テーブルがメインの適用プロセスと同期した状態に持ち込まれることを保証します。同期が行われると、テーブルのレプリケーションの制御は、通常通りレプリケーションが継続されるメイン適用プロセスに戻されます。</target>
        </trans-unit>
        <trans-unit id="257568e0871ee2fb3ae1bd84f534adce4db0bec5" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value, when using moving-aggregate mode. This works the same as &lt;code&gt;initial_condition&lt;/code&gt;.</source>
          <target state="translated">移動集約モードを使用する場合の状態値の初期設定。これは、 &lt;code&gt;initial_condition&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="eb62c8458668a0689948660586a0f8259374a819" translate="yes" xml:space="preserve">
          <source>The initial setting for the state value. This must be a string constant in the form accepted for the data type &lt;code&gt;state_data_type&lt;/code&gt;. If not specified, the state value starts out null.</source>
          <target state="translated">状態値の初期設定。これは、データ型 &lt;code&gt;state_data_type&lt;/code&gt; で受け入れられる形式の文字列定数でなければなりません。指定しない場合、状態値はnullから始まります。</target>
        </trans-unit>
        <trans-unit id="d82c96a461d121c75c52d8ce64285a1d86e2ab14" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state for moving-aggregate mode. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">移動アグリゲートモードの遷移状態の初期値。これは、外部文字列表現の初期値を含むテキストフィールドです。このフィールドがNULLの場合、遷移状態の値はNULLから始まります。</target>
        </trans-unit>
        <trans-unit id="dfef147dfd625c38da29727096d66edbe7450de5" translate="yes" xml:space="preserve">
          <source>The initial value of the transition state. This is a text field containing the initial value in its external string representation. If this field is null, the transition state value starts out null.</source>
          <target state="translated">遷移状態の初期値。これは、外部文字列表現の初期値を含むテキスト・フィールドです。このフィールドがNULLの場合、遷移状態の値はNULLから始まります。</target>
        </trans-unit>
        <trans-unit id="6e8d9c8e49727d756d0711797450f963975e284e" translate="yes" xml:space="preserve">
          <source>The initially assigned data type of a numeric constant is just a starting point for the type resolution algorithms. In most cases the constant will be automatically coerced to the most appropriate type depending on context. When necessary, you can force a numeric value to be interpreted as a specific data type by casting it. For example, you can force a numeric value to be treated as type &lt;code&gt;real&lt;/code&gt; (&lt;code&gt;float4&lt;/code&gt;) by writing:</source>
          <target state="translated">数値定数の最初に割り当てられたデータ型は、型解決アルゴリズムの開始点にすぎません。ほとんどの場合、定数はコンテキストに応じて自動的に最適な型に強制変換されます。必要に応じて、数値をキャストすることにより、数値を特定のデータ型として解釈させることができます。たとえば、次のように記述することで、数値を強制 &lt;code&gt;real&lt;/code&gt; 型（ &lt;code&gt;float4&lt;/code&gt; ）として扱うことができます。</target>
        </trans-unit>
        <trans-unit id="f4532069877c3839fd18c7cafdf1b166d436f334" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;UNION&lt;/code&gt; is resolved as emitting type &lt;code&gt;text&lt;/code&gt;, according to the rules given above. Then the outer &lt;code&gt;UNION&lt;/code&gt; has inputs of types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;, leading to the observed error. The problem can be fixed by ensuring that the leftmost &lt;code&gt;UNION&lt;/code&gt; has at least one input of the desired result type.</source>
          <target state="translated">内側の &lt;code&gt;UNION&lt;/code&gt; は、上記のルールに従って、タイプ &lt;code&gt;text&lt;/code&gt; の放出として解決されます。次に、外側の &lt;code&gt;UNION&lt;/code&gt; に &lt;code&gt;text&lt;/code&gt; 型と &lt;code&gt;integer&lt;/code&gt; 型の入力があり、観測されたエラーが発生します。左端の &lt;code&gt;UNION&lt;/code&gt; に目的の結果タイプの入力が少なくとも1つあることを確認することで、問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="752b1c95a1eae331cb7a120fbc2cbc7b360efa2f" translate="yes" xml:space="preserve">
          <source>The input for a range value must follow one of the following patterns:</source>
          <target state="translated">範囲値の入力は、以下のパターンのいずれかに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="5db960d2928db992e514ea865af6ec0e73cf5806" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is missing, the netmask is 32 for IPv4 and 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">このタイプの入力フォーマットは、 &lt;code&gt;address/y&lt;/code&gt; &lt;code&gt;address&lt;/code&gt; IPv4またはIPv6アドレスであり、 &lt;code&gt;y&lt;/code&gt; はネットマスクのビット数です。場合 &lt;code&gt;/y&lt;/code&gt; の部分が欠落している値は、単に単一のホストを表すように、ネットマスクは、IPv4の場合32およびIPv6の128です。表示では、ネットマスクが単一のホストを指定している場合、 &lt;code&gt;/y&lt;/code&gt; の部分は抑制されます。</target>
        </trans-unit>
        <trans-unit id="a8be18b330a3d96f66997a77713b943e9dcae523" translate="yes" xml:space="preserve">
          <source>The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is omitted, the netmask is taken to be 32 for IPv4 or 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</source>
          <target state="translated">The input format for this type is &lt;code&gt;address/y&lt;/code&gt; where &lt;code&gt;address&lt;/code&gt; is an IPv4 or IPv6 address and &lt;code&gt;y&lt;/code&gt; is the number of bits in the netmask. If the &lt;code&gt;/y&lt;/code&gt; portion is omitted, the netmask is taken to be 32 for IPv4 or 128 for IPv6, so the value represents just a single host. On display, the &lt;code&gt;/y&lt;/code&gt; portion is suppressed if the netmask specifies a single host.</target>
        </trans-unit>
        <trans-unit id="1496dddf6a6d3aece3a51059d08e155ea1323eea" translate="yes" xml:space="preserve">
          <source>The input/output syntax for the JSON data types is as specified in RFC 7159.</source>
          <target state="translated">JSON データ型の入出力構文は、RFC 7159 で規定されています。</target>
        </trans-unit>
        <trans-unit id="28b76175a8e4e44a6929b2bbc612975f4e90fb8f" translate="yes" xml:space="preserve">
          <source>The instance handles all key features of a DBMS: read and write access to files and shared memory, assurance of the ACID properties, &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connections&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt;, privilege verification, crash recovery, replication, etc.</source>
          <target state="translated">The instance handles all key features of a DBMS: read and write access to files and shared memory, assurance of the ACID properties, &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connections&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt;, privilege verification, crash recovery, replication, etc.</target>
        </trans-unit>
        <trans-unit id="03aa7e8fbd88e7f3d34658426c4782d01d3a8689" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.86&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">&lt;code&gt;pause&lt;/code&gt; 設定の使用目的は、データベースに対してクエリを実行して、この回復ターゲットが回復に最も望ましいポイントであるかどうかを確認できるようにすることです。一時停止状態は、 &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; （&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;表9.86を&lt;/a&gt;参照）を使用して再開できます。これにより、リカバリが終了します。このリカバリターゲットが目的の停止ポイントでない場合は、サーバーをシャットダウンし、リカバリターゲットの設定を新しいターゲットに変更し、再起動してリカバリを続行します。</target>
        </trans-unit>
        <trans-unit id="1eb808aeb9bcf9fecdcdeaa1957208268bb0812e" translate="yes" xml:space="preserve">
          <source>The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</source>
          <target state="translated">The intended use of the &lt;code&gt;pause&lt;/code&gt; setting is to allow queries to be executed against the database to check if this recovery target is the most desirable point for recovery. The paused state can be resumed by using &lt;code&gt;pg_wal_replay_resume()&lt;/code&gt; (see &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-CONTROL-TABLE&quot;&gt;Table 9.87&lt;/a&gt;), which then causes recovery to end. If this recovery target is not the desired stopping point, then shut down the server, change the recovery target settings to a later target and restart to continue recovery.</target>
        </trans-unit>
        <trans-unit id="eae9a7b2978d9149a7d3a255f37f5ad888745278" translate="yes" xml:space="preserve">
          <source>The intended use of this setting is that logical replication systems set it to &lt;code&gt;replica&lt;/code&gt; when they are applying replicated changes. The effect of that will be that triggers and rules (that have not been altered from their default configuration) will not fire on the replica. See the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; clauses &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; and &lt;code&gt;ENABLE RULE&lt;/code&gt; for more information.</source>
          <target state="translated">この設定の使用目的は、論理的なレプリケーション・システムがそれを設定することである &lt;code&gt;replica&lt;/code&gt; 彼らは複製された変更を適用しているとき。その影響は、トリガーとルール（デフォルトの構成から変更されていないもの）がレプリカで起動されないことです。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;句の &lt;code&gt;ENABLE TRIGGER&lt;/code&gt; および &lt;code&gt;ENABLE RULE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="e73e54c88ad65514d99a46ba805b5445c9c890d2" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow administrators to reduce the I/O impact of these commands on concurrent database activity. There are many situations where it is not important that maintenance commands like &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; finish quickly; however, it is usually very important that these commands do not significantly interfere with the ability of the system to perform other database operations. Cost-based vacuum delay provides a way for administrators to achieve this.</source>
          <target state="translated">この機能の目的は、管理者がこれらのコマンドによる同時データベースアクティビティへのI / Oの影響を軽減できるようにすることです。 &lt;code&gt;VACUUM&lt;/code&gt; や &lt;code&gt;ANALYZE&lt;/code&gt; のような保守コマンドが迅速に終了することが重要ではない多くの状況があります。ただし、通常、これらのコマンドが、システムが他のデータベース操作を実行する機能を大幅に妨害しないことが非常に重要です。コストベースのバキューム遅延は、管理者がこれを達成する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="3ce7c282b1076520793e0399674bfd41329343fd" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow debugging or performance-measurement libraries to be loaded into specific sessions without an explicit &lt;code&gt;LOAD&lt;/code&gt; command being given. For example, &lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt; could be enabled for all sessions under a given user name by setting this parameter with &lt;code&gt;ALTER ROLE SET&lt;/code&gt;. Also, this parameter can be changed without restarting the server (but changes only take effect when a new session is started), so it is easier to add new modules this way, even if they should apply to all sessions.</source>
          <target state="translated">この機能の目的は、明示的な &lt;code&gt;LOAD&lt;/code&gt; コマンドを指定しなくても、デバッグまたはパフォーマンス測定ライブラリを特定のセッションにロードできるようにすることです。たとえば、 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; でこのパラメーターを設定することにより、特定のユーザー名の下のすべてのセッションで&lt;a href=&quot;auto-explain&quot;&gt;auto_explain&lt;/a&gt;を有効にすることができます。また、このパラメーターはサーバーを再起動せずに変更できます（ただし、変更は新しいセッションが開始されたときにのみ有効になるため）、すべてのセッションに適用する必要がある場合でも、この方法で新しいモジュールを追加する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="a2719b729cd7a399352ec70d46ec3bef1938f299" translate="yes" xml:space="preserve">
          <source>The intent of this feature is to allow unprivileged users to load debugging or performance-measurement libraries into specific sessions without requiring an explicit &lt;code&gt;LOAD&lt;/code&gt; command. To that end, it would be typical to set this parameter using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable on the client or by using &lt;code&gt;ALTER ROLE SET&lt;/code&gt;.</source>
          <target state="translated">この機能の目的は、特権を持たないユーザーが明示的な &lt;code&gt;LOAD&lt;/code&gt; コマンドを必要とせずに、デバッグまたはパフォーマンス測定ライブラリを特定のセッションにロードできるようにすることです。そのためには、クライアントで &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を使用するか、 &lt;code&gt;ALTER ROLE SET&lt;/code&gt; を使用して、このパラメーターを設定するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="410143821cb3667d869f89c45a8792b1a3405b2c" translate="yes" xml:space="preserve">
          <source>The interface was changed in version 8.4, to reflect the new FSM implementation introduced in the same version.</source>
          <target state="translated">同バージョンで導入された新しいFSM実装を反映させるために、バージョン8.4でインターフェースが変更されました。</target>
        </trans-unit>
        <trans-unit id="e6f5b2286acbba014ef24a9c86063e430de3bd3b" translate="yes" xml:space="preserve">
          <source>The internal representation of one value of an SQL data type.</source>
          <target state="translated">SQLデータ型の1つの値の内部表現。</target>
        </trans-unit>
        <trans-unit id="2585564a6c8456926cf3442c468ac844142dcda1" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type (&lt;code&gt;xid&lt;/code&gt;) is 32 bits wide and wraps around every 4 billion transactions. However, these functions export a 64-bit format that is extended with an &amp;ldquo;epoch&amp;rdquo; counter so it will not wrap around during the life of an installation. The data type used by these functions, &lt;code&gt;txid_snapshot&lt;/code&gt;, stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;.</source>
          <target state="translated">内部トランザクションIDタイプ（ &lt;code&gt;xid&lt;/code&gt; ）は32ビット幅で、40億トランザクションごとにラップされます。ただし、これらの関数は、「エポック」カウンターで拡張された64ビット形式をエクスポートするため、インストールの存続期間中にラップアラウンドしません。これらの関数で使用されるデータ型 &lt;code&gt;txid_snapshot&lt;/code&gt; は、特定の時点でのトランザクションIDの可視性に関する情報を格納します。そのコンポーネントを&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT-PARTS&quot;&gt;表9.75に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5975b3720301fef7c0533cfc1f13765af09e30a8" translate="yes" xml:space="preserve">
          <source>The internal transaction ID type &lt;code&gt;xid&lt;/code&gt; is 32 bits wide and wraps around every 4 billion transactions. However, the functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; use a 64-bit type &lt;code&gt;xid8&lt;/code&gt; that does not wrap around during the life of an installation, and can be converted to &lt;code&gt;xid&lt;/code&gt; by casting if required. The data type &lt;code&gt;pg_snapshot&lt;/code&gt; stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;. &lt;code&gt;pg_snapshot&lt;/code&gt;'s textual representation is &lt;code&gt;xmin:xmax:xip_list&lt;/code&gt;. For example &lt;code&gt;10:20:10,14,15&lt;/code&gt; means &lt;code&gt;xmin=10, xmax=20, xip_list=10, 14, 15&lt;/code&gt;.</source>
          <target state="translated">The internal transaction ID type &lt;code&gt;xid&lt;/code&gt; is 32 bits wide and wraps around every 4 billion transactions. However, the functions shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT&quot;&gt;Table 9.74&lt;/a&gt; use a 64-bit type &lt;code&gt;xid8&lt;/code&gt; that does not wrap around during the life of an installation, and can be converted to &lt;code&gt;xid&lt;/code&gt; by casting if required. The data type &lt;code&gt;pg_snapshot&lt;/code&gt; stores information about transaction ID visibility at a particular moment in time. Its components are described in &lt;a href=&quot;functions-info#FUNCTIONS-PG-SNAPSHOT-PARTS&quot;&gt;Table 9.75&lt;/a&gt;. &lt;code&gt;pg_snapshot&lt;/code&gt; 's textual representation is &lt;code&gt;xmin:xmax:xip_list&lt;/code&gt; . For example &lt;code&gt;10:20:10,14,15&lt;/code&gt; means &lt;code&gt;xmin=10, xmax=20, xip_list=10, 14, 15&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed88f1a587353da5320c94618461fa62d026126f" translate="yes" xml:space="preserve">
          <source>The inverse operation, producing a character string value from &lt;code&gt;xml&lt;/code&gt;, uses the function &lt;code&gt;xmlserialize&lt;/code&gt;:</source>
          <target state="translated">逆の操作は、 &lt;code&gt;xml&lt;/code&gt; から文字列値を生成し、関数 &lt;code&gt;xmlserialize&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7d6e11429a0e8345e13107b3c0d526111bff86da" translate="yes" xml:space="preserve">
          <source>The isolation level of a transaction determines what data the transaction can see when other transactions are running concurrently:</source>
          <target state="translated">トランザクションの分離レベルは、他のトランザクションが同時に実行されているときに、そのトランザクションが見ることができるデータを決定します。</target>
        </trans-unit>
        <trans-unit id="e2ee987ab1ca440434d3e02dd908e8550d18dae5" translate="yes" xml:space="preserve">
          <source>The items themselves are stored in space allocated backwards from the end of unallocated space. The exact structure varies depending on what the table is to contain. Tables and sequences both use a structure named &lt;code&gt;HeapTupleHeaderData&lt;/code&gt;, described below.</source>
          <target state="translated">アイテム自体は、未割り当てスペースの最後から後方に割り当てられたスペースに格納されます。正確な構造は、テーブルに何を含めるかによって異なります。テーブルとシーケンスはどちらも、以下で説明する &lt;code&gt;HeapTupleHeaderData&lt;/code&gt; という名前の構造を使用します。</target>
        </trans-unit>
        <trans-unit id="e475eb2d988c6851551d574040f066c9556a439f" translate="yes" xml:space="preserve">
          <source>The join condition of an inner join can be written either in the &lt;code&gt;WHERE&lt;/code&gt; clause or in the &lt;code&gt;JOIN&lt;/code&gt; clause. For example, these table expressions are equivalent:</source>
          <target state="translated">内部結合の結合条件は、 &lt;code&gt;WHERE&lt;/code&gt; 句または &lt;code&gt;JOIN&lt;/code&gt; 句で記述できます。たとえば、次のテーブル式は同等です。</target>
        </trans-unit>
        <trans-unit id="61d61ab7e2b00d48bd33fdcfe38f2676100e3a4c" translate="yes" xml:space="preserve">
          <source>The join condition specified with &lt;code&gt;ON&lt;/code&gt; can also contain conditions that do not relate directly to the join. This can prove useful for some queries but needs to be thought out carefully. For example:</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; で指定された結合条件には、結合に直接関係しない条件を含めることもできます。これは、一部のクエリでは役立つ場合がありますが、慎重に検討する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="3614aab2546a7b09e20ddc9fc01ce0160043ffc8" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator.</source>
          <target state="translated">この演算子の結合選択性推定関数。</target>
        </trans-unit>
        <trans-unit id="d643834432c9495e055ac02fd710963d0e899ceb" translate="yes" xml:space="preserve">
          <source>The join selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">この演算子の結合選択性推定関数。</target>
        </trans-unit>
        <trans-unit id="105b61ba49be801d77c8efa5f2d2e79da5107648" translate="yes" xml:space="preserve">
          <source>The journal that keeps track of the changes in the &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; as user- and system-invoked operations take place. It comprises many individual &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; written sequentially to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="translated">The journal that keeps track of the changes in the &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; as user- and system-invoked operations take place. It comprises many individual &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; written sequentially to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e444824ca1c6f24ef2a354622bc8815bf038f6fd" translate="yes" xml:space="preserve">
          <source>The key and parent-key fields can be any data type, but they must be the same type. Note that the &lt;em&gt;&lt;code&gt;start_with&lt;/code&gt;&lt;/em&gt; value must be entered as a text string, regardless of the type of the key field.</source>
          <target state="translated">キーフィールドと親キーフィールドは任意のデータ型にすることができますが、同じ型でなければなりません。&lt;em&gt; &lt;code&gt;start_with&lt;/code&gt; &lt;/em&gt;値は、キーフィールドのタイプに関係なく、テキスト文字列として入力する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5ed049b1b7aaa3ba51ad6c118d926aadc8da74a8" translate="yes" xml:space="preserve">
          <source>The key field(s) for the index are specified as column names, or alternatively as expressions written in parentheses. Multiple fields can be specified if the index method supports multicolumn indexes.</source>
          <target state="translated">インデックスのキーフィールドは、カラム名で指定するか、あるいは括弧内の式で指定します。インデックスメソッドがマルチカラムインデックスをサポートしている場合は、複数のフィールドを指定することができます。</target>
        </trans-unit>
        <trans-unit id="d640126eef92261555823243becabed1414b9599" translate="yes" xml:space="preserve">
          <source>The key part of a catalog header file is a C structure definition describing the layout of each row of the catalog. This begins with a &lt;code&gt;CATALOG&lt;/code&gt; macro, which so far as the C compiler is concerned is just shorthand for &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt;. Each field in the struct gives rise to a catalog column. Fields can be annotated using the BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, for example to define a default value for a field or mark it as nullable or not nullable. The &lt;code&gt;CATALOG&lt;/code&gt; line can also be annotated, with some other BKI property macros described in &lt;code&gt;genbki.h&lt;/code&gt;, to define other properties of the catalog as a whole, such as whether it is a shared relation.</source>
          <target state="translated">カタログヘッダーファイルの重要な部分は、カタログの各行のレイアウトを記述するC構造体の定義です。これは、 &lt;code&gt;CATALOG&lt;/code&gt; マクロで始まります。Cコンパイラに関する限り、これは &lt;code&gt;typedef struct FormData_catalogname&lt;/code&gt; の省略形です。構造体の各フィールドは、カタログ列を生成します。 &lt;code&gt;genbki.h&lt;/code&gt; で説明されているBKIプロパティマクロを使用してフィールドに注釈を付けることができます。たとえば、フィールドのデフォルト値を定義したり、フィールドをnull可能またはnull不可としてマークしたりできます。 &lt;code&gt;CATALOG&lt;/code&gt; ラインはまた、記載されるいくつかの他のBKI性マクロと、注釈を付けることができる &lt;code&gt;genbki.h&lt;/code&gt; 例えば、共有関係であるかどうかのように、全体としてカタログの他のプロパティを定義します。</target>
        </trans-unit>
        <trans-unit id="84768082ee997613deb3f74ec096a132ad1ca977" translate="yes" xml:space="preserve">
          <source>The key part of all this is to set up a recovery configuration that describes how you want to recover and how far the recovery should run. The one thing that you absolutely must specify is the &lt;code&gt;restore_command&lt;/code&gt;, which tells PostgreSQL how to retrieve archived WAL file segments. Like the &lt;code&gt;archive_command&lt;/code&gt;, this is a shell command string. It can contain &lt;code&gt;%f&lt;/code&gt;, which is replaced by the name of the desired log file, and &lt;code&gt;%p&lt;/code&gt;, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write &lt;code&gt;%%&lt;/code&gt; if you need to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. The simplest useful command is something like:</source>
          <target state="translated">これらすべての重要な部分は、どのように回復したいか、どの程度回復を実行する必要があるかを説明する回復構成をセットアップすることです。絶対に指定する必要があるのは、 &lt;code&gt;restore_command&lt;/code&gt; です。これは、アーカイブされたWALファイルセグメントを取得する方法をPostgreSQLに指示します。 &lt;code&gt;archive_command&lt;/code&gt; と同様に、これはシェルコマンド文字列です。これには、目的のログファイルの名前に置き換えられた &lt;code&gt;%f&lt;/code&gt; と、ログファイルのコピー先のパス名に置き換えられた &lt;code&gt;%p&lt;/code&gt; を含めることができます。 （パス名は、現在の作業ディレクトリ、つまりクラスターのデータディレクトリからの相対パスです。）コマンドに実際の &lt;code&gt;%&lt;/code&gt; 文字を埋め込む必要がある場合は、 &lt;code&gt;%%&lt;/code&gt; と記述します。最も簡単で便利なコマンドは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="6ce0e2cb46720b77226f610a445bda26007f0b40" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;COLUMN&lt;/code&gt; is noise and can be omitted.</source>
          <target state="translated">キーワード &lt;code&gt;COLUMN&lt;/code&gt; はノイズであり、省略できます。</target>
        </trans-unit>
        <trans-unit id="5b5ac0f06c70f1fb5409349bf24004b2a55d2f18" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all functions not only external ones.</source>
          <target state="translated">キーワード &lt;code&gt;EXTERNAL&lt;/code&gt; は、SQL適合のために許可されていますが、SQLとは異なり、この機能は外部関数だけでなくすべての関数に適用されるため、オプションです。</target>
        </trans-unit>
        <trans-unit id="7b66b886be54f4dad1fc59336fb968283aedd583" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;EXTERNAL&lt;/code&gt; is allowed for SQL conformance, but it is optional since, unlike in SQL, this feature applies to all procedures not only external ones.</source>
          <target state="translated">キーワード &lt;code&gt;EXTERNAL&lt;/code&gt; は、SQL準拠のために許可されていますが、SQLとは異なり、この機能は外部のプロシージャだけでなくすべてのプロシージャに適用されるため、オプションです。</target>
        </trans-unit>
        <trans-unit id="f14ab28890a5b7ef2546dae62a05463965282a2c" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ILIKE&lt;/code&gt; can be used instead of &lt;code&gt;LIKE&lt;/code&gt; to make the match case-insensitive according to the active locale. This is not in the SQL standard but is a PostgreSQL extension.</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; の代わりにキーワード &lt;code&gt;ILIKE&lt;/code&gt; を使用すると、アクティブなロケールに応じて、大文字と小文字を区別せずに一致させることができます。これはSQL標準にはありませんが、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="56bcc837725f3c99bfbefa9f4ad797df653bb446" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;PUBLIC&lt;/code&gt; indicates that the privileges are to be granted to all roles, including those that might be created later. &lt;code&gt;PUBLIC&lt;/code&gt; can be thought of as an implicitly defined group that always includes all roles. Any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;PUBLIC&lt;/code&gt; は、特権が、後で作成される可能性があるものも含めて、すべてのロールに付与されることを示します。 &lt;code&gt;PUBLIC&lt;/code&gt; は、常にすべてのロールを含む暗黙的に定義されたグループと考えることができます。特定のロールには、直接付与された権限、現在メンバーとなっているロールに付与された権限、および &lt;code&gt;PUBLIC&lt;/code&gt; に付与された権限の合計が付与されます。</target>
        </trans-unit>
        <trans-unit id="099dc57512200b2d79974967fc17d8da0e67f388" translate="yes" xml:space="preserve">
          <source>The key word &lt;code&gt;ROW&lt;/code&gt; is optional when there is more than one expression in the list.</source>
          <target state="translated">リストに複数の式がある場合、キーワード &lt;code&gt;ROW&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="f75dcd3d9f2023dad0df5e4baecf4f11764e4ecf" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;INSENSITIVE&lt;/code&gt;, and &lt;code&gt;SCROLL&lt;/code&gt; can appear in any order.</source>
          <target state="translated">キーワード &lt;code&gt;BINARY&lt;/code&gt; 、 &lt;code&gt;INSENSITIVE&lt;/code&gt; 、および &lt;code&gt;SCROLL&lt;/code&gt; は任意の順序で使用できます。</target>
        </trans-unit>
        <trans-unit id="933ba0b83729a47d657b68dbaf9310c7b7c42eff" translate="yes" xml:space="preserve">
          <source>The key words &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are the preferred (SQL-compliant) method for writing Boolean constants in SQL queries. But you can also use the string representations by following the generic string-literal constant syntax described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;, for example &lt;code&gt;'yes'::boolean&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;TRUE&lt;/code&gt; および &lt;code&gt;FALSE&lt;/code&gt; は、SQLクエリでブール定数を書き込むための推奨（SQL準拠）メソッドです。ただし、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;セクション4.1.2.7&lt;/a&gt;で説明されている一般的な文字列リテラル定数構文、たとえば &lt;code&gt;'yes'::boolean&lt;/code&gt; に従って文字列表現を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="301ce5b56290e04645decb19cd60fcc9e64d775e" translate="yes" xml:space="preserve">
          <source>The keytab file is generated by the Kerberos software; see the Kerberos documentation for details. The following example is for MIT-compatible Kerberos 5 implementations:</source>
          <target state="translated">keytabファイルはKerberosソフトウェアによって生成されます。以下の例は、MIT互換のKerberos 5の実装のためのものです。</target>
        </trans-unit>
        <trans-unit id="77aaa5ebf06bbbd98db8e2f5ba28cce520375eb5" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;ANY&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt;&lt;code&gt;num_sync&lt;/code&gt; listed standbys. For example, a setting of &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to proceed as soon as at least any three standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; reply.</source>
          <target state="translated">キーワード &lt;code&gt;ANY&lt;/code&gt; は、 &lt;code&gt;num_sync&lt;/code&gt; と組み合わせて、クォーラムベースの同期レプリケーションを指定し、WALレコードが&lt;em&gt;少なくとも&lt;/em&gt; &lt;code&gt;num_sync&lt;/code&gt; リストされたスタンバイに複製されるまでトランザクションコミットを待機させます。たとえば、 &lt;code&gt;ANY 3 (s1, s2, s3, s4)&lt;/code&gt; を設定すると、 &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; の少なくとも3つのスタンバイが応答するとすぐに、各コミットが続行されます。</target>
        </trans-unit>
        <trans-unit id="f98af4e22fce388807986209bcfe098613dae4c1" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;FIRST&lt;/code&gt;, coupled with &lt;code&gt;num_sync&lt;/code&gt;, specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;code&gt;num_sync&lt;/code&gt; synchronous standbys chosen based on their priorities. For example, a setting of &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; will cause each commit to wait for replies from three higher-priority standbys chosen from standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt;. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby. The keyword &lt;code&gt;FIRST&lt;/code&gt; is optional.</source>
          <target state="translated">キーワード &lt;code&gt;FIRST&lt;/code&gt; を &lt;code&gt;num_sync&lt;/code&gt; と組み合わせて使用すると、優先度ベースの同期レプリケーションが指定され、WALレコードが優先度に基づいて選択された &lt;code&gt;num_sync&lt;/code&gt; 同期スタンバイに複製されるまで、トランザクションコミットが待機します。たとえば、 &lt;code&gt;FIRST 3 (s1, s2, s3, s4)&lt;/code&gt; は、各コミットは、スタンバイサーバー &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; から選択された3つの優先順位の高いスタンバイからの応答を待機します。。リストの最初の方に名前が表示されているスタンバイには、より高い優先順位が与えられ、同期と見なされます。このリストの後半にある他のスタンバイサーバーは、潜在的な同期スタンバイを表しています。現在の同期スタンバイのいずれかが何らかの理由で切断された場合、すぐに次に優先順位の高いスタンバイに置き換えられます。キーワード &lt;code&gt;FIRST&lt;/code&gt; はオプションです。</target>
        </trans-unit>
        <trans-unit id="c6753d4b26b83ec9737507aab616ad0a90dffe5e" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write and will be stored on disk.</source>
          <target state="translated">キーワード &lt;code&gt;STORED&lt;/code&gt; は、列が書き込み時に計算され、ディスクに格納されることを示すために必要です。</target>
        </trans-unit>
        <trans-unit id="436779e1054adc0e89a0677ecb406409dda7f240" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; is required to signify that the column will be computed on write. (The computed value will be presented to the foreign-data wrapper for storage and must be returned on reading.)</source>
          <target state="translated">列が書き込み時に計算されることを示すには、キーワード &lt;code&gt;STORED&lt;/code&gt; が必要です。（計算された値は、格納のために外部データラッパーに提示され、読み取り時に返される必要があります。）</target>
        </trans-unit>
        <trans-unit id="5edd7a55d1b24539fc9cfa0bcf24706822731dd3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;STORED&lt;/code&gt; must be specified to choose the stored kind of generated column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">保存された種類の生成された列を選択するには、キーワード &lt;code&gt;STORED&lt;/code&gt; を指定する必要があります。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e643395261c7f81c30fc2a4e61b7aaf97e975625" translate="yes" xml:space="preserve">
          <source>The label provider associated with this label.</source>
          <target state="translated">このラベルに関連付けられたラベルプロバイダ。</target>
        </trans-unit>
        <trans-unit id="468c79531b62d3d36755c25fe6c2c2d1c6c04f9c" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SE-Linux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">ラベル提供者は、与えられたラベルが有効であるかどうか、そしてそのラベルを与えられたオブジェクトに割り当てることが許されるかどうかを決定する。与えられたラベルの意味も同様に、ラベル提供者の裁量に委ねられています。PostgreSQLは、ラベルプロバイダがセキュリティラベルを解釈しなければならないかどうか、あるいはどのように解釈しなければならないかについての制限を設けていません。実際には、この機能はSE-Linuxのようなラベルベースの強制アクセス制御(MAC)システムとの統合を可能にすることを意図しています。このようなシステムでは、ユーザやグループなどの従来の裁量アクセス制御(DAC)の概念ではなく、オブジェクトラベルに基づいてすべてのアクセス制御の決定を行います。</target>
        </trans-unit>
        <trans-unit id="8eaf1d04fc556db25e421838f63ccbd315696008" translate="yes" xml:space="preserve">
          <source>The label provider determines whether a given label is valid and whether it is permissible to assign that label to a given object. The meaning of a given label is likewise at the discretion of the label provider. PostgreSQL places no restrictions on whether or how a label provider must interpret security labels; it merely provides a mechanism for storing them. In practice, this facility is intended to allow integration with label-based mandatory access control (MAC) systems such as SELinux. Such systems make all access control decisions based on object labels, rather than traditional discretionary access control (DAC) concepts such as users and groups.</source>
          <target state="translated">ラベル提供者は、与えられたラベルが有効であるかどうか、そしてそのラベルを与えられたオブジェクトに割り当てることが許されるかどうかを決定する。与えられたラベルの意味も同様に、ラベル提供者の裁量に委ねられています。PostgreSQLは、ラベルプロバイダがセキュリティラベルを解釈しなければならないかどうか、あるいはどのように解釈しなければならないかについての制限を設けていません。実際には、この機能はSELinuxのようなラベルベースの強制アクセス制御(MAC)システムとの統合を可能にすることを意図しています。そのようなシステムは、ユーザやグループのような伝統的な裁量アクセス制御(DAC)の概念ではなく、オブジェクトラベルに基づいてすべてのアクセス制御の決定を行います。</target>
        </trans-unit>
        <trans-unit id="e2fab09475b65e9983ce79215513aca004922a64" translate="yes" xml:space="preserve">
          <source>The lag times reported in the &lt;code&gt;pg_stat_replication&lt;/code&gt; view are measurements of the time taken for recent WAL to be written, flushed and replayed and for the sender to know about it. These times represent the commit delay that was (or would have been) introduced by each synchronous commit level, if the remote server was configured as a synchronous standby. For an asynchronous standby, the &lt;code&gt;replay_lag&lt;/code&gt; column approximates the delay before recent transactions became visible to queries. If the standby server has entirely caught up with the sending server and there is no more WAL activity, the most recently measured lag times will continue to be displayed for a short time and then show NULL.</source>
          <target state="translated">&lt;code&gt;pg_stat_replication&lt;/code&gt; ビューで報告されるラグタイムは、最近のWALが書き込まれ、フラッシュされ、再生され、送信者がそれを知るのにかかる時間の測定値です。これらの時間は、リモートサーバーが同期スタンバイとして構成されている場合に、各同期コミットレベルによって導入された（または導入されたであろう）コミット遅延を表します。非同期スタンバイの場合、 &lt;code&gt;replay_lag&lt;/code&gt; 列は、最近のトランザクションがクエリに表示されるまでの遅延を概算します。スタンバイサーバーが送信サーバーに完全に追いついて、WALアクティビティがなくなった場合、最後に測定されたラグタイムがしばらく表示され続け、その後NULLが表示されます。</target>
        </trans-unit>
        <trans-unit id="eb0c7351bd920c1bdbdffe727ba791d1a927eafe" translate="yes" xml:space="preserve">
          <source>The largest part of shared memory is known as &lt;em&gt;shared buffers&lt;/em&gt; and is used to mirror part of data files, organized into pages. When a page is modified, it is called a dirty page until it is written back to the file system.</source>
          <target state="translated">The largest part of shared memory is known as &lt;em&gt;shared buffers&lt;/em&gt; and is used to mirror part of data files, organized into pages. When a page is modified, it is called a dirty page until it is written back to the file system.</target>
        </trans-unit>
        <trans-unit id="bee0490b803b85b6819bd67e0eb5d37f8061673f" translate="yes" xml:space="preserve">
          <source>The largest statistics target among the columns being analyzed determines the number of table rows sampled to prepare the statistics. Increasing the target causes a proportional increase in the time and space needed to do &lt;code&gt;ANALYZE&lt;/code&gt;.</source>
          <target state="translated">分析される列の中で最大の統計ターゲットは、統計を準備するためにサンプリングされるテーブル行の数を決定します。ターゲットを増やすと、 &lt;code&gt;ANALYZE&lt;/code&gt; を実行するために必要な時間とスペースが比例して増加します。</target>
        </trans-unit>
        <trans-unit id="08ac6817284c2739892a594416144a19a2fc3c3b" translate="yes" xml:space="preserve">
          <source>The last example shows that the checks include whether namespaces are correctly matched.</source>
          <target state="translated">最後の例では、名前空間が正しくマッチしているかどうかのチェックが含まれていることを示しています。</target>
        </trans-unit>
        <trans-unit id="b141d1efe06f21d25a717b844dfa4141ae98f099" translate="yes" xml:space="preserve">
          <source>The last five parameters are pass-by-reference outputs:</source>
          <target state="translated">最後の5つのパラメータは、パスバイレファレンス出力です。</target>
        </trans-unit>
        <trans-unit id="640860dcca4728ae99db3adc4362cf72e26f4370" translate="yes" xml:space="preserve">
          <source>The last line could also be:</source>
          <target state="translated">最後の一行も可能性があります。</target>
        </trans-unit>
        <trans-unit id="a268591c13ee52793b16cb868a71b9f235920223" translate="yes" xml:space="preserve">
          <source>The last line is useful in verifying that the client is trying to connect to the right place. If there is in fact no server running there, the kernel error message will typically be either &lt;code&gt;Connection refused&lt;/code&gt; or &lt;code&gt;No such file or directory&lt;/code&gt;, as illustrated. (It is important to realize that &lt;code&gt;Connection refused&lt;/code&gt; in this context does &lt;em&gt;not&lt;/em&gt; mean that the server got your connection request and rejected it. That case will produce a different message, as shown in &lt;a href=&quot;client-authentication-problems&quot;&gt;Section 20.15&lt;/a&gt;.) Other error messages such as &lt;code&gt;Connection timed out&lt;/code&gt; might indicate more fundamental problems, like lack of network connectivity.</source>
          <target state="translated">最後の行は、クライアントが正しい場所に接続しようとしていることを確認するのに役立ちます。実際にサーバーが実行されていない場合、図に示すように、通常、カーネルエラーメッセージは[ &lt;code&gt;Connection refused&lt;/code&gt; または[ &lt;code&gt;No such file or directory&lt;/code&gt; はありません]になります。 （それはそれを認識することが重要である &lt;code&gt;Connection refused&lt;/code&gt; んこのコンテキストでは&lt;em&gt;ない&lt;/em&gt;サーバーは、接続要求を持って、それを拒否したことを意味する。に示すように、ケースには、異なるメッセージを生成することを&lt;a href=&quot;client-authentication-problems&quot;&gt;節20.15&lt;/a&gt;。）のような他のエラーメッセージ &lt;code&gt;Connection timed out&lt;/code&gt; かもしれないがネットワーク接続の不足など、より根本的な問題を示します。</target>
        </trans-unit>
        <trans-unit id="cca952ade3d373926896de08f3f6cd0f1c245369" translate="yes" xml:space="preserve">
          <source>The last line printed out by &lt;code&gt;psql&lt;/code&gt; is the prompt, and it indicates that &lt;code&gt;psql&lt;/code&gt; is listening to you and that you can type SQL queries into a work space maintained by &lt;code&gt;psql&lt;/code&gt;. Try out these commands:</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; によって出力される最後の行はプロンプトです。これは、 &lt;code&gt;psql&lt;/code&gt; がユーザーの言うことを聞いており、SQLクエリを &lt;code&gt;psql&lt;/code&gt; によって維持されているワークスペースに入力できることを示しています。次のコマンドを試してください：</target>
        </trans-unit>
        <trans-unit id="4a2bf24f5739dd825710ff53126984ef2f6e0852" translate="yes" xml:space="preserve">
          <source>The last modification time of the file as reported by the server at the time of the backup. Unlike the other fields stored in the backup, this field is not used by &lt;a href=&quot;app-pgverifybackup&quot;&gt;pg_verifybackup&lt;/a&gt;. It is included only for informational purposes.</source>
          <target state="translated">The last modification time of the file as reported by the server at the time of the backup. Unlike the other fields stored in the backup, this field is not used by &lt;a href=&quot;app-pgverifybackup&quot;&gt;pg_verifybackup&lt;/a&gt;. It is included only for informational purposes.</target>
        </trans-unit>
        <trans-unit id="eb5a300b26673b4a75043297a6f146dcd49c5439" translate="yes" xml:space="preserve">
          <source>The last sequence value written to disk. If caching is used, this value can be greater than the last value handed out from the sequence. Null if the sequence has not been read from yet. Also, if the current user does not have &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence, the value is null.</source>
          <target state="translated">ディスクに書き込まれた最後のシーケンス値。キャッシングを使用する場合、この値はシーケンスから渡される最後の値よりも大きくなる可能性があります。シーケンスがまだ読み取られていない場合はnull。また、現在のユーザーがシーケンスに対する &lt;code&gt;USAGE&lt;/code&gt; または &lt;code&gt;SELECT&lt;/code&gt; 特権を持っていない場合、値はnullです。</target>
        </trans-unit>
        <trans-unit id="3ddb6dca4d033d643b4947fa1e0c4bfe448712f8" translate="yes" xml:space="preserve">
          <source>The last six input formats shown above are not part of any standard.</source>
          <target state="translated">上記の最後の6つの入力フォーマットは、どの規格にも属していません。</target>
        </trans-unit>
        <trans-unit id="8146be3b6220418f9831589eda3884a4555e4dfa" translate="yes" xml:space="preserve">
          <source>The last two states are seen only when &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; is non-negative. If &lt;code&gt;restart_lsn&lt;/code&gt; is NULL, this field is null.</source>
          <target state="translated">The last two states are seen only when &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; is non-negative. If &lt;code&gt;restart_lsn&lt;/code&gt; is NULL, this field is null.</target>
        </trans-unit>
        <trans-unit id="5fe313657b9f725a4a4c3652ad1d9e1c661ac0d8" translate="yes" xml:space="preserve">
          <source>The latter is syntactically valid, but it represents a call of a single-argument aggregate function with two &lt;code&gt;ORDER BY&lt;/code&gt; keys (the second one being rather useless since it's a constant).</source>
          <target state="translated">後者は構文的には有効ですが、2つの &lt;code&gt;ORDER BY&lt;/code&gt; キーを使用した単一引数の集約関数の呼び出しを表しています（2番目の関数は定数なので、あまり役に立ちません）。</target>
        </trans-unit>
        <trans-unit id="ec920275f2c822a2a5adceef23c754e25dadccba" translate="yes" xml:space="preserve">
          <source>The lax mode facilitates matching of a JSON document structure and path expression if the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array or unwrapped by converting its elements into an SQL/JSON sequence before performing this operation. Besides, comparison operators automatically unwrap their operands in the lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed only when:</source>
          <target state="translated">ゆるいモードは、JSONデータが期待されるスキーマに適合しない場合に、JSON文書構造とパス式のマッチングを容易にします。オペランドが特定の操作の要件に一致しない場合、そのオペランドは自動的にSQL/JSON配列としてラップされるか、その操作を実行する前にその要素をSQL/JSONシーケンスに変換してアンラップすることができます。また、比較演算子は自動的に緩いモードでオペランドをアンラップするので、SQL/JSON配列をすぐに比較することができます。サイズ1の配列は、その唯一の要素と等しいとみなされます。自動アンラップは、以下の場合にのみ実行されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="c52a670d06775855c2164b78f437c77c8a3136cd" translate="yes" xml:space="preserve">
          <source>The least downtime can be achieved by installing the new server in a different directory and running both the old and the new servers in parallel, on different ports. Then you can use something like:</source>
          <target state="translated">新しいサーバを別のディレクトリにインストールし、古いサーバと新しいサーバを別々のポートで並行して実行することで、ダウンタイムを最小限に抑えることができます。そうすれば、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="082fd8f2f5ff84b43f58645d6265cd8d6ba42c18" translate="yes" xml:space="preserve">
          <source>The left-hand side is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. Furthermore, the subquery cannot return more than one row. (If it returns zero rows, the result is taken to be null.) The left-hand side is evaluated and compared row-wise to the single subquery result row.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。さらに、サブクエリは複数の行を返すことはできません。 （ゼロ行を返す場合、結果はnullと見なされます。）左側が評価され、行ごとに単一のサブクエリ結果行と比較されます。</target>
        </trans-unit>
        <trans-unit id="f44070270517992cebfd8a7909698b4367aa0cae" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ALL&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for all subquery rows (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for any subquery row. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、この形式の &lt;code&gt;ALL&lt;/code&gt; の左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して、サブクエリの結果の各行と行ごとに比較されます。 &lt;code&gt;ALL&lt;/code&gt; の結果は、比較がすべてのサブクエリ行に対してtrueを返す場合（サブクエリが行を返さない場合を含む）は「true」です。比較がサブクエリ行に対してfalseを返す場合、結果は「false」です。サブクエリ行との比較がfalseを返さず、少なくとも1つの比較がNULLを返す場合、結果はNULLです。</target>
        </trans-unit>
        <trans-unit id="3a495b6469d287a27574f63256e96477ed641f86" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;ANY&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result, using the given &lt;code&gt;operator&lt;/code&gt;. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if the comparison returns true for any subquery row. The result is &amp;ldquo;false&amp;rdquo; if the comparison returns false for every subquery row (including the case where the subquery returns no rows). The result is NULL if no comparison with a subquery row returns true, and at least one comparison returns NULL.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、この形式の &lt;code&gt;ANY&lt;/code&gt; の左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して、サブクエリの結果の各行と行ごとに比較されます。比較がサブクエリ行に対してtrueを返す場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は「true」です。比較がすべてのサブクエリ行に対してfalseを返す場合（サブクエリが行を返さない場合を含む）、結果は「false」です。サブクエリ行との比較がtrueを返さず、少なくとも1つの比較がNULLを返す場合、結果はNULLです。</target>
        </trans-unit>
        <trans-unit id="afdaf261917f03fc0c447e59e3d5a8be456d89c2" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">この &lt;code&gt;IN&lt;/code&gt; の形式の左側は、&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されている行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、行ごとにサブクエリの結果の各行と比較されます。等しいサブクエリ行が見つかった場合、 &lt;code&gt;IN&lt;/code&gt; の結果は「true」です。等しい行が見つからない場合（サブクエリが行を返さない場合を含む）、結果は「false」になります。</target>
        </trans-unit>
        <trans-unit id="a1d433de59d411f27b86b3382eba3a1fea3e9e5d" translate="yes" xml:space="preserve">
          <source>The left-hand side of this form of &lt;code&gt;NOT IN&lt;/code&gt; is a row constructor, as described in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;Section 4.2.13&lt;/a&gt;. The right-hand side is a parenthesized subquery, which must return exactly as many columns as there are expressions in the left-hand row. The left-hand expressions are evaluated and compared row-wise to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;セクション4.2.13で&lt;/a&gt;説明されているように、この形式の &lt;code&gt;NOT IN&lt;/code&gt; の左側は行コンストラクタです。右側は括弧で囲まれたサブクエリで、左側の行の式と同じ数の列を返す必要があります。左側の式が評価され、行ごとにサブクエリの結果の各行と比較されます。等しくないサブクエリ行のみが見つかった場合（サブクエリが行を返さない場合を含む）、 &lt;code&gt;NOT IN&lt;/code&gt; の結果は「true」になります。等しい行が見つかった場合、結果は「false」です。</target>
        </trans-unit>
        <trans-unit id="4585d75ed76ee1f40b5daa39dfcad2d39fb7784d" translate="yes" xml:space="preserve">
          <source>The left-of/right-of/adjacent operators always return false when an empty range is involved; that is, an empty range is not considered to be either before or after any other range.</source>
          <target state="translated">left-of/right-of/adjacent演算子は、空の範囲が含まれている場合は常にfalseを返します。</target>
        </trans-unit>
        <trans-unit id="2f5d1e6e1b59ebb3b7a2ceefdc5f69123a880bd7" translate="yes" xml:space="preserve">
          <source>The length of a &lt;code&gt;tsvector&lt;/code&gt; (lexemes + positions) must be less than 1 megabyte</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; （語彙目+位置）の長さは1メガバイト未満でなければなりません</target>
        </trans-unit>
        <trans-unit id="fb55102e4d77862d8595a399532f60d05305a61a" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2 kilobytes</source>
          <target state="translated">各字句の長さは2キロバイト以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="72cf9ee51b093da890b7dcc27caaf482e19db7ab" translate="yes" xml:space="preserve">
          <source>The length of each lexeme must be less than 2K bytes</source>
          <target state="translated">各字句の長さは2Kバイト以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="07e3cb5f7b40e6d63b3d5d01d67980671a6f7bf1" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">ライブラリファイル名は通常、サーバーのライブラリ検索パス（&lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;によって設定）で検索される、単なるファイル名として与えられます。または、フルパス名で指定することもできます。どちらの場合も、プラットフォームの標準共有ライブラリのファイル名拡張子は省略できます。このトピックの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;セクション37.10.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca07c214a1fa57e76fa5efc5dc421655af5b85fc" translate="yes" xml:space="preserve">
          <source>The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</source>
          <target state="translated">The library file name is typically given as just a bare file name, which is sought in the server's library search path (set by &lt;a href=&quot;runtime-config-client#GUC-DYNAMIC-LIBRARY-PATH&quot;&gt;dynamic_library_path&lt;/a&gt;). Alternatively it can be given as a full path name. In either case the platform's standard shared library file name extension may be omitted. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-c.html#XFUNC-C-DYNLOAD&quot;&gt;Section 37.10.1&lt;/a&gt; for more information on this topic.</target>
        </trans-unit>
        <trans-unit id="eb9d5172bb2076ce6b62f3e5058e20954eddcb55" translate="yes" xml:space="preserve">
          <source>The libxml2 library does seem to always return node-sets to PostgreSQL with their members in the same relative order they had in the input document. Its documentation does not commit to this behavior, and an XPath 1.0 expression cannot control it.</source>
          <target state="translated">libxml2ライブラリは常にノードセットをPostgreSQLに返し、そのメンバを入力ドキュメントと同じ相対順序で返しているようです。ドキュメントではこの動作はコミットされておらず、XPath 1.0の式では制御できません。</target>
        </trans-unit>
        <trans-unit id="e92855a9b20ea0f884a230e63ef7768d88fd5352" translate="yes" xml:space="preserve">
          <source>The limitations of pg_restore are detailed below.</source>
          <target state="translated">pg_restoreの制限事項を以下に詳述します。</target>
        </trans-unit>
        <trans-unit id="87e598717783e82b1e191a7f90cf401c4ee0b779" translate="yes" xml:space="preserve">
          <source>The line number inside the current statement, starting from &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">現在のステートメント内の &lt;code&gt;1&lt;/code&gt; から始まる行番号。</target>
        </trans-unit>
        <trans-unit id="d10565a24d6154d743d122e032098869756ae365" translate="yes" xml:space="preserve">
          <source>The list below shows the available lock modes and the contexts in which they are used automatically by PostgreSQL. You can also acquire any of these locks explicitly with the command &lt;a href=&quot;sql-lock&quot;&gt;LOCK&lt;/a&gt;. Remember that all of these lock modes are table-level locks, even if the name contains the word &amp;ldquo;row&amp;rdquo;; the names of the lock modes are historical. To some extent the names reflect the typical usage of each lock mode &amp;mdash; but the semantics are all the same. The only real difference between one lock mode and another is the set of lock modes with which each conflicts (see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;). Two transactions cannot hold locks of conflicting modes on the same table at the same time. (However, a transaction never conflicts with itself. For example, it might acquire &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock and later acquire &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock on the same table.) Non-conflicting lock modes can be held concurrently by many transactions. Notice in particular that some lock modes are self-conflicting (for example, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock cannot be held by more than one transaction at a time) while others are not self-conflicting (for example, an &lt;code&gt;ACCESS SHARE&lt;/code&gt; lock can be held by multiple transactions).</source>
          <target state="translated">以下のリストは、PostgreSQLによって自動的に使用される使用可能なロックモードとコンテキストを示しています。コマンド&lt;a href=&quot;sql-lock&quot;&gt;LOCKを使用&lt;/a&gt;して、これらのロックを明示的に取得することもできます。名前に「行」という単語が含まれている場合でも、これらのロックモードはすべてテーブルレベルのロックであることを忘れないでください。ロックモードの名前は歴史的なものです。名前は、各ロックモードの一般的な使用法をある程度反映していますが、セマンティクスはすべて同じです。あるロックモードと別のロックモードの唯一の実際の違いは、それぞれが競合するロックモードのセットです（&lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;表13.2を&lt;/a&gt;参照）。 2つのトランザクションは、同じテーブル上で競合するモードのロックを同時に保持することはできません。 （ただし、トランザクションはそれ自体と競合することはありません。たとえば、 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; を取得する場合があります。ロックし、後で同じテーブルで &lt;code&gt;ACCESS SHARE&lt;/code&gt; ロックを取得します。）競合しないロックモードは、多くのトランザクションで同時に保持できます。特に、いくつかのロックモードは自己矛盾している（たとえば、 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックは一度に複数のトランザクションで保持できない）一方で、他のモードは自己矛盾していない（たとえば、 &lt;code&gt;ACCESS SHARE&lt;/code&gt; ロックは複数のトランザクション）。</target>
        </trans-unit>
        <trans-unit id="4e69c1b0ac656b6b15e1946ebe2102bdb20487dd" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">組み込み関数のリストは&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章にあり&lt;/a&gt;ます。その他の機能はユーザーが追加できます。</target>
        </trans-unit>
        <trans-unit id="98078b1844b2f5121863d76d0e6ccd8659c9a105" translate="yes" xml:space="preserve">
          <source>The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</source>
          <target state="translated">The list of built-in functions is in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. Other functions can be added by the user.</target>
        </trans-unit>
        <trans-unit id="034ee84c98b899e3f08ab6a22f176f2b0b9c945d" translate="yes" xml:space="preserve">
          <source>The list of output expressions after &lt;code&gt;SELECT&lt;/code&gt; can be empty, producing a zero-column result table. This is not valid syntax according to the SQL standard. PostgreSQL allows it to be consistent with allowing zero-column tables. However, an empty list is not allowed when &lt;code&gt;DISTINCT&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 後の出力式のリストを空にして、ゼロ列の結果テーブルを作成できます。これは、SQL標準では有効な構文ではありません。PostgreSQLでは、ゼロ列テーブルを許可することと一貫性を保つことができます。ただし、 &lt;code&gt;DISTINCT&lt;/code&gt; を使用する場合、空のリストは許可されません。</target>
        </trans-unit>
        <trans-unit id="8494c9c3de42f371358e2a2e5b1c91631cba7c4b" translate="yes" xml:space="preserve">
          <source>The listing file consists of a header and one line for each item, e.g.:</source>
          <target state="translated">リストファイルは、ヘッダと各項目の1行で構成されています。</target>
        </trans-unit>
        <trans-unit id="c073ed3743a7cc8517210053a4e46a167f30e3ab" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;1.2&lt;/code&gt; is of type &lt;code&gt;numeric&lt;/code&gt;, and the &lt;code&gt;integer&lt;/code&gt; value &lt;code&gt;1&lt;/code&gt; can be cast implicitly to &lt;code&gt;numeric&lt;/code&gt;, so that type is used.</source>
          <target state="translated">リテラル &lt;code&gt;1.2&lt;/code&gt; は &lt;code&gt;numeric&lt;/code&gt; 型であり、 &lt;code&gt;integer&lt;/code&gt; 値 &lt;code&gt;1&lt;/code&gt; は暗黙的に &lt;code&gt;numeric&lt;/code&gt; にキャストできるため、その型が使用されます。</target>
        </trans-unit>
        <trans-unit id="81389809d8e329e135cb6738d28db71cfa07fe84" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to archive a completed WAL file segment. Any &lt;code&gt;%p&lt;/code&gt; in the string is replaced by the path name of the file to archive, and any &lt;code&gt;%f&lt;/code&gt; is replaced by only the file name. (The path name is relative to the working directory of the server, i.e., the cluster's data directory.) Use &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command. It is important for the command to return a zero exit status only if it succeeds. For more information see &lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;Section 25.3.1&lt;/a&gt;.</source>
          <target state="translated">完了したWALファイルセグメントをアーカイブするために実行するローカルシェルコマンド。どれ &lt;code&gt;%p&lt;/code&gt; を文字列では、アーカイブへのファイルのパス名に置き換えられ、任意の &lt;code&gt;%f&lt;/code&gt; はファイル名のみに置き換えられています。 （パス名は、サーバーの作業ディレクトリ、つまりクラスターのデータディレクトリを基準にしています。） &lt;code&gt;%%&lt;/code&gt; を使用して、コマンドに実際の &lt;code&gt;%&lt;/code&gt; 文字を埋め込みます。コマンドが成功した場合にのみ、ゼロの終了ステータスを返すことが重要です。詳細については、&lt;a href=&quot;continuous-archiving#BACKUP-ARCHIVING-WAL&quot;&gt;セクション25.3.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0c6814fd70a4837bf3123c78d06664813ae5c2c3" translate="yes" xml:space="preserve">
          <source>The local shell command to execute to retrieve an archived segment of the WAL file series. This parameter is required for archive recovery, but optional for streaming replication. Any &lt;code&gt;%f&lt;/code&gt; in the string is replaced by the name of the file to retrieve from the archive, and any &lt;code&gt;%p&lt;/code&gt; is replaced by the copy destination path name on the server. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Any &lt;code&gt;%r&lt;/code&gt; is replaced by the name of the file containing the last valid restart point. That is the earliest file that must be kept to allow a restore to be restartable, so this information can be used to truncate the archive to just the minimum required to support restarting from the current restore. &lt;code&gt;%r&lt;/code&gt; is typically only used by warm-standby configurations (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">一連のWALファイルのアーカイブされたセグメントを取得するために実行するローカルシェルコマンド。このパラメーターはアーカイブの回復には必須ですが、ストリーミングレプリケーションではオプションです。どれ &lt;code&gt;%f&lt;/code&gt; を文字列では、アーカイブから取得するために、ファイルの名前に置き換えられ、任意の &lt;code&gt;%p&lt;/code&gt; は、サーバー上のコピー先のパス名に置き換えられます。 （パス名は、現在の作業ディレクトリ、つまりクラスターのデータディレクトリからの相対パスです。） &lt;code&gt;%r&lt;/code&gt; は、最後の有効な再起動ポイントを含むファイルの名前に置き換えられます。これは、復元を再開できるようにするために保持する必要がある最も古いファイルなので、この情報を使用して、現在の復元からの再開をサポートするために必要な最小限の値までアーカイブを切り捨てることができます。 &lt;code&gt;%r&lt;/code&gt; 通常は、ウォームスタンバイ構成でのみ使用されます（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2を&lt;/a&gt;参照）。書き込みは &lt;code&gt;%%&lt;/code&gt; に実際埋め込む &lt;code&gt;%&lt;/code&gt; の文字を。</target>
        </trans-unit>
        <trans-unit id="1eefb4d9f04f196c0b255cf3b0eec2ac11926c27" translate="yes" xml:space="preserve">
          <source>The locale settings influence the following SQL features:</source>
          <target state="translated">ロケール設定は、以下のSQL機能に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="7a32d4357c6c565a2645be6e8f5dcd4ff20db468" translate="yes" xml:space="preserve">
          <source>The location must be an existing, empty directory that is owned by the PostgreSQL operating system user. All objects subsequently created within the tablespace will be stored in files underneath this directory. The location must not be on removable or transient storage, as the cluster might fail to function if the tablespace is missing or lost.</source>
          <target state="translated">この場所は、PostgreSQLオペレーティングシステムユーザが所有する、既存の空のディレクトリでなければなりません。テーブル空間内に作成されたすべてのオブジェクトは、このディレクトリの下にあるファイルに格納されます。テーブルスペースがない場合や紛失した場合にクラスタが機能しなくなる可能性があるため、その場所はリムーバブルストレージや一時的なストレージ上にあってはなりません。</target>
        </trans-unit>
        <trans-unit id="b667dea533a6876f6f89e862e7e520ec6a41f7d3" translate="yes" xml:space="preserve">
          <source>The location of the history file can be set explicitly via the &lt;code&gt;HISTFILE&lt;/code&gt; psql variable or the &lt;code&gt;PSQL_HISTORY&lt;/code&gt; environment variable.</source>
          <target state="translated">履歴ファイルの場所は、 &lt;code&gt;HISTFILE&lt;/code&gt; psql変数または &lt;code&gt;PSQL_HISTORY&lt;/code&gt; 環境変数を介して明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="b9e8edabe8e574f621a1a9a4ab6a0372f27514c2" translate="yes" xml:space="preserve">
          <source>The lock mode specifies which locks this lock conflicts with. Lock modes are described in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">ロックモードは、このロックが競合するロックを指定します。ロックモードについては、&lt;a href=&quot;explicit-locking&quot;&gt;セクション13.3で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="11e9f2a01b63d9d65afbfe49635022cefcf4e76a" translate="yes" xml:space="preserve">
          <source>The locking clause has the general form</source>
          <target state="translated">ロック句は一般的な形式を持っています。</target>
        </trans-unit>
        <trans-unit id="91a41283b7fcf940c9ed38d5616364c7bd0504f5" translate="yes" xml:space="preserve">
          <source>The locking clauses cannot be used in contexts where returned rows cannot be clearly identified with individual table rows; for example they cannot be used with aggregation.</source>
          <target state="translated">ロック句は、返された行が個々のテーブル行と明確に識別できないようなコンテキストでは使用できません。</target>
        </trans-unit>
        <trans-unit id="5be2e9c7a10ee3339b74248910b8189ec3602ecb" translate="yes" xml:space="preserve">
          <source>The logging collector is designed to never lose messages. This means that in case of extremely high load, server processes could be blocked while trying to send additional log messages when the collector has fallen behind. In contrast, syslog prefers to drop messages if it cannot write them, which means it may fail to log some messages in such cases but it will not block the rest of the system.</source>
          <target state="translated">ロギングコレクターはメッセージを決して失わないように設計されています。これは、非常に高い負荷の場合、コレクターが遅れたときに追加のログメッセージを送信しようとしている間に、サーバープロセスがブロックされる可能性があることを意味します。対照的に、syslog はメッセージを書くことができない場合にはメッセージを落とすことを好みます。</target>
        </trans-unit>
        <trans-unit id="e54879093a2f0566d1aa83e68c13d2dd946cc6fd" translate="yes" xml:space="preserve">
          <source>The logical replication apply process currently only fires row triggers, not statement triggers. The initial table synchronization, however, is implemented like a &lt;code&gt;COPY&lt;/code&gt; command and thus fires both row and statement triggers for &lt;code&gt;INSERT&lt;/code&gt;.</source>
          <target state="translated">論理レプリケーション適用プロセスは現在、ステートメントトリガーではなく、行トリガーのみを起動します。ただし、初期テーブル同期は &lt;code&gt;COPY&lt;/code&gt; コマンドのように実装されているため、 &lt;code&gt;INSERT&lt;/code&gt; の行トリガーとステートメントトリガーの両方を起動します。</target>
        </trans-unit>
        <trans-unit id="497c1b112de3cb7224f97eec3f477dda0c464f33" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all points less than the upper bound are included in the range. Likewise, if the upper bound of the range is omitted, then all points greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range.</source>
          <target state="translated">範囲の下界は省略することができ、つまり、上界よりも小さい点はすべて範囲に含まれます。同様に、範囲の上界が省略されると、下界よりも大きいすべての点が範囲に含まれることを意味する。範囲の下界と上界の両方が省略された場合、その要素型のすべての値が範囲内に含まれているとみなされます。</target>
        </trans-unit>
        <trans-unit id="57c98e1829ac48ed92032df563adc8eac7513b47" translate="yes" xml:space="preserve">
          <source>The lower bound of a range can be omitted, meaning that all values less than the upper bound are included in the range, e.g., &lt;code&gt;(,3]&lt;/code&gt;. Likewise, if the upper bound of the range is omitted, then all values greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range. Specifying a missing bound as inclusive is automatically converted to exclusive, e.g., &lt;code&gt;[,]&lt;/code&gt; is converted to &lt;code&gt;(,)&lt;/code&gt;. You can think of these missing values as +/-infinity, but they are special range type values and are considered to be beyond any range element type's +/-infinity values.</source>
          <target state="translated">The lower bound of a range can be omitted, meaning that all values less than the upper bound are included in the range, e.g., &lt;code&gt;(,3]&lt;/code&gt; . Likewise, if the upper bound of the range is omitted, then all values greater than the lower bound are included in the range. If both lower and upper bounds are omitted, all values of the element type are considered to be in the range. Specifying a missing bound as inclusive is automatically converted to exclusive, e.g., &lt;code&gt;[,]&lt;/code&gt; is converted to &lt;code&gt;(,)&lt;/code&gt; . You can think of these missing values as +/-infinity, but they are special range type values and are considered to be beyond any range element type's +/-infinity values.</target>
        </trans-unit>
        <trans-unit id="d2bb8fcfd48d2a42926444acc296752b10019e69" translate="yes" xml:space="preserve">
          <source>The machine used is an Intel Mobile Core i3.</source>
          <target state="translated">使用したマシンはIntel Mobile Core i3です。</target>
        </trans-unit>
        <trans-unit id="a9f59ce368a2e8f66b6b7f102badc5b6a6bb9471" translate="yes" xml:space="preserve">
          <source>The magic that makes the two loosely coupled servers work together is simply a &lt;code&gt;restore_command&lt;/code&gt; used on the standby that, when asked for the next WAL file, waits for it to become available from the primary. Normal recovery processing would request a file from the WAL archive, reporting failure if the file was unavailable. For standby processing it is normal for the next WAL file to be unavailable, so the standby must wait for it to appear. For files ending in &lt;code&gt;.history&lt;/code&gt; there is no need to wait, and a non-zero return code must be returned. A waiting &lt;code&gt;restore_command&lt;/code&gt; can be written as a custom script that loops after polling for the existence of the next WAL file. There must also be some way to trigger failover, which should interrupt the &lt;code&gt;restore_command&lt;/code&gt;, break the loop and return a file-not-found error to the standby server. This ends recovery and the standby will then come up as a normal server.</source>
          <target state="translated">2つの疎結合サーバーを連携させる魔法は、単にスタンバイで使用される &lt;code&gt;restore_command&lt;/code&gt; であり、次のWALファイルを要求されたときに、プライマリから使用可能になるのを待ちます。通常の回復処理では、WALアーカイブからファイルを要求し、ファイルが利用できない場合は失敗を報告します。スタンバイ処理の場合、次のWALファイルが使用できなくなるのは正常であるため、スタンバイはそれが表示されるまで待機する必要があります。 &lt;code&gt;.history&lt;/code&gt; で終わるファイルの場合、待機する必要はなく、ゼロ以外の戻りコードを返す必要があります。待機中の &lt;code&gt;restore_command&lt;/code&gt; は、次のWALファイルの存在をポーリングした後にループするカスタムスクリプトとして作成できます。フェイルオーバーをトリガーするいくつかの方法も必要です。 &lt;code&gt;restore_command&lt;/code&gt; 、ループを中断し、ファイルが見つからないというエラーをスタンバイサーバーに返します。これでリカバリが終了し、スタンバイが通常のサーバーとして起動します。</target>
        </trans-unit>
        <trans-unit id="ce18091b48e231b7d70d5b7f47f40d4962ad395e" translate="yes" xml:space="preserve">
          <source>The main advantage of using the MVCC model of concurrency control rather than locking is that in MVCC locks acquired for querying (reading) data do not conflict with locks acquired for writing data, and so reading never blocks writing and writing never blocks reading. PostgreSQL maintains this guarantee even when providing the strictest level of transaction isolation through the use of an innovative &lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt; (SSI) level.</source>
          <target state="translated">ロックではなく同時実行制御のMVCCモデルを使用する主な利点は、MVCCでは、クエリ（読み取り）のために取得されたロックが、データの書き込みのために取得されたロックと競合しないため、読み取りが書き込みをブロックせず、書き込みが読み取りをブロックしないことです。PostgreSQLは、革新的な&lt;em&gt;Serializable Snapshot Isolation&lt;/em&gt;（SSI）レベルを使用して最も厳密なレベルのトランザクション分離を提供する場合でも、この保証を維持します。</target>
        </trans-unit>
        <trans-unit id="44c8536b44aa283079c384b9a03db01c74d90dd9" translate="yes" xml:space="preserve">
          <source>The main disadvantage of this approach is that searches must scan the list of pending entries in addition to searching the regular index, and so a large list of pending entries will slow searches significantly. Another disadvantage is that, while most updates are fast, an update that causes the pending list to become &amp;ldquo;too large&amp;rdquo; will incur an immediate cleanup cycle and thus be much slower than other updates. Proper use of autovacuum can minimize both of these problems.</source>
          <target state="translated">このアプローチの主な欠点は、通常のインデックスの検索に加えて、検索で保留中のエントリのリストをスキャンする必要があるため、保留中のエントリのリストが大きいと検索が大幅に遅くなることです。もう1つの欠点は、ほとんどの更新は高速ですが、保留リストが「大きすぎる」ようになる更新では、即時のクリーンアップサイクルが発生するため、他の更新よりもはるかに遅くなることです。 autovacuumを適切に使用すると、これらの問題の両方を最小限に抑えることができます。</target>
        </trans-unit>
        <trans-unit id="4ddd5b9589c157b509c992d47b1a2271d0f14677" translate="yes" xml:space="preserve">
          <source>The main limitation of the single-parameter form of &lt;code&gt;crosstab&lt;/code&gt; is that it treats all values in a group alike, inserting each value into the first available column. If you want the value columns to correspond to specific categories of data, and some groups might not have data for some of the categories, that doesn't work well. The two-parameter form of &lt;code&gt;crosstab&lt;/code&gt; handles this case by providing an explicit list of the categories corresponding to the output columns.</source>
          <target state="translated">&lt;code&gt;crosstab&lt;/code&gt; 単一パラメーター形式の主な制限は、グループ内のすべての値を同様に扱い、各値を最初の使用可能な列に挿入することです。値列をデータの特定のカテゴリに対応させたい場合、一部のグループには一部のカテゴリのデータがない可能性がありますが、これはうまく機能しません。2パラメータ形式の &lt;code&gt;crosstab&lt;/code&gt; は、出力列に対応するカテゴリの明示的なリストを提供することにより、このケースを処理します。</target>
        </trans-unit>
        <trans-unit id="c0c0e4e09c0e4b312acc4efbfbf35b08e17ec465" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server has no free replication slots. Using a replication slot is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">このオプションの主な目的は、サーバに空きレプリケーションスロットがない場合にベースバックアップを取ることができるようにすることです。バックアップ中に必要なWALがサーバによって削除されるのを防ぐことができるからです。</target>
        </trans-unit>
        <trans-unit id="778d9031e427ea1e84edd5ec78787ba6c076cbf5" translate="yes" xml:space="preserve">
          <source>The main purpose of this option is to allow taking a base backup when the server is out of free replication slots. Using replication slots is almost always preferred, because it prevents needed WAL from being removed by the server during the backup.</source>
          <target state="translated">このオプションの主な目的は、サーバに空きレプリケーションスロットがない場合にベースバックアップを取ることができるようにすることです。バックアップ中に必要なWALがサーバによって削除されるのを防ぐことができるので、レプリケーションスロットを使用することがほとんどの場合好ましいです。</target>
        </trans-unit>
        <trans-unit id="29caa328c42873be4b6687bd164a1f6cd134599f" translate="yes" xml:space="preserve">
          <source>The main reason for providing the option to specify multiple changes in a single &lt;code&gt;ALTER TABLE&lt;/code&gt; is that multiple table scans or rewrites can thereby be combined into a single pass over the table.</source>
          <target state="translated">単一の &lt;code&gt;ALTER TABLE&lt;/code&gt; で複数の変更を指定するオプションを提供する主な理由は、複数のテーブルスキャンまたは再書き込みをテーブル上で単一のパスに結合できるためです。</target>
        </trans-unit>
        <trans-unit id="cb4b3004c02ae1c44498a4d45ad098f017583f6e" translate="yes" xml:space="preserve">
          <source>The main reason not to use &lt;code&gt;FOR UPDATE&lt;/code&gt; with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; is if you need the cursor to be scrollable, or to be insensitive to the subsequent updates (that is, continue to show the old data). If this is a requirement, pay close heed to the caveats shown above.</source>
          <target state="translated">未使用の主な理由 &lt;code&gt;FOR UPDATE&lt;/code&gt; と &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; あなたは（古いデータを表示し続ける、である）スクロールする、またはそれ以降の更新の影響を受けないようにカーソルが必要な場合です。これが必要な場合は、上記の警告に注意してください。</target>
        </trans-unit>
        <trans-unit id="4a8b7d5e4956ce1f0f4b5a2c51be8faff6d42ee8" translate="yes" xml:space="preserve">
          <source>The majority of the information defining an operator family is not in its &lt;code&gt;pg_opfamily&lt;/code&gt; row, but in the associated rows in &lt;a href=&quot;catalog-pg-amop&quot;&gt;&lt;code&gt;pg_amop&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;catalog-pg-amproc&quot;&gt;&lt;code&gt;pg_amproc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;catalog-pg-opclass&quot;&gt;&lt;code&gt;pg_opclass&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">演算子族を定義する情報の大部分は、その &lt;code&gt;pg_opfamily&lt;/code&gt; 行ではなく、&lt;a href=&quot;catalog-pg-amop&quot;&gt; &lt;code&gt;pg_amop&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;catalog-pg-amproc&quot;&gt; &lt;code&gt;pg_amproc&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;catalog-pg-opclass&quot;&gt; &lt;code&gt;pg_opclass&lt;/code&gt; の&lt;/a&gt;関連する行にあります。</target>
        </trans-unit>
        <trans-unit id="84e832e692fdd3f5ebc26e5d5addbf853c3e6115" translate="yes" xml:space="preserve">
          <source>The mandatory &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the list of columns in the output table. Each entry describes a single column. See the syntax summary above for the format. The column name and type are required; the path, default and nullability clauses are optional.</source>
          <target state="translated">必須の &lt;code&gt;COLUMNS&lt;/code&gt; 句は、出力テーブルの列のリストを指定します。各エントリは1つの列を示します。形式については、上記の構文の要約を参照してください。列の名前とタイプは必須です。パス、デフォルト、およびnullability句はオプションです。</target>
        </trans-unit>
        <trans-unit id="1ed034d07246f2d9a932c645c69a5fd7f25b6f13" translate="yes" xml:space="preserve">
          <source>The map is conservative in the sense that we make sure that whenever a bit is set, we know the condition is true, but if a bit is not set, it might or might not be true. Visibility map bits are only set by vacuum, but are cleared by any data-modifying operations on a page.</source>
          <target state="translated">このマップは、ビットがセットされているときはいつでも条件が真であることがわかるようにするという意味で保守的ですが、ビットがセットされていない場合は、真ではないかもしれないし、真ではないかもしれないということになります。可視性マップのビットは真空によってのみ設定されますが、ページ上でデータを変更する操作によってクリアされます。</target>
        </trans-unit>
        <trans-unit id="08696b64b531889519840be43314b0f033492f9a" translate="yes" xml:space="preserve">
          <source>The match distance in a &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator cannot be more than 16,384</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; （FOLLOWED BY） &lt;code&gt;tsquery&lt;/code&gt; 演算子の一致距離は、16,384を超えることはできません</target>
        </trans-unit>
        <trans-unit id="0adc4fae7a170393939bebd8f752ad648c1e97c9" translate="yes" xml:space="preserve">
          <source>The matching code in the C module could then follow this skeleton:</source>
          <target state="translated">そして、Cモジュール内のマッチするコードは、このスケルトンに従うことができます。</target>
        </trans-unit>
        <trans-unit id="628cd5529e4eb158401ec35941dd337c440c275a" translate="yes" xml:space="preserve">
          <source>The maximum allowed precision when explicitly specified in the type declaration is 1000; &lt;code&gt;NUMERIC&lt;/code&gt; without a specified precision is subject to the limits described in &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt;.</source>
          <target state="translated">型宣言で明示的に指定された場合の最大許容精度は1000です。精度が指定されていない &lt;code&gt;NUMERIC&lt;/code&gt; には、&lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;表8.2で&lt;/a&gt;説明されている制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="f276734cd29218873896bf82d393e1b3527b68e3" translate="yes" xml:space="preserve">
          <source>The maximum number of buffers that can be registered for a generic WAL record is &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt;. An error will be thrown if this limit is exceeded.</source>
          <target state="translated">一般的なWALレコードに登録できる最大バッファー数は &lt;code&gt;MAX_GENERIC_XLOG_PAGES&lt;/code&gt; です。この制限を超えると、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="62795c0abeb86c3cb2f44c4d31a9efa4ab1b021c" translate="yes" xml:space="preserve">
          <source>The maximum number of columns for a table is further reduced as the tuple being stored must fit in a single 8192-byte heap page. For example, excluding the tuple header, a tuple made up of 1600 &lt;code&gt;int&lt;/code&gt; columns would consume 6400 bytes and could be stored in a heap page, but a tuple of 1600 &lt;code&gt;bigint&lt;/code&gt; columns would consume 12800 bytes and would therefore not fit inside a heap page. Variable-length fields of types such as &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; can have their values stored out of line in the table's TOAST table when the values are large enough to require it. Only an 18-byte pointer must remain inside the tuple in the table's heap. For shorter length variable-length fields, either a 4-byte or 1-byte field header is used and the value is stored inside the heap tuple.</source>
          <target state="translated">格納されるタプルは単一の8192バイトのヒープページに収まる必要があるため、テーブルの最大列数はさらに減少します。たとえば、タプルヘッダーを除いて、1600 &lt;code&gt;int&lt;/code&gt; 列で構成されるタプルは6400バイトを消費し、ヒープページに格納できますが、1600 &lt;code&gt;bigint&lt;/code&gt; 列のタプルは12800バイトを消費するため、ヒープページ内に収まりません。 &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、 &lt;code&gt;char&lt;/code&gt; などのタイプの可変長フィールド値がそれを必要とするのに十分な大きさである場合、それらの値を表のTOASTテーブルの行外に格納することができます。18バイトのポインタのみが、テーブルのヒープのタプル内に残っている必要があります。短い長さの可変長フィールドの場合、4バイトまたは1バイトのフィールドヘッダーが使用され、値はヒープタプル内に格納されます。</target>
        </trans-unit>
        <trans-unit id="5febb5cd9beb7e14dc02349a0fabc85e580c54fa" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to store in the command history (default 500). If set to a negative value, no limit is applied.</source>
          <target state="translated">コマンド履歴に保存するコマンドの最大数(デフォルトは500)。負の値を設定した場合、制限は適用されません。</target>
        </trans-unit>
        <trans-unit id="db38918ed0ba22959c7e085e2da67d6ae9e85522" translate="yes" xml:space="preserve">
          <source>The maximum number of entries in the array fields can be controlled on a column-by-column basis using the &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; command, or globally by setting the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; run-time parameter.</source>
          <target state="translated">配列フィールドの最大エントリ数は、 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; コマンドを使用して列ごとに制御するか、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;ランタイムパラメータを設定してグローバルに制御できます。</target>
        </trans-unit>
        <trans-unit id="d3e538107920d935aeb7ce10873e4d969580a999" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">返す行の最大数。詳細については、&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="758de2e2b468c97aa92a9251f6473d290c2c8830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">The maximum number of rows to return. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</target>
        </trans-unit>
        <trans-unit id="196f6ebe76be64ba3b271dddfbd4d6c8ae41617e" translate="yes" xml:space="preserve">
          <source>The maximum number of seconds to wait when attempting connection before returning that the server is not responding. Setting to 0 disables. The default is 3 seconds.</source>
          <target state="translated">接続を試みたときに、サーバーが応答していないことを返すまでの最大待機時間を指定します。0に設定すると無効になります。デフォルトは3秒です。</target>
        </trans-unit>
        <trans-unit id="3aa8188a6b3b3fb92b1108055edfe63bc9db8999" translate="yes" xml:space="preserve">
          <source>The maximum time that a table can go unvacuumed is two billion transactions minus the &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; value at the time of the last aggressive vacuum. If it were to go unvacuumed for longer than that, data loss could result. To ensure that this does not happen, autovacuum is invoked on any table that might contain unfrozen rows with XIDs older than the age specified by the configuration parameter &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;. (This will happen even if autovacuum is disabled.)</source>
          <target state="translated">テーブルが非バキューム状態になる最大時間は、20億トランザクションから、最後のアグレッシブバキューム時の &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 値を引いたものです。それよりも長い時間、真空引きを行わないと、データが失われる可能性があります。これが起こらないようにするために、構成パラメーター&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_ageで&lt;/a&gt;指定された経過日数よりも古いXIDを持つフリーズされていない行を含む可能性があるすべてのテーブルでautovacuumが呼び出されます。 （これは自動バキュームが無効になっている場合でも起こります。）</target>
        </trans-unit>
        <trans-unit id="a2f6e9f6c92be1d6e4dbdfb81636d51c2482b4e7" translate="yes" xml:space="preserve">
          <source>The maximum transfer rate of data transferred from the server. Values are in kilobytes per second. Use a suffix of &lt;code&gt;M&lt;/code&gt; to indicate megabytes per second. A suffix of &lt;code&gt;k&lt;/code&gt; is also accepted, and has no effect. Valid values are between 32 kilobytes per second and 1024 megabytes per second.</source>
          <target state="translated">サーバーから転送されるデータの最大転送速度。値はキロバイト/秒です。メガバイト/秒を示すには、 &lt;code&gt;M&lt;/code&gt; のサフィックスを使用します。 &lt;code&gt;k&lt;/code&gt; のサフィックスも受け入れられ、効果はありません。有効な値は、毎秒32キロバイトから毎秒1024メガバイトです。</target>
        </trans-unit>
        <trans-unit id="aad15d96db29ca223b68ad77ebaeeab386249ae0" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is as follows:</source>
          <target state="translated">フィールドの意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="cd3a4582b6d44983f8eaba4187d7e09c6429edc7" translate="yes" xml:space="preserve">
          <source>The meaning of this parameter, and its default value, changed in PostgreSQL 12; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt; for further discussion.</source>
          <target state="translated">このパラメーターの意味とそのデフォルト値はPostgreSQL 12で変更されました。詳細については、&lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;セクション8.1.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c7b63395362512b01d4281cff1f264dd9fa16bd8" translate="yes" xml:space="preserve">
          <source>The meanings of &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, and &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; are the same as in &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;. An aggregate will not be considered for parallelization if it is marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (which is the default!) or &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;. Note that the parallel-safety markings of the aggregate's support functions are not consulted by the planner, only the marking of the aggregate itself.</source>
          <target state="translated">&lt;code&gt;PARALLEL SAFE&lt;/code&gt; 、 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 、および &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; の意味は、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONの場合&lt;/a&gt;と同じです。集約が &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; （デフォルト）または &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; とマークされている場合、集約は並列化の対象とは見なされません。アグリゲートのサポート機能の並列安全マーキングはプランナによって参照されず、アグリゲート自体のマーキングのみが参照されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d9104f9afa808fa94ea8a0bf0c8363adf4ab748e" translate="yes" xml:space="preserve">
          <source>The mechanism that converts &lt;code&gt;(+-)&lt;/code&gt; to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten:</source>
          <target state="translated">&lt;code&gt;(+-)&lt;/code&gt; を通常の範囲に変換するメカニズムは、境界の有効桁数を決定する際に完全に正確ではありません。たとえば、結果の間隔に10の累乗が含まれている場合は、下限に余分な数字が追加されます。</target>
        </trans-unit>
        <trans-unit id="221c60f17786086e4d1d8637638f0c8d9f6223fa" translate="yes" xml:space="preserve">
          <source>The members of a group role can use the privileges of the role in two ways. First, every member of a group can explicitly do &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; to temporarily &amp;ldquo;become&amp;rdquo; the group role. In this state, the database session has access to the privileges of the group role rather than the original login role, and any database objects created are considered owned by the group role not the login role. Second, member roles that have the &lt;code&gt;INHERIT&lt;/code&gt; attribute automatically have use of the privileges of roles of which they are members, including any privileges inherited by those roles. As an example, suppose we have done:</source>
          <target state="translated">グループロールのメンバーは、ロールの特権を2つの方法で使用できます。まず、グループのすべてのメンバーは&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;を明示的に実行して、一時的にグループの役割になることができます。この状態では、データベースセッションは元のログインロールではなくグループロールの権限にアクセスでき、作成されたデータベースオブジェクトはすべて、ログインロールではなくグループロールが所有していると見なされます。第2に、 &lt;code&gt;INHERIT&lt;/code&gt; 属性を持つメンバーの役割は、それらのメンバーが属している役割の特権（それらの役割によって継承された特権を含む）を自動的に使用します。例として、次のようにしたとします。</target>
        </trans-unit>
        <trans-unit id="c531d86ffa3bb917e6ad2f8783d407b8d81b1be4" translate="yes" xml:space="preserve">
          <source>The mentioned transformations and compilations are normally done automatically using the &lt;em&gt;makefiles&lt;/em&gt; shipped with the PostgreSQL source distribution.</source>
          <target state="translated">上記の変換とコンパイルは、通常、PostgreSQLソース配布に付属する&lt;em&gt;makefile&lt;/em&gt;を使用して自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="8cd29d65e9431541c4a7e3d8e7bf9c8ca5af8963" translate="yes" xml:space="preserve">
          <source>The message is encrypted with a symmetric key.</source>
          <target state="translated">メッセージは対称鍵で暗号化されます。</target>
        </trans-unit>
        <trans-unit id="bb36ba49fd3ad58b447d4a645799893632a3669c" translate="yes" xml:space="preserve">
          <source>The message is public-key encrypted, but the key ID has been removed. That means you will need to try all your secret keys on it to see which one decrypts it. &lt;code&gt;pgcrypto&lt;/code&gt; itself does not produce such messages.</source>
          <target state="translated">メッセージは公開鍵で暗号化されていますが、鍵IDは削除されています。つまり、すべての秘密鍵を試して、どれが復号するかを確認する必要があります。 &lt;code&gt;pgcrypto&lt;/code&gt; 自体はそのようなメッセージを生成しません。</target>
        </trans-unit>
        <trans-unit id="80b9ed75dbe3c0d3f0a0153cbc3b5f5a6c2e4216" translate="yes" xml:space="preserve">
          <source>The metasyntax forms described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt; do not exist in XQuery.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;セクション9.7.3.4で&lt;/a&gt;説明されているメタ構文フォームはXQueryには存在しません。</target>
        </trans-unit>
        <trans-unit id="5167d97b5af2d410349f4f14e2833acb2e09f087" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ANY&lt;/code&gt; specifies a quorum-based synchronous replication and makes transaction commits wait until their WAL records are replicated to &lt;em&gt;at least&lt;/em&gt; the requested number of synchronous standbys in the list.</source>
          <target state="translated">メソッド &lt;code&gt;ANY&lt;/code&gt; は、クォーラムベースの同期レプリケーションを指定し、WALレコードが&lt;em&gt;少なくとも&lt;/em&gt;リスト内の要求された同期スタンバイの数に複製されるまで、トランザクションコミットを待機させます。</target>
        </trans-unit>
        <trans-unit id="f49f419e2b9a22a4fc79b879fb7d7ed163340aa2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;FIRST&lt;/code&gt; specifies a priority-based synchronous replication and makes transaction commits wait until their WAL records are replicated to the requested number of synchronous standbys chosen based on their priorities. The standbys whose names appear earlier in the list are given higher priority and will be considered as synchronous. Other standby servers appearing later in this list represent potential synchronous standbys. If any of the current synchronous standbys disconnects for whatever reason, it will be replaced immediately with the next-highest-priority standby.</source>
          <target state="translated">メソッド &lt;code&gt;FIRST&lt;/code&gt; は、優先度ベースの同期レプリケーションを指定し、優先度に基づいて選択された要求された数の同期スタンバイにWALレコードが複製されるまで、トランザクションコミットを待機させます。リストの最初の方に名前が表示されているスタンバイには、より高い優先順位が与えられ、同期と見なされます。このリストの後半にある他のスタンバイサーバーは、潜在的な同期スタンバイを表しています。現在の同期スタンバイのいずれかが何らかの理由で切断された場合、すぐに次に優先順位の高いスタンバイに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="3b4f76e9dc87199736499aa89b071e2462e85235" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;md5&lt;/code&gt; uses a custom less secure challenge-response mechanism. It prevents password sniffing and avoids storing passwords on the server in plain text but provides no protection if an attacker manages to steal the password hash from the server. Also, the MD5 hash algorithm is nowadays no longer considered secure against determined attacks.</source>
          <target state="translated">メソッド &lt;code&gt;md5&lt;/code&gt; は、カスタムの安全性の低いチャレンジ/レスポンスメカニズムを使用します。パスワードスニッフィングを防止し、パスワードをプレーンテキストでサーバーに保存しませんが、攻撃者がサーバーからパスワードハッシュを盗んだ場合、保護は提供されません。また、現在、MD5ハッシュアルゴリズムは、決まった攻撃に対して安全であるとは見なされていません。</target>
        </trans-unit>
        <trans-unit id="bbe98735c0b460f287d0e1fc8bbe8558da46b394" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;password&lt;/code&gt; sends the password in clear-text and is therefore vulnerable to password &amp;ldquo;sniffing&amp;rdquo; attacks. It should always be avoided if possible. If the connection is protected by SSL encryption then &lt;code&gt;password&lt;/code&gt; can be used safely, though. (Though SSL certificate authentication might be a better choice if one is depending on using SSL).</source>
          <target state="translated">メソッド &lt;code&gt;password&lt;/code&gt; はパスワードを平文で送信するため、パスワードの「盗聴」攻撃に対して脆弱です。可能であれば常に回避する必要があります。ただし、接続がSSL暗号化によって保護されている場合は、 &lt;code&gt;password&lt;/code&gt; を安全に使用できます。（ただし、SSLの使用に依存している場合は、SSL証明書認証の方が適している場合があります）。</target>
        </trans-unit>
        <trans-unit id="c4e1d81897ac3ef5344a09ff3085827106ec9fad" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;scram-sha-256&lt;/code&gt; performs SCRAM-SHA-256 authentication, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;. It is a challenge-response scheme that prevents password sniffing on untrusted connections and supports storing passwords on the server in a cryptographically hashed form that is thought to be secure.</source>
          <target state="translated">方法 &lt;code&gt;scram-sha-256&lt;/code&gt; を行うに記載されているようにSCRAM-SHA-256認証、&lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;RFC 7677&lt;/a&gt;。これは、信頼できない接続でのパスワードスニッフィングを防ぎ、安全であると考えられる暗号化されたハッシュ形式でサーバーにパスワードを保存することをサポートするチャレンジ/レスポンス方式です。</target>
        </trans-unit>
        <trans-unit id="4d38dbf255ad283e492b192c046e51eef7da09c0" translate="yes" xml:space="preserve">
          <source>The method a client application must use to detect notification events depends on which PostgreSQL application programming interface it uses. With the libpq library, the application issues &lt;code&gt;LISTEN&lt;/code&gt; as an ordinary SQL command, and then must periodically call the function &lt;code&gt;PQnotifies&lt;/code&gt; to find out whether any notification events have been received. Other interfaces such as libpgtcl provide higher-level methods for handling notify events; indeed, with libpgtcl the application programmer should not even issue &lt;code&gt;LISTEN&lt;/code&gt; or &lt;code&gt;UNLISTEN&lt;/code&gt; directly. See the documentation for the interface you are using for more details.</source>
          <target state="translated">クライアントアプリケーションが通知イベントを検出するために使用する必要がある方法は、使用するPostgreSQLアプリケーションプログラミングインターフェイスによって異なります。 libpqライブラリを使用すると、アプリケーションは通常のSQLコマンドとして &lt;code&gt;LISTEN&lt;/code&gt; を発行し、定期的に関数 &lt;code&gt;PQnotifies&lt;/code&gt; を呼び出して、通知イベントが受信されたかどうかを確認する必要があります。 libpgtclなどの他のインターフェースは、通知イベントを処理するための高レベルのメソッドを提供します。実際、libpgtclを使用すると、アプリケーションプログラマは &lt;code&gt;LISTEN&lt;/code&gt; または &lt;code&gt;UNLISTEN&lt;/code&gt; を直接発行することもできません。詳細については、使用しているインターフェースのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="820cf6d702543aba9dfe85b2f79f3d6774753e9a" translate="yes" xml:space="preserve">
          <source>The method described in this section has been obsoleted by the use of stored generated columns, as described in &lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;Section 12.2.2&lt;/a&gt;.</source>
          <target state="translated">このセクションで説明する方法は、&lt;a href=&quot;textsearch-tables#TEXTSEARCH-TABLES-INDEX&quot;&gt;セクション12.2.2で&lt;/a&gt;説明するように、格納された生成列を使用することで廃止されました。</target>
        </trans-unit>
        <trans-unit id="318a555813c808d85dcecb5209b3a3a236dc9ab5" translate="yes" xml:space="preserve">
          <source>The method for triggering failover is an important part of planning and design. One potential option is the &lt;code&gt;restore_command&lt;/code&gt; command. It is executed once for each WAL file, but the process running the &lt;code&gt;restore_command&lt;/code&gt; is created and dies for each file, so there is no daemon or server process, and signals or a signal handler cannot be used. Therefore, the &lt;code&gt;restore_command&lt;/code&gt; is not suitable to trigger failover. It is possible to use a simple timeout facility, especially if used in conjunction with a known &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary. However, this is somewhat error prone since a network problem or busy primary server might be sufficient to initiate failover. A notification mechanism such as the explicit creation of a trigger file is ideal, if this can be arranged.</source>
          <target state="translated">フェイルオーバーをトリガーする方法は、計画と設計の重要な部分です。可能なオプションの1つは、 &lt;code&gt;restore_command&lt;/code&gt; コマンドです。WALファイルごとに1回実行されますが、 &lt;code&gt;restore_command&lt;/code&gt; を実行するプロセスが作成され、ファイルごとに終了するため、デーモンまたはサーバープロセスが存在せず、シグナルまたはシグナルハンドラーを使用できません。したがって、 &lt;code&gt;restore_command&lt;/code&gt; はフェイルオーバーのトリガーには適していません。特に、既知の &lt;code&gt;archive_timeout&lt;/code&gt; と組み合わせて使用​​する場合は、単純なタイムアウト機能を使用できます。プライマリの設定。ただし、フェイルオーバーを開始するには、ネットワークの問題またはビジーなプライマリサーバーで十分な場合があるため、これはエラーが発生しやすくなります。可能であれば、トリガーファイルの明示的な作成などの通知メカニズムが理想的です。</target>
        </trans-unit>
        <trans-unit id="9ecf9a698c1e522b9c1de1bf5af789211b8be7ed" translate="yes" xml:space="preserve">
          <source>The millennium</source>
          <target state="translated">千年紀</target>
        </trans-unit>
        <trans-unit id="d49286ea0d415b0aad37189b731269fb41a33f65" translate="yes" xml:space="preserve">
          <source>The minute component of the time zone offset</source>
          <target state="translated">タイムゾーンオフセットの分単位</target>
        </trans-unit>
        <trans-unit id="70c1dd6d1f4cd9d65c5ea9908ee66b76d8b0f4e4" translate="yes" xml:space="preserve">
          <source>The minutes field (0 - 59)</source>
          <target state="translated">議事録フィールド (0-59)</target>
        </trans-unit>
        <trans-unit id="8e27da07ae7efc7685d90ec013484c3ec2a72626" translate="yes" xml:space="preserve">
          <source>The minutes field (0&amp;ndash;59)</source>
          <target state="translated">The minutes field (0&amp;ndash;59)</target>
        </trans-unit>
        <trans-unit id="f58bb99f67c9dd4fa543f324ba0a954d9aeea2c7" translate="yes" xml:space="preserve">
          <source>The missing positions 1,2,4 are because of stop words. Ranks calculated for documents with and without stop words are quite different:</source>
          <target state="translated">1,2,4の位置が欠けているのは、ストップワードのためです。ストップワードのある文書とない文書では、順位の計算にかなりの差があります。</target>
        </trans-unit>
        <trans-unit id="7efece902ce6baec1dac421e4950dc636bcb9bc8" translate="yes" xml:space="preserve">
          <source>The mixed notation combines positional and named notation. However, as already mentioned, named arguments cannot precede positional arguments. For example:</source>
          <target state="translated">混合記法は、位置引数と名前付き引数を組み合わせたものです。しかし、すでに述べたように、名前付き引数は位置引数に先行することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="dfdfde6fd27332a6600ccf2d0ac2ce0c45f7420f" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">関数、プロシージャ、または集約引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数だけなので、 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="68b58e6626dcfa87dd99931a1610596ebfd41322" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">関数、プロシージャ、または集約引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数だけなので、 &lt;code&gt;COMMENT&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="d48b93746498257a59bb7fe4e61442dbe73691fd" translate="yes" xml:space="preserve">
          <source>The mode of a function, procedure, or aggregate argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">関数、プロシージャ、または集約引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。注意 &lt;code&gt;SECURITY LABEL&lt;/code&gt; 、実際に注意を払っていない &lt;code&gt;OUT&lt;/code&gt; の唯一の入力引数が関数の同一性を決定するために必要とされているので、引数を指定します。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="45f33dca690dafc673c0eaa64fba7b4d58d74383" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. (Aggregate functions do not support &lt;code&gt;OUT&lt;/code&gt; arguments.) If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only the last argument can be marked &lt;code&gt;VARIADIC&lt;/code&gt;.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; または &lt;code&gt;VARIADIC&lt;/code&gt; 。（集約関数は &lt;code&gt;OUT&lt;/code&gt; 引数をサポートしていません。）省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。最後の引数のみ &lt;code&gt;VARIADIC&lt;/code&gt; とマークできます。</target>
        </trans-unit>
        <trans-unit id="4568485f8330f08f8282bc3a9f4e6ab0835ae883" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d77ba6d205a4cdad089faf693afa61d51e9631c2" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. (&lt;code&gt;OUT&lt;/code&gt; arguments are currently not supported for procedures. Use &lt;code&gt;INOUT&lt;/code&gt; instead.)</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。（ &lt;code&gt;OUT&lt;/code&gt; 引数は現在、プロシージャではサポートされていません。代わりに &lt;code&gt;INOUT&lt;/code&gt; を使用してください。）</target>
        </trans-unit>
        <trans-unit id="38c566bf6c299177523daede4805416a31c75adc" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数のみであるため、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="0c0698969a82046af9f337be0b0bf94de3d24ca9" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to &lt;code&gt;OUT&lt;/code&gt; arguments, since only the input arguments are needed to determine the function's identity. So it is sufficient to list the &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, and &lt;code&gt;VARIADIC&lt;/code&gt; arguments.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。関数のIDを決定するために必要なのは入力引数だけなので、 &lt;code&gt;DROP FUNCTION&lt;/code&gt; は実際には &lt;code&gt;OUT&lt;/code&gt; 引数に注意を払わないことに注意してください。したがって、 &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、および &lt;code&gt;VARIADIC&lt;/code&gt; 引数をリストするだけで十分です。</target>
        </trans-unit>
        <trans-unit id="6f4ca0b892fae54672225fff5e45afe9a23bd3fa" translate="yes" xml:space="preserve">
          <source>The mode of an argument: &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT&lt;/code&gt;, &lt;code&gt;INOUT&lt;/code&gt;, or &lt;code&gt;VARIADIC&lt;/code&gt;. If omitted, the default is &lt;code&gt;IN&lt;/code&gt;. Only &lt;code&gt;OUT&lt;/code&gt; arguments can follow a &lt;code&gt;VARIADIC&lt;/code&gt; one. Also, &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments cannot be used together with the &lt;code&gt;RETURNS TABLE&lt;/code&gt; notation.</source>
          <target state="translated">引数のモード： &lt;code&gt;IN&lt;/code&gt; 、 &lt;code&gt;OUT&lt;/code&gt; 、 &lt;code&gt;INOUT&lt;/code&gt; 、または &lt;code&gt;VARIADIC&lt;/code&gt; 。省略した場合、デフォルトは &lt;code&gt;IN&lt;/code&gt; です。 &lt;code&gt;VARIADIC&lt;/code&gt; 引数の後に続くことができるのは &lt;code&gt;OUT&lt;/code&gt; 引数のみです。また、 &lt;code&gt;OUT&lt;/code&gt; および &lt;code&gt;INOUT&lt;/code&gt; 引数を &lt;code&gt;RETURNS TABLE&lt;/code&gt; 表記と一緒に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="51a81b68008882e6907064e5a6c6b245cdf62054" translate="yes" xml:space="preserve">
          <source>The modification of data that is already in the database is referred to as updating. You can update individual rows, all the rows in a table, or a subset of all rows. Each column can be updated separately; the other columns are not affected.</source>
          <target state="translated">すでにデータベースにあるデータを変更することを更新といいます。個々の行、テーブル内のすべての行、またはすべての行のサブセットを更新することができます。各列は個別に更新することができ、他の列は影響を受けません。</target>
        </trans-unit>
        <trans-unit id="853b75e3f66e460231939e7956e83ee3b696375d" translate="yes" xml:space="preserve">
          <source>The module also provides a data type &lt;code&gt;lo&lt;/code&gt;, which is really just a domain of the &lt;code&gt;oid&lt;/code&gt; type. This is useful for differentiating database columns that hold large object references from those that are OIDs of other things. You don't have to use the &lt;code&gt;lo&lt;/code&gt; type to use the trigger, but it may be convenient to use it to keep track of which columns in your database represent large objects that you are managing with the trigger. It is also rumored that the ODBC driver gets confused if you don't use &lt;code&gt;lo&lt;/code&gt; for BLOB columns.</source>
          <target state="translated">このモジュールは、データ型 &lt;code&gt;lo&lt;/code&gt; も提供します。これは、実際には &lt;code&gt;oid&lt;/code&gt; 型のドメインにすぎません。これは、ラージオブジェクト参照を保持するデータベース列を、他のもののOIDであるものと区別するのに役立ちます。トリガーを使用するために &lt;code&gt;lo&lt;/code&gt; タイプを使用する必要はありませんが、トリガーで管理している大きなオブジェクトをデータベースのどの列が表すかを追跡するために使用すると便利な場合があります。BLOB列に &lt;code&gt;lo&lt;/code&gt; を使用しないと、ODBCドライバーが混乱するという噂もあります。</target>
        </trans-unit>
        <trans-unit id="81ca0d62d96cb007036c4e8c71ad66419c59e2b5" translate="yes" xml:space="preserve">
          <source>The module must be loaded by adding &lt;code&gt;pg_stat_statements&lt;/code&gt; to &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;, because it requires additional shared memory. This means that a server restart is needed to add or remove the module.</source>
          <target state="translated">追加の共有メモリを必要とするため、モジュールは &lt;code&gt;pg_stat_statements&lt;/code&gt; を &lt;code&gt;postgresql.conf&lt;/code&gt; の&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;に追加してロードする必要があります。つまり、モジュールを追加または削除するには、サーバーを再起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="d72e93f82e4421713f65eb6d758581a8fbe9cccf" translate="yes" xml:space="preserve">
          <source>The module provides a C function &lt;code&gt;pg_buffercache_pages&lt;/code&gt; that returns a set of records, plus a view &lt;code&gt;pg_buffercache&lt;/code&gt; that wraps the function for convenient use.</source>
          <target state="translated">このモジュールは、レコードのセットを返すC関数 &lt;code&gt;pg_buffercache_pages&lt;/code&gt; と、便利に使用できるように関数をラップするビュー &lt;code&gt;pg_buffercache&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="32a787e9d3c71749ae7c7075bc8cc6c86f32c2a0" translate="yes" xml:space="preserve">
          <source>The module provides no SQL-accessible functions. To use it, simply load it into the server. You can load it into an individual session:</source>
          <target state="translated">このモジュールは、SQLにアクセス可能な関数を提供しません。使用するには、サーバにロードするだけです。個々のセッションにロードすることができます。</target>
        </trans-unit>
        <trans-unit id="7b136900f1dbee2d882f7a554d2840c344beb60e" translate="yes" xml:space="preserve">
          <source>The module requires additional shared memory proportional to &lt;code&gt;pg_stat_statements.max&lt;/code&gt;. Note that this memory is consumed whenever the module is loaded, even if &lt;code&gt;pg_stat_statements.track&lt;/code&gt; is set to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">モジュールには、 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; に比例する追加の共有メモリが必要です。このメモリは、 &lt;code&gt;pg_stat_statements.track&lt;/code&gt; が &lt;code&gt;none&lt;/code&gt; に設定されている場合でも、モジュールがロードされるたびに消費されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e9ad875208f4afcd97973304af9fd6ef485a5b48" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; &lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</target>
        </trans-unit>
        <trans-unit id="96530f50681b8674942f17d7870b9786b275bddf" translate="yes" xml:space="preserve">
          <source>The monitoring information about subscription is visible in &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt;. This view contains one row for every subscription worker. A subscription can have zero or more active subscription workers depending on its state.</source>
          <target state="translated">サブスクリプションに関する監視情報は&lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; に&lt;/a&gt;表示されます。このビューには、サブスクリプションワーカーごとに1つの行が含まれます。サブスクリプションは、その状態に応じて、0個以上のアクティブなサブスクリプションワーカーを持つことができます。</target>
        </trans-unit>
        <trans-unit id="e4f2efea26fbea2f4a0f53659ea7db3de7f00c25" translate="yes" xml:space="preserve">
          <source>The most common reason for conflict between standby queries and WAL replay is &amp;ldquo;early cleanup&amp;rdquo;. Normally, PostgreSQL allows cleanup of old row versions when there are no transactions that need to see them to ensure correct visibility of data according to MVCC rules. However, this rule can only be applied for transactions executing on the master. So it is possible that cleanup on the master will remove row versions that are still visible to a transaction on the standby.</source>
          <target state="translated">スタンバイクエリとWAL再生の競合の最も一般的な理由は、「早期クリーンアップ」です。通常、PostgreSQLでは、MVCCルールに従ってデータを正しく表示するためにそれらを表示する必要のあるトランザクションがない場合、古い行バージョンをクリーンアップできます。ただし、このルールは、マスターで実行されているトランザクションにのみ適用できます。そのため、マスターでのクリーンアップにより、スタンバイのトランザクションにまだ表示されている行バージョンが削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="731bbf4edb90976573e528f87d62ab4f72b17368" translate="yes" xml:space="preserve">
          <source>The most critical part of the display is the estimated statement execution cost, which is the planner's guess at how long it will take to run the statement (measured in cost units that are arbitrary, but conventionally mean disk page fetches). Actually two numbers are shown: the start-up cost before the first row can be returned, and the total cost to return all the rows. For most queries the total cost is what matters, but in contexts such as a subquery in &lt;code&gt;EXISTS&lt;/code&gt;, the planner will choose the smallest start-up cost instead of the smallest total cost (since the executor will stop after getting one row, anyway). Also, if you limit the number of rows to return with a &lt;code&gt;LIMIT&lt;/code&gt; clause, the planner makes an appropriate interpolation between the endpoint costs to estimate which plan is really the cheapest.</source>
          <target state="translated">表示の最も重要な部分は、ステートメントの実行コストの見積もりです。これは、プランナーがステートメントの実行にかかる時間を推測したものです（任意のコスト単位で測定されますが、通常はディスクページのフェッチを意味します）。実際には2つの数値が表示されます。最初の行が返される前の開始コストと、すべての行を返すための合計コストです。ほとんどのクエリでは総コストが重要ですが、 &lt;code&gt;EXISTS&lt;/code&gt; のサブクエリなどのコンテキストでは、プランナは最小の総コストではなく最小の起動コストを選択します（とにかく、エグゼキュータは1行を取得した後に停止するため）。また、返す行数を &lt;code&gt;LIMIT&lt;/code&gt; で制限した場合 節では、プランナはエンドポイントのコストを適切に補間して、実際に最も安いプランを見積もります。</target>
        </trans-unit>
        <trans-unit id="413b816a60a8ce6de7ad09a5ffb4362dd48af1ec" translate="yes" xml:space="preserve">
          <source>The most fundamental way to set these parameters is to edit the file &lt;code&gt;postgresql.conf&lt;/code&gt;, which is normally kept in the data directory. A default copy is installed when the database cluster directory is initialized. An example of what this file might look like is:</source>
          <target state="translated">これらのパラメータを設定する最も基本的な方法は、通常データディレクトリに保存される &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルを編集することです。デフォルトのコピーは、データベースクラスターディレクトリが初期化されるときにインストールされます。このファイルの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e306bed63f3a1d9eca423326fcf07e6b9edcc6b0" translate="yes" xml:space="preserve">
          <source>The most important disk monitoring task of a database administrator is to make sure the disk doesn't become full. A filled data disk will not result in data corruption, but it might prevent useful activity from occurring. If the disk holding the WAL files grows full, database server panic and consequent shutdown might occur.</source>
          <target state="translated">データベース管理者の最も重要なディスク監視作業は、ディスクが満杯にならないようにすることです。データディスクが一杯になってもデータが破損することはありませんが、有用なアクティビティの発生を妨げる可能性があります。WAL ファイルを保持しているディスクが一杯になると、データベースサーバーがパニックに陥り、結果としてシャットダウンが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="877dc37c3736494355fb75407dc41fe0e6f84483" translate="yes" xml:space="preserve">
          <source>The most interesting options are probably &lt;code&gt;compress-algo&lt;/code&gt; and &lt;code&gt;unicode-mode&lt;/code&gt;. The rest should have reasonable defaults.</source>
          <target state="translated">最も興味深いオプションは、おそらく &lt;code&gt;compress-algo&lt;/code&gt; と &lt;code&gt;unicode-mode&lt;/code&gt; です。残りは妥当なデフォルトでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9a6d131c4243d30d96e0db292f1623b359a016fb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">この&lt;em&gt;関数&lt;/em&gt;に使用する&lt;em&gt;プランナサポート関数&lt;/em&gt;の名前（オプションでスキーマ修飾）。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;項37.11&lt;/a&gt;を参照してください。このオプションを使用するには、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="1902fa4c4f3be48a1f8af8f713baf8e7dfa86fb2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</source>
          <target state="translated">The name (optionally schema-qualified) of a &lt;em&gt;planner support function&lt;/em&gt; to use for this function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt; for details. You must be superuser to use this option.</target>
        </trans-unit>
        <trans-unit id="14b6fcb4c63d755a00d7e0670d638ed746023a2d" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a domain to be created.</source>
          <target state="translated">作成されるドメインの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="38611bfc887263be7f78673bf7d9d5cdb57c578a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator class.</source>
          <target state="translated">演算子クラスのインデックスメソッドサポート関数である関数の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="5902522e953f867bcf2f16270ac0968cc20f9546" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a function that is an index method support function for the operator family. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">演算子ファミリのインデックスメソッドサポート関数である関数の名前(スキーマ修飾も可)。引数リストが指定されていない場合、その名前はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d845c7a3b53e4177570415c0bc3bcd5b3195e4e2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence to be altered.</source>
          <target state="translated">変更するシーケンスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="86f2ddbdf403f4ceac3ce1673bf568f23dd1ad99" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a sequence.</source>
          <target state="translated">シーケンスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="ac3e3dd701383980ee625dc0305504430477533a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a specific table or materialized view to vacuum. If the specified table is a partitioned table, all of its leaf partitions are vacuumed.</source>
          <target state="translated">バキュームする特定のテーブルまたはマテリアライズドビューの名前(スキーマ修飾も可)。指定したテーブルがパーティショニングされたテーブルの場合は、そのすべてのリーフパーティションがバキュームされます。</target>
        </trans-unit>
        <trans-unit id="53bb17c6184a24ee8382a2d75581d17a4a86859a" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a table to truncate. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is truncated. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are truncated. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">切り捨てるテーブルの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが切り捨てられます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）は切り捨てられます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="2e64f1d6069ef5fc5ed6316b39d72b0e2b06f901" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a type to be created.</source>
          <target state="translated">作成される型の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="f9bf344cdc87b1adaf5636fb2ebcad9f1ddba5b6" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of a view to be created.</source>
          <target state="translated">作成するビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="b639552e986e941a3c10c2544ec995a239ffb6e3" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing &lt;code&gt;btree&lt;/code&gt; operator family that describes the sort ordering associated with an ordering operator.</source>
          <target state="translated">順序付け演算子に関連付けられた並べ替え順序を説明する既存の &lt;code&gt;btree&lt;/code&gt; 演算子族の名前（オプションでスキーマ修飾）。</target>
        </trans-unit>
        <trans-unit id="34900785f9149eeefbc60e92cda94ca173cd04e7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing aggregate function.</source>
          <target state="translated">既存の集約関数の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="578ce1660a308750d3e750170be95b160d2b4eaa" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing collation.</source>
          <target state="translated">既存の照合順序の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="f41ad29e0b7f082d84fd62fd8cb20d2acca4d7fc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing conversion.</source>
          <target state="translated">既存の変換の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="3906d435eac2789ae790437fa866de097132bd5f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing domain.</source>
          <target state="translated">既存のドメインの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="d79e2ff622e47d59db15f73c173411091fa8fabb" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing function. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">既存の関数の名前(スキーマ修飾も可)。引数リストが指定されていない場合は、その名前はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e19891aa77a7fd37f7b714112d5a229b9e2c2c1e" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing materialized view.</source>
          <target state="translated">既存のマテリアライズドビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="d3c124f08f1d17279d8902cee277b8d4f1a183ad" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator class.</source>
          <target state="translated">既存の演算子クラスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="38e2880de321890fbbcce2e9729e127a62b40b76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator family.</source>
          <target state="translated">既存の演算子ファミリーの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="054a0dca285caf1e015006f488ef65a3eecedbf4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing operator.</source>
          <target state="translated">既存の演算子の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="77adb5998ee2e3aabde213dad5e54fd26872e3dc" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing procedure. If no argument list is specified, the name must be unique in its schema.</source>
          <target state="translated">既存のプロシージャの名前(オプションでスキーマ修飾)。引数リストが指定されていない場合、その名前はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f544776c8e3c1cef33633f466a66f32aea31c3fe" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table or view. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is scanned. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are scanned. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">既存のテーブルまたはビューの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみがスキャンされます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）がスキャンされます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="fed47b49b5a2826cdd529f07291a0b91365295e5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">変更する既存のテーブルの名前（オプションでスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが変更されています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）が変更されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="9e39d635b5a89d3591bd7fd7ce4ecbe9ffd4c1d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table to lock. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is locked. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are locked. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">ロックする既存のテーブルの名前（オプションでスキーマ修飾）。もし &lt;code&gt;ONLY&lt;/code&gt; テーブルがロックされているだけで、テーブル名の前に指定されています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての下位テーブル（存在する場合）がロックされます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="7b428f5695f116b2abd1edd43a6b7f791e930f67" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing table.</source>
          <target state="translated">既存のテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="d6bac31933d004e229772d4577bb5205aa40d1b4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search configuration.</source>
          <target state="translated">既存のテキスト検索設定の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="c30fa81fa2fa2992c5e25e7be26425ba28f70618" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search dictionary.</source>
          <target state="translated">既存のテキスト検索辞書の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="6764c434bb1917335a8e7ae9bad93f1fcc49fc17" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search parser.</source>
          <target state="translated">既存のテキスト検索パーサの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="dcc71c03641d807db453dbb54b0a2fce72902867" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing text search template.</source>
          <target state="translated">既存のテキスト検索テンプレートの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="c07fc33a37601af59ca6761edf035f64fe688e76" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an existing view.</source>
          <target state="translated">既存のビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="5f3b87270ccb7b31876399c63171eeddc6c5acd0" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an index to remove.</source>
          <target state="translated">削除するインデックスの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="4d1a15fbadbb463eba7072f8d97b36fff8e4db35" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator class.</source>
          <target state="translated">演算子クラスに関連付けられた演算子の名前 (オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="f55c07895028de262598e75436d631175b201a69" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of an operator associated with the operator family.</source>
          <target state="translated">演算子ファミリーに関連付けられた演算子の名前 (オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="b2bd7b76dedcec38eb17eed38f1b959f8bd417a7" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the aggregate function to create.</source>
          <target state="translated">作成する集約関数の名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="a93a4bd4bc9034a1432f189ca88e837333dc130b" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the data type to remove.</source>
          <target state="translated">削除するデータ型の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="985217a7a1fa0c3a567eb7244b6b8b146f2c7b30" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the foreign table to drop.</source>
          <target state="translated">ドロップする外部テーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="c10f31992b2571e70d614bb2d060a79ba59a8a33" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the function to create.</source>
          <target state="translated">作成する関数の名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="83e9847814c3ba939cbc4f420e1c3c7c00a69552" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to be created.</source>
          <target state="translated">作成されるマテリアライズされたビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="2255582209b1f3da815e53122bc13a8a7b84cf00" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to refresh.</source>
          <target state="translated">更新するマテリアライズされたビューの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="2db1fb74b2f868165f2c5564d755e2f43c24353f" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the materialized view to remove.</source>
          <target state="translated">削除するマテリアライズされたビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="9df0359ba8b94b06eb25b013152842f292a7b4df" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure to create.</source>
          <target state="translated">作成するプロシージャの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="4cd07bcb956404ed169f912452a4480e70e115e4" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the procedure.</source>
          <target state="translated">プロシージャの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="2a4c2e1b22bdcbf405362b9ae17fa1fbce426df2" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the sequence to be created.</source>
          <target state="translated">作成するシーケンスの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="048a9ab4e359ce8b95a4959e9df97e30c4e65d60" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be altered.</source>
          <target state="translated">変更する統計オブジェクトの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="f52881167770a0af5eb7409ca2185b9c04bac337" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to be created.</source>
          <target state="translated">作成される統計オブジェクトの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="4b423cb4d9cc1b2bcdad9b8dd172fb72d89e4e2c" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the statistics object to drop.</source>
          <target state="translated">ドロップする統計オブジェクトの名前(スキーマ修飾も可)。</target>
        </trans-unit>
        <trans-unit id="b61d21dada065f46c4c7b2b7d604e26966040dc1" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table containing the column(s) the statistics are computed on.</source>
          <target state="translated">統計の計算対象となる列を含むテーブルの名前(スキーマで修飾されている場合もあります)。</target>
        </trans-unit>
        <trans-unit id="8defd757e6f0ae34c512e774b626ccf674726eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table for which the trigger is defined.</source>
          <target state="translated">トリガーが定義されているテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="4d5698a39cc31b5f7b88bdd408f67f5c7638f5d5" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view that the rule applies to.</source>
          <target state="translated">ルールが適用されるテーブルまたはビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="b756bc816e4bf98b49581640b12dbf571a3be447" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table or view the rule applies to.</source>
          <target state="translated">ルールが適用されるテーブルまたはビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="1babb726cd58996c0c81dade9eb62f3731eca7ef" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table that the policy is on.</source>
          <target state="translated">ポリシーが置かれているテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="66f5ae5d2b295f1ee2b970f57d5d9ecd6bf021d8" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table the policy applies to.</source>
          <target state="translated">ポリシーが適用されるテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="2163decbe5c6781dc3c30049b04dc6fe3b754ccd" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to be created.</source>
          <target state="translated">作成するテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="7faaacd9226a4e88c9e4c1c3c739210417e124ce" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to delete rows from. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are deleted from the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also deleted from any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">行を削除するテーブルの名前（オプションでスキーマ修飾）。テーブル名の前に &lt;code&gt;ONLY&lt;/code&gt; が指定されている場合、一致する行は名前付きテーブルからのみ削除されます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、一致する行も名前付きテーブルから継承するテーブルから削除されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="2a919fb8f51d9d6b6757a121c98308d8b2e355a9" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to drop.</source>
          <target state="translated">ドロップするテーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="805225c1106f83d7720b93b38e959f1241d2a307" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table to update. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, matching rows are updated in the named table only. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, matching rows are also updated in any tables inheriting from the named table. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">更新するテーブルの名前（オプションでスキーマ修飾）。テーブル名の前に &lt;code&gt;ONLY&lt;/code&gt; が指定されている場合、一致する行は名前付きテーブルでのみ更新されます。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、指定されたテーブルから継承するすべてのテーブルで一致する行も更新されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="56ec5e8966f4a00d4b5c2a7c99ee7bd04c931eab" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the table, view, or foreign table the trigger is for.</source>
          <target state="translated">トリガーが対象とするテーブル、ビュー、または外部テーブルの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="72a54509c9fcd2a9291f8a3e62487b349d23e646" translate="yes" xml:space="preserve">
          <source>The name (optionally schema-qualified) of the view to remove.</source>
          <target state="translated">削除するビューの名前(オプションでスキーマ修飾)。</target>
        </trans-unit>
        <trans-unit id="359f50eaf29e3eca920ffd05f6355f20cb0c9f2e" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a specific table to analyze. If omitted, all regular tables, partitioned tables, and materialized views in the current database are analyzed (but not foreign tables). If the specified table is a partitioned table, both the inheritance statistics of the partitioned table as a whole and statistics of the individual partitions are updated.</source>
          <target state="translated">解析する特定のテーブルの名前(スキーマ修飾されている場合もあります)。省略した場合、現在のデータベース内のすべての通常のテーブル、パーティショニングされたテーブル、マテリアライズされたビューが分析されます(外部テーブルは含まれません)。指定されたテーブルがパーティショニングされたテーブルの場合、パーティショニングされたテーブル全体の継承統計と個々のパーティションの統計の両方が更新されます。</target>
        </trans-unit>
        <trans-unit id="a0cd47e6e1a9ee5389b9c55e40402c5ad699bfc0" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of a table.</source>
          <target state="translated">テーブルの名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="36578a59c82b2f2c476f7f18ac9898c7cebf4713" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing domain to alter.</source>
          <target state="translated">変更する既存ドメインの名前(スキーマ修飾の可能性があります)。</target>
        </trans-unit>
        <trans-unit id="c76b8e93831ffb6b044097c12ef94efed652a62a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing foreign table to alter. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is altered. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are altered. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">変更する既存の外部テーブルの名前（おそらくスキーマ修飾）。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが変更されています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）が変更されます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="fc6c50c1390116c899b9f1d7b2719134752e51ac" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing index to alter.</source>
          <target state="translated">変更する既存のインデックスの名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="f3966882870cfe613d0a8e73355b9179fb2c810a" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of an existing type to alter.</source>
          <target state="translated">変更する既存の型の名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="06da0274ecfe82f800f0ab5a5f38a984e49a92a1" translate="yes" xml:space="preserve">
          <source>The name (possibly schema-qualified) of the table to be indexed.</source>
          <target state="translated">インデックスを作成するテーブルの名前(スキーマ修飾されている可能性があります)。</target>
        </trans-unit>
        <trans-unit id="a158ac6caffff3f341ed81dff98d22b9af284fcf" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;test1_id_index&lt;/code&gt; can be chosen freely, but you should pick something that enables you to remember later what the index was for.</source>
          <target state="translated">&lt;code&gt;test1_id_index&lt;/code&gt; という名前は自由に選択できますが、後でインデックスの目的を思い出せる名前を選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="27865390113cdcda66f400351749779a6e670188" translate="yes" xml:space="preserve">
          <source>The name can be any string of less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; characters (64 characters in a standard build). Only printable ASCII characters may be used in the &lt;code&gt;cluster_name&lt;/code&gt; value. Other characters will be replaced with question marks (&lt;code&gt;?&lt;/code&gt;). No name is shown if this parameter is set to the empty string &lt;code&gt;''&lt;/code&gt; (which is the default). This parameter can only be set at server start.</source>
          <target state="translated">名前は、 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 文字（標準ビルドでは64文字）未満の任意の文字列にすることができます。 &lt;code&gt;cluster_name&lt;/code&gt; 値には、印刷可能なASCII文字のみを使用できます。他の文字は疑問符（ &lt;code&gt;?&lt;/code&gt; ）に置き換えられます。このパラメーターが空の文字列 &lt;code&gt;''&lt;/code&gt; （デフォルト）に設定されている場合、名前は表示されません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="0be2813c09731c2a742fdb24fc852c07e13e3ed7" translate="yes" xml:space="preserve">
          <source>The name of a &lt;code&gt;table_name&lt;/code&gt; column. Used to infer arbiter indexes. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on &lt;code&gt;index_column_name&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 列の名前。アービターインデックスを推測するために使用されます。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。 &lt;code&gt;index_column_name&lt;/code&gt; に対する &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="347e4a2b8b46492f607cf8e79afee93d1d470e6b" translate="yes" xml:space="preserve">
          <source>The name of a b-tree operator class for the subtype.</source>
          <target state="translated">サブタイプのb-tree演算子クラスの名前。</target>
        </trans-unit>
        <trans-unit id="84001d19bb8ee2bc0f3fd3214b7948ea87315d70" translate="yes" xml:space="preserve">
          <source>The name of a base-type property to be modified; see above for possible values.</source>
          <target state="translated">変更したいベース型プロパティの名前。</target>
        </trans-unit>
        <trans-unit id="3e4c963309e1915e51f2989fadcd94d4d9264511" translate="yes" xml:space="preserve">
          <source>The name of a column in the new materialized view. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">新しいマテリアライズされたビューのカラム名。カラム名が指定されていない場合は、クエリの出力カラム名から取得します。</target>
        </trans-unit>
        <trans-unit id="38a996c1d10563af1a139319a2d1ffd30fc57281" translate="yes" xml:space="preserve">
          <source>The name of a column in the new table. If column names are not provided, they are taken from the output column names of the query.</source>
          <target state="translated">新しいテーブルのカラム名。カラム名が指定されていない場合は、クエリの出力カラム名から取得されます。</target>
        </trans-unit>
        <trans-unit id="88674d0aca3396b42507d5f644ff534993edea22" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. (Inserting into only some fields of a composite column leaves the other fields null.) When referencing a column with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;, do not include the table's name in the specification of a target column. For example, &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; is invalid (this follows the general behavior for &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; で指定されたテーブル内の列の名前。列名は、必要に応じて、サブフィールド名または配列添え字で修飾できます。 （複合列の一部のフィールドのみに挿入すると、他のフィールドはnullのままになります。） &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; で列を参照するときは、ターゲット列の指定にテーブルの名前を含めないでください。たとえば、 &lt;code&gt;INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1&lt;/code&gt; は無効です（これは &lt;code&gt;UPDATE&lt;/code&gt; の一般的な動作に従います）。</target>
        </trans-unit>
        <trans-unit id="37965fca46dac2ae8978b3ba3784bd4c0e6d710a" translate="yes" xml:space="preserve">
          <source>The name of a column in the table named by &lt;code&gt;table_name&lt;/code&gt;. The column name can be qualified with a subfield name or array subscript, if needed. Do not include the table's name in the specification of a target column &amp;mdash; for example, &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; で指定されたテーブル内の列の名前。列名は、必要に応じてサブフィールド名または配列添え字で修飾できます。ターゲット列の指定にテーブルの名前を含めないでください。たとえば、 &lt;code&gt;UPDATE table_name SET table_name.col = 1&lt;/code&gt; は無効です。</target>
        </trans-unit>
        <trans-unit id="43b0ac7767512f2c3828414a44343ffbdea05c48" translate="yes" xml:space="preserve">
          <source>The name of a column of the table.</source>
          <target state="translated">テーブルのカラム名。</target>
        </trans-unit>
        <trans-unit id="66eab6eba8b42b05c2deccc82d07f73f07802b19" translate="yes" xml:space="preserve">
          <source>The name of a column to be created in the new table.</source>
          <target state="translated">新しいテーブルに作成するカラムの名前。</target>
        </trans-unit>
        <trans-unit id="b107b21b5ebe28c88ce9e0df68fea5f76d67283a" translate="yes" xml:space="preserve">
          <source>The name of a database to create.</source>
          <target state="translated">作成するデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="2836c4dd7800c0b2de8f3f3ed8ae3591f1a8fd6b" translate="yes" xml:space="preserve">
          <source>The name of a difference function for the subtype.</source>
          <target state="translated">サブタイプの差分関数の名前です。</target>
        </trans-unit>
        <trans-unit id="cc2b3b4a893c2c09d0bead8670c584d57f2b3d8a" translate="yes" xml:space="preserve">
          <source>The name of a function that converts an array of modifier(s) for the type into internal form.</source>
          <target state="translated">型の修飾子の配列を内部形式に変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="9cfae7f4211e6fa9e0eeadb788b0238e1401f532" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external binary form to its internal form.</source>
          <target state="translated">型の外部バイナリ形式から内部形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="b8ec9150353430f953f8a2508fb1cc00d06ec3ad" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's external textual form to its internal form.</source>
          <target state="translated">型の外部テキスト形式から内部形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="e45bf619f83208134b19be3fe39ffa394657e429" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external binary form.</source>
          <target state="translated">型の内部形式から外部バイナリ形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="ec568fe6711779cbc4fe49c405863a46d77641d0" translate="yes" xml:space="preserve">
          <source>The name of a function that converts data from the type's internal form to its external textual form.</source>
          <target state="translated">型の内部形式から外部テキスト形式にデータを変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="a4232581838ec7343a99a8c7be95b2e49c198605" translate="yes" xml:space="preserve">
          <source>The name of a function that converts the internal form of the type's modifier(s) to external textual form.</source>
          <target state="translated">型の修飾子の内部形式を外部テキスト形式に変換する関数の名前です。</target>
        </trans-unit>
        <trans-unit id="4ebc5121bc2fa18e076b2f1de0b2de537a76ba61" translate="yes" xml:space="preserve">
          <source>The name of a function that performs statistical analysis for the data type.</source>
          <target state="translated">データ型の統計解析を行う関数の名前です。</target>
        </trans-unit>
        <trans-unit id="8693551fac54570d94fac46289d20bd3cbf6ee4e" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;ALTER EXTENSION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">関数、プロシージャ、または集約引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER EXTENSION&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6fe30dcb3f4583c58770f03da94374abd82c96ab" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;COMMENT&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">関数、プロシージャ、または集約引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;COMMENT&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="037ed7ab4666d9436acdd62556426330fa27de4d" translate="yes" xml:space="preserve">
          <source>The name of a function, procedure, or aggregate argument. Note that &lt;code&gt;SECURITY LABEL&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">関数、プロシージャ、または集約引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;SECURITY LABEL&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="85d26a05a8c2a48486d4d983a4308017ec19fa06" translate="yes" xml:space="preserve">
          <source>The name of a role whose objects will be dropped, and whose privileges will be revoked.</source>
          <target state="translated">オブジェクトが削除され、その権限が取り消されるロールの名前です。</target>
        </trans-unit>
        <trans-unit id="2d651ee55d17fde141e789374afa64231439951d" translate="yes" xml:space="preserve">
          <source>The name of a role. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role will be reassigned to &lt;code&gt;new_role&lt;/code&gt;.</source>
          <target state="translated">役割の名前。現在のデータベース内のすべてのオブジェクトの所有権、およびこのロールが所有するすべての共有オブジェクト（データベース、テーブルスペース）の所有権は、 &lt;code&gt;new_role&lt;/code&gt; に再割り当てされます。</target>
        </trans-unit>
        <trans-unit id="a41f912a967bc6187a0ff565790395916fca2f2a" translate="yes" xml:space="preserve">
          <source>The name of a rule to create. This must be distinct from the name of any other rule for the same table. Multiple rules on the same table and same event type are applied in alphabetical name order.</source>
          <target state="translated">作成するルールの名前。これは、同じテーブルの他のルールの名前とは区別する必要があります。同じテーブルで同じイベントタイプの複数のルールは、アルファベット順に適用されます。</target>
        </trans-unit>
        <trans-unit id="16dbd653daa2713c731e96ec7016300d7b0623c9" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">実行時パラメータの名前。使用可能なパラメーターは、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;と&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;リファレンスページに記載されています。さらに、表示できるが設定できないパラメータがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="aee34bf395a3fa67b708559214834f0819e94a8b" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</source>
          <target state="translated">The name of a run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page. In addition, there are a few parameters that can be shown but not set:</target>
        </trans-unit>
        <trans-unit id="fdb5b09a2e8ba40ee029ef0bb0deb2b715d29f64" translate="yes" xml:space="preserve">
          <source>The name of a schema to be created. If this is omitted, the &lt;code&gt;user_name&lt;/code&gt; is used as the schema name. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">作成するスキーマの名前。これを省略すると、 &lt;code&gt;user_name&lt;/code&gt; がスキーマ名として使用されます。この名前はシステムスキーマ用に予約されているため、名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。</target>
        </trans-unit>
        <trans-unit id="19552fb60b57524fdf3c4ba971f713deaf575934" translate="yes" xml:space="preserve">
          <source>The name of a schema.</source>
          <target state="translated">スキーマの名前です。</target>
        </trans-unit>
        <trans-unit id="bec37b1bb0aae7199fe140e94c49fd869d890cc2" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns.</source>
          <target state="translated">分析する特定のカラムの名前。デフォルトはすべてのカラムです。</target>
        </trans-unit>
        <trans-unit id="f4dd69da6250801b1a99f96f4fc7a1fc3fc7a5ca" translate="yes" xml:space="preserve">
          <source>The name of a specific column to analyze. Defaults to all columns. If a column list is specified, &lt;code&gt;ANALYZE&lt;/code&gt; must also be specified.</source>
          <target state="translated">分析する特定の列の名前。デフォルトはすべての列です。列リストを指定する場合は、 &lt;code&gt;ANALYZE&lt;/code&gt; も指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="4d277ce7dc1369544c960227202849bca34e3070" translate="yes" xml:space="preserve">
          <source>The name of a standby server for this purpose is the &lt;code&gt;application_name&lt;/code&gt; setting of the standby, as set in the standby's connection information. In case of a physical replication standby, this should be set in the &lt;code&gt;primary_conninfo&lt;/code&gt; setting; the default is the setting of &lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_name&lt;/a&gt; if set, else &lt;code&gt;walreceiver&lt;/code&gt;. For logical replication, this can be set in the connection information of the subscription, and it defaults to the subscription name. For other replication stream consumers, consult their documentation.</source>
          <target state="translated">このためのスタンバイサーバーの名前は、スタンバイの接続情報に設定されている、スタンバイの &lt;code&gt;application_name&lt;/code&gt; 設定です。物理レプリケーションスタンバイの場合、これは &lt;code&gt;primary_conninfo&lt;/code&gt; 設定で設定する必要があります。デフォルトは、設定されている場合は&lt;a href=&quot;runtime-config-logging#GUC-CLUSTER-NAME&quot;&gt;cluster_nameの&lt;/a&gt;設定、それ以外の場合は &lt;code&gt;walreceiver&lt;/code&gt; です。論理レプリケーションの場合、これはサブスクリプションの接続情報で設定でき、デフォルトでサブスクリプション名になります。他のレプリケーションストリームコンシューマについては、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c8bcdb2c75dca6dff745c6b72d3eafa935add170" translate="yes" xml:space="preserve">
          <source>The name of a subscription to be dropped.</source>
          <target state="translated">落とす定期購読の名前です。</target>
        </trans-unit>
        <trans-unit id="10c04b3f0b50c7a796c21e054204f49c5305809f" translate="yes" xml:space="preserve">
          <source>The name of a subscription whose properties are to be altered.</source>
          <target state="translated">プロパティが変更されるサブスクリプションの名前。</target>
        </trans-unit>
        <trans-unit id="a917fa888db788a84ebf308d993302ba69b3956f" translate="yes" xml:space="preserve">
          <source>The name of a table column to be covered by the computed statistics. At least two column names must be given; the order of the column names is insignificant.</source>
          <target state="translated">計算された統計量の対象となる表の列の名前。少なくとも2つの列名を指定しなければなりません;列名の順序は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="547022940eaa9d3307e6377842b21fffa3dea285" translate="yes" xml:space="preserve">
          <source>The name of a table storage parameter.</source>
          <target state="translated">テーブルストレージパラメータの名前です。</target>
        </trans-unit>
        <trans-unit id="25f3d061a48202d36e2eddaaf0e7e422750642c9" translate="yes" xml:space="preserve">
          <source>The name of a tablespace to be created. The name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">作成するテーブルスペースの名前。この名前はシステムテーブルスペース用に予約されているため、名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。</target>
        </trans-unit>
        <trans-unit id="f526639651b0458136ca498c2f2f2ac4fbd6800d" translate="yes" xml:space="preserve">
          <source>The name of a tablespace.</source>
          <target state="translated">テーブルスペースの名前。</target>
        </trans-unit>
        <trans-unit id="3f86890bb22a9b09c6fb6202e966b0cb90e86399" translate="yes" xml:space="preserve">
          <source>The name of a template-specific option to be set for this dictionary.</source>
          <target state="translated">この辞書に設定するテンプレート固有のオプションの名前。</target>
        </trans-unit>
        <trans-unit id="d2fc4bb5096ba459cde4afbb76fdac536da62aa5" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be consulted for the specified token type(s). If multiple dictionaries are listed, they are consulted in the specified order.</source>
          <target state="translated">指定されたトークンタイプに対して参照するテキスト検索辞書の名前。複数の辞書がリストアップされている場合は、指定された順番で参照されます。</target>
        </trans-unit>
        <trans-unit id="b2ade2843219f0c75eecbdfb9ad26e157949ac15" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be replaced in the mapping.</source>
          <target state="translated">マッピングで置き換えるテキスト検索辞書の名前。</target>
        </trans-unit>
        <trans-unit id="c2e4d9635ee5eae77abbb98d0d04f44a7382134a" translate="yes" xml:space="preserve">
          <source>The name of a text search dictionary to be substituted for &lt;code&gt;old_dictionary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old_dictionary&lt;/code&gt; の代わりに使用するテキスト検索辞書の名前。</target>
        </trans-unit>
        <trans-unit id="e536a7c03f29f8cbc17f3a583238f110ae4c9ca6" translate="yes" xml:space="preserve">
          <source>The name of a token type that is emitted by the configuration's parser.</source>
          <target state="translated">設定のパーサから出力されるトークン型の名前です。</target>
        </trans-unit>
        <trans-unit id="e42ab0f9b2f16ce7c6531f791e195b576f9b5e7b" translate="yes" xml:space="preserve">
          <source>The name of a variable used to filter events. This makes it possible to restrict the firing of the trigger to a subset of the cases in which it is supported. Currently the only supported &lt;code&gt;filter_variable&lt;/code&gt; is &lt;code&gt;TAG&lt;/code&gt;.</source>
          <target state="translated">イベントのフィルタリングに使用される変数の名前。これにより、トリガーの起動を、トリガーがサポートされるケースのサブセットに制限することができます。現在サポートされている &lt;code&gt;filter_variable&lt;/code&gt; は &lt;code&gt;TAG&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="cbbf80f6f4c468a122711e341fba3efb95ed9b4e" translate="yes" xml:space="preserve">
          <source>The name of an argument.</source>
          <target state="translated">引数の名前です。</target>
        </trans-unit>
        <trans-unit id="e982fa6e95b8aff320484711c377b6849476a259" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">引数の名前。集約関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="56b0baceffec189e51468368e1573f50c02b2801" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="da880762c1ed4640b76217347360561ae983a357" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">引数の名前。プロシージャのIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0681d59ee9000bab536592eb7b8ddac88b06215c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP AGGREGATE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the aggregate function's identity.</source>
          <target state="translated">引数の名前。集約関数のIDを判別するために必要なのは引数のデータ型だけなので、 &lt;code&gt;DROP AGGREGATE&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f97c790620d0347b2dc1f2b503ffe310415155c" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP FUNCTION&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the function's identity.</source>
          <target state="translated">引数の名前。関数のIDを決定するために必要なのは引数のデータ型だけなので、 &lt;code&gt;DROP FUNCTION&lt;/code&gt; は実際には引数名に注意を払わないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="75484c7635e6405e3d0e3238f7f514ab40e45aaa" translate="yes" xml:space="preserve">
          <source>The name of an argument. Note that &lt;code&gt;DROP PROCEDURE&lt;/code&gt; does not actually pay any attention to argument names, since only the argument data types are needed to determine the procedure's identity.</source>
          <target state="translated">引数の名前。ことを注意 &lt;code&gt;DROP PROCEDURE&lt;/code&gt; は、唯一の引数のデータ型が手続きの同一性を決定するために必要ですので、実際に、引数名に注意を払っていません。</target>
        </trans-unit>
        <trans-unit id="6264b5b03c956e34b1a101cf23f2e7ebcfb44a8b" translate="yes" xml:space="preserve">
          <source>The name of an argument. Some languages (including SQL and PL/pgSQL) let you use the name in the function body. For other languages the name of an input argument is just extra documentation, so far as the function itself is concerned; but you can use input argument names when calling a function to improve readability (see &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt;). In any case, the name of an output argument is significant, because it defines the column name in the result row type. (If you omit the name for an output argument, the system will choose a default column name.)</source>
          <target state="translated">引数の名前。一部の言語（SQLおよびPL / pgSQLを含む）では、関数本体で名前を使用できます。他の言語の場合、関数自体に関する限り、入力引数の名前は単なる追加のドキュメントです。ただし、関数を呼び出すときに入力引数名を使用して読みやすくすることができます（&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;セクション4.3を&lt;/a&gt;参照）。いずれの場合でも、出力引数の名前は、結果の行タイプの列名を定義するため、重要です。（出力引数の名前を省略すると、システムはデフォルトの列名を選択します。）</target>
        </trans-unit>
        <trans-unit id="375094d89a9e7c5813b8961536891f0759815217" translate="yes" xml:space="preserve">
          <source>The name of an argument. This is currently only useful for documentation purposes. If omitted, the argument has no name.</source>
          <target state="translated">引数の名前。これは現在のところ、文書化の目的でのみ有用です。省略された場合、引数には名前がありません。</target>
        </trans-unit>
        <trans-unit id="ed524d1ea7eb8aeebc2ae58ea9eeac500ae4de68" translate="yes" xml:space="preserve">
          <source>The name of an attribute (column) for the composite type.</source>
          <target state="translated">複合型の属性(列)の名前。</target>
        </trans-unit>
        <trans-unit id="6a17e927a8bc128615b789bf21656b4af0a59747" translate="yes" xml:space="preserve">
          <source>The name of an existing access method.</source>
          <target state="translated">既存のアクセスメソッドの名前です。</target>
        </trans-unit>
        <trans-unit id="ebcda1893633e936b520a2a0321ab231b1b0ba97" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to be associated with a column of a composite type, or with a range type.</source>
          <target state="translated">複合型のカラム、または範囲型のカラムに関連付けられる既存の照合順序の名前。</target>
        </trans-unit>
        <trans-unit id="6a99a7164db5effbf0ea0eafd9c39dd9aa197443" translate="yes" xml:space="preserve">
          <source>The name of an existing collation to copy. The new collation will have the same properties as the existing one, but it will be an independent object.</source>
          <target state="translated">コピーする既存の照合順序の名前。新しい照合順序は既存のものと同じプロパティを持ちますが、独立したオブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="af62875da4376911af8fd6633488eb76e3df9aa2" translate="yes" xml:space="preserve">
          <source>The name of an existing data type that the new type will have the same representation as. The values of &lt;code&gt;internallength&lt;/code&gt;, &lt;code&gt;passedbyvalue&lt;/code&gt;, &lt;code&gt;alignment&lt;/code&gt;, and &lt;code&gt;storage&lt;/code&gt; are copied from that type, unless overridden by explicit specification elsewhere in this &lt;code&gt;CREATE TYPE&lt;/code&gt; command.</source>
          <target state="translated">新しいデータ型が同じ表現を持つ既存のデータ型の名前。 &lt;code&gt;internallength&lt;/code&gt; 、 &lt;code&gt;passedbyvalue&lt;/code&gt; 、 &lt;code&gt;alignment&lt;/code&gt; 、および &lt;code&gt;storage&lt;/code&gt; の値は、この &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドの他の場所で明示的に指定されてオーバーライドされない限り、そのタイプからコピーされます。</target>
        </trans-unit>
        <trans-unit id="269f93ea4a18405eca9d42f3c25429fa59f4bc3d" translate="yes" xml:space="preserve">
          <source>The name of an existing data type to become a column of the composite type.</source>
          <target state="translated">複合型のカラムになる既存のデータ型の名前。</target>
        </trans-unit>
        <trans-unit id="9a63f99fdd0bce011ca8d049908cd4539b298e7c" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign server to use for the foreign table. For details on defining a server, see &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;.</source>
          <target state="translated">外部テーブルに使用する既存の外部サーバーの名前。サーバーの定義の詳細については、「&lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="f2454ed01e6d27ce51d6d152286d9f4044a0971f" translate="yes" xml:space="preserve">
          <source>The name of an existing foreign-data wrapper.</source>
          <target state="translated">既存の外部データラッパーの名前。</target>
        </trans-unit>
        <trans-unit id="215bb96ed8aefedc59bc2785aaa4809857f9f3b1" translate="yes" xml:space="preserve">
          <source>The name of an existing index.</source>
          <target state="translated">既存のインデックスの名前。</target>
        </trans-unit>
        <trans-unit id="dcfd6d7a1b6a134c08f28bb84b429370f63f9bf9" translate="yes" xml:space="preserve">
          <source>The name of an existing policy to alter.</source>
          <target state="translated">変更する既存のポリシーの名前です。</target>
        </trans-unit>
        <trans-unit id="d3e43edda0ed2c669ea64ea4de1cacab37227192" translate="yes" xml:space="preserve">
          <source>The name of an existing procedural language. For backward compatibility, the name can be enclosed by single quotes.</source>
          <target state="translated">既存の手続き型言語の名前。後方互換性のために、名前は単一引用符で囲むことができます。</target>
        </trans-unit>
        <trans-unit id="dbc811803ec9f6996f00764f5d9b3a696bbe0492" translate="yes" xml:space="preserve">
          <source>The name of an existing publication whose definition is to be altered.</source>
          <target state="translated">定義を変更する既存の出版物の名前。</target>
        </trans-unit>
        <trans-unit id="e43f43145062802662e910809c0dbf5106a36151" translate="yes" xml:space="preserve">
          <source>The name of an existing publication.</source>
          <target state="translated">既存の出版物の名前。</target>
        </trans-unit>
        <trans-unit id="51d243f6e89c7e39326aaa5f0f4dbaf017f84cd3" translate="yes" xml:space="preserve">
          <source>The name of an existing role of which the current role is a member. If &lt;code&gt;FOR ROLE&lt;/code&gt; is omitted, the current role is assumed.</source>
          <target state="translated">現在の役割がメンバーになっている既存の役割の名前。場合 &lt;code&gt;FOR ROLE&lt;/code&gt; 省略され、現在の役割が想定されます。</target>
        </trans-unit>
        <trans-unit id="55490c4e62932d1546a037c62cdff84638b0e3d3" translate="yes" xml:space="preserve">
          <source>The name of an existing role to grant or revoke privileges for. This parameter, and all the other parameters in &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt;, act as described under &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; or &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;, except that one is setting permissions for a whole class of objects rather than specific named objects.</source>
          <target state="translated">権限を付与または取り消す既存のロールの名前。このパラメーター、および &lt;code&gt;abbreviated_grant_or_revoke&lt;/code&gt; の他のすべてのパラメーターは、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;または&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;で説明されているとおりに機能します。ただし、特定の名前付きオブジェクトではなく、オブジェクトのクラス全体にアクセス許可を設定します。</target>
        </trans-unit>
        <trans-unit id="c635ecbb1c53d1706cdab235bd6da7bb6c713113" translate="yes" xml:space="preserve">
          <source>The name of an existing rule to alter.</source>
          <target state="translated">変更する既存のルールの名前。</target>
        </trans-unit>
        <trans-unit id="313ea254effb62079628babb9fa1cbd9eaa5bbb0" translate="yes" xml:space="preserve">
          <source>The name of an existing schema.</source>
          <target state="translated">既存のスキーマの名前。</target>
        </trans-unit>
        <trans-unit id="5f4188f167a8cf646d3b7406994faa33188bb313" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when setting privileges for schemas, since schemas can't be nested.</source>
          <target state="translated">The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when setting privileges for schemas, since schemas can't be nested.</target>
        </trans-unit>
        <trans-unit id="cc48699243fdc0b302f46f2ff91dbd816b03aa4b" translate="yes" xml:space="preserve">
          <source>The name of an existing schema. If specified, the default privileges are altered for objects later created in that schema. If &lt;code&gt;IN SCHEMA&lt;/code&gt; is omitted, the global default privileges are altered. &lt;code&gt;IN SCHEMA&lt;/code&gt; is not allowed when using &lt;code&gt;ON SCHEMAS&lt;/code&gt; as schemas can't be nested.</source>
          <target state="translated">既存のスキーマの名前。指定した場合、そのスキーマで後で作成されるオブジェクトのデフォルト特権が変更されます。場合は &lt;code&gt;IN SCHEMA&lt;/code&gt; 省略され、グローバルなデフォルト権限が変更されています。 &lt;code&gt;ON SCHEMAS&lt;/code&gt; を使用する場合、スキーマはネストできないため、 &lt;code&gt;IN SCHEMA&lt;/code&gt; は許可されません。</target>
        </trans-unit>
        <trans-unit id="02ea513b553c81e6e8bfffc28bfc183407ce6f92" translate="yes" xml:space="preserve">
          <source>The name of an existing server for which the user mapping is to be created.</source>
          <target state="translated">ユーザー マッピングを作成する既存のサーバーの名前です。</target>
        </trans-unit>
        <trans-unit id="94ab6bc9007ffe24527bb571f8caf6972fd6e32c" translate="yes" xml:space="preserve">
          <source>The name of an existing server.</source>
          <target state="translated">既存のサーバーの名前です。</target>
        </trans-unit>
        <trans-unit id="7b99635b20ef9c6fbf704b3d5683df0c76ea50a5" translate="yes" xml:space="preserve">
          <source>The name of an existing tablespace.</source>
          <target state="translated">既存のテーブルスペースの名前。</target>
        </trans-unit>
        <trans-unit id="1fba9536f8e094817879340972f3fc186e59ac3a" translate="yes" xml:space="preserve">
          <source>The name of an existing text search configuration to copy.</source>
          <target state="translated">コピーする既存のテキスト検索設定の名前。</target>
        </trans-unit>
        <trans-unit id="e62d3905f77c5380a51ef346837f8bb973da087a" translate="yes" xml:space="preserve">
          <source>The name of an existing trigger to alter.</source>
          <target state="translated">変更する既存のトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="39eaed243c343dcf7cbdeda1eb27256bd699e984" translate="yes" xml:space="preserve">
          <source>The name of an existing user that is mapped to foreign server. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. When &lt;code&gt;PUBLIC&lt;/code&gt; is specified, a so-called public mapping is created that is used when no user-specific mapping is applicable.</source>
          <target state="translated">外部サーバーにマップされている既存のユーザーの名前。 &lt;code&gt;CURRENT_USER&lt;/code&gt; および &lt;code&gt;USER&lt;/code&gt; は、現在のユーザーの名前と一致します。とき &lt;code&gt;PUBLIC&lt;/code&gt; が指定されている、いわゆる公共のマッピングには、ユーザ固有のマッピングが適用されない場合に使用されているが作成されます。</target>
        </trans-unit>
        <trans-unit id="7ff3e30c52fed6a21d64c778f1c3cb5bfde69e2e" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter.</source>
          <target state="translated">インデックス・メソッド固有のストレージ・パラメータの名前。</target>
        </trans-unit>
        <trans-unit id="391b7b7e4f5957c20764197abfbac06a778f9581" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; below for details.</source>
          <target state="translated">The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; below for details.</target>
        </trans-unit>
        <trans-unit id="094d120f87047ccaf9df626ee5c7800b9676897f" translate="yes" xml:space="preserve">
          <source>The name of an index-method-specific storage parameter. See &lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;Index Storage Parameters&lt;/a&gt; for details.</source>
          <target state="translated">インデックスメソッド固有の格納パラメーターの名前。詳細については、&lt;a href=&quot;sql-createindex#SQL-CREATEINDEX-STORAGE-PARAMETERS&quot;&gt;インデックスストレージパラメータ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b4f0f37a4747ead833ac927d954e2f698dfd533d" translate="yes" xml:space="preserve">
          <source>The name of an index.</source>
          <target state="translated">インデックスの名前。</target>
        </trans-unit>
        <trans-unit id="905bf1ebfe51e20690887bb37e5649f46c622ebf" translate="yes" xml:space="preserve">
          <source>The name of an installed extension.</source>
          <target state="translated">インストールされている拡張機能の名前。</target>
        </trans-unit>
        <trans-unit id="31791bd4a497bca0b376ada0235a5c621eadda59" translate="yes" xml:space="preserve">
          <source>The name of an object to be added to or removed from the extension. Names of tables, aggregates, domains, foreign tables, functions, operators, operator classes, operator families, procedures, routines, sequences, text search objects, types, and views can be schema-qualified.</source>
          <target state="translated">拡張機能に追加または削除するオブジェクトの名前。テーブル、集約、ドメイン、外部テーブル、関数、演算子、演算子クラス、演算子ファミリー、プロシージャ、ルーチン、シーケンス、テキスト検索オブジェクト、型、およびビューの名前をスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="649c7c5351f25263eb73a851a860d7f29c995641" translate="yes" xml:space="preserve">
          <source>The name of an open cursor to close.</source>
          <target state="translated">閉じるオープンカーソルの名前。</target>
        </trans-unit>
        <trans-unit id="cd55222991d683c14fbae3099b3d272c1928bd18" translate="yes" xml:space="preserve">
          <source>The name of an operator class parameter. See below for details.</source>
          <target state="translated">演算子クラスのパラメータの名前です。詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="8b92d299708f5e6b56970b9d25ff76f34c8756f5" translate="yes" xml:space="preserve">
          <source>The name of an operator class. See below for details.</source>
          <target state="translated">演算子クラスの名前です。詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="4bf28d916074af135f4ae230a1fccbd417f00476" translate="yes" xml:space="preserve">
          <source>The name of an output column in the &lt;code&gt;RETURNS TABLE&lt;/code&gt; syntax. This is effectively another way of declaring a named &lt;code&gt;OUT&lt;/code&gt; parameter, except that &lt;code&gt;RETURNS TABLE&lt;/code&gt; also implies &lt;code&gt;RETURNS SETOF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNS TABLE&lt;/code&gt; 構文の出力列の名前。これは事実上、名前付き &lt;code&gt;OUT&lt;/code&gt; パラメータを宣言するもう1つの方法ですが、 &lt;code&gt;RETURNS TABLE&lt;/code&gt; は &lt;code&gt;RETURNS SETOF&lt;/code&gt; も暗黙的に指定します。</target>
        </trans-unit>
        <trans-unit id="7860b7ca240f288c9e09edb9a6f18857751787c5" translate="yes" xml:space="preserve">
          <source>The name of next WAL segment file should be larger than any WAL segment file name currently existing in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory. These names are also in hexadecimal and have three parts. The first part is the &amp;ldquo;timeline ID&amp;rdquo; and should usually be kept the same. For example, if &lt;code&gt;00000001000000320000004A&lt;/code&gt; is the largest entry in &lt;code&gt;pg_wal&lt;/code&gt;, use &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; or higher.</source>
          <target state="translated">次のWALセグメントファイルの名前は、データディレクトリの下の &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリに現在存在するWALセグメントファイル名よりも大きくする必要があります。これらの名前も16進数で、3つの部分に分かれています。最初の部分は「タイムラインID」であり、通常は同じに保つ必要があります。たとえば、 &lt;code&gt;00000001000000320000004A&lt;/code&gt; が &lt;code&gt;pg_wal&lt;/code&gt; の最大のエントリである場合、 &lt;code&gt;-l 00000001000000320000004B&lt;/code&gt; 以上を使用します。</target>
        </trans-unit>
        <trans-unit id="d8e7a2287904ed813d9d1d342dd594453e6a492a" translate="yes" xml:space="preserve">
          <source>The name of the access method to be created.</source>
          <target state="translated">作成するアクセスメソッドの名前です。</target>
        </trans-unit>
        <trans-unit id="a1d2d753926a3554219bc61e5340b3472157868a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to add, alter, or drop.</source>
          <target state="translated">追加、変更、または削除する属性の名前。</target>
        </trans-unit>
        <trans-unit id="5c7d389a37d0c9ede9dd1bea0952aff86a55c92e" translate="yes" xml:space="preserve">
          <source>The name of the canonicalization function for the range type.</source>
          <target state="translated">範囲型の正規化関数の名前です。</target>
        </trans-unit>
        <trans-unit id="243c7e9e7dd348f6643caec550e3f500eb8cc280" translate="yes" xml:space="preserve">
          <source>The name of the collation to use for the index. By default, the index uses the collation declared for the column to be indexed or the result collation of the expression to be indexed. Indexes with non-default collations can be useful for queries that involve expressions using non-default collations.</source>
          <target state="translated">インデックスに使用する照合順序の名前。デフォルトでは、インデックスはインデックスを作成する列に対して宣言された照合順序、またはインデックスを作成する式の結果の照合順序を使用します。デフォルト以外の照合順序を持つインデックスは、デフォルト以外の照合順序を使用する式を含む問い合わせに便利です。</target>
        </trans-unit>
        <trans-unit id="77f1c321d574cf562cfe00eca4e768698060a618" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified.</source>
          <target state="translated">照合の名前。照合順序の名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="ceb886814d1ec273ae0613d250c7095ff800d469" translate="yes" xml:space="preserve">
          <source>The name of the collation. The collation name can be schema-qualified. If it is not, the collation is defined in the current schema. The collation name must be unique within that schema. (The system catalogs can contain collations with the same name for other encodings, but these are ignored if the database encoding does not match.)</source>
          <target state="translated">照合の名前。照合順序の名前はスキーマで修飾することができます。スキーマ修飾されていない場合、照合順序は現在のスキーマで定義されます。照合順序名はスキーマ内で一意でなければなりません。(システムカタログには、他のエンコーディングと同じ名前の照合順序を含めることができますが、データベースのエンコーディングが一致しない場合は無視されます)</target>
        </trans-unit>
        <trans-unit id="9f63d4696a4bbfab6f19c7c4c3231039f6a920b8" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified.</source>
          <target state="translated">変換の名前です。変換名はスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="0a0e15e0eec7998677fce35d40af5b0838f2cb6f" translate="yes" xml:space="preserve">
          <source>The name of the conversion. The conversion name can be schema-qualified. If it is not, the conversion is defined in the current schema. The conversion name must be unique within a schema.</source>
          <target state="translated">変換の名前です。変換名はスキーマ修飾されていることがあります。そうでない場合、変換は現在のスキーマで定義されます。変換名はスキーマ内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c9574a7a1218329dadec3b5ae9047230517d66aa" translate="yes" xml:space="preserve">
          <source>The name of the current database.</source>
          <target state="translated">現在のデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="1d7349ab2501bed854162775079bf683be5a7fac" translate="yes" xml:space="preserve">
          <source>The name of the cursor</source>
          <target state="translated">カーソルの名前</target>
        </trans-unit>
        <trans-unit id="b6d5b083913d1c8495981451aeb22d6a26cea7b8" translate="yes" xml:space="preserve">
          <source>The name of the cursor to be created.</source>
          <target state="translated">作成するカーソルの名前。</target>
        </trans-unit>
        <trans-unit id="88e407c8ddef33e57e58fe4ab21cafbf53e15168" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be deleted is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;DELETE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 条件で使用するカーソルの名前。削除される行は、このカーソルから最後にフェッチされた行です。カーソルは、 &lt;code&gt;DELETE&lt;/code&gt; のターゲットテーブルに対する非グループ化クエリである必要があります。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; はブール条件と一緒に指定できないことに注意してください。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; でのカーソルの使用の詳細については、&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="38020942de5ae8771a5e3d0b598b6d0ab023caec" translate="yes" xml:space="preserve">
          <source>The name of the cursor to use in a &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; condition. The row to be updated is the one most recently fetched from this cursor. The cursor must be a non-grouping query on the &lt;code&gt;UPDATE&lt;/code&gt;'s target table. Note that &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; cannot be specified together with a Boolean condition. See &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; for more information about using cursors with &lt;code&gt;WHERE CURRENT OF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WHERE CURRENT OF&lt;/code&gt; 条件で使用するカーソルの名前。更新される行は、このカーソルから最後にフェッチされた行です。カーソルは、 &lt;code&gt;UPDATE&lt;/code&gt; のターゲットテーブルの非グループ化クエリである必要があります。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; はブール条件と一緒に指定できないことに注意してください。 &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; でのカーソルの使用の詳細については、&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a37403f5a4aea39da3b7fe089d21ee355979a3e1" translate="yes" xml:space="preserve">
          <source>The name of the data type of the transform.</source>
          <target state="translated">トランスフォームのデータ型の名前。</target>
        </trans-unit>
        <trans-unit id="af7361a3be8ca4eab2c0f2265411cfd60f5af420" translate="yes" xml:space="preserve">
          <source>The name of the database the configuration variable should be set in.</source>
          <target state="translated">設定変数が設定されるべきデータベースの名前です。</target>
        </trans-unit>
        <trans-unit id="84b00afcd962f475515c1915126400e90b5a9818" translate="yes" xml:space="preserve">
          <source>The name of the database this slot is associated with, or null. Only logical slots have an associated database.</source>
          <target state="translated">このスロットが関連付けられているデータベースの名前、またはnullです。論理スロットのみが関連付けられたデータベースを持ちます。</target>
        </trans-unit>
        <trans-unit id="2a89c928e3a93a0e913b45ef5c9ea96a08977f60" translate="yes" xml:space="preserve">
          <source>The name of the database to remove.</source>
          <target state="translated">削除するデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="0fd3bf3f6aa3e86ff6150d84d8e17149c266ae35" translate="yes" xml:space="preserve">
          <source>The name of the database whose attributes are to be altered.</source>
          <target state="translated">属性を変更するデータベースの名前です。</target>
        </trans-unit>
        <trans-unit id="0944e5dfd14965f192e2a8ef7a09d183046338d3" translate="yes" xml:space="preserve">
          <source>The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">現在接続しているデータベースの名前です。これは、データベースに接続するたびに(プログラムの起動を含む)設定されますが、変更したり、設定を解除したりすることができます。</target>
        </trans-unit>
        <trans-unit id="11232ebb2f1cf69c5f3c6cd470c6a4d13d479f8e" translate="yes" xml:space="preserve">
          <source>The name of the element type that the range type will represent ranges of.</source>
          <target state="translated">範囲型が範囲を表す要素型の名前です。</target>
        </trans-unit>
        <trans-unit id="2c439c06e3cc89c7e2b7094efdc072f8eaa5f405" translate="yes" xml:space="preserve">
          <source>The name of the end function for the parser.</source>
          <target state="translated">パーサーの終了関数の名前です。</target>
        </trans-unit>
        <trans-unit id="4682e028a8481b8dc70802bb5909c69f9733e336" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">指定された関数の呼び出しをトリガーするイベントの名前。イベント名の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/event-trigger-definition.html&quot;&gt;セクション39.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="48923e41b7df203b0e79b78492f062da75beedf7" translate="yes" xml:space="preserve">
          <source>The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</source>
          <target state="translated">The name of the event that triggers a call to the given function. See &lt;a href=&quot;https://www.postgresql.org/docs/13/event-trigger-definition.html&quot;&gt;Section 39.1&lt;/a&gt; for more information on event names.</target>
        </trans-unit>
        <trans-unit id="28c26a8cf1a6172d4db73edd5254e5a34f8a5967" translate="yes" xml:space="preserve">
          <source>The name of the event trigger to remove.</source>
          <target state="translated">削除するイベントトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="850574c01fb5268b0342a8b6bb42720569d55e9d" translate="yes" xml:space="preserve">
          <source>The name of the existing operator family to add this operator class to. If not specified, a family named the same as the operator class is used (creating it, if it doesn't already exist).</source>
          <target state="translated">この演算子クラスを追加する既存の演算子ファミリーの名前。指定しない場合は、演算子クラスと同じ名前のファミリが使用されます (既に存在しない場合は作成されます)。</target>
        </trans-unit>
        <trans-unit id="e1cc11f5fc0531b3a520c5755578268d661fb876" translate="yes" xml:space="preserve">
          <source>The name of the extension that the function is to depend on.</source>
          <target state="translated">関数が依存する拡張子の名前。</target>
        </trans-unit>
        <trans-unit id="6af23b7fd50d16bb7de156bad92b5bd09f67edbf" translate="yes" xml:space="preserve">
          <source>The name of the extension that the index is to depend on.</source>
          <target state="translated">インデックスが依存する拡張子の名前。</target>
        </trans-unit>
        <trans-unit id="0076c726a59acb3194ce3e4e3b9519a8daeff897" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A materialized view that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">The name of the extension that the materialized view is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A materialized view that's marked as dependent on an extension is automatically dropped when the extension is dropped.</target>
        </trans-unit>
        <trans-unit id="dc831ae12120e6fd5fdd21a20fd1a1e7bd573e67" translate="yes" xml:space="preserve">
          <source>The name of the extension that the materialized view is to depend on.</source>
          <target state="translated">マテリアライズされたビューが依存する拡張子の名前です。</target>
        </trans-unit>
        <trans-unit id="4f55051df080e15b2a3119833fb2677544739012" translate="yes" xml:space="preserve">
          <source>The name of the extension that the procedure is to depend on.</source>
          <target state="translated">プロシージャが依存する拡張子の名前です。</target>
        </trans-unit>
        <trans-unit id="eb5ffaeae34b0a924ba5f2135444604598a2a8e1" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A trigger that's marked as dependent on an extension is automatically dropped when the extension is dropped.</source>
          <target state="translated">The name of the extension that the trigger is to depend on (or no longer dependent on, if &lt;code&gt;NO&lt;/code&gt; is specified). A trigger that's marked as dependent on an extension is automatically dropped when the extension is dropped.</target>
        </trans-unit>
        <trans-unit id="0a35573e050ab73e125502a3b5564abce7fd88f9" translate="yes" xml:space="preserve">
          <source>The name of the extension that the trigger is to depend on.</source>
          <target state="translated">トリガーが依存する拡張子の名前です。</target>
        </trans-unit>
        <trans-unit id="88e9cf7b26c10377ec9b042f69222e5d8682e8ed" translate="yes" xml:space="preserve">
          <source>The name of the extension to be installed. PostgreSQL will create the extension using details from the file &lt;code&gt;SHAREDIR/extension/&lt;/code&gt;&lt;code&gt;extension_name&lt;/code&gt;&lt;code&gt;.control&lt;/code&gt;.</source>
          <target state="translated">インストールする拡張機能の名前。PostgreSQLは、ファイル &lt;code&gt;SHAREDIR/extension/&lt;/code&gt; &lt;code&gt;extension_name&lt;/code&gt; &lt;code&gt;.control&lt;/code&gt; の詳細を使用して拡張機能を作成します。</target>
        </trans-unit>
        <trans-unit id="d6fa04f440c0a0fbd9ef5c8562fd34285144f5e9" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed, when using moving-aggregate mode. This works the same as &lt;code&gt;ffunc&lt;/code&gt;, except that its first argument's type is &lt;code&gt;mstate_data_type&lt;/code&gt; and extra dummy arguments are specified by writing &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;. The aggregate result type determined by &lt;code&gt;mffunc&lt;/code&gt; or &lt;code&gt;mstate_data_type&lt;/code&gt; must match that determined by the aggregate's regular implementation.</source>
          <target state="translated">移動集約モードを使用している場合に、すべての入力行をたどった後に集約の結果を計算するために呼び出される最後の関数の名前。これは &lt;code&gt;mstate_data_type&lt;/code&gt; と同じように &lt;code&gt;ffunc&lt;/code&gt; ますが、最初の引数の型がmstate_data_typeであり、追加の仮引数が &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; を記述することによって指定される点が異なります。 &lt;code&gt;mffunc&lt;/code&gt; または &lt;code&gt;mstate_data_type&lt;/code&gt; によって決定される集計結果のタイプは、集計の通常の実装によって決定されるものと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="f5f06809f2c728bd2159e0f8d844d66eca27a10c" translate="yes" xml:space="preserve">
          <source>The name of the final function called to compute the aggregate's result after all input rows have been traversed. For a normal aggregate, this function must take a single argument of type &lt;code&gt;state_data_type&lt;/code&gt;. The return data type of the aggregate is defined as the return type of this function. If &lt;code&gt;ffunc&lt;/code&gt; is not specified, then the ending state value is used as the aggregate's result, and the return type is &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">すべての入力行をたどった後に集計の結果を計算するために呼び出される最後の関数の名前。通常の集計の場合、この関数はタイプ &lt;code&gt;state_data_type&lt;/code&gt; の単一の引数を取る必要があります。集約の戻りデータ型は、この関数の戻り型として定義されています。 &lt;code&gt;ffunc&lt;/code&gt; が指定されていない場合、終了状態の値が集計の結果として使用され、戻り値の型は &lt;code&gt;state_data_type&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="72c35b2edf9735176f859431671ff1f17e5d197c" translate="yes" xml:space="preserve">
          <source>The name of the foreign server to be created.</source>
          <target state="translated">作成する外部サーバーの名前です。</target>
        </trans-unit>
        <trans-unit id="c3a096f51b1b0afdadcf653b248a2d3f34aa4744" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper that manages the server.</source>
          <target state="translated">サーバを管理する外部データラッパーの名前です。</target>
        </trans-unit>
        <trans-unit id="d54745f11f4179244c18fb9a79fb68702588d241" translate="yes" xml:space="preserve">
          <source>The name of the foreign-data wrapper to be created.</source>
          <target state="translated">作成する外部データラッパーの名前です。</target>
        </trans-unit>
        <trans-unit id="1fdbb3b7aa9f05df80cfbaca84874bb5ff3faf75" translate="yes" xml:space="preserve">
          <source>The name of the forward state transition function to be called for each input row in moving-aggregate mode. This is exactly like the regular transition function, except that its first argument and result are of type &lt;code&gt;mstate_data_type&lt;/code&gt;, which might be different from &lt;code&gt;state_data_type&lt;/code&gt;.</source>
          <target state="translated">移動集約モードで各入力行に対して呼び出される転送状態遷移関数の名前。これは通常の遷移関数とまったく同じですが、最初の引数と結果の型が &lt;code&gt;mstate_data_type&lt;/code&gt; であり、 &lt;code&gt;state_data_type&lt;/code&gt; とは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="644a4d91bed7658870a145ab3141d930ef90e912" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the SQL environment to the language. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;internal&lt;/code&gt;. The actual argument will be of the type for the transform, and the function should be coded as if it were. (But it is not allowed to declare an SQL-level function returning &lt;code&gt;internal&lt;/code&gt; without at least one argument of type &lt;code&gt;internal&lt;/code&gt;.) The actual return value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">タイプをSQL環境から言語に変換する関数の名前。これは、タイプの一つの引数を取らなければならない &lt;code&gt;internal&lt;/code&gt; および戻り値の型が &lt;code&gt;internal&lt;/code&gt; 。実際の引数は変換のタイプであり、関数はあたかもそうであるかのようにコード化されるべきです。 （ただし、少なくとも1つの &lt;code&gt;internal&lt;/code&gt; 型の引数なしで &lt;code&gt;internal&lt;/code&gt; を返すSQLレベルの関数を宣言することはできません。）実際の戻り値は、言語の実装に固有の値になります。引数リストが指定されていない場合、関数名はそのスキーマ内で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="72f3b32f063bc50605b229238d27a5869c6aa7b9" translate="yes" xml:space="preserve">
          <source>The name of the function for converting the type from the language to the SQL environment. It must take one argument of type &lt;code&gt;internal&lt;/code&gt; and return the type that is the type for the transform. The actual argument value will be something specific to the language implementation. If no argument list is specified, the function name must be unique in its schema.</source>
          <target state="translated">型を言語からSQL環境に変換する関数の名前。これは、 &lt;code&gt;internal&lt;/code&gt; 型の引数を1つ取り、変換の型である型を返す必要があります。実際の引数値は、言語の実装に固有の値になります。引数リストが指定されていない場合、関数名はそのスキーマ内で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="67cb877b3731a337b10795d0e7186566d6a3d1e1" translate="yes" xml:space="preserve">
          <source>The name of the get-next-token function for the parser.</source>
          <target state="translated">パーサのget-next-token関数の名前です。</target>
        </trans-unit>
        <trans-unit id="6d1ebf156ba07f5a77467c8ec4ff708f33b3fc16" translate="yes" xml:space="preserve">
          <source>The name of the group (role) to modify.</source>
          <target state="translated">変更するグループ(ロール)の名前。</target>
        </trans-unit>
        <trans-unit id="2ed53b580ba0bc8625e75a9560c3a6e88d077a4d" translate="yes" xml:space="preserve">
          <source>The name of the headline function for the parser (a function that summarizes a set of tokens).</source>
          <target state="translated">パーサのヘッドライン関数(トークンの集合を要約する関数)の名前です。</target>
        </trans-unit>
        <trans-unit id="a3a747073ce359aa3857b433256c5b13312b5a04" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator class is for.</source>
          <target state="translated">演算子クラスが使用するインデックスアクセスメソッドの名前。</target>
        </trans-unit>
        <trans-unit id="ed18a236c732efe90dba559278f7adbf5db0ca9c" translate="yes" xml:space="preserve">
          <source>The name of the index access method the operator family is for.</source>
          <target state="translated">演算子ファミリが使用するインデックスアクセスメソッドの名前。</target>
        </trans-unit>
        <trans-unit id="c45cc6bfca0d231f36cbda7b1370cd41ed1d67b6" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator class is for.</source>
          <target state="translated">この演算子クラスのインデックスメソッドの名前。</target>
        </trans-unit>
        <trans-unit id="615794124cec123ffa046fc334d0b7cb274ccdc2" translate="yes" xml:space="preserve">
          <source>The name of the index method this operator family is for.</source>
          <target state="translated">この演算子ファミリが使用するインデックス・メソッドの名前。</target>
        </trans-unit>
        <trans-unit id="4bb90538453113f1fb57ae8f2d37c35f322febf6" translate="yes" xml:space="preserve">
          <source>The name of the index method to be used. Choices are &lt;code&gt;btree&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;gist&lt;/code&gt;, &lt;code&gt;spgist&lt;/code&gt;, &lt;code&gt;gin&lt;/code&gt;, and &lt;code&gt;brin&lt;/code&gt;. The default method is &lt;code&gt;btree&lt;/code&gt;.</source>
          <target state="translated">使用するインデックスメソッドの名前。選択肢は、 &lt;code&gt;btree&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; 、 &lt;code&gt;gist&lt;/code&gt; 、 &lt;code&gt;spgist&lt;/code&gt; 、 &lt;code&gt;gin&lt;/code&gt; 、および &lt;code&gt;brin&lt;/code&gt; 。デフォルトのメソッドは &lt;code&gt;btree&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bb830e2432e53c927391aeee88f93bb4667bcae4" translate="yes" xml:space="preserve">
          <source>The name of the index to be created. No schema name can be included here; the index is always created in the same schema as its parent table. If the name is omitted, PostgreSQL chooses a suitable name based on the parent table's name and the indexed column name(s).</source>
          <target state="translated">作成するインデックスの名前。インデックスは常に親テーブルと同じスキーマで作成されます。名前が省略された場合、PostgreSQLは親テーブルの名前とインデックス化された列名に基づいて適切な名前を選択します。</target>
        </trans-unit>
        <trans-unit id="a4663fb986b280170b92707494282c81c2899c4f" translate="yes" xml:space="preserve">
          <source>The name of the init function for the template.</source>
          <target state="translated">テンプレートのinit関数の名前です。</target>
        </trans-unit>
        <trans-unit id="f00fd5139904e6694b429785636163e14a782210" translate="yes" xml:space="preserve">
          <source>The name of the inverse state transition function to be used in moving-aggregate mode. This function has the same argument and result types as &lt;code&gt;msfunc&lt;/code&gt;, but it is used to remove a value from the current aggregate state, rather than add a value to it. The inverse transition function must have the same strictness attribute as the forward state transition function.</source>
          <target state="translated">移動集約モードで使用される逆状態遷移関数の名前。この関数の引数と結果の型は &lt;code&gt;msfunc&lt;/code&gt; と同じですが、値を追加するのではなく、現在の集計状態から値を削除するために使用されます。逆遷移関数は、順方向状態遷移関数と同じ厳密性属性を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="3d95c2fd2534c7b2ce3a1746cb2c27650d29fdc4" translate="yes" xml:space="preserve">
          <source>The name of the language of the transform.</source>
          <target state="translated">トランスフォームの言語名。</target>
        </trans-unit>
        <trans-unit id="26a3e76d4aff5006209caa326a5bf1517ad79006" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">関数を実装している言語の名前が。それはすることができ &lt;code&gt;sql&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;internal&lt;/code&gt; 、またはユーザ定義の手続き言語、例えばの名前 &lt;code&gt;plpgsql&lt;/code&gt; が。名前を単一引用符で囲むことは非推奨であり、一致する大文字小文字が必要です。</target>
        </trans-unit>
        <trans-unit id="c42d1caf7aebd169681e8521779ebec6bdd5b337" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">The name of the language that the function is implemented in. It can be &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; , or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt; . Enclosing the name in single quotes is deprecated and requires matching case.</target>
        </trans-unit>
        <trans-unit id="0b5713bc5c339abbdacc15961df416377c21c0e3" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g. &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">手順を実装している言語の名前が。それはすることができ &lt;code&gt;sql&lt;/code&gt; 、 &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;internal&lt;/code&gt; 、またはユーザ定義の手続き言語、例えばの名前 &lt;code&gt;plpgsql&lt;/code&gt; が。名前を単一引用符で囲むことは非推奨であり、一致する大文字小文字が必要です。</target>
        </trans-unit>
        <trans-unit id="6442a7baa7c6ad1af9dfd2863b84c1d799ed57dc" translate="yes" xml:space="preserve">
          <source>The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt;. Enclosing the name in single quotes is deprecated and requires matching case.</source>
          <target state="translated">The name of the language that the procedure is implemented in. It can be &lt;code&gt;sql&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; , or the name of a user-defined procedural language, e.g., &lt;code&gt;plpgsql&lt;/code&gt; . Enclosing the name in single quotes is deprecated and requires matching case.</target>
        </trans-unit>
        <trans-unit id="86f56142098dd6b61f4dc395fb22e1f6084da31b" translate="yes" xml:space="preserve">
          <source>The name of the lexize function for the template.</source>
          <target state="translated">テンプレートの lexize 関数の名前です。</target>
        </trans-unit>
        <trans-unit id="78bf3c88f1577390b2b7639c878108066bdde80d" translate="yes" xml:space="preserve">
          <source>The name of the lextypes function for the parser (a function that returns information about the set of token types it produces).</source>
          <target state="translated">パーサの lextypes 関数の名前(生成するトークン型の集合に関する情報を返す関数)。</target>
        </trans-unit>
        <trans-unit id="99c5d2489b4f3028ca831f4f9b0e7e15704ecdca" translate="yes" xml:space="preserve">
          <source>The name of the new procedural language. The name must be unique among the languages in the database.</source>
          <target state="translated">新しい手続き言語の名前。この名前はデータベース内の言語の中で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf36b4ea435ecc1c1aaf6ed21ca9df2c4c0596b3" translate="yes" xml:space="preserve">
          <source>The name of the new publication.</source>
          <target state="translated">新刊の名前です。</target>
        </trans-unit>
        <trans-unit id="dc580686d337370d500fabd6d8d4233f2a645d1a" translate="yes" xml:space="preserve">
          <source>The name of the new role.</source>
          <target state="translated">新しい役割の名前です。</target>
        </trans-unit>
        <trans-unit id="9deb527e5d18a4a607e93b3c59b44924e3848af5" translate="yes" xml:space="preserve">
          <source>The name of the new subscription.</source>
          <target state="translated">新しいサブスクリプションの名前です。</target>
        </trans-unit>
        <trans-unit id="84ca9243f0b08a6130478bf4d0fddd3954c72484" translate="yes" xml:space="preserve">
          <source>The name of the object to be commented. Names of tables, aggregates, collations, conversions, domains, foreign tables, functions, indexes, operators, operator classes, operator families, procedures, routines, sequences, statistics, text search objects, types, and views can be schema-qualified. When commenting on a column, &lt;code&gt;relation_name&lt;/code&gt; must refer to a table, view, composite type, or foreign table.</source>
          <target state="translated">コメントするオブジェクトの名前。テーブル、集計、照合、変換、ドメイン、外部テーブル、関数、インデックス、演算子、演算子クラス、演算子ファミリ、プロシージャ、ルーチン、シーケンス、統計、テキスト検索オブジェクト、タイプ、およびビューの名前は、スキーマで修飾できます。列にコメントを付ける場合、 &lt;code&gt;relation_name&lt;/code&gt; はテーブル、ビュー、複合型、または外部テーブルを参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="0ad7f76d8fb02cb1c406ee55180e013d61f5632a" translate="yes" xml:space="preserve">
          <source>The name of the object to be labeled. Names of tables, aggregates, domains, foreign tables, functions, procedures, routines, sequences, types, and views can be schema-qualified.</source>
          <target state="translated">ラベルを付けるオブジェクトの名前。テーブル、集約、ドメイン、外部テーブル、関数、プロシージャ、ルーチン、シーケンス、型、およびビューの名前をスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="d73d0a54fa511d10e86523f09232c08b9e6d5db1" translate="yes" xml:space="preserve">
          <source>The name of the object to which this label applies, as text.</source>
          <target state="translated">このラベルが適用されるオブジェクトの名前をテキストで指定します。</target>
        </trans-unit>
        <trans-unit id="42c399b3a656097491cae7892f14f5784153a41c" translate="yes" xml:space="preserve">
          <source>The name of the operator class to be created. The name can be schema-qualified.</source>
          <target state="translated">作成する演算子クラスの名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="3c9b852f5483728a82051e673011a9205c74fef8" translate="yes" xml:space="preserve">
          <source>The name of the operator family to be created. The name can be schema-qualified.</source>
          <target state="translated">作成する演算子ファミリの名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="aa3dee6563b812e00d9ce856987f40752c4ba957" translate="yes" xml:space="preserve">
          <source>The name of the operator to be defined. See above for allowable characters. The name can be schema-qualified, for example &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt;. If not, then the operator is created in the current schema. Two operators in the same schema can have the same name if they operate on different data types. This is called &lt;em&gt;overloading&lt;/em&gt;.</source>
          <target state="translated">定義する演算子の名前。使用できる文字については、上記を参照してください。名前はスキーマで修飾できます &lt;code&gt;CREATE OPERATOR myschema.+ (...)&lt;/code&gt; 例：CREATE OPERATOR myschema。+（...））。そうでない場合、演算子は現在のスキーマに作成されます。同じスキーマ内の2つの演算子は、異なるデータ型を操作する場合、同じ名前を持つことができます。これは&lt;em&gt;オーバーロード&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="89042cdb5d6d0a5c95dd63eb06cd01f0a55a975c" translate="yes" xml:space="preserve">
          <source>The name of the policy</source>
          <target state="translated">ポリシー名</target>
        </trans-unit>
        <trans-unit id="b729bdecc076d261a6f2aa96bf01271915d37a2a" translate="yes" xml:space="preserve">
          <source>The name of the policy to be created. This must be distinct from the name of any other policy for the table.</source>
          <target state="translated">作成するポリシーの名前です。これは、そのテーブルの他のポリシーの名前とは区別されなければなりません。</target>
        </trans-unit>
        <trans-unit id="e268e30430f81e017c4a875eccb62cdf9b012871" translate="yes" xml:space="preserve">
          <source>The name of the policy to drop.</source>
          <target state="translated">ドロップするポリシーの名前です。</target>
        </trans-unit>
        <trans-unit id="e49a87c2d393345ad07affbe76b904f4fe401c81" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to deallocate.</source>
          <target state="translated">デアロケートするための準備されたステートメントの名前です。</target>
        </trans-unit>
        <trans-unit id="96c3920c719f442187d159c204dd3612ea686ae5" translate="yes" xml:space="preserve">
          <source>The name of the prepared statement to execute.</source>
          <target state="translated">実行する準備されたステートメントの名前です。</target>
        </trans-unit>
        <trans-unit id="655476f7c7223e1c8c574d3f749ecc5208b3f1a9" translate="yes" xml:space="preserve">
          <source>The name of the procedural language the code is written in. If omitted, the default is &lt;code&gt;plpgsql&lt;/code&gt;.</source>
          <target state="translated">コードが記述されている手続き型言語の名前。省略した場合、デフォルトは &lt;code&gt;plpgsql&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="03668e7125b4437e3ffadf3e4e590be0e7efc658" translate="yes" xml:space="preserve">
          <source>The name of the provider with which this label is to be associated. The named provider must be loaded and must consent to the proposed labeling operation. If exactly one provider is loaded, the provider name may be omitted for brevity.</source>
          <target state="translated">このラベルが関連付けられるプロバイダの名前。指定されたプロバイダがロードされ、提案されたラベリング操作に同意しなければならない。プロバイダが1つだけロードされている場合は、簡潔にするためにプロバイダ名を省略してもよい。</target>
        </trans-unit>
        <trans-unit id="4982a7a5e8149f1e3c35391b81b9f53d77cb4f02" translate="yes" xml:space="preserve">
          <source>The name of the role that will be made the new owner of the affected objects.</source>
          <target state="translated">影響を受けるオブジェクトの新しい所有者となるロールの名前です。</target>
        </trans-unit>
        <trans-unit id="d91a150acbfef5a5067b673c038cee51df98a783" translate="yes" xml:space="preserve">
          <source>The name of the role to remove.</source>
          <target state="translated">削除するロールの名前。</target>
        </trans-unit>
        <trans-unit id="f2c76cbbaae9ad7b16ccf9e7e0922d982cd4547e" translate="yes" xml:space="preserve">
          <source>The name of the role whose attributes are to be altered.</source>
          <target state="translated">属性を変更するロールの名前です。</target>
        </trans-unit>
        <trans-unit id="a2cca4e02caca1d1f07a5556d0d3f7be637865d7" translate="yes" xml:space="preserve">
          <source>The name of the rule to drop.</source>
          <target state="translated">落とすルールの名前。</target>
        </trans-unit>
        <trans-unit id="fc701ae189d9b3d813db243f4da26ea0b33711ef" translate="yes" xml:space="preserve">
          <source>The name of the savepoint to destroy.</source>
          <target state="translated">破壊するセーブポイントの名前。</target>
        </trans-unit>
        <trans-unit id="4816861b05e3da72c531801eafbb94d541e0e94f" translate="yes" xml:space="preserve">
          <source>The name of the schema in which to install the extension's objects, given that the extension allows its contents to be relocated. The named schema must already exist. If not specified, and the extension's control file does not specify a schema either, the current default object creation schema is used.</source>
          <target state="translated">拡張モジュールのオブジェクトをインストールするスキーマの名前です。指定したスキーマは既に存在しなければなりません。指定されておらず、拡張モジュールのコントロールファイルがスキーマを指定していない場合は、現在のデフォルトのオブジェクト作成スキーマが使用されます。</target>
        </trans-unit>
        <trans-unit id="42eda784d25f0da5728fd9204f655f7fcdcb985b" translate="yes" xml:space="preserve">
          <source>The name of the schema to which the table will be moved.</source>
          <target state="translated">テーブルを移動させるスキーマの名前です。</target>
        </trans-unit>
        <trans-unit id="baf4061d3be604bdc194c1f14606449bf4b0f2d6" translate="yes" xml:space="preserve">
          <source>The name of the shared memory allocation. NULL for unused memory and &lt;code&gt;&amp;lt;anonymous&amp;gt;&lt;/code&gt; for anonymous allocations.</source>
          <target state="translated">The name of the shared memory allocation. NULL for unused memory and &lt;code&gt;&amp;lt;anonymous&amp;gt;&lt;/code&gt; for anonymous allocations.</target>
        </trans-unit>
        <trans-unit id="ac04d5a0b8ecbdd03c9da31af0a4b7d10ec89b66" translate="yes" xml:space="preserve">
          <source>The name of the source data type of the cast.</source>
          <target state="translated">キャストのソースデータ型の名前です。</target>
        </trans-unit>
        <trans-unit id="2294ddf1df955220bbac238988facccf0c6a0592" translate="yes" xml:space="preserve">
          <source>The name of the specific index, table, or database to be reindexed. Index and table names can be schema-qualified. Presently, &lt;code&gt;REINDEX DATABASE&lt;/code&gt; and &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; can only reindex the current database, so their parameter must match the current database's name.</source>
          <target state="translated">インデックスを再作成する特定のインデックス、テーブル、またはデータベースの名前。インデックス名とテーブル名はスキーマで修飾できます。現在、 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; と &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; は現在のデータベースのインデックスのみを再作成できるため、それらのパラメーターは現在のデータベースの名前と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="1371535897b887a5106cddf678bff07e0c5f80a9" translate="yes" xml:space="preserve">
          <source>The name of the start function for the parser.</source>
          <target state="translated">パーサの開始関数の名前です。</target>
        </trans-unit>
        <trans-unit id="015f67e7eaa6c3588c5e9952c547a024ac10153d" translate="yes" xml:space="preserve">
          <source>The name of the state transition function to be called for each input row. For a normal &lt;code&gt;N&lt;/code&gt;-argument aggregate function, the &lt;code&gt;sfunc&lt;/code&gt; must take &lt;code&gt;N&lt;/code&gt;+1 arguments, the first being of type &lt;code&gt;state_data_type&lt;/code&gt; and the rest matching the declared input data type(s) of the aggregate. The function must return a value of type &lt;code&gt;state_data_type&lt;/code&gt;. This function takes the current state value and the current input data value(s), and returns the next state value.</source>
          <target state="translated">各入力行に対して呼び出される状態遷移関数の名前。通常の &lt;code&gt;N&lt;/code&gt; 引数集約関数の場合、 &lt;code&gt;sfunc&lt;/code&gt; は &lt;code&gt;N&lt;/code&gt; +1引数を取る必要があります。最初の引数は &lt;code&gt;state_data_type&lt;/code&gt; 型で、残りは宣言された集約の入力データ型と一致します。関数は、 &lt;code&gt;state_data_type&lt;/code&gt; 型の値を返す必要があります。この関数は、現在の状態値と現在の入力データ値を受け取り、次の状態値を返します。</target>
        </trans-unit>
        <trans-unit id="98dfcac96a79ab8d2309606485d5d666ca4e2daa" translate="yes" xml:space="preserve">
          <source>The name of the table and column to update</source>
          <target state="translated">更新するテーブルとカラムの名前</target>
        </trans-unit>
        <trans-unit id="86a9a516ee162e483fd6f8fbe8dac2f83cc35633" translate="yes" xml:space="preserve">
          <source>The name of the table on which this trigger acts.</source>
          <target state="translated">このトリガが作用するテーブルの名前。</target>
        </trans-unit>
        <trans-unit id="df029c5f6289a56399018c193966351757b130e4" translate="yes" xml:space="preserve">
          <source>The name of the table to attach as a new partition or to detach from this table.</source>
          <target state="translated">新しいパーティションとしてアタッチするテーブル名、またはこのテーブルから切り離すテーブル名。</target>
        </trans-unit>
        <trans-unit id="910f7a94c4794ba13cd804620ae6f535c8697348" translate="yes" xml:space="preserve">
          <source>The name of the tablespace that will be associated with the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the template database's tablespace. This tablespace will be the default tablespace used for objects created in this database. See &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; for more information.</source>
          <target state="translated">新しいデータベースに関連付けられるテーブルスペースの名前、またはテンプレートデータベースのテーブルスペースを使用する &lt;code&gt;DEFAULT&lt;/code&gt; 。このテーブルスペースは、このデータベースで作成されたオブジェクトに使用されるデフォルトのテーブルスペースになります。詳細については、&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2adc75b40aac253d8d3fd83763a5999e795d523d" translate="yes" xml:space="preserve">
          <source>The name of the tablespace to which the table will be moved.</source>
          <target state="translated">テーブルが移動されるテーブル空間の名前。</target>
        </trans-unit>
        <trans-unit id="ed5faf3ddd011b5c76e052594331ee12feb17ee5" translate="yes" xml:space="preserve">
          <source>The name of the target data type of the cast.</source>
          <target state="translated">キャストの対象となるデータ型の名前です。</target>
        </trans-unit>
        <trans-unit id="f5d196df67f8715141577ca0dfa1d0026e0d7817" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default template (&lt;code&gt;template1&lt;/code&gt;).</source>
          <target state="translated">新しいデータベースを作成するテンプレートの名前、またはデフォルトのテンプレート（ &lt;code&gt;template1&lt;/code&gt; ）を使用する &lt;code&gt;DEFAULT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38cd3261917960f8e539d80ae266a773e2ca894a" translate="yes" xml:space="preserve">
          <source>The name of the text search configuration to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索設定の名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="7715676ee8a2df410a7d9b5d6a75ed5f4bbb933b" translate="yes" xml:space="preserve">
          <source>The name of the text search dictionary to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索辞書の名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="08a42806dfcb8f125b19f0057086523042a36ad3" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索パーサの名前です。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="24ce45ce2160196c06edff30b966c8ad75ac789f" translate="yes" xml:space="preserve">
          <source>The name of the text search parser to use for this configuration.</source>
          <target state="translated">この設定に使用するテキスト検索パーサの名前。</target>
        </trans-unit>
        <trans-unit id="84cb2dc1f232e52ae9a92c0bb4186a0059e53aa7" translate="yes" xml:space="preserve">
          <source>The name of the text search template that will define the basic behavior of this dictionary.</source>
          <target state="translated">この辞書の基本的な動作を定義するテキスト検索テンプレートの名前。</target>
        </trans-unit>
        <trans-unit id="1584a807877a42990d603d823d759977f3901ddc" translate="yes" xml:space="preserve">
          <source>The name of the text search template to be created. The name can be schema-qualified.</source>
          <target state="translated">作成するテキスト検索テンプレートの名前。この名前はスキーマで修飾することができます。</target>
        </trans-unit>
        <trans-unit id="d0987d8df78c216eed09875fd5ebec69f27a40ed" translate="yes" xml:space="preserve">
          <source>The name of the trigger to remove.</source>
          <target state="translated">削除するトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="afd08ce0efd0e1d1a3450afd63d3251269afcb61" translate="yes" xml:space="preserve">
          <source>The name of the user who will own the tablespace. If omitted, defaults to the user executing the command. Only superusers can create tablespaces, but they can assign ownership of tablespaces to non-superusers.</source>
          <target state="translated">テーブルスペースを所有するユーザの名前。省略した場合は、コマンドを実行したユーザーがデフォルトとなります。スーパーユーザのみが表領域を作成できますが、スーパーユーザ以外に表領域の所有権を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="1c1d8e2ccb4524cb644f6e39612aee840de9a90d" translate="yes" xml:space="preserve">
          <source>The name or IP addresses of the RADIUS servers to connect to. This parameter is required.</source>
          <target state="translated">接続先のRADIUSサーバーの名前またはIPアドレス。このパラメータは必須です。</target>
        </trans-unit>
        <trans-unit id="21389222271889edde6e7b3bd3c9fdd837bca670" translate="yes" xml:space="preserve">
          <source>The name parameter will be MD5-hashed, so the cleartext cannot be derived from the generated UUID. The generation of UUIDs by this method has no random or environment-dependent element and is therefore reproducible.</source>
          <target state="translated">nameパラメータはMD5ハッシュ化されるので、生成されたUUIDからクリアテキストを派生させることはできません。この方法によるUUIDの生成は、ランダムな要素や環境に依存する要素を持たないため、再現性があります。</target>
        </trans-unit>
        <trans-unit id="ee74a07e23c9dea72df5a27b777fb65b403c0393" translate="yes" xml:space="preserve">
          <source>The name stems from the fact that this table should not be readable by the public since it contains passwords. &lt;a href=&quot;view-pg-user&quot;&gt;&lt;code&gt;pg_user&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_shadow&lt;/code&gt; that blanks out the password field.</source>
          <target state="translated">この名前は、このテーブルにはパスワードが含まれているため、一般の人が読めるようにすべきではないという事実に由来しています。&lt;a href=&quot;view-pg-user&quot;&gt; &lt;code&gt;pg_user&lt;/code&gt; は&lt;/a&gt;上公に読める図である &lt;code&gt;pg_shadow&lt;/code&gt; システムパスワードフィールドをブランクにします。</target>
        </trans-unit>
        <trans-unit id="5d07e8a1b061fb282161f125ed44c357f0d17c75" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This must be distinct from the name of any other trigger for the same table. The name cannot be schema-qualified &amp;mdash; the trigger inherits the schema of its table. For a constraint trigger, this is also the name to use when modifying the trigger's behavior using &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">新しいトリガーに付ける名前。これは、同じテーブルの他のトリガーの名前とは異なる必要があります。名前をスキーマで修飾することはできません&amp;mdash;トリガーはそのテーブルのスキーマを継承します。制約トリガーの場合、これは &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; を使用してトリガーの動作を変更するときに使用する名前でもあります。</target>
        </trans-unit>
        <trans-unit id="7b32b1efee504dab33e5254f802082429e271272" translate="yes" xml:space="preserve">
          <source>The name to give the new trigger. This name must be unique within the database.</source>
          <target state="translated">新しいトリガーを与える名前。この名前はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="11fed6031dec77608082f3fa5b2080d3486c35aa" translate="yes" xml:space="preserve">
          <source>The name to give to the new savepoint.</source>
          <target state="translated">新しいセーブポイントに与える名前。</target>
        </trans-unit>
        <trans-unit id="cf734951b344df7b211da487949af76d60fe726b" translate="yes" xml:space="preserve">
          <source>The names of opclasses and opfamilies are only unique within an access method, so they are represented by &lt;code&gt;access_method_name&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;object_name&lt;/code&gt;.</source>
          <target state="translated">opclassesとopfamiliesの名前はアクセスメソッド内でのみ一意であるため、 &lt;code&gt;access_method_name&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;object_name&lt;/code&gt; で表されます。</target>
        </trans-unit>
        <trans-unit id="d60acc58684395b40a907774a02224d52b1340e7" translate="yes" xml:space="preserve">
          <source>The naming of output columns here is different from that done in the &lt;code&gt;FROM&lt;/code&gt; clause (see &lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;Section 7.2.1.2&lt;/a&gt;). It is possible to rename the same column twice, but the name assigned in the select list is the one that will be passed on.</source>
          <target state="translated">ここでの出力列の命名は、 &lt;code&gt;FROM&lt;/code&gt; 句で行われる命名とは異なります（&lt;a href=&quot;queries-table-expressions#QUERIES-TABLE-ALIASES&quot;&gt;セクション7.2.1.2を&lt;/a&gt;参照）。同じ列の名前を2回変更することは可能ですが、選択リストで割り当てられた名前が渡されます。</target>
        </trans-unit>
        <trans-unit id="8c0fc2cb480be9bb9c51a4bc9a223616db655fd1" translate="yes" xml:space="preserve">
          <source>The negator of this operator.</source>
          <target state="translated">この演算子の否定子。</target>
        </trans-unit>
        <trans-unit id="c48796461ad5a772c7e7652201b09a6a57e675ec" translate="yes" xml:space="preserve">
          <source>The new column is initially filled with whatever default value is given (null if you don't specify a &lt;code&gt;DEFAULT&lt;/code&gt; clause).</source>
          <target state="translated">新しい列には、指定されたデフォルト値が最初に入力されます（ &lt;code&gt;DEFAULT&lt;/code&gt; 句を指定しない場合はnull ）。</target>
        </trans-unit>
        <trans-unit id="99a5a709438ce00d416364163ad8901072e9ceb4" translate="yes" xml:space="preserve">
          <source>The new comment, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the comment.</source>
          <target state="translated">文字列リテラルとして記述された新しいコメント。コメントを削除する場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91d67a443bb1c7292a967c48bc783941c67a9238" translate="yes" xml:space="preserve">
          <source>The new connection can re-use connection parameters from the previous connection; not only database name, user, host, and port, but other settings such as &lt;code&gt;sslmode&lt;/code&gt;. By default, parameters are re-used in the positional syntax, but not when a &lt;code&gt;conninfo&lt;/code&gt; string is given. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. If parameters are re-used, then any parameter not explicitly specified as a positional parameter or in the &lt;code&gt;conninfo&lt;/code&gt; string is taken from the existing connection's parameters. An exception is that if the &lt;code&gt;host&lt;/code&gt; setting is changed from its previous value using the positional syntax, any &lt;code&gt;hostaddr&lt;/code&gt; setting present in the existing connection's parameters is dropped. When the command neither specifies nor reuses a particular parameter, the libpq default is used.</source>
          <target state="translated">The new connection can re-use connection parameters from the previous connection; not only database name, user, host, and port, but other settings such as &lt;code&gt;sslmode&lt;/code&gt; . By default, parameters are re-used in the positional syntax, but not when a &lt;code&gt;conninfo&lt;/code&gt; string is given. Passing a first argument of &lt;code&gt;-reuse-previous=on&lt;/code&gt; or &lt;code&gt;-reuse-previous=off&lt;/code&gt; overrides that default. If parameters are re-used, then any parameter not explicitly specified as a positional parameter or in the &lt;code&gt;conninfo&lt;/code&gt; string is taken from the existing connection's parameters. An exception is that if the &lt;code&gt;host&lt;/code&gt; setting is changed from its previous value using the positional syntax, any &lt;code&gt;hostaddr&lt;/code&gt; setting present in the existing connection's parameters is dropped. When the command neither specifies nor reuses a particular parameter, the libpq default is used.</target>
        </trans-unit>
        <trans-unit id="510132e01b735c3f8d5397d2880131961e5b0f83" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed and removed from the query buffer. Whatever remains in the query buffer is redisplayed. Type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer.</source>
          <target state="translated">The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed and removed from the query buffer. Whatever remains in the query buffer is redisplayed. Type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer.</target>
        </trans-unit>
        <trans-unit id="d0eef4b2f503cdd8ca575c4d5c2db5edd06b1406" translate="yes" xml:space="preserve">
          <source>The new contents of the query buffer are then re-parsed according to the normal rules of psql, treating the whole buffer as a single line. Any complete queries are immediately executed; that is, if the query buffer contains or ends with a semicolon, everything up to that point is executed. Whatever remains will wait in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel it by clearing the query buffer. Treating the buffer as a single line primarily affects meta-commands: whatever is in the buffer after a meta-command will be taken as argument(s) to the meta-command, even if it spans multiple lines. (Thus you cannot make meta-command-using scripts this way. Use &lt;code&gt;\i&lt;/code&gt; for that.)</source>
          <target state="translated">次に、クエリバッファの新しい内容がpsqlの通常のルールに従って再解析され、バッファ全体が1行として扱われます。完全なクエリはすぐに実行されます。つまり、クエリバッファにセミコロンが含まれるかセミコロンで終わる場合、その時点までのすべてが実行されます。残っているものはクエリバッファで待機します。セミコロンまたは &lt;code&gt;\g&lt;/code&gt; を入力して送信するか、 &lt;code&gt;\r&lt;/code&gt; を入力してクエリバッファをクリアしてキャンセルします。バッファを単一行として扱うと、主にメタコマンドに影響します。メタコマンドの後のバッファにあるものはすべて、複数行にわたる場合でも、メタコマンドの引数として扱われます。 （したがって、このようにメタコマンドを使用するスクリプトを作成することはできません。 &lt;code&gt;\i&lt;/code&gt; を使用してください。）</target>
        </trans-unit>
        <trans-unit id="8c2269882cf52ae9f068a61edc3b778c3a536ff9" translate="yes" xml:space="preserve">
          <source>The new declaration of the tables would look like this:</source>
          <target state="translated">テーブルの新しい宣言は次のようになります。</target>
        </trans-unit>
        <trans-unit id="abb08cd78d70403e2ed01ba829b0b0e107ad79e1" translate="yes" xml:space="preserve">
          <source>The new default tablespace of the database.</source>
          <target state="translated">データベースの新しいデフォルトのテーブルスペース。</target>
        </trans-unit>
        <trans-unit id="bd696aa29e06c8bdaa37006c64334315b20f98b5" translate="yes" xml:space="preserve">
          <source>The new name for the constraint.</source>
          <target state="translated">制約の新しい名前。</target>
        </trans-unit>
        <trans-unit id="1897f67b69c5b7376acb8d806a5382da72697a70" translate="yes" xml:space="preserve">
          <source>The new name for the domain.</source>
          <target state="translated">ドメインの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="212f3ea5ee1a7012ae1ea00ecf4feddc77a325c7" translate="yes" xml:space="preserve">
          <source>The new name for the foreign server.</source>
          <target state="translated">海外サーバーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="10044e9774ec8f7e4eeef4126404d9a4c8740bba" translate="yes" xml:space="preserve">
          <source>The new name for the foreign-data wrapper.</source>
          <target state="translated">外部データラッパーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="c11d926987759462d0f175b4415bf3358d9ff337" translate="yes" xml:space="preserve">
          <source>The new name for the index.</source>
          <target state="translated">インデックスの新しい名前。</target>
        </trans-unit>
        <trans-unit id="33305417939d3b3756d6c5255331fe9d857743c1" translate="yes" xml:space="preserve">
          <source>The new name for the materialized view.</source>
          <target state="translated">マテリアライズされたビューの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="d0bd51a33ddf1dfa219e2e91d0e8c933e6563371" translate="yes" xml:space="preserve">
          <source>The new name for the policy.</source>
          <target state="translated">ポリシーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="20931af42c3c5e46457e70a88b633cec676d6b34" translate="yes" xml:space="preserve">
          <source>The new name for the publication.</source>
          <target state="translated">出版物の新名称です。</target>
        </trans-unit>
        <trans-unit id="afd5b43d5185c06c93949d1324710b679e0f98bd" translate="yes" xml:space="preserve">
          <source>The new name for the rule.</source>
          <target state="translated">ルールの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="b48d77b2ef95f7c457090bcbbe943d0c70311b15" translate="yes" xml:space="preserve">
          <source>The new name for the sequence.</source>
          <target state="translated">シーケンスの新しい名前。</target>
        </trans-unit>
        <trans-unit id="fc2f67f3244cee265dae6b633cc864544be564aa" translate="yes" xml:space="preserve">
          <source>The new name for the statistics object.</source>
          <target state="translated">統計オブジェクトの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="5e567bc00743ec90ea48cd87ca4d4d39aaaf2a0e" translate="yes" xml:space="preserve">
          <source>The new name for the subscription.</source>
          <target state="translated">サブスクリプションの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="bb15ea9a2978ce58ebb2c54bd4908c64b61e3ec5" translate="yes" xml:space="preserve">
          <source>The new name for the trigger.</source>
          <target state="translated">トリガーの新しい名前。</target>
        </trans-unit>
        <trans-unit id="db155d6348c19b7d3227f389aca4111ed1c5bd26" translate="yes" xml:space="preserve">
          <source>The new name for the type.</source>
          <target state="translated">タイプの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="c523989c2e7068afb2501bed469e5428f5fdb7a8" translate="yes" xml:space="preserve">
          <source>The new name for the view.</source>
          <target state="translated">ビューの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="f2b9a6bf2f60ce509d60ec6a402dbd4fb867b9c2" translate="yes" xml:space="preserve">
          <source>The new name of the aggregate function.</source>
          <target state="translated">集計関数の新しい名前。</target>
        </trans-unit>
        <trans-unit id="aedc4948fc467788ca8aa2ca7751c93796b91571" translate="yes" xml:space="preserve">
          <source>The new name of the attribute to be renamed.</source>
          <target state="translated">名前を変更する属性の新しい名前。</target>
        </trans-unit>
        <trans-unit id="e113491ed22e052f8e080471ba08c58dedb8ea64" translate="yes" xml:space="preserve">
          <source>The new name of the collation.</source>
          <target state="translated">照合の新しい名前。</target>
        </trans-unit>
        <trans-unit id="4c4b7b49d6b58b2034ea06105277cd50556d40cb" translate="yes" xml:space="preserve">
          <source>The new name of the conversion.</source>
          <target state="translated">変換の新しい名前です。</target>
        </trans-unit>
        <trans-unit id="7bd49806ce97a6cf0ae2db0f7447c28e5ce8134f" translate="yes" xml:space="preserve">
          <source>The new name of the database.</source>
          <target state="translated">データベースの新しい名前。</target>
        </trans-unit>
        <trans-unit id="75a4aa01c626eb3410b405c18307300931670062" translate="yes" xml:space="preserve">
          <source>The new name of the event trigger.</source>
          <target state="translated">イベントトリガーの新しい名前。</target>
        </trans-unit>
        <trans-unit id="e4d75585a773a6cebff31b74551567f8918ab64f" translate="yes" xml:space="preserve">
          <source>The new name of the function.</source>
          <target state="translated">関数の新しい名前。</target>
        </trans-unit>
        <trans-unit id="2911d96c910b5a17b53eadc422fecbb845a71e4b" translate="yes" xml:space="preserve">
          <source>The new name of the group.</source>
          <target state="translated">グループの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="01ed3bb6171bf404a649ad2b2a5598d4f2218b1d" translate="yes" xml:space="preserve">
          <source>The new name of the language</source>
          <target state="translated">新しい言語の名前</target>
        </trans-unit>
        <trans-unit id="5629a006f70e9712f7f3f90081ef5ec794958fe9" translate="yes" xml:space="preserve">
          <source>The new name of the operator class.</source>
          <target state="translated">演算子クラスの新しい名前。</target>
        </trans-unit>
        <trans-unit id="cac8082223d146caa1279e011dcbd9499e966dea" translate="yes" xml:space="preserve">
          <source>The new name of the operator family.</source>
          <target state="translated">オペレータファミリーの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="b633cb5bdc25233c7a8bdbb49f3cdbe73d120c26" translate="yes" xml:space="preserve">
          <source>The new name of the procedure.</source>
          <target state="translated">プロシージャの新しい名前。</target>
        </trans-unit>
        <trans-unit id="3a9dddb1e76ff061e88bc3524aee453d2bee494e" translate="yes" xml:space="preserve">
          <source>The new name of the role.</source>
          <target state="translated">新しい役名です。</target>
        </trans-unit>
        <trans-unit id="2cf77fbb7b0d27045bc13b02630747a959116461" translate="yes" xml:space="preserve">
          <source>The new name of the schema. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system schemas.</source>
          <target state="translated">スキーマの新しい名前。新しい名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。そのような名前はシステムスキーマ用に予約されているためです。</target>
        </trans-unit>
        <trans-unit id="a8efb3edcac41dbb05c4e401ddd6f8995c994227" translate="yes" xml:space="preserve">
          <source>The new name of the tablespace. The new name cannot begin with &lt;code&gt;pg_&lt;/code&gt;, as such names are reserved for system tablespaces.</source>
          <target state="translated">テーブルスペースの新しい名前。新しい名前を &lt;code&gt;pg_&lt;/code&gt; で始めることはできません。そのような名前はシステムテーブルスペース用に予約されているためです。</target>
        </trans-unit>
        <trans-unit id="5bc002f16673653b0690b28fc66ef20f059c3d17" translate="yes" xml:space="preserve">
          <source>The new name of the text search configuration.</source>
          <target state="translated">テキスト検索設定の新しい名前です。</target>
        </trans-unit>
        <trans-unit id="61d4e96018e9afca4b18c94ddcebcfce618c7e91" translate="yes" xml:space="preserve">
          <source>The new name of the text search dictionary.</source>
          <target state="translated">テキスト検索辞書の新名称。</target>
        </trans-unit>
        <trans-unit id="b0ee20d36931a187480bdf33645d746804cd8021" translate="yes" xml:space="preserve">
          <source>The new name of the text search parser.</source>
          <target state="translated">テキスト検索パーサの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="1aa4447ea683fc5f23d92a99564476e94e7ba4f8" translate="yes" xml:space="preserve">
          <source>The new name of the text search template.</source>
          <target state="translated">テキスト検索テンプレートの新しい名前です。</target>
        </trans-unit>
        <trans-unit id="1cf431c1643a8759a28879f52b1cc3af8c233902" translate="yes" xml:space="preserve">
          <source>The new operator family is initially empty. It should be populated by issuing subsequent &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; commands to add contained operator classes, and optionally &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; commands to add &amp;ldquo;loose&amp;rdquo; operators and their corresponding support functions.</source>
          <target state="translated">新しい演算子族は最初は空です。後続の &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; コマンドを発行して含まれる演算子クラスを追加し、オプションで &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; コマンドを発行して「緩い」演算子とそれに対応するサポート関数を追加することで、データを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="f4c637105948973c0a153e08837179c7cca26481" translate="yes" xml:space="preserve">
          <source>The new owner of the aggregate function.</source>
          <target state="translated">集計関数の新しい所有者。</target>
        </trans-unit>
        <trans-unit id="6e427a5a254b743496752784773d8f681fc927a5" translate="yes" xml:space="preserve">
          <source>The new owner of the collation.</source>
          <target state="translated">コレーションの新しい所有者です。</target>
        </trans-unit>
        <trans-unit id="696c05a86f35e15f1b9049294a231e9c92db726b" translate="yes" xml:space="preserve">
          <source>The new owner of the conversion.</source>
          <target state="translated">転換の新オーナー。</target>
        </trans-unit>
        <trans-unit id="8c3476b50bc477a63585319a4ee66bd132d319a7" translate="yes" xml:space="preserve">
          <source>The new owner of the database.</source>
          <target state="translated">データベースの新しい所有者。</target>
        </trans-unit>
        <trans-unit id="d33f9460834c9ae8c6bbf2129c64d4ae9c681396" translate="yes" xml:space="preserve">
          <source>The new owner of the function. Note that if the function is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">関数の新しい所有者。関数が &lt;code&gt;SECURITY DEFINER&lt;/code&gt; とマークされている場合、その後、新しい所有者として実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="df4e6318da1bb722216c2b84ac2c4e660006a7bf" translate="yes" xml:space="preserve">
          <source>The new owner of the language</source>
          <target state="translated">言葉の新しい持ち主</target>
        </trans-unit>
        <trans-unit id="f528312a4f330c09f0db9a04fb7594d8a6881296" translate="yes" xml:space="preserve">
          <source>The new owner of the large object</source>
          <target state="translated">大きなオブジェクトの新しい所有者</target>
        </trans-unit>
        <trans-unit id="042ac141d75c40bbad49229676115d2c3f46dc44" translate="yes" xml:space="preserve">
          <source>The new owner of the operator class.</source>
          <target state="translated">演算子クラスの新しい所有者。</target>
        </trans-unit>
        <trans-unit id="690e510771eb7df59bdf5e81e98ce1c088ae0a0a" translate="yes" xml:space="preserve">
          <source>The new owner of the operator family.</source>
          <target state="translated">オペレーター一家の新オーナー。</target>
        </trans-unit>
        <trans-unit id="9786082232a6fabf8fef79154a67d7d246e8ac12" translate="yes" xml:space="preserve">
          <source>The new owner of the operator.</source>
          <target state="translated">運営者の新オーナー。</target>
        </trans-unit>
        <trans-unit id="3597f21e2766a9a6fcb13ac8067e53ff7ef13d45" translate="yes" xml:space="preserve">
          <source>The new owner of the procedure. Note that if the procedure is marked &lt;code&gt;SECURITY DEFINER&lt;/code&gt;, it will subsequently execute as the new owner.</source>
          <target state="translated">プロシージャの新しい所有者。プロシージャが &lt;code&gt;SECURITY DEFINER&lt;/code&gt; とマークされている場合、その後、新しい所有者として実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="69d41d917f1d5469eff45e378f228e62ac815b74" translate="yes" xml:space="preserve">
          <source>The new owner of the schema.</source>
          <target state="translated">スキーマの新しい所有者です。</target>
        </trans-unit>
        <trans-unit id="db70ea94e40096f71c45b13de8eea08d1af85b1d" translate="yes" xml:space="preserve">
          <source>The new owner of the tablespace.</source>
          <target state="translated">テーブルスペースの新しい所有者。</target>
        </trans-unit>
        <trans-unit id="e5c9278160aed343baae5e000f62f65dff7fc448" translate="yes" xml:space="preserve">
          <source>The new owner of the text search configuration.</source>
          <target state="translated">テキスト検索設定の新しい所有者です。</target>
        </trans-unit>
        <trans-unit id="aa73a2e5e347d201842eebdd89d547d089c6c8be" translate="yes" xml:space="preserve">
          <source>The new owner of the text search dictionary.</source>
          <target state="translated">テキスト検索辞書の新しい持ち主です。</target>
        </trans-unit>
        <trans-unit id="edb8e480bb54a06edf443d08eda6114457bafd19" translate="yes" xml:space="preserve">
          <source>The new role will automatically inherit privileges of roles it is a member of. This is the default.</source>
          <target state="translated">新しいロールは、それがメンバーであるロールの権限を自動的に継承します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="9a32a2a68f765041e1e9d89874f5db158ceae654" translate="yes" xml:space="preserve">
          <source>The new role will not automatically inherit privileges of roles it is a member of.</source>
          <target state="translated">新しいロールは、それがメンバーであるロールの権限を自動的に継承しません。</target>
        </trans-unit>
        <trans-unit id="9261c055206b3b24159966bd5e49b879f7e13689" translate="yes" xml:space="preserve">
          <source>The new schema for the aggregate function.</source>
          <target state="translated">集計機能の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="4dc45ae2528649758dd2b3da76e3b1bde5aae0c1" translate="yes" xml:space="preserve">
          <source>The new schema for the collation.</source>
          <target state="translated">照合用の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="fa5c853ff4ce0885678abb91184961581c7c86e8" translate="yes" xml:space="preserve">
          <source>The new schema for the conversion.</source>
          <target state="translated">変換のための新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="94f971cb399c2e27724257d01667804b12528aea" translate="yes" xml:space="preserve">
          <source>The new schema for the domain.</source>
          <target state="translated">ドメインの新しいスキーマ。</target>
        </trans-unit>
        <trans-unit id="ffcd3334bad17af07bda4b5f314843b54c035a01" translate="yes" xml:space="preserve">
          <source>The new schema for the extension.</source>
          <target state="translated">拡張機能の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="892a2ed0bb951cfb6e7f263bc8da7d70f88d788a" translate="yes" xml:space="preserve">
          <source>The new schema for the function.</source>
          <target state="translated">関数の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="f75cbb7e0424884c76eaf66a88fc00d8e62673a7" translate="yes" xml:space="preserve">
          <source>The new schema for the materialized view.</source>
          <target state="translated">マテリアライズされたビューの新しいスキーマ。</target>
        </trans-unit>
        <trans-unit id="f6752ffe51d8560507628fd3fa3becd8329772f1" translate="yes" xml:space="preserve">
          <source>The new schema for the operator class.</source>
          <target state="translated">演算子クラスの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="91c91f016c0e190b6282eebefe2a49a89e2c716c" translate="yes" xml:space="preserve">
          <source>The new schema for the operator family.</source>
          <target state="translated">演算子ファミリの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="a28f607105e64dc0674bab3c516a94057914430b" translate="yes" xml:space="preserve">
          <source>The new schema for the operator.</source>
          <target state="translated">演算子の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="5b76b1ebef9ac79184347fc03689e8ad83b75ad3" translate="yes" xml:space="preserve">
          <source>The new schema for the procedure.</source>
          <target state="translated">プロシージャの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="e1ef41d9bc55a3a445826b83357df117508b85c8" translate="yes" xml:space="preserve">
          <source>The new schema for the sequence.</source>
          <target state="translated">シーケンスの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="051afa3d07978a274fc9c7a36c2e3cc09b60a787" translate="yes" xml:space="preserve">
          <source>The new schema for the statistics object.</source>
          <target state="translated">統計オブジェクトの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="b33b53d7a11df09b3be2d48051dd92657dd5246a" translate="yes" xml:space="preserve">
          <source>The new schema for the text search configuration.</source>
          <target state="translated">テキスト検索設定のための新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="ef261ca400ba6b8c404f8ae1051c9ddf74db7470" translate="yes" xml:space="preserve">
          <source>The new schema for the text search dictionary.</source>
          <target state="translated">テキスト検索辞書の新しいスキーマ。</target>
        </trans-unit>
        <trans-unit id="6ee901249db3b5665acf6e566a8134c2dd5623bb" translate="yes" xml:space="preserve">
          <source>The new schema for the text search parser.</source>
          <target state="translated">テキスト検索パーサの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="0a8618e7f7d0e904983cf7fb40badda672a564d7" translate="yes" xml:space="preserve">
          <source>The new schema for the text search template.</source>
          <target state="translated">テキスト検索テンプレートの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="2dae7eeaa9912635729239a107cfdb2251e22f7c" translate="yes" xml:space="preserve">
          <source>The new schema for the type.</source>
          <target state="translated">型の新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="9da42308b2dd3741e38d355739234da9161529c8" translate="yes" xml:space="preserve">
          <source>The new schema for the view.</source>
          <target state="translated">ビューの新しいスキーマです。</target>
        </trans-unit>
        <trans-unit id="10efc2ba412402b38cf8661a03b9c2fa3f9344e1" translate="yes" xml:space="preserve">
          <source>The new security label, written as a string literal; or &lt;code&gt;NULL&lt;/code&gt; to drop the security label.</source>
          <target state="translated">文字列リテラルとして記述された新しいセキュリティラベル。または、セキュリティラベルを削除する場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e179748e50d17a45a45be3da432d0626ce9f1871" translate="yes" xml:space="preserve">
          <source>The new server can now be safely started, and then any rsync'ed standby servers.</source>
          <target state="translated">これで新しいサーバを安全に起動し、rsync された待機サーバをすべて起動することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="9cccbe82fdca6cb05f61febaafdcdbee82d07beb" translate="yes" xml:space="preserve">
          <source>The new user will be a superuser.</source>
          <target state="translated">新しいユーザーはスーパーユーザーになります。</target>
        </trans-unit>
        <trans-unit id="c54c521c104ba07a131d94a8006311919b30f264" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create databases.</source>
          <target state="translated">新しいユーザーがデータベースを作成することができるようになります。</target>
        </trans-unit>
        <trans-unit id="d45b0936a7b0d005278d7069b144bbda44325062" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to create new roles (that is, this user will have &lt;code&gt;CREATEROLE&lt;/code&gt; privilege).</source>
          <target state="translated">新しいユーザーは、新しいロールを作成できます（つまり、このユーザーには &lt;code&gt;CREATEROLE&lt;/code&gt; 特権があります）。</target>
        </trans-unit>
        <trans-unit id="f77c7b82b1f36620c7d5c97f31d6b3e8156045cd" translate="yes" xml:space="preserve">
          <source>The new user will be allowed to log in (that is, the user name can be used as the initial session user identifier). This is the default.</source>
          <target state="translated">新しいユーザーのログインが許可されます(つまり、ユーザー名を初期セッションのユーザー識別子として使用することができます)。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="20d6f51c275f9b74aaf81f7d6a5623641aaaf3e3" translate="yes" xml:space="preserve">
          <source>The new user will have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">新しいユーザーには &lt;code&gt;REPLICATION&lt;/code&gt; 権限が付与されます。これについては、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLEの&lt;/a&gt;ドキュメントで詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="5ea6c8532360a87549f7c059f52122ef9c601695" translate="yes" xml:space="preserve">
          <source>The new user will not be a superuser. This is the default.</source>
          <target state="translated">新しいユーザーはスーパーユーザーにはなりません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="72c465f76c8179666632ce0c6f15419c4133425d" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create databases. This is the default.</source>
          <target state="translated">新しいユーザーはデータベースの作成を許可されません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="32dd0b63f5a01c58c0731e9846c0b6a55a21f4f0" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to create new roles. This is the default.</source>
          <target state="translated">新しいユーザーが新しいロールを作成することはできません。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="87cc74c8ed55ae4e670446b51aab48e450dbc14b" translate="yes" xml:space="preserve">
          <source>The new user will not be allowed to log in. (A role without login privilege is still useful as a means of managing database permissions.)</source>
          <target state="translated">新しいユーザーにはログインが許可されません。(ログイン権限のないロールは、データベースの権限を管理する手段としてまだ有用です)。</target>
        </trans-unit>
        <trans-unit id="a13d7c8eff958866dd3c2de41dd7c33e5dff939b" translate="yes" xml:space="preserve">
          <source>The new user will not have the &lt;code&gt;REPLICATION&lt;/code&gt; privilege, which is described more fully in the documentation for &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;.</source>
          <target state="translated">新しいユーザーには &lt;code&gt;REPLICATION&lt;/code&gt; 特権がありません。これについては、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLEの&lt;/a&gt;ドキュメントで詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="127849b8d3eea48eada06bb9a69ad7d49b073868" translate="yes" xml:space="preserve">
          <source>The new value for a table storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">テーブルストレージパラメータの新しい値。これは、パラメータに応じて数値か単語になります。</target>
        </trans-unit>
        <trans-unit id="c290b36401426b8422b4d66e484cd2e82d3b87ce" translate="yes" xml:space="preserve">
          <source>The new value for an index-method-specific storage parameter. This might be a number or a word depending on the parameter.</source>
          <target state="translated">インデックス・メソッド固有のストレージ・パラメータの新しい値。これはパラメータに応じて数値か単語になります。</target>
        </trans-unit>
        <trans-unit id="c34da01d538b4bb95a9dcedad6f42505d9964bfa" translate="yes" xml:space="preserve">
          <source>The new value of the column</source>
          <target state="translated">カラムの新しい値</target>
        </trans-unit>
        <trans-unit id="9cc0b73abbe4bf474235a0a153fa246959f47339" translate="yes" xml:space="preserve">
          <source>The new value to be added to an enum type's list of values, or the new name to be given to an existing value. Like all enum literals, it needs to be quoted.</source>
          <target state="translated">列挙型の値のリストに追加される新しい値、または既存の値に与えられる新しい名前。すべての列挙型リテラルと同様に、引用符で囲まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="3abd3f485b5c74bf1e64463613b4fb3d9ef53408" translate="yes" xml:space="preserve">
          <source>The new value to use for a template-specific option. If the equal sign and value are omitted, then any previous setting for the option is removed from the dictionary, allowing the default to be used.</source>
          <target state="translated">テンプレート固有のオプシ ョ ンに使用する新しい値。等号と値を省略した場合は、そのオプションに対する以前の設定はすべて辞書から削除され、デフォルトを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="54266d9e3dff5c3d85bb17314ebcd06db8a0c4e2" translate="yes" xml:space="preserve">
          <source>The next example shows how to obtain the union of the tables &lt;code&gt;distributors&lt;/code&gt; and &lt;code&gt;actors&lt;/code&gt;, restricting the results to those that begin with the letter W in each table. Only distinct rows are wanted, so the key word &lt;code&gt;ALL&lt;/code&gt; is omitted.</source>
          <target state="translated">次の例は、 &lt;code&gt;distributors&lt;/code&gt; と &lt;code&gt;actors&lt;/code&gt; のテーブルの和集合を取得する方法を示し、結果を各テーブルの文字Wで始まるものに制限しています。個別の行のみが必要なので、キーワード &lt;code&gt;ALL&lt;/code&gt; は省略されます。</target>
        </trans-unit>
        <trans-unit id="0b983bad83edd443b7b8ce4de658661eaff249f8" translate="yes" xml:space="preserve">
          <source>The next step is to set the session to use the new configuration, which was created in the &lt;code&gt;public&lt;/code&gt; schema:</source>
          <target state="translated">次の手順では、 &lt;code&gt;public&lt;/code&gt; スキーマで作成された新しい構成を使用するようにセッションを設定します。</target>
        </trans-unit>
        <trans-unit id="69b04f7d07fe975427e0f7bf99be4fe924c78cc6" translate="yes" xml:space="preserve">
          <source>The non-default GIN operator class &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports indexing the &lt;code&gt;@&amp;gt;&lt;/code&gt; operator only. An example of creating an index with this operator class is:</source>
          <target state="translated">デフォルト以外のGIN演算子クラス &lt;code&gt;jsonb_path_ops&lt;/code&gt; は、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 演算子のインデックス作成のみをサポートしています。この演算子クラスでインデックスを作成する例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1d49459b2ff80f4c26bb14ba35712908d50a4f44" translate="yes" xml:space="preserve">
          <source>The normal PostgreSQL query optimizer performs a &lt;em&gt;near-exhaustive search&lt;/em&gt; over the space of alternative strategies. This algorithm, first introduced in IBM's System R database, produces a near-optimal join order, but can take an enormous amount of time and memory space when the number of joins in the query grows large. This makes the ordinary PostgreSQL query optimizer inappropriate for queries that join a large number of tables.</source>
          <target state="translated">通常のPostgreSQLクエリオプティマイザーは、代替戦略の領域に対して&lt;em&gt;ほぼ完全な検索&lt;/em&gt;を実行します。 IBMのSystem Rデータベースで最初に導入されたこのアルゴリズムは、ほぼ最適な結合順序を生成しますが、クエリ内の結合の数が大きくなると、膨大な時間とメモリ領域を消費する可能性があります。これにより、通常のPostgreSQLクエリオプティマイザーは、多数のテーブルを結合するクエリには不適切になります。</target>
        </trans-unit>
        <trans-unit id="ddb0abe82fae0bb47141f78e86913e1352bb274e" translate="yes" xml:space="preserve">
          <source>The notations &lt;code&gt;varchar(n)&lt;/code&gt; and &lt;code&gt;char(n)&lt;/code&gt; are aliases for &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, respectively. &lt;code&gt;character&lt;/code&gt; without length specifier is equivalent to &lt;code&gt;character(1)&lt;/code&gt;. If &lt;code&gt;character varying&lt;/code&gt; is used without length specifier, the type accepts strings of any size. The latter is a PostgreSQL extension.</source>
          <target state="translated">表記 &lt;code&gt;varchar(n)&lt;/code&gt; および &lt;code&gt;char(n)&lt;/code&gt; は、それぞれ &lt;code&gt;character varying(n)&lt;/code&gt; および &lt;code&gt;character(n)&lt;/code&gt; のエイリアスです。長さ指定子のない &lt;code&gt;character&lt;/code&gt; は、 &lt;code&gt;character(1)&lt;/code&gt; と同等です。 &lt;code&gt;character varying&lt;/code&gt; 指定が長さ指定子なしで使用される場合、型は任意のサイズの文字列を受け入れます。後者はPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="fbc61286b42787c186b2be652915f7206bb4ed7e" translate="yes" xml:space="preserve">
          <source>The number of &lt;em&gt;key columns&lt;/em&gt; in the index, not counting any &lt;em&gt;included columns&lt;/em&gt;, which are merely stored and do not participate in the index semantics</source>
          <target state="translated">格納されているだけで、インデックスセマンティクスに関与していない、&lt;em&gt;含まれている列&lt;/em&gt;は数えない、インデックス内の&lt;em&gt;キー列&lt;/em&gt;の数&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32236378278e06cdc1ed2783abcf03baa463efaf" translate="yes" xml:space="preserve">
          <source>The number of WAL segment files in &lt;code&gt;pg_wal&lt;/code&gt; directory depends on &lt;code&gt;min_wal_size&lt;/code&gt;, &lt;code&gt;max_wal_size&lt;/code&gt; and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, &lt;code&gt;max_wal_size&lt;/code&gt; is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. &lt;code&gt;min_wal_size&lt;/code&gt; puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; ディレクトリ内のWALセグメントファイルの数は、 &lt;code&gt;min_wal_size&lt;/code&gt; 、 &lt;code&gt;max_wal_size&lt;/code&gt; 、および以前のチェックポイントサイクルで生成されたWALの量に依存します。古いログセグメントファイルが不要になると、それらは削除またはリサイクルされます（つまり、番号が付けられたシーケンスの将来のセグメントになるように名前が変更されます）。ログ出力レートの短期間のピークにより、 &lt;code&gt;max_wal_size&lt;/code&gt; を超えると、システムがこの制限に戻るまで、不要なセグメントファイルが削除されます。この制限を下回ると、システムは次のチェックポイントまでの推定必要量をカバーするのに十分なWALファイルをリサイクルし、残りを削除します。推定は、以前のチェックポイントサイクルで使用されたWALファイルの数の移動平均に基づいています。移動平均は、実際の使用量が見積もりを超えるとすぐに増加するため、ある程度平均使用量ではなくピーク使用量に対応します。 &lt;code&gt;min_wal_size&lt;/code&gt; は、将来の使用のためにリサイクルされるWALファイルの量の最小値を設定します。その多くのWALは、システムがアイドル状態で、WALの使用量の見積もりからWALはほとんど必要ないことがわかっていても、将来の使用のために常にリサイクルされます。</target>
        </trans-unit>
        <trans-unit id="e63ffb99c780c2d3b3feec330c071c01fcbaec0d" translate="yes" xml:space="preserve">
          <source>The number of bytes that can be written to WAL such that this slot is not in danger of getting in state &quot;lost&quot;. It is NULL for lost slots, as well as if &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">The number of bytes that can be written to WAL such that this slot is not in danger of getting in state &quot;lost&quot;. It is NULL for lost slots, as well as if &lt;code&gt;max_slot_wal_keep_size&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8748e9fef55cda632ea0102b0e063bbbb95c6586" translate="yes" xml:space="preserve">
          <source>The number of columns in partition key</source>
          <target state="translated">パーティションキーのカラム数</target>
        </trans-unit>
        <trans-unit id="edbeec849445e687cd12eea0389ae4b06b732e80" translate="yes" xml:space="preserve">
          <source>The number of direct ancestors this column has. A column with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">この列が持つ直接の先祖の数。先祖の数が0以外のカラムは、削除したり名前を変更したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="d7208773dc180e0dd7b3e10265b4f310a20ba88e" translate="yes" xml:space="preserve">
          <source>The number of direct inheritance ancestors this constraint has. A constraint with a nonzero number of ancestors cannot be dropped nor renamed.</source>
          <target state="translated">この制約が持つ直接継承の先祖の数。祖先の数が0以外の制約は、削除したり名前を変更したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="8301961997733ca48d253481eefaad3008a00674" translate="yes" xml:space="preserve">
          <source>The number of dirty buffers written in each round is based on the number of new buffers that have been needed by server processes during recent rounds. The average recent need is multiplied by &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; to arrive at an estimate of the number of buffers that will be needed during the next round. Dirty buffers are written until there are that many clean, reusable buffers available. (However, no more than &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; buffers will be written per round.) Thus, a setting of 1.0 represents a &amp;ldquo;just in time&amp;rdquo; policy of writing exactly the number of buffers predicted to be needed. Larger values provide some cushion against spikes in demand, while smaller values intentionally leave writes to be done by server processes. The default is 2.0. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">各ラウンドで書き込まれるダーティバッファーの数は、最近のラウンド中にサーバープロセスで必要とされた新しいバッファーの数に基づいています。最近の平均の必要量に &lt;code&gt;bgwriter_lru_multiplier&lt;/code&gt; を掛けて、次のラウンドで必要になるバッファーの数の見積もりを導きます。ダーティバッファは、使用可能なクリーンで再利用可能なバッファが多くなるまで書き込まれます。 （ただし、 &lt;code&gt;bgwriter_lru_maxpages&lt;/code&gt; 以下バッファはラウンドごとに書き込まれます。）したがって、1.0の設定は、必要と予測されるバッファの数を正確に書き込む「ジャストインタイム」ポリシーを表します。値を大きくすると、需要の急増に対するある程度の緩衝効果が得られます。値を小さくすると、意図的に書き込みがサーバープロセスによって行われるようになります。デフォルトは2.0です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="3d25f5401af5c842168f311144ea17e37058d652" translate="yes" xml:space="preserve">
          <source>The number of distinct nonnull data values in the column. A value greater than zero is the actual number of distinct values. A value less than zero is the negative of a multiplier for the number of rows in the table; for example, a column in which about 80% of the values are nonnull and each nonnull value appears about twice on average could be represented by &lt;code&gt;stadistinct&lt;/code&gt; = -0.4. A zero value means the number of distinct values is unknown.</source>
          <target state="translated">列内の個別の非nullデータ値の数。ゼロより大きい値は、個別の値の実際の数です。ゼロより小さい値は、テーブルの行数の乗数の負数です。例えば、値の約80％が非NULLであり、それぞれ非NULL値を平均して二回について表示される列は、によって表すことができる &lt;code&gt;stadistinct&lt;/code&gt; = -0.4。ゼロの値は、異なる値の数が不明であることを意味します。</target>
        </trans-unit>
        <trans-unit id="8289805730489472578e3f27b2f1d288c0d7dec6" translate="yes" xml:space="preserve">
          <source>The number of iterations of the S2K algorithm to use. It must be a value between 1024 and 65011712, inclusive.</source>
          <target state="translated">使用するS2Kアルゴリズムの繰り返し回数を指定します.1024から65011712の間の値でなければなりません.</target>
        </trans-unit>
        <trans-unit id="9f0e73558363d09e86314a049abfbcf61eaf5cbd" translate="yes" xml:space="preserve">
          <source>The number of lexemes must be less than 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">語彙素の数は2 &lt;sup&gt;64&lt;/sup&gt;未満でなければなりません&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d2adf53592a4a37e557ef19975d87459fecab27a" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before reporting an authentication failure. The default is 0.</source>
          <target state="translated">認証失敗を報告するまでの待ち時間をミリ秒単位で指定します。既定値は 0 です。</target>
        </trans-unit>
        <trans-unit id="4848e62664c3602823768b8a292b1248da926aa5" translate="yes" xml:space="preserve">
          <source>The number of nodes (lexemes + operators) in a &lt;code&gt;tsquery&lt;/code&gt; must be less than 32,768</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; のノード（語彙素+演算子）の数は32,768未満である必要があります</target>
        </trans-unit>
        <trans-unit id="e36ab63c8c21311a28348db0c90c93619e02161d" translate="yes" xml:space="preserve">
          <source>The number of query cancels and the reason for them can be viewed using the &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; system view on the standby server. The &lt;code&gt;pg_stat_database&lt;/code&gt; system view also contains summary information.</source>
          <target state="translated">クエリのキャンセルの数とその理由は、スタンバイサーバーの &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; システムビューを使用して確認できます。 &lt;code&gt;pg_stat_database&lt;/code&gt; システムビューにも要約情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="9d730ed06cd7648c33a05712cd3d40df8021dd41" translate="yes" xml:space="preserve">
          <source>The number of repetitions of the index scan that should be factored into the cost estimates. This will typically be greater than one when considering a parameterized scan for use in the inside of a nestloop join. Note that the cost estimates should still be for just one scan; a larger &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; means that it may be appropriate to allow for some caching effects across multiple scans.</source>
          <target state="translated">コストの見積もりに含める必要があるインデックススキャンの繰り返し数。ネストループ結合の内部で使用するためのパラメーター化されたスキャンを検討する場合、これは通常1より大きくなります。コストの見積もりは、まだ1回のスキャンである必要があります。&lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt;が大きいほど、複数のスキャンにまたがるキャッシュ効果を考慮に入れることが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="166b286d18f619fbe9f6a3ea1bb840802689109b" translate="yes" xml:space="preserve">
          <source>The number of rows returned or affected by the last SQL query, or 0 if the query failed or did not report a row count.</source>
          <target state="translated">最後のSQLクエリによって返された、または影響を受けた行の数、またはクエリが失敗したか、行数が報告されなかった場合は0。</target>
        </trans-unit>
        <trans-unit id="1d69a3b171c0833334cc425ee7e0d762adec494e" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">行を返し始める前にスキップする行の数。詳細については、&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="94382b43faed8152ee9a457cefa14e2d7062f389" translate="yes" xml:space="preserve">
          <source>The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">The number of rows to skip before starting to return rows. For details see &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</target>
        </trans-unit>
        <trans-unit id="aade2c0dad75a39b57c1da4c3274b381a44640e8" translate="yes" xml:space="preserve">
          <source>The number of the ISO 8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year.</source>
          <target state="translated">ISO 8601の週番付の1年の週の番号。定義により、ISOの週は月曜日から始まり、1年の第1週にはその年の1月4日が含まれています。言い換えれば、1年の最初の木曜日は、その年の第1週に含まれているということになります。</target>
        </trans-unit>
        <trans-unit id="4cb2d1007085e9fe567cf2f04104acbb29523d8d" translate="yes" xml:space="preserve">
          <source>The number of the column</source>
          <target state="translated">列の番号を表示します。</target>
        </trans-unit>
        <trans-unit id="17b9b1cbc38db2adfa96c6b3cafb442db5c59e27" translate="yes" xml:space="preserve">
          <source>The number of the column. Ordinary columns are numbered from 1 up. System columns, such as &lt;code&gt;ctid&lt;/code&gt;, have (arbitrary) negative numbers.</source>
          <target state="translated">列の番号。通常の列には、1から順に番号が付けられます。 &lt;code&gt;ctid&lt;/code&gt; などのシステム列には、（任意の）負の数があります。</target>
        </trans-unit>
        <trans-unit id="d5de13da859bcae07a08d4b002774933f9c4b34a" translate="yes" xml:space="preserve">
          <source>The number of the described column</source>
          <target state="translated">記載されている欄の番号</target>
        </trans-unit>
        <trans-unit id="8054a525924b0216f44b2c15796e49dd9491e9dd" translate="yes" xml:space="preserve">
          <source>The numbers provided by &lt;code&gt;BUFFERS&lt;/code&gt; help to identify which parts of the query are the most I/O-intensive.</source>
          <target state="translated">&lt;code&gt;BUFFERS&lt;/code&gt; によって提供される数値は、クエリのどの部分が最もI / O集中であるかを識別するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a9a9a9a7a626d48ccbaac2fc53aad8be63a44035" translate="yes" xml:space="preserve">
          <source>The numerical, unique, sequentially-assigned identifier that each transaction receives when it first causes a database modification. Frequently abbreviated as &lt;em&gt;xid&lt;/em&gt;. When stored on disk, xids are only 32-bits wide, so only approximately four billion write transaction IDs can be generated; to permit the system to run for longer than that, &lt;em&gt;epochs&lt;/em&gt; are used, also 32 bits wide. When the counter reaches the maximum xid value, it starts over at &lt;code&gt;3&lt;/code&gt; (values under that are reserved) and the epoch value is incremented by one. In some contexts, the epoch and xid values are considered together as a single 64-bit value.</source>
          <target state="translated">The numerical, unique, sequentially-assigned identifier that each transaction receives when it first causes a database modification. Frequently abbreviated as &lt;em&gt;xid&lt;/em&gt;. When stored on disk, xids are only 32-bits wide, so only approximately four billion write transaction IDs can be generated; to permit the system to run for longer than that, &lt;em&gt;epochs&lt;/em&gt; are used, also 32 bits wide. When the counter reaches the maximum xid value, it starts over at &lt;code&gt;3&lt;/code&gt; (values under that are reserved) and the epoch value is incremented by one. In some contexts, the epoch and xid values are considered together as a single 64-bit value.</target>
        </trans-unit>
        <trans-unit id="23f1e0aeb5175fc6ed920199dd580b15702c2054" translate="yes" xml:space="preserve">
          <source>The object which describes a WAL range always has three keys:</source>
          <target state="translated">WAL範囲を記述するオブジェクトは、常に3つのキーを持っています。</target>
        </trans-unit>
        <trans-unit id="9f439f1411e4ff73cafff6f9e11f463408382ecb" translate="yes" xml:space="preserve">
          <source>The object which describes a single file contains either a &lt;code&gt;Path&lt;/code&gt; key or an &lt;code&gt;Encoded-Path&lt;/code&gt; key. Normally, the &lt;code&gt;Path&lt;/code&gt; key will be present. The associated string value is the path of the file relative to the root of the backup directory. Files located in a user-defined tablespace will have paths whose first two components are &lt;code&gt;pg_tblspc&lt;/code&gt; and the OID of the tablespace. If the path is not a string that is legal in UTF-8, or if the user requests that encoded paths be used for all files, then the &lt;code&gt;Encoded-Path&lt;/code&gt; key will be present instead. This stores the same data, but it is encoded as a string of hexadecimal digits. Each pair of hexadecimal digits in the string represents a single octet.</source>
          <target state="translated">単一のファイルを記述するオブジェクトには、 &lt;code&gt;Path&lt;/code&gt; キーまたは &lt;code&gt;Encoded-Path&lt;/code&gt; キーのいずれかが含まれています。通常、 &lt;code&gt;Path&lt;/code&gt; キーが存在します。関連する文字列値は、バックアップディレクトリのルートを基準にしたファイルのパスです。ユーザー定義の表領域にあるファイルには、最初の2つのコンポーネントが &lt;code&gt;pg_tblspc&lt;/code&gt; と表領域のOIDであるパスがあります。パスがUTF-8で有効な文字列でない場合、またはユーザーがエンコードされたパスをすべてのファイルに使用するように要求した場合は、代わりに &lt;code&gt;Encoded-Path&lt;/code&gt; キーが表示されます。これは同じデータを格納しますが、16進数の文字列としてエンコードされます。文字列内の16進数の各ペアは、単一のオクテットを表します。</target>
        </trans-unit>
        <trans-unit id="3001cae2699919156e01018ff603c7cc3b34ddd4" translate="yes" xml:space="preserve">
          <source>The object's key-value pairs, represented as an array of objects containing three fields: &lt;code&gt;&quot;key&quot;&lt;/code&gt;, &lt;code&gt;&quot;value&quot;&lt;/code&gt;, and &lt;code&gt;&quot;id&quot;&lt;/code&gt;; &lt;code&gt;&quot;id&quot;&lt;/code&gt; is a unique identifier of the object the key-value pair belongs to</source>
          <target state="translated">オブジェクトのキーと値のペア。 &lt;code&gt;&quot;key&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;value&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;id&quot;&lt;/code&gt; 3つのフィールドを含むオブジェクトの配列として表されます。 &lt;code&gt;&quot;id&quot;&lt;/code&gt; は、キーと値のペアが属するオブジェクトの一意の識別子です</target>
        </trans-unit>
        <trans-unit id="c96b4217f4ff70cb5052589aed86a75a58ea381a" translate="yes" xml:space="preserve">
          <source>The obsolete options &lt;code&gt;SORT1&lt;/code&gt;, &lt;code&gt;SORT2&lt;/code&gt;, &lt;code&gt;LTCMP&lt;/code&gt;, and &lt;code&gt;GTCMP&lt;/code&gt; were formerly used to specify the names of sort operators associated with a merge-joinable operator. This is no longer necessary, since information about associated operators is found by looking at B-tree operator families instead. If one of these options is given, it is ignored except for implicitly setting &lt;code&gt;MERGES&lt;/code&gt; true.</source>
          <target state="translated">廃止されたオプション &lt;code&gt;SORT1&lt;/code&gt; 、 &lt;code&gt;SORT2&lt;/code&gt; 、 &lt;code&gt;LTCMP&lt;/code&gt; 、および &lt;code&gt;GTCMP&lt;/code&gt; は、以前は結合結合可能な演算子に関連付けられたソート演算子の名前を指定するために使用されていました。関連する演算子に関する情報は代わりにBツリー演算子ファミリを調べることで見つかるので、これはもう必要ありません。これらのオプションのいずれかを指定すると、暗黙的に &lt;code&gt;MERGES&lt;/code&gt; が trueに設定されている場合を除いて無視されます。</target>
        </trans-unit>
        <trans-unit id="c4bf61bc0ae75f599a4b04ad0336e82b98b0a3d1" translate="yes" xml:space="preserve">
          <source>The octet with decimal value 92 (backslash) is doubled in the output. Details are in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;Table 8.8&lt;/a&gt;.</source>
          <target state="translated">10進値92（バックスラッシュ）のオクテットは、出力で2倍になります。詳細を&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-RESESC&quot;&gt;表8.8に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ed338423cb1bcb126644c1e6c22121f438859be7" translate="yes" xml:space="preserve">
          <source>The offset at which the allocation starts. NULL for anonymous allocations and unused memory.</source>
          <target state="translated">割り当てを開始するオフセット。匿名割り当てと未使用メモリの場合は NULL。</target>
        </trans-unit>
        <trans-unit id="1bf48e5f27220de9fe763df392dfdaead2007f3b" translate="yes" xml:space="preserve">
          <source>The offset fields specify the hours, and optionally minutes and seconds, difference from UTC. They have the format &lt;code&gt;hh&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;mm&lt;/code&gt;[&lt;code&gt;:&lt;/code&gt;&lt;code&gt;ss&lt;/code&gt;]] optionally with a leading sign (&lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;). The positive sign is used for zones &lt;em&gt;west&lt;/em&gt; of Greenwich. (Note that this is the opposite of the ISO-8601 sign convention used elsewhere in PostgreSQL.) &lt;code&gt;hh&lt;/code&gt; can have one or two digits; &lt;code&gt;mm&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; (if used) must have two.</source>
          <target state="translated">オフセットフィールドは、UTCとの時間、およびオプションで分と秒の差を指定します。 &lt;code&gt;hh&lt;/code&gt; [ &lt;code&gt;:&lt;/code&gt; &lt;code&gt;mm&lt;/code&gt; [ &lt;code&gt;:&lt;/code&gt; &lt;code&gt;ss&lt;/code&gt; ]]の形式で、オプションで先行記号（ &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; ）が付いています。正の符号は、グリニッジの&lt;em&gt;西&lt;/em&gt;のゾーンに使用されます。 （これは、PostgreSQLの他の場所で使用されているISO-8601符号規則の反対であることに注意してください。） &lt;code&gt;hh&lt;/code&gt; は1桁または2桁にすることができます。 &lt;code&gt;mm&lt;/code&gt; と &lt;code&gt;ss&lt;/code&gt; （使用する場合）には2つ必要です。</target>
        </trans-unit>
        <trans-unit id="51b42992b2dbbebe4441f992b139d475f2a6576d" translate="yes" xml:space="preserve">
          <source>The old indexes are dropped. The &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; session locks for the indexes and the table are released.</source>
          <target state="translated">古いインデックスは削除されます。インデックスとテーブルの &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; セッションロックが解放されます。</target>
        </trans-unit>
        <trans-unit id="aff5f1b14035796efdcabc3055a299cc4fcb8ba7" translate="yes" xml:space="preserve">
          <source>The old indexes have &lt;code&gt;pg_index.indisready&lt;/code&gt; switched to &amp;ldquo;false&amp;rdquo; to prevent any new tuple insertions, after waiting for running queries that might reference the old index to complete.</source>
          <target state="translated">古いインデックスを参照するクエリの実行が完了するのを待った後、新しいインデックスの挿入を防ぐために、古いインデックスは &lt;code&gt;pg_index.indisready&lt;/code&gt; を「false」に切り替えました。</target>
        </trans-unit>
        <trans-unit id="05be6eb32947b010e242b9b77a81ac45522407a1" translate="yes" xml:space="preserve">
          <source>The oldest transaction affecting the system catalogs that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove catalog tuples deleted by any later transaction.</source>
          <target state="translated">このスロットがデータベースを保持する必要があるシステムカタログに影響を与える最も古いトランザクション。 &lt;code&gt;VACUUM&lt;/code&gt; は、その後のトランザクションによって削除されたカタログタプルを削除できません。</target>
        </trans-unit>
        <trans-unit id="5faf9118a5f5509db65f9f3d1a55a7c88d7b4faa" translate="yes" xml:space="preserve">
          <source>The oldest transaction that this slot needs the database to retain. &lt;code&gt;VACUUM&lt;/code&gt; cannot remove tuples deleted by any later transaction.</source>
          <target state="translated">このスロットがデータベースを保持する必要がある最も古いトランザクション。 &lt;code&gt;VACUUM&lt;/code&gt; は、その後のトランザクションによって削除されたタプルを削除できません。</target>
        </trans-unit>
        <trans-unit id="f97ff854cd0196d6cae74ec459d42c99253ddda9" translate="yes" xml:space="preserve">
          <source>The only feature of AREs that is actually incompatible with POSIX EREs is that &lt;code&gt;\&lt;/code&gt; does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the &lt;code&gt;***&lt;/code&gt; syntax of directors likewise is outside the POSIX syntax for both BREs and EREs.</source>
          <target state="translated">POSIX EREと実際に互換性のないAREの唯一の機能は、 &lt;code&gt;\&lt;/code&gt; がブラケット式内の特別な意味を失わないことです。他のすべてのARE機能は、違法であるか、POSIX EREで未定義または不特定の影響を持つ構文を使用します。同様に、ディレクターの &lt;code&gt;***&lt;/code&gt; 構文は、BREとEREの両方のPOSIX構文の外にあります。</target>
        </trans-unit>
        <trans-unit id="8a1895f6d1a24facb26fe1c49448d16cf40a3e4a" translate="yes" xml:space="preserve">
          <source>The only firm requirement for using NFS with PostgreSQL is that the file system is mounted using the &lt;code&gt;hard&lt;/code&gt; option. With the &lt;code&gt;hard&lt;/code&gt; option, processes can &amp;ldquo;hang&amp;rdquo; indefinitely if there are network problems, so this configuration will require a careful monitoring setup. The &lt;code&gt;soft&lt;/code&gt; option will interrupt system calls in case of network problems, but PostgreSQL will not repeat system calls interrupted in this way, so any such interruption will result in an I/O error being reported.</source>
          <target state="translated">PostgreSQLでNFSを使用するための唯一の確実な要件は、ファイルシステムが &lt;code&gt;hard&lt;/code&gt; オプションを使用してマウントされていることです。 &lt;code&gt;hard&lt;/code&gt; ネットワークに問題がある場合は、この設定は注意深い監視のセットアップが必要になりますので、オプションで、プロセスは、無期限に「ハング」することができます。 &lt;code&gt;soft&lt;/code&gt; のオプションは、ネットワークの問題の場合のシステムコールを中断しますが、そのような中断が報告されているI / Oエラーになりますので、PostgreSQLは繰り返しませんシステムコールは、このように中断されます。</target>
        </trans-unit>
        <trans-unit id="a396e16c5e2752bf51d263513d40dc846694333b" translate="yes" xml:space="preserve">
          <source>The only parameter required by the &lt;code&gt;synonym&lt;/code&gt; template is &lt;code&gt;SYNONYMS&lt;/code&gt;, which is the base name of its configuration file &amp;mdash; &lt;code&gt;my_synonyms&lt;/code&gt; in the above example. The file's full name will be &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; (where &lt;code&gt;$SHAREDIR&lt;/code&gt; means the PostgreSQL installation's shared-data directory). The file format is just one line per word to be substituted, with the word followed by its synonym, separated by white space. Blank lines and trailing spaces are ignored.</source>
          <target state="translated">&lt;code&gt;synonym&lt;/code&gt; テンプレートで必要な唯一のパラメーターは &lt;code&gt;SYNONYMS&lt;/code&gt; です。これは、その構成ファイルのベース名であり、上の例では &lt;code&gt;my_synonyms&lt;/code&gt; です。ファイルのフルネームは &lt;code&gt;$SHAREDIR/tsearch_data/my_synonyms.syn&lt;/code&gt; （ &lt;code&gt;$SHAREDIR&lt;/code&gt; はPostgreSQLインストールの共有データディレクトリを意味します）。ファイル形式は、置換される単語ごとに1行だけで、単語の後には同義語が続き、空白で区切られます。空白行と末尾のスペースは無視されます。</target>
        </trans-unit>
        <trans-unit id="a030d7c4538742e2439ddd895553830f470ea35b" translate="yes" xml:space="preserve">
          <source>The operations that occur on both primary and standby servers are normal continuous archiving and recovery tasks. The only point of contact between the two database servers is the archive of WAL files that both share: primary writing to the archive, standby reading from the archive. Care must be taken to ensure that WAL archives from separate primary servers do not become mixed together or confused. The archive need not be large if it is only required for standby operation.</source>
          <target state="translated">プライマリサーバーとスタンバイサーバーの両方で発生する操作は、通常の継続的なアーカイブとリカバリタスクです。2つのデータベースサーバー間の唯一の接点は、両方が共有するWALファイルのアーカイブです。別々のプライマリサーバからの WAL アーカイブが混在したり、混同したりしないように注意しなければなりません。アーカイブは、待機動作のためだけに必要なものであれば、大きくする必要はありません。</target>
        </trans-unit>
        <trans-unit id="78a77532759d107a293f71b3071e91121689e001" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;!=&lt;/code&gt; is mapped to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; on input, so these two names are always equivalent.</source>
          <target state="translated">演算子 &lt;code&gt;!=&lt;/code&gt; は入力時に &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; にマップされるため、これら2つの名前は常に同等です。</target>
        </trans-unit>
        <trans-unit id="7680d70684ff5657bfcc4e3b94f75e49715485f1" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific.</source>
          <target state="translated">演算子 &lt;code&gt;~~&lt;/code&gt; は &lt;code&gt;LIKE&lt;/code&gt; と同等であり、 &lt;code&gt;~~*&lt;/code&gt; は &lt;code&gt;ILIKE&lt;/code&gt; に対応します。また、それぞれ &lt;code&gt;NOT LIKE&lt;/code&gt; および &lt;code&gt;NOT ILIKE&lt;/code&gt; を表す &lt;code&gt;!~~&lt;/code&gt; および &lt;code&gt;!~~*&lt;/code&gt; 演算子もあります。これらの演算子はすべてPostgreSQL固有です。</target>
        </trans-unit>
        <trans-unit id="bd4509fc82896a3a7a34fb1c8f105531cc74d101" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~~&lt;/code&gt; is equivalent to &lt;code&gt;LIKE&lt;/code&gt;, and &lt;code&gt;~~*&lt;/code&gt; corresponds to &lt;code&gt;ILIKE&lt;/code&gt;. There are also &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt; operators that represent &lt;code&gt;NOT LIKE&lt;/code&gt; and &lt;code&gt;NOT ILIKE&lt;/code&gt;, respectively. All of these operators are PostgreSQL-specific. You may see these operator names in &lt;code&gt;EXPLAIN&lt;/code&gt; output and similar places, since the parser actually translates &lt;code&gt;LIKE&lt;/code&gt; et al. to these operators.</source>
          <target state="translated">演算子 &lt;code&gt;~~&lt;/code&gt; は &lt;code&gt;LIKE&lt;/code&gt; と同等であり、 &lt;code&gt;~~*&lt;/code&gt; は &lt;code&gt;ILIKE&lt;/code&gt; に対応します。そこにもある &lt;code&gt;!~~&lt;/code&gt; および &lt;code&gt;!~~*&lt;/code&gt; 表す演算子 &lt;code&gt;NOT LIKE&lt;/code&gt; および &lt;code&gt;NOT ILIKE&lt;/code&gt; をそれぞれが、。これらの演算子はすべてPostgreSQL固有です。パーサーは実際に &lt;code&gt;LIKE&lt;/code&gt; et alを変換するため、これらの演算子名は &lt;code&gt;EXPLAIN&lt;/code&gt; 出力および同様の場所に表示される場合があります。これらの演算子に。</target>
        </trans-unit>
        <trans-unit id="1d017a3795e4c2a850feefb2cba71cdbcd408d49" translate="yes" xml:space="preserve">
          <source>The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type &lt;code&gt;int4&lt;/code&gt; would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for values of type &lt;code&gt;int4&lt;/code&gt;. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when making an index. The operator class determines the basic sort ordering (which can then be modified by adding sort options &lt;code&gt;COLLATE&lt;/code&gt;, &lt;code&gt;ASC&lt;/code&gt;/&lt;code&gt;DESC&lt;/code&gt; and/or &lt;code&gt;NULLS FIRST&lt;/code&gt;/&lt;code&gt;NULLS LAST&lt;/code&gt;).</source>
          <target state="translated">演算子クラスは、その列のインデックスで使用される演算子を識別します。たとえば、タイプ &lt;code&gt;int4&lt;/code&gt; の Bツリーインデックスは &lt;code&gt;int4_ops&lt;/code&gt; クラスを使用します。この演算子クラスには、 &lt;code&gt;int4&lt;/code&gt; 型の値の比較関数が含まれています。実際には、列のデータ型のデフォルトの演算子クラスで通常は十分です。演算子クラスがある主な理由は、一部のデータ型では、意味のあるインデックス動作が複数存在する可能性があるためです。たとえば、絶対値または実部のいずれかで複素数データ型を並べ替えることができます。これを行うには、データ型に対して2つの演算子クラスを定義し、インデックスを作成するときに適切なクラスを選択します。演算子クラスは、基本的な並べ替え順序を決定します（これは、並べ替えオプション &lt;code&gt;COLLATE&lt;/code&gt; 、 &lt;code&gt;ASC&lt;/code&gt; / &lt;code&gt;DESC&lt;/code&gt; および/または &lt;code&gt;NULLS FIRST&lt;/code&gt; / &lt;code&gt;NULLS LAST&lt;/code&gt; を追加することで変更できます）。</target>
        </trans-unit>
        <trans-unit id="79d3ccfc646e039879a5fc434785db86b4443933" translate="yes" xml:space="preserve">
          <source>The operator classes &lt;code&gt;text_pattern_ops&lt;/code&gt;, &lt;code&gt;varchar_pattern_ops&lt;/code&gt;, and &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; support B-tree indexes on the types &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char&lt;/code&gt; respectively. The difference from the default operator classes is that the values are compared strictly character by character rather than according to the locale-specific collation rules. This makes these operator classes suitable for use by queries involving pattern matching expressions (&lt;code&gt;LIKE&lt;/code&gt; or POSIX regular expressions) when the database does not use the standard &amp;ldquo;C&amp;rdquo; locale. As an example, you might index a &lt;code&gt;varchar&lt;/code&gt; column like this:</source>
          <target state="translated">演算子クラス &lt;code&gt;text_pattern_ops&lt;/code&gt; 、 &lt;code&gt;varchar_pattern_ops&lt;/code&gt; 、および &lt;code&gt;bpchar_pattern_ops&lt;/code&gt; は、それぞれ型 &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、および &lt;code&gt;char&lt;/code&gt; の Bツリーインデックスをサポートします。デフォルトの演算子クラスとの違いは、値がロケール固有の照合規則に従ってではなく、文字ごとに厳密に比較されることです。これにより、データベースが標準の「C」ロケールを使用しない場合、これらの演算子クラスは、パターンマッチング式（ &lt;code&gt;LIKE&lt;/code&gt; またはPOSIX正規表現）を含むクエリでの使用に適しています。例として、次のように &lt;code&gt;varchar&lt;/code&gt; 列にインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="33bad4a7b35adf68e8d48de054b950c2d1ec9c35" translate="yes" xml:space="preserve">
          <source>The operator family this entry is for</source>
          <target state="translated">このエントリが対象とするオペレータファミリ</target>
        </trans-unit>
        <trans-unit id="223e98e65916141080aa613ffd5f9982aa449061" translate="yes" xml:space="preserve">
          <source>The operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">オペレーター名は、以下のリストの &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1（デフォルトでは63）文字までのシーケンスです。</target>
        </trans-unit>
        <trans-unit id="e93319af4ff4ab58e4fcfce194629f2f03f458a1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; are equivalent to PostgreSQL's built-in operators of the same names, except that they work only on integer arrays that do not contain nulls, while the built-in operators work for any array type. This restriction makes them faster than the built-in operators in many cases.</source>
          <target state="translated">演算子 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;@&lt;/code&gt; は、NULLを含まない整数配列でのみ機能するのを除いて、同じ名前のPostgreSQLの組み込み演算子と同等ですが、組み込み演算子は任意の配列型で機能します。この制限により、多くの場合、組み込み演算子よりも速くなります。</target>
        </trans-unit>
        <trans-unit id="a0d063cd8a5cd2a97ff1408a1433cc81fe5925af" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; have analogues &lt;code&gt;^&amp;lt;@&lt;/code&gt;, &lt;code&gt;^@&amp;gt;&lt;/code&gt;, &lt;code&gt;^@&lt;/code&gt;, &lt;code&gt;^~&lt;/code&gt;, which are the same except they do not use indexes. These are useful only for testing purposes.</source>
          <target state="translated">演算子 &lt;code&gt;&amp;lt;@&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;@&lt;/code&gt; 、および &lt;code&gt;~&lt;/code&gt; は類似の &lt;code&gt;^&amp;lt;@&lt;/code&gt; 、 &lt;code&gt;^@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;^@&lt;/code&gt; 、 &lt;code&gt;^~&lt;/code&gt; 、インデックスを使用しないことを除いて同じです。これらは、テスト目的でのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="fbca8888a118f48ef45503ea9b2b65638278cb3a" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operand without affecting the result. But see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.</source>
          <target state="translated">演算子 &lt;code&gt;AND&lt;/code&gt; および &lt;code&gt;OR&lt;/code&gt; は交換可能です。つまり、結果に影響を与えることなく、左と右のオペランドを切り替えることができます。ただし、部分式の評価順序の詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;4.2.14項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ab3b948d9f1df6a05c6208cb2087918561197bec" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;OR&lt;/code&gt; are commutative, that is, you can switch the left and right operands without affecting the result. (However, it is not guaranteed that the left operand is evaluated before the right operand. See &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt; for more information about the order of evaluation of subexpressions.)</source>
          <target state="translated">演算子 &lt;code&gt;AND&lt;/code&gt; と &lt;code&gt;OR&lt;/code&gt; は可換です。つまり、結果に影響を与えることなく、左右のオペランドを切り替えることができます。（ただし、左のオペランドが右のオペランドの前に評価されることは保証されていません。部分式の評価の順序の詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;セクション4.2.14&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="afda15b721563ddc4ee8a5707f908cf503dfae35" translate="yes" xml:space="preserve">
          <source>The operators provided by the &lt;code&gt;hstore&lt;/code&gt; module are shown in &lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;Table F.7&lt;/a&gt;, the functions in &lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;Table F.8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; モジュールで提供される演算子を&lt;a href=&quot;hstore#HSTORE-OP-TABLE&quot;&gt;表F.7&lt;/a&gt;に、関数を&lt;a href=&quot;hstore#HSTORE-FUNC-TABLE&quot;&gt;表F.8に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="43de536c659d022d6659ab7d7ed96e1f9a44966b" translate="yes" xml:space="preserve">
          <source>The operators should not be defined by SQL functions. A SQL function is likely to be inlined into the calling query, which will prevent the optimizer from recognizing that the query matches an index.</source>
          <target state="translated">演算子はSQL関数で定義すべきではありません。SQL関数は呼び出したクエリの中にインライン化されている可能性が高く、オプティマイザがクエリがインデックスにマッチしていることを認識できなくなります。</target>
        </trans-unit>
        <trans-unit id="c7779f9394f3c14857d843cdc250d88697a649fe" translate="yes" xml:space="preserve">
          <source>The optimal value for this option depends on the hardware setup of the server, of the client, and of the network. Factors include the number of CPU cores and the disk setup. A good place to start is the number of CPU cores on the server, but values larger than that can also lead to faster restore times in many cases. Of course, values that are too high will lead to decreased performance because of thrashing.</source>
          <target state="translated">このオプションの最適値は、サーバ、クライアント、ネットワークのハードウェア設定に依存します。要因には、CPU コア数とディスクの設定が含まれます。サーバの CPU コア数から始めるのが良いでしょうが、これよりも大きい値を設定すると、多くの場合、リストア時間を短縮することができます。もちろん、高すぎる値はスラッシングのためにパフォーマンスの低下につながります。</target>
        </trans-unit>
        <trans-unit id="d0eb1545843db39f7e5b62a874b3d76a7289a03a" translate="yes" xml:space="preserve">
          <source>The optimizer can also use a B-tree index for queries involving the pattern matching operators &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;&lt;em&gt;if&lt;/em&gt; the pattern is a constant and is anchored to the beginning of the string &amp;mdash; for example, &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; or &lt;code&gt;col ~ '^foo'&lt;/code&gt;, but not &lt;code&gt;col LIKE '%bar'&lt;/code&gt;. However, if your database does not use the C locale you will need to create the index with a special operator class to support indexing of pattern-matching queries; see &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; below. It is also possible to use B-tree indexes for &lt;code&gt;ILIKE&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt;, but only if the pattern starts with non-alphabetic characters, i.e., characters that are not affected by upper/lower case conversion.</source>
          <target state="translated">パターンが定数で文字列の先頭にアンカーされている&lt;em&gt;場合&lt;/em&gt;、オプティマイザはパターンマッチング演算子 &lt;code&gt;LIKE&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; を含むクエリにBツリーインデックスを使用することもできます。たとえば、 &lt;code&gt;col LIKE 'foo%'&lt;/code&gt; または &lt;code&gt;col ~ '^foo'&lt;/code&gt; 、ただし &lt;code&gt;col LIKE '%bar'&lt;/code&gt; 。ただし、データベースでCロケールが使用されていない場合は、パターンマッチングクエリのインデックス作成をサポートするために、特別な演算子クラスを使用してインデックスを作成する必要があります。以下の&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10を&lt;/a&gt;参照してください。 &lt;code&gt;ILIKE&lt;/code&gt; および &lt;code&gt;~*&lt;/code&gt; Bツリーインデックスを使用することもできます。&lt;em&gt;&lt;/em&gt;、ただしパターンがアルファベット以外の文字、つまり大文字と小文字の変換の影響を受けない文字で始まる場合のみ。</target>
        </trans-unit>
        <trans-unit id="8627270becb595b05140641f72d8445a0f79aa4e" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;STORED&lt;/code&gt; is not standard but is also used by other SQL implementations. The SQL standard does not specify the storage of generated columns.</source>
          <target state="translated">オプション &lt;code&gt;STORED&lt;/code&gt; は標準ではありませんが、他のSQL実装でも使用されます。SQL標準では、生成された列のストレージは指定されていません。</target>
        </trans-unit>
        <trans-unit id="a815faad2e87479a66432f285e1a514f8c1d46e0" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, any database name in the connection string will be ignored.</source>
          <target state="translated">このオプションは、他のクライアントアプリケーションとの整合性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_basebackupはクラスター内の特定のデータベースに接続しないため、接続文字列内のデータベース名はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="734d38a3ce131eec63febbaae7def3c5bde63bbb" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_basebackup doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">このオプションは他のクライアントアプリケーションとの一貫性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_basebackupはクラスター内の特定のデータベースに接続しないため、接続文字列のデータベース名は無視されます。</target>
        </trans-unit>
        <trans-unit id="0db5016ffe3da0ce1e6c9b806713d2a3baee1dd9" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_dumpall needs to connect to many databases, the database name in the connection string will be ignored. Use the &lt;code&gt;-l&lt;/code&gt; option to specify the name of the database used for the initial connection, which will dump global objects and discover what other databases should be dumped.</source>
          <target state="translated">このオプションは他のクライアントアプリケーションとの一貫性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_dumpallは多くのデータベースに接続する必要があるため、接続文字列のデータベース名は無視されます。使用 &lt;code&gt;-l&lt;/code&gt; グローバルオブジェクトをダンプし、他のデータベースをダンプする必要があるものを発見する最初の接続に使用するデータベースの名前を指定するオプション。</target>
        </trans-unit>
        <trans-unit id="b6f402f5f677410d43632fdfdda39802e1f95c15" translate="yes" xml:space="preserve">
          <source>The option is called &lt;code&gt;--dbname&lt;/code&gt; for consistency with other client applications, but because pg_receivewal doesn't connect to any particular database in the cluster, database name in the connection string will be ignored.</source>
          <target state="translated">このオプションは他のクライアントアプリケーションとの一貫性を &lt;code&gt;--dbname&lt;/code&gt; ために--dbnameと呼ばれますが、pg_receivewalはクラスター内の特定のデータベースに接続しないため、接続文字列のデータベース名は無視されます。</target>
        </trans-unit>
        <trans-unit id="c7c64ec896dfd3c50e33366b062eb4c419c8b0b7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;CYCLE&lt;/code&gt; key word can be used to enable the sequence to wrap around when the &lt;code&gt;maxvalue&lt;/code&gt; or &lt;code&gt;minvalue&lt;/code&gt; has been reached by an ascending or descending sequence respectively. If the limit is reached, the next number generated will be the &lt;code&gt;minvalue&lt;/code&gt; or &lt;code&gt;maxvalue&lt;/code&gt;, respectively.</source>
          <target state="translated">任意 &lt;code&gt;CYCLE&lt;/code&gt; のキー・ワードは、場合周りにラップする配列を可能にするために使用することができる &lt;code&gt;maxvalue&lt;/code&gt; または &lt;code&gt;minvalue&lt;/code&gt; 昇順またはそれぞれ降順によって到達されました。限界に達した場合、生成された次数があろう &lt;code&gt;minvalue&lt;/code&gt; または &lt;code&gt;maxvalue&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="2bdec9ebdf4b00fd140bf7dd49f116ee6c5a4a50" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;GROUP BY&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;GROUP BY&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="9c06d7f3daaeb4524eeb820424e28a6752ac9545" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;HAVING&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;HAVING&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="e76a720d25d7bf8d3cf5b4abaa11a67203b026f7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause specifies a list of columns which will be included in the index as &lt;em&gt;non-key&lt;/em&gt; columns. A non-key column cannot be used in an index scan search qualification, and it is disregarded for purposes of any uniqueness or exclusion constraint enforced by the index. However, an index-only scan can return the contents of non-key columns without having to visit the index's table, since they are available directly from the index entry. Thus, addition of non-key columns allows index-only scans to be used for queries that otherwise could not use them.</source>
          <target state="translated">オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句は、&lt;em&gt;非キー&lt;/em&gt;列としてインデックスに含まれる列のリストを指定します。非キー列は、インデックススキャンの検索条件では使用できません。また、インデックスによって実施される一意性または除外制約のために無視されます。ただし、インデックスのみのスキャンでは、インデックスエントリから直接使用できるため、インデックスのテーブルにアクセスすることなく、非キーカラムの内容を返すことができます。したがって、非キー列を追加すると、インデックスのみのスキャンを、他の方法では使用できなかったクエリに使用できます。</target>
        </trans-unit>
        <trans-unit id="2aa8e8dd6edbe127a1d3d92fe785e89d8eca0bac" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new foreign table automatically inherits all columns. Parent tables can be plain tables or foreign tables. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">オプションの &lt;code&gt;INHERITS&lt;/code&gt; 句は、新しい外部テーブルがすべての列を自動的に継承するテーブルのリストを指定します。親テーブルは、プレーンテーブルまたは外部テーブルです。詳細については、同様の形式の&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d357ec942143a3e86ce2ca9c6595bccf9733322e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;INHERITS&lt;/code&gt; clause specifies a list of tables from which the new table automatically inherits all columns. Parent tables can be plain tables or foreign tables.</source>
          <target state="translated">オプションの &lt;code&gt;INHERITS&lt;/code&gt; 句は、新しいテーブルがすべての列を自動的に継承するテーブルのリストを指定します。親テーブルは、プレーンテーブルまたは外部テーブルです。</target>
        </trans-unit>
        <trans-unit id="935c04d83e4414228c1da5a13e9997ce0d9aed17" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LANGUAGE&lt;/code&gt; clause can be written either before or after the code block.</source>
          <target state="translated">オプションの &lt;code&gt;LANGUAGE&lt;/code&gt; 句は、コードブロックの前または後に記述できます。</target>
        </trans-unit>
        <trans-unit id="4b362bf605fea7a639d64d32d41debf1c9b97b1a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ON CONFLICT&lt;/code&gt; clause specifies an alternative action to raising a unique violation or exclusion constraint violation error. For each individual row proposed for insertion, either the insertion proceeds, or, if an &lt;em&gt;arbiter&lt;/em&gt; constraint or index specified by &lt;em&gt;&lt;code&gt;conflict_target&lt;/code&gt;&lt;/em&gt; is violated, the alternative &lt;em&gt;&lt;code&gt;conflict_action&lt;/code&gt;&lt;/em&gt; is taken. &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; simply avoids inserting a row as its alternative action. &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; updates the existing row that conflicts with the row proposed for insertion as its alternative action.</source>
          <target state="translated">オプションの &lt;code&gt;ON CONFLICT&lt;/code&gt; 句は、一意の違反または除外制約違反エラーを発生させる代替アクションを指定します。挿入が提案された個々の行ごとに、挿入が進行するか、&lt;em&gt; &lt;code&gt;conflict_target&lt;/code&gt; &lt;/em&gt;で指定された&lt;em&gt;アービター&lt;/em&gt;制約またはインデックスに違反した場合は、代替の&lt;em&gt; &lt;code&gt;conflict_action&lt;/code&gt; &lt;/em&gt;が実行されます。 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; は、代替アクションとして行を挿入することを単に回避します。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; は、代替アクションとして挿入が提案された行と競合する既存の行を更新します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5dd05dee5b8b79438a7ed8440a1b3f1d3a71ea3" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;ORDER BY&lt;/code&gt; clause has this general form:</source>
          <target state="translated">オプションの &lt;code&gt;ORDER BY&lt;/code&gt; 句の一般的な形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7116353ef7e307ca01f79a625c49cbb834ed45dc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;PARTITION BY&lt;/code&gt; clause specifies a strategy of partitioning the table. The table thus created is called a &lt;em&gt;partitioned&lt;/em&gt; table. The parenthesized list of columns or expressions forms the &lt;em&gt;partition key&lt;/em&gt; for the table. When using range or hash partitioning, the partition key can include multiple columns or expressions (up to 32, but this limit can be altered when building PostgreSQL), but for list partitioning, the partition key must consist of a single column or expression.</source>
          <target state="translated">オプションの &lt;code&gt;PARTITION BY&lt;/code&gt; 句は、テーブルを分割する方法を指定します。このように作成されたテーブルは、&lt;em&gt;パーティション&lt;/em&gt;テーブルと呼ば&lt;em&gt;れ&lt;/em&gt;ます。括弧で囲まれた列または式のリストは、テーブルの&lt;em&gt;パーティションキー&lt;/em&gt;を形成します。範囲またはハッシュパーティションを使用する場合、パーティションキーには複数の列または式を含めることができますが（最大32ですが、この制限はPostgreSQLを構築するときに変更できます）、リストパーティションの場合、パーティションキーは単一の列または式で構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="f6243054cea2c976be92eb3f4ea9df686539e824" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RECURSIVE&lt;/code&gt; modifier changes &lt;code&gt;WITH&lt;/code&gt; from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using &lt;code&gt;RECURSIVE&lt;/code&gt;, a &lt;code&gt;WITH&lt;/code&gt; query can refer to its own output. A very simple example is this query to sum the integers from 1 through 100:</source>
          <target state="translated">オプションの &lt;code&gt;RECURSIVE&lt;/code&gt; 修飾子は、 &lt;code&gt;WITH&lt;/code&gt; を単なる構文上の便利さから、標準SQLでは不可能であったことを実行する機能に変更します。 &lt;code&gt;RECURSIVE&lt;/code&gt; を使用すると、 &lt;code&gt;WITH&lt;/code&gt; クエリは自身の出力を参照できます。非常に単純な例は、1から100までの整数を合計する次のクエリです。</target>
        </trans-unit>
        <trans-unit id="fadff698169cd4951ccc6a878ef428bb081f97f0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;REPEATABLE&lt;/code&gt; clause specifies a &lt;code&gt;seed&lt;/code&gt; number or expression to use for generating random numbers within the sampling method. The seed value can be any non-null floating-point value. Two queries that specify the same seed and &lt;code&gt;argument&lt;/code&gt; values will select the same sample of the table, if the table has not been changed meanwhile. But different seed values will usually produce different samples. If &lt;code&gt;REPEATABLE&lt;/code&gt; is not given then a new random sample is selected for each query, based upon a system-generated seed. Note that some add-on sampling methods do not accept &lt;code&gt;REPEATABLE&lt;/code&gt;, and will always produce new samples on each use.</source>
          <target state="translated">オプションの &lt;code&gt;REPEATABLE&lt;/code&gt; 句は、サンプリングメソッド内で乱数を生成するために使用する &lt;code&gt;seed&lt;/code&gt; 番号または式を指定します。シード値には、null以外の任意の浮動小数点値を指定できます。その間にテーブルが変更されていない場合、同じシードと &lt;code&gt;argument&lt;/code&gt; 値を指定する2つのクエリは、テーブルの同じサンプルを選択します。ただし、シード値が異なると、通常は異なるサンプルが生成されます。 &lt;code&gt;REPEATABLE&lt;/code&gt; が指定されていない場合、システムで生成されたシードに基づいて、クエリごとに新しいランダムサンプルが選択されます。一部のアドオンサンプリングメソッドは &lt;code&gt;REPEATABLE&lt;/code&gt; を受け入れず、使用するたびに常に新しいサンプルを生成することに注意してください。</target>
        </trans-unit>
        <trans-unit id="8777d7f8d07792d4f3e98ee0b8208d63db9f0b46" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;DELETE&lt;/code&gt; to compute and return value(s) based on each row actually deleted. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;USING&lt;/code&gt;, can be computed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;RETURNING&lt;/code&gt; 句を使用すると、 &lt;code&gt;DELETE&lt;/code&gt; は実際に削除された各行に基づいて値を計算して返します。テーブルの列や &lt;code&gt;USING&lt;/code&gt; で言及された他のテーブルの列、あるいはその両方を使用する式はすべて計算できます。 &lt;code&gt;RETURNING&lt;/code&gt; リストの構文は、 &lt;code&gt;SELECT&lt;/code&gt; の出力リストの構文と同じです。</target>
        </trans-unit>
        <trans-unit id="3578c21272426a6d018e36dbe114df05af571e18" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;INSERT&lt;/code&gt; to compute and return value(s) based on each row actually inserted (or updated, if an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause was used). This is primarily useful for obtaining values that were supplied by defaults, such as a serial sequence number. However, any expression using the table's columns is allowed. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;. Only rows that were successfully inserted or updated will be returned. For example, if a row was locked but not updated because an &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; clause &lt;code&gt;condition&lt;/code&gt; was not satisfied, the row will not be returned.</source>
          <target state="translated">オプションの &lt;code&gt;RETURNING&lt;/code&gt; 句を使用すると、 &lt;code&gt;INSERT&lt;/code&gt; は実際に挿入された（または &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句が使用された場合は更新された）各行に基づいて値を計算して返します。これは主に、シリアルシーケンス番号など、デフォルトで提供された値を取得するのに役立ちます。ただし、テーブルの列を使用する式は許可されます。 &lt;code&gt;RETURNING&lt;/code&gt; リストの構文は、 &lt;code&gt;SELECT&lt;/code&gt; の出力リストの構文と同じです。正常に挿入または更新された行のみが返されます。たとえば、 &lt;code&gt;ON CONFLICT DO UPDATE ... WHERE&lt;/code&gt; 句の &lt;code&gt;condition&lt;/code&gt; が満たされていないために行がロックされたが更新されなかった場合、行は返されません。</target>
        </trans-unit>
        <trans-unit id="26fec39eb66cc8ba300ea17034aad6e1ab719ea0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;RETURNING&lt;/code&gt; clause causes &lt;code&gt;UPDATE&lt;/code&gt; to compute and return value(s) based on each row actually updated. Any expression using the table's columns, and/or columns of other tables mentioned in &lt;code&gt;FROM&lt;/code&gt;, can be computed. The new (post-update) values of the table's columns are used. The syntax of the &lt;code&gt;RETURNING&lt;/code&gt; list is identical to that of the output list of &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;RETURNING&lt;/code&gt; 句を使用すると、 &lt;code&gt;UPDATE&lt;/code&gt; は実際に更新された各行に基づいて値を計算して返します。テーブルの列、および/または &lt;code&gt;FROM&lt;/code&gt; で言及された他のテーブルの列を使用する任意の式を計算できます。テーブルの列の新しい（更新後）値が使用されます。 &lt;code&gt;RETURNING&lt;/code&gt; リストの構文は、 &lt;code&gt;SELECT&lt;/code&gt; の出力リストの構文と同じです。</target>
        </trans-unit>
        <trans-unit id="7038a19db2dc16317b16f8d00a20421d7087db41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;WHERE&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="7792c91023d2f01afcab3c87bb09f61e0ba95957" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses in the table expression specify a pipeline of successive transformations performed on the table derived in the &lt;code&gt;FROM&lt;/code&gt; clause. All these transformations produce a virtual table that provides the rows that are passed to the select list to compute the output rows of the query.</source>
          <target state="translated">テーブル式のオプションの &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句は、 &lt;code&gt;FROM&lt;/code&gt; 句で派生したテーブルで実行される連続した変換のパイプラインを指定します。これらの変換はすべて、クエリの出力行を計算するために選択リストに渡される行を提供する仮想テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="8a3824e49e923ca91de9f24e0e18785c61620d57" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WINDOW&lt;/code&gt; clause has the general form</source>
          <target state="translated">オプションの &lt;code&gt;WINDOW&lt;/code&gt; 句の一般的な形式</target>
        </trans-unit>
        <trans-unit id="0734bf4cc1224dac3864d0137b3f27ef1692d40c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH&lt;/code&gt; clause specifies &lt;em&gt;storage parameters&lt;/em&gt; for the index. Each index method has its own set of allowed storage parameters. The B-tree, hash, GiST and SP-GiST index methods all accept this parameter:</source>
          <target state="translated">オプションの &lt;code&gt;WITH&lt;/code&gt; 句は、インデックスの&lt;em&gt;格納パラメータ&lt;/em&gt;を指定します。各インデックスメソッドには、許可されたストレージパラメータの独自のセットがあります。Bツリー、ハッシュ、GiST、およびSP-GiSTインデックスメソッドはすべて、このパラメーターを受け入れます。</target>
        </trans-unit>
        <trans-unit id="a2ab89e063673dbb227b7d91abdf56f04b8f9bc9" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause gives a comma-separated list of namespace definitions, where each &lt;code&gt;namespace_uri&lt;/code&gt; is a &lt;code&gt;text&lt;/code&gt; expression and each &lt;code&gt;namespace_name&lt;/code&gt; is a simple identifier. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">オプションの &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 句は、名前空間定義のコンマ区切りのリストを提供します。ここで、各 &lt;code&gt;namespace_uri&lt;/code&gt; は &lt;code&gt;text&lt;/code&gt; 式であり、各 &lt;code&gt;namespace_name&lt;/code&gt; は単純な識別子です。ドキュメントで使用されるXML名前空間とそのエイリアスを指定します。デフォルトの名前空間仕様は現在サポートされていません。</target>
        </trans-unit>
        <trans-unit id="058389bedd0ce52c16be7bfd9114242b91506b69" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;XMLNAMESPACES&lt;/code&gt; clause is a comma-separated list of namespaces. It specifies the XML namespaces used in the document and their aliases. A default namespace specification is not currently supported.</source>
          <target state="translated">オプションの &lt;code&gt;XMLNAMESPACES&lt;/code&gt; 句は、名前空間のコンマ区切りのリストです。ドキュメントで使用されるXML名前空間とそのエイリアスを指定します。デフォルトの名前空間仕様は現在サポートされていません。</target>
        </trans-unit>
        <trans-unit id="57ded7b498b198ec6bfc70d87458a99fd28a21d6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;analyze_function&lt;/code&gt; performs type-specific statistics collection for columns of the data type. By default, &lt;code&gt;ANALYZE&lt;/code&gt; will attempt to gather statistics using the type's &amp;ldquo;equals&amp;rdquo; and &amp;ldquo;less-than&amp;rdquo; operators, if there is a default b-tree operator class for the type. For non-scalar types this behavior is likely to be unsuitable, so it can be overridden by specifying a custom analysis function. The analysis function must be declared to take a single argument of type &lt;code&gt;internal&lt;/code&gt;, and return a &lt;code&gt;boolean&lt;/code&gt; result. The detailed API for analysis functions appears in &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt;.</source>
          <target state="translated">オプションの &lt;code&gt;analyze_function&lt;/code&gt; は、データ型の列に対して型固有の統計収集を実行します。タイプにデフォルトのbツリー演算子クラスがある場合、 &lt;code&gt;ANALYZE&lt;/code&gt; はデフォルトで、タイプの「等しい」および「より小さい」演算子を使用して統計を収集しようとします。非スカラー型の場合、この動作は不適切である可能性が高いため、カスタム分析関数を指定することでオーバーライドできます。分析関数は、 &lt;code&gt;internal&lt;/code&gt; 型の単一の引数を取り、 &lt;code&gt;boolean&lt;/code&gt; 結果を返すように宣言する必要があります。分析関数の詳細なAPIは &lt;code&gt;src/include/commands/vacuum.h&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="7747a49a90a7a4edd6982d5e13265f6731caae73" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;canonical&lt;/code&gt; function must take one argument of the range type being defined, and return a value of the same type. This is used to convert range values to a canonical form, when applicable. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information. Creating a &lt;code&gt;canonical&lt;/code&gt; function is a bit tricky, since it must be defined before the range type can be declared. To do this, you must first create a shell type, which is a placeholder type that has no properties except a name and an owner. This is done by issuing the command &lt;code&gt;CREATE TYPE name&lt;/code&gt;, with no additional parameters. Then the function can be declared using the shell type as argument and result, and finally the range type can be declared using the same name. This automatically replaces the shell type entry with a valid range type.</source>
          <target state="translated">オプションの &lt;code&gt;canonical&lt;/code&gt; 関数は、定義されている範囲型の引数を1つ取り、同じ型の値を返す必要があります。これは、該当する場合、範囲値を標準形式に変換するために使用されます。詳細については、&lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;セクション8.17.8&lt;/a&gt;を参照してください。範囲関数を宣言する前に定義する必要があるため、 &lt;code&gt;canonical&lt;/code&gt; 関数の作成は少し難しいです。これを行うには、最初にシェルタイプを作成する必要があります。これは、名前と所有者以外のプロパティを持たないプレースホルダータイプです。これを行うには、コマンド &lt;code&gt;CREATE TYPE name&lt;/code&gt; を発行します。、追加のパラメーターなし。その後、引数と結果としてシェル型を使用して関数を宣言できます。最後に、同じ名前を使用して範囲型を宣言できます。これにより、シェルタイプエントリが有効な範囲タイプに自動的に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="e405c33bd06f9fd7d49a367fa9d3ceab7c5a9a0c" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flag&lt;/code&gt; string may include one or more of the characters &lt;code&gt;i&lt;/code&gt; for case-insensitive match, &lt;code&gt;m&lt;/code&gt; to allow &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to match at newlines, &lt;code&gt;s&lt;/code&gt; to allow &lt;code&gt;.&lt;/code&gt; to match a newline, and &lt;code&gt;q&lt;/code&gt; to quote the whole pattern (reducing the behavior to a simple substring match).</source>
          <target state="translated">オプションの &lt;code&gt;flag&lt;/code&gt; 文字列は文字の一つ以上含むことができる &lt;code&gt;i&lt;/code&gt; 大文字と小文字を区別しない一致のために、 &lt;code&gt;m&lt;/code&gt; 可能にするために &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; は改行に一致するように、 &lt;code&gt;s&lt;/code&gt; は許可します &lt;code&gt;.&lt;/code&gt; 改行を照合するには &lt;code&gt;q&lt;/code&gt; を使用し、パターン全体を引用符で囲みます（動作を単純な部分文字列照合に減らします）。</target>
        </trans-unit>
        <trans-unit id="6929038d2d7ee1cd89d49d3d8b27997b9126c9d2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">オプションの &lt;code&gt;frame_clause&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="1a0ad788554501dd9d4e6143a34e5057b31ec466" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;frame_clause&lt;/code&gt; defines the &lt;em&gt;window frame&lt;/em&gt; for window functions that depend on the frame (not all do). The window frame is a set of related rows for each row of the query (called the &lt;em&gt;current row&lt;/em&gt;). The &lt;code&gt;frame_clause&lt;/code&gt; can be one of</source>
          <target state="translated">オプションの &lt;code&gt;frame_clause&lt;/code&gt; は、&lt;em&gt;フレーム&lt;/em&gt;に依存する（すべてではない）ウィンドウ関数の&lt;em&gt;ウィンドウフレーム&lt;/em&gt;を定義し&lt;em&gt;ます&lt;/em&gt;。ウィンドウフレームは、クエリの各行（&lt;em&gt;現在の行&lt;/em&gt;と呼ばれる）の関連する行のセットです。 &lt;code&gt;frame_clause&lt;/code&gt; は、のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="78c603df9d8f5aec2127eee4c089f14a6a63935b" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;like_option&lt;/code&gt; clauses specify which additional properties of the original table to copy. Specifying &lt;code&gt;INCLUDING&lt;/code&gt; copies the property, specifying &lt;code&gt;EXCLUDING&lt;/code&gt; omits the property. &lt;code&gt;EXCLUDING&lt;/code&gt; is the default. If multiple specifications are made for the same kind of object, the last one is used. The available options are:</source>
          <target state="translated">オプションの &lt;code&gt;like_option&lt;/code&gt; 句は、コピーする元のテーブルの追加のプロパティを指定します。 &lt;code&gt;INCLUDING&lt;/code&gt; を指定するとプロパティがコピーされ、 &lt;code&gt;EXCLUDING&lt;/code&gt; を指定するとプロパティが省略されます。 &lt;code&gt;EXCLUDING&lt;/code&gt; がデフォルトです。同じ種類のオブジェクトに対して複数の指定が行われた場合、最後の指定が使用されます。使用可能なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3b1514641d42b559d683d1926252a8c2e4d381f2" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;receive_function&lt;/code&gt; converts the type's external binary representation to the internal representation. If this function is not supplied, the type cannot participate in binary input. The binary representation should be chosen to be cheap to convert to internal form, while being reasonably portable. (For example, the standard integer data types use network byte order as the external binary representation, while the internal representation is in the machine's native byte order.) The receive function should perform adequate checking to ensure that the value is valid. The receive function can be declared as taking one argument of type &lt;code&gt;internal&lt;/code&gt;, or as taking three arguments of types &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;. The first argument is a pointer to a &lt;code&gt;StringInfo&lt;/code&gt; buffer holding the received byte string; the optional arguments are the same as for the text input function. The receive function must return a value of the data type itself. Usually, a receive function should be declared STRICT; if it is not, it will be called with a NULL first parameter when reading a NULL input value. The function must still return NULL in this case, unless it raises an error. (This case is mainly meant to support domain receive functions, which might need to reject NULL inputs.) Similarly, the optional &lt;code&gt;send_function&lt;/code&gt; converts from the internal representation to the external binary representation. If this function is not supplied, the type cannot participate in binary output. The send function must be declared as taking one argument of the new data type. The send function must return type &lt;code&gt;bytea&lt;/code&gt;. Send functions are not invoked for NULL values.</source>
          <target state="translated">オプションの &lt;code&gt;receive_function&lt;/code&gt; は、型の外部バイナリ表現を内部表現に変換します。この関数が提供されていない場合、型はバイナリ入力に参加できません。バイナリ表現は、合理的に移植可能である一方で、内部形式に変換するのに安価であるように選択する必要があります。 （たとえば、標準の整数データ型は外部バイナリ表現としてネットワークバイトオーダーを使用しますが、内部表現はマシンのネイティブバイトオーダーです。）受信関数は適切なチェックを実行して、値が有効であることを確認する必要があります。 receive関数は、 &lt;code&gt;internal&lt;/code&gt; 型の引数を1つ取るか、 &lt;code&gt;internal&lt;/code&gt; 、 &lt;code&gt;oid&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 型の引数を3つ取ると宣言できます。。最初の引数は、受信したバイト文字列を保持する &lt;code&gt;StringInfo&lt;/code&gt; バッファへのポインタです。オプションの引数は、テキスト入力関数の場合と同じです。 receive関数は、データ型自体の値を返す必要があります。通常、受信関数はSTRICTとして宣言する必要があります。そうでない場合は、NULL入力値を読み取るときにNULLの最初のパラメーターで呼び出されます。この場合、エラーが発生しない限り、関数はNULLを返す必要があります。 （このケースは主に、NULL入力を拒否する必要があるドメイン受信関数をサポートするためのものです。）同様に、オプションの &lt;code&gt;send_function&lt;/code&gt; 内部表現から外部バイナリ表現に変換します。この関数が提供されない場合、型はバイナリ出力に参加できません。send関数は、新しいデータ型の1つの引数を取るように宣言する必要があります。send関数は、タイプ &lt;code&gt;bytea&lt;/code&gt; を返す必要があります。NULL値の場合、送信関数は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="7d7acb9837f1f10a2e0445707407528f679ac86a" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;sequence_options&lt;/code&gt; clause can be used to override the options of the sequence. See &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; for details.</source>
          <target state="translated">オプションの &lt;code&gt;sequence_options&lt;/code&gt; 句を使用して、シーケンスのオプションを上書きできます。詳細については、&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7bcdb21e727a9ca38cf42b2a6d25b5e2872506f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;subtype_diff&lt;/code&gt; function must take two values of the &lt;code&gt;subtype&lt;/code&gt; type as argument, and return a &lt;code&gt;double precision&lt;/code&gt; value representing the difference between the two given values. While this is optional, providing it allows much greater efficiency of GiST indexes on columns of the range type. See &lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;Section 8.17.8&lt;/a&gt; for more information.</source>
          <target state="translated">オプションの &lt;code&gt;subtype_diff&lt;/code&gt; 関数は、 &lt;code&gt;subtype&lt;/code&gt; 2つの値を引数として取り、指定された2つの値の差を表す &lt;code&gt;double precision&lt;/code&gt; 値を返す必要があります。これはオプションですが、範囲タイプの列でGiSTインデックスの効率を大幅に向上させることができます。詳細については、&lt;a href=&quot;rangetypes#RANGETYPES-DEFINING&quot;&gt;セクション8.17.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1325ceadd1cae01690d39e7c916f8ac8cf741797" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;type_modifier_input_function&lt;/code&gt; and &lt;code&gt;type_modifier_output_function&lt;/code&gt; are needed if the type supports modifiers, that is optional constraints attached to a type declaration, such as &lt;code&gt;char(5)&lt;/code&gt; or &lt;code&gt;numeric(30,2)&lt;/code&gt;. PostgreSQL allows user-defined types to take one or more simple constants or identifiers as modifiers. However, this information must be capable of being packed into a single non-negative integer value for storage in the system catalogs. The &lt;code&gt;type_modifier_input_function&lt;/code&gt; is passed the declared modifier(s) in the form of a &lt;code&gt;cstring&lt;/code&gt; array. It must check the values for validity (throwing an error if they are wrong), and if they are correct, return a single non-negative &lt;code&gt;integer&lt;/code&gt; value that will be stored as the column &amp;ldquo;typmod&amp;rdquo;. Type modifiers will be rejected if the type does not have a &lt;code&gt;type_modifier_input_function&lt;/code&gt;. The &lt;code&gt;type_modifier_output_function&lt;/code&gt; converts the internal integer typmod value back to the correct form for user display. It must return a &lt;code&gt;cstring&lt;/code&gt; value that is the exact string to append to the type name; for example &lt;code&gt;numeric&lt;/code&gt;'s function might return &lt;code&gt;(30,2)&lt;/code&gt;. It is allowed to omit the &lt;code&gt;type_modifier_output_function&lt;/code&gt;, in which case the default display format is just the stored typmod integer value enclosed in parentheses.</source>
          <target state="translated">オプションの &lt;code&gt;type_modifier_input_function&lt;/code&gt; および &lt;code&gt;type_modifier_output_function&lt;/code&gt; は、タイプが修飾子をサポートする場合に必要です。これは、 &lt;code&gt;char(5)&lt;/code&gt; や &lt;code&gt;numeric(30,2)&lt;/code&gt; などのタイプ宣言に付加されたオプションの制約です。 PostgreSQLでは、ユーザー定義型で1つ以上の単純な定数または識別子を修飾子として使用できます。ただし、この情報は、システムカタログに格納するために、単一の負でない整数値にパックできる必要があります。 &lt;code&gt;type_modifier_input_function&lt;/code&gt; が渡されるの形で（S）修飾子宣言 &lt;code&gt;cstring&lt;/code&gt; アレイ。値の妥当性をチェックし（値が間違っている場合はエラーをスローする）、値が正しい場合は1つの負でない値を返す &lt;code&gt;integer&lt;/code&gt; 列「typmod」として格納される整数値。タイプに &lt;code&gt;type_modifier_input_function&lt;/code&gt; がない場合、タイプ修飾子は拒否されます。 &lt;code&gt;type_modifier_output_function&lt;/code&gt; は、ユーザ表示用の正しい形式に内部整数typmod値バックを変換します。型名に追加する正確な文字列である &lt;code&gt;cstring&lt;/code&gt; 値を返す必要があります。たとえば、 &lt;code&gt;numeric&lt;/code&gt; の関数は &lt;code&gt;(30,2)&lt;/code&gt; を返す可能性があります。 &lt;code&gt;type_modifier_output_function&lt;/code&gt; を省略できます。この場合、デフォルトの表示形式は、括弧で囲まれた格納されたtypmod整数値のみです。</target>
        </trans-unit>
        <trans-unit id="af1ecc2cb7dfd4fb66fffd97bf916a5a132fb429" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; changes the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;.</source>
          <target state="translated">オプションの句 &lt;code&gt;AS data_type&lt;/code&gt; は、シーケンスのデータ型を変更します。有効なタイプは、 &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a6491ae8d81a26646c521265ecd71bb3dba07346" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;AS data_type&lt;/code&gt; specifies the data type of the sequence. Valid types are &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. &lt;code&gt;bigint&lt;/code&gt; is the default. The data type determines the default minimum and maximum values of the sequence.</source>
          <target state="translated">オプションの句 &lt;code&gt;AS data_type&lt;/code&gt; は、シーケンスのデータ型を指定します。有効なタイプは、 &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; です。 &lt;code&gt;bigint&lt;/code&gt; がデフォルトです。データ型によって、シーケンスのデフォルトの最小値と最大値が決まります。</target>
        </trans-unit>
        <trans-unit id="4ef52006c6e494bfa443e060a826bdc36541e6b7" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;CACHE cache&lt;/code&gt; specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.</source>
          <target state="translated">オプションの句 &lt;code&gt;CACHE cache&lt;/code&gt; は、より高速なアクセスのために、事前に割り当てられ、メモリに格納されるシーケンス番号の数を指定します。最小値は1（一度に生成できる値は1つのみ、つまりキャッシュなし）で、これもデフォルトです。</target>
        </trans-unit>
        <trans-unit id="e1922af2324c94734b798d29c69dd1e6a8cd6788" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;INCREMENT BY increment&lt;/code&gt; specifies which value is added to the current sequence value to create a new value. A positive value will make an ascending sequence, a negative one a descending sequence. The default value is 1.</source>
          <target state="translated">オプションの &lt;code&gt;INCREMENT BY increment&lt;/code&gt; 句は、新しい値を作成するために現在のシーケンス値に追加される値を指定します。正の値は昇順のシーケンスになり、負の値は降順のシーケンスになります。デフォルト値は1です。</target>
        </trans-unit>
        <trans-unit id="129d57b7ace9b8671169f53fc01dbaf732d5dd2a" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, the defaults of the maximum value of the data type and -1 for ascending and descending sequences, respectively, will be used. If neither option is specified, the current maximum value will be maintained.</source>
          <target state="translated">オプションの句 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; は、シーケンスの最大値を決定します。 &lt;code&gt;NO MAXVALUE&lt;/code&gt; が指定されている場合、データ型の最大値のデフォルトと昇順と降順の-1のデフォルトがそれぞれ使用されます。どちらのオプションも指定しない場合、現在の最大値が維持されます。</target>
        </trans-unit>
        <trans-unit id="636d2219bc9ef5ee8fa4e79b4cd4c563ed5f1551" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; determines the maximum value for the sequence. If this clause is not supplied or &lt;code&gt;NO MAXVALUE&lt;/code&gt; is specified, then default values will be used. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.</source>
          <target state="translated">オプションの句 &lt;code&gt;MAXVALUE maxvalue&lt;/code&gt; は、シーケンスの最大値を決定します。この句が指定されていない場合、または &lt;code&gt;NO MAXVALUE&lt;/code&gt; が指定されている場合は、デフォルト値が使用されます。昇順のデフォルトは、データ型の最大値です。降順のデフォルトは-1です。</target>
        </trans-unit>
        <trans-unit id="c5eb2614e0e305c391d790e5028cc9a0dac1d3fe" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, the defaults of 1 and the minimum value of the data type for ascending and descending sequences, respectively, will be used. If neither option is specified, the current minimum value will be maintained.</source>
          <target state="translated">オプションの句 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; は、シーケンスが生成できる最小値を決定します。場合 &lt;code&gt;NO MINVALUE&lt;/code&gt; が指定され、1のデフォルトおよび配列を昇降するためのデータ・タイプの最小値は、それぞれ、使用されるであろう。どちらのオプションも指定しない場合、現在の最小値が維持されます。</target>
        </trans-unit>
        <trans-unit id="e9e2bcb7eb75a3afb340c5c1fc227a8406ff8640" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;MINVALUE minvalue&lt;/code&gt; determines the minimum value a sequence can generate. If this clause is not supplied or &lt;code&gt;NO MINVALUE&lt;/code&gt; is specified, then defaults will be used. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.</source>
          <target state="translated">オプションの句 &lt;code&gt;MINVALUE minvalue&lt;/code&gt; は、シーケンスが生成できる最小値を決定します。この句が指定されていない場合、または &lt;code&gt;NO MINVALUE&lt;/code&gt; が指定されている場合は、デフォルトが使用されます。昇順シーケンスのデフォルトは1です。降順シーケンスのデフォルトは、データ型の最小値です。</target>
        </trans-unit>
        <trans-unit id="fcd2de5b18440bca469ca6adbeb6f5f5db2e6405" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; changes the current value of the sequence. This is similar to calling the &lt;code&gt;setval&lt;/code&gt; function with &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;: the specified value will be returned by the &lt;em&gt;next&lt;/em&gt; call of &lt;code&gt;nextval&lt;/code&gt;. Writing &lt;code&gt;RESTART&lt;/code&gt; with no &lt;code&gt;restart&lt;/code&gt; value is equivalent to supplying the start value that was recorded by &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="translated">オプションの句 &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; は、シーケンスの現在の値を変更します。これは、 &lt;code&gt;is_called&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; で &lt;code&gt;setval&lt;/code&gt; 関数を呼び出すのと似ています。指定された値は、 &lt;code&gt;nextval&lt;/code&gt; の&lt;em&gt;次の&lt;/em&gt;呼び出しで返されます。 &lt;code&gt;restart&lt;/code&gt; 値なしで &lt;code&gt;RESTART&lt;/code&gt; を書き込むことは、 &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; によって記録された、または最後に &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt; によって設定された開始値を提供することと同じです。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fb28acc2fa41aa8ead28a09cd415f780a8cadf0" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; allows the sequence to begin anywhere. The default starting value is &lt;code&gt;minvalue&lt;/code&gt; for ascending sequences and &lt;code&gt;maxvalue&lt;/code&gt; for descending ones.</source>
          <target state="translated">オプションの句 &lt;code&gt;START WITH start&lt;/code&gt; を使用すると、シーケンスをどこからでも開始できます。デフォルトの開始値は &lt;code&gt;minvalue&lt;/code&gt; 配列と、昇順のために &lt;code&gt;maxvalue&lt;/code&gt; ものを降順。</target>
        </trans-unit>
        <trans-unit id="eb785729e5f5d903e46bb6918c0a11aa04baffd1" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;START WITH start&lt;/code&gt; changes the recorded start value of the sequence. This has no effect on the &lt;em&gt;current&lt;/em&gt; sequence value; it simply sets the value that future &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; commands will use.</source>
          <target state="translated">オプションの句 &lt;code&gt;START WITH start&lt;/code&gt; は、シーケンスの記録された開始値を変更します。これは&lt;em&gt;現在の&lt;/em&gt;シーケンス値には影響しません。これは単に、将来の &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; コマンドが使用する値を設定するだけです。</target>
        </trans-unit>
        <trans-unit id="1713a9e1e99f66c0bcfe7df0c08c776ea8b0c311" translate="yes" xml:space="preserve">
          <source>The optional constraint clauses specify constraints (tests) that new or updated rows must satisfy for an insert or update operation to succeed. A constraint is an SQL object that helps define the set of valid values in the table in various ways.</source>
          <target state="translated">オプションの制約句は、新規または更新された行が挿入または更新操作を成功させるために満たす必要がある制約(テスト)を指定します。制約は、様々な方法でテーブル内の有効な値のセットを定義するのに役立つSQLオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="e18e0d61bcb7c9d71d791c91de29bb60405c83c7" translate="yes" xml:space="preserve">
          <source>The optional flag &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; indicates that values of this data type are passed by value, rather than by reference. Types passed by value must be fixed-length, and their internal representation cannot be larger than the size of the &lt;code&gt;Datum&lt;/code&gt; type (4 bytes on some machines, 8 bytes on others).</source>
          <target state="translated">オプションのフラグ &lt;code&gt;PASSEDBYVALUE&lt;/code&gt; は、このデータ型の値が参照ではなく値によって渡されることを示します。値で渡される型は固定長である必要があり、その内部表現は &lt;code&gt;Datum&lt;/code&gt; 型のサイズ（一部のマシンでは4バイト、その他のマシンでは8バイト）を超えることはできません。</target>
        </trans-unit>
        <trans-unit id="96f5588e1c2e2855ea8548eee4502bfe5b21503f" translate="yes" xml:space="preserve">
          <source>The optional parameter &lt;code&gt;PATTERN&lt;/code&gt; can be the name of a text search object, optionally schema-qualified. If &lt;code&gt;PATTERN&lt;/code&gt; is omitted then information about all visible objects will be displayed. &lt;code&gt;PATTERN&lt;/code&gt; can be a regular expression and can provide &lt;em&gt;separate&lt;/em&gt; patterns for the schema and object names. The following examples illustrate this:</source>
          <target state="translated">オプションのパラメーター &lt;code&gt;PATTERN&lt;/code&gt; は、オプションでスキーマ修飾されたテキスト検索オブジェクトの名前にすることができます。場合は &lt;code&gt;PATTERN&lt;/code&gt; 省略されたすべての可視オブジェクトに関する情報が表示されます。 &lt;code&gt;PATTERN&lt;/code&gt; は正規表現にすることができ、スキーマとオブジェクト名に&lt;em&gt;個別の&lt;/em&gt;パターンを提供できます。次の例は、これを示しています。</target>
        </trans-unit>
        <trans-unit id="de01abc64ad555117df4d2eb14da2dc8395e780a" translate="yes" xml:space="preserve">
          <source>The optional third argument of the function is an array of namespace mappings. This array should be a two-dimensional &lt;code&gt;text&lt;/code&gt; array with the length of the second axis being equal to 2 (i.e., it should be an array of arrays, each of which consists of exactly 2 elements). The first element of each array entry is the namespace name (alias), the second the namespace URI. It is not required that aliases provided in this array be the same as those being used in the XML document itself (in other words, both in the XML document and in the &lt;code&gt;xpath&lt;/code&gt; function context, aliases are &lt;em&gt;local&lt;/em&gt;).</source>
          <target state="translated">関数のオプションの3番目の引数は、名前空間マッピングの配列です。この配列は、2番目の軸の長さが2に等しい2 次元の &lt;code&gt;text&lt;/code&gt; 配列である必要があります（つまり、それぞれがちょうど2つの要素で構成される配列の配列である必要があります）。各配列エントリの最初の要素は名前空間名（エイリアス）、2番目の要素は名前空間URIです。この配列で提供されるエイリアスが、XMLドキュメント自体で使用されているエイリアスと同じである必要はありません（つまり、XMLドキュメントと &lt;code&gt;xpath&lt;/code&gt; 関数コンテキストの両方で、エイリアスは&lt;em&gt;localです&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="3d0c8a9e2cea5113636abde4ca21364d5044faa7" translate="yes" xml:space="preserve">
          <source>The optional user-defined method are:</source>
          <target state="translated">オプションのユーザー定義メソッドは</target>
        </trans-unit>
        <trans-unit id="f7c4a4f219f0aa64d3de98d0b070691b60ede2a2" translate="yes" xml:space="preserve">
          <source>The optional user-defined method is:</source>
          <target state="translated">オプションのユーザー定義メソッドは</target>
        </trans-unit>
        <trans-unit id="84a938a7941f222eb580e7e8263bbd7142209820" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--docdir&lt;/code&gt;, &lt;code&gt;--pkgincludedir&lt;/code&gt;, &lt;code&gt;--localedir&lt;/code&gt;, &lt;code&gt;--mandir&lt;/code&gt;, &lt;code&gt;--sharedir&lt;/code&gt;, &lt;code&gt;--sysconfdir&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, &lt;code&gt;--cppflags&lt;/code&gt;, &lt;code&gt;--cflags&lt;/code&gt;, &lt;code&gt;--cflags_sl&lt;/code&gt;, &lt;code&gt;--ldflags&lt;/code&gt;, &lt;code&gt;--ldflags_sl&lt;/code&gt;, and &lt;code&gt;--libs&lt;/code&gt; were added in PostgreSQL 8.1. The option &lt;code&gt;--htmldir&lt;/code&gt; was added in PostgreSQL 8.4. The option &lt;code&gt;--ldflags_ex&lt;/code&gt; was added in PostgreSQL 9.0.</source>
          <target state="translated">オプション &lt;code&gt;--docdir&lt;/code&gt; 、 &lt;code&gt;--pkgincludedir&lt;/code&gt; 、 &lt;code&gt;--localedir&lt;/code&gt; 、 &lt;code&gt;--mandir&lt;/code&gt; 、 &lt;code&gt;--sharedir&lt;/code&gt; 、 &lt;code&gt;--sysconfdir&lt;/code&gt; 、 &lt;code&gt;--cc&lt;/code&gt; 、 &lt;code&gt;--cppflags&lt;/code&gt; 、 &lt;code&gt;--cflags&lt;/code&gt; 、 &lt;code&gt;--cflags_sl&lt;/code&gt; 、 &lt;code&gt;--ldflags&lt;/code&gt; 、 &lt;code&gt;--ldflags_sl&lt;/code&gt; 、および &lt;code&gt;--libs&lt;/code&gt; はPostgreSQL 8.1で追加されました。オプション &lt;code&gt;--htmldir&lt;/code&gt; はPostgreSQL 8.4で追加されました。オプション &lt;code&gt;--ldflags_ex&lt;/code&gt; はPostgreSQL 9.0で追加されました。</target>
        </trans-unit>
        <trans-unit id="fabb800956bbdc09009ffd9f1b017eb0d6e1abef" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;-O&lt;/code&gt;, and &lt;code&gt;-T&lt;/code&gt; correspond to options of the underlying SQL command &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;; see there for more information about them.</source>
          <target state="translated">オプション &lt;code&gt;-D&lt;/code&gt; 、 &lt;code&gt;-l&lt;/code&gt; 、 &lt;code&gt;-E&lt;/code&gt; 、 &lt;code&gt;-O&lt;/code&gt; 、および &lt;code&gt;-T&lt;/code&gt; は、基礎となるSQLコマンド&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASEの&lt;/a&gt;オプションに対応しています。それらについての詳細はそちらを参照してください。</target>
        </trans-unit>
        <trans-unit id="b59022ce6b09c2f629170565a77c3c19be85bd9c" translate="yes" xml:space="preserve">
          <source>The options can appear in any order.</source>
          <target state="translated">オプションは任意の順番で表示されます。</target>
        </trans-unit>
        <trans-unit id="83b4362928db8b9651a7b14a89534a668d30b89b" translate="yes" xml:space="preserve">
          <source>The options described here are used mainly for debugging purposes, and in some cases to assist with recovery of severely damaged databases. There should be no reason to use them in a production database setup. They are listed here only for use by PostgreSQL system developers. Furthermore, these options might change or be removed in a future release without notice.</source>
          <target state="translated">ここで説明したオプションは主にデバッグ目的で使用され、場合によっては深刻な損傷を受けたデータベースの復旧を支援するために使用されます。実運用のデータベースの設定でこれらを使用する理由はありません。これらのオプションは、PostgreSQLシステムの開発者が使用するためだけにここに記載されています。さらに、これらのオプションは将来のリリースで予告なしに変更されたり削除されたりするかもしれません。</target>
        </trans-unit>
        <trans-unit id="f8dd3a92af0a56bfda8d9752b838ef4b2d6a4df2" translate="yes" xml:space="preserve">
          <source>The order 3501 might be among the billed or unbilled orders.</source>
          <target state="translated">オーダー3501は、課金されたオーダーと課金されていないオーダーの中に含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="abcd49a17f5a3270a489cdc6cf5f6ae4822bbd01" translate="yes" xml:space="preserve">
          <source>The order doesn't matter. It does not necessarily determine in which order the constraints are checked.</source>
          <target state="translated">順番は重要ではありません。制約がどの順番でチェックされるかは、必ずしも決定されません。</target>
        </trans-unit>
        <trans-unit id="4885441a3f0959533bfa66d30ac9b400042a2243" translate="yes" xml:space="preserve">
          <source>The order of evaluation of subexpressions is not defined. In particular, the inputs of an operator or function are not necessarily evaluated left-to-right or in any other fixed order.</source>
          <target state="translated">副式の評価の順序は定義されていません。特に、演算子や関数の入力は必ずしも左から右に評価されるわけではなく、その他の固定された順序で評価されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="89519eed893d527079231a8a6443c77bf1a65103" translate="yes" xml:space="preserve">
          <source>The order of the pairs is not significant (and may not be reproduced on output). Whitespace between pairs or around the &lt;code&gt;=&amp;gt;&lt;/code&gt; sign is ignored. Double-quote keys and values that include whitespace, commas, &lt;code&gt;=&lt;/code&gt;s or &lt;code&gt;&amp;gt;&lt;/code&gt;s. To include a double quote or a backslash in a key or value, escape it with a backslash.</source>
          <target state="translated">ペアの順序は重要ではありません（出力では再現されない場合があります）。ペア間または &lt;code&gt;=&amp;gt;&lt;/code&gt; 記号の前後の空白は無視されます。空白、カンマ、 &lt;code&gt;=&lt;/code&gt; sまたは &lt;code&gt;&amp;gt;&lt;/code&gt; s を含む二重引用符付きのキーと値。キーまたは値に二重引用符または円記号を含めるには、円記号でエスケープします。</target>
        </trans-unit>
        <trans-unit id="6a0d0d4551f2d45fd2b79524bceb16c2da137ff6" translate="yes" xml:space="preserve">
          <source>The ordering of the values in an enum type is the order in which the values were listed when the type was created. All standard comparison operators and related aggregate functions are supported for enums. For example:</source>
          <target state="translated">列挙型の値の順序は、型が作成されたときに値がリストされていた順序になります。すべての標準比較演算子と関連する集約関数は、列挙型でサポートされています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4a1c45805d8830616db8f03a352b425367265a0b" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the index column.</source>
          <target state="translated">序数とは、インデックス列の序数(左から右)の位置を指します。</target>
        </trans-unit>
        <trans-unit id="542906884bd50e7620583567769e2555be971b00" translate="yes" xml:space="preserve">
          <source>The ordinal number refers to the ordinal (left-to-right) position of the output column. This feature makes it possible to define an ordering on the basis of a column that does not have a unique name. This is never absolutely necessary because it is always possible to assign a name to an output column using the &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">序数は、出力列の序数（左から右）の位置を指します。この機能により、一意の名前を持たない列に基づいて順序を定義できます。 &lt;code&gt;AS&lt;/code&gt; 句を使用して出力列に名前を割り当てることが常に可能なため、これは絶対に必要なことではありません。</target>
        </trans-unit>
        <trans-unit id="b06b3bbd9847482f4b77272cbdd9dddfd2293b02" translate="yes" xml:space="preserve">
          <source>The ordinary qualified-column-name syntax &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;column_name&lt;/code&gt; can be understood as applying &lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;field selection&lt;/a&gt; to the composite value of the table's current row. (For efficiency reasons, it's not actually implemented that way.)</source>
          <target state="translated">通常の修飾列名構文 &lt;code&gt;table_name&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;column_name&lt;/code&gt; は、&lt;a href=&quot;sql-expressions#FIELD-SELECTION&quot;&gt;フィールド選択&lt;/a&gt;をテーブルの現在の行の複合値に適用することとして理解できます。（効率上の理由から、実際にはそのようには実装されていません。）</target>
        </trans-unit>
        <trans-unit id="26d29240df565151bc026ac25aff13ab3efc3c48" translate="yes" xml:space="preserve">
          <source>The origin node's LSN up to which data has been replicated.</source>
          <target state="translated">データがレプリケートされたオリジンノードのLSN。</target>
        </trans-unit>
        <trans-unit id="0c0890af1d3eba99328b2705ec2de494e2103157" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">その他の句は、オプションの演算子最適化句を指定します。それらの意味は、&lt;a href=&quot;https://www.postgresql.org/docs/12/xoper-optimization.html&quot;&gt;セクション37.15で&lt;/a&gt;詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="9473f0f0dfb8c5d74bfb5c710889c3c431764eb1" translate="yes" xml:space="preserve">
          <source>The other clauses specify optional operator optimization clauses. Their meaning is detailed in &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper-optimization.html&quot;&gt;Section 37.15&lt;/a&gt;.</source>
          <target state="translated">他の句は、オプションの演算子最適化句を指定します。それらの意味は&lt;a href=&quot;https://www.postgresql.org/docs/13/xoper-optimization.html&quot;&gt;セクション37.15で&lt;/a&gt;詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="968a2d78a8c8100f337e33a5ce08a9f2a42bbad9" translate="yes" xml:space="preserve">
          <source>The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see &lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;Section 19.11.2&lt;/a&gt; for details). The values that are chosen by &lt;code&gt;initdb&lt;/code&gt; are actually only written into the configuration file &lt;code&gt;postgresql.conf&lt;/code&gt; to serve as defaults when the server is started. If you remove these assignments from &lt;code&gt;postgresql.conf&lt;/code&gt; then the server will inherit the settings from its execution environment.</source>
          <target state="translated">他のロケールカテゴリは、ロケールカテゴリと同じ名前のサーバー構成パラメータを設定することにより、いつでも変更できます（詳細については、&lt;a href=&quot;runtime-config-client#RUNTIME-CONFIG-CLIENT-FORMAT&quot;&gt;セクション19.11.2&lt;/a&gt;を参照してください）。 &lt;code&gt;initdb&lt;/code&gt; によって選択された値は、実際にはサーバーの起動時にデフォルトとして機能するように構成ファイル &lt;code&gt;postgresql.conf&lt;/code&gt; にのみ書き込まれます。これらの割り当てを &lt;code&gt;postgresql.conf&lt;/code&gt; から削除すると、サーバーはその実行環境から設定を継承します。</target>
        </trans-unit>
        <trans-unit id="c995e27c615e98c0f723cb03133efd117f67f54f" translate="yes" xml:space="preserve">
          <source>The other locale settings &lt;a href=&quot;runtime-config-client#GUC-LC-MESSAGES&quot;&gt;lc_messages&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt; are not fixed per database and are not set by this command. If you want to make them the default for a specific database, you can use &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt;.</source>
          <target state="translated">その他のロケール設定&lt;a href=&quot;runtime-config-client#GUC-LC-MESSAGES&quot;&gt;lc_messages&lt;/a&gt;、&lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt;、&lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;、および&lt;a href=&quot;runtime-config-client#GUC-LC-TIME&quot;&gt;lc_time&lt;/a&gt;はデータベースごとに固定されておらず、このコマンドでは設定されません。それらを特定のデータベースのデフォルトにしたい場合は、 &lt;code&gt;ALTER DATABASE ... SET&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="4f628b39443abf4900d7c741215add2d55c377a2" translate="yes" xml:space="preserve">
          <source>The other required settings have default values that are sufficient for a basic setup.</source>
          <target state="translated">その他の必要な設定は、基本的な設定を行うのに十分な初期値が設定されています。</target>
        </trans-unit>
        <trans-unit id="37e3a8e885deb65cc32448cece3ed8b5de192c3e" translate="yes" xml:space="preserve">
          <source>The other three operators are defined in terms of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; in the obvious way, and must act consistently with them.</source>
          <target state="translated">他の3つの演算子は &lt;code&gt;=&lt;/code&gt; と &lt;code&gt;&amp;lt;&lt;/code&gt; の観点から明白な方法で定義されており、それらと一貫して動作する必要があります。</target>
        </trans-unit>
        <trans-unit id="cca1af5395645eeb86ba526f8d241c5ba5b41b07" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;Table F.23&lt;/a&gt;.</source>
          <target state="translated">出力列については、&lt;a href=&quot;pgstattuple#PGSTATAPPROX-COLUMNS&quot;&gt;表F.23で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="2061781f2ae71dd3ed97908a6bff9dc965e50b4d" translate="yes" xml:space="preserve">
          <source>The output columns are described in &lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;Table F.22&lt;/a&gt;.</source>
          <target state="translated">出力列については、&lt;a href=&quot;pgstattuple#PGSTATTUPLE-COLUMNS&quot;&gt;表F.22で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="a9d41f9345eb262fbbccef45f4cf925c1a6818ef" translate="yes" xml:space="preserve">
          <source>The output columns are:</source>
          <target state="translated">出力されるカラムは</target>
        </trans-unit>
        <trans-unit id="ddee20dbbcf56a7d470d5e18264fdb853ffab834" translate="yes" xml:space="preserve">
          <source>The output format of the date/time types can be set to one of the four styles ISO 8601, SQL (Ingres), traditional POSTGRES (Unix date format), or German. The default is the ISO format. (The SQL standard requires the use of the ISO 8601 format. The name of the &amp;ldquo;SQL&amp;rdquo; output format is a historical accident.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;Table 8.14&lt;/a&gt; shows examples of each output style. The output of the &lt;code&gt;date&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; types is generally only the date or time part in accordance with the given examples. However, the POSTGRES style outputs date-only values in ISO format.</source>
          <target state="translated">日付/時刻型の出力形式は、ISO 8601、SQL（Ingres）、従来のPOSTGRES（Unix日付形式）、またはドイツ語の4つのスタイルのいずれかに設定できます。デフォルトはISO形式です。（SQL標準では、ISO 8601形式を使用する必要があります。「SQL」出力形式の名前は歴史的な偶然です。）&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT-TABLE&quot;&gt;表8.14&lt;/a&gt;は、各出力スタイルの例を示しています。 &lt;code&gt;date&lt;/code&gt; と &lt;code&gt;time&lt;/code&gt; タイプの出力は、通常、与えられた例に従って日付または時刻の部分のみです。ただし、POSTGRESスタイルはISO形式で日付のみの値を出力します。</target>
        </trans-unit>
        <trans-unit id="ca0d537c6aa930d0ccd3e11ab06cbea4823708c4" translate="yes" xml:space="preserve">
          <source>The output format of the interval type can be set to one of the four styles &lt;code&gt;sql_standard&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;postgres_verbose&lt;/code&gt;, or &lt;code&gt;iso_8601&lt;/code&gt;, using the command &lt;code&gt;SET intervalstyle&lt;/code&gt;. The default is the &lt;code&gt;postgres&lt;/code&gt; format. &lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;Table 8.18&lt;/a&gt; shows examples of each output style.</source>
          <target state="translated">間隔タイプの出力フォーマットは、コマンド &lt;code&gt;SET intervalstyle&lt;/code&gt; を使用して、 &lt;code&gt;sql_standard&lt;/code&gt; 、 &lt;code&gt;postgres&lt;/code&gt; 、 &lt;code&gt;postgres_verbose&lt;/code&gt; 、または &lt;code&gt;iso_8601&lt;/code&gt; の4つのスタイルのいずれかに設定できます。デフォルトは &lt;code&gt;postgres&lt;/code&gt; 形式です。&lt;a href=&quot;datatype-datetime#INTERVAL-STYLE-OUTPUT-TABLE&quot;&gt;表8.18に&lt;/a&gt;、各出力スタイルの例を示します。</target>
        </trans-unit>
        <trans-unit id="46e4d541f5041111722fb3ba79a2c654be039359" translate="yes" xml:space="preserve">
          <source>The output is a multiline string, with one line per node in the binary tree within the page. Only those nodes that are not zero are printed. The so-called &quot;next&quot; pointer, which points to the next slot to be returned from the page, is also printed.</source>
          <target state="translated">出力は複数行の文字列で、ページ内のバイナリツリーのノードごとに1行ずつ出力されます。ゼロではないノードのみが出力されます。ページから返される次のスロットを指す、いわゆる &quot;next&quot; ポインタも印刷されます。</target>
        </trans-unit>
        <trans-unit id="ad08831002285835cd9adfadf104f64de7aa0e5d" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;command&lt;/code&gt;, similar to ordinary &amp;ldquo;back-tick&amp;rdquo; substitution.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; の出力。通常の「バックティック」置換に似ています。</target>
        </trans-unit>
        <trans-unit id="f5a340fab5cd2f5c7335b7c6ceb29826d0789ea6" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;pg_config --configure&lt;/code&gt; contains shell quotation marks so arguments with spaces are represented correctly. Therefore, using &lt;code&gt;eval&lt;/code&gt; is required for proper results.</source>
          <target state="translated">&lt;code&gt;pg_config --configure&lt;/code&gt; の出力にはシェル引用符が含まれているため、スペースを含む引数は正しく表現されます。したがって、適切な結果を得るには &lt;code&gt;eval&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a81f92d4917ee9ed4622690e19a83d472fca1d6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;iso_8601&lt;/code&gt; style matches the &amp;ldquo;format with designators&amp;rdquo; described in section 4.4.3.2 of the ISO 8601 standard.</source>
          <target state="translated">&lt;code&gt;iso_8601&lt;/code&gt; スタイルの出力は、ISO 8601規格のセクション4.4.3.2で説明されている「指定子付きのフォーマット」と一致します。</target>
        </trans-unit>
        <trans-unit id="2ff8c3f12c0cc1fd0eb9b2845008220be0844b33" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;DateStyle&lt;/a&gt; parameter was set to &lt;code&gt;ISO&lt;/code&gt;.</source>
          <target state="translated">出力 &lt;code&gt;postgres&lt;/code&gt; スタイルは、8.4以前のPostgreSQLのリリースの出力と一致する&lt;a href=&quot;runtime-config-client#GUC-DATESTYLE&quot;&gt;のDateStyleの&lt;/a&gt;パラメータに設定された &lt;code&gt;ISO&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1546f3a4ad8e76189b8c8e44c823160ec87aa0b6" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;postgres_verbose&lt;/code&gt; style matches the output of PostgreSQL releases prior to 8.4 when the &lt;code&gt;DateStyle&lt;/code&gt; parameter was set to non-&lt;code&gt;ISO&lt;/code&gt; output.</source>
          <target state="translated">出力 &lt;code&gt;postgres_verbose&lt;/code&gt; スタイルは、いつのPostgreSQLの出力は、8.4以前のリリースと一致する &lt;code&gt;DateStyle&lt;/code&gt; パラメータが非に設定した &lt;code&gt;ISO&lt;/code&gt; の出力。</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">出力されるはずです。</target>
        </trans-unit>
        <trans-unit id="7d18635316d58c0f1b2d1367a93ab0ee048d2342" translate="yes" xml:space="preserve">
          <source>The overall file layout is: open square bracket, one or more sets of curly braces each of which represents a catalog row, close square bracket. Write a comma after each closing curly brace.</source>
          <target state="translated">ファイル全体のレイアウトは次のようになります:開いた角括弧、1つ以上の中括弧のセット、それぞれがカタログの行を表し、閉じた角括弧。閉じた中括弧の後にはコンマを書きます。</target>
        </trans-unit>
        <trans-unit id="8de7f224fb0466b959b163b48657edcd9f526ad8" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can alter user mappings for that server for any user. Also, a user can alter a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部サーバーの所有者は、任意のユーザーのそのサーバーのユーザーマッピングを変更できます。また、サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権がユーザーに付与されている場合、ユーザーは自分のユーザー名のユーザーマッピングを変更できます。</target>
        </trans-unit>
        <trans-unit id="70e088bcc4a224d8f310f80a737853c522321de9" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can create user mappings for that server for any user. Also, a user can create a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部サーバーの所有者は、任意のユーザーのそのサーバーのユーザーマッピングを作成できます。また、サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権がユーザーに付与されている場合、ユーザーは自分のユーザー名のユーザーマッピングを作成できます。</target>
        </trans-unit>
        <trans-unit id="85f81248211a9e60d13a1c97f497ca0b1b6a21d0" translate="yes" xml:space="preserve">
          <source>The owner of a foreign server can drop user mappings for that server for any user. Also, a user can drop a user mapping for their own user name if &lt;code&gt;USAGE&lt;/code&gt; privilege on the server has been granted to the user.</source>
          <target state="translated">外部サーバーの所有者は、任意のユーザーのそのサーバーのユーザーマッピングを削除できます。また、サーバーに対する &lt;code&gt;USAGE&lt;/code&gt; 特権がユーザーに付与されている場合、ユーザーは自分のユーザー名のユーザーマッピングを削除できます。</target>
        </trans-unit>
        <trans-unit id="6963c00112713ecda93817baf7fc7475ab9e7155" translate="yes" xml:space="preserve">
          <source>The papal bull of February 1582 decreed that 10 days should be dropped from October 1582 so that 15 October should follow immediately after 4 October. This was observed in Italy, Poland, Portugal, and Spain. Other Catholic countries followed shortly after, but Protestant countries were reluctant to change, and the Greek Orthodox countries didn't change until the start of the 20th century. The reform was observed by Great Britain and its dominions (including what is now the USA) in 1752. Thus 2 September 1752 was followed by 14 September 1752. This is why Unix systems that have the &lt;code&gt;cal&lt;/code&gt; program produce the following:</source>
          <target state="translated">1582年2月の教皇牛は、1582年10月から10日を削除して、10月15日が10月4日の直後に続くようにすることを命じました。これはイタリア、ポーランド、ポルトガル、スペインで観察されました。他のカトリック諸国もその直後に続きましたが、プロテスタント諸国は変化することに消極的であり、ギリシャ正教会の国々は20世紀の初めまで変化しませんでした。改革は1752年にイギリスとその領土（現在はアメリカを含む）によって観察されました。したがって、1752年9月2日の後に1752年9月14日が続きました。これが、 &lt;code&gt;cal&lt;/code&gt; プログラムを備えたUnixシステムが以下を生成する理由です。</target>
        </trans-unit>
        <trans-unit id="265188275c6e5e56d9f827410bd00598d6ffb2ea" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt; enables monitoring of the current command being executed by any server process.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-ACTIVITIES&quot;&gt;track_activities&lt;/a&gt;は、任意のサーバープロセスによって実行されている現在のコマンドの監視を有効にします。</target>
        </trans-unit>
        <trans-unit id="e1be1796cec7a4cb2472b6d31337e6a73b1f4697" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; controls whether statistics are collected about table and index accesses.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt;は、テーブルおよびインデックスアクセスに関する統計を収集するかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="c3e68d3468b41bd94198c06d139a59af78cfd7be" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functions&lt;/a&gt; enables tracking of usage of user-defined functions.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-FUNCTIONS&quot;&gt;track_functionsを&lt;/a&gt;使用すると、ユーザー定義関数の使用状況を追跡できます。</target>
        </trans-unit>
        <trans-unit id="8df18f4279a1a3adf31a5aebfa3bc87053f75fc7" translate="yes" xml:space="preserve">
          <source>The parameter &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; enables monitoring of block read and write times.</source>
          <target state="translated">パラメータ&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timingを&lt;/a&gt;使用すると、ブロックの読み取り時間と書き込み時間を監視できます。</target>
        </trans-unit>
        <trans-unit id="fc99094ae896ae637595cea62c377dc56ce6f9fd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;count&lt;/code&gt; specifies the maximum number of rows to return, while &lt;code&gt;start&lt;/code&gt; specifies the number of rows to skip before starting to return rows. When both are specified, &lt;code&gt;start&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;count&lt;/code&gt; rows to be returned.</source>
          <target state="translated">パラメーター &lt;code&gt;count&lt;/code&gt; は、返す最大行数を指定し、 &lt;code&gt;start&lt;/code&gt; は、行の戻りを開始する前にスキップする行数を指定します。両方を指定すると、返される &lt;code&gt;count&lt;/code&gt; 行のカウントを開始する前に、 &lt;code&gt;start&lt;/code&gt; 行がスキップされます。</target>
        </trans-unit>
        <trans-unit id="d547546da964747acd19cdd9eb1f2bdf8c4f57e8" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;nulls&lt;/code&gt;&lt;/em&gt; determines whether null values should be included in the output. If true, null values in columns are represented as:</source>
          <target state="translated">パラメータ&lt;em&gt; &lt;code&gt;nulls&lt;/code&gt; &lt;/em&gt;は、null値を出力に含めるかどうかを決定します。trueの場合、列のnull値は次のように表されます。</target>
        </trans-unit>
        <trans-unit id="0b194e705f492d2a9e697965a54eb7bc8ec38435" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;&lt;code&gt;targetns&lt;/code&gt;&lt;/em&gt; specifies the desired XML namespace of the result. If no particular namespace is wanted, an empty string should be passed.</source>
          <target state="translated">パラメータ&lt;em&gt; &lt;code&gt;targetns&lt;/code&gt; &lt;/em&gt;は、結果の目的のXML名前空間を指定します。特定の名前空間が不要な場合は、空の文字列を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="9da16630f92a321b59e356eb1f16f45959c31e24" translate="yes" xml:space="preserve">
          <source>The parameter data type(s) of the function.</source>
          <target state="translated">関数のパラメータデータ型。</target>
        </trans-unit>
        <trans-unit id="5d10e331ebaa600753d0a6fe423faa9e38a0555a" translate="yes" xml:space="preserve">
          <source>The parameter is the name of a table. The result is a set of records, with one row for each locked row within the table. The output columns are shown in &lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;Table F.20&lt;/a&gt;.</source>
          <target state="translated">パラメータはテーブルの名前です。結果はレコードのセットで、テーブル内のロックされた行ごとに1つの行があります。出力列を&lt;a href=&quot;pgrowlocks#PGROWLOCKS-COLUMNS&quot;&gt;表F.20に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="2c2a6968b73a82456119add43eff37f88e4a3336" translate="yes" xml:space="preserve">
          <source>The parameter name</source>
          <target state="translated">パラメータ名</target>
        </trans-unit>
        <trans-unit id="10634e221a9f53cda3c36547bc9c020dce985fe4" translate="yes" xml:space="preserve">
          <source>The parameter symbols used to replace constants in representative query texts start from the next number after the highest &lt;code&gt;$&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; parameter in the original query text, or &lt;code&gt;$1&lt;/code&gt; if there was none. It's worth noting that in some cases there may be hidden parameter symbols that affect this numbering. For example, PL/pgSQL uses hidden parameter symbols to insert values of function local variables into queries, so that a PL/pgSQL statement like &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; would have representative text like &lt;code&gt;SELECT i + $2&lt;/code&gt;.</source>
          <target state="translated">代表的なクエリテキストの定数を置き換えるために使用されるパラメーターシンボルは、元のクエリテキストの最も高い &lt;code&gt;$&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; パラメーターの後の次の数字から始まります。ない場合は &lt;code&gt;$1&lt;/code&gt; です。場合によっては、この番号付けに影響を与える非表示のパラメーターシンボルが存在する可能性があることに注意してください。たとえば、PL / pgSQLは非表示のパラメーターシンボルを使用して関数のローカル変数の値をクエリに挿入するため、 &lt;code&gt;SELECT i + 1 INTO j&lt;/code&gt; ようなPL / pgSQLステートメントは &lt;code&gt;SELECT i + $2&lt;/code&gt; ような代表的なテキストになります。</target>
        </trans-unit>
        <trans-unit id="61c677b727193bb37a9911ff1962107228c69d5b" translate="yes" xml:space="preserve">
          <source>The parameter value</source>
          <target state="translated">パラメータの値</target>
        </trans-unit>
        <trans-unit id="bbcaadaf51c94b64fefad474400e1f3834e2ed35" translate="yes" xml:space="preserve">
          <source>The parameters can appear in any order, not only that illustrated above, and most are optional. You must register two or more functions (using &lt;code&gt;CREATE FUNCTION&lt;/code&gt;) before defining the type. The support functions &lt;code&gt;input_function&lt;/code&gt; and &lt;code&gt;output_function&lt;/code&gt; are required, while the functions &lt;code&gt;receive_function&lt;/code&gt;, &lt;code&gt;send_function&lt;/code&gt;, &lt;code&gt;type_modifier_input_function&lt;/code&gt;, &lt;code&gt;type_modifier_output_function&lt;/code&gt; and &lt;code&gt;analyze_function&lt;/code&gt; are optional. Generally these functions have to be coded in C or another low-level language.</source>
          <target state="translated">パラメータは、上に示したものだけでなく、任意の順序で指定でき、ほとんどがオプションです。タイプを定義する前に、（ &lt;code&gt;CREATE FUNCTION&lt;/code&gt; を使用して）2つ以上の関数を登録する必要があります。サポート関数 &lt;code&gt;input_function&lt;/code&gt; および &lt;code&gt;output_function&lt;/code&gt; は必須ですが、関数 &lt;code&gt;receive_function&lt;/code&gt; 、 &lt;code&gt;send_function&lt;/code&gt; 、 &lt;code&gt;type_modifier_input_function&lt;/code&gt; 、 &lt;code&gt;type_modifier_output_function&lt;/code&gt; および &lt;code&gt;analyze_function&lt;/code&gt; はオプションです。一般に、これらの関数はCまたは別の低水準言語でコーディングする必要があります。</target>
        </trans-unit>
        <trans-unit id="35c28a20bb52660d5ea22014191009de5ae11925" translate="yes" xml:space="preserve">
          <source>The parameters for the &lt;code&gt;MOVE&lt;/code&gt; command are identical to those of the &lt;code&gt;FETCH&lt;/code&gt; command; refer to &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for details on syntax and usage.</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; コマンドのパラメーターは、 &lt;code&gt;FETCH&lt;/code&gt; コマンドのパラメーターと同じです。構文と使用法の詳細については、&lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c486bfa67e493a85ca76bb0a5dfe71e780089bca" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;CREATE AGGREGATE&lt;/code&gt; can be written in any order, not just the order illustrated above.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; のパラメーターは、上記の順序だけでなく、任意の順序で書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="d0f868092f1804769e10c18a42faa0f07b1980df" translate="yes" xml:space="preserve">
          <source>The parameters representing table and field names are copied as-is into the SQL queries that &lt;code&gt;connectby&lt;/code&gt; generates internally. Therefore, include double quotes if the names are mixed-case or contain special characters. You may also need to schema-qualify the table name.</source>
          <target state="translated">テーブル名とフィールド名を表すパラメーターは、 &lt;code&gt;connectby&lt;/code&gt; が内部で生成するSQLクエリにそのままコピーされます。したがって、名前が大/小文字が混在している場合や特殊文字が含まれている場合は、二重引用符を含めてください。テーブル名をスキーマ修飾する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="7230bb5c0f71b8c1dd5a14e1c76f97c166b31063" translate="yes" xml:space="preserve">
          <source>The parentheses are required here to show that &lt;code&gt;compositecol&lt;/code&gt; is a column name not a table name, or that &lt;code&gt;mytable&lt;/code&gt; is a table name not a schema name in the second case.</source>
          <target state="translated">ここで括弧は、 &lt;code&gt;compositecol&lt;/code&gt; がテーブル名ではなく列名であること、または2番目のケースでは &lt;code&gt;mytable&lt;/code&gt; がスキーマ名ではなくテーブル名であることを示すために必要です。</target>
        </trans-unit>
        <trans-unit id="3872d508fa039522a5d3058284138f504197106f" translate="yes" xml:space="preserve">
          <source>The parentheses in the last example are required. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more about arrays.</source>
          <target state="translated">最後の例の括弧は必須です。配列の詳細については、&lt;a href=&quot;arrays&quot;&gt;セクション8.15&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba38ce516ae1d7c833e7896243109df28d306a9d" translate="yes" xml:space="preserve">
          <source>The parentheses or brackets indicate whether the lower and upper bounds are exclusive or inclusive, as described previously. Notice that the final pattern is &lt;code&gt;empty&lt;/code&gt;, which represents an empty range (a range that contains no points).</source>
          <target state="translated">括弧または括弧は、前述のように、下限と上限が排他的であるか包含的であるかを示します。最終的なパターンは &lt;code&gt;empty&lt;/code&gt; であることに注意してください。これは、空の範囲（ポイントを含まない範囲）を表します。</target>
        </trans-unit>
        <trans-unit id="09b446449a4319a7ef9115b3be9989109d17ce7e" translate="yes" xml:space="preserve">
          <source>The parser has to check the query string (which arrives as plain text) for valid syntax. If the syntax is correct a &lt;em&gt;parse tree&lt;/em&gt; is built up and handed back; otherwise an error is returned. The parser and lexer are implemented using the well-known Unix tools bison and flex.</source>
          <target state="translated">パーサーは、有効な構文がないか（プレーンテキストとして到着する）クエリ文字列をチェックする必要があります。構文が正しければ、&lt;em&gt;解析ツリー&lt;/em&gt;が作成されて戻されます。そうでない場合、エラーが返されます。パーサーとレクサーは、有名なUnixツールのbisonとflexを使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="6ff5674ed423bd0fd40e474001e355555798b1f1" translate="yes" xml:space="preserve">
          <source>The parser initially marks the constants as being of type &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; respectively. There is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator in the system catalogs, but there is a &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator. The query will therefore succeed if a cast from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt; is available and is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which in fact it is. The parser will apply the implicit cast and resolve the query as if it had been written</source>
          <target state="translated">パーサーは最初に定数をそれぞれ &lt;code&gt;integer&lt;/code&gt; 型と &lt;code&gt;numeric&lt;/code&gt; 型としてマークします。システムカタログには &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 演算子はありませんが、 &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 演算子はあります。したがって、 &lt;code&gt;integer&lt;/code&gt; から &lt;code&gt;numeric&lt;/code&gt; へのキャストが利用可能で、 &lt;code&gt;AS IMPLICIT&lt;/code&gt; としてマークされている場合、クエリは成功します &amp;mdash;実際にはそうです。パーサーは暗黙的なキャストを適用し、クエリが書き込まれたかのように解決します</target>
        </trans-unit>
        <trans-unit id="25f13c18d68a86fdbefd4291a356d75813cdb2e5" translate="yes" xml:space="preserve">
          <source>The parser is defined in the file &lt;code&gt;gram.y&lt;/code&gt; and consists of a set of &lt;em&gt;grammar rules&lt;/em&gt; and &lt;em&gt;actions&lt;/em&gt; that are executed whenever a rule is fired. The code of the actions (which is actually C code) is used to build up the parse tree.</source>
          <target state="translated">パーサーは &lt;code&gt;gram.y&lt;/code&gt; ファイルで定義されており、一連の&lt;em&gt;文法規則&lt;/em&gt;と、規則が実行されるたびに実行される&lt;em&gt;アクション&lt;/em&gt;で構成されています。アクションのコード（実際にはCコードです）は、解析ツリーを構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1857339fc15ab225bd01ccd9d926ca70975b0fc9" translate="yes" xml:space="preserve">
          <source>The parser learns from the &lt;code&gt;pg_cast&lt;/code&gt; catalog that &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary-compatible, meaning that one can be passed to a function that accepts the other without doing any physical conversion. Therefore, no type conversion call is really inserted in this case.</source>
          <target state="translated">パーサーは &lt;code&gt;pg_cast&lt;/code&gt; カタログから、 &lt;code&gt;text&lt;/code&gt; と &lt;code&gt;varchar&lt;/code&gt; がバイナリ互換であることを学習します。つまり、物理的な変換を行わずに、一方を他方を受け入れる関数に渡すことができます。したがって、この場合、タイプ変換呼び出しは実際には挿入されません。</target>
        </trans-unit>
        <trans-unit id="0e756c19d42be08cb71cc09834d6f8f8f843f91e" translate="yes" xml:space="preserve">
          <source>The parser stage creates a parse tree using only fixed rules about the syntactic structure of SQL. It does not make any lookups in the system catalogs, so there is no possibility to understand the detailed semantics of the requested operations. After the parser completes, the &lt;em&gt;transformation process&lt;/em&gt; takes the tree handed back by the parser as input and does the semantic interpretation needed to understand which tables, functions, and operators are referenced by the query. The data structure that is built to represent this information is called the &lt;em&gt;query tree&lt;/em&gt;.</source>
          <target state="translated">パーサーステージは、SQLの構文構造に関する固定ルールのみを使用して解析ツリーを作成します。システムカタログでルックアップを行わないため、要求された操作の詳細なセマンティクスを理解することはできません。パーサーが完了すると、&lt;em&gt;変換プロセス&lt;/em&gt;はパーサーから渡されたツリーを入力として受け取り、クエリによって参照されるテーブル、関数、および演算子を理解するために必要なセマンティック解釈を行います。この情報を表すために構築されたデータ構造は、&lt;em&gt;クエリツリー&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="ebdbb42aa00d24e0d513d01a8c9b666b615ba1dd" translate="yes" xml:space="preserve">
          <source>The parser's notion of a &amp;ldquo;letter&amp;rdquo; is determined by the database's locale setting, specifically &lt;code&gt;lc_ctype&lt;/code&gt;. Words containing only the basic ASCII letters are reported as a separate token type, since it is sometimes useful to distinguish them. In most European languages, token types &lt;code&gt;word&lt;/code&gt; and &lt;code&gt;asciiword&lt;/code&gt; should be treated alike.</source>
          <target state="translated">パーサーの「文字」の概念は、データベースのロケール設定、具体的には &lt;code&gt;lc_ctype&lt;/code&gt; によって決まります。基本的なASCII文字のみを含む単語は、区別するのに役立つ場合があるため、別のトークンタイプとして報告されます。ほとんどのヨーロッパ言語では、トークンタイプ &lt;code&gt;word&lt;/code&gt; と &lt;code&gt;asciiword&lt;/code&gt; は同じように扱う必要があります。</target>
        </trans-unit>
        <trans-unit id="9c43fc6c8c7c3f14d277b633b89dfade64caf03b" translate="yes" xml:space="preserve">
          <source>The part of PostgreSQL that is devoted to determining (&lt;em&gt;planning&lt;/em&gt;) the most efficient way to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;. Also known as &lt;em&gt;query optimizer&lt;/em&gt;, &lt;em&gt;optimizer&lt;/em&gt;, or simply &lt;em&gt;planner&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;クエリ&lt;/a&gt;を実行するための最も効率的な方法を決定（&lt;em&gt;計画&lt;/em&gt;）することに専念しているPostgreSQLの部分。&lt;em&gt;クエリオプティマイザー&lt;/em&gt;、&lt;em&gt;オプティマイザー&lt;/em&gt;、または単に&lt;em&gt;プランナーと&lt;/em&gt;も呼ばれ&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a4e5a431eb644b141f3790b8cfbc5fd53514f52" translate="yes" xml:space="preserve">
          <source>The partial transaction isolation provided by Read Committed mode is adequate for many applications, and this mode is fast and simple to use; however, it is not sufficient for all cases. Applications that do complex queries and updates might require a more rigorously consistent view of the database than Read Committed mode provides.</source>
          <target state="translated">Read Committedモードで提供される部分的なトランザクションの分離は多くのアプリケーションに適しており、このモードは高速で使いやすいですが、すべての場合に十分ではありません。複雑なクエリや更新を行うアプリケーションでは、Read Committedモードが提供するよりも厳密に一貫したデータベースの表示が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="eb9b101fa3ff04c41a301e2ea58c51b731736d02" translate="yes" xml:space="preserve">
          <source>The partition bound specification for a new partition. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on the syntax of the same.</source>
          <target state="translated">新しいパーティションのパーティションバインド仕様。構文の詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a843f1857d3445c37bfb25c214ac7c60e2eda3b2" translate="yes" xml:space="preserve">
          <source>The password is always stored encrypted in the system catalogs. The &lt;code&gt;ENCRYPTED&lt;/code&gt; keyword has no effect, but is accepted for backwards compatibility. The method of encryption is determined by the configuration parameter &lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;. If the presented password string is already in MD5-encrypted or SCRAM-encrypted format, then it is stored as-is regardless of &lt;code&gt;password_encryption&lt;/code&gt; (since the system cannot decrypt the specified encrypted password string, to encrypt it in a different format). This allows reloading of encrypted passwords during dump/restore.</source>
          <target state="translated">パスワードは常に暗号化されてシステムカタログに保存されます。 &lt;code&gt;ENCRYPTED&lt;/code&gt; キーワードは効果がありませんが、後方互換性のために受け入れられています。暗号化の方法は、構成パラメーター&lt;a href=&quot;runtime-config-connection#GUC-PASSWORD-ENCRYPTION&quot;&gt;password_encryption&lt;/a&gt;によって決定されます。提示されたパスワード文字列がすでにMD5暗号化またはSCRAM暗号化形式である場合、それは &lt;code&gt;password_encryption&lt;/code&gt; に関係なくそのまま保存されます（指定された暗号化パスワード文字列を復号化して別の形式で暗号化することはできないため）。これにより、ダンプ/復元中に暗号化されたパスワードをリロードできます。</target>
        </trans-unit>
        <trans-unit id="d6a56dd735da3ef3f125939acf3298322bea99f6" translate="yes" xml:space="preserve">
          <source>The path at your site might be different. Contact your site administrator or check the installation instructions to correct the situation.</source>
          <target state="translated">ご利用のサイトのパスが異なる場合があります。サイト管理者に連絡するか、インストール方法を確認して修正してください。</target>
        </trans-unit>
        <trans-unit id="ae4a259e6f096215a3bc76dbbbf4ab5a1fa7063f" translate="yes" xml:space="preserve">
          <source>The path expression contains &lt;code&gt;type()&lt;/code&gt; or &lt;code&gt;size()&lt;/code&gt; methods that return the type and the number of elements in the array, respectively.</source>
          <target state="translated">パス式には、配列のタイプと要素数をそれぞれ返す &lt;code&gt;type()&lt;/code&gt; または &lt;code&gt;size()&lt;/code&gt; メソッドが含まれています。</target>
        </trans-unit>
        <trans-unit id="665f879c5dd1bad744ce39b38be0ec7bfa475f6e" translate="yes" xml:space="preserve">
          <source>The path name of the input or output file. An input file name can be an absolute or relative path, but an output file name must be an absolute path. Windows users might need to use an &lt;code&gt;E''&lt;/code&gt; string and double any backslashes used in the path name.</source>
          <target state="translated">入力ファイルまたは出力ファイルのパス名。入力ファイル名は絶対パスまたは相対パスにすることができますが、出力ファイル名は絶対パスでなければなりません。Windowsユーザーは、 &lt;code&gt;E''&lt;/code&gt; 文字列を使用し、パス名に使用されるバックスラッシュを2倍にする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="acfece2d4d4a40c54bd9f721a413e8f8e6ea9b4c" translate="yes" xml:space="preserve">
          <source>The pattern characters &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;G&lt;/code&gt; represent the sign, currency symbol, decimal point, and thousands separator characters defined by the current locale (see &lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;lc_monetary&lt;/a&gt; and &lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numeric&lt;/a&gt;). The pattern characters period and comma represent those exact characters, with the meanings of decimal point and thousands separator, regardless of locale.</source>
          <target state="translated">パターン文字 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;L&lt;/code&gt; 、 &lt;code&gt;D&lt;/code&gt; 、および &lt;code&gt;G&lt;/code&gt; は、現在のロケールで定義されている符号、通貨記号、小数点、および桁区切り記号を&lt;a href=&quot;runtime-config-client#GUC-LC-MONETARY&quot;&gt;表し&lt;/a&gt;ます（lc_monetaryおよび&lt;a href=&quot;runtime-config-client#GUC-LC-NUMERIC&quot;&gt;lc_numericを&lt;/a&gt;参照）。パターン文字のピリオドとコンマは、ロケールに関係なく、小数点と3桁ごとの区切り記号の意味を持つこれらの正確な文字を表します。</target>
        </trans-unit>
        <trans-unit id="0f3ba6e11e445232d30834cd144281a86bebafa9" translate="yes" xml:space="preserve">
          <source>The pattern matching operators of all three kinds do not support nondeterministic collations. If required, apply a different collation to the expression to work around this limitation.</source>
          <target state="translated">3種類すべてのパターンマッチング演算子は、非決定的な照合をサポートしていません。必要であれば、この制限を回避するために、式に別の照合を適用してください。</target>
        </trans-unit>
        <trans-unit id="53ad7762f98479cbca28b8363660cbfe1cf95173" translate="yes" xml:space="preserve">
          <source>The payload of the notifications consists of the table name, a letter to indicate which type of operation was performed, and column name/value pairs for primary key columns. Each part is separated from the next by a comma. For ease of parsing using regular expressions, table and column names are always wrapped in double quotes, and data values are always wrapped in single quotes. Embedded quotes are doubled.</source>
          <target state="translated">通知のペイロードは、テーブル名、どのタイプの操作が実行されたかを示す文字、主キーカラムのカラム名/値のペアで構成される。各部分はカンマで区切られています。正規表現を使用した解析を容易にするために、テーブル名とカラム名は常に二重引用符で、データ値は常に一重引用符で囲まれています。埋め込み引用符は2倍になります。</target>
        </trans-unit>
        <trans-unit id="99b6bf90a9bb8e6d618127a1a2c46cd208469261" translate="yes" xml:space="preserve">
          <source>The peer authentication method works by obtaining the client's operating system user name from the kernel and using it as the allowed database user name (with optional user name mapping). This method is only supported on local connections.</source>
          <target state="translated">ピア認証方法は、クライアントのオペレーティングシステムのユーザ名をカーネルから取得し、それを許可されたデータベースのユーザ名として使用することで動作します (オプションのユーザ名マッピングを使用します)。この方法はローカル接続でのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="919e0066d8303b60f8d9dce39383d269124b1827" translate="yes" xml:space="preserve">
          <source>The per-index statistics are particularly useful to determine which indexes are being used and how effective they are.</source>
          <target state="translated">特にインデックスあたりの統計は、どのインデックスが使われているのか、どの程度の効果があるのかを把握するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="2b32037bdcf53d4293fda5e00a43bb07b50f376a" translate="yes" xml:space="preserve">
          <source>The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the &lt;code&gt;seg&lt;/code&gt; column; see the script &lt;code&gt;sort-segments.pl&lt;/code&gt; for an example.</source>
          <target state="translated">Rツリーインデックスのパフォーマンスは、入力値の初期順序に大きく依存します。入力テーブルを &lt;code&gt;seg&lt;/code&gt; 列でソートすると非常に役立つ場合があります。例については、スクリプト &lt;code&gt;sort-segments.pl&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="794af340a68964153b03ef2b6d22753d285cf9d8" translate="yes" xml:space="preserve">
          <source>The period (&lt;code&gt;.&lt;/code&gt;) is used in numeric constants, and to separate schema, table, and column names.</source>
          <target state="translated">ピリオド（ &lt;code&gt;.&lt;/code&gt; ）は数値定数で使用され、スキーマ、テーブル、列の名前を区切るために使用されます。</target>
        </trans-unit>
        <trans-unit id="1dd06a0691afe3884d57662cd23df0c2e7cc6503" translate="yes" xml:space="preserve">
          <source>The pg_config utility prints configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries.</source>
          <target state="translated">pg_configユーティリティは、現在インストールされているバージョンのPostgreSQLの設定パラメータを表示します。これは例えば、必要なヘッダファイルやライブラリを見つけるのを容易にするためにPostgreSQLにインターフェースを提供したいソフトウェアパッケージが使用することを意図しています。</target>
        </trans-unit>
        <trans-unit id="38257de71aaf3c94498314a3023e95f97988a3ee" translate="yes" xml:space="preserve">
          <source>The phenomena which are prohibited at various levels are:</source>
          <target state="translated">様々なレベルで禁止されている現象は</target>
        </trans-unit>
        <trans-unit id="23f998eae14382a70d2324fb449ffb907b06c285" translate="yes" xml:space="preserve">
          <source>The phrases &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;ILIKE&lt;/code&gt;, &lt;code&gt;NOT LIKE&lt;/code&gt;, and &lt;code&gt;NOT ILIKE&lt;/code&gt; are generally treated as operators in PostgreSQL syntax; for example they can be used in &lt;code&gt;expression&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt; ANY (&lt;code&gt;subquery&lt;/code&gt;) constructs, although an &lt;code&gt;ESCAPE&lt;/code&gt; clause cannot be included there. In some obscure cases it may be necessary to use the underlying operator names instead.</source>
          <target state="translated">フレーズ &lt;code&gt;LIKE&lt;/code&gt; 、 &lt;code&gt;ILIKE&lt;/code&gt; 、 &lt;code&gt;NOT LIKE&lt;/code&gt; 、および &lt;code&gt;NOT ILIKE&lt;/code&gt; が、一般的にPostgreSQLの構文で演算子として扱われます。たとえば、 &lt;code&gt;ESCAPE&lt;/code&gt; 句を含めることはできませんが、 &lt;code&gt;expression&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; ANY（ &lt;code&gt;subquery&lt;/code&gt; ）構造で使用できます。あいまいな場合には、代わりに基になる演算子名を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="eb2bc77065c28244748a514edbbf72d360f29dfc" translate="yes" xml:space="preserve">
          <source>The physical location of the row version within its table. Note that although the &lt;code&gt;ctid&lt;/code&gt; can be used to locate the row version very quickly, a row's &lt;code&gt;ctid&lt;/code&gt; will change if it is updated or moved by &lt;code&gt;VACUUM FULL&lt;/code&gt;. Therefore &lt;code&gt;ctid&lt;/code&gt; is useless as a long-term row identifier. A primary key should be used to identify logical rows.</source>
          <target state="translated">テーブル内の行バージョンの物理的な場所。 &lt;code&gt;ctid&lt;/code&gt; を使用して行バージョンをすばやく見つけることができますが、行の &lt;code&gt;ctid&lt;/code&gt; は、 &lt;code&gt;VACUUM FULL&lt;/code&gt; によって更新または移動されると変更されることに注意してください。したがって、 &lt;code&gt;ctid&lt;/code&gt; は長期的な行識別子としては役に立ちません。論理行を識別するには、主キーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ed43e04d92b420464b4279a7468ab8888b8672c6" translate="yes" xml:space="preserve">
          <source>The planner assumes that the two conditions are independent, so that the individual selectivities of the clauses can be multiplied together:</source>
          <target state="translated">プランナーは、2つの条件が独立していることを前提としているので、節の個々の選択性を掛け合わせることができます。</target>
        </trans-unit>
        <trans-unit id="5f8b19a5896d87add8af3e241d28d22aabc60ce5" translate="yes" xml:space="preserve">
          <source>The planner cannot automatically determine whether a user-defined function or aggregate is parallel safe, parallel restricted, or parallel unsafe, because this would require predicting every operation which the function could possibly perform. In general, this is equivalent to the Halting Problem and therefore impossible. Even for simple functions where it could conceivably be done, we do not try, since this would be expensive and error-prone. Instead, all user-defined functions are assumed to be parallel unsafe unless otherwise marked. When using &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; or &lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;, markings can be set by specifying &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;, or &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; as appropriate. When using &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;, the &lt;code&gt;PARALLEL&lt;/code&gt; option can be specified with &lt;code&gt;SAFE&lt;/code&gt;, &lt;code&gt;RESTRICTED&lt;/code&gt;, or &lt;code&gt;UNSAFE&lt;/code&gt; as the corresponding value.</source>
          <target state="translated">関数が実行する可能性のあるすべての操作を予測する必要があるため、プランナはユーザー定義関数または集計が並列安全、並列制限、または並列安全でないかどうかを自動的に判断できません。一般に、これは停止問題と同等であり、したがって不可能です。実行できると思われる単純な関数であっても、コストがかかり、エラーが発生しやすいため、試さないでください。代わりに、特に明記されていない限り、すべてのユーザー定義関数は並列安全ではないと見なされます。&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;または&lt;a href=&quot;sql-alterfunction&quot;&gt;ALTER FUNCTION&lt;/a&gt;を使用する場合、 &lt;code&gt;PARALLEL SAFE&lt;/code&gt; 、 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; 、または &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; を適切に指定することにより、マーキングを設定できます。使用する場合&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;、 &lt;code&gt;PARALLEL&lt;/code&gt; オプションは、対応する値として &lt;code&gt;SAFE&lt;/code&gt; 、 &lt;code&gt;RESTRICTED&lt;/code&gt; 、または &lt;code&gt;UNSAFE&lt;/code&gt; を使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="9b371bcb4f76e8388ab2f98830da7c42b56f6e59" translate="yes" xml:space="preserve">
          <source>The planner classifies operations involved in a query as either &lt;em&gt;parallel safe&lt;/em&gt;, &lt;em&gt;parallel restricted&lt;/em&gt;, or &lt;em&gt;parallel unsafe&lt;/em&gt;. A parallel safe operation is one which does not conflict with the use of parallel query. A parallel restricted operation is one which cannot be performed in a parallel worker, but which can be performed in the leader while parallel query is in use. Therefore, parallel restricted operations can never occur below a &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node, but can occur elsewhere in a plan which contains such a node. A parallel unsafe operation is one which cannot be performed while parallel query is in use, not even in the leader. When a query contains anything which is parallel unsafe, parallel query is completely disabled for that query.</source>
          <target state="translated">プランナは、クエリに関連する操作を、&lt;em&gt;並列セーフ&lt;/em&gt;、&lt;em&gt;並列制限&lt;/em&gt;、または&lt;em&gt;並列アンセーフの&lt;/em&gt;いずれかに分類します。並列安全操作は、並列クエリの使用と競合しない操作です。並列制限付き操作は、並列ワーカーでは実行できませんが、並列クエリの使用中にリーダーで実行できる操作です。したがって、 &lt;code&gt;Gather&lt;/code&gt; または &lt;code&gt;Gather Merge&lt;/code&gt; の下では、並行して制限された操作が発生することはありません。ノードですが、そのようなノードを含むプランの他の場所で発生する可能性があります。並列の安全でない操作とは、並列クエリが使用されている間は実行できず、リーダーでさえ実行できない操作です。クエリに並列で安全でないものが含まれている場合、そのクエリの並列クエリは完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="41ec537c1145f33dc399ea4d0d8e72c677f37799" translate="yes" xml:space="preserve">
          <source>The planner estimates the selectivity for each condition individually, arriving at the same 1% estimates as above. Then it assumes that the conditions are independent, and so it multiplies their selectivities, producing a final selectivity estimate of just 0.01%. This is a significant underestimate, as the actual number of rows matching the conditions (100) is two orders of magnitude higher.</source>
          <target state="translated">プランナーは,各条件についての選択率を個別に推定し,上記と同じ1%の推定値に到達する.そして、条件が独立していると仮定して、それらの選択率を掛け合わせ、最終的な選択率の推定値はわずか0.01%になります。条件にマッチする実際の行の数(100)は2桁高いので、これはかなりの過小評価です。</target>
        </trans-unit>
        <trans-unit id="12ef35e8963b60e1a1f66c8c5c86ede0e85c0b68" translate="yes" xml:space="preserve">
          <source>The planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for the operator &lt;code&gt;&amp;lt;&lt;/code&gt; in &lt;code&gt;pg_operator&lt;/code&gt;. This is held in the column &lt;code&gt;oprrest&lt;/code&gt;, and the entry in this case is &lt;code&gt;scalarltsel&lt;/code&gt;. The &lt;code&gt;scalarltsel&lt;/code&gt; function retrieves the histogram for &lt;code&gt;unique1&lt;/code&gt; from &lt;code&gt;pg_statistic&lt;/code&gt;. For manual queries it is more convenient to look in the simpler &lt;code&gt;pg_stats&lt;/code&gt; view:</source>
          <target state="translated">プランナーは調べ &lt;code&gt;WHERE&lt;/code&gt; オペレータのための選択機能アップ条項の条件とルックス &lt;code&gt;&amp;lt;&lt;/code&gt; 中 &lt;code&gt;pg_operator&lt;/code&gt; 。これは列 &lt;code&gt;oprrest&lt;/code&gt; に保持され、この場合のエントリは &lt;code&gt;scalarltsel&lt;/code&gt; です。 &lt;code&gt;scalarltsel&lt;/code&gt; の機能は、ヒストグラム取得 &lt;code&gt;unique1&lt;/code&gt; から &lt;code&gt;pg_statistic&lt;/code&gt; 。手動クエリの場合は、より単純な &lt;code&gt;pg_stats&lt;/code&gt; ビューを調べるほうが便利です。</target>
        </trans-unit>
        <trans-unit id="55eece76171cb5150093319bc0d23d3c3262a30e" translate="yes" xml:space="preserve">
          <source>The planner examines the condition and determines the selectivity of this clause to be 1%. By comparing this estimate and the actual number of rows, we see that the estimate is very accurate (in fact exact, as the table is very small). Changing the &lt;code&gt;WHERE&lt;/code&gt; condition to use the &lt;code&gt;b&lt;/code&gt; column, an identical plan is generated. But observe what happens if we apply the same condition on both columns, combining them with &lt;code&gt;AND&lt;/code&gt;:</source>
          <target state="translated">プランナーは条件を調べ、この句の選択性を1％と決定します。この見積もりと実際の行数を比較すると、見積もりが非常に正確であることがわかります（テーブルが非常に小さいため、実際には正確です）。 &lt;code&gt;b&lt;/code&gt; 列を使用するように &lt;code&gt;WHERE&lt;/code&gt; 条件を変更すると、同じプランが生成されます。しかし、両方の列に同じ条件を適用し、それらを &lt;code&gt;AND&lt;/code&gt; で結合するとどうなるかを観察します。</target>
        </trans-unit>
        <trans-unit id="7a1338924ef7e4d51c210a157253f9f111c3a5a5" translate="yes" xml:space="preserve">
          <source>The planner may implement an &lt;code&gt;ORDER BY&lt;/code&gt; clause in several ways. The above example shows that such an ordering clause may be implemented implicitly. The planner may also add an explicit &lt;code&gt;sort&lt;/code&gt; step:</source>
          <target state="translated">プランナーは、いくつかの方法で &lt;code&gt;ORDER BY&lt;/code&gt; 句を実装できます。上記の例は、そのような順序付け句が暗黙的に実装される可能性があることを示しています。プランナーは、明示的な &lt;code&gt;sort&lt;/code&gt; ステップを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="ccbe97e96812fba17e36b64c7a8a14a6a5fc672b" translate="yes" xml:space="preserve">
          <source>The planner thinks (quite correctly) that this sample table is too small to bother with an index scan, so we have a plain sequential scan in which all the rows got rejected by the filter condition. But if we force an index scan to be used, we see:</source>
          <target state="translated">プランナーは、このサンプルテーブルが小さすぎてインデックススキャンを気にすることができないと(かなり正確に)考えているので、フィルタ条件によってすべての行が拒否されたプレーンなシーケンシャルスキャンを行います。しかし、インデックススキャンを強制的に使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="9e657fb9f6d61f80be4eb7b46475ad5f607f9e2a" translate="yes" xml:space="preserve">
          <source>The planner will consider satisfying an &lt;code&gt;ORDER BY&lt;/code&gt; specification either by scanning an available index that matches the specification, or by scanning the table in physical order and doing an explicit sort. For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than using an index because it requires less disk I/O due to following a sequential access pattern. Indexes are more useful when only a few rows need be fetched. An important special case is &lt;code&gt;ORDER BY&lt;/code&gt; in combination with &lt;code&gt;LIMIT&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;: an explicit sort will have to process all the data to identify the first &lt;code&gt;n&lt;/code&gt; rows, but if there is an index matching the &lt;code&gt;ORDER BY&lt;/code&gt;, the first &lt;code&gt;n&lt;/code&gt; rows can be retrieved directly, without scanning the remainder at all.</source>
          <target state="translated">プランナーは、仕様に一致する使用可能なインデックスをスキャンするか、物理的な順序でテーブルをスキャンして明示的なソートを行うことにより、 &lt;code&gt;ORDER BY&lt;/code&gt; 仕様を満たすことを検討します。テーブルの大部分をスキャンする必要があるクエリの場合、シーケンシャルアクセスパターンに従うため、必要なディスクI / Oが少ないため、明示的なソートはインデックスを使用するよりも高速になる可能性があります。インデックスは、フェッチする必要があるのが数行のみの場合により便利です。重要な特殊なケースがある &lt;code&gt;ORDER BY&lt;/code&gt; と組み合わせて &lt;code&gt;LIMIT&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; は：明示的なソートは、最初に識別するために、すべてのデータを処理する必要があります &lt;code&gt;n&lt;/code&gt; 個の行を、しかし、屈折率整合がある場合は &lt;code&gt;ORDER BY&lt;/code&gt; 、最初 &lt;code&gt;n&lt;/code&gt; 行は、残りをまったくスキャンせずに直接取得できます。</target>
        </trans-unit>
        <trans-unit id="f13fe03a32c9bbc1e61cf84d9ac188afb139c0ce" translate="yes" xml:space="preserve">
          <source>The planner will merge sub-queries into upper queries if the resulting &lt;code&gt;FROM&lt;/code&gt; list would have no more than this many items. Smaller values reduce planning time but might yield inferior query plans. The default is eight. For more information see &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.</source>
          <target state="translated">結果の &lt;code&gt;FROM&lt;/code&gt; リストにこれより多くのアイテムがない場合、プランナーはサブクエリを上位クエリにマージします。値が小さいほど計画時間は短縮されますが、クエリプランが低下する可能性があります。デフォルトは8です。詳細については、&lt;a href=&quot;explicit-joins&quot;&gt;セクション14.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7e54dd315c563119cab38a459210d1e25c17b541" translate="yes" xml:space="preserve">
          <source>The planner will rewrite explicit &lt;code&gt;JOIN&lt;/code&gt; constructs (except &lt;code&gt;FULL JOIN&lt;/code&gt;s) into lists of &lt;code&gt;FROM&lt;/code&gt; items whenever a list of no more than this many items would result. Smaller values reduce planning time but might yield inferior query plans.</source>
          <target state="translated">プランナは、明示的な &lt;code&gt;JOIN&lt;/code&gt; 構文（ &lt;code&gt;FULL JOIN&lt;/code&gt; を除く）を &lt;code&gt;FROM&lt;/code&gt; アイテムのリストに書き換えます。これにより、この数以下のアイテムのリストが生成されます。値が小さいほど計画時間は短縮されますが、クエリプランが低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="51459135e7da0626e3461453ee190521c7ca83f8" translate="yes" xml:space="preserve">
          <source>The planner's information about the query being processed.</source>
          <target state="translated">処理中のクエリに関するプランナーの情報です。</target>
        </trans-unit>
        <trans-unit id="1577e921445112f0dec558626039eff4a0e20d9e" translate="yes" xml:space="preserve">
          <source>The planner's search procedure actually works with data structures called &lt;em&gt;paths&lt;/em&gt;, which are simply cut-down representations of plans containing only as much information as the planner needs to make its decisions. After the cheapest path is determined, a full-fledged &lt;em&gt;plan tree&lt;/em&gt; is built to pass to the executor. This represents the desired execution plan in sufficient detail for the executor to run it. In the rest of this section we'll ignore the distinction between paths and plans.</source>
          <target state="translated">プランナーの検索手順は、実際には&lt;em&gt;パス&lt;/em&gt;と呼ばれるデータ構造で機能し&lt;em&gt;ます&lt;/em&gt;。これは、プランナーが決定を下すのに必要な情報だけを含むプランの単純な表現です。最も安いパスが決定された後、エグゼキュータに渡すための本格的な&lt;em&gt;計画ツリー&lt;/em&gt;が構築されます。これは、エグゼキューターが実行するのに十分な詳細で、望ましい実行プランを表します。このセクションの残りの部分では、パスとプランの違いを無視します。</target>
        </trans-unit>
        <trans-unit id="4a55c4b471813d250b09c8e9cf01cec1bc297015" translate="yes" xml:space="preserve">
          <source>The planner/optimizer starts by generating plans for scanning each individual relation (table) used in the query. The possible plans are determined by the available indexes on each relation. There is always the possibility of performing a sequential scan on a relation, so a sequential scan plan is always created. Assume an index is defined on a relation (for example a B-tree index) and a query contains the restriction &lt;code&gt;relation.attribute OPR constant&lt;/code&gt;. If &lt;code&gt;relation.attribute&lt;/code&gt; happens to match the key of the B-tree index and &lt;code&gt;OPR&lt;/code&gt; is one of the operators listed in the index's &lt;em&gt;operator class&lt;/em&gt;, another plan is created using the B-tree index to scan the relation. If there are further indexes present and the restrictions in the query happen to match a key of an index, further plans will be considered. Index scan plans are also generated for indexes that have a sort ordering that can match the query's &lt;code&gt;ORDER BY&lt;/code&gt; clause (if any), or a sort ordering that might be useful for merge joining (see below).</source>
          <target state="translated">プランナー/オプティマイザは、クエリで使用される個々のリレーション（テーブル）をスキャンするためのプランを生成することから始めます。可能なプランは、各関係で使用可能なインデックスによって決定されます。リレーションで順次スキャンを実行する可能性は常にあるため、順次スキャン計画が常に作成されます。インデックスがリレーション（たとえば、Bツリーインデックス）で定義されていて、クエリに制限 &lt;code&gt;relation.attribute OPR constant&lt;/code&gt; が含まれていると仮定します。場合 &lt;code&gt;relation.attribute&lt;/code&gt; B-treeインデックスのキーと一致するように起こり、 &lt;code&gt;OPR&lt;/code&gt; は、インデックスの中に記載されている事業者の一つである&lt;em&gt;演算子クラス&lt;/em&gt;、別のプランがBツリーインデックスを使用して作成され、関係をスキャンします。追加のインデックスが存在し、クエリの制限がインデックスのキーと一致する場合、追加のプランが検討されます。インデックススキャンプランは、クエリの &lt;code&gt;ORDER BY&lt;/code&gt; 句（存在する場合）に一致するソート順、またはマージ結合に役立つソート順（以下を参照）を持つインデックスに対しても生成されます。</target>
        </trans-unit>
        <trans-unit id="af6fcc949e29ec6b5395bb9895c598ac00851a39" translate="yes" xml:space="preserve">
          <source>The policy above implicitly provides a &lt;code&gt;WITH CHECK&lt;/code&gt; clause identical to its &lt;code&gt;USING&lt;/code&gt; clause, so that the constraint applies both to rows selected by a command (so a manager cannot &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; existing rows belonging to a different manager) and to rows modified by a command (so rows belonging to a different manager cannot be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;).</source>
          <target state="translated">上記のポリシーは、暗黙的に &lt;code&gt;USING&lt;/code&gt; 句と同じ &lt;code&gt;WITH CHECK&lt;/code&gt; 句を提供するため、制約はコマンドで選択された行（マネージャが別のマネージャに属する既存の行を &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; できない）と変更された行の両方に適用されますコマンドによって（したがって、別のマネージャーに属する行は、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; を介して作成できません）。</target>
        </trans-unit>
        <trans-unit id="332f3ca0119d1ff928cc3032c43d7a8c6d076ef7" translate="yes" xml:space="preserve">
          <source>The port number at which the database server is listening.</source>
          <target state="translated">データベースサーバーがリッスンしているポート番号。</target>
        </trans-unit>
        <trans-unit id="3946be524d4d21ed59a4396709c558221452e965" translate="yes" xml:space="preserve">
          <source>The port number on the RADIUS servers to connect to. If no port is specified, the default port &lt;code&gt;1812&lt;/code&gt; will be used.</source>
          <target state="translated">接続するRADIUSサーバーのポート番号。ポートを指定しない場合、デフォルトのポート &lt;code&gt;1812&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="e70d1aceb09cc5ddba7934344393827032e6f65c" translate="yes" xml:space="preserve">
          <source>The port numbers to connect to on the RADIUS servers. If no port is specified, the default RADIUS port (&lt;code&gt;1812&lt;/code&gt;) will be used.</source>
          <target state="translated">RADIUSサーバーで接続するポート番号。ポートが指定されていない場合は、デフォルトのRADIUSポート（ &lt;code&gt;1812&lt;/code&gt; ）が使用されます。</target>
        </trans-unit>
        <trans-unit id="d78397caeb854681d204384441be23fbf5963377" translate="yes" xml:space="preserve">
          <source>The possible privileges are:</source>
          <target state="translated">考えられる特典は</target>
        </trans-unit>
        <trans-unit id="f40d6965a9bc397fb0c918307a4356333c6e9be1" translate="yes" xml:space="preserve">
          <source>The possible types of qualified join are:</source>
          <target state="translated">資格を持った人が参加することが可能なタイプは、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="150d329b119d4f11b9ac2cd02c8c0d218611bacb" translate="yes" xml:space="preserve">
          <source>The potential for bloat in non-B-tree indexes has not been well researched. It is a good idea to periodically monitor the index's physical size when using any non-B-tree index type.</source>
          <target state="translated">非B-treeインデックスにおける肥大化の可能性は、あまり研究されていません。非B-treeインデックスタイプを使用する場合は、定期的にインデックスの物理的なサイズを監視することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d757a72d029cfb4caba9e0b1db29785724f4d19a" translate="yes" xml:space="preserve">
          <source>The preceding statement is not true on Microsoft Windows: there, any changes in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file are immediately applied by subsequent new connections.</source>
          <target state="translated">上記の説明はMicrosoft Windowsには当てはまりません &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルの変更は、その後の新しい接続によってすぐに適用されます。</target>
        </trans-unit>
        <trans-unit id="252c412e1c63dfae47e051caef322b62e83bb886" translate="yes" xml:space="preserve">
          <source>The precise rule that is applied in such cases is that an invalid timestamp that appears to fall within a jump-forward daylight savings transition is assigned the UTC offset that prevailed in the time zone just before the transition, while an ambiguous timestamp that could fall on either side of a jump-back transition is assigned the UTC offset that prevailed just after the transition. In most time zones this is equivalent to saying that &amp;ldquo;the standard-time interpretation is preferred when in doubt&amp;rdquo;.</source>
          <target state="translated">そのような場合に適用される正確なルールは、ジャンプフォワードの夏時間の移行に該当すると思われる無効なタイムスタンプには、移行直前のタイムゾーンで優勢だったUTCオフセットが割り当てられ、あいまいなタイムスタンプはジャンプバック遷移のどちらの側にも、遷移直後に適用されたUTCオフセットが割り当てられます。ほとんどのタイムゾーンでは、これは「疑わしい場合は標準時の解釈が好ましい」と言うことと同じです。</target>
        </trans-unit>
        <trans-unit id="28bfcc19c7bbea45feb0d0e7674c45c3d0b2a8ce" translate="yes" xml:space="preserve">
          <source>The precision must be positive, the scale zero or positive. Alternatively:</source>
          <target state="translated">精度は正でなければならず,目盛はゼロまたは正でなければなりません.あるいは</target>
        </trans-unit>
        <trans-unit id="3ffc8a93a54e6689bf8eb9af624f2ca2cef390c0" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">事前定義された集計関数については、&lt;a href=&quot;functions-aggregate&quot;&gt;セクション9.20で&lt;/a&gt;説明します。ユーザーは他の集約関数を追加できます。</target>
        </trans-unit>
        <trans-unit id="e0a2c0ac127cccc7aaf6bb36feba44f57ab9026a" translate="yes" xml:space="preserve">
          <source>The predefined aggregate functions are described in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;. Other aggregate functions can be added by the user.</source>
          <target state="translated">事前定義された集計関数については、&lt;a href=&quot;functions-aggregate&quot;&gt;セクション9.21で&lt;/a&gt;説明しています。他の集計関数は、ユーザーが追加できます。</target>
        </trans-unit>
        <trans-unit id="85290651a145a4790c306bf3090be3ac088ff86f" translate="yes" xml:space="preserve">
          <source>The preferred key type is &amp;ldquo;DSA and Elgamal&amp;rdquo;.</source>
          <target state="translated">推奨される鍵タイプは「DSA and Elgamal」です。</target>
        </trans-unit>
        <trans-unit id="9dcad895255c51069330af5d11a7861de5e972db" translate="yes" xml:space="preserve">
          <source>The preferred way of creating any of the standard procedural languages is just:</source>
          <target state="translated">標準的な手続き言語のいずれかを作成するための好ましい方法は、ただそれだけです。</target>
        </trans-unit>
        <trans-unit id="1d193e74c38ebc3f88cf6c96d5dc626c1a851ce8" translate="yes" xml:space="preserve">
          <source>The preferred way to add and remove members of roles that are being used as groups is to use &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;.</source>
          <target state="translated">グループとして使用されているロールのメンバーを追加および削除するための推奨される方法は、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="56dfc8a10ef1e4c4eee74088145c35840ecca451" translate="yes" xml:space="preserve">
          <source>The prefixes used for hyphenation were also compiled from:</source>
          <target state="translated">ハイフネーションに使用される接頭辞もからコンパイルしました。</target>
        </trans-unit>
        <trans-unit id="21fd2dec3de8b8ad1e5f622c8c13eab56cd148d6" translate="yes" xml:space="preserve">
          <source>The presence of &lt;code&gt;HAVING&lt;/code&gt; turns a query into a grouped query even if there is no &lt;code&gt;GROUP BY&lt;/code&gt; clause. This is the same as what happens when the query contains aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause. All the selected rows are considered to form a single group, and the &lt;code&gt;SELECT&lt;/code&gt; list and &lt;code&gt;HAVING&lt;/code&gt; clause can only reference table columns from within aggregate functions. Such a query will emit a single row if the &lt;code&gt;HAVING&lt;/code&gt; condition is true, zero rows if it is not true.</source>
          <target state="translated">存在 &lt;code&gt;HAVING&lt;/code&gt; 全く存在しない場合でもターンにグループ化されたクエリにクエリを &lt;code&gt;GROUP BY&lt;/code&gt; 句。これは、クエリに集計関数が含まれているが &lt;code&gt;GROUP BY&lt;/code&gt; 句が含まれていない場合と同じです。選択されたすべての行は1つのグループを形成すると見なされ、 &lt;code&gt;SELECT&lt;/code&gt; リストと &lt;code&gt;HAVING&lt;/code&gt; 句は集計関数内からのみテーブル列を参照できます。そのようなクエリは、 &lt;code&gt;HAVING&lt;/code&gt; 条件がtrueの場合は1行を発行し、trueでない場合は0行を発行します。</target>
        </trans-unit>
        <trans-unit id="48e01dab4eaf7172ed513c36aea408ac9dcff0a1" translate="yes" xml:space="preserve">
          <source>The previous example with &lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; was an oversimplification of what &lt;code&gt;scalarltsel&lt;/code&gt; really does; now that we have seen an example of the use of MCVs, we can fill in some more detail. The example was correct as far as it went, because since &lt;code&gt;unique1&lt;/code&gt; is a unique column it has no MCVs (obviously, no value is any more common than any other value). For a non-unique column, there will normally be both a histogram and an MCV list, and &lt;em&gt;the histogram does not include the portion of the column population represented by the MCVs&lt;/em&gt;. We do things this way because it allows more precise estimation. In this situation &lt;code&gt;scalarltsel&lt;/code&gt; directly applies the condition (e.g., &amp;ldquo;&amp;lt; 1000&amp;rdquo;) to each value of the MCV list, and adds up the frequencies of the MCVs for which the condition is true. This gives an exact estimate of the selectivity within the portion of the table that is MCVs. The histogram is then used in the same way as above to estimate the selectivity in the portion of the table that is not MCVs, and then the two numbers are combined to estimate the overall selectivity. For example, consider</source>
          <target state="translated">&lt;code&gt;unique1 &amp;lt; 1000&lt;/code&gt; の前の例は、 &lt;code&gt;scalarltsel&lt;/code&gt; が実際に行うことの単純化しすぎでした。 MCVの使用例を見てきましたので、もう少し詳しく入力できます。 &lt;code&gt;unique1&lt;/code&gt; は一意の列であるため、MCVがないため（この例では、他のどの値よりも一般的な値はありません）、この例は、これまでのところ正しいものでした。一意でない列の場合、通常はヒストグラムとMCVリストの両方が存在し、ヒストグラムにはMCVで&lt;em&gt;表される列の母集団の部分は含まれません&lt;/em&gt;。これにより、より正確な推定が可能になります。この状況では &lt;code&gt;scalarltsel&lt;/code&gt; 条件（たとえば、「&amp;lt;1000」）をMCVリストの各値に直接適用し、条件が真であるMCVの頻度を合計します。これにより、MCVであるテーブルの部分内の選択性の正確な見積もりが得られます。次に、上記と同じ方法でヒストグラムを使用して、テーブルのMCV以外の部分の選択性を推定し、2つの数値を組み合わせて全体的な選択性を推定します。たとえば、</target>
        </trans-unit>
        <trans-unit id="bb34259f0365c548655973db55e1cb8224129b77" translate="yes" xml:space="preserve">
          <source>The primary and standby server work together to provide this capability, though the servers are only loosely coupled. The primary server operates in continuous archiving mode, while each standby server operates in continuous recovery mode, reading the WAL files from the primary. No changes to the database tables are required to enable this capability, so it offers low administration overhead compared to some other replication solutions. This configuration also has relatively low performance impact on the primary server.</source>
          <target state="translated">プライマリサーバとスタンバイサーバはこの機能を提供するために連携していますが、サーバは疎結合でしかありません。プライマリ・サーバは連続アーカイブ・モードで動作し、各スタンバイ・サーバは連続リカバリ・モードで動作し、プライマリからWALファイルを読み込みます。この機能を有効にするためにデータベーステーブルに変更を加える必要がないため、他のレプリケーションソリューションと比較して管理オーバーヘッドが少なくて済みます。また、この構成では、プライマリサーバへのパフォーマンスへの影響も比較的少なくなります。</target>
        </trans-unit>
        <trans-unit id="0da66f61871c96b75f9ab923507bcc1a24b7f889" translate="yes" xml:space="preserve">
          <source>The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them. The easiest conflict to understand is performance: if a huge data load is taking place on the primary then this will generate a similar stream of WAL records on the standby, so standby queries may contend for system resources, such as I/O.</source>
          <target state="translated">プライマリサーバとスタンバイサーバは、多くの点で疎通しています。プライマリでのアクションは、スタンバイにも影響を与えます。その結果、両者の間に否定的な相互作用や競合が発生する可能性があります。プライマリで膨大なデータ負荷が発生している場合、スタンバイでも同様のWALレコードのストリームが生成されるため、スタンバイクエリはI/Oなどのシステムリソースを争う可能性があります。</target>
        </trans-unit>
        <trans-unit id="798c0c5f43fda644a454b46372f29e554497fa2e" translate="yes" xml:space="preserve">
          <source>The primary error message and associated SQLSTATE code for the most recent failed query in the current psql session, or an empty string and &lt;code&gt;00000&lt;/code&gt; if no error has occurred in the current session.</source>
          <target state="translated">現在のpsqlセッションで最後に失敗したクエリのプライマリエラーメッセージと関連するSQLSTATEコード、または現在のセッションでエラーが発生していない場合は空の文字列と &lt;code&gt;00000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ab145e1a33deb5fe3582f237dbec8cdd7e1d8ca" translate="yes" xml:space="preserve">
          <source>The primary goal of developing GIN indexes was to create support for highly scalable full-text search in PostgreSQL, and there are often situations when a full-text search returns a very large set of results. Moreover, this often happens when the query contains very frequent words, so that the large result set is not even useful. Since reading many tuples from the disk and sorting them could take a lot of time, this is unacceptable for production. (Note that the index search itself is very fast.)</source>
          <target state="translated">GINインデックスの開発の第一の目的は、PostgreSQLにおける高度にスケーラブルな全文検索のサポートを作成することでした。さらに、これは問い合わせに非常に頻繁に使われる単語が含まれている場合によく起こりますので、大きな結果セットは役に立たないことになります。ディスクから多くのタプルを読み込んでソートするには多くの時間がかかるので、これは本番では受け入れられません。(インデックス検索自体は非常に高速であることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="6c7d00d06905a4bbc00c744c0f27a07f33dd5060" translate="yes" xml:space="preserve">
          <source>The primary key constraint should name a set of columns that is different from the set of columns named by any unique constraint defined for the same table. (Otherwise, the unique constraint is redundant and will be discarded.)</source>
          <target state="translated">主キー制約は、同じテーブルに対して定義された一意制約で指定された列のセットとは異なる列のセットを指定しなければなりません (そうでなければ、一意制約は冗長であり、破棄されます)。(そうでない場合、一意制約は冗長であり、破棄されます)。</target>
        </trans-unit>
        <trans-unit id="095c1f180ee69bf2f8a1425ef17c7371474cd375" translate="yes" xml:space="preserve">
          <source>The primary query and the &lt;code&gt;WITH&lt;/code&gt; queries are all (notionally) executed at the same time. This implies that the effects of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; cannot be seen from other parts of the query, other than by reading its &lt;code&gt;RETURNING&lt;/code&gt; output. If two such data-modifying statements attempt to modify the same row, the results are unspecified.</source>
          <target state="translated">プライマリクエリと &lt;code&gt;WITH&lt;/code&gt; クエリは、すべて（概念的に）同時に実行されます。これは、 &lt;code&gt;RETURNING&lt;/code&gt; 出力を読み取る以外に、 &lt;code&gt;WITH&lt;/code&gt; のデータ変更ステートメントの影響をクエリの他の部分から確認できないことを意味します。このような2つのデータ変更ステートメントが同じ行を変更しようとした場合、結果は不定です。</target>
        </trans-unit>
        <trans-unit id="9af619375db4792c2c6568b4b82266a2578d8e4a" translate="yes" xml:space="preserve">
          <source>The primary use of unlogged tables is for storing transient work data that must be shared across processes.</source>
          <target state="translated">ログなしテーブルの主な用途は、プロセス間で共有しなければならない過渡的な作業データを格納するためのものです。</target>
        </trans-unit>
        <trans-unit id="8ea3da5c410e9ce91a550f33e83dec4f1762b9fe" translate="yes" xml:space="preserve">
          <source>The privileges necessary to execute this command are left implementation-defined by the standard.</source>
          <target state="translated">このコマンドを実行するために必要な権限は、標準で実装が定義されています。</target>
        </trans-unit>
        <trans-unit id="3d054afefddca1f4fd0c80061650d8bf2f8607fd" translate="yes" xml:space="preserve">
          <source>The privileges required by other commands are listed on the reference page of the respective command.</source>
          <target state="translated">他のコマンドで必要な権限は、それぞれのコマンドの参照ページに記載されています。</target>
        </trans-unit>
        <trans-unit id="304d4014e67dda82fac817f06e9aef50bfd659e4" translate="yes" xml:space="preserve">
          <source>The privileges required to create a conversion might be changed in a future release.</source>
          <target state="translated">変換を作成するために必要な権限は、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="1eb7e4f8bb27785f30b9b8a7055a803cd67b6df6" translate="yes" xml:space="preserve">
          <source>The privileges that have been granted for a particular object are displayed as a list of &lt;code&gt;aclitem&lt;/code&gt; entries, where each &lt;code&gt;aclitem&lt;/code&gt; describes the permissions of one grantee that have been granted by a particular grantor. For example, &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; specifies that the role &lt;code&gt;calvin&lt;/code&gt; has the privilege &lt;code&gt;SELECT&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;) with grant option (&lt;code&gt;*&lt;/code&gt;) as well as the non-grantable privilege &lt;code&gt;UPDATE&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt;), both granted by the role &lt;code&gt;hobbes&lt;/code&gt;. If &lt;code&gt;calvin&lt;/code&gt; also has some privileges on the same object granted by a different grantor, those would appear as a separate &lt;code&gt;aclitem&lt;/code&gt; entry. An empty grantee field in an &lt;code&gt;aclitem&lt;/code&gt; stands for &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">特定のオブジェクトに対して付与された特権は、 &lt;code&gt;aclitem&lt;/code&gt; エントリのリストとして表示されます。各 &lt;code&gt;aclitem&lt;/code&gt; は、特定の付与者によって付与された1人の被付与者の権限を示します。たとえば、 &lt;code&gt;calvin=r*w/hobbes&lt;/code&gt; は、役割 &lt;code&gt;calvin&lt;/code&gt; が権限（ &lt;code&gt;SELECT&lt;/code&gt; )（ &lt;code&gt;r&lt;/code&gt; ）と付与オプション（ &lt;code&gt;*&lt;/code&gt; ）、および付与不可能な権限 &lt;code&gt;UPDATE&lt;/code&gt; （ &lt;code&gt;w&lt;/code&gt; ）を &lt;code&gt;hobbes&lt;/code&gt; 、どちらも役割hobbesによって付与されることを指定します。 &lt;code&gt;calvin&lt;/code&gt; が別の付与者によって付与された同じオブジェクトに対していくつかの特権を持っている場合、それらは別個の &lt;code&gt;aclitem&lt;/code&gt; として表示されますエントリ。 &lt;code&gt;aclitem&lt;/code&gt; の空の被付与者フィールドは &lt;code&gt;PUBLIC&lt;/code&gt; を表します。</target>
        </trans-unit>
        <trans-unit id="146fa2f880a1a0967ddf597dd80c4df17c9e7c69" translate="yes" xml:space="preserve">
          <source>The procedural language code to be executed. This must be specified as a string literal, just as in &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Use of a dollar-quoted literal is recommended.</source>
          <target state="translated">実行される手続き言語コード。これは、 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; と同様に、文字列リテラルとして指定する必要があります。ドルで引用されたリテラルの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="6f86ee50294a4a7a3fef4b5b2297c9c5402611ba" translate="yes" xml:space="preserve">
          <source>The procedural language to be used must already have been installed into the current database by means of &lt;code&gt;CREATE EXTENSION&lt;/code&gt;. &lt;code&gt;plpgsql&lt;/code&gt; is installed by default, but other languages are not.</source>
          <target state="translated">使用する手続き言語は、 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; によって現在のデータベースにすでにインストールされている必要があります。 &lt;code&gt;plpgsql&lt;/code&gt; はデフォルトでインストールされますが、他の言語はインストールされていません。</target>
        </trans-unit>
        <trans-unit id="eeffbbfe4a95a1cfc7af97774b63ebc4c95bcc67" translate="yes" xml:space="preserve">
          <source>The procedure for making a base backup using the low level APIs contains a few more steps than the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step.</source>
          <target state="translated">低レベルAPIを使用してベースバックアップを作成する手順には、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;メソッドよりもいくつかの手順が含まれていますが、比較的簡単です。これらのステップが順番に実行され、次のステップに進む前にステップの成功が確認されることが非常に重要です。</target>
        </trans-unit>
        <trans-unit id="0cb38c62a0e05e7bd2148e42b61d27ee2ab30693" translate="yes" xml:space="preserve">
          <source>The procedure will now execute with whatever search path is used by its caller.</source>
          <target state="translated">このプロシージャは、その呼び出し元で使用される検索パスで実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="4b5bcbc092d024a0a7543e925fc016ccd66517c6" translate="yes" xml:space="preserve">
          <source>The process ID of the backend currently connected to.</source>
          <target state="translated">現在接続しているバックエンドのプロセスID。</target>
        </trans-unit>
        <trans-unit id="34795750bd1d44ec3bd68f7c69b56e729608c717" translate="yes" xml:space="preserve">
          <source>The process ID of the session using this slot if the slot is currently actively being used. &lt;code&gt;NULL&lt;/code&gt; if inactive.</source>
          <target state="translated">スロットが現在アクティブに使用されている場合、このスロットを使用するセッションのプロセスID。非アクティブの場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a4bb7cc46bcf50934800d5f3c98570d230e94a" translate="yes" xml:space="preserve">
          <source>The process for an exclusive backup is mostly the same as for a non-exclusive one, but it differs in a few key steps. This type of backup can only be taken on a primary and does not allow concurrent backups. Moreover, because it creates a backup label file, as described below, it can block automatic restart of the master server after a crash. On the other hand, the erroneous removal of this file from a backup or standby is a common mistake, which can result in serious data corruption. If it is necessary to use this method, the following steps may be used.</source>
          <target state="translated">排他的バックアップのプロセスは非排他的バックアップとほとんど同じですが、いくつかの重要なステップが異なります。このタイプのバックアップはプライマリ上でのみ実行でき、同時バックアップはできません。さらに、後述するようにバックアップラベルファイルを作成するため、クラッシュ後のマスターサーバの自動再起動をブロックすることができます。一方、バックアップやスタンバイからこのファイルを誤って削除してしまうことは、よくあるミスであり、深刻なデータの破損につながる可能性があります。どうしてもこの方法を使う必要がある場合は、以下の手順で行うことができます。</target>
        </trans-unit>
        <trans-unit id="3ac18966156d31cda12f7c9ac2957f1b7e5f24a9" translate="yes" xml:space="preserve">
          <source>The process of collecting statistics from data in &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; and other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; to help the &lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;query planner&lt;/a&gt; to make decisions about how to execute &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;クエリプランナー&lt;/a&gt;が&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;クエリの&lt;/a&gt;実行方法を決定するのに役立つ、&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;およびその他の&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;関係の&lt;/a&gt;データから統計を収集するプロセス。</target>
        </trans-unit>
        <trans-unit id="164dce5302a4d4d5322e298ad9a4e62c23cc3474" translate="yes" xml:space="preserve">
          <source>The process of removing outdated &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple versions&lt;/a&gt; from tables or materialized views, and other closely related processing required by PostgreSQL's implementation of &lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;MVCC&lt;/a&gt;. This can be initiated through the use of the &lt;code&gt;VACUUM&lt;/code&gt; command, but can also be handled automatically via &lt;a href=&quot;glossary#GLOSSARY-AUTOVACUUM&quot;&gt;autovacuum&lt;/a&gt; processes.</source>
          <target state="translated">テーブルまたはマテリアライズドビューから古い&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;タプルバージョン&lt;/a&gt;を削除するプロセス、およびPostgreSQLの&lt;a href=&quot;glossary#GLOSSARY-MVCC&quot;&gt;MVCC&lt;/a&gt;の実装に必要なその他の密接に関連する処理。これは、 &lt;code&gt;VACUUM&lt;/code&gt; コマンドを使用して開始できますが、自動&lt;a href=&quot;glossary#GLOSSARY-AUTOVACUUM&quot;&gt;バキューム&lt;/a&gt;プロセスを介して自動的に処理することもできます。</target>
        </trans-unit>
        <trans-unit id="6e312719075282712af63a4478358c161b9ce7c1" translate="yes" xml:space="preserve">
          <source>The process of retrieving or the command to retrieve data from a database is called a &lt;em&gt;query&lt;/em&gt;. In SQL the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command is used to specify queries. The general syntax of the &lt;code&gt;SELECT&lt;/code&gt; command is</source>
          <target state="translated">取得のプロセス、またはデータベースからデータを取得するコマンドは、&lt;em&gt;クエリ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。SQLでは、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;コマンドを使用してクエリを指定します。 &lt;code&gt;SELECT&lt;/code&gt; コマンドの一般的な構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b0bd352dde02b38bfa623807b29516cb539dd331" translate="yes" xml:space="preserve">
          <source>The program &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; is a wrapper program around this command, provided for convenience.</source>
          <target state="translated">&lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt;プログラムは、このコマンドのラッパープログラムであり、便宜上提供されています。</target>
        </trans-unit>
        <trans-unit id="3eff284be443ff432de37efc6563b33dc2f6e837" translate="yes" xml:space="preserve">
          <source>The prompts psql issues can be customized to your preference. The three variables &lt;code&gt;PROMPT1&lt;/code&gt;, &lt;code&gt;PROMPT2&lt;/code&gt;, and &lt;code&gt;PROMPT3&lt;/code&gt; contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command entry, for example because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you are running an SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; command and you need to type in a row value on the terminal.</source>
          <target state="translated">プロンプトpsqlの問題は、好みに応じてカスタマイズできます。3つの変数 &lt;code&gt;PROMPT1&lt;/code&gt; 、 &lt;code&gt;PROMPT2&lt;/code&gt; 、および &lt;code&gt;PROMPT3&lt;/code&gt; には、プロンプトの外観を説明する文字列と特別なエスケープシーケンスが含まれています。プロンプト1は、psqlが新しいコマンドを要求したときに発行される通常のプロンプトです。プロンプト2は、コマンドがセミコロンで終了していない、または引用符が閉じられていないなどの理由で、コマンド入力中にさらに入力が予想される場合に発行されます。プロンプト3は、SQL &lt;code&gt;COPY FROM STDIN&lt;/code&gt; コマンドを実行していて、端末で行の値を入力する必要がある場合に発行されます。</target>
        </trans-unit>
        <trans-unit id="beda63023776d34df94471c0f164755d13f940bc" translate="yes" xml:space="preserve">
          <source>The property of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; that either all its operations complete as a single unit or none do. In addition, if a system failure occurs during the execution of a transaction, no partial results are visible after recovery. This is one of the ACID properties.</source>
          <target state="translated">すべての操作が単一のユニットとして完了するか、まったく完了しない&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;トランザクション&lt;/a&gt;のプロパティ。さらに、トランザクションの実行中にシステム障害が発生した場合、回復後に部分的な結果は表示されません。これはACIDプロパティの1つです。</target>
        </trans-unit>
        <trans-unit id="60437688afa311c4869b8b3f6a8991364e3687d3" translate="yes" xml:space="preserve">
          <source>The property of certain &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; that the changes to them are not reflected in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. This disables replication and crash recovery for these relations.</source>
          <target state="translated">それらへの変更が&lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WALに&lt;/a&gt;反映されないという特定の&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;関係&lt;/a&gt;のプロパティ。これにより、これらの関係のレプリケーションとクラッシュリカバリが無効になります。</target>
        </trans-unit>
        <trans-unit id="fb5f3d4498a374f31c0813bda303e196477c5021" translate="yes" xml:space="preserve">
          <source>The property that some information has been pre-computed and stored for later use, rather than computing it on-the-fly.</source>
          <target state="translated">その場で計算するのではなく、ある情報が事前に計算されて保存されていて、後から使えるようになっているという性質があります。</target>
        </trans-unit>
        <trans-unit id="83b4c095224b564ce4e74b023e585d03df96a6dc" translate="yes" xml:space="preserve">
          <source>The property that the data in the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; is always in compliance with &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;integrity constraints&lt;/a&gt;. Transactions may be allowed to violate some of the constraints transiently before it commits, but if such violations are not resolved by the time it commits, such a transaction is automatically &lt;a href=&quot;glossary#GLOSSARY-ROLLBACK&quot;&gt;rolled back&lt;/a&gt;. This is one of the ACID properties.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;内のデータが常に&lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;整合性制約&lt;/a&gt;に準拠しているというプロパティ。トランザクションは、コミットする前に一時的にいくつかの制約に違反することが許可される場合がありますが、そのような違反がコミットするまでに解決されない場合、そのようなトランザクションは自動的に&lt;a href=&quot;glossary#GLOSSARY-ROLLBACK&quot;&gt;ロールバックされ&lt;/a&gt;ます。これはACIDプロパティの1つです。</target>
        </trans-unit>
        <trans-unit id="a6435c94ce6f1ff88843d11bc1738457d2390918" translate="yes" xml:space="preserve">
          <source>The property that the effects of a transaction are not visible to &lt;a href=&quot;glossary#GLOSSARY-CONCURRENCY&quot;&gt;concurrent transactions&lt;/a&gt; before it commits. This is one of the ACID properties.</source>
          <target state="translated">トランザクションの効果は、コミットする前に&lt;a href=&quot;glossary#GLOSSARY-CONCURRENCY&quot;&gt;並行トランザクション&lt;/a&gt;に表示されないというプロパティ。これはACIDプロパティの1つです。</target>
        </trans-unit>
        <trans-unit id="0b52632ebba8d8fdc7d9a5f3df0121e320094037" translate="yes" xml:space="preserve">
          <source>The provided functions are shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;Table F.5&lt;/a&gt;.</source>
          <target state="translated">提供される関数を&lt;a href=&quot;earthdistance#EARTHDISTANCE-CUBE-FUNCTIONS&quot;&gt;表F.5に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="5afa1f9b64bd52e3a56222e3e5d393c2eefea25a" translate="yes" xml:space="preserve">
          <source>The purpose is to limit the impact of pg_basebackup on the running server.</source>
          <target state="translated">この目的は、pg_basebackupが実行中のサーバに与える影響を制限することです。</target>
        </trans-unit>
        <trans-unit id="5073941a47e032b26bcb9d69507584568abea85b" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; List&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 句の目的は、クエリの&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; &lt;/a&gt;リストまたは&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt;句に&lt;em&gt;表示されるウィンドウ関数&lt;/em&gt;の動作を指定することです。これらの関数は、 &lt;code&gt;OVER&lt;/code&gt; 句の名前で &lt;code&gt;WINDOW&lt;/code&gt; 句のエントリを参照できます。 &lt;code&gt;WINDOW&lt;/code&gt; の句エントリは、しかし、どこでも参照する必要はありません。クエリで使用されていない場合は、単に無視されます。ウィンドウ関数呼び出しはそのウィンドウ定義を &lt;code&gt;OVER&lt;/code&gt; 句で直接指定できるため、 &lt;code&gt;WINDOW&lt;/code&gt; 句をまったく使用せずにウィンドウ関数を使用することが可能です。ただし、 &lt;code&gt;WINDOW&lt;/code&gt; 句は、同じウィンドウ定義が複数のウィンドウ関数に必要な場合の入力を節約します。</target>
        </trans-unit>
        <trans-unit id="b96262653baf1cfb436f7851543f2559b2750e87" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;code&gt;WINDOW&lt;/code&gt; clause is to specify the behavior of &lt;em&gt;window functions&lt;/em&gt; appearing in the query's &lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt;&lt;code&gt;SELECT&lt;/code&gt; list&lt;/a&gt; or &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt;&lt;/a&gt; clause. These functions can reference the &lt;code&gt;WINDOW&lt;/code&gt; clause entries by name in their &lt;code&gt;OVER&lt;/code&gt; clauses. A &lt;code&gt;WINDOW&lt;/code&gt; clause entry does not have to be referenced anywhere, however; if it is not used in the query it is simply ignored. It is possible to use window functions without any &lt;code&gt;WINDOW&lt;/code&gt; clause at all, since a window function call can specify its window definition directly in its &lt;code&gt;OVER&lt;/code&gt; clause. However, the &lt;code&gt;WINDOW&lt;/code&gt; clause saves typing when the same window definition is needed for more than one window function.</source>
          <target state="translated">&lt;code&gt;WINDOW&lt;/code&gt; 句の目的は、クエリの&lt;a href=&quot;sql-select#SQL-SELECT-LIST&quot;&gt; &lt;code&gt;SELECT&lt;/code&gt; &lt;/a&gt;リストまたは&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; &lt;/a&gt;句に&lt;em&gt;表示されるウィンドウ関数&lt;/em&gt;の動作を指定することです。これらの関数は、 &lt;code&gt;OVER&lt;/code&gt; 句の名前で &lt;code&gt;WINDOW&lt;/code&gt; 句のエントリを参照できます。 &lt;code&gt;WINDOW&lt;/code&gt; の句エントリは、しかし、どこでも参照する必要はありません。クエリで使用されていない場合は、単に無視されます。ウィンドウ関数呼び出しはそのウィンドウ定義をその &lt;code&gt;OVER&lt;/code&gt; 句で直接指定できるため、 &lt;code&gt;WINDOW&lt;/code&gt; 句をまったく使用せずにウィンドウ関数を使用することができます。ただし、 &lt;code&gt;WINDOW&lt;/code&gt; 句は、複数のウィンドウ関数に同じウィンドウ定義が必要な場合に入力を節約します。</target>
        </trans-unit>
        <trans-unit id="7a79e1e6c48912d3a19f2334c5cde8a4adb3de10" translate="yes" xml:space="preserve">
          <source>The purpose of an index, of course, is to support scans for tuples matching an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, often called a &lt;em&gt;qualifier&lt;/em&gt; or &lt;em&gt;scan key&lt;/em&gt;. The semantics of index scanning are described more fully in &lt;a href=&quot;index-scanning&quot;&gt;Section 61.3&lt;/a&gt;, below. An index access method can support &amp;ldquo;plain&amp;rdquo; index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, or both. The scan-related functions that an index access method must or may provide are:</source>
          <target state="translated">もちろん、インデックスの目的は、多くの場合&lt;em&gt;修飾子&lt;/em&gt;または&lt;em&gt;スキャンキー&lt;/em&gt;と呼ばれる、インデックス付け可能な &lt;code&gt;WHERE&lt;/code&gt; 条件に一致するタプルのスキャンをサポートすることです。インデックススキャンのセマンティクスについては、以下の&lt;a href=&quot;index-scanning&quot;&gt;セクション61.3&lt;/a&gt;で詳しく説明します。索引アクセス方式は、「プレーン」索引スキャン、「ビットマップ」索引スキャン、またはその両方をサポートできます。インデックスアクセスメソッドが提供しなければならない、または提供する可能性があるスキャン関連の関数は次のとおりです。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71dfcd4f15fca395ab847bf8654ecc1126908484" translate="yes" xml:space="preserve">
          <source>The quantifiers &lt;code&gt;{1,1}&lt;/code&gt; and &lt;code&gt;{1,1}?&lt;/code&gt; can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this:</source>
          <target state="translated">数量詞 &lt;code&gt;{1,1}&lt;/code&gt; および &lt;code&gt;{1,1}?&lt;/code&gt; 部分式またはRE全体に対して、それぞれ貪欲または非貪欲を強制するために使用できます。これは、RE全体に、その要素から推定されるものとは異なる貪欲属性を持たせる必要がある場合に役立ちます。例として、いくつかの数字を含む文字列をその前後の数字と部分に分離しようとしていると仮定します。このようにしようとするかもしれません：</target>
        </trans-unit>
        <trans-unit id="343b9e25e0029b4f349abf2c9eb3c709d6c9db46" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1 - 4) that the date is in</source>
          <target state="translated">日付が入っている年の四半期(1~4)。</target>
        </trans-unit>
        <trans-unit id="4b7ab2f4293b424598bc3b854175b38f8e2117d5" translate="yes" xml:space="preserve">
          <source>The quarter of the year (1&amp;ndash;4) that the date is in</source>
          <target state="translated">日付が含まれる年の四半期（1〜4）</target>
        </trans-unit>
        <trans-unit id="5c024cf5d71d6d58e1719ea5b88c2edd0af4738d" translate="yes" xml:space="preserve">
          <source>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</source>
          <target state="translated">クエリされたJSONデータには、入れ子になった配列が含まれています。この場合、一番外側の配列のみがアンラップされ、内側の配列はすべて変更されません。このように、暗黙のアンラップは、各パス評価ステップ内で1つのレベルだけ下に行くことができます。</target>
        </trans-unit>
        <trans-unit id="9ec83a60a4572c2a39f277feef2e26e14c05d5aa" translate="yes" xml:space="preserve">
          <source>The query above specifies that the &lt;code&gt;english&lt;/code&gt; configuration is to be used to parse and normalize the strings. Alternatively we could omit the configuration parameters:</source>
          <target state="translated">上記のクエリは、 &lt;code&gt;english&lt;/code&gt; 構成を使用して文字列を解析および正規化することを指定しています。あるいは、構成パラメーターを省略できます。</target>
        </trans-unit>
        <trans-unit id="755893eaea71f45690b0b8daa7c44ccecde3f16e" translate="yes" xml:space="preserve">
          <source>The query is running inside of another query that is already parallel. For example, if a function called by a parallel query issues an SQL query itself, that query will never use a parallel plan. This is a limitation of the current implementation, but it may not be desirable to remove this limitation, since it could result in a single query using a very large number of processes.</source>
          <target state="translated">そのクエリは、すでに並列化されている別のクエリの内部で実行されています。例えば、並列クエリによって呼び出された関数がSQLクエリ自体を発行した場合、そのクエリは決して並列プランを使用しません。これは現在の実装の制限ですが、1つのクエリで非常に多くのプロセスを使用することになる可能性があるため、この制限を取り除くことは望ましくないかもしれません。</target>
        </trans-unit>
        <trans-unit id="5a0a949650f6ba760f80fb27f318b51f13c26bd4" translate="yes" xml:space="preserve">
          <source>The query might be suspended during execution. In any situation in which the system thinks that partial or incremental execution might occur, no parallel plan is generated. For example, a cursor created using &lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt; will never use a parallel plan. Similarly, a PL/pgSQL loop of the form &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; will never use a parallel plan, because the parallel query system is unable to verify that the code in the loop is safe to execute while parallel query is active.</source>
          <target state="translated">クエリは実行中に一時停止される可能性があります。部分的または増分的な実行が発生する可能性があるとシステムが判断する状況では、並列プランは生成されません。たとえば、&lt;a href=&quot;sql-declare&quot;&gt;DECLARE CURSOR&lt;/a&gt;を使用して作成されたカーソルは、並列プランを使用しません。同様に、 &lt;code&gt;FOR x IN query LOOP .. END LOOP&lt;/code&gt; という形式のPL / pgSQLループは、並列プランを使用することはありません。これは、並列クエリシステムが、並列クエリがアクティブな間、ループ内のコードが安全に実行されていることを確認できないためです。 。</target>
        </trans-unit>
        <trans-unit id="bdfa8875f3090d46606e95d96800e6f18174861f" translate="yes" xml:space="preserve">
          <source>The query must reference only columns stored in the index. For example, given an index on columns &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of a table that also has a column &lt;code&gt;z&lt;/code&gt;, these queries could use index-only scans:</source>
          <target state="translated">クエリは、インデックスに格納されている列のみを参照する必要があります。たとえば、列 &lt;code&gt;z&lt;/code&gt; もあるテーブルの列 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; のインデックスを指定すると、これらのクエリはインデックスのみのスキャンを使用できます。</target>
        </trans-unit>
        <trans-unit id="c50468726e4134a52ce71c84ac34c354a3e1b957" translate="yes" xml:space="preserve">
          <source>The query optimizer takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating query plans, so you are very likely to get different plans (yielding different row orders) depending on what you give for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">クエリオプティマイザーはクエリプランを生成するときに &lt;code&gt;LIMIT&lt;/code&gt; を考慮に入れるため、 &lt;code&gt;LIMIT&lt;/code&gt; および &lt;code&gt;OFFSET&lt;/code&gt; に指定した内容に応じて、異なるプランを取得する（異なる行順序を生成する）可能性が非常に高くなります。したがって、異なる &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 値を使用してクエリ結果の異なるサブセットを選択すると、 &lt;code&gt;ORDER BY&lt;/code&gt; で予測可能な結果の順序付けを適用しない限り&lt;em&gt;、一貫性のない結果になり&lt;/em&gt;ます。これはバグではありません。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を使用して順序を制約しない限り、SQLが特定の順序でクエリの結果を提供することを約束しないという事実の本質的な結果です。</target>
        </trans-unit>
        <trans-unit id="9591ec91d27bd94fc1ed0042a9c68fc7e7f8799e" translate="yes" xml:space="preserve">
          <source>The query planner takes &lt;code&gt;LIMIT&lt;/code&gt; into account when generating a query plan, so you are very likely to get different plans (yielding different row orders) depending on what you use for &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;. Thus, using different &lt;code&gt;LIMIT&lt;/code&gt;/&lt;code&gt;OFFSET&lt;/code&gt; values to select different subsets of a query result &lt;em&gt;will give inconsistent results&lt;/em&gt; unless you enforce a predictable result ordering with &lt;code&gt;ORDER BY&lt;/code&gt;. This is not a bug; it is an inherent consequence of the fact that SQL does not promise to deliver the results of a query in any particular order unless &lt;code&gt;ORDER BY&lt;/code&gt; is used to constrain the order.</source>
          <target state="translated">クエリプランナーは、クエリプランを生成するときに &lt;code&gt;LIMIT&lt;/code&gt; を考慮に入れるため、 &lt;code&gt;LIMIT&lt;/code&gt; および &lt;code&gt;OFFSET&lt;/code&gt; に何を使用するかに応じて、異なるプランを取得する（異なる行順序を生成する）可能性が非常に高くなります。したがって、異なる &lt;code&gt;LIMIT&lt;/code&gt; / &lt;code&gt;OFFSET&lt;/code&gt; 値を使用してクエリ結果の異なるサブセットを選択すると、 &lt;code&gt;ORDER BY&lt;/code&gt; で予測可能な結果の順序付けを適用しない限り&lt;em&gt;、一貫性のない結果になり&lt;/em&gt;ます。これはバグではありません。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を使用して順序を制約しない限り、SQLが特定の順序でクエリの結果を提供することを約束しないという事実の本質的な結果です。</target>
        </trans-unit>
        <trans-unit id="4af81e08bfabc175af6208808228c3292ec1d219" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">クエリリライタについては&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章で&lt;/a&gt;詳細に説明しているため、ここで説明する必要はありません。リライターの入力と出力の両方がクエリツリーであること、つまり、ツリーのセマンティックディテールの表現またはレベルに変更がないことのみを指摘します。書き換えはマクロ展開の一種と考えることができます。</target>
        </trans-unit>
        <trans-unit id="294de92ad34c3155980be69ecc50bda8db23e6c8" translate="yes" xml:space="preserve">
          <source>The query rewriter is discussed in some detail in &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;, so there is no need to cover it here. We will only point out that both the input and the output of the rewriter are query trees, that is, there is no change in the representation or level of semantic detail in the trees. Rewriting can be thought of as a form of macro expansion.</source>
          <target state="translated">クエリリライタについては、&lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;第40章で&lt;/a&gt;詳しく説明しているため、ここで説明する必要はありません。リライタの入力と出力の両方がクエリツリーである、つまり、ツリーのセマンティック詳細の表現やレベルに変更がないことだけを指摘します。書き換えは、マクロ展開の一形態と考えることができます。</target>
        </trans-unit>
        <trans-unit id="84cbe05d8623ccd8c2adba905f772e1af6572a6b" translate="yes" xml:space="preserve">
          <source>The query string submitted by the client to create this prepared statement. For prepared statements created via SQL, this is the &lt;code&gt;PREPARE&lt;/code&gt; statement submitted by the client. For prepared statements created via the frontend/backend protocol, this is the text of the prepared statement itself.</source>
          <target state="translated">この準備されたステートメントを作成するためにクライアントによって送信されたクエリ文字列。SQLを介して作成された準備済みステートメントの場合、これはクライアントによって送信された &lt;code&gt;PREPARE&lt;/code&gt; ステートメントです。フロントエンド/バックエンドプロトコルを介して作成された準備済みステートメントの場合、これは準備済みステートメント自体のテキストです。</target>
        </trans-unit>
        <trans-unit id="b1d53885b655d33f7ad2a2d0f4ca8ce4c9afa697" translate="yes" xml:space="preserve">
          <source>The query that is actually sent to the remote server for execution can be examined using &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt;.</source>
          <target state="translated">実際にリモートサーバーに送信されて実行されるクエリは、 &lt;code&gt;EXPLAIN VERBOSE&lt;/code&gt; を使用して調べることができます。</target>
        </trans-unit>
        <trans-unit id="bb7170c364ffc0983c042ed7b707bee01230d841" translate="yes" xml:space="preserve">
          <source>The query tree created by the transformation process is structurally similar to the raw parse tree in most places, but it has many differences in detail. For example, a &lt;code&gt;FuncCall&lt;/code&gt; node in the parse tree represents something that looks syntactically like a function call. This might be transformed to either a &lt;code&gt;FuncExpr&lt;/code&gt; or &lt;code&gt;Aggref&lt;/code&gt; node depending on whether the referenced name turns out to be an ordinary function or an aggregate function. Also, information about the actual data types of columns and expression results is added to the query tree.</source>
          <target state="translated">変換プロセスによって作成されるクエリツリーは、ほとんどの場所で生の解析ツリーと構造的に似ていますが、細部に多くの違いがあります。たとえば、解析ツリーの &lt;code&gt;FuncCall&lt;/code&gt; ノードは、構文的には関数呼び出しのように見えるものを表します。これは、参照された名前が通常の関数であるか集約関数であるかによって、 &lt;code&gt;FuncExpr&lt;/code&gt; または &lt;code&gt;Aggref&lt;/code&gt; ノードに変換される場合があります。また、列の実際のデータ型と式の結果に関する情報がクエリツリーに追加されます。</target>
        </trans-unit>
        <trans-unit id="85e8ce3a8f2eab045a32523ebad51fd65a628dc9" translate="yes" xml:space="preserve">
          <source>The query uses any function marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt;. Most system-defined functions are &lt;code&gt;PARALLEL SAFE&lt;/code&gt;, but user-defined functions are marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; by default. See the discussion of &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt;.</source>
          <target state="translated">クエリは &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; とマークされた関数を使用します。ほとんどのシステム定義関数は &lt;code&gt;PARALLEL SAFE&lt;/code&gt; ですが、ユーザー定義関数はデフォルトで &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; とマークされています。&lt;a href=&quot;parallel-safety&quot;&gt;セクション15.4&lt;/a&gt;の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ae584697a944b3092f1bdba0372976965b96c14e" translate="yes" xml:space="preserve">
          <source>The query writes any data or locks any database rows. If a query contains a data-modifying operation either at the top level or within a CTE, no parallel plans for that query will be generated. As an exception, the commands &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt;, and &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; which create a new table and populate it can use a parallel plan.</source>
          <target state="translated">クエリは、データを書き込むか、データベース行をロックします。クエリに最上位レベルまたはCTE内のいずれかにデータ変更操作が含まれている場合、そのクエリの並列プランは生成されません。例外として、新しいテーブルを作成してデータを追加する &lt;code&gt;CREATE TABLE ... AS&lt;/code&gt; 、 &lt;code&gt;SELECT INTO&lt;/code&gt; 、および &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; コマンドは、並列プランを使用できます。</target>
        </trans-unit>
        <trans-unit id="646431d95f05f7752d11dec325de9bca5192ab21" translate="yes" xml:space="preserve">
          <source>The radius of the Earth is obtained from the &lt;code&gt;earth()&lt;/code&gt; function. It is given in meters. But by changing this one function you can change the module to use some other units, or to use a different value of the radius that you feel is more appropriate.</source>
          <target state="translated">地球の半径は、 &lt;code&gt;earth()&lt;/code&gt; 関数から取得されます。それはメートルで与えられます。ただし、この1つの関数を変更することで、モジュールを変更して他のいくつかの単位を使用したり、より適切と思われる別の半径の値を使用したりできます。</target>
        </trans-unit>
        <trans-unit id="33dd011e0a27c9e4a8da0750e328420ec5636341" translate="yes" xml:space="preserve">
          <source>The range type's &lt;code&gt;subtype&lt;/code&gt; can be any type with an associated b-tree operator class (to determine the ordering of values for the range type). Normally the subtype's default b-tree operator class is used to determine ordering; to use a non-default operator class, specify its name with &lt;code&gt;subtype_opclass&lt;/code&gt;. If the subtype is collatable, and you want to use a non-default collation in the range's ordering, specify the desired collation with the &lt;code&gt;collation&lt;/code&gt; option.</source>
          <target state="translated">範囲タイプの &lt;code&gt;subtype&lt;/code&gt; は、関連するbツリー演算子クラスを持つ任意のタイプにすることができます（範囲タイプの値の順序を決定するため）。通常、サブタイプのデフォルトのbツリー演算子クラスは、順序を決定するために使用されます。デフォルト以外の演算子クラスを使用するには、 &lt;code&gt;subtype_opclass&lt;/code&gt; でその名前を指定します。サブタイプが照合可能であり、デフォルト以外の照合を範囲の順序で使用する場合は、 &lt;code&gt;collation&lt;/code&gt; オプションで目的の照合を指定します。</target>
        </trans-unit>
        <trans-unit id="45e371c3b97fa5eccf6d1070963f8eb35bb332f4" translate="yes" xml:space="preserve">
          <source>The rate is targeted by starting transactions along a Poisson-distributed schedule time line. The expected start time schedule moves forward based on when the client first started, not when the previous transaction ended. That approach means that when transactions go past their original scheduled end time, it is possible for later ones to catch up again.</source>
          <target state="translated">レートは、ポアソン分散されたスケジュールのタイムラインに沿ってトランザクションを開始することによって目標とされています。予想される開始時間のスケジュールは、前のトランザクションがいつ終了したかではなく、クライアントが最初に開始した時間に基づいて進みます。このアプローチは、トランザクションが元の予定された終了時間を過ぎても、後のトランザクションが再び追いつくことが可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="f993d6ebc7309b2d31242d61b21f2b56ac8f6a72" translate="yes" xml:space="preserve">
          <source>The reason for separating raw parsing from semantic analysis is that system catalog lookups can only be done within a transaction, and we do not wish to start a transaction immediately upon receiving a query string. The raw parsing stage is sufficient to identify the transaction control commands (&lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, etc), and these can then be correctly executed without any further analysis. Once we know that we are dealing with an actual query (such as &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;), it is okay to start a transaction if we're not already in one. Only then can the transformation process be invoked.</source>
          <target state="translated">生の解析とセマンティック分析を分離する理由は、システムカタログのルックアップはトランザクション内でのみ実行でき、クエリ文字列を受け取った直後にトランザクションを開始したくないためです。生の解析段階は、トランザクション制御コマンド（ &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;ROLLBACK&lt;/code&gt; など）を識別するのに十分であり、その後、これらをさらに分析することなく正しく実行できます。実際のクエリ（ &lt;code&gt;SELECT&lt;/code&gt; や &lt;code&gt;UPDATE&lt;/code&gt; など）を処理していることがわかったら、トランザクションがまだない場合は、トランザクションを開始してもかまいません。その後でのみ、変換プロセスを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="2555cbea73ebf259be548a413cb3f00d947e85ce" translate="yes" xml:space="preserve">
          <source>The reason that periodic vacuuming solves the problem is that &lt;code&gt;VACUUM&lt;/code&gt; will mark rows as &lt;em&gt;frozen&lt;/em&gt;, indicating that they were inserted by a transaction that committed sufficiently far in the past that the effects of the inserting transaction are certain to be visible to all current and future transactions. Normal XIDs are compared using modulo-2&lt;sup&gt;32&lt;/sup&gt; arithmetic. This means that for every normal XID, there are two billion XIDs that are &amp;ldquo;older&amp;rdquo; and two billion that are &amp;ldquo;newer&amp;rdquo;; another way to say it is that the normal XID space is circular with no endpoint. Therefore, once a row version has been created with a particular normal XID, the row version will appear to be &amp;ldquo;in the past&amp;rdquo; for the next two billion transactions, no matter which normal XID we are talking about. If the row version still exists after more than two billion transactions, it will suddenly appear to be in the future. To prevent this, PostgreSQL reserves a special XID, &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which does not follow the normal XID comparison rules and is always considered older than every normal XID. Frozen row versions are treated as if the inserting XID were &lt;code&gt;FrozenTransactionId&lt;/code&gt;, so that they will appear to be &amp;ldquo;in the past&amp;rdquo; to all normal transactions regardless of wraparound issues, and so such row versions will be valid until deleted, no matter how long that is.</source>
          <target state="translated">定期的なバキューム処理が問題を解決する理由は、 &lt;code&gt;VACUUM&lt;/code&gt; が行を&lt;em&gt;フリーズ&lt;/em&gt;としてマークすることです。これは、過去に十分にコミットされたトランザクションによって行が挿入され、挿入トランザクションの影響が現在および将来のすべてのトランザクションで確実に認識されることを示します。 。通常のXIDはmodulo-2 &lt;sup&gt;32&lt;/sup&gt;を使用して比較されます&lt;sup&gt;&lt;/sup&gt;算術。つまり、通常のXIDごとに、20億個の「古い」XIDと20億個の「新しい」XIDがあります。別の言い方をすると、通常のXID空間は、エンドポイントのない円形であるということです。したがって、特定の通常のXIDを使用して行バージョンが作成されると、どの通常のXIDを使用しているかに関係なく、次の20億トランザクションの行バージョンは「過去」であるように見えます。 20億を超えるトランザクションの後で行バージョンがまだ存在している場合、突然将来的にそうなります。これを防ぐために、PostgreSQLは特別なXID &lt;code&gt;FrozenTransactionId&lt;/code&gt; を予約します。これは、通常のXID比較規則に従わず、常にすべての通常のXIDよりも古いと見なされます。凍結された行バージョンは、挿入するXIDが &lt;code&gt;FrozenTransactionId&lt;/code&gt; であるかのように扱われます。、つまり、ラップアラウンドの問題に関係なく、すべての通常のトランザクションに対して「過去」にあるように見えるため、そのような行バージョンは、どれほど長くても、削除されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="3e52350494447bb6f36961ad4e797bd18a9eb61e" translate="yes" xml:space="preserve">
          <source>The reason that single quotes must be doubled, as shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt;, is that this is true for any string literal in a SQL command. The generic string-literal parser consumes the outermost single quotes and reduces any pair of single quotes to one data character. What the &lt;code&gt;bytea&lt;/code&gt; input function sees is just one single quote, which it treats as a plain data character. However, the &lt;code&gt;bytea&lt;/code&gt; input function treats backslashes as special, and the other behaviors shown in &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; are implemented by that function.</source>
          <target state="translated">&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;に示すように、単一引用符を二重にする必要があるのは、これがSQLコマンドの文字列リテラルに当てはまるためです。汎用文字列リテラルパーサーは、最も外側の単一引用符を使用し、単一引用符のペアを1つのデータ文字に減らします。何 &lt;code&gt;bytea&lt;/code&gt; 型の入力機能が見ると、それはプレーンなデータ文字として扱いますただ一つの引用です。ただし、 &lt;code&gt;bytea&lt;/code&gt; 入力関数はバックスラッシュを特殊なものとして扱い、&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7に&lt;/a&gt;示す他の動作はその関数によって実装されます。</target>
        </trans-unit>
        <trans-unit id="035f0c664448dfa923a884566e84523654a5a8a5" translate="yes" xml:space="preserve">
          <source>The recommended method for configuring shared memory in macOS is to create a file named &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, containing variable assignments such as:</source>
          <target state="translated">macOSで共有メモリを構成するための推奨される方法は、次のような変数の割り当てを含む &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; という名前のファイルを作成することです。</target>
        </trans-unit>
        <trans-unit id="b6faaba60ea4ceaac002ffa0497dd503d8d8e004" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the index and try again to perform &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;. (Another possibility is to rebuild the index with &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">このような場合に推奨される回復方法は、インデックスを削除して、もう一度 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; を実行することです。（別の可能性は &lt;code&gt;REINDEX INDEX CONCURRENTLY&lt;/code&gt; でインデックスを再構築することです）。</target>
        </trans-unit>
        <trans-unit id="65854068ac8d3288768569a456ffe6db4148ee2b" translate="yes" xml:space="preserve">
          <source>The recommended recovery method in such cases is to drop the invalid index and try again to perform &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;. The concurrent index created during the processing has a name ending in the suffix &lt;code&gt;ccnew&lt;/code&gt;, or &lt;code&gt;ccold&lt;/code&gt; if it is an old index definition which we failed to drop. Invalid indexes can be dropped using &lt;code&gt;DROP INDEX&lt;/code&gt;, including invalid toast indexes.</source>
          <target state="translated">このような場合に推奨される回復方法は、無効なインデックスを削除して、 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; を再度実行することです。処理中に作成されたコンカレントインデックスの名前は、末尾が &lt;code&gt;ccnew&lt;/code&gt; で &lt;code&gt;ccold&lt;/code&gt; か、削除に失敗した古いインデックス定義の場合はccoldです。無効なトーストインデックスを含む無効な &lt;code&gt;DROP INDEX&lt;/code&gt; 、DROP INDEXを使用して削除できます。</target>
        </trans-unit>
        <trans-unit id="dfc0dfd0875395d5ad4e9971dc3ba071b3c62b6b" translate="yes" xml:space="preserve">
          <source>The recommended syntax for referencing an ordered-set aggregate is to write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications, in the same style as in &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;. However, it will also work to omit &lt;code&gt;ORDER BY&lt;/code&gt; and just run the direct and aggregated argument specifications into a single list. In this abbreviated form, if &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; was used in both the direct and aggregated argument lists, write &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; only once.</source>
          <target state="translated">順序付き集合集計を参照するための推奨構文は、直接引数と集計引数の指定の間に &lt;code&gt;ORDER BY&lt;/code&gt; を&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;と同じスタイルで記述することです。ただし、 &lt;code&gt;ORDER BY&lt;/code&gt; を省略して、直接および集約された引数指定を1つのリストに実行することもできます。この省略形で、 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; が直接引数リストと集約引数リストの両方で使用されている場合は、 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; を 1回だけ記述します。</target>
        </trans-unit>
        <trans-unit id="2c54b57bbcf06dd2c13692d0332c35778b6cad50" translate="yes" xml:space="preserve">
          <source>The recursive query evaluation algorithm produces its output in breadth-first search order. You can display the results in depth-first search order by making the outer query &lt;code&gt;ORDER BY&lt;/code&gt; a &amp;ldquo;path&amp;rdquo; column constructed in this way.</source>
          <target state="translated">再帰クエリ評価アルゴリズムは、幅優先の検索順序で出力を生成します。このように構築された「パス」列を外部クエリ &lt;code&gt;ORDER BY&lt;/code&gt; にすることで、結果を深さ優先の検索順序で表示できます。</target>
        </trans-unit>
        <trans-unit id="10c71ff4aa80650437aaee9d5a8e7f1f079dae18" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned as the target of a dependent policy object.</source>
          <target state="translated">参照されるオブジェクト(役割でなければならない)は、従属ポリシーオブジェクトの対象として言及されています。</target>
        </trans-unit>
        <trans-unit id="c023a7885506a46d5cd80a1b95eea9a1b30194d8" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is mentioned in the ACL (access control list, i.e., privileges list) of the dependent object. (A &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; entry is not made for the owner of the object, since the owner will have a &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; entry anyway.)</source>
          <target state="translated">参照されるオブジェクト（ロールである必要があります）は、依存オブジェクトのACL（アクセス制御リスト、つまり特権リスト）に記述されています。（所有者はとにかく &lt;code&gt;SHARED_DEPENDENCY_OWNER&lt;/code&gt; エントリを持っているため、オブジェクトの所有者に対して &lt;code&gt;SHARED_DEPENDENCY_ACL&lt;/code&gt; エントリは作成されません。）</target>
        </trans-unit>
        <trans-unit id="b0815ccf510952893128b6ac3763e885ed6f0544" translate="yes" xml:space="preserve">
          <source>The referenced object (which must be a role) is the owner of the dependent object.</source>
          <target state="translated">参照されるオブジェクト(ロールでなければなりません)は、従属オブジェクトの所有者です。</target>
        </trans-unit>
        <trans-unit id="a3a42d2bcdc41726ac7929beb724897943cebede" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">XQueryによって定義された正規表現フラグ文字は、POSIXのオプション文字に関連していますが、同じではありません（&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23&lt;/a&gt;）。一方で &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;q&lt;/code&gt; のオプションは同じように動作し、他の人はそうではありません。</target>
        </trans-unit>
        <trans-unit id="ae81b35c4a3c7dab3568d7bb9b480ebd9e7e6d71" translate="yes" xml:space="preserve">
          <source>The regular expression flag letters defined by XQuery are related to but not the same as the option letters for POSIX (&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;). While the &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; options behave the same, others do not:</source>
          <target state="translated">XQueryによって定義された正規表現フラグ文字は、POSIXのオプション文字に関連していますが、同じではありません（&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.24&lt;/a&gt;）。一方で &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;q&lt;/code&gt; のオプションは同じように動作し、他の人はそうではありません。</target>
        </trans-unit>
        <trans-unit id="ba9e7d00d7dfab39d193126f7366a926fa396e54" translate="yes" xml:space="preserve">
          <source>The relevant files have to be installed into &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; and a summary of them into &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt;, where &lt;code&gt;$pkglibdir&lt;/code&gt; is the directory returned by &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; and &lt;code&gt;$extension&lt;/code&gt; is the base name of the extension's shared library.</source>
          <target state="translated">関連するファイルをにインストールする必要があります &lt;code&gt;$pkglibdir/bitcode/$extension/&lt;/code&gt; へのそれらの概要と &lt;code&gt;$pkglibdir/bitcode/$extension.index.bc&lt;/code&gt; 、 &lt;code&gt;$pkglibdir&lt;/code&gt; で返されるディレクトリで &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; と &lt;code&gt;$extension&lt;/code&gt; あります拡張機能の共有ライブラリのベース名。</target>
        </trans-unit>
        <trans-unit id="6ba726b7abb409f8a48dfda787ffd9ea8e7624bd" translate="yes" xml:space="preserve">
          <source>The relevant settings can be changed in &lt;code&gt;/etc/system&lt;/code&gt;, for example:</source>
          <target state="translated">関連する設定は &lt;code&gt;/etc/system&lt;/code&gt; で変更できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="7fd56dd803d0f7d0e1d83485ba93a1ea518a48b4" translate="yes" xml:space="preserve">
          <source>The remaining defaults are quite generously sized, and usually do not require changes.</source>
          <target state="translated">残りのデフォルトはかなり余裕のあるサイズで、通常は変更を必要としません。</target>
        </trans-unit>
        <trans-unit id="e214a53b19603c5bd3de31f71ebb545b28127eb2" translate="yes" xml:space="preserve">
          <source>The remaining five input formats are not part of any standard.</source>
          <target state="translated">残りの5つの入力フォーマットは、どの規格にも属していません。</target>
        </trans-unit>
        <trans-unit id="a23206cc28b1e52f80477ca74330c7ee7d48a063" translate="yes" xml:space="preserve">
          <source>The remaining forms change the session default for a run-time configuration variable for a PostgreSQL database. Whenever a new session is subsequently started in that database, the specified value becomes the session default value. The database-specific default overrides whatever setting is present in &lt;code&gt;postgresql.conf&lt;/code&gt; or has been received from the &lt;code&gt;postgres&lt;/code&gt; command line. Only the database owner or a superuser can change the session defaults for a database. Certain variables cannot be set this way, or can only be set by a superuser.</source>
          <target state="translated">残りのフォームは、PostgreSQLデータベースのランタイム構成変数のセッションデフォルトを変更します。その後、そのデータベースで新しいセッションが開始されると、指定された値がセッションのデフォルト値になります。データベース固有のデフォルトは、 &lt;code&gt;postgresql.conf&lt;/code&gt; に存在する設定、または &lt;code&gt;postgres&lt;/code&gt; コマンドラインから受け取った設定を上書きします。データベースのセッションのデフォルトを変更できるのは、データベースの所有者またはスーパーユーザーだけです。特定の変数はこの方法では設定できません。またはスーパーユーザーのみが設定できます。</target>
        </trans-unit>
        <trans-unit id="657f4dc87f97eb4fa07203598556b9c37fdd908d" translate="yes" xml:space="preserve">
          <source>The remaining locale categories can be changed later when the server is started. You can also use &lt;code&gt;--locale&lt;/code&gt; to set the default for all locale categories, including collation order and character set classes. All server locale values (&lt;code&gt;lc_*&lt;/code&gt;) can be displayed via &lt;code&gt;SHOW ALL&lt;/code&gt;. More details can be found in &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt;.</source>
          <target state="translated">残りのロケールカテゴリは、後でサーバーを起動したときに変更できます。 &lt;code&gt;--locale&lt;/code&gt; を使用して、照合順序や文字セットクラスを含むすべてのロケールカテゴリのデフォルトを設定することもできます。すべてのサーバーロケール値（ &lt;code&gt;lc_*&lt;/code&gt; ）は、 &lt;code&gt;SHOW ALL&lt;/code&gt; を使用して表示できます。詳細については、&lt;a href=&quot;locale&quot;&gt;セクション23.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="39583e46f87084afedd4c54635cee3575eddc6c6" translate="yes" xml:space="preserve">
          <source>The remaining variants change a role's session default for a configuration variable, either for all databases or, when the &lt;code&gt;IN DATABASE&lt;/code&gt; clause is specified, only for sessions in the named database. If &lt;code&gt;ALL&lt;/code&gt; is specified instead of a role name, this changes the setting for all roles. Using &lt;code&gt;ALL&lt;/code&gt; with &lt;code&gt;IN DATABASE&lt;/code&gt; is effectively the same as using the command &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt;.</source>
          <target state="translated">残りのバリアントは、すべてのデータベース、または &lt;code&gt;IN DATABASE&lt;/code&gt; 句が指定されている場合は、指定されたデータベース内のセッションに対してのみ、構成変数のロールのセッションデフォルトを変更します。場合は &lt;code&gt;ALL&lt;/code&gt; がロール名の代わりに指定され、これは、すべての役割の設定を変更します。使い方 &lt;code&gt;ALL&lt;/code&gt; をし &lt;code&gt;IN DATABASE&lt;/code&gt; 効果的にコマンド使用するのと同じです &lt;code&gt;ALTER DATABASE ... SET ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5290f23dd3a823420c1c9cce7d4e8058bd8eb3fa" translate="yes" xml:space="preserve">
          <source>The remaining variants change the owner and the name of the publication.</source>
          <target state="translated">残りの亜種は、所有者と出版物の名前を変更します。</target>
        </trans-unit>
        <trans-unit id="fd818ebf2b83e4b29f88c818dcaf7941b628e1ea" translate="yes" xml:space="preserve">
          <source>The remote schema to import from. The specific meaning of a remote schema depends on the foreign data wrapper in use.</source>
          <target state="translated">インポート元のリモートスキーマ。リモートスキーマの特定の意味は、使用している外部データラッパーに依存します。</target>
        </trans-unit>
        <trans-unit id="c2f6cfebe2ad1dd2cbdde5a3b92b04d140d615ff" translate="yes" xml:space="preserve">
          <source>The remote transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level when the local transaction has &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation level; otherwise it uses &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level. This choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans. A consequence is that successive queries within a single transaction will see the same data from the remote server, even if concurrent updates are occurring on the remote server due to other activities. That behavior would be expected anyway if the local transaction uses &lt;code&gt;SERIALIZABLE&lt;/code&gt; or &lt;code&gt;REPEATABLE READ&lt;/code&gt; isolation level, but it might be surprising for a &lt;code&gt;READ COMMITTED&lt;/code&gt; local transaction. A future PostgreSQL release might modify these rules.</source>
          <target state="translated">ローカルトランザクションに &lt;code&gt;SERIALIZABLE&lt;/code&gt; 分離レベルがある場合、リモートトランザクションは &lt;code&gt;SERIALIZABLE&lt;/code&gt; 分離レベルを使用します。それ以外の場合は、 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 分離レベルを使用します。この選択により、クエリがリモートサーバーで複数のテーブルスキャンを実行する場合、すべてのスキャンでスナップショットの一貫した結果が得られます。結果として、他のアクティビティによってリモートサーバーで同時更新が発生している場合でも、単一のトランザクション内の連続したクエリは、リモートサーバーから同じデータを参照します。ローカルトランザクションが &lt;code&gt;SERIALIZABLE&lt;/code&gt; または &lt;code&gt;REPEATABLE READ&lt;/code&gt; 分離レベルを使用している場合は、とにかくその動作が予想されますが、 &lt;code&gt;READ COMMITTED&lt;/code&gt; の場合は驚くかもしれません。ローカルトランザクション。将来のPostgreSQLリリースでは、これらのルールが変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b784ef85aba666ab41976b71fec7b8c205701bef" translate="yes" xml:space="preserve">
          <source>The reported &lt;code&gt;index_size&lt;/code&gt; will normally correspond to one more page than is accounted for by &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt;, because it also includes the index's metapage.</source>
          <target state="translated">報告された &lt;code&gt;index_size&lt;/code&gt; は、インデックスのメタページも含まれているため、 &lt;code&gt;internal_pages + leaf_pages + empty_pages + deleted_pages&lt;/code&gt; 、internal_pages + leaf_pages + empty_pages + deleted_pa​​gesで説明されているよりも1つ多いページに対応します。</target>
        </trans-unit>
        <trans-unit id="55f0c215e7b27076f4a6dfbf779db270819931cc" translate="yes" xml:space="preserve">
          <source>The reported lag times are not predictions of how long it will take for the standby to catch up with the sending server assuming the current rate of replay. Such a system would show similar times while new WAL is being generated, but would differ when the sender becomes idle. In particular, when the standby has caught up completely, &lt;code&gt;pg_stat_replication&lt;/code&gt; shows the time taken to write, flush and replay the most recent reported WAL location rather than zero as some users might expect. This is consistent with the goal of measuring synchronous commit and transaction visibility delays for recent write transactions. To reduce confusion for users expecting a different model of lag, the lag columns revert to NULL after a short time on a fully replayed idle system. Monitoring systems should choose whether to represent this as missing data, zero or continue to display the last known value.</source>
          <target state="translated">報告された遅延時間は、現在の再生速度を想定して、スタンバイが送信サーバーに追いつくのにかかる時間の予測ではありません。このようなシステムは、新しいWALが生成されている間も同様の時間を示しますが、送信者がアイドルになると異なります。特に、スタンバイが完全に追いついた場合、 &lt;code&gt;pg_stat_replication&lt;/code&gt; は、一部のユーザーが予想するようなゼロではなく、最新の報告されたWALロケーションの書き込み、フラッシュ、および再生にかかる時間を示しています。これは、最近の書き込みトランザクションの同期コミットおよびトランザクション可視性遅延を測定するという目標と一致しています。ラグの異なるモデルを期待しているユーザーの混乱を減らすために、完全に再生されたアイドルシステムで少し時間が経過すると、ラグ列がNULLに戻ります。監視システムは、これを欠落データとして表すか、ゼロにするか、または最後の既知の値を表示し続けるかを選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="a645551df2ec2063cbaae776527e78ce19d49632" translate="yes" xml:space="preserve">
          <source>The representative query texts are kept in an external disk file, and do not consume shared memory. Therefore, even very lengthy query texts can be stored successfully. However, if many long query texts are accumulated, the external file might grow unmanageably large. As a recovery method if that happens, &lt;code&gt;pg_stat_statements&lt;/code&gt; may choose to discard the query texts, whereupon all existing entries in the &lt;code&gt;pg_stat_statements&lt;/code&gt; view will show null &lt;code&gt;query&lt;/code&gt; fields, though the statistics associated with each &lt;code&gt;queryid&lt;/code&gt; are preserved. If this happens, consider reducing &lt;code&gt;pg_stat_statements.max&lt;/code&gt; to prevent recurrences.</source>
          <target state="translated">代表的なクエリテキストは外部ディスクファイルに保存され、共有メモリを消費しません。したがって、非常に長いクエリテキストでも正常に保存できます。ただし、長いクエリテキストが多数蓄積されると、外部ファイルが管理できないほど大きくなる可能性があります。これが発生した場合の回復方法として、 &lt;code&gt;pg_stat_statements&lt;/code&gt; はクエリテキストを破棄することを選択できます。これにより、 &lt;code&gt;pg_stat_statements&lt;/code&gt; ビューの既存のすべてのエントリにnull &lt;code&gt;query&lt;/code&gt; フィールドが表示されますが、各 &lt;code&gt;queryid&lt;/code&gt; 関連付けられた統計は保持されます。これが発生した場合は、 &lt;code&gt;pg_stat_statements.max&lt;/code&gt; を減らして再発を防止することを検討してください。</target>
        </trans-unit>
        <trans-unit id="af46176f2702f864ba766599fbfd240339b13483" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;COLUMNS&lt;/code&gt; clause specifies the column(s) that will be produced in the output table. See the syntax summary above for the format. A name is required for each column, as is a data type (unless &lt;code&gt;FOR ORDINALITY&lt;/code&gt; is specified, in which case type &lt;code&gt;integer&lt;/code&gt; is implicit). The path, default and nullability clauses are optional.</source>
          <target state="translated">必須の &lt;code&gt;COLUMNS&lt;/code&gt; 句は、出力テーブルに生成される列を指定します。形式については、上記の構文の概要を参照してください。データ型と同様に、各列には名前が必要です（ &lt;code&gt;FOR ORDINALITY&lt;/code&gt; が指定されている場合を除きます。指定されている場合、型 &lt;code&gt;integer&lt;/code&gt; は暗黙的です）。 path、default、およびnullability句はオプションです。</target>
        </trans-unit>
        <trans-unit id="7e8d7c0fc3cb406e8f13266456fbfe6097e7dd7f" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression (given as &lt;code&gt;text&lt;/code&gt;) that is evaluated, passing the XML value &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">必要な &lt;code&gt;row_expression&lt;/code&gt; 引数は、XMLノードのセットを取得するためにXML値 &lt;code&gt;document_expression&lt;/code&gt; をコンテキスト項目として渡して評価されるXPath 1.0式（ &lt;code&gt;text&lt;/code&gt; として指定）です。これらのノードは、 &lt;code&gt;xmltable&lt;/code&gt; が出力行に変換するものです。 &lt;code&gt;document_expression&lt;/code&gt; がnullの場合、 &lt;code&gt;row_expression&lt;/code&gt; が空のノードセットまたはノードセット以外の値を生成する場合、行は生成されません。</target>
        </trans-unit>
        <trans-unit id="0ec95cfaa7fde5c159e36da65695933b4d1251cc" translate="yes" xml:space="preserve">
          <source>The required &lt;code&gt;row_expression&lt;/code&gt; argument is an XPath 1.0 expression that is evaluated, passing the &lt;code&gt;document_expression&lt;/code&gt; as its context item, to obtain a set of XML nodes. These nodes are what &lt;code&gt;xmltable&lt;/code&gt; transforms into output rows. No rows will be produced if the &lt;code&gt;document_expression&lt;/code&gt; is null, nor if the &lt;code&gt;row_expression&lt;/code&gt; produces an empty node-set or any value other than a node-set.</source>
          <target state="translated">必要な &lt;code&gt;row_expression&lt;/code&gt; 引数は、XMLノードのセットを取得するために &lt;code&gt;document_expression&lt;/code&gt; をコンテキストアイテムとして渡して評価されるXPath 1.0式です。これらのノードは、 &lt;code&gt;xmltable&lt;/code&gt; が出力行に変換するものです。 &lt;code&gt;document_expression&lt;/code&gt; がnullの場合、 &lt;code&gt;row_expression&lt;/code&gt; が空のノードセットまたはノードセット以外の値を生成する場合、行は生成されません。</target>
        </trans-unit>
        <trans-unit id="b11399ca691e0ca5b399e8672e2715124cece495" translate="yes" xml:space="preserve">
          <source>The requirement to escape &lt;em&gt;non-printable&lt;/em&gt; octets varies depending on locale settings. In some instances you can get away with leaving them unescaped.</source>
          <target state="translated">&lt;em&gt;印刷不可能な&lt;/em&gt;オクテットをエスケープする要件は、ロケール設定によって異なります。場合によっては、エスケープせずにそのままにしておくことができます。</target>
        </trans-unit>
        <trans-unit id="b1fdcf794bda35b8905b9d7b4d4c5b307eaf0f21" translate="yes" xml:space="preserve">
          <source>The resolution can be done either by changing data on the subscriber so that it does not conflict with the incoming change or by skipping the transaction that conflicts with the existing data. The transaction can be skipped by calling the &lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt;&lt;code&gt;pg_replication_origin_advance()&lt;/code&gt;&lt;/a&gt; function with a &lt;em&gt;&lt;code&gt;node_name&lt;/code&gt;&lt;/em&gt; corresponding to the subscription name, and a position. The current position of origins can be seen in the &lt;a href=&quot;view-pg-replication-origin-status&quot;&gt;&lt;code&gt;pg_replication_origin_status&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">解決は、受信した変更と競合しないようにサブスクライバーのデータを変更するか、既存のデータと競合するトランザクションをスキップすることによって実行できます。サブスクリプション名に対応する&lt;em&gt; &lt;code&gt;node_name&lt;/code&gt; &lt;/em&gt;と位置を指定して&lt;a href=&quot;functions-admin#PG-REPLICATION-ORIGIN-ADVANCE&quot;&gt; &lt;code&gt;pg_replication_origin_advance()&lt;/code&gt; &lt;/a&gt;関数を呼び出すことにより、トランザクションをスキップできます。起点の現在の位置は、&lt;a href=&quot;view-pg-replication-origin-status&quot;&gt; &lt;code&gt;pg_replication_origin_status&lt;/code&gt; &lt;/a&gt;システムビューで確認できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="723a98a8202cef2494a119e8677686ce411c0bb4" translate="yes" xml:space="preserve">
          <source>The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the &lt;code&gt;\lo_list&lt;/code&gt; command.</source>
          <target state="translated">応答は、ラージオブジェクトがオブジェクトID 152801を受け取ったことを示します。これは、新しく作成されたラージオブジェクトに将来アクセスするために使用できます。読みやすくするために、常に人間が読めるコメントをすべてのオブジェクトに関連付けることをお勧めします。OIDとコメントの両方は、 &lt;code&gt;\lo_list&lt;/code&gt; コマンドで表示できます。</target>
        </trans-unit>
        <trans-unit id="2934d0e903001f7986e041f38eab1c8c1f288032" translate="yes" xml:space="preserve">
          <source>The restriction for the join is &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt;. The operator is just our familiar &lt;code&gt;=&lt;/code&gt;, however the selectivity function is obtained from the &lt;code&gt;oprjoin&lt;/code&gt; column of &lt;code&gt;pg_operator&lt;/code&gt;, and is &lt;code&gt;eqjoinsel&lt;/code&gt;. &lt;code&gt;eqjoinsel&lt;/code&gt; looks up the statistical information for both &lt;code&gt;tenk2&lt;/code&gt; and &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">結合の制限は &lt;code&gt;t2.unique2 = t1.unique2&lt;/code&gt; です。操作者は、私たちのよく知られている &lt;code&gt;=&lt;/code&gt; しかし、選択関数から得られる、 &lt;code&gt;oprjoin&lt;/code&gt; 用のカラム &lt;code&gt;pg_operator&lt;/code&gt; 、及びある &lt;code&gt;eqjoinsel&lt;/code&gt; 。 &lt;code&gt;eqjoinsel&lt;/code&gt; は &lt;code&gt;tenk2&lt;/code&gt; と &lt;code&gt;tenk1&lt;/code&gt; の両方の統計情報を検索します。</target>
        </trans-unit>
        <trans-unit id="42ea840e6963b1db2f144f830a72190a8a92d8a7" translate="yes" xml:space="preserve">
          <source>The restriction on &lt;code&gt;tenk1&lt;/code&gt;, &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt;, is evaluated before the nested-loop join. This is handled analogously to the previous range example. This time the value 50 falls into the first bucket of the &lt;code&gt;unique1&lt;/code&gt; histogram:</source>
          <target state="translated">上の制限 &lt;code&gt;tenk1&lt;/code&gt; 、 &lt;code&gt;unique1 &amp;lt; 50&lt;/code&gt; 、ネストされたループが参加する前に、評価されます。これは、前の範囲の例と同様に処理されます。今回は、値50が &lt;code&gt;unique1&lt;/code&gt; ヒストグラムの最初のバケットに分類されます。</target>
        </trans-unit>
        <trans-unit id="80154a0c17a7ca3699a207d67e1600353cb2e59b" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator.</source>
          <target state="translated">この演算子の制限選択性推定関数。</target>
        </trans-unit>
        <trans-unit id="c1e9d6876e675991a0158e89b5c587ee7ffe971a" translate="yes" xml:space="preserve">
          <source>The restriction selectivity estimator function for this operator; write NONE to remove existing selectivity estimator.</source>
          <target state="translated">この演算子の制限選択性推定関数;既存の選択性推定関数を削除するにはNONEを書く。</target>
        </trans-unit>
        <trans-unit id="bff27a668430c02df3bea2ab6b32530d85a3310d" translate="yes" xml:space="preserve">
          <source>The result has the same type as the first argument &amp;mdash; but there is a subtlety. What is actually returned is the first argument of the implied &lt;code&gt;=&lt;/code&gt; operator, and in some cases that will have been promoted to match the second argument's type. For example, &lt;code&gt;NULLIF(1, 2.2)&lt;/code&gt; yields &lt;code&gt;numeric&lt;/code&gt;, because there is no &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt; operator, only &lt;code&gt;numeric&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">結果は最初の引数と同じタイプですが、微妙な点があります。実際に返されるのは、暗黙の &lt;code&gt;=&lt;/code&gt; 演算子の最初の引数であり、場合によっては、2番目の引数の型と一致するようにプロモートされます。たとえば、 &lt;code&gt;NULLIF(1, 2.2)&lt;/code&gt; は、 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; 演算子がなく、 &lt;code&gt;numeric&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;numeric&lt;/code&gt; のみであるため、 &lt;code&gt;numeric&lt;/code&gt; 生成します。</target>
        </trans-unit>
        <trans-unit id="e176f734fe6408fc6b88696f88ea896277748c08" translate="yes" xml:space="preserve">
          <source>The result is equivalent to replacing the target data directory with the source one. Only changed blocks from relation files are copied; all other files are copied in full, including configuration files. The advantage of pg_rewind over taking a new base backup, or tools like rsync, is that pg_rewind does not require reading through unchanged blocks in the cluster. This makes it a lot faster when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">この結果は、ターゲットのデータディレクトリをソースのデータディレクトリに置き換えるのと同じです。リレーションファイルから変更されたブロックのみがコピーされ、他のすべてのファイルは設定ファイルを含めて完全にコピーされます。pg_rewindの利点は、新しいベースバックアップやrsyncのようなツールを使用するよりも、pg_rewindがクラスタ内の変更されていないブロックを読み込む必要がないことです。これにより、データベースが大規模で、クラスタ間でブロックのごく一部が異なるだけの場合には、非常に高速になります。</target>
        </trans-unit>
        <trans-unit id="71c257a34cf97f05e33ccd5803182c14ff7c7772" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt;.</source>
          <target state="translated">結果は &lt;code&gt;/CN=Somebody /C=Some country/O=Some organization&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="465e9b5b70493d1bded19fc1f9a4a0487651fc46" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear max(&lt;code&gt;m&lt;/code&gt;-&lt;code&gt;n&lt;/code&gt;,0) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; オプションを指定しない限り、 &lt;code&gt;EXCEPT&lt;/code&gt; の結果には重複行は含まれません。 &lt;code&gt;ALL&lt;/code&gt; 有する行 &lt;code&gt;m&lt;/code&gt; 左テーブルとで重複を &lt;code&gt;n&lt;/code&gt; 右側のテーブルに重複が最大（表示される &lt;code&gt;m&lt;/code&gt; - &lt;code&gt;n&lt;/code&gt; は結果セットの回数、0）。 &lt;code&gt;DISTINCT&lt;/code&gt; を記述して、重複行を排除するデフォルトの動作を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="8e065829e339ca2263a957857644dcd1c568a754" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;INTERSECT&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. With &lt;code&gt;ALL&lt;/code&gt;, a row that has &lt;code&gt;m&lt;/code&gt; duplicates in the left table and &lt;code&gt;n&lt;/code&gt; duplicates in the right table will appear min(&lt;code&gt;m&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;) times in the result set. &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; オプションを指定しない限り、 &lt;code&gt;INTERSECT&lt;/code&gt; の結果には重複行は含まれません。 &lt;code&gt;ALL&lt;/code&gt; 有する行 &lt;code&gt;m&lt;/code&gt; 左テーブルとで重複 &lt;code&gt;n&lt;/code&gt; 分（表示され、右表の重複を &lt;code&gt;m&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; は結果セット内の）回。 &lt;code&gt;DISTINCT&lt;/code&gt; を記述して、重複行を排除するデフォルトの動作を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="2ef35ef4ee4e7ace61e6bdb22721c0932c911c40" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;UNION&lt;/code&gt; does not contain any duplicate rows unless the &lt;code&gt;ALL&lt;/code&gt; option is specified. &lt;code&gt;ALL&lt;/code&gt; prevents elimination of duplicates. (Therefore, &lt;code&gt;UNION ALL&lt;/code&gt; is usually significantly quicker than &lt;code&gt;UNION&lt;/code&gt;; use &lt;code&gt;ALL&lt;/code&gt; when you can.) &lt;code&gt;DISTINCT&lt;/code&gt; can be written to explicitly specify the default behavior of eliminating duplicate rows.</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; オプションを指定しない限り、 &lt;code&gt;UNION&lt;/code&gt; の結果には重複行は含まれません。 &lt;code&gt;ALL&lt;/code&gt; は重複の排除を防ぎます。（したがって、 &lt;code&gt;UNION ALL&lt;/code&gt; は通常 &lt;code&gt;UNION&lt;/code&gt; よりもかなり高速です。可能な場合は &lt;code&gt;ALL&lt;/code&gt; を使用してください。） &lt;code&gt;DISTINCT&lt;/code&gt; を記述して、重複行を排除するデフォルトの動作を明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="72402b7b0b331fd1b54d5308fde49885c6b05ef8" translate="yes" xml:space="preserve">
          <source>The result of a database content mapping looks like this:</source>
          <target state="translated">データベースのコンテンツマッピングの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5bf0f22088cf3019c1a1b1dbed662be7a69e9148" translate="yes" xml:space="preserve">
          <source>The result of a schema content mapping looks like this:</source>
          <target state="translated">スキーマのコンテンツマッピングの結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="31f7fafc96662c4abec5838f93938c08f12e39f5" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.15.2.3&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get an array size:</source>
          <target state="translated">各パス評価ステップの結果は、&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;セクション9.15.2.3に&lt;/a&gt;リストされている1つ以上の &lt;code&gt;jsonpath&lt;/code&gt; オペレーターおよびメソッドによって処理できます。各メソッド名の前にはドットを付ける必要があります。たとえば、配列サイズを取得できます。</target>
        </trans-unit>
        <trans-unit id="ec7ce6cfc1de15ad9d69c5a41b7880b123d8687e" translate="yes" xml:space="preserve">
          <source>The result of each path evaluation step can be processed by one or more &lt;code&gt;jsonpath&lt;/code&gt; operators and methods listed in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;. Each method name must be preceded by a dot. For example, you can get the size of an array:</source>
          <target state="translated">各パス評価ステップの結果は、&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;セクション9.16.2.2に&lt;/a&gt;リストされている1つ以上の &lt;code&gt;jsonpath&lt;/code&gt; 演算子およびメソッドによって処理できます。各メソッド名の前にはドットを付ける必要があります。たとえば、配列のサイズを取得できます。</target>
        </trans-unit>
        <trans-unit id="2c39389298dad4176af2cd2f4f928038308a6b18" translate="yes" xml:space="preserve">
          <source>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</source>
          <target state="translated">トランザクションのグループを正常にコミットした結果は、それらのトランザクションを一度に一つずつ実行するすべての可能な順序と矛盾しています。</target>
        </trans-unit>
        <trans-unit id="f90d6b2c73e8ea4c0551da0df475a8d425331eb2" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;union&lt;/code&gt; function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The &lt;code&gt;union&lt;/code&gt; function should return a pointer to newly &lt;code&gt;palloc()&lt;/code&gt;ed memory. You can't just return the input value as-is, even if there is no type change.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 関数の結果は、インデックスのストレージタイプの値である必要があります（それがインデックス付きの列のタイプと異なる場合と異なる場合があります）。 &lt;code&gt;union&lt;/code&gt; 機能が新しくへのポインタを返す必要があります &lt;code&gt;palloc()&lt;/code&gt; 編メモリ。型の変更がない場合でも、入力値をそのまま返すことはできません。</target>
        </trans-unit>
        <trans-unit id="1b294fef53c3a5221592cc68d2bcc8aa48d712cd" translate="yes" xml:space="preserve">
          <source>The result of the function is a single record. The &lt;em&gt;&lt;code&gt;lsn&lt;/code&gt;&lt;/em&gt; column holds the backup's ending write-ahead log location (which again can be ignored). The second and third columns are &lt;code&gt;NULL&lt;/code&gt; when ending an exclusive backup; after a non-exclusive backup they hold the desired contents of the label and tablespace map files.</source>
          <target state="translated">関数の結果は単一のレコードです。&lt;em&gt; &lt;code&gt;lsn&lt;/code&gt; &lt;/em&gt;列は（再び無視することができます）、バックアップの終了先行書き込みログの場所を保持しています。排他バックアップを終了するとき、2番目と3番目の列は &lt;code&gt;NULL&lt;/code&gt; です。非排他的バックアップの後、ラベルおよびテーブルスペースマップファイルの目的の内容を保持します。</target>
        </trans-unit>
        <trans-unit id="b4a9c39c953a9312145a45ccbb983953c2e08ee1" translate="yes" xml:space="preserve">
          <source>The result of the previous two inserts looks like this:</source>
          <target state="translated">前の2つのインサートの結果はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="b464f588a5c51e3217548207540b5bba236a02d5" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;setval&lt;/code&gt; is just the value of its second argument.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; によって返される結果は、2番目の引数の値です。</target>
        </trans-unit>
        <trans-unit id="94a3bc7cb16b6aa14b4272070826c46eaa5db71f" translate="yes" xml:space="preserve">
          <source>The result type of the &lt;code&gt;datetime()&lt;/code&gt; and &lt;code&gt;datetime(template)&lt;/code&gt; methods can be &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timetz&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamptz&lt;/code&gt;, or &lt;code&gt;timestamp&lt;/code&gt;. Both methods determine their result type dynamically.</source>
          <target state="translated">結果タイプ &lt;code&gt;datetime()&lt;/code&gt; と &lt;code&gt;datetime(template)&lt;/code&gt; の方法があってもよい &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;timetz&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;timestamptz&lt;/code&gt; 、または &lt;code&gt;timestamp&lt;/code&gt; 。どちらの方法も、結果タイプを動的に決定します。</target>
        </trans-unit>
        <trans-unit id="5675fc85ce2eab9d13414767f82a9b7b9d9a68bc" translate="yes" xml:space="preserve">
          <source>The resulting dump can be restored with psql:</source>
          <target state="translated">結果のダンプはpsqlでリストアできます。</target>
        </trans-unit>
        <trans-unit id="bd98dcbc013dfe386ef25cd013047250a70319f2" translate="yes" xml:space="preserve">
          <source>The results of the &lt;code&gt;in_range&lt;/code&gt; function must be consistent with the sort ordering imposed by the operator family. To be precise, given any fixed values of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 関数の結果は、演算子族によって課されるソート順と一致している必要があります。正確には、 &lt;code&gt;offset&lt;/code&gt; と &lt;code&gt;sub&lt;/code&gt; の固定値を指定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="09c3bbabf641766b5c1086657a825502c1601a40" translate="yes" xml:space="preserve">
          <source>The results of two queries can be combined using the set operations union, intersection, and difference. The syntax is</source>
          <target state="translated">2つのクエリの結果は、集合演算の union、intersection、および difference を使用して結合することができます。構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6af5cccdc36b9ba47ebe00f94b9f0ae450f2173e" translate="yes" xml:space="preserve">
          <source>The return data type (optionally schema-qualified). The return type can be a base, composite, or domain type, or can reference the type of a table column. Depending on the implementation language it might also be allowed to specify &amp;ldquo;pseudo-types&amp;rdquo; such as &lt;code&gt;cstring&lt;/code&gt;. If the function is not supposed to return a value, specify &lt;code&gt;void&lt;/code&gt; as the return type.</source>
          <target state="translated">戻りデータ型（オプションでスキーマ修飾）。戻り値の型は、基本型、複合型、またはドメイン型であるか、テーブル列の型を参照できます。実装言語によっては、 &lt;code&gt;cstring&lt;/code&gt; などの「疑似タイプ」を指定することも許可される場合があります。関数が値を返すことが想定されていない場合は、戻り値の型として &lt;code&gt;void&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="68f515e9225e3a8bd926fdcf278047adb080a143" translate="yes" xml:space="preserve">
          <source>The return type of a cast function must be identical to or binary-coercible to the cast's target type.</source>
          <target state="translated">キャスト関数の戻り値の型は、キャストのターゲット型と同じか、バイナリ互換でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e79b9ffc9a06ade0f94c181bff76d0c5e0055f02" translate="yes" xml:space="preserve">
          <source>The return type of each function is &lt;code&gt;xml&lt;/code&gt;.</source>
          <target state="translated">各関数の戻り値の型は &lt;code&gt;xml&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2ccb6d89ec3d8d5f1a14886d00086edc74d4f798" translate="yes" xml:space="preserve">
          <source>The return value is static information about an operator class and collation. Returning &lt;code&gt;true&lt;/code&gt; indicates that the &lt;code&gt;order&lt;/code&gt; function for the operator class is guaranteed to only return &lt;code&gt;0&lt;/code&gt; (&amp;ldquo;arguments are equal&amp;rdquo;) when its &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arguments are also interchangeable without any loss of semantic information. Not registering an &lt;code&gt;equalimage&lt;/code&gt; function or returning &lt;code&gt;false&lt;/code&gt; indicates that this condition cannot be assumed to hold.</source>
          <target state="translated">戻り値は、演算子クラスと照合順序に関する静的情報です。 &lt;code&gt;true&lt;/code&gt; を返すことは、演算子クラスの &lt;code&gt;order&lt;/code&gt; 関数が、セマンティック情報を失うことなく &lt;code&gt;A&lt;/code&gt; 引数と &lt;code&gt;B&lt;/code&gt; 引数も交換可能である場合に、 &lt;code&gt;0&lt;/code&gt; （「引数が等しい」）のみを返すことが保証されていることを示します。 &lt;code&gt;equalimage&lt;/code&gt; 関数を登録しない、または &lt;code&gt;false&lt;/code&gt; を返す場合は、この条件が成立すると想定できないことを示します。</target>
        </trans-unit>
        <trans-unit id="ae53d800dbf466337096571156e983ea2cef4a1a" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;BrinMemTuple&lt;/code&gt; and &lt;code&gt;BrinValues&lt;/code&gt; structs. See &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; for details.</source>
          <target state="translated">返される列は、 &lt;code&gt;BrinMemTuple&lt;/code&gt; および &lt;code&gt;BrinValues&lt;/code&gt; 構造体のフィールドに対応しています。詳細については、 &lt;code&gt;src/include/access/brin_tuple.h&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="cbe5a0ea635cc6baf516f6e2eb370c36b529a917" translate="yes" xml:space="preserve">
          <source>The returned columns correspond to the fields in the &lt;code&gt;PageHeaderData&lt;/code&gt; struct. See &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; for details.</source>
          <target state="translated">返される列は、 &lt;code&gt;PageHeaderData&lt;/code&gt; 構造体のフィールドに対応しています。詳細については、 &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="9ce8dcca026fdd1326a0feb6d5dcbe4fd79aa2a7" translate="yes" xml:space="preserve">
          <source>The rewriting forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; are not MVCC-safe. After a table rewrite, the table will appear empty to concurrent transactions, if they are using a snapshot taken before the rewrite occurred. See &lt;a href=&quot;mvcc-caveats&quot;&gt;Section 13.5&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; の書き換え形式はMVCCセーフではありません。テーブルの再書き込み後、再書き込みが行われる前に作成されたスナップショットを使用している場合、テーブルは同時トランザクションに対して空のように見えます。詳細については、&lt;a href=&quot;mvcc-caveats&quot;&gt;セクション13.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9dd9c3f397a07f60ffdbedaa5659c2ca90ab6d90" translate="yes" xml:space="preserve">
          <source>The right to drop an object, or to alter its definition in any way, is not treated as a grantable privilege; it is inherent in the owner, and cannot be granted or revoked. (However, a similar effect can be obtained by granting or revoking membership in the role that owns the object; see below.) The owner implicitly has all grant options for the object, too.</source>
          <target state="translated">オブジェクトを削除したり、その定義を変更したりする権利は、付与可能な特権としては扱われません。(ただし、オブジェクトを所有するロールのメンバーシップを付与または取り消すことで、同様の効果を得ることができます。)所有者も暗黙のうちに、オブジェクトのすべての付与オプションを持っています。</target>
        </trans-unit>
        <trans-unit id="1485f3d0af50f7ad2c38bab6ab4b82f7cade74e8" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is always the privilege of the owner only.</source>
          <target state="translated">オブジェクトを修正したり破壊したりする権利は、常に所有者のみの特権です。</target>
        </trans-unit>
        <trans-unit id="081b4bb5f9bb63c56a6d0ef4a59ec5296ea9be8b" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is inherent in being the object's owner, and cannot be granted or revoked in itself. (However, like all privileges, that right can be inherited by members of the owning role; see &lt;a href=&quot;role-membership&quot;&gt;Section 21.3&lt;/a&gt;.)</source>
          <target state="translated">オブジェクトを変更または破棄する権利は、オブジェクトの所有者であることに固有のものであり、それ自体で付与または取り消すことはできません。（ただし、すべての特権と同様に、その権限は所有する役割のメンバーが継承できます。&lt;a href=&quot;role-membership&quot;&gt;セクション21.3を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="a4b02a1fae471a2cfa0b9f0f9afcb866f7eeb267" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all comparisons yield true (including the case where the array has zero elements). The result is &amp;ldquo;false&amp;rdquo; if any false result is found.</source>
          <target state="translated">右側は括弧で囲まれた式で、配列値を生成する必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して配列の各要素と比較されます。演算子はブール型の結果を生成する必要があります。 &lt;code&gt;ALL&lt;/code&gt; の結果は、すべての比較の結果がtrueの場合（配列の要素が0の場合を含む）は「true」です。誤った結果が見つかった場合、結果は「偽」です。</target>
        </trans-unit>
        <trans-unit id="0854056fb124d8ec388aaba4b2f113f43a992144" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the array has zero elements).</source>
          <target state="translated">右側は括弧で囲まれた式であり、配列値を生成する必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して配列の各要素と比較されます。演算子はブール型の結果を生成する必要があります。結果 &lt;code&gt;ANY&lt;/code&gt; は、任意の真の結果が得られた場合、「真」です。真の結果が見つからない場合（配列の要素が0の場合を含む）、結果は「偽」になります。</target>
        </trans-unit>
        <trans-unit id="4cadd4592ac992256e9ca190e2ede2776b0f06bb" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is equal to any of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">右側は、括弧で囲まれたスカラー式のリストです。左側の式の結果がいずれかの右側の式と等しい場合、結果は「true」になります。これは、</target>
        </trans-unit>
        <trans-unit id="9a6bece97382db0f9b6ad5060523f2f32e422503" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is unequal to all of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">右側は、括弧で囲まれたスカラー式のリストです。左側の式の結果がすべての右側の式と等しくない場合、結果は「true」になります。これは、</target>
        </trans-unit>
        <trans-unit id="4623e53b09512588ad13e7eaadc6e34f6d36d750" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all rows yield true (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any false result is found. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用してサブクエリ結果の各行と比較されます。 &lt;code&gt;ALL&lt;/code&gt; の結果は、すべての行がtrueになる場合（サブクエリが行を返さない場合を含む）は「true」です。誤った結果が見つかった場合、結果は「偽」です。サブクエリ行との比較がfalseを返さず、少なくとも1つの比較がNULLを返す場合、結果はNULLです。</target>
        </trans-unit>
        <trans-unit id="89b47774fd6157f8ca176076b1ed18f995c2daef" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the subquery returns no rows).</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用してサブクエリ結果の各行と比較されます。真の結果が得られた場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は「真」になります。真の結果が見つからない場合（サブクエリが行を返さない場合を含む）、結果は「偽」になります。</target>
        </trans-unit>
        <trans-unit id="a7873b5839bfc7065dc6edeb7940049a4cb53216" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、サブクエリ結果の各行と比較されます。等しいサブクエリ行が見つかった場合、 &lt;code&gt;IN&lt;/code&gt; の結果は「true」です。等しい行が見つからない場合（サブクエリが行を返さない場合を含む）、結果は「false」になります。</target>
        </trans-unit>
        <trans-unit id="0ca2d475edb7fe77a4b6be61177af0a4c222988e" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、サブクエリ結果の各行と比較されます。等しくないサブクエリ行のみが見つかった場合（サブクエリが行を返さない場合を含む）、 &lt;code&gt;NOT IN&lt;/code&gt; の結果は「true」になります。等しい行が見つかった場合、結果は「false」です。</target>
        </trans-unit>
        <trans-unit id="60ffe49fd73a1dfeb0ff0a3cd27bc012700f7f66" translate="yes" xml:space="preserve">
          <source>The risk that is taken by using asynchronous commit is of data loss, not data corruption. If the database should crash, it will recover by replaying WAL up to the last record that was flushed. The database will therefore be restored to a self-consistent state, but any transactions that were not yet flushed to disk will not be reflected in that state. The net effect is therefore loss of the last few transactions. Because the transactions are replayed in commit order, no inconsistency can be introduced &amp;mdash; for example, if transaction B made changes relying on the effects of a previous transaction A, it is not possible for A's effects to be lost while B's effects are preserved.</source>
          <target state="translated">非同期コミットを使用することによるリスクは、データの破損ではなく、データの損失です。データベースがクラッシュした場合、フラッシュされた最後のレコードまでWALを再生することで回復します。したがって、データベースは自己矛盾のない状態に復元されますが、まだディスクにフラッシュされていないトランザクションはその状態に反映されません。したがって、最終的な影響は、最後のいくつかのトランザクションの損失です。トランザクションはコミット順で再生されるため、不整合が生じることはありません。たとえば、トランザクションBが前のトランザクションAの影響に依存して変更を加えた場合、Bの影響が保持されている間にAの影響が失われることはありません。</target>
        </trans-unit>
        <trans-unit id="458aee8243a88af8890a3686268fbeeebdc768b4" translate="yes" xml:space="preserve">
          <source>The role attributes &lt;code&gt;LOGIN&lt;/code&gt;, &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;CREATEDB&lt;/code&gt;, and &lt;code&gt;CREATEROLE&lt;/code&gt; can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually &lt;code&gt;SET ROLE&lt;/code&gt; to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; to the &lt;code&gt;admin&lt;/code&gt; role. Then a session connecting as role &lt;code&gt;joe&lt;/code&gt; would not have these privileges immediately, only after doing &lt;code&gt;SET ROLE admin&lt;/code&gt;.</source>
          <target state="translated">ロール属性 &lt;code&gt;LOGIN&lt;/code&gt; 、 &lt;code&gt;SUPERUSER&lt;/code&gt; 、 &lt;code&gt;CREATEDB&lt;/code&gt; 、および &lt;code&gt;CREATEROLE&lt;/code&gt; は特別な特権と考えることができますが、データベースオブジェクトに対する通常の特権のように継承されることはありません。あなたが実際に必要 &lt;code&gt;SET ROLE&lt;/code&gt; 属性を使用するために、これらのいずれかの属性を有する特定の役割に。上記の例を続けると、 &lt;code&gt;CREATEDB&lt;/code&gt; と &lt;code&gt;CREATEROLE&lt;/code&gt; を &lt;code&gt;admin&lt;/code&gt; ロールに付与することを選択できます。そうすると、ロール &lt;code&gt;joe&lt;/code&gt; として接続しているセッションは、 &lt;code&gt;SET ROLE admin&lt;/code&gt; を実行した後でのみ、これらの特権をすぐには得られません。</target>
        </trans-unit>
        <trans-unit id="cc4f14a678d35107865a506875d403f1fabcef04" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default (namely, the user executing the command). To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">新しいデータベースを所有するユーザーのロール名、または &lt;code&gt;DEFAULT&lt;/code&gt; を使用するDEFAULT（つまり、コマンドを実行するユーザー）。別のロールが所有するデータベースを作成するには、そのロールの直接的または間接的なメンバーであるか、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="e0cd094fcb28a6d1c971a4fe5ea4b6668f0b2297" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new schema. If omitted, defaults to the user executing the command. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">新しいスキーマを所有するユーザーのロール名です。省略した場合は、コマンドを実行しているユーザがデフォルトです。他のロールが所有するスキーマを作成するには、そのロールの直接または間接的なメンバであるか、スーパーユーザでなければなりません。</target>
        </trans-unit>
        <trans-unit id="288659e152f65b17d46027cdd207a204fb13225f" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">レプリケーション接続に使用されるロールは、 &lt;code&gt;REPLICATION&lt;/code&gt; 属性を持っている（またはスーパーユーザーである）必要があります。ロールへのアクセスは &lt;code&gt;pg_hba.conf&lt;/code&gt; で設定する必要があり、 &lt;code&gt;LOGIN&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="ae4f6c3527bb773eca24ae98fe7bc2235694a76b" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). If the role lacks &lt;code&gt;SUPERUSER&lt;/code&gt; and &lt;code&gt;BYPASSRLS&lt;/code&gt;, publisher row security policies can execute. If the role does not trust all table owners, include &lt;code&gt;options=-crow_security=off&lt;/code&gt; in the connection string; if a table owner then adds a row security policy, that setting will cause replication to halt rather than execute the policy. Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">レプリケーション接続に使用されるロールには、 &lt;code&gt;REPLICATION&lt;/code&gt; 属性が必要です（またはスーパーユーザーである必要があります）。ロールに &lt;code&gt;SUPERUSER&lt;/code&gt; と &lt;code&gt;BYPASSRLS&lt;/code&gt; がない場合、パブリッシャー行のセキュリティポリシーを実行できます。ロールがすべてのテーブル所有者を信頼しない場合は、接続文字列に &lt;code&gt;options=-crow_security=off&lt;/code&gt; を含めます。次に、テーブルの所有者が行のセキュリティポリシーを追加すると、その設定により、ポリシーが実行されるのではなく、レプリケーションが停止します。ロールへのアクセスは &lt;code&gt;pg_hba.conf&lt;/code&gt; で構成する必要があり、 &lt;code&gt;LOGIN&lt;/code&gt; 属性を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="7270c8298ccd5ab28e0386f721a4bd64642b81f5" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy applies. Multiple roles can be specified at one time. To apply the policy to all roles, use &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">ポリシーが適用される役割。一度に複数のロールを指定できます。ポリシーをすべてのロールに適用するには、 &lt;code&gt;PUBLIC&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="672dc56056e4468fca330096a6f7988e99426d64" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy is to be applied. The default is &lt;code&gt;PUBLIC&lt;/code&gt;, which will apply the policy to all roles.</source>
          <target state="translated">ポリシーが適用される役割。デフォルトは &lt;code&gt;PUBLIC&lt;/code&gt; で、すべてのロールにポリシーが適用されます。</target>
        </trans-unit>
        <trans-unit id="da08283627fb6b277f73d5b0ddf0372ed6cb0f5d" translate="yes" xml:space="preserve">
          <source>The roles to which the policy is applied</source>
          <target state="translated">ポリシーが適用される役割</target>
        </trans-unit>
        <trans-unit id="0b502eae099c8f10d1ed4ef0c354669f63bce361" translate="yes" xml:space="preserve">
          <source>The roles to which this policy applies</source>
          <target state="translated">このポリシーが適用される役割</target>
        </trans-unit>
        <trans-unit id="acd6a9c4a0e56d2f8f09c7b30b75a454cb6c1d08" translate="yes" xml:space="preserve">
          <source>The rows considered by a window function are those of the &amp;ldquo;virtual table&amp;rdquo; produced by the query's &lt;code&gt;FROM&lt;/code&gt; clause as filtered by its &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses if any. For example, a row removed because it does not meet the &lt;code&gt;WHERE&lt;/code&gt; condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different &lt;code&gt;OVER&lt;/code&gt; clauses, but they all act on the same collection of rows defined by this virtual table.</source>
          <target state="translated">ウィンドウ関数によって考慮される行は、 &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句（存在する場合）によってフィルターされたクエリの &lt;code&gt;FROM&lt;/code&gt; 句によって生成された「仮想テーブル」の行です。たとえば、 &lt;code&gt;WHERE&lt;/code&gt; 条件を満たさないために削除された行は、どのウィンドウ関数にも表示されません。クエリには、さまざまな &lt;code&gt;OVER&lt;/code&gt; 句を使用してさまざまな方法でデータをスライスする複数のウィンドウ関数を含めることができますが、これらはすべて、この仮想テーブルで定義された行の同じコレクションに作用します。</target>
        </trans-unit>
        <trans-unit id="ac9a42afd27bb82c7fefe7d8456c8e56005d3e20" translate="yes" xml:space="preserve">
          <source>The rows skipped by an &lt;code&gt;OFFSET&lt;/code&gt; clause still have to be computed inside the server; therefore a large &lt;code&gt;OFFSET&lt;/code&gt; might be inefficient.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 句によってスキップされた行は、サーバー内で計算する必要があります。したがって、大きな &lt;code&gt;OFFSET&lt;/code&gt; は非効率的です。</target>
        </trans-unit>
        <trans-unit id="9c6595d74dd986e8e704f616ce70f02f89a3b6e5" translate="yes" xml:space="preserve">
          <source>The rule firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;, analogous to triggers as described above.</source>
          <target state="translated">ルール起動メカニズムは、上記のトリガーと同様に、構成変数&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_roleの&lt;/a&gt;影響も受けます。</target>
        </trans-unit>
        <trans-unit id="77cbd29a44e08d42c19c09374140fe6b3a2c7eb5" translate="yes" xml:space="preserve">
          <source>The rules file has the following format:</source>
          <target state="translated">ルールファイルの形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="20f26d0e3be07fc8411c53cf4fec028b4fb7ddc1" translate="yes" xml:space="preserve">
          <source>The rules given in the preceding sections will result in assignment of non-&lt;code&gt;unknown&lt;/code&gt; data types to all expressions in a SQL query, except for unspecified-type literals that appear as simple output columns of a &lt;code&gt;SELECT&lt;/code&gt; command. For example, in</source>
          <target state="translated">前のセクションで示した規則により、SQL コマンドのすべての式に、 &lt;code&gt;unknown&lt;/code&gt; データ型が割り当てられます。ただし、 &lt;code&gt;SELECT&lt;/code&gt; コマンドの単純な出力列として表示される未指定のタイプのリテラルは除きます。たとえば、</target>
        </trans-unit>
        <trans-unit id="a710b4d0128d22b5baa147d345de94a14b25c08a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;1...2&lt;/code&gt;, or &lt;code&gt;1 .. 2&lt;/code&gt;, or &lt;code&gt;1..2&lt;/code&gt; (spaces around the range operator are ignored)</source>
          <target state="translated">&lt;code&gt;1...2&lt;/code&gt; 、または &lt;code&gt;1 .. 2&lt;/code&gt; 、または &lt;code&gt;1..2&lt;/code&gt; と同じ（範囲演算子の前後のスペースは無視されます）</target>
        </trans-unit>
        <trans-unit id="e6e201d82f084cc5d95195c10944ee93631d8df0" translate="yes" xml:space="preserve">
          <source>The same, and also reset any associated sequence generators:</source>
          <target state="translated">同様に、また、関連するシーケンスジェネレータをリセットします。</target>
        </trans-unit>
        <trans-unit id="241b8d226e8b5f79ed0ec6888a0ce004af81b21c" translate="yes" xml:space="preserve">
          <source>The same, but counting only word occurrences with weight &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">同じですが、重みが &lt;code&gt;A&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; の単語の出現のみをカウントします。</target>
        </trans-unit>
        <trans-unit id="d2d2e57444e30e19980ec9c24adfc53e9305e592" translate="yes" xml:space="preserve">
          <source>The same, but only execute the function if column &lt;code&gt;balance&lt;/code&gt; is specified as a target in the &lt;code&gt;UPDATE&lt;/code&gt; command:</source>
          <target state="translated">同じですが、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドで列 &lt;code&gt;balance&lt;/code&gt; がターゲットとして指定されている場合にのみ関数を実行します。</target>
        </trans-unit>
        <trans-unit id="002437cb1427716a633526fb7913d4100317c440" translate="yes" xml:space="preserve">
          <source>The same, specified as a table constraint:</source>
          <target state="translated">同じく、テーブル制約として指定されています。</target>
        </trans-unit>
        <trans-unit id="788d460ac0c5a82665dae9bd0fa72bfb74260b32" translate="yes" xml:space="preserve">
          <source>The same, using regular expression notation to consolidate the switches:</source>
          <target state="translated">同じく正規表現表記を使ってスイッチを集約している。</target>
        </trans-unit>
        <trans-unit id="bfae0e75e1b6288495d53b506d9a241bf9d03b6d" translate="yes" xml:space="preserve">
          <source>The same, when the column has a default expression that won't automatically cast to the new data type:</source>
          <target state="translated">カラムにデフォルトの式があり、それが自動的に新しいデータ型にキャストされない場合も同様です。</target>
        </trans-unit>
        <trans-unit id="d799562b98253554741c727e0742611d0f2a5b8b" translate="yes" xml:space="preserve">
          <source>The sample results shown on this page assume that the server parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;&lt;code&gt;bytea_output&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format).</source>
          <target state="translated">このページに示されているサンプル結果は、サーバーパラメータ&lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt; &lt;code&gt;bytea_output&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;escape&lt;/code&gt; するように設定されていることを前提としています（従来のPostgreSQL形式）。</target>
        </trans-unit>
        <trans-unit id="63cecb1fda6e05d04ffb99e00faba23729910dbf" translate="yes" xml:space="preserve">
          <source>The savepoint to roll back to.</source>
          <target state="translated">ロールバックするセーブポイント。</target>
        </trans-unit>
        <trans-unit id="237920c06713568a0627b8a6cf3c35b4a6fcf5f1" translate="yes" xml:space="preserve">
          <source>The scalar ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) do not make a lot of sense for any practical purpose but sorting. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column.</source>
          <target state="translated">スカラーの順序付け演算子（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; など）は、ソート以外の実用的な目的にはあまり意味がありません。これらの演算子は最初に最初の座標を比較し、等しい場合は2番目の座標を比較します。これらは主に、 &lt;code&gt;cube&lt;/code&gt; のbツリーインデックス演算子クラスをサポートするために存在します。これは、たとえば、UNIQUE制約が必要な場合に役立ちます。 &lt;code&gt;cube&lt;/code&gt; の列。</target>
        </trans-unit>
        <trans-unit id="c8365d330a7b8ee61b52ae905279178001855d43" translate="yes" xml:space="preserve">
          <source>The schema containing the &lt;code&gt;citext&lt;/code&gt; operators must be in the current &lt;code&gt;search_path&lt;/code&gt; (typically &lt;code&gt;public&lt;/code&gt;); if it is not, the normal case-sensitive &lt;code&gt;text&lt;/code&gt; operators will be invoked instead.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 演算子を含むスキーマは、現在の &lt;code&gt;search_path&lt;/code&gt; （通常は &lt;code&gt;public&lt;/code&gt; ）になければなりません。そうでない場合は、代わりに通常の大文字と小文字を区別する &lt;code&gt;text&lt;/code&gt; 演算子が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a1b72adef26aba98ed5b9a11c3f8d9f992851abe" translate="yes" xml:space="preserve">
          <source>The schema definitions are not replicated, and the published tables must exist on the subscriber. Only regular tables may be the target of replication. For example, you can't replicate to a view.</source>
          <target state="translated">スキーマ定義はレプリケートされず、公開されたテーブルはサブスクライバ上に存在する必要があります。レギュラーテーブルのみがレプリケーションの対象となる場合があります。例えば、ビューにレプリケートすることはできません。</target>
        </trans-unit>
        <trans-unit id="459a237a85ce3b91cf8ef1e52361b976ab47c1f2" translate="yes" xml:space="preserve">
          <source>The schema in which the imported foreign tables will be created.</source>
          <target state="translated">インポートされた外部テーブルが作成されるスキーマ。</target>
        </trans-unit>
        <trans-unit id="01865c073aef636c813a71a650ffa6b695ee5717" translate="yes" xml:space="preserve">
          <source>The schemes shown here assume that the values of a row's key column(s) never change, or at least do not change enough to require it to move to another partition. An &lt;code&gt;UPDATE&lt;/code&gt; that attempts to do that will fail because of the &lt;code&gt;CHECK&lt;/code&gt; constraints. If you need to handle such cases, you can put suitable update triggers on the child tables, but it makes management of the structure much more complicated.</source>
          <target state="translated">ここに示すスキームは、行のキー列の値が決して変更されないか、少なくとも別のパーティションに移動する必要があるほど十分に変更されないことを前提としています。これを実行しようとする &lt;code&gt;UPDATE&lt;/code&gt; は、 &lt;code&gt;CHECK&lt;/code&gt; 制約のために失敗します。このようなケースを処理する必要がある場合は、子テーブルに適切な更新トリガーを配置できますが、構造の管理がはるかに複雑になります。</target>
        </trans-unit>
        <trans-unit id="ec9b55e40d83c1563492fc665bcf7be0f37fb815" translate="yes" xml:space="preserve">
          <source>The scripts can be run in any order and can be deleted once they have been run.</source>
          <target state="translated">スクリプトは任意の順番で実行することができ、一度実行したら削除することができます。</target>
        </trans-unit>
        <trans-unit id="5351b57ec30c67488f197082c674a1ac3697572e" translate="yes" xml:space="preserve">
          <source>The search filter to use when doing search+bind authentication. Occurrences of &lt;code&gt;$username&lt;/code&gt; will be replaced with the user name. This allows for more flexible search filters than &lt;code&gt;ldapsearchattribute&lt;/code&gt;.</source>
          <target state="translated">search + bind認証を行うときに使用する検索フィルター。 &lt;code&gt;$username&lt;/code&gt; 出現箇所はユーザー名に置き換えられます。これにより、 &lt;code&gt;ldapsearchattribute&lt;/code&gt; よりも柔軟な検索フィルターが可能になります。</target>
        </trans-unit>
        <trans-unit id="cc9e6cb9abd2e41c04bc258bc4b8a29867d6da64" translate="yes" xml:space="preserve">
          <source>The search path can be altered at run time. The command is:</source>
          <target state="translated">検索パスは実行時に変更することができます。コマンドは</target>
        </trans-unit>
        <trans-unit id="478354e0ca1e05b1455044d0dbe23d731c182378" translate="yes" xml:space="preserve">
          <source>The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write</source>
          <target state="translated">検索パスは、データ型名、関数名、演算子名についても、テーブル名と同じように動作します。データ型名と関数名は、テーブル名と全く同じ方法で修飾することができます。式の中に修飾された演算子名を記述する必要がある場合、特別な規定があります。</target>
        </trans-unit>
        <trans-unit id="90f585a0c61cda16f1f2f37af64c77ecb164389f" translate="yes" xml:space="preserve">
          <source>The second approach combines any authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries with the verification of client certificates by setting the &lt;code&gt;clientcert&lt;/code&gt; authentication option to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. The former option only enforces that the certificate is valid, while the latter also ensures that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the user name or an applicable mapping.</source>
          <target state="translated">2番目のアプローチでは、 &lt;code&gt;clientcert&lt;/code&gt; 認証オプションを &lt;code&gt;verify-ca&lt;/code&gt; または &lt;code&gt;verify-full&lt;/code&gt; に設定することにより、 &lt;code&gt;hostssl&lt;/code&gt; エントリの認証方法とクライアント証明書の検証を組み合わせます。前者のオプションは、証明書が有効であることのみを強制しますが、後者は、証明書の &lt;code&gt;cn&lt;/code&gt; （共通名）がユーザー名または適用可能なマッピングと一致することも保証します。</target>
        </trans-unit>
        <trans-unit id="4e7e9d77036e0c9575b0fa838e7bb55bd546fa0a" translate="yes" xml:space="preserve">
          <source>The second argument must be a well formed XML document. In particular, it must have a single root node element.</source>
          <target state="translated">第二引数は、よく形成されたXML文書でなければなりません。特に、それは単一のルートノード要素を持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="971af670862eab67d21e45dbeea285001e2a069e" translate="yes" xml:space="preserve">
          <source>The second example will store cities and their associated geographical location:</source>
          <target state="translated">2 番目の例では、都市とそれに関連付けられた地理的な位置を格納します。</target>
        </trans-unit>
        <trans-unit id="a8fdfc2d4d4050aa9351fe7e549967c0e1502821" translate="yes" xml:space="preserve">
          <source>The second form changes the name of the database. Only the database owner or a superuser can rename a database; non-superuser owners must also have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. The current database cannot be renamed. (Connect to a different database if you need to do that.)</source>
          <target state="translated">2番目の形式は、データベースの名前を変更します。データベースの名前を変更できるのは、データベースの所有者またはスーパーユーザーだけです。スーパーユーザー以外の所有者も &lt;code&gt;CREATEDB&lt;/code&gt; 特権を持っている必要があります。現在のデータベースの名前は変更できません。（必要な場合は、別のデータベースに接続してください。）</target>
        </trans-unit>
        <trans-unit id="5f97cd14403d43a28906f958a63aa9be74a831f3" translate="yes" xml:space="preserve">
          <source>The second form is a PostgreSQL extension. It fills the columns from the left with as many values as are given, and the rest will be defaulted.</source>
          <target state="translated">2つ目のフォームはPostgreSQLの拡張です。左から順に与えられた値の数だけ列を埋めていき、残りはデフォルトになります。</target>
        </trans-unit>
        <trans-unit id="001f55ae6b12f7691ee493402996a3cedd18d43d" translate="yes" xml:space="preserve">
          <source>The second form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates an enumerated (enum) type, as described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;. Enum types take a list of quoted labels, each of which must be less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long (64 bytes in a standard PostgreSQL build). (It is possible to create an enumerated type with zero labels, but such a type cannot be used to hold values before at least one label is added using &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;datatype-enum&quot;&gt;セクション8.7で&lt;/a&gt;説明されているように、 &lt;code&gt;CREATE TYPE&lt;/code&gt; の2番目の形式は、列挙（enum）タイプを作成します。列挙型は引用符で囲まれたラベルのリストを &lt;code&gt;NAMEDATALEN&lt;/code&gt; ます。それぞれのラベルはNAMEDATALENバイト長（標準のPostgreSQLビルドでは64バイト）未満でなければなりません。（ラベルなしの列挙型を作成することは可能ですが、&lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;を使用して少なくとも1つのラベルが追加されるまで、そのような型を使用して値を保持することはできません。）</target>
        </trans-unit>
        <trans-unit id="9646c72014e3dc0cdbc889805cc625cb2e00d4a4" translate="yes" xml:space="preserve">
          <source>The second implementation of the rule system is a technique called &lt;em&gt;query rewriting&lt;/em&gt;. The &lt;em&gt;rewrite system&lt;/em&gt; is a module that exists between the &lt;em&gt;parser stage&lt;/em&gt; and the &lt;em&gt;planner/optimizer&lt;/em&gt;. This technique is still implemented.</source>
          <target state="translated">ルールシステムの2番目の実装は、&lt;em&gt;クエリ書き換え&lt;/em&gt;と呼ばれる手法です。&lt;em&gt;書き換えシステムは、&lt;/em&gt;間に存在するモジュールである&lt;em&gt;パーサステージ&lt;/em&gt;と&lt;em&gt;プランナ/オプティマイザ&lt;/em&gt;。この手法はまだ実装されています。</target>
        </trans-unit>
        <trans-unit id="b82fe6094f17ae862d5ae179aa9cdfdad11af121" translate="yes" xml:space="preserve">
          <source>The second line is the command that would be invoked in restart mode.</source>
          <target state="translated">2行目は、再起動モードで呼び出されるコマンドです。</target>
        </trans-unit>
        <trans-unit id="5e54d9500bd7199e013e0c26f4d1118e580aabf7" translate="yes" xml:space="preserve">
          <source>The second part of the module relies on representing Earth locations as values of type &lt;code&gt;point&lt;/code&gt;, in which the first component is taken to represent longitude in degrees, and the second component is taken to represent latitude in degrees. Points are taken as (longitude, latitude) and not vice versa because longitude is closer to the intuitive idea of x-axis and latitude to y-axis.</source>
          <target state="translated">モジュールの2番目の部分は、地球の位置を &lt;code&gt;point&lt;/code&gt; 型の値として表すことに依存しています。最初のコンポーネントは経度を度で表し、2番目のコンポーネントは緯度を度で表します。経度はx軸、緯度はy軸の直感的な考え方に近いため、ポイントは（経度、緯度）として解釈され、その逆は解釈されません。</target>
        </trans-unit>
        <trans-unit id="07476921b1bd87798420cb9dffdda71ef3f07ce3" translate="yes" xml:space="preserve">
          <source>The second variant changes the name of the role. Database superusers can rename any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can rename non-superuser roles. The current session user cannot be renamed. (Connect as a different user if you need to do that.) Because &lt;code&gt;MD5&lt;/code&gt;-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is &lt;code&gt;MD5&lt;/code&gt;-encrypted.</source>
          <target state="translated">2番目のバリアントは、役割の名前を変更します。データベースのスーパーユーザーは、任意のロールの名前を変更できます。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、スーパーユーザー以外のロールの名前を変更できます。現在のセッションユーザーの名前は変更できません。（接続別のユーザーとして、あなたがそれを行う必要があります。）ので &lt;code&gt;MD5&lt;/code&gt; は、パスワードが暗号化塩としてロール名を使用-encryptedパスワードがある場合は、ロール名を変更するとパスワードはクリア &lt;code&gt;MD5&lt;/code&gt; が -encrypted。</target>
        </trans-unit>
        <trans-unit id="ee438b765dcc18ec34d603a483697e804f9db58b" translate="yes" xml:space="preserve">
          <source>The seconds field, including any fractional seconds</source>
          <target state="translated">秒フィールド(端数秒を含む</target>
        </trans-unit>
        <trans-unit id="cfe4da30b9c6bff8e95fbde2fcc03500be370613" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts (0 - 59&lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;)</source>
          <target state="translated">小数部を含む秒フィールド（0-59 &lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="663b58f51194288bd80b435fbc5e648d8e6f6580" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds</source>
          <target state="translated">秒フィールド(端数部分を含む)に1,000,000を乗じたもの。</target>
        </trans-unit>
        <trans-unit id="2d44e15dba826649cac46abaee1bc5cb23f259a3" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.</source>
          <target state="translated">秒フィールド(端数部分を含む)に1000を掛けたもの。これには完全な秒数が含まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7bfc04444cf0b5a28dd815138a4bbbe840cd72f0" translate="yes" xml:space="preserve">
          <source>The security label applied to this object.</source>
          <target state="translated">このオブジェクトに適用されるセキュリティラベル。</target>
        </trans-unit>
        <trans-unit id="b47689b397bbce6da7cf131cc329c56ad0b8b0d2" translate="yes" xml:space="preserve">
          <source>The security model of SELinux describes all the access control rules as relationships between a subject entity (typically, a client of the database) and an object entity (such as a database object), each of which is identified by a security label. If access to an unlabeled object is attempted, the object is treated as if it were assigned the label &lt;code&gt;unlabeled_t&lt;/code&gt;.</source>
          <target state="translated">SELinuxのセキュリティモデルは、すべてのアクセス制御ルールをサブジェクトエンティティ（通常はデータベースのクライアント）とオブジェクトエンティティ（データベースオブジェクトなど）の間の関係として記述します。各エンティティはセキュリティラベルによって識別されます。ラベルのないオブジェクトにアクセスしようとすると、オブジェクトはラベル &lt;code&gt;unlabeled_t&lt;/code&gt; が割り当てられているかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="230231accae0954bfa7e47d9f5e404dcd469b2c5" translate="yes" xml:space="preserve">
          <source>The security policy of SELinux also has rules to control whether or not particular accesses are logged. By default, access violations are logged, but allowed accesses are not.</source>
          <target state="translated">SELinux のセキュリティポリシーには、特定のアクセスがログに記録されるかどうかを制御するルールもあります。デフォルトでは、アクセス違反は記録されますが、許可されたアクセスは記録されません。</target>
        </trans-unit>
        <trans-unit id="dbcd4d113ca55d30a1adafc062bb48c13c7f8e98" translate="yes" xml:space="preserve">
          <source>The seed can also be set by invoking the function &lt;code&gt;setseed&lt;/code&gt;:</source>
          <target state="translated">シードは、関数 &lt;code&gt;setseed&lt;/code&gt; を呼び出して設定することもできます。</target>
        </trans-unit>
        <trans-unit id="1c3344ee525a48fbaf283fc79a5b884444be3dcb" translate="yes" xml:space="preserve">
          <source>The segment [a, b] contains the segment [c, d], that is, a &amp;lt;= c and b &amp;gt;= d.</source>
          <target state="translated">セグメント[a、b]には、セグメント[c、d]が含まれています。つまり、a &amp;lt;= cおよびb&amp;gt; = dです。</target>
        </trans-unit>
        <trans-unit id="0167ae8a0ef2744b5f058f32dbb8df42b67bb33e" translate="yes" xml:space="preserve">
          <source>The segment [a, b] is contained in [c, d], that is, a &amp;gt;= c and b &amp;lt;= d.</source>
          <target state="translated">セグメント[a、b]は[c、d]に含まれます。つまり、a&amp;gt; = cおよびb &amp;lt;= dです。</target>
        </trans-unit>
        <trans-unit id="2f9dfe875337796db870c4bb2a262e2bbef3945b" translate="yes" xml:space="preserve">
          <source>The segments [a, b] and [c, d] overlap.</source>
          <target state="translated">セグメント[a,b]と[c,d]が重なっている。</target>
        </trans-unit>
        <trans-unit id="b10711fce98e1c5fe5a4897a9961ed9ae2f37aef" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</source>
          <target state="translated">SQL/JSONパス述語と演算子のセマンティクスは一般的にSQLに従います。同時に、JSONデータを最も自然に扱う方法を提供するために、SQL/JSONパス構文はJavaScriptの規約の一部を使用しています。</target>
        </trans-unit>
        <trans-unit id="fd623d8bcf9db9273d58642da7f1fb001cf303e9" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a natural way of working with JSON data, SQL/JSON path syntax uses some JavaScript conventions:</source>
          <target state="translated">SQL/JSONパス述語と演算子のセマンティクスは一般的にSQLに従います。同時に、JSONデータを扱う自然な方法を提供するために、SQL/JSONパス構文はいくつかのJavaScriptの規約を使用しています。</target>
        </trans-unit>
        <trans-unit id="ca2f632c9b81511535163336539f86f918d83e9e" translate="yes" xml:space="preserve">
          <source>The semicolon (&lt;code&gt;;&lt;/code&gt;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.</source>
          <target state="translated">セミコロン（ &lt;code&gt;;&lt;/code&gt; ）は、SQLコマンドを終了します。文字列定数または引用符で囲まれた識別子内を除き、コマンド内のどこにも表示できません。</target>
        </trans-unit>
        <trans-unit id="7c68a3eca090a3377bf1a78fea499d56ec605109" translate="yes" xml:space="preserve">
          <source>The sequence created for a &lt;code&gt;serial&lt;/code&gt; column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</source>
          <target state="translated">&lt;code&gt;serial&lt;/code&gt; 列用に作成されたシーケンスは、所有する列が削除されると自動的に削除されます。列を削除せずにシーケンスを削除できますが、これにより列のデフォルト式が強制的に削除されます。</target>
        </trans-unit>
        <trans-unit id="b5a5d93057bd5edff8daf4648c4c935388f9e10e" translate="yes" xml:space="preserve">
          <source>The sequence name can be schema-qualified if necessary:</source>
          <target state="translated">シーケンス名は必要に応じてスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="c6a359aa04dbc4531fddf8d09e8fef46d55e14f6" translate="yes" xml:space="preserve">
          <source>The sequence to be operated on by a sequence function is specified by a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the sequence in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the sequence name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the sequence name. Thus:</source>
          <target state="translated">シーケンス関数によって操作されるシーケンスは、 &lt;code&gt;regclass&lt;/code&gt; 引数によって指定されます。これは、 &lt;code&gt;pg_class&lt;/code&gt; システムカタログ内のシーケンスのOIDです。ただし、 &lt;code&gt;regclass&lt;/code&gt; データ型の入力コンバーターが機能するため、OIDを手動で検索する必要はありません。リテラル定数のように見えるように、単一引用符で囲まれたシーケンス名を記述するだけです。通常のSQL名の処理との互換性のために、シーケンス名の前後に二重引用符が含まれていない限り、文字列は小文字に変換されます。したがって：</target>
        </trans-unit>
        <trans-unit id="ea7d18fda0e93393ee728bac05185520e2d92f5c" translate="yes" xml:space="preserve">
          <source>The server log might contain more information about an authentication failure than is reported to the client. If you are confused about the reason for a failure, check the server log.</source>
          <target state="translated">サーバーログには、認証の失敗に関する情報が、クライアントに報告された情報よりも多く含まれている可能性があります。失敗の理由がわからない場合は、サーバログを確認してください。</target>
        </trans-unit>
        <trans-unit id="4ca1254319f0477050eedb4dcb243dbc28231770" translate="yes" xml:space="preserve">
          <source>The server name must be unique within the database.</source>
          <target state="translated">サーバー名はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7c59301168d9556837d6ae02c071fa4e2e245b97" translate="yes" xml:space="preserve">
          <source>The server process is idle. This event type indicates a process waiting for activity in its main processing loop. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスはアイドル状態です。このイベントタイプは、メイン処理ループでアクティビティを待機しているプロセスを示します。 &lt;code&gt;wait_event&lt;/code&gt; は、特定の待機ポイントを識別します。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;表27.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="31a48413f524a2e22ba2b89cc5a923ac95e25337" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a heavyweight lock. Heavyweight locks, also known as lock manager locks or simply locks, primarily protect SQL-visible objects such as tables. However, they are also used to ensure mutual exclusion for certain internal operations such as relation extension. &lt;code&gt;wait_event&lt;/code&gt; will identify the type of lock awaited; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、重いロックを待機しています。ロックマネージャロックまたは単にロックとも呼ばれるヘビーウェイトロックは、主にテーブルなどのSQLで表示されるオブジェクトを保護します。ただし、これらは、関係拡張などの特定の内部操作の相互排除を保証するためにも使用されます。 &lt;code&gt;wait_event&lt;/code&gt; は、待機中のロックのタイプを識別します。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;表27.11を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1f51ae65c30da3ee23ba46209eb3c2d669b578e3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a lightweight lock. Most such locks protect a particular data structure in shared memory. &lt;code&gt;wait_event&lt;/code&gt; will contain a name identifying the purpose of the lightweight lock. (Some locks have specific names; others are part of a group of locks each with a similar purpose.) See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;Table 27.12&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは軽量ロックを待機しています。このようなロックのほとんどは、共有メモリ内の特定のデータ構造を保護します。 &lt;code&gt;wait_event&lt;/code&gt; には、軽量ロックの目的を識別する名前が含まれます。（一部のロックには特定の名前があります。その他のロックは、それぞれが同様の目的を持つロックのグループの一部です。）&lt;a href=&quot;monitoring-stats#WAIT-EVENT-LWLOCK-TABLE&quot;&gt;表27.12を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1282755dbc7fcbac3f92fb89910bc9353d2096ee" translate="yes" xml:space="preserve">
          <source>The server process is waiting for a timeout to expire. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、タイムアウトの期限が切れるのを待っています。 &lt;code&gt;wait_event&lt;/code&gt; は、特定の待機ポイントを識別します。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;表27.13を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8e0987499e5a13bf6c786db17c89cc8ef22d6f54" translate="yes" xml:space="preserve">
          <source>The server process is waiting for activity on a socket connected to a user application. Thus, the server expects something to happen that is independent of its internal processes. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-CLIENT-TABLE&quot;&gt;Table 27.7&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、ユーザーアプリケーションに接続されたソケットでのアクティビティを待機しています。したがって、サーバーは、内部プロセスから独立した何かが発生することを予期します。 &lt;code&gt;wait_event&lt;/code&gt; は、特定の待機ポイントを識別します。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-CLIENT-TABLE&quot;&gt;表27.7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9b31b52ace66848125879633c9823a38b3287ac3" translate="yes" xml:space="preserve">
          <source>The server process is waiting for an I/O operation to complete. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IO-TABLE&quot;&gt;Table 27.9&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、I / O操作が完了するのを待っています。 &lt;code&gt;wait_event&lt;/code&gt; は、特定の待機ポイントを識別します。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-IO-TABLE&quot;&gt;表27.9を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e8bb014aedce015b73f39d1e5ca61f9c69eeed52" translate="yes" xml:space="preserve">
          <source>The server process is waiting for exclusive access to a data buffer. Buffer pin waits can be protracted if another process holds an open cursor that last read data from the buffer in question. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-BUFFERPIN-TABLE&quot;&gt;Table 27.6&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、データバッファーへの排他的アクセスを待機しています。問題のバッファから最後にデータを読み取ったオープンカーソルを別のプロセスが保持している場合、バッファピンの待機時間が長くなる可能性があります。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-BUFFERPIN-TABLE&quot;&gt;表27.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d9849ed38bcc2dc42a7bd3ba776b5832e6dd4516" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some condition defined by an extension module. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-EXTENSION-TABLE&quot;&gt;Table 27.8&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、拡張モジュールによって定義された何らかの条件を待機しています。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-EXTENSION-TABLE&quot;&gt;表27.8を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7fff16781ff90b488a09e62468878f27f389a70f" translate="yes" xml:space="preserve">
          <source>The server process is waiting for some interaction with another server process. &lt;code&gt;wait_event&lt;/code&gt; will identify the specific wait point; see &lt;a href=&quot;monitoring-stats#WAIT-EVENT-IPC-TABLE&quot;&gt;Table 27.10&lt;/a&gt;.</source>
          <target state="translated">サーバープロセスは、別のサーバープロセスとの相互作用を待機しています。 &lt;code&gt;wait_event&lt;/code&gt; は、特定の待機ポイントを識別します。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-IPC-TABLE&quot;&gt;表27.10を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac56c0453261e732a23fed94e0a24c8f95cc0488" translate="yes" xml:space="preserve">
          <source>The server reads these files at server start and whenever the server configuration is reloaded. On Windows systems, they are also re-read whenever a new backend process is spawned for a new client connection.</source>
          <target state="translated">サーバは、サーバの起動時やサーバ設定のリロード時にこれらのファイルを読み込みます。Windows システムでは、新しいクライアント接続のために新しいバックエンドプロセスが生成されるたびに、これらのファイルが再読まれます。</target>
        </trans-unit>
        <trans-unit id="d0d31219164213fd90b64aadc8577b6089ce02b9" translate="yes" xml:space="preserve">
          <source>The server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept. This will be &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; and &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; if the server is built with SSL support, or else just the latter.</source>
          <target state="translated">サーバーはAuthenticationSASLメッセージを送信します。これには、サーバーが受け入れることができるSASL認証メカニズムのリストが含まれています。これは次のようになります &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; と &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 、サーバーがSSLサポート、または他のちょうど後者で構築されている場合。</target>
        </trans-unit>
        <trans-unit id="b019b1a1b7d85dded861255aa6e59d8f9921d05a" translate="yes" xml:space="preserve">
          <source>The server will occasionally request the client to perform a flush and report the flush position to the server. This setting is in addition to that, to perform flushes more frequently.</source>
          <target state="translated">サーバーは、時々クライアントにフラッシュの実行を要求し、フラッシュの位置をサーバーに報告します。この設定はそれに加えて、より頻繁にフラッシュを実行するためのものです。</target>
        </trans-unit>
        <trans-unit id="7b8da77a2b390601e3adff073821408d13cdbea6" translate="yes" xml:space="preserve">
          <source>The server's checkpointer process automatically performs a checkpoint every so often. A checkpoint is begun every &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; seconds, or if &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; is about to be exceeded, whichever comes first. The default settings are 5 minutes and 1 GB, respectively. If no WAL has been written since the previous checkpoint, new checkpoints will be skipped even if &lt;code&gt;checkpoint_timeout&lt;/code&gt; has passed. (If WAL archiving is being used and you want to put a lower limit on how often files are archived in order to bound potential data loss, you should adjust the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; parameter rather than the checkpoint parameters.) It is also possible to force a checkpoint by using the SQL command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">サーバーのチェックポインタープロセスは、チェックポイントを時々自動的に実行します。チェックポイントは、&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;秒ごと、または&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_sizeを超えよう&lt;/a&gt;としている場合のいずれか早い方で開始されます。デフォルト設定は、それぞれ5分と1 GBです。前のチェックポイント以降にWALが書き込まれていない場合、 &lt;code&gt;checkpoint_timeout&lt;/code&gt; が経過しても新しいチェックポイントはスキップされます。 （WALアーカイブが使用されており、潜在的なデータ損失を制限するためにファイルをアーカイブする頻度に下限を設定する場合は、チェックポイントパラメーターではなく、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt;パラメーターを調整する必要があります。）チェックポイントを強制することもできます。 SQLコマンド &lt;code&gt;CHECKPOINT&lt;/code&gt; を使用する。</target>
        </trans-unit>
        <trans-unit id="c205218c3546e4b301b493a03547b46277844636" translate="yes" xml:space="preserve">
          <source>The server's version number as a string, for example &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt; or &lt;code&gt;11beta1&lt;/code&gt;, and in numeric form, for example &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;. These are set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">例えば、文字列としてサーバのバージョン番号、 &lt;code&gt;9.6.2&lt;/code&gt; 、 &lt;code&gt;10.1&lt;/code&gt; または &lt;code&gt;11beta1&lt;/code&gt; 、および数値形式で、例えば &lt;code&gt;90602&lt;/code&gt; または &lt;code&gt;100001&lt;/code&gt; 。これらは、データベース（プログラムの起動を含む）に接続するたびに設定されますが、変更または設定解除できます。</target>
        </trans-unit>
        <trans-unit id="5a84cc79fdbb16a887f43ceaad26726c6755ffe1" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">セッションのデフォルトのトランザクションモードは、構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;、および&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrableを&lt;/a&gt;設定することによっても設定できます。（実際、 &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; は、これらの変数を &lt;code&gt;SET&lt;/code&gt; で設定するのに相当する冗長です。）これは、 &lt;code&gt;ALTER DATABASE&lt;/code&gt; などを使用して、構成ファイルでデフォルトを設定できることを意味します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2aaa3b9320a8aa3d463da80f8c085ef96d144a67" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">セッションのデフォルトのトランザクションモードは、構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;、および&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrableを&lt;/a&gt;設定することによっても設定できます。 （実際、 &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; は、これらの変数を &lt;code&gt;SET&lt;/code&gt; で設定するのとまったく同じです。）これは、 &lt;code&gt;ALTER DATABASE&lt;/code&gt; などを介して構成ファイルでデフォルトを設定できることを意味します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;第19章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6723e0bdad2077d09fd447f64653c3402fb21a9f" translate="yes" xml:space="preserve">
          <source>The session user identifier can be changed only if the initial session user (the &lt;em&gt;authenticated user&lt;/em&gt;) had the superuser privilege. Otherwise, the command is accepted only if it specifies the authenticated user name.</source>
          <target state="translated">セッションユーザー識別子は、最初のセッションユーザー（&lt;em&gt;認証されたユーザー&lt;/em&gt;）がスーパーユーザー特権を持っている場合にのみ変更できます。それ以外の場合、コマンドは、認証されたユーザー名を指定する場合にのみ受け入れられます。</target>
        </trans-unit>
        <trans-unit id="715d310203fd1767744b0e3abc3cbaadfd49947d" translate="yes" xml:space="preserve">
          <source>The session user identifier is initially set to be the (possibly authenticated) user name provided by the client. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of &lt;code&gt;SECURITY DEFINER&lt;/code&gt; functions and similar mechanisms; it can also be changed by &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. The current user identifier is relevant for permission checking.</source>
          <target state="translated">セッションユーザー識別子は、最初はクライアントから提供された（認証されている可能性がある）ユーザー名に設定されています。現在のユーザーIDは通常、セッションユーザーID と同じですが、 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 関数および同様のメカニズムのコンテキストで一時的に変更される可能性があります。&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;で変更することもできます。現在のユーザー識別子は、権限チェックに関連しています。</target>
        </trans-unit>
        <trans-unit id="94dcf85932be3ca953bb5dbee89cd4f7713067fb" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章で&lt;/a&gt;説明されているように、特定のクライアント接続が接続できるデータベースロールのセットは、クライアント認証設定によって決定されます。（したがって、ユーザーのログイン名が本名と一致する必要がないのと同じように、クライアントはオペレーティングシステムユーザーと一致するロールとして接続することに限定されません。）ロールIDは接続されたクライアントが利用できる特権のセットを決定するため、マルチユーザー環境をセットアップするときは、特権を慎重に構成することが重要です。</target>
        </trans-unit>
        <trans-unit id="116c57f39b5a10aa3016899fd490e3422c042da6" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章で&lt;/a&gt;説明されているように、特定のクライアント接続が接続できるデータベースロールのセットは、クライアント認証の設定によって決定されます。 （したがって、クライアントは、オペレーティングシステムユーザーと一致するロールとして接続することに限定されません。ユーザーのログイン名が本名と一致する必要がないのと同じです。）ロールIDによって、接続されたクライアントが使用できる特権のセットが決まります。マルチユーザー環境をセットアップするときは、特権を慎重に構成することが重要です。</target>
        </trans-unit>
        <trans-unit id="d9e7e3efb30616b981cfefa41268aa6951e3d5f2" translate="yes" xml:space="preserve">
          <source>The setting &lt;code&gt;RemoveIPC&lt;/code&gt; in &lt;code&gt;logind.conf&lt;/code&gt; controls whether IPC objects are removed when a user fully logs out. System users are exempt. This setting defaults to on in stock systemd, but some operating system distributions default it to off.</source>
          <target state="translated">設定 &lt;code&gt;RemoveIPC&lt;/code&gt; で &lt;code&gt;logind.conf&lt;/code&gt; のユーザーが完全にログアウトするIPCオブジェクトが削除されているかどうかを制御します。システムユーザーは免除されます。この設定はデフォルトで在庫ありのsystemdですが、一部のオペレーティングシステムのディストリビューションではデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="64eba0ac674f39ed469aa292d2c2a8445eebc9f9" translate="yes" xml:space="preserve">
          <source>The setting of some parameters on the standby will need reconfiguration if they have been changed on the primary. For these parameters, the value on the standby must be equal to or greater than the value on the primary. Therefore, if you want to increase these values, you should do so on all standby servers first, before applying the changes to the primary server. Conversely, if you want to decrease these values, you should do so on the primary server first, before applying the changes to all standby servers. If these parameters are not set high enough then the standby will refuse to start. Higher values can then be supplied and the server restarted to begin recovery again. These parameters are:</source>
          <target state="translated">待機中の一部のパラメータをプライマリで変更した場合、再設定が必要になります。これらのパラメータについては、待機側の値がプライマリ側の値と同じかそれ以上である必要があります。したがって、これらの値を増加させたい場合は、プライマリサーバに変更を適用する前に、まずすべてのスタンバイサーバで変更を行う必要があります。逆に、これらの値を小さくしたい場合は、すべての待機サーバに変更を適用する前に、まずプライマリ サーバで変更を行う必要があります。これらのパラメータが十分に高く設定されていない場合、待機サーバは起動を拒否します。この場合は、より高い値を指定してサーバを再起動し、復旧を再開することができます。これらのパラメータは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8f66060d984a3d43717aaa1c8e7136685e2e6d1f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g. query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">共有ロックテーブルは、 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）オブジェクト（たとえば、テーブル）のロックを追跡します。したがって、一度にロックできるオブジェクトはこれだけです。このパラメーターは、各トランザクションに割り当てられるオブジェクトロックの平均数を制御します。すべてのトランザクションのロックがロックテーブルに収まる限り、個々のトランザクションはより多くのオブジェクトをロックできます。これは&lt;em&gt;ありません&lt;/em&gt;ロックできる行の数。その値は無制限です。デフォルトの64で十分であることが歴史的に証明されていますが、単一のトランザクションで多くの異なるテーブルにアクセスするクエリ（たとえば、多くの子を持つ親テーブルのクエリ）がある場合は、この値を上げる必要があるかもしれません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="f3a2293e6351084a16aac1acbf3842262fd1322f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g., query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">共有ロックテーブルは、 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）オブジェクト（テーブルなど）のロックを追跡します。したがって、一度にロックできるのは、これだけ多くの個別のオブジェクトです。このパラメーターは、各トランザクションに割り当てられるオブジェクトロックの平均数を制御します。すべてのトランザクションのロックがロックテーブルに収まる限り、個々のトランザクションはより多くのオブジェクトをロックできます。これは&lt;em&gt;そうで&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;ロックできる行の数。その値は無制限です。デフォルトの64は歴史的に十分であることが証明されていますが、1つのトランザクションで多くの異なるテーブルにアクセスするクエリがある場合、たとえば、多くの子を持つ親テーブルのクエリがある場合は、この値を上げる必要があります。このパラメーターは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ed8d27015cd393d0e4d2ed8b1d7004db3e56b61f" translate="yes" xml:space="preserve">
          <source>The shared memory size settings can be changed via the &lt;code&gt;sysctl&lt;/code&gt; interface. For example, to allow 16 GB:</source>
          <target state="translated">共有メモリサイズの設定は、 &lt;code&gt;sysctl&lt;/code&gt; インターフェースを介して変更できます。たとえば、16 GBを許可するには：</target>
        </trans-unit>
        <trans-unit id="068843c57f60fb86ac3cb60c430b5300612b2f9d" translate="yes" xml:space="preserve">
          <source>The shared predicate lock table tracks locks on &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has generally been sufficient in testing, but you might need to raise this value if you have clients that touch many different tables in a single serializable transaction. This parameter can only be set at server start.</source>
          <target state="translated">共有述語ロックテーブルは、 &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）オブジェクト（テーブルなど）のロックを追跡します。したがって、一度にロックできるオブジェクトはこれだけです。このパラメーターは、各トランザクションに割り当てられるオブジェクトロックの平均数を制御します。すべてのトランザクションのロックがロックテーブルに収まる限り、個々のトランザクションはより多くのオブジェクトをロックできます。これは、ロックできる行数ではあり&lt;em&gt;ません&lt;/em&gt;。その値は無制限です。テストでは通常、デフォルトの64で十分ですが、1つのシリアル化可能なトランザクションで多くの異なるテーブルにアクセスするクライアントがある場合は、この値を上げる必要があるかもしれません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ca5a87d53a78cc8149d60b5d1c35e814aa59a259" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">RADIUSサーバと安全に通信する際に使用する共有秘密。これはPostgreSQLサーバとRADIUSサーバで全く同じ値を持つ必要があります。これは少なくとも16文字の文字列にすることを推奨します。このパラメータは必須です。</target>
        </trans-unit>
        <trans-unit id="1aeeff6b5f410ecdf1f1d99d13f99d22c13ce407" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS servers. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">RADIUSサーバと安全に通信する際に使用する共有秘密。これはPostgreSQLサーバとRADIUSサーバで全く同じ値を持つ必要があります。これは少なくとも16文字の文字列にすることを推奨します。このパラメータは必須です。</target>
        </trans-unit>
        <trans-unit id="58e38019afd1ad1853e1d01481b88d4b91b8d05a" translate="yes" xml:space="preserve">
          <source>The sharp (&lt;code&gt;#&lt;/code&gt;) sign is a comment delimiter. It may appear at any position in a line. The rest of the line will be skipped.</source>
          <target state="translated">シャープ（ &lt;code&gt;#&lt;/code&gt; ）記号はコメント区切り文字です。行の任意の位置に表示されます。残りの行はスキップされます。</target>
        </trans-unit>
        <trans-unit id="67cfcf8acce2ecc45db3a0f17045ee10928b08a1" translate="yes" xml:space="preserve">
          <source>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</source>
          <target state="translated">この代替方法を用いて待機サーバを設定する場合の簡単な手順は以下の通りです。各ステップの詳細については、前述の通り前のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="968f59638db3803d09dafd7e362f7206431f6346" translate="yes" xml:space="preserve">
          <source>The simple comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; compare the lower bounds first, and only if those are equal, compare the upper bounds. These comparisons are not usually very useful for ranges, but are provided to allow B-tree indexes to be constructed on ranges.</source>
          <target state="translated">単純な比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; は、最初に下限を比較し、それらが等しい場合にのみ、上限を比較します。これらの比較は通常、範囲にはあまり役立ちませんが、Bツリーインデックスを範囲に基づいて構築できるようにするために提供されています。</target>
        </trans-unit>
        <trans-unit id="8ea620de73d7bb2e034a3dc8ebd2dd0118f06f72" translate="yes" xml:space="preserve">
          <source>The simplest kind of extended statistics tracks &lt;em&gt;functional dependencies&lt;/em&gt;, a concept used in definitions of database normal forms. We say that column &lt;code&gt;b&lt;/code&gt; is functionally dependent on column &lt;code&gt;a&lt;/code&gt; if knowledge of the value of &lt;code&gt;a&lt;/code&gt; is sufficient to determine the value of &lt;code&gt;b&lt;/code&gt;, that is there are no two rows having the same value of &lt;code&gt;a&lt;/code&gt; but different values of &lt;code&gt;b&lt;/code&gt;. In a fully normalized database, functional dependencies should exist only on primary keys and superkeys. However, in practice many data sets are not fully normalized for various reasons; intentional denormalization for performance reasons is a common example. Even in a fully normalized database, there may be partial correlation between some columns, which can be expressed as partial functional dependency.</source>
          <target state="translated">最も単純な種類の拡張統計は、&lt;em&gt;機能の依存関係を&lt;/em&gt;追跡し&lt;em&gt;ます&lt;/em&gt;。これは、データベースの正規形の定義で使用される概念です。我々は、その列言う &lt;code&gt;b&lt;/code&gt; 列に機能的に依存している &lt;code&gt;a&lt;/code&gt; の値を知っている場合の値を決定するのに十分である &lt;code&gt;b&lt;/code&gt; 同一の値を有するいかなる2つの列が存在しないとすると、の異なる値 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 。完全に正規化されたデータベースでは、機能の依存関係は主キーとスーパーキーにのみ存在する必要があります。ただし、実際には、多くのデータセットがさまざまな理由で完全に正規化されていません。パフォーマンス上の理由による意図的な非正規化が一般的な例です。完全に正規化されたデータベースでも、一部の列間に部分的な相関がある場合があり、部分的な機能依存として表すことができます。</target>
        </trans-unit>
        <trans-unit id="218e0e862d91c332c13bb63fca705baa68ee5396" translate="yes" xml:space="preserve">
          <source>The simplest kind of select list is &lt;code&gt;*&lt;/code&gt; which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;). For instance, it could be a list of column names:</source>
          <target state="translated">最も単純な種類の選択リストは &lt;code&gt;*&lt;/code&gt; で、テーブル式が生成するすべての列を出力します。それ以外の場合、選択リストは値式のコンマ区切りのリストです（&lt;a href=&quot;sql-expressions&quot;&gt;セクション4.2で&lt;/a&gt;定義）。たとえば、列名のリストである可能性があります。</target>
        </trans-unit>
        <trans-unit id="95ff410c0d68dcd6b5d1a3a14a5e05f946ef4e40" translate="yes" xml:space="preserve">
          <source>The simplest option for removing old data is to drop the partition that is no longer necessary:</source>
          <target state="translated">古いデータを削除する最も簡単な方法は、不要になったパーティションを落とすことです。</target>
        </trans-unit>
        <trans-unit id="9d938ffa1d7d07edb850b5b705fb8034d9885325" translate="yes" xml:space="preserve">
          <source>The size of the block range is determined at index creation time by the &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for &lt;code&gt;pages_per_range&lt;/code&gt;. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan.</source>
          <target state="translated">ブロック範囲のサイズは、インデックスの作成時に &lt;code&gt;pages_per_range&lt;/code&gt; ストレージパラメータによって決定されます。インデックスエントリの数は、ページ単位のリレーションのサイズを、 &lt;code&gt;pages_per_range&lt;/code&gt; で選択した値で割った値に等しくなります。したがって、数値が小さいほど、インデックスは大きくなります（より多くのインデックスエントリを格納する必要があるため）。同時に、格納されるサマリーデータはより正確になり、インデックススキャン中により多くのデータブロックをスキップできます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
