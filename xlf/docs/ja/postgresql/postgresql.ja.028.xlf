<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="95363da9cd107f5dcc6d6108200a75dee0fecc9d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;client_id&lt;/code&gt; indicates which client session ran the transaction, &lt;code&gt;transaction_no&lt;/code&gt; counts how many transactions have been run by that session, &lt;code&gt;time&lt;/code&gt; is the total elapsed transaction time in microseconds, &lt;code&gt;script_no&lt;/code&gt; identifies which script file was used (useful when multiple scripts were specified with &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;-b&lt;/code&gt;), and &lt;code&gt;time_epoch&lt;/code&gt;/&lt;code&gt;time_us&lt;/code&gt; are a Unix-epoch time stamp and an offset in microseconds (suitable for creating an ISO 8601 time stamp with fractional seconds) showing when the transaction completed. The &lt;code&gt;schedule_lag&lt;/code&gt; field is the difference between the transaction's scheduled start time, and the time it actually started, in microseconds. It is only present when the &lt;code&gt;--rate&lt;/code&gt; option is used. When both &lt;code&gt;--rate&lt;/code&gt; and &lt;code&gt;--latency-limit&lt;/code&gt; are used, the &lt;code&gt;time&lt;/code&gt; for a skipped transaction will be reported as &lt;code&gt;skipped&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;client_id&lt;/code&gt; はトランザクションを &lt;code&gt;transaction_no&lt;/code&gt; したクライアントセッションを示し、transaction_noはそのセッションで実行されたトランザクション数をカウントし &lt;code&gt;script_no&lt;/code&gt; はマイクロ秒単位の合計トランザクション経過 &lt;code&gt;time&lt;/code&gt; です。script_noは使用されたスクリプトファイルを示します（ &lt;code&gt;-f&lt;/code&gt; または &lt;code&gt;-b&lt;/code&gt; ）、および &lt;code&gt;time_epoch&lt;/code&gt; / &lt;code&gt;time_us&lt;/code&gt; は、トランザクションがいつ完了したかを示すUnixエポックタイムスタンプとマイクロ秒単位のオフセット（小数秒のISO 8601タイムスタンプの作成に適しています）です。 &lt;code&gt;schedule_lag&lt;/code&gt; フィールドは、トランザクションのスケジュールされた開始時刻と実際に開始した時刻の差（マイクロ秒単位）です。 &lt;code&gt;--rate&lt;/code&gt; オプションが使用されている場合にのみ存在します。両方の場合は &lt;code&gt;--rate&lt;/code&gt; と &lt;code&gt;--latency-limit&lt;/code&gt; 使用され、 &lt;code&gt;time&lt;/code&gt; スキップされたトランザクションのためには、として報告されます &lt;code&gt;skipped&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15575bf8bc20a17322a91c6a004375b23fe3bede" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;collation&lt;/code&gt; is a possibly schema-qualified identifier. The &lt;code&gt;COLLATE&lt;/code&gt; clause binds tighter than operators; parentheses can be used when necessary.</source>
          <target state="translated">ここで、 &lt;code&gt;collation&lt;/code&gt; はスキーマで修飾されている可能性のある識別子です。 &lt;code&gt;COLLATE&lt;/code&gt; の句は、演算子より緊密な結合します; 括弧は必要に応じて使用できます。</target>
        </trans-unit>
        <trans-unit id="cd38ffefd9af14e03f114a3c898a1682942460e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">ここで、 &lt;code&gt;condition&lt;/code&gt; は &lt;code&gt;boolean&lt;/code&gt; 型の結果に評価される任意の式です。この条件を満たさない行は出力から削除されます。実際の行の値が変数参照の代わりに使用されたときにtrueが返された場合、その行は条件を満たしています。</target>
        </trans-unit>
        <trans-unit id="883e212f0298979617ff0fdf44518bd05a084205" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">ここで、 &lt;code&gt;condition&lt;/code&gt; は &lt;code&gt;boolean&lt;/code&gt; 型の結果に評価される任意の式です。この条件を満たさない行は、テーブルに挿入されません。実際の行の値が変数参照の代わりに使用されたときにtrueが返された場合、その行は条件を満たしています。</target>
        </trans-unit>
        <trans-unit id="50d757545c644d09173ed3fc8ac85d6de14f6f0b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is the same as specified for the &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">where &lt;code&gt;condition&lt;/code&gt; は、 &lt;code&gt;WHERE&lt;/code&gt; 句に指定されたものと同じです。</target>
        </trans-unit>
        <trans-unit id="0e39ffa4c4736dc3798858fa334aa10d101b9ea1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;config_name&lt;/code&gt; is a column in the &lt;code&gt;pgweb&lt;/code&gt; table. This allows mixed configurations in the same index while recording which configuration was used for each index entry. This would be useful, for example, if the document collection contained documents in different languages. Again, queries that are meant to use the index must be phrased to match, e.g., &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;config_name&lt;/code&gt; は &lt;code&gt;pgweb&lt;/code&gt; テーブルの列です。これにより、各インデックスエントリに使用された構成を記録しながら、同じインデックスで混合構成を使用できます。これは、たとえば、ドキュメントコレクションにさまざまな言語のドキュメントが含まれている場合に役立ちます。繰り返しになりますが、インデックスを使用することを目的としたクエリは、一致するようにフレーズを指定する必要があります &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt; 例：WHERE to_tsvector（config_name、body）@@ 'a＆b'）。</target>
        </trans-unit>
        <trans-unit id="0e33c809b5aed59b29d15e3755cf042bcd7cf972" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dbname&lt;/code&gt; is the name of the already-created database to test in. (You may also need &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and/or &lt;code&gt;-U&lt;/code&gt; options to specify how to connect to the database server.)</source>
          <target state="translated">ここで、 &lt;code&gt;dbname&lt;/code&gt; は、テスト用にすでに作成されているデータベースの名前です（データベースサーバーへの接続方法を指定するには、 &lt;code&gt;-h&lt;/code&gt; 、 &lt;code&gt;-p&lt;/code&gt; 、 &lt;code&gt;-U&lt;/code&gt; オプションも必要になる場合があります）。</target>
        </trans-unit>
        <trans-unit id="2efafe66fc0fb01790e7b075da02f4b34a5191f4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;delim&lt;/code&gt; is the delimiter character for the type, as recorded in its &lt;code&gt;pg_type&lt;/code&gt; entry. Among the standard data types provided in the PostgreSQL distribution, all use a comma (&lt;code&gt;,&lt;/code&gt;), except for type &lt;code&gt;box&lt;/code&gt; which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). Each &lt;code&gt;val&lt;/code&gt; is either a constant of the array element type, or a subarray. An example of an array constant is:</source>
          <target state="translated">ここで、 &lt;code&gt;delim&lt;/code&gt; は、 &lt;code&gt;pg_type&lt;/code&gt; エントリに記録されているタイプの区切り文字です。セミコロン（ &lt;code&gt;;&lt;/code&gt; ）を使用するタイプ &lt;code&gt;box&lt;/code&gt; を除いて、PostgreSQLディストリビューションで提供される標準のデータタイプの中で、すべてカンマ（ &lt;code&gt;,&lt;/code&gt; ）を使用します。各 &lt;code&gt;val&lt;/code&gt; は、配列要素タイプの定数またはサブ配列です。配列定数の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="cc0c370cc6c4db09350c38f91dbc0ead530523ea" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;digits&lt;/code&gt; is one or more decimal digits (0 through 9). At least one digit must be before or after the decimal point, if one is used. At least one digit must follow the exponent marker (&lt;code&gt;e&lt;/code&gt;), if one is present. There cannot be any spaces or other characters embedded in the constant. Note that any leading plus or minus sign is not actually considered part of the constant; it is an operator applied to the constant.</source>
          <target state="translated">ここで、 &lt;code&gt;digits&lt;/code&gt; は1つ以上の10進数（0から9）です。小数点を使用する場合、少なくとも1桁は小数点の前または後になければなりません。指数マーカーがある場合、少なくとも1桁は指数マーカー（ &lt;code&gt;e&lt;/code&gt; ）の後に続く必要があります。定数にスペースやその他の文字を埋め込むことはできません。先頭のプラス記号またはマイナス記号は、実際には定数の一部とは見なされないことに注意してください。これは定数に適用される演算子です。</target>
        </trans-unit>
        <trans-unit id="bfd7fccfedd66d19eee35d6037183fff7ab24667" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;documents&lt;/code&gt; is a table that has a text field &lt;code&gt;bodytext&lt;/code&gt; that we wish to search. The reason for using the &lt;code&gt;simple&lt;/code&gt; configuration with the &lt;code&gt;to_tsvector&lt;/code&gt; function, instead of using a language-specific configuration, is that we want a list of the original (unstemmed) words.</source>
          <target state="translated">どこ &lt;code&gt;documents&lt;/code&gt; テキストフィールドがあるテーブルで &lt;code&gt;bodytext&lt;/code&gt; 我々が検索したいということを。言語固有の構成を使用するのではなく、 &lt;code&gt;to_tsvector&lt;/code&gt; 関数で &lt;code&gt;simple&lt;/code&gt; 構成を使用する理由は、元の（ステムされていない）単語のリストが必要なためです。</target>
        </trans-unit>
        <trans-unit id="9a039bb227f52a1b9a93d81d62221c9b30047689" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dumpfile&lt;/code&gt; is the file output by the pg_dump command. The database &lt;code&gt;dbname&lt;/code&gt; will not be created by this command, so you must create it yourself from &lt;code&gt;template0&lt;/code&gt; before executing psql (e.g., with &lt;code&gt;createdb -T template0 dbname&lt;/code&gt;). psql supports options similar to pg_dump for specifying the database server to connect to and the user name to use. See the &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; reference page for more information. Non-text file dumps are restored using the &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; utility.</source>
          <target state="translated">ここで、 &lt;code&gt;dumpfile&lt;/code&gt; はpg_dumpコマンドによって出力されるファイルです。データベースの &lt;code&gt;dbname&lt;/code&gt; あなたからそれを自分で作成する必要がありますので、このコマンドによって作成されることはありません &lt;code&gt;template0&lt;/code&gt; （と、例えばpsqlを実行する前に、 &lt;code&gt;createdb -T template0 dbname&lt;/code&gt; ）。psqlは、接続するデータベースサーバーと使用するユーザー名を指定するためのpg_dumpと同様のオプションをサポートしています。詳細については、&lt;a href=&quot;app-psql&quot;&gt;psqlの&lt;/a&gt;リファレンスページを参照してください。非テキストファイルのダンプは、&lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt;ユーティリティを使用して復元されます。</target>
        </trans-unit>
        <trans-unit id="e33127f2af6130f52a3e81c11a87546a1d4d1276" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; can be one of</source>
          <target state="translated">ここで、 &lt;code&gt;frame_start&lt;/code&gt; および &lt;code&gt;frame_end&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="2f4a0bb9f112237b3006e826384b66b73f19342f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e. the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="translated">ここ &lt;code&gt;interval_start&lt;/code&gt; は（Unixのエポックタイムスタンプなど）間隔の開始である、 &lt;code&gt;num_transactions&lt;/code&gt; は間隔内のトランザクションの数であり、 &lt;code&gt;sum_latency&lt;/code&gt; が間隔内トランザクション待ち時間の和であり、 &lt;code&gt;sum_latency_2&lt;/code&gt; は内トランザクション待ち時間の二乗の合計であります間隔は、 &lt;code&gt;min_latency&lt;/code&gt; は区間内の最小の待ち時間であり、そして &lt;code&gt;max_latency&lt;/code&gt; は区間内の最大待ち時間です。次のフィールド、 &lt;code&gt;sum_lag&lt;/code&gt; 、 &lt;code&gt;sum_lag_2&lt;/code&gt; 、 &lt;code&gt;min_lag&lt;/code&gt; 、および &lt;code&gt;max_lag&lt;/code&gt; があれば、唯一の存在です &lt;code&gt;--rate&lt;/code&gt; オプションが使用されます。これらは、各トランザクションが前のトランザクションの終了を待機する必要があった時間、つまり各トランザクションのスケジュールされた開始時間と実際に開始された時間の差に関する統計を提供します。最後のフィールド &lt;code&gt;skipped&lt;/code&gt; は、 &lt;code&gt;--latency-limit&lt;/code&gt; オプションも使用されている場合にのみ存在します。開始が遅すぎたためにスキップされたトランザクションの数をカウントします。各トランザクションは、コミットされた間隔でカウントされます。</target>
        </trans-unit>
        <trans-unit id="21a535125ba922f6008364af8c73fa378c746f74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e., the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="translated">ここで、 &lt;code&gt;interval_start&lt;/code&gt; は間隔の開始（Unixエポックタイムスタンプとして）、 &lt;code&gt;num_transactions&lt;/code&gt; は間隔内のトランザクションの数、 &lt;code&gt;sum_latency&lt;/code&gt; は間隔内のトランザクション待ち時間の合計、 &lt;code&gt;sum_latency_2&lt;/code&gt; は内のトランザクション待ち時間の2乗の合計です。間隔は、 &lt;code&gt;min_latency&lt;/code&gt; は区間内の最小の待ち時間であり、そして &lt;code&gt;max_latency&lt;/code&gt; は区間内の最大待ち時間です。次のフィールド &lt;code&gt;sum_lag&lt;/code&gt; 、 &lt;code&gt;sum_lag_2&lt;/code&gt; 、 &lt;code&gt;min_lag&lt;/code&gt; 、および &lt;code&gt;max_lag&lt;/code&gt; は、 &lt;code&gt;--rate&lt;/code&gt; 場合にのみ存在します。オプションが使用されます。これらは、各トランザクションが前のトランザクションが終了するのを待たなければならなかった時間、つまり、各トランザクションのスケジュールされた開始時間と実際に開始された時間の差に関する統計を提供します。 &lt;code&gt;skipped&lt;/code&gt; 最後のフィールドは、 &lt;code&gt;--latency-limit&lt;/code&gt; オプションも使用されている場合にのみ存在します。開始が遅すぎたためにスキップされたトランザクションの数をカウントします。各トランザクションは、コミットされた間隔でカウントされます。</target>
        </trans-unit>
        <trans-unit id="02521c4b560914d5a494676dd3a10eaddf5a2d27" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. &lt;code&gt;pg_start_backup&lt;/code&gt; creates a &lt;em&gt;backup label&lt;/em&gt; file, called &lt;code&gt;backup_label&lt;/code&gt;, in the cluster directory with information about your backup, including the start time and label string. The function also creates a &lt;em&gt;tablespace map&lt;/em&gt; file, called &lt;code&gt;tablespace_map&lt;/code&gt;, in the cluster directory with information about tablespace symbolic links in &lt;code&gt;pg_tblspc/&lt;/code&gt; if one or more such link is present. Both files are critical to the integrity of the backup, should you need to restore from it.</source>
          <target state="translated">ここで、 &lt;code&gt;label&lt;/code&gt; は、このバックアップ操作を一意に識別するために使用する文字列です。 &lt;code&gt;pg_start_backup&lt;/code&gt; は、作成し&lt;em&gt;たバックアップラベル&lt;/em&gt;と呼ばれるファイル、 &lt;code&gt;backup_label&lt;/code&gt; を開始時刻とラベル文字列を含むバックアップに関する情報を、とクラスタディレクトリで、。関数は、作成し&lt;em&gt;た表領域マップ&lt;/em&gt;と呼ばれるファイル、 &lt;code&gt;tablespace_map&lt;/code&gt; に表領域のシンボリックリンクに関する情報とクラスタディレクトリ内に、 &lt;code&gt;pg_tblspc/&lt;/code&gt; 1つまたは複数のそのようなリンクが存在する場合。両方のファイルは、バックアップから復元する必要がある場合に備えて、バックアップの整合性にとって重要です。</target>
        </trans-unit>
        <trans-unit id="2632c6a394b4c5afed578e3db6104be70d7c969c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. The connection calling &lt;code&gt;pg_start_backup&lt;/code&gt; must be maintained until the end of the backup, or the backup will be automatically aborted.</source>
          <target state="translated">ここで、 &lt;code&gt;label&lt;/code&gt; は、このバックアップ操作を一意に識別するために使用する文字列です。 &lt;code&gt;pg_start_backup&lt;/code&gt; を呼び出す接続は、バックアップが終了するまで維持する必要があります。そうしないと、バックアップは自動的に中止されます。</target>
        </trans-unit>
        <trans-unit id="14ec95115d9949716f5574166b53e4a99c82ef40" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;lock_strength&lt;/code&gt; can be one of</source>
          <target state="translated">ここで、 &lt;code&gt;lock_strength&lt;/code&gt; は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="bc24930f3c49a2f1c610c96b58a313a1bb2f6567" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;name&lt;/code&gt; follows the usual rules for SQL identifiers. The current role automatically becomes the owner of the new database. It is the privilege of the owner of a database to remove it later (which also removes all the objects in it, even if they have a different owner).</source>
          <target state="translated">ここで、 &lt;code&gt;name&lt;/code&gt; はSQL識別子の通常の規則に従います。現在のロールが自動的に新しいデータベースの所有者になります。後でデータベースを削除するのは、データベースの所有者の権限です（所有者が異なる場合でも、データベース内のすべてのオブジェクトが削除されます）。</target>
        </trans-unit>
        <trans-unit id="2e04d3386ac5dbafbf688329834c2f0edf9b1b29" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;num_sync&lt;/code&gt; is the number of synchronous standbys that transactions need to wait for replies from, and &lt;code&gt;standby_name&lt;/code&gt; is the name of a standby server. &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;ANY&lt;/code&gt; specify the method to choose synchronous standbys from the listed servers.</source>
          <target state="translated">ここで、 &lt;code&gt;num_sync&lt;/code&gt; はトランザクションが応答を待機する必要がある同期スタンバイの数であり、 &lt;code&gt;standby_name&lt;/code&gt; はスタンバイサーバーの名前です。 &lt;code&gt;FIRST&lt;/code&gt; および &lt;code&gt;ANY&lt;/code&gt; は、リストされたサーバーから同期スタンバイを選択する方法を指定します。</target>
        </trans-unit>
        <trans-unit id="051ce8638a4cb0df58ccc78d0226c857003f3754" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.</source>
          <target state="translated">どこ &lt;code&gt;old_cluster&lt;/code&gt; と &lt;code&gt;new_cluster&lt;/code&gt; は主に、現在のディレクトリに対して相対的である、と &lt;code&gt;remote_dir&lt;/code&gt; がある&lt;em&gt;上に&lt;/em&gt;、スタンバイ上の古いものと新しいクラスタディレクトリ。プライマリとスタンバイの指定されたディレクトリの下のディレクトリ構造は一致している必要があります。リモートディレクトリの指定の詳細については、rsyncのマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="a7b5550c4042ab7be1b02d82ee60cb4e972c7064" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.,</source>
          <target state="translated">どこ &lt;code&gt;old_cluster&lt;/code&gt; と &lt;code&gt;new_cluster&lt;/code&gt; は主に、現在のディレクトリに対して相対的である、と &lt;code&gt;remote_dir&lt;/code&gt; がある&lt;em&gt;上に&lt;/em&gt;、スタンバイ上の古いものと新しいクラスタディレクトリ。プライマリとスタンバイの指定されたディレクトリの下のディレクトリ構造は一致する必要があります。リモートディレクトリの指定の詳細については、rsyncのマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="6995f4e58e8fe029424bd429b077f2eb8c3fe1f6" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is an optional precision specification giving the number of fractional digits in the seconds field. Precision can be specified for &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt; types, and can range from 0 to 6. If no precision is specified in a constant specification, it defaults to the precision of the literal value (but not more than 6 digits).</source>
          <target state="translated">ここで、 &lt;code&gt;p&lt;/code&gt; は、秒フィールドの小数桁数を指定するオプションの精度指定です。精度は、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;timestamp&lt;/code&gt; 、および &lt;code&gt;interval&lt;/code&gt; タイプで指定でき、0から6の範囲で指定できます。定数指定で精度が指定されていない場合、デフォルトでリテラル値の精度になります（ただし、6桁以下）。</target>
        </trans-unit>
        <trans-unit id="3ae43e1773ab7435ea942bef4aab35ea977ed17e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;quantity&lt;/code&gt; is a number (possibly signed); &lt;code&gt;unit&lt;/code&gt; is &lt;code&gt;microsecond&lt;/code&gt;, &lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;week&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, &lt;code&gt;millennium&lt;/code&gt;, or abbreviations or plurals of these units; &lt;code&gt;direction&lt;/code&gt; can be &lt;code&gt;ago&lt;/code&gt; or empty. The at sign (&lt;code&gt;@&lt;/code&gt;) is optional noise. The amounts of the different units are implicitly added with appropriate sign accounting. &lt;code&gt;ago&lt;/code&gt; negates all the fields. This syntax is also used for interval output, if &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; is set to &lt;code&gt;postgres_verbose&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;quantity&lt;/code&gt; は数値です（おそらく署名されています）。 &lt;code&gt;unit&lt;/code&gt; ある &lt;code&gt;microsecond&lt;/code&gt; 、 &lt;code&gt;millisecond&lt;/code&gt; 、 &lt;code&gt;second&lt;/code&gt; 、 &lt;code&gt;minute&lt;/code&gt; 、 &lt;code&gt;hour&lt;/code&gt; 、 &lt;code&gt;day&lt;/code&gt; 、 &lt;code&gt;week&lt;/code&gt; 、 &lt;code&gt;month&lt;/code&gt; 、 &lt;code&gt;year&lt;/code&gt; 、 &lt;code&gt;decade&lt;/code&gt; 、 &lt;code&gt;century&lt;/code&gt; 、 &lt;code&gt;millennium&lt;/code&gt; 、あるいはこれらの単位の略語や複数形。 &lt;code&gt;direction&lt;/code&gt; は &lt;code&gt;ago&lt;/code&gt; でも空でもかまいません。アットマーク（ &lt;code&gt;@&lt;/code&gt; ）はオプションのノイズです。異なる単位の金額は、適切な符号会計で暗黙的に追加されます。 &lt;code&gt;ago&lt;/code&gt; すべてのフィールドを否定します。この構文は、&lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt;が &lt;code&gt;postgres_verbose&lt;/code&gt; に設定されている場合、間隔出力にも使用されます。</target>
        </trans-unit>
        <trans-unit id="bb85a9d1ba20986c4eabc4c0cc672867a0082382" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;salt&lt;/code&gt;, &lt;code&gt;StoredKey&lt;/code&gt; and &lt;code&gt;ServerKey&lt;/code&gt; are in Base64 encoded format. This format is the same as that specified by RFC 5803.</source>
          <target state="translated">ここで、 &lt;code&gt;salt&lt;/code&gt; 、 &lt;code&gt;StoredKey&lt;/code&gt; 、および &lt;code&gt;ServerKey&lt;/code&gt; はBase64エンコード形式です。この形式は、RFC 5803で指定されている形式と同じです。</target>
        </trans-unit>
        <trans-unit id="902cd914b55268a7f42373967de3300fb2a6df74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;search_condition&lt;/code&gt; is any value expression (see &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;) that returns a value of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;search_condition&lt;/code&gt; は、 &lt;code&gt;boolean&lt;/code&gt; 型の値を返す任意の値式（&lt;a href=&quot;sql-expressions&quot;&gt;セクション4.2を&lt;/a&gt;参照）です。</target>
        </trans-unit>
        <trans-unit id="9cab206ed9f849b266fa8bbb5c105eda41d171c2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_definition&lt;/code&gt; has the syntax</source>
          <target state="translated">ここで、 &lt;code&gt;window_definition&lt;/code&gt; の構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1ffcb73100c9208f3d73e7359a7710f21793aea4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_name&lt;/code&gt; is a name that can be referenced from &lt;code&gt;OVER&lt;/code&gt; clauses or subsequent window definitions, and &lt;code&gt;window_definition&lt;/code&gt; is</source>
          <target state="translated">ここで、 &lt;code&gt;window_name&lt;/code&gt; は &lt;code&gt;OVER&lt;/code&gt; 句または後続のウィンドウ定義から参照できる名前で、 &lt;code&gt;window_definition&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="05865f2594ddc7befb862529cd119701ff24e8ac" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the respective coordinates, as floating-point numbers.</source>
          <target state="translated">ここで、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は、浮動小数点数としてのそれぞれの座標です。</target>
        </trans-unit>
        <trans-unit id="63a67aa07860e75ed55512e599efa11799c590cd" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; is a single character with no other significance, matches that character</source>
          <target state="translated">ここで、 &lt;code&gt;x&lt;/code&gt; は他に意味のない単一の文字であり、その文字に一致します</target>
        </trans-unit>
        <trans-unit id="2cfc72d3af1bb50704e8aee07809af6321faa971" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;xsi&lt;/code&gt; is the XML namespace prefix for XML Schema Instance. An appropriate namespace declaration will be added to the result value. If false, columns containing null values are simply omitted from the output.</source>
          <target state="translated">ここで、 &lt;code&gt;xsi&lt;/code&gt; はXMLスキーマインスタンスのXML名前空間プレフィックスです。適切な名前空間宣言が結果値に追加されます。falseの場合、null値を含む列は出力から単に省略されます。</target>
        </trans-unit>
        <trans-unit id="cbd4a92c9b71cd49ffa17bbdcc8f19ea4f09000a" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="translated">ここで、 &lt;code&gt;nextval()&lt;/code&gt; 関数は&lt;em&gt;シーケンスオブジェクト&lt;/em&gt;から連続した値を提供し&lt;em&gt;ます&lt;/em&gt;（&lt;a href=&quot;functions-sequence&quot;&gt;セクション9.16を&lt;/a&gt;参照）。この配置は十分に一般的であるため、特別な省略形があります。</target>
        </trans-unit>
        <trans-unit id="7bd08f9310fcb14cbd5436b568512ce2df9ab484" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="translated">ここで、 &lt;code&gt;nextval()&lt;/code&gt; 関数は、&lt;em&gt;シーケンスオブジェクト&lt;/em&gt;から連続する値を提供し&lt;em&gt;ます&lt;/em&gt;（&lt;a href=&quot;functions-sequence&quot;&gt;セクション9.17を&lt;/a&gt;参照）。この配置は十分に一般的であるため、特別な省略形があります。</target>
        </trans-unit>
        <trans-unit id="9f13f6d0c9013e1b5a9453aad6e84166421dc49f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;operator&lt;/code&gt; token follows the syntax rules of &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;Section 4.1.3&lt;/a&gt;, or is one of the key words &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;, or is a qualified operator name in the form:</source>
          <target state="translated">どこ &lt;code&gt;operator&lt;/code&gt; の構文規則は次のトークン&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;4.1.3項を&lt;/a&gt;、またはキーワードの一つであり &lt;code&gt;AND&lt;/code&gt; 、 &lt;code&gt;OR&lt;/code&gt; 、および &lt;code&gt;NOT&lt;/code&gt; 、またはフォームで修飾された演算子名です。</target>
        </trans-unit>
        <trans-unit id="8a017c95f90d3833011c4cbc0c74fcbcfe44ef42" translate="yes" xml:space="preserve">
          <source>where the archive directory is physically located on the standby server, so that the &lt;code&gt;archive_command&lt;/code&gt; is accessing it across NFS, but the files are local to the standby. This will:</source>
          <target state="translated">ここで、アーカイブディレクトリはスタンバイサーバーに物理的に配置されています。これにより、 &lt;code&gt;archive_command&lt;/code&gt; はNFS経由でアーカイブディレクトリにアクセスしますが、ファイルはスタンバイに対してローカルです。この意志：</target>
        </trans-unit>
        <trans-unit id="a6b4be2958f0bb91c3ed3c4e4583c088a4832f4d" translate="yes" xml:space="preserve">
          <source>where the colon (&lt;code&gt;:&lt;/code&gt;) symbol acts as a delimiter between a phrase and its replacement.</source>
          <target state="translated">ここで、コロン（ &lt;code&gt;:&lt;/code&gt; ）記号は、フレーズとその交換の間の区切り文字として機能します。</target>
        </trans-unit>
        <trans-unit id="e11e7f071949ee7312e3026921c20a83a618fe45" translate="yes" xml:space="preserve">
          <source>where the comment begins with &lt;code&gt;/*&lt;/code&gt; and extends to the matching occurrence of &lt;code&gt;*/&lt;/code&gt;. These block comments nest, as specified in the SQL standard but unlike C, so that one can comment out larger blocks of code that might contain existing block comments.</source>
          <target state="translated">コメントは &lt;code&gt;/*&lt;/code&gt; で始まり、一致する &lt;code&gt;*/&lt;/code&gt; まで続きます。これらのブロックコメントは、SQL標準で指定されているようにネストされますが、Cとは異なり、既存のブロックコメントを含む可能性のあるコードのより大きなブロックをコメント化できます。</target>
        </trans-unit>
        <trans-unit id="8e7c67b39887933602dcee06120320113183300a" translate="yes" xml:space="preserve">
          <source>where the component fields are:</source>
          <target state="translated">コンポーネントフィールドがあるところ。</target>
        </trans-unit>
        <trans-unit id="0a5be562692973652e8751f219be291ae87f74a1" translate="yes" xml:space="preserve">
          <source>where the file name for the source file must be available on the machine running the backend process, not the client, since the backend process reads the file directly. You can read more about the &lt;code&gt;COPY&lt;/code&gt; command in &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;.</source>
          <target state="translated">ソースファイルのファイル名は、クライアントではなく、バックエンドプロセスを実行しているマシンで使用できる必要があります。これは、バックエンドプロセスがファイルを直接読み取るためです。 &lt;code&gt;COPY&lt;/code&gt; コマンドの詳細については、&lt;a href=&quot;sql-copy&quot;&gt;COPYを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aca0a6010ee58659cb962578b12187acb232c0bd" translate="yes" xml:space="preserve">
          <source>where the format of a table mapping depends on the &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; parameter as explained above.</source>
          <target state="translated">上記で説明したように、テーブルマッピングの形式は&lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; &lt;/em&gt;パラメータに依存します。</target>
        </trans-unit>
        <trans-unit id="c322d4fb81e0c24a81de070751209570b9a21fe2" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the boundary of the polygon.</source>
          <target state="translated">ここで、点は多角形の境界を構成する線分の端点である。</target>
        </trans-unit>
        <trans-unit id="f3a39e39e3dc55cc38a327aeb589b6bbda39e7f5" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the path. Square brackets (&lt;code&gt;[]&lt;/code&gt;) indicate an open path, while parentheses (&lt;code&gt;()&lt;/code&gt;) indicate a closed path. When the outermost parentheses are omitted, as in the third through fifth syntaxes, a closed path is assumed.</source>
          <target state="translated">ここで、ポイントはパスを構成する線分の端点です。角括弧（ &lt;code&gt;[]&lt;/code&gt; ）は開いたパスを示し、括弧（ &lt;code&gt;()&lt;/code&gt; ）は閉じたパスを示します。3番目から5番目の構文のように、最も外側の括弧が省略されると、閉じたパスが想定されます。</target>
        </trans-unit>
        <trans-unit id="8b49a312334fd1bdab104f06f0ce7761910dd239" translate="yes" xml:space="preserve">
          <source>where the recursive self-reference must appear on the right-hand side of the &lt;code&gt;UNION&lt;/code&gt;. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive &lt;code&gt;SELECT&lt;/code&gt; query in a data-modifying statement. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for an example.</source>
          <target state="translated">ここで、再帰的な自己参照は &lt;code&gt;UNION&lt;/code&gt; の右側にある必要があります。クエリごとに許可される再帰的自己参照は1つだけです。再帰的なデータ変更ステートメントはサポートされていませんが、再帰的な &lt;code&gt;SELECT&lt;/code&gt; クエリの結果をデータ変更ステートメントで使用できます。例については、&lt;a href=&quot;queries-with&quot;&gt;セクション7.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1dab6fc9fba9dce67d798f2e3e758f073548c0c8" translate="yes" xml:space="preserve">
          <source>where the schema mapping is as above.</source>
          <target state="translated">ここで、スキーママッピングは上記のようになります。</target>
        </trans-unit>
        <trans-unit id="382029671c1699461f42fe369fd317b19afaa4b7" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="translated">ここで、真空ベースのしきい値は&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;であり、真空スケール係数は&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;であり、タプルの数は &lt;code&gt;pg_class&lt;/code&gt; です。 &lt;code&gt;reltuples&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e9fff4ccdc17ba4f1e6aa42fae36f876c94b66d" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;. The number of obsolete tuples is obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="translated">ここで、バキュームベースのしきい値は&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;、バキュームスケール係数は&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;、タプルの数は &lt;code&gt;pg_class&lt;/code&gt; です。 &lt;code&gt;reltuples&lt;/code&gt; 。廃止されたタプルの数は、統計コレクターから取得されます。これは、 &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; 操作ごとに更新される半正確なカウントです。 （負荷が高いと一部の情報が失われる可能性があるため、これは半正確です。）テーブルの &lt;code&gt;relfrozenxid&lt;/code&gt; 値が古い &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; トランザクションよりも大きい場合、積極的なバキュームが実行され、古いタプルが凍結され、 &lt;code&gt;relfrozenxid&lt;/code&gt; が進みます。; それ以外の場合は、最後のバキューム以降に変更されたページのみがスキャンされます。</target>
        </trans-unit>
        <trans-unit id="2c431885a457348236e447edee84410e42626acc" translate="yes" xml:space="preserve">
          <source>where the vacuum insert base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt;, and vacuum insert scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt;. Such vacuums may allow portions of the table to be marked as &lt;em&gt;all visible&lt;/em&gt; and also allow tuples to be frozen, which can reduce the work required in subsequent vacuums. For tables which receive &lt;code&gt;INSERT&lt;/code&gt; operations but no or almost no &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; operations, it may be beneficial to lower the table's &lt;a href=&quot;sql-createtable#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE&quot;&gt;autovacuum_freeze_min_age&lt;/a&gt; as this may allow tuples to be frozen by earlier vacuums. The number of obsolete tuples and the number of inserted tuples are obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="translated">ここで、真空インサートのベースしきい値は&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt;であり、真空インサートのスケール係数は&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt;です。このような掃除機を使用すると、テーブルの一部を&lt;em&gt;すべて表示&lt;/em&gt;できるようにマークしたり、タプルを凍結したりできるため、後続の掃除機で必要な作業を減らすことができます。 &lt;code&gt;INSERT&lt;/code&gt; 操作を受信するが、 &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; 操作をまったくまたはほとんど受信しないテーブルの&lt;a href=&quot;sql-createtable#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE&quot;&gt;場合&lt;/a&gt;、テーブルのautovacuum_freeze_min_ageを下げることが有益な場合があります。これにより、タプルが以前の掃除機で凍結される可能性があるためです。廃止されたタプルの数と挿入されたタプルの数は、統計コレクターから取得されます。これは、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、および &lt;code&gt;INSERT&lt;/code&gt; 操作ごとに更新される半正確なカウントです。 （高負荷で一部の情報が失われる可能性があるため、半正確です。）テーブルの &lt;code&gt;relfrozenxid&lt;/code&gt; 値が &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; トランザクションよりも古い場合、積極的なバキュームが実行され、古いタプルがフリーズされ、 &lt;code&gt;relfrozenxid&lt;/code&gt; が進められます。それ以外の場合は、最後のバキューム以降に変更されたページのみがスキャンされます。</target>
        </trans-unit>
        <trans-unit id="4e9d5d3d104047e0064d4303bd59ec16810bf890" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="translated">自分のログイン名が記載されている場所。これは、管理者がPostgreSQLユーザーアカウントを作成していない場合に発生します。（PostgreSQLのユーザーアカウントは、オペレーティングシステムのユーザーアカウントとは異なります。）管理者である場合、アカウントの作成については、&lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;第21章を&lt;/a&gt;参照してください。最初のユーザーアカウントを作成するには、PostgreSQLがインストールされているオペレーティングシステムユーザー（通常は &lt;code&gt;postgres&lt;/code&gt; ）になる必要があります。また、オペレーティングシステムのユーザー名とは異なるPostgreSQLユーザー名が割り当てられている可能性もあります。その場合、 &lt;code&gt;-U&lt;/code&gt; スイッチを使用するか、 &lt;code&gt;PGUSER&lt;/code&gt; 環境変数を設定して、PostgreSQLユーザー名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="0112d5560695a821c035d2d69c40472d94f7f8cb" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="translated">あなた自身のログイン名が言及されているところ。これは、管理者がPostgreSQLユーザーアカウントを作成していない場合に発生します。 （PostgreSQLユーザーアカウントはオペレーティングシステムのユーザーアカウントとは異なります。）管理者の場合は、アカウントの作成について&lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;第21章を&lt;/a&gt;参照してください。最初のユーザーアカウントを作成するには、PostgreSQLがインストールされているオペレーティングシステムユーザー（通常は &lt;code&gt;postgres&lt;/code&gt; ）になる必要があります。オペレーティングシステムのユーザー名とは異なるPostgreSQLユーザー名が割り当てられている可能性もあります。その場合は、 &lt;code&gt;-U&lt;/code&gt; スイッチを使用するか、 &lt;code&gt;PGUSER&lt;/code&gt; 環境変数を設定してPostgreSQLユーザー名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f1cf5f67d7b1357c152874d6df8382f05565c46" translate="yes" xml:space="preserve">
          <source>which displays per-product sales totals in only the top sales regions. The &lt;code&gt;WITH&lt;/code&gt; clause defines two auxiliary statements named &lt;code&gt;regional_sales&lt;/code&gt; and &lt;code&gt;top_regions&lt;/code&gt;, where the output of &lt;code&gt;regional_sales&lt;/code&gt; is used in &lt;code&gt;top_regions&lt;/code&gt; and the output of &lt;code&gt;top_regions&lt;/code&gt; is used in the primary &lt;code&gt;SELECT&lt;/code&gt; query. This example could have been written without &lt;code&gt;WITH&lt;/code&gt;, but we'd have needed two levels of nested sub-&lt;code&gt;SELECT&lt;/code&gt;s. It's a bit easier to follow this way.</source>
          <target state="translated">上位の販売地域のみの製品ごとの売上合計を表示します。 &lt;code&gt;WITH&lt;/code&gt; の句は、という2つの補助文定義 &lt;code&gt;regional_sales&lt;/code&gt; と &lt;code&gt;top_regions&lt;/code&gt; の出力、 &lt;code&gt;regional_sales&lt;/code&gt; がで使用され &lt;code&gt;top_regions&lt;/code&gt; の出力 &lt;code&gt;top_regions&lt;/code&gt; をプライマリに使用される &lt;code&gt;SELECT&lt;/code&gt; クエリを。この例は &lt;code&gt;WITH&lt;/code&gt; なしで作成することもできましたが、2つのレベルのネストされたサブ &lt;code&gt;SELECT&lt;/code&gt; が必要でした。この方法に従う方が少し簡単です。</target>
        </trans-unit>
        <trans-unit id="bae8a1a20973cccefd7c610839e91bd3974b4005" translate="yes" xml:space="preserve">
          <source>which finds the ten places closest to a given target point. The ability to do this is again dependent on the particular operator class being used. In &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;, operators that can be used in this way are listed in the column &amp;ldquo;Ordering Operators&amp;rdquo;.</source>
          <target state="translated">指定されたターゲットポイントに最も近い10の場所を検索します。これを行う機能は、使用される特定の演算子クラスに依存します。では&lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;、表64.1&lt;/a&gt;、このように使用することができます演算子は、列「注文演算子」に記載されています。</target>
        </trans-unit>
        <trans-unit id="8dfde0f1cc2ebaaf170e42acdfe9b417e65a8fd3" translate="yes" xml:space="preserve">
          <source>which gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using &lt;code&gt;HAVING&lt;/code&gt;:</source>
          <target state="translated">これにより、都市ごとに1つの出力行が得られます。各集計結果は、その都市に一致するテーブル行に対して計算されます。 &lt;code&gt;HAVING&lt;/code&gt; を使用して、これらのグループ化された行をフィルタリングできます。</target>
        </trans-unit>
        <trans-unit id="18b9fcfc65791db8244d0ec78c95baca6172d630" translate="yes" xml:space="preserve">
          <source>which gives us the same results for only the cities that have all &lt;code&gt;temp_lo&lt;/code&gt; values below 40. Finally, if we only care about cities whose names begin with &amp;ldquo;&lt;code&gt;S&lt;/code&gt;&amp;rdquo;, we might do:</source>
          <target state="translated">これにより、すべての &lt;code&gt;temp_lo&lt;/code&gt; 値が40未満の都市についてのみ同じ結果が得られます。最後に、名前が「 &lt;code&gt;S&lt;/code&gt; 」で始まる都市のみを考慮する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="689a2e02b1a49db16b3b1be754391d4fc8da64e0" translate="yes" xml:space="preserve">
          <source>which is executed as:</source>
          <target state="translated">として実行されます。</target>
        </trans-unit>
        <trans-unit id="f15875e884530dd30ab6d27db56535aa74c98f64" translate="yes" xml:space="preserve">
          <source>which obtains the 50th percentile, or median, value of the &lt;code&gt;income&lt;/code&gt; column from table &lt;code&gt;households&lt;/code&gt;. Here, &lt;code&gt;0.5&lt;/code&gt; is a direct argument; it would make no sense for the percentile fraction to be a value varying across rows.</source>
          <target state="translated">テーブル &lt;code&gt;households&lt;/code&gt; から &lt;code&gt;income&lt;/code&gt; 列の50パーセンタイル、つまり中央値を取得します。ここで、 &lt;code&gt;0.5&lt;/code&gt; は直接の引数です。パーセンタイル部分が行間で異なる値であっても意味がありません。</target>
        </trans-unit>
        <trans-unit id="f6ee8c6433c23fa17a7f1946c5c1b26470b55b09" translate="yes" xml:space="preserve">
          <source>which refers to a function with zero arguments, whereas the first variant can refer to a function with any number of arguments, including zero, as long as the name is unique.</source>
          <target state="translated">これは引数がゼロの関数を参照しますが、最初のバリアントは名前が一意である限り、ゼロを含む任意の数の引数を持つ関数を参照することができるのに対し、最初のバリアントはゼロを含む任意の数の引数を持つ関数を参照することができます。</target>
        </trans-unit>
        <trans-unit id="0e899e70b75b90b65729658ed54cd0ca39432992" translate="yes" xml:space="preserve">
          <source>which returns:</source>
          <target state="translated">を返します。</target>
        </trans-unit>
        <trans-unit id="74cad75d5e4f20aa31f501f8fefdc21abad67352" translate="yes" xml:space="preserve">
          <source>which shows that the planner thinks that sorting &lt;code&gt;onek&lt;/code&gt; by index-scanning is about 12% more expensive than sequential-scan-and-sort. Of course, the next question is whether it's right about that. We can investigate that using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, as discussed below.</source>
          <target state="translated">これは、プランナがインデックススキャンによる &lt;code&gt;onek&lt;/code&gt; の並べ替えは、順次スキャンと並べ替えよりも約12％高いと考えていることを示しています。もちろん、次の問題はそれが正しいかどうかです。以下で説明するように、 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を使用してそれを調査できます。</target>
        </trans-unit>
        <trans-unit id="7c0656a99c8833cfc345dd27d0b6820caa432991" translate="yes" xml:space="preserve">
          <source>which we wish to display like</source>
          <target state="translated">のように表示したい</target>
        </trans-unit>
        <trans-unit id="c282db8639e1ae34ff018f3c72116a8c43100b68" translate="yes" xml:space="preserve">
          <source>which will copy archivable WAL segments to the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. (This is an example, not a recommendation, and might not work on all platforms.) After the &lt;code&gt;%p&lt;/code&gt; and &lt;code&gt;%f&lt;/code&gt; parameters have been replaced, the actual command executed might look like this:</source>
          <target state="translated">&lt;code&gt;/mnt/server/archivedir&lt;/code&gt; 可能なWALセグメントをディレクトリ/ mnt / server / archivedirにコピーします。（これは例であり、推奨ではなく、すべてのプラットフォームで機能するとは限りません。） &lt;code&gt;%p&lt;/code&gt; および &lt;code&gt;%f&lt;/code&gt; パラメーターが置き換えられた後、実行される実際のコマンドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0a169e40949af2620c4e85dda15d79975492e73f" translate="yes" xml:space="preserve">
          <source>which will copy previously archived WAL segments from the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. Of course, you can use something much more complicated, perhaps even a shell script that requests the operator to mount an appropriate tape.</source>
          <target state="translated">以前にアーカイブされたWALセグメントを &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; ディレクトリからコピーします。もちろん、もっと複雑なものを使用することもできます。適切なテープをマウントするようオペレーターに要求するシェルスクリプトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="26cd6a2051ea99afa4a27d84b6ed47beb5036a7c" translate="yes" xml:space="preserve">
          <source>which will leave the server running in the foreground. This must be done while logged into the PostgreSQL user account. Without &lt;code&gt;-D&lt;/code&gt;, the server will try to use the data directory named by the environment variable &lt;code&gt;PGDATA&lt;/code&gt;. If that variable is not provided either, it will fail.</source>
          <target state="translated">これにより、サーバーがフォアグラウンドで実行されたままになります。これは、PostgreSQLユーザーアカウントにログインして行う必要があります。 &lt;code&gt;-D&lt;/code&gt; がない場合、サーバーは環境変数 &lt;code&gt;PGDATA&lt;/code&gt; 指定されたデータディレクトリを使用しようとします。その変数も提供されていない場合、失敗します。</target>
        </trans-unit>
        <trans-unit id="c4e8f14819326dd3aae3a2cf53d737470310c24e" translate="yes" xml:space="preserve">
          <source>which will match the stemmed form of &lt;code&gt;postgraduate&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;postgraduate&lt;/code&gt; の語幹形と一致します。</target>
        </trans-unit>
        <trans-unit id="5ff082187c1d02a1fdad2296ffb917870a45b03c" translate="yes" xml:space="preserve">
          <source>which would allow a box value's component numbers to be accessed by subscripting. Otherwise the type behaves the same as before.</source>
          <target state="translated">これは、ボックス値のコンポーネント番号に添え字でアクセスできるようにするためのものです。それ以外の場合、この型は以前と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="df5d2347727e9e14fc56d97420272403e963b0b6" translate="yes" xml:space="preserve">
          <source>which would be a valid value of the &lt;code&gt;inventory_item&lt;/code&gt; type defined above. To make a field be NULL, write no characters at all in its position in the list. For example, this constant specifies a NULL third field:</source>
          <target state="translated">これは、上で定義した &lt;code&gt;inventory_item&lt;/code&gt; タイプの有効な値になります。フィールドをNULLにするには、リスト内のその位置に文字をまったく書き込まないでください。たとえば、次の定数はNULLの3番目のフィールドを指定します。</target>
        </trans-unit>
        <trans-unit id="9a3be0245636efccdc3c57134520df09a0e4a0a4" translate="yes" xml:space="preserve">
          <source>white space and comments cannot appear within multi-character symbols, such as &lt;code&gt;(?:&lt;/code&gt;</source>
          <target state="translated">空白やコメントは、 &lt;code&gt;(?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b43caaeffd6a470ec3896dc284dda83445964f79" translate="yes" xml:space="preserve">
          <source>white space or &lt;code&gt;#&lt;/code&gt; within a bracket expression is retained</source>
          <target state="translated">括弧式内の空白または &lt;code&gt;#&lt;/code&gt; は保持されます</target>
        </trans-unit>
        <trans-unit id="52b07ed610fcda069d74b3a411d9e935637def49" translate="yes" xml:space="preserve">
          <source>will be allowed if the cast from type &lt;code&gt;integer&lt;/code&gt; to type &lt;code&gt;text&lt;/code&gt; is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt;, otherwise not. (We generally use the term &lt;em&gt;assignment cast&lt;/em&gt; to describe this kind of cast.)</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 型から &lt;code&gt;text&lt;/code&gt; 型へのキャストが &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; とマークされている場合は許可され、そうでない場合はマークされません。（通常、この種の&lt;em&gt;キャスト&lt;/em&gt;を説明するために、&lt;em&gt;割り当てキャスト&lt;/em&gt;という用語を使用します。）</target>
        </trans-unit>
        <trans-unit id="e7b329bd0ae166b219c0dac7856440cebddc7bef" translate="yes" xml:space="preserve">
          <source>will be parsed as:</source>
          <target state="translated">として解析されます。</target>
        </trans-unit>
        <trans-unit id="fcc5b8ad0d43009e11ed531b9ba723b81a61922b" translate="yes" xml:space="preserve">
          <source>will draw an error even though the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations have identical behaviors. Mixing stripped and non-stripped collation names is therefore not recommended.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; と &lt;code&gt;POSIX&lt;/code&gt; の照合順序が同じ動作であっても、エラーが発生します。したがって、ストリップされた照合名とストリップされていない照合名を混在させることはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="8ea301593a0a7ff485b37c9d6c155df86be3bfc8" translate="yes" xml:space="preserve">
          <source>will lock only rows having &lt;code&gt;col1 = 5&lt;/code&gt;, even though that condition is not textually within the sub-query.</source>
          <target state="translated">&lt;code&gt;col1 = 5&lt;/code&gt; 行のみをロックしますが、その条件はテキスト上ではサブクエリ内にありません。</target>
        </trans-unit>
        <trans-unit id="b9075f9f3f87909783fee359888bd2c471dea042" translate="yes" xml:space="preserve">
          <source>will only process the master table.</source>
          <target state="translated">はマスターテーブルのみを処理します。</target>
        </trans-unit>
        <trans-unit id="166a3172a29e9b1013bd7227d7fa350d195805cd" translate="yes" xml:space="preserve">
          <source>will remove the domain part for users with system user names that end with &lt;code&gt;@mydomain.com&lt;/code&gt;, and allow any user whose system name ends with &lt;code&gt;@otherdomain.com&lt;/code&gt; to log in as &lt;code&gt;guest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@mydomain.com&lt;/code&gt; で終わるシステムユーザー名を持つユーザーのドメイン部分を削除し、システム名が &lt;code&gt;@otherdomain.com&lt;/code&gt; 終わるすべてのユーザーが &lt;code&gt;guest&lt;/code&gt; としてログインできるようにします。</target>
        </trans-unit>
        <trans-unit id="e42965869a7de1a0b4c9e3864a5bad5ded3e3510" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index that includes all rows in the table.</source>
          <target state="translated">はテーブルのサイズに比例した労力を必要とします。PostgreSQLは、テーブル全体またはテーブル内の全行を含むインデックスの全体をスキャンする必要があります。</target>
        </trans-unit>
        <trans-unit id="733025f436e0af6dc9df77a7ba625859cbbf72ca" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index which includes all rows in the table.</source>
          <target state="translated">はテーブルのサイズに比例した労力を必要とします。PostgreSQLは、テーブル全体またはテーブル内の全行を含むインデックスの全体をスキャンする必要があります。</target>
        </trans-unit>
        <trans-unit id="91e07485ce9849ddc161bb7d803839b8f2cfb477" translate="yes" xml:space="preserve">
          <source>will result in the three SQL commands being individually sent to the server, with each one's results being displayed before continuing to the next command. However, a semicolon entered as &lt;code&gt;\;&lt;/code&gt; will not trigger command processing, so that the command before it and the one after are effectively combined and sent to the server in one request. So for example</source>
          <target state="translated">3つのSQLコマンドが個別にサーバーに送信され、次のコマンドに進む前に各コマンドの結果が表示されます。ただし、セミコロンが &lt;code&gt;\;&lt;/code&gt; として入力されました。コマンド処理はトリガーされないため、その前のコマンドと後のコマンドが効果的に結合され、1つの要求でサーバーに送信されます。だから例えば</target>
        </trans-unit>
        <trans-unit id="047ba62edd680e2d56a13904abdabc4188cb005b" translate="yes" xml:space="preserve">
          <source>will return a table of two columns and three rows. It's effectively equivalent to:</source>
          <target state="translated">は2列3行のテーブルを返します。と実質的には同等です。</target>
        </trans-unit>
        <trans-unit id="6cf8c1d7fdc60299e5a5cb3f3300a0c91cf43fb7" translate="yes" xml:space="preserve">
          <source>will start the server in the background and put the output into the named log file. The &lt;code&gt;-D&lt;/code&gt; option has the same meaning here as for &lt;code&gt;postgres&lt;/code&gt;. &lt;code&gt;pg_ctl&lt;/code&gt; is also capable of stopping the server.</source>
          <target state="translated">バックグラウンドでサーバーを起動し、出力を名前付きログファイルに書き込みます。 &lt;code&gt;-D&lt;/code&gt; オプションは、ここでの場合と同じ意味を持つ &lt;code&gt;postgres&lt;/code&gt; 。 &lt;code&gt;pg_ctl&lt;/code&gt; はサーバーを停止することもできます。</target>
        </trans-unit>
        <trans-unit id="7130bc171fc84062054c81f8bc4460528312537b" translate="yes" xml:space="preserve">
          <source>with hot standby</source>
          <target state="translated">ホットスタンバイで</target>
        </trans-unit>
        <trans-unit id="af6d8270bf9a28cb0890365af8ad9fbaf343522d" translate="yes" xml:space="preserve">
          <source>with sync off</source>
          <target state="translated">同期オフで</target>
        </trans-unit>
        <trans-unit id="3a3cc3c4fb4b36db89f9594987cae52aab437928" translate="yes" xml:space="preserve">
          <source>with sync on</source>
          <target state="translated">同調して</target>
        </trans-unit>
        <trans-unit id="9370d4f218264e82510fdcf2db2c6328e076bb0c" translate="yes" xml:space="preserve">
          <source>with the default &lt;code&gt;BLCKSZ&lt;/code&gt; of 8192 bytes</source>
          <target state="translated">デフォルトの &lt;code&gt;BLCKSZ&lt;/code&gt; は8192バイト</target>
        </trans-unit>
        <trans-unit id="1fcb8a613e6e45488de8c47b5f45118a3ee76969" translate="yes" xml:space="preserve">
          <source>without any precision or scale creates a column in which numeric values of any precision and scale can be stored, up to the implementation limit on precision. A column of this kind will not coerce input values to any particular scale, whereas &lt;code&gt;numeric&lt;/code&gt; columns with a declared scale will coerce input values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to integer precision. We find this a bit useless. If you're concerned about portability, always specify the precision and scale explicitly.)</source>
          <target state="translated">精度または位取りがない場合は、精度の実装制限まで、任意の精度および位取りの数値を格納できる列が作成されます。この種類の列は入力値を特定のスケールに強制変換しませんが、宣言されたスケールを持つ &lt;code&gt;numeric&lt;/code&gt; 列は入力値をそのスケールに強制変換します。（SQL標準では、デフォルトのスケール0、つまり整数精度への強制が必要です。これは少し役に立ちません。移植性が心配な場合は、常に精度とスケールを明示的に指定してください。）</target>
        </trans-unit>
        <trans-unit id="db48d21b6765af674c2d86f7d7085037c147d319" translate="yes" xml:space="preserve">
          <source>would fail to preserve the &lt;code&gt;FOR UPDATE&lt;/code&gt; lock after the &lt;code&gt;ROLLBACK TO&lt;/code&gt;. This has been fixed in release 9.3.</source>
          <target state="translated">&lt;code&gt;ROLLBACK TO&lt;/code&gt; の後で &lt;code&gt;FOR UPDATE&lt;/code&gt; ロックを保持できません。これはリリース9.3で修正されました。</target>
        </trans-unit>
        <trans-unit id="d993c428e713634961b14ab1031f2202eb8ab483" translate="yes" xml:space="preserve">
          <source>would query the table &lt;code&gt;my_table&lt;/code&gt;. Note that this may be unsafe: the value of the variable is copied literally, so it can contain unbalanced quotes, or even backslash commands. You must make sure that it makes sense where you put it.</source>
          <target state="translated">テーブル &lt;code&gt;my_table&lt;/code&gt; をクエリします。これは安全でない可能性があることに注意してください。変数の値は文字どおりにコピーされるため、不均衡な引用符やバックスラッシュコマンドを含めることができます。どこに置くかが理にかなっていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="4fb1884d01fa0af9488b72c839058eb9b1cd3ec9" translate="yes" xml:space="preserve">
          <source>www.openwall.com</source>
          <target state="translated">www.openwall.com</target>
        </trans-unit>
        <trans-unit id="ee60015c8f586443db97ad8f39f2b79227b8fd01" translate="yes" xml:space="preserve">
          <source>xact</source>
          <target state="translated">xact</target>
        </trans-unit>
        <trans-unit id="30e2ca63aa35fbb6880b2c6d43d8e5e3aa97095e" translate="yes" xml:space="preserve">
          <source>xml2</source>
          <target state="translated">xml2</target>
        </trans-unit>
        <trans-unit id="f94d7d22277dd8bae275a25a490b99203cccb3b3" translate="yes" xml:space="preserve">
          <source>y-intercept of the least-squares-fit linear equation determined by the (&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;) pairs</source>
          <target state="translated">（ &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;Y&lt;/code&gt; ）のペアによって決定される最小二乗適合線形方程式のy切片</target>
        </trans-unit>
        <trans-unit id="150f912c47bfa78eaad7a19807fcef6747d4b800" translate="yes" xml:space="preserve">
          <source>year (4 or more digits)</source>
          <target state="translated">年</target>
        </trans-unit>
        <trans-unit id="611de26b771af738f57fb9b6c8721bb546f69f99" translate="yes" xml:space="preserve">
          <source>year (4 or more digits) with comma</source>
          <target state="translated">年号(4桁以上カンマ付き)</target>
        </trans-unit>
        <trans-unit id="127cd8c2aa50e43e37fcd0ad357fa69ed4e6f270" translate="yes" xml:space="preserve">
          <source>year 99 BC</source>
          <target state="translated">紀元前99年</target>
        </trans-unit>
        <trans-unit id="d468eeeab09a5f89dd95cca8a1d68fbf5b52784a" translate="yes" xml:space="preserve">
          <source>year and day of year</source>
          <target state="translated">年日</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="b7caf4dc1da846acd815fdde550fbd1677a60c12" translate="yes" xml:space="preserve">
          <source>yes (Note 1)</source>
          <target state="translated">あり(注1</target>
        </trans-unit>
        <trans-unit id="a6e931eb3e1e969efa57eb9a58fd4f25fd4cb2e1" translate="yes" xml:space="preserve">
          <source>you will find that &lt;code&gt;tenk1&lt;/code&gt; has 358 disk pages and 10000 rows. The estimated cost is computed as (disk pages read * &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;) + (rows scanned * &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;). By default, &lt;code&gt;seq_page_cost&lt;/code&gt; is 1.0 and &lt;code&gt;cpu_tuple_cost&lt;/code&gt; is 0.01, so the estimated cost is (358 * 1.0) + (10000 * 0.01) = 458.</source>
          <target state="translated">&lt;code&gt;tenk1&lt;/code&gt; には358個のディスクページと10000行があることがわかります。（ディスクページが*読みと推定コストが計算さ&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;をseq_page_costを&lt;/a&gt;）+（行は*スキャン&lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_costを&lt;/a&gt;）。デフォルトでは、 &lt;code&gt;seq_page_cost&lt;/code&gt; は1.0、 &lt;code&gt;cpu_tuple_cost&lt;/code&gt; は0.01であるため、推定コストは（358 * 1.0）+（10000 * 0.01）= 458です。</target>
        </trans-unit>
        <trans-unit id="1982d2d3e9d46b67ceb2b6b1086e041a7f7ce8a9" translate="yes" xml:space="preserve">
          <source>zero octet</source>
          <target state="translated">ゼロオクテット</target>
        </trans-unit>
        <trans-unit id="5aab974202bf0788f59e7ce97b96b6b4d59e6caf" translate="yes" xml:space="preserve">
          <source>{A,B,C}</source>
          <target state="translated">{A,B,C}</target>
        </trans-unit>
        <trans-unit id="f751f41a86686962c7eb6a6c72d7aead8c2eed66" translate="yes" xml:space="preserve">
          <source>~ ! @ # % ^ &amp;amp; | ` ?</source>
          <target state="translated">〜！@＃％^＆| `？</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
