<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="debbd30b66af886f3ad4a4846dc7b2ee2e468eb1" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, emit the data needed to allow perf to profile functions generated by JIT. This writes out files to &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt;; the user is responsible for performing cleanup when desired. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVMに必要な機能がある場合は、JITによって生成された関数をperfがプロファイルできるようにするために必要なデータを発行します。これにより、ファイルが &lt;code&gt;$HOME/.debug/jit/&lt;/code&gt; れます。ユーザーは、必要に応じてクリーンアップを実行する必要があります。デフォルト設定は &lt;code&gt;off&lt;/code&gt; です。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ef3c317e4d741dc71490a33136e9ff9dc5428c13" translate="yes" xml:space="preserve">
          <source>If LLVM has the required functionality, register generated functions with GDB. This makes debugging easier. The default setting is &lt;code&gt;off&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">LLVMに必要な機能がある場合は、生成された関数をGDBに登録します。これにより、デバッグが容易になります。デフォルト設定は &lt;code&gt;off&lt;/code&gt; です。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="efe3f3026039f58c4fe8aa03beba8ad31146f904" translate="yes" xml:space="preserve">
          <source>If OIDs are included in the file, the OID field immediately follows the field-count word. It is a normal field except that it's not included in the field-count. Note that oid system columns are not supported in current versions of PostgreSQL.</source>
          <target state="translated">ファイルにOIDが含まれている場合、OIDフィールドはフィールドカウントの単語の直後に続きます。これは、フィールドカウントに含まれないことを除いて、通常のフィールドです。oidシステムカラムは現在のバージョンのPostgreSQLではサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8e65f986646d4bd64aa08e3d223eb8fd14aab146" translate="yes" xml:space="preserve">
          <source>If PAM is set up to read &lt;code&gt;/etc/shadow&lt;/code&gt;, authentication will fail because the PostgreSQL server is started by a non-root user. However, this is not an issue when PAM is configured to use LDAP or other authentication methods.</source>
          <target state="translated">PAMが &lt;code&gt;/etc/shadow&lt;/code&gt; を読み取るように設定されている場合、PostgreSQLサーバーはroot以外のユーザーによって起動されるため、認証は失敗します。ただし、PAMがLDAPまたはその他の認証方法を使用するように構成されている場合、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="415ce588e29ad070811b2db4490099f305d07266" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">PostgreSQL自体がシステムのメモリ不足の原因である場合は、構成を変更することで問題を回避できます。場合によっては、メモリ関連の構成パラメータ、特に&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; を&lt;/a&gt;下げると役立つことがあります。また、データベースサーバー自体への接続が多すぎることが原因で問題が発生する場合もあります。多くの場合、&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt;を減らして、代わりに外部接続プーリングソフトウェアを使用する方が良い場合があります。</target>
        </trans-unit>
        <trans-unit id="6e051bc67e0a6c331eb48a8b787733592331e28c" translate="yes" xml:space="preserve">
          <source>If PostgreSQL itself is the cause of the system running out of memory, you can avoid the problem by changing your configuration. In some cases, it may help to lower memory-related configuration parameters, particularly &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;&lt;code&gt;shared_buffers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;&lt;code&gt;work_mem&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt;&lt;code&gt;hash_mem_multiplier&lt;/code&gt;&lt;/a&gt;. In other cases, the problem may be caused by allowing too many connections to the database server itself. In many cases, it may be better to reduce &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;&lt;code&gt;max_connections&lt;/code&gt;&lt;/a&gt; and instead make use of external connection-pooling software.</source>
          <target state="translated">PostgreSQL自体がシステムのメモリ不足の原因である場合は、構成を変更することで問題を回避できます。場合によっては、メモリ関連の構成パラメータ、特に低下するのを助けることができる&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt; &lt;code&gt;shared_buffers&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt; &lt;code&gt;work_mem&lt;/code&gt; &lt;/a&gt;、及び&lt;a href=&quot;runtime-config-resource#GUC-HASH-MEM-MULTIPLIER&quot;&gt; &lt;code&gt;hash_mem_multiplier&lt;/code&gt; を&lt;/a&gt;。その他の場合、データベースサーバー自体への接続を許可しすぎることが問題の原因である可能性があります。多くの場合、&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt; &lt;code&gt;max_connections&lt;/code&gt; &lt;/a&gt;を減らし、代わりに外部接続プールソフトウェアを使用する方がよい場合があります。</target>
        </trans-unit>
        <trans-unit id="ce5c2e1e6b44cb1c8622c0c5ffed0c31ab912017" translate="yes" xml:space="preserve">
          <source>If PostgreSQL was compiled with OpenLDAP as the LDAP client library, the &lt;code&gt;ldapserver&lt;/code&gt; setting may be omitted. In that case, a list of host names and ports is looked up via RFC 2782 DNS SRV records. The name &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; is looked up, where &lt;code&gt;DOMAIN&lt;/code&gt; is extracted from &lt;code&gt;ldapbasedn&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLがLDAPクライアントライブラリとしてOpenLDAPを使用してコンパイルされている場合、 &lt;code&gt;ldapserver&lt;/code&gt; 設定は省略できます。その場合、ホスト名とポートのリストはRFC 2782 DNS SRVレコードを介して検索されます。名前 &lt;code&gt;_ldap._tcp.DOMAIN&lt;/code&gt; が検索され、 &lt;code&gt;DOMAIN&lt;/code&gt; は &lt;code&gt;ldapbasedn&lt;/code&gt; から抽出されます。</target>
        </trans-unit>
        <trans-unit id="f92e62044fa208f984d06131f910dfb1c21e1338" translate="yes" xml:space="preserve">
          <source>If SELinux is disabled or not installed, you must set that product up first before installing this module.</source>
          <target state="translated">SELinux が無効になっているか、インストールされていない場合は、このモジュールをインストールする前に、その製品を最初にセットアップする必要があります。</target>
        </trans-unit>
        <trans-unit id="a9341d807a078bf8721a956d7df4d8eca09e01a0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; command is executed while a base backup is being taken, and then the template database that the &lt;code&gt;CREATE DATABASE&lt;/code&gt; copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</source>
          <target state="translated">場合は&lt;a href=&quot;sql-createdatabase&quot;&gt;、CREATE DATABASEの&lt;/a&gt;コマンドが実行されるベースのバックアップが取られているし、そのテンプレートデータベースながら &lt;code&gt;CREATE DATABASE&lt;/code&gt; ベースバックアップの進行中に変更されたコピーは、回復は、これらの変更はに伝播させることになる可能性がありますデータベースも作成しました。これはもちろん望ましくありません。このリスクを回避するために、ベースバックアップの実行中にテンプレートデータベースを変更しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fa1de3a6861be1ec1b6ec90aa7e6b3e06531f1df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DROP&lt;/code&gt; command lists multiple objects, &lt;code&gt;CASCADE&lt;/code&gt; is only required when there are dependencies outside the specified group. For example, when saying &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; the existence of a foreign key referencing &lt;code&gt;tab1&lt;/code&gt; from &lt;code&gt;tab2&lt;/code&gt; would not mean that &lt;code&gt;CASCADE&lt;/code&gt; is needed to succeed.</source>
          <target state="translated">場合は &lt;code&gt;DROP&lt;/code&gt; のコマンドリスト、複数のオブジェクト、 &lt;code&gt;CASCADE&lt;/code&gt; が指定されたグループ外の依存関係が存在する場合にのみ必要です。言ったときにたとえば、 &lt;code&gt;DROP TABLE tab1, tab2&lt;/code&gt; 参照する外部キーの存在 &lt;code&gt;tab1&lt;/code&gt; のをから &lt;code&gt;tab2&lt;/code&gt; という意味ではないだろう &lt;code&gt;CASCADE&lt;/code&gt; が成功するために必要とされています。</target>
        </trans-unit>
        <trans-unit id="92e1a30bd1d3658160c72094059d0371a401f9cd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a function, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the function for the same variable are restricted to the function: the configuration parameter's prior value is still restored at function exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after function exit, unless the current transaction is rolled back.</source>
          <target state="translated">場合 &lt;code&gt;SET&lt;/code&gt; 句は機能に装着され、その後の効果 &lt;code&gt;SET LOCAL&lt;/code&gt; を同じ変数の関数の内部で実行したコマンドは、機能に制限されています：構成パラメータの前の値がまだ機能出口で復元されます。ただし、通常の &lt;code&gt;SET&lt;/code&gt; コマンド（ &lt;code&gt;LOCAL&lt;/code&gt; なし）は、以前の &lt;code&gt;SET LOCAL&lt;/code&gt; コマンドの場合と同様に、 &lt;code&gt;SET&lt;/code&gt; 句をオーバーライドします。このようなコマンドの影響は、現在のトランザクションがロールバックされない限り、関数の終了後も保持されます。</target>
        </trans-unit>
        <trans-unit id="9c0a79a4075f581261c7fcce27f70643bea75e21" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then that procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">場合 &lt;code&gt;SET&lt;/code&gt; の句が手順に取り付けられ、このプロシージャはトランザクション制御ステートメントを実行することができない（例えば、 &lt;code&gt;COMMIT&lt;/code&gt; と &lt;code&gt;ROLLBACK&lt;/code&gt; 、言語に依存します）。</target>
        </trans-unit>
        <trans-unit id="f0bddcb97ee43256f36e19dc04e898959e413d86" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SET&lt;/code&gt; clause is attached to a procedure, then the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; command executed inside the procedure for the same variable are restricted to the procedure: the configuration parameter's prior value is still restored at procedure exit. However, an ordinary &lt;code&gt;SET&lt;/code&gt; command (without &lt;code&gt;LOCAL&lt;/code&gt;) overrides the &lt;code&gt;SET&lt;/code&gt; clause, much as it would do for a previous &lt;code&gt;SET LOCAL&lt;/code&gt; command: the effects of such a command will persist after procedure exit, unless the current transaction is rolled back.</source>
          <target state="translated">場合 &lt;code&gt;SET&lt;/code&gt; 句が手続きに装着され、その後の影響 &lt;code&gt;SET LOCAL&lt;/code&gt; 同じ変数のための手順内部で実行したコマンドは、プロシージャに制限されている：設定パラメータの前の値は、まだ手続きの出口で復元されます。ただし、通常の &lt;code&gt;SET&lt;/code&gt; コマンド（ &lt;code&gt;LOCAL&lt;/code&gt; なし）は、以前の &lt;code&gt;SET LOCAL&lt;/code&gt; コマンドと同じように &lt;code&gt;SET&lt;/code&gt; 句をオーバーライドします。このようなコマンドの影響は、現在のトランザクションがロールバックされない限り、プロシージャの終了後も保持されます。</target>
        </trans-unit>
        <trans-unit id="902cabcc62fcf46f7c4713fa1c043b73884c956f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;&lt;code&gt;command&lt;/code&gt; argument is given, the query's output is written to the named file or piped to the given shell command, instead of displaying it as usual. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; または &lt;code&gt;|&lt;/code&gt; の場合 &lt;code&gt;command&lt;/code&gt; 引数を指定すると、クエリの出力は、通常どおり表示されるのではなく、指定されたファイルに書き込まれるか、指定されたシェルコマンドにパイプされます。ファイルまたはコマンドは、クエリが0個以上のタプルを正常に返した場合にのみ書き込まれ、クエリが失敗した場合やデータを返さないSQLコマンドの場合は書き込まれません。</target>
        </trans-unit>
        <trans-unit id="dc2402d507bf01ad0609465ee16a38cc42b24afe" translate="yes" xml:space="preserve">
          <source>If a check constraint, an internal representation of the expression. (It's recommended to use &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; to extract the definition of a check constraint.)</source>
          <target state="translated">チェック制約の場合、式の内部表現。（チェック制約の定義を抽出するには、 &lt;code&gt;pg_get_constraintdef()&lt;/code&gt; を使用することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="f25b711856ae449f9c3d73dd4473185e384f4706" translate="yes" xml:space="preserve">
          <source>If a column in the parent table is an identity column, that property is not inherited. A column in the child table can be declared identity column if desired.</source>
          <target state="translated">親テーブルのカラムが ID カラムである場合、そのプロパティは継承されません。必要に応じて、子テーブルの列を ID 列として宣言することができます。</target>
        </trans-unit>
        <trans-unit id="90d9a8592c9a8387fcf3bd4a77c9762fb9a47cc1" translate="yes" xml:space="preserve">
          <source>If a column list is specified, &lt;code&gt;COPY TO&lt;/code&gt; copies only the data in the specified columns to the file. For &lt;code&gt;COPY FROM&lt;/code&gt;, each field in the file is inserted, in order, into the specified column. Table columns not specified in the &lt;code&gt;COPY FROM&lt;/code&gt; column list will receive their default values.</source>
          <target state="translated">列リストが指定されている場合、 &lt;code&gt;COPY TO&lt;/code&gt; は、指定された列のデータのみをファイルにコピーします。以下のために &lt;code&gt;COPY FROM&lt;/code&gt; 、ファイル内の各フィールドは、指定された列に順番に挿入されています。 &lt;code&gt;COPY FROM&lt;/code&gt; 列リストで指定されていないテーブル列は、デフォルト値を受け取ります。</target>
        </trans-unit>
        <trans-unit id="c8c03e9dff51a371ecb3dbf0f3542cbc1ae0bd39" translate="yes" xml:space="preserve">
          <source>If a column list is specified, you only need &lt;code&gt;INSERT&lt;/code&gt; privilege on the listed columns. Similarly, when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; is specified, you only need &lt;code&gt;UPDATE&lt;/code&gt; privilege on the column(s) that are listed to be updated. However, &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; also requires &lt;code&gt;SELECT&lt;/code&gt; privilege on any column whose values are read in the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; expressions or &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">列リストが指定されている場合は、リストされた列に対する &lt;code&gt;INSERT&lt;/code&gt; 特権のみが必要です。同様に、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; が指定されている場合は、更新対象としてリストされている列に対する &lt;code&gt;UPDATE&lt;/code&gt; 特権のみが必要です。ただし、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; には、値が &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 式または &lt;code&gt;condition&lt;/code&gt; 読み取られる列に対する &lt;code&gt;SELECT&lt;/code&gt; 特権も必要です。</target>
        </trans-unit>
        <trans-unit id="6ae12c756d83d3fa84f0842896261c6e6de98fbd" translate="yes" xml:space="preserve">
          <source>If a column result is NULL, the corresponding variable is unset rather than being set.</source>
          <target state="translated">カラムの結果がNULLの場合、対応する変数はセットされるのではなくアンセットされます。</target>
        </trans-unit>
        <trans-unit id="cd07d38bba484cac13838ebc8d7dd08509069d67" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">列のXPath式が非XML値（XPath 1.0では文字列、ブール値、またはdoubleに制限されている）を返し、列が &lt;code&gt;xml&lt;/code&gt; 以外のPostgreSQLタイプを持っている場合、値の文字列表現をPostgreSQLタイプ。（値がブール値の場合、出力列のタイプカテゴリが数値の場合、その文字列表現は &lt;code&gt;1&lt;/code&gt; または &lt;code&gt;0&lt;/code&gt; と見なされ、それ以外の場合は &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; になります。）</target>
        </trans-unit>
        <trans-unit id="3d86c8d327357d64a90febd0e7b2a64229fc6de1" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-XML value (which is limited to string, boolean, or double in XPath 1.0) and the column has a PostgreSQL type other than &lt;code&gt;xml&lt;/code&gt;, the column will be set as if by assigning the value's string representation to the PostgreSQL type. (If the value is a boolean, its string representation is taken to be &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if the output column's type category is numeric, otherwise &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.)</source>
          <target state="translated">列のXPath式が非XML値（XPath 1.0ではstring、boolean、またはdoubleに制限されている）を返し、列が &lt;code&gt;xml&lt;/code&gt; 以外のPostgreSQLタイプである場合、列は値の文字列表現を割り当てることによって設定されます。 PostgreSQLタイプに。（値がブール値の場合、出力列のタイプ・カテゴリーが数値の場合、そのストリング表現は &lt;code&gt;1&lt;/code&gt; または &lt;code&gt;0&lt;/code&gt; と見なされ、それ以外の場合は &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; になります。）</target>
        </trans-unit>
        <trans-unit id="dd49d82e6f7364358b7e1308125e6548ff45efeb" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">列のXPath式が空ではないXMLノードのセットを返し、列のPostgreSQLタイプが &lt;code&gt;xml&lt;/code&gt; の場合、列がドキュメント形式またはコンテンツ形式の場合、列には式の結果が正確に割り当てられます。&lt;a href=&quot;#ftn.id-1.5.8.19.7.5.14.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.19.7.5.14.2&quot;&gt;[8]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f606ba5da3ce72a5b48e1fa0637f31121b0521b" translate="yes" xml:space="preserve">
          <source>If a column's XPath expression returns a non-empty set of XML nodes and the column's PostgreSQL type is &lt;code&gt;xml&lt;/code&gt;, the column will be assigned the expression result exactly, if it is of document or content form. &lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">列のXPath式が空でないXMLノードのセットを返し、列のPostgreSQLタイプが &lt;code&gt;xml&lt;/code&gt; の場合、列がドキュメント形式またはコンテンツ形式であれば、列には式の結果が正確に割り当てられます。&lt;a href=&quot;#ftn.id-1.5.8.21.7.5.15.2&quot;&gt;&lt;sup id=&quot;id-1.5.8.21.7.5.15.2&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2001ae15ca417e0e9b4706925c6ddabecd8102f7" translate="yes" xml:space="preserve">
          <source>If a conflicting row has been inserted by an as-yet-uncommitted transaction, the would-be inserter must wait to see if that transaction commits. If it rolls back then there is no conflict. If it commits without deleting the conflicting row again, there is a uniqueness violation. (In practice we just wait for the other transaction to end and then redo the visibility check in toto.)</source>
          <target state="translated">まだコミットされていないトランザクションによって競合する行が挿入された場合、そのトランザクションがコミットするかどうかを確認するために、挿入予定のサータは待たなければなりません。もしそれがロールバックした場合、競合はありません。もし、競合している行を再び削除せずにコミットした場合は、一意性の違反となります。(実際には、他のトランザクションが終了するのを待ってから、全体の可視性チェックをやり直します)。</target>
        </trans-unit>
        <trans-unit id="25c5a233f983a5a11d2f0ce26b28af3fbae3c56b" translate="yes" xml:space="preserve">
          <source>If a conflicting valid row has been deleted by the current transaction, it's okay. (In particular, since an UPDATE always deletes the old row version before inserting the new version, this will allow an UPDATE on a row without changing the key.)</source>
          <target state="translated">競合する有効な行が現在のトランザクションによって削除されていても問題ありません(特に、UPDATEは常に新しいバージョンを挿入する前に古い行のバージョンを削除するので、これによりキーを変更せずに行のUPDATEを行うことができます)。</target>
        </trans-unit>
        <trans-unit id="2370b745676126171b063e2e2d72095b349175fc" translate="yes" xml:space="preserve">
          <source>If a constraint is deferrable, this clause specifies the default time to check the constraint. If the constraint is &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;, it is checked after each statement. This is the default. If the constraint is &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt;, it is checked only at the end of the transaction. The constraint check time can be altered with the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command.</source>
          <target state="translated">制約が延期可能な場合、この句は制約をチェックするデフォルトの時間を指定します。制約が &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; の場合、各ステートメントの後にチェックされます。これがデフォルトです。制約が &lt;code&gt;INITIALLY DEFERRED&lt;/code&gt; の場合、トランザクションの最後にのみチェックされます。制約チェック時間は、&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;コマンドで変更できます。</target>
        </trans-unit>
        <trans-unit id="45ddd1496c9c8970f749841790d5cc33a1ed958c" translate="yes" xml:space="preserve">
          <source>If a constraint name is provided then the index will be renamed to match the constraint name. Otherwise the constraint will be named the same as the index.</source>
          <target state="translated">制約名が指定された場合、インデックスは制約名と一致するように名前が変更されます。それ以外の場合は、制約はインデックスと同じ名前になります。</target>
        </trans-unit>
        <trans-unit id="516a948273fe630c2fd2d3bb4954b014ec3a728f" translate="yes" xml:space="preserve">
          <source>If a cursor is closed after a savepoint which is later rolled back, the &lt;code&gt;CLOSE&lt;/code&gt; is not rolled back; that is, the cursor remains closed.</source>
          <target state="translated">後でロールバックされるセーブポイントの後でカーソルが閉じられた場合、 &lt;code&gt;CLOSE&lt;/code&gt; はロールバックされません。つまり、カーソルは閉じたままです。</target>
        </trans-unit>
        <trans-unit id="6755c4a78a3da118c77dadc78bfef40de55f4e2d" translate="yes" xml:space="preserve">
          <source>If a daylight-savings abbreviation is given but the transition &lt;code&gt;rule&lt;/code&gt; field is omitted, the fallback behavior is to use the rule &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt;, which corresponds to USA practice as of 2020 (that is, spring forward on the second Sunday of March, fall back on the first Sunday of November, both transitions occurring at 2AM prevailing time). Note that this rule does not give correct USA transition dates for years before 2007.</source>
          <target state="translated">夏時間の省略形が指定されているが、遷移 &lt;code&gt;rule&lt;/code&gt; フィールドが省略されている場合、フォールバック動作はルール &lt;code&gt;M3.2.0,M11.1.0&lt;/code&gt; を使用します。これは、2020年の米国の慣行に対応します（つまり、第2日曜日に春先に進みます）。 3月の場合、11月の第1日曜日にフォールバックします。どちらの遷移も、通常の午前2時に発生します。この規則は、2007年より前の年の正しい米国移行日を示していないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0b8ad01bd9eefe5ae6504ee533b29e5940a9bbcc" translate="yes" xml:space="preserve">
          <source>If a different escape character than backslash is desired, it can be specified using the &lt;code&gt;UESCAPE&lt;/code&gt; clause after the string, for example:</source>
          <target state="translated">バックスラッシュとは異なるエスケープ文字が必要な場合は、文字列の後に &lt;code&gt;UESCAPE&lt;/code&gt; 句を使用して指定できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="8c0e309df60d6b04409ae8154560e144f149154e" translate="yes" xml:space="preserve">
          <source>If a dynamically loadable module needs to be opened and the file name specified in the &lt;code&gt;CREATE FUNCTION&lt;/code&gt; or &lt;code&gt;LOAD&lt;/code&gt; command does not have a directory component (i.e., the name does not contain a slash), the system will search this path for the required file.</source>
          <target state="translated">動的にロード可能なモジュールを開く必要があり、 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; または &lt;code&gt;LOAD&lt;/code&gt; コマンドで指定されたファイル名にディレクトリコンポーネントがない場合（つまり、名前にスラッシュが含まれていない場合）、システムはこのパスで必要なファイルを検索します。</target>
        </trans-unit>
        <trans-unit id="eead72d18dc8bb550762010fb49abdc92926fc22" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for FK = FK comparisons</source>
          <target state="translated">外部キーの場合、FK=FK比較のための等値演算子のリスト</target>
        </trans-unit>
        <trans-unit id="f2557ac45b6d34f20af024d349a08e662002e006" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = FK comparisons</source>
          <target state="translated">外部キーの場合、PK=FK比較のための等質演算子のリスト</target>
        </trans-unit>
        <trans-unit id="65b7a7238de39c08afb78813e4651af5cc557847" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the equality operators for PK = PK comparisons</source>
          <target state="translated">外部キーの場合、PK=PK 比較のための等質演算子のリスト</target>
        </trans-unit>
        <trans-unit id="84b58f81bb95714e62ab14756a76120d62320f41" translate="yes" xml:space="preserve">
          <source>If a foreign key, list of the referenced columns</source>
          <target state="translated">外部キーの場合、参照される列のリスト</target>
        </trans-unit>
        <trans-unit id="7870e560cb55fb3708abcfcfa26fc2aa507576ee" translate="yes" xml:space="preserve">
          <source>If a foreign key, the referenced table; else 0</source>
          <target state="translated">外部キーの場合は、参照されているテーブル。</target>
        </trans-unit>
        <trans-unit id="575611ec6feb49c10dfac57d786d3e40ac55a75b" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any unit conversion.</source>
          <target state="translated">単位で小数値を指定した場合、次に小さい単位がある場合はその倍数に丸められます。例えば、 &lt;code&gt;30.1 GB&lt;/code&gt; に変換され &lt;code&gt;30822 MB&lt;/code&gt; ない &lt;code&gt;32319628902 B&lt;/code&gt; 。パラメータが整数型の場合、単位変換後に整数への最終的な丸めが行われます。</target>
        </trans-unit>
        <trans-unit id="302fc67ef061c10f65906072775cc6ba157a3bf8" translate="yes" xml:space="preserve">
          <source>If a fractional value is specified with a unit, it will be rounded to a multiple of the next smaller unit if there is one. For example, &lt;code&gt;30.1 GB&lt;/code&gt; will be converted to &lt;code&gt;30822 MB&lt;/code&gt; not &lt;code&gt;32319628902 B&lt;/code&gt;. If the parameter is of integer type, a final rounding to integer occurs after any units conversion.</source>
          <target state="translated">分数の値が単位で指定されている場合、次の小さい単位の倍数に丸められます（ある場合）。たとえば、 &lt;code&gt;30.1 GB&lt;/code&gt; は &lt;code&gt;32319628902 B&lt;/code&gt; ではなく30822 &lt;code&gt;30822 MB&lt;/code&gt; 変換されます。パラメータが整数型の場合、整数への最終的な丸めは単位変換後に行われます。</target>
        </trans-unit>
        <trans-unit id="16517351d5f6d1324d494a56b7cbc1349aadbd26" translate="yes" xml:space="preserve">
          <source>If a function executed within a parallel worker acquires locks which are not held by the leader, for example by querying a table not referenced in the query, those locks will be released at worker exit, not end of transaction. If you write a function which does this, and this behavior difference is important to you, mark such functions as &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; to ensure that they execute only in the leader.</source>
          <target state="translated">クエリで参照されていないテーブルをクエリするなどして、並列ワーカー内で実行される関数がリーダーによって保持されていないロックを取得した場合、それらのロックはトランザクションの終了ではなく、ワーカー出口で解放されます。これを実行する関数を作成し、この動作の違いが重要な場合は、そのような関数を &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; としてマークして、リーダーでのみ実行されるようにします。</target>
        </trans-unit>
        <trans-unit id="c08af80c4ec0b88bc818f2eba0deaa5cfe1fa698" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;STRICT&lt;/code&gt; with a &lt;code&gt;VARIADIC&lt;/code&gt; argument, the strictness check tests that the variadic array &lt;em&gt;as a whole&lt;/em&gt; is non-null. The function will still be called if the array has null elements.</source>
          <target state="translated">関数が &lt;code&gt;VARIADIC&lt;/code&gt; 引数を &lt;code&gt;STRICT&lt;/code&gt; してSTRICTと宣言されている場合、厳密性チェックは、可変個配列&lt;em&gt;全体&lt;/em&gt;がnullでないことをテストします。配列にnull要素がある場合でも、関数は呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3d9a8948caa2988125e4b727f3b2df8159e037f5" translate="yes" xml:space="preserve">
          <source>If a function is declared with a &lt;code&gt;VARIADIC&lt;/code&gt; array parameter, and the call does not use the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, then the function is treated as if the array parameter were replaced by one or more occurrences of its element type, as needed to match the call. After such expansion the function might have effective argument types identical to some non-variadic function. In that case the function appearing earlier in the search path is used, or if the two functions are in the same schema, the non-variadic one is preferred.</source>
          <target state="translated">関数が &lt;code&gt;VARIADIC&lt;/code&gt; 配列パラメーターで宣言されていて、呼び出しが &lt;code&gt;VARIADIC&lt;/code&gt; キーワードを使用していない場合、関数は、呼び出しに一致する必要に応じて、配列パラメーターがそのエレメントタイプの1つ以上のオカレンスで置き換えられたものとして扱われます。そのような拡張の後、関数はいくつかの非可変関数と同じ有効な引数型を持つかもしれません。その場合、検索パスの前にある関数が使用されます。または、2つの関数が同じスキーマにある場合は、非可変関数が優先されます。</target>
        </trans-unit>
        <trans-unit id="29873e6b07ca3d965e9bf60280fc04e4b50e061e" translate="yes" xml:space="preserve">
          <source>If a generic plan is in use, it will contain parameter symbols &lt;code&gt;$n&lt;/code&gt;, while a custom plan will have the supplied parameter values substituted into it.</source>
          <target state="translated">汎用プランが使用されている場合、それにはパラメーターシンボル &lt;code&gt;$n&lt;/code&gt; が含まれますが、カスタムプランには、提供されたパラメーター値が代入されます。</target>
        </trans-unit>
        <trans-unit id="b9eddb833bc9b9e1959393e089ee3b45e63b93cb" translate="yes" xml:space="preserve">
          <source>If a host name is specified (anything that is not an IP address range or a special key word is treated as a host name), that name is compared with the result of a reverse name resolution of the client's IP address (e.g., reverse DNS lookup, if DNS is used). Host name comparisons are case insensitive. If there is a match, then a forward name resolution (e.g., forward DNS lookup) is performed on the host name to check whether any of the addresses it resolves to are equal to the client's IP address. If both directions match, then the entry is considered to match. (The host name that is used in &lt;code&gt;pg_hba.conf&lt;/code&gt; should be the one that address-to-name resolution of the client's IP address returns, otherwise the line won't be matched. Some host name databases allow associating an IP address with multiple host names, but the operating system will only return one host name when asked to resolve an IP address.)</source>
          <target state="translated">ホスト名が指定されている場合（IPアドレスの範囲または特別なキーワードではないものはすべてホスト名として扱われます）、その名前はクライアントのIPアドレスの逆の名前解決の結果と比較されます（たとえば、逆DNS DNSが使用されている場合、ルックアップ）。ホスト名の比較では、大文字と小文字は区別されません。一致する場合、ホスト名に対して前方名前解決（DNSの前方参照など）が実行され、解決されるアドレスのいずれかがクライアントのIPアドレスと等しいかどうかが確認されます。両方向が一致する場合、エントリは一致すると見なされます。 （ &lt;code&gt;pg_hba.conf&lt;/code&gt; で使用されるホスト名クライアントのIPアドレスのアドレスから名前への解決が返すものである必要があります。そうでない場合、行は一致しません。一部のホスト名データベースでは、IPアドレスを複数のホスト名に関連付けることができますが、オペレーティングシステムは、IPアドレスの解決を要求されたときに1つのホスト名のみを返します。</target>
        </trans-unit>
        <trans-unit id="29821b670fa593b8c5ed4db6b848a4180ea0c1c3" translate="yes" xml:space="preserve">
          <source>If a limit count is given, no more than that many rows will be returned (but possibly fewer, if the query itself yields fewer rows). &lt;code&gt;LIMIT ALL&lt;/code&gt; is the same as omitting the &lt;code&gt;LIMIT&lt;/code&gt; clause, as is &lt;code&gt;LIMIT&lt;/code&gt; with a NULL argument.</source>
          <target state="translated">制限カウントが指定されている場合、返される行数はその数にすぎません（ただし、クエリ自体が生成する行数が少ない場合は、それよりも少ない可能性があります）。 &lt;code&gt;LIMIT ALL&lt;/code&gt; は、NULL引数を持つ &lt;code&gt;LIMIT&lt;/code&gt; と同様に、 &lt;code&gt;LIMIT&lt;/code&gt; 句を省略した場合と同じです。</target>
        </trans-unit>
        <trans-unit id="2e0f012a9c847bea5735587a0a262fd8fc04fc30" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name.</source>
          <target state="translated">行番号が指定された場合、psqlはファイルまたはクエリバッファの指定された行にカーソルを配置します。1つの全桁の引数が与えられた場合、psqlはそれがファイル名ではなく行番号であると仮定することに注意してください。</target>
        </trans-unit>
        <trans-unit id="989ad942cdac74f48ff0f663910b668e0bfcd851" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.)</source>
          <target state="translated">行番号が指定された場合、psqlは関数本体の指定された行にカーソルを配置します。(通常、関数本体はファイルの最初の行からは開始しないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="f28240e112ab05b43febc5915be398cc2c0ace7d" translate="yes" xml:space="preserve">
          <source>If a line number is specified, psql will position the cursor on the specified line of the view definition.</source>
          <target state="translated">行番号が指定された場合、psqlはビュー定義の指定された行にカーソルを配置します。</target>
        </trans-unit>
        <trans-unit id="e1603d0c375b802bfd8ff93da28473ffff6f9ce0" translate="yes" xml:space="preserve">
          <source>If a list of columns is specified, &lt;code&gt;COPY&lt;/code&gt; will only copy the data in the specified columns to or from the file. If there are any columns in the table that are not in the column list, &lt;code&gt;COPY FROM&lt;/code&gt; will insert the default values for those columns.</source>
          <target state="translated">列のリストが指定されている場合、 &lt;code&gt;COPY&lt;/code&gt; は指定された列のデータのみをファイルとの間でコピーします。列リストにない列がテーブルにある場合、 &lt;code&gt;COPY FROM&lt;/code&gt; はそれらの列のデフォルト値を挿入します。</target>
        </trans-unit>
        <trans-unit id="5d76d1bc7bed56c879e14e369962729e0bb7fe98" translate="yes" xml:space="preserve">
          <source>If a new child node must be added, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgAddNode&lt;/code&gt;. Set &lt;code&gt;nodeLabel&lt;/code&gt; to the label to be used for the new node, and set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) at which to insert the node in the node array. After the node has been added, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the modified inner tuple; that call should result in an &lt;code&gt;spgMatchNode&lt;/code&gt; result.</source>
          <target state="translated">新しい子ノードを追加する必要がある場合は、 &lt;code&gt;resultType&lt;/code&gt; を &lt;code&gt;spgAddNode&lt;/code&gt; に設定します。セット &lt;code&gt;nodeLabel&lt;/code&gt; 新しいノードに使用されるラベル、及びセットに &lt;code&gt;nodeN&lt;/code&gt; インデックス（ゼロから）ノードアレイ内のノードを挿入するれます。ノードが追加された後、変更された内部タプルを使用して、 &lt;code&gt;choose&lt;/code&gt; 関数が再度呼び出されます。その呼び出しの結果は &lt;code&gt;spgMatchNode&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="342f14a4cf8cecaaec4f439a2239828717657aec" translate="yes" xml:space="preserve">
          <source>If a parent column is a generated column, a child column must also be a generated column using the same expression. In the definition of the child column, leave off the &lt;code&gt;GENERATED&lt;/code&gt; clause, as it will be copied from the parent.</source>
          <target state="translated">親列が生成された列である場合、子列も同じ式を使用して生成された列である必要があります。子列の定義では、親からコピーされるため、 &lt;code&gt;GENERATED&lt;/code&gt; 句は省略します。</target>
        </trans-unit>
        <trans-unit id="bc7892c6f8a458e96e3334e518119041320e0ca8" translate="yes" xml:space="preserve">
          <source>If a parent column is not a generated column, a child column may be defined to be a generated column or not.</source>
          <target state="translated">親カラムが生成カラムでない場合、子カラムは生成カラムであるかどうかを定義してもよい。</target>
        </trans-unit>
        <trans-unit id="c6c9e178ba05d52398d348d0978c9f0904579a20" translate="yes" xml:space="preserve">
          <source>If a part of the plan guarantees an ordering on a prefix of the required sort keys, then the planner may instead decide to use an &lt;code&gt;incremental sort&lt;/code&gt; step:</source>
          <target state="translated">プランの一部で必要なソートキーのプレフィックスの順序が保証されている場合、プランナーは代わりに &lt;code&gt;incremental sort&lt;/code&gt; ステップを使用することを決定できます。</target>
        </trans-unit>
        <trans-unit id="01753c01a634660c1afc91855a2bf3e6c0a24915" translate="yes" xml:space="preserve">
          <source>If a problem arises while rebuilding the indexes, such as a uniqueness violation in a unique index, the &lt;code&gt;REINDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; new index in addition to the pre-existing one. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">一意のインデックスの一意性違反など、インデックスの再構築中に問題が発生した場合、 &lt;code&gt;REINDEX&lt;/code&gt; コマンドは失敗しますが、既存のインデックスに加えて「無効な」新しいインデックスが残ります。このインデックスは不完全な場合があるため、クエリの目的では無視されます。ただし、それでも更新オーバーヘッドが消費されます。 psql &lt;code&gt;\d&lt;/code&gt; コマンドは &lt;code&gt;INVALID&lt;/code&gt; のようなインデックスを報告します：</target>
        </trans-unit>
        <trans-unit id="fc2fcf347772c27798939c43c378ac44b8d079f9" translate="yes" xml:space="preserve">
          <source>If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an &amp;ldquo;invalid&amp;rdquo; index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:</source>
          <target state="translated">テーブルのスキャン中に、デッドロックや一意のインデックスの一意性違反などの問題が発生した場合、 &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドは失敗しますが、「無効な」インデックスが残ります。このインデックスは不完全な場合があるため、クエリの目的では無視されます。ただし、それでも更新オーバーヘッドが消費されます。 psql &lt;code&gt;\d&lt;/code&gt; コマンドは &lt;code&gt;INVALID&lt;/code&gt; のようなインデックスを報告します：</target>
        </trans-unit>
        <trans-unit id="60b7f8c376b0c316858e3c03acae729e9e8e0bbd" translate="yes" xml:space="preserve">
          <source>If a problem like this arises, it may not affect each individual index that is ordered using an affected collation, simply because &lt;em&gt;indexed&lt;/em&gt; values might happen to have the same absolute ordering regardless of the behavioral inconsistency. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; and &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt; for further details about how PostgreSQL uses operating system locales and collations.</source>
          <target state="translated">このような問題が発生した場合、影響を受ける照合を使用して順序付けされた個々のインデックスには影響しない可能性があります。これは、動作の不整合に関係なく、&lt;em&gt;インデックス付けされた&lt;/em&gt;値が同じ絶対順序になる場合があるためです。参照&lt;a href=&quot;locale&quot;&gt;セクション23.1&lt;/a&gt;と&lt;a href=&quot;collation&quot;&gt;セクション23.2を&lt;/a&gt; PostgreSQLは、オペレーティングシステムのロケールと照合順序を使用する方法についての詳細は。</target>
        </trans-unit>
        <trans-unit id="14159bc71155b473a106589680a4763fc75cdf28" translate="yes" xml:space="preserve">
          <source>If a query contains aggregate function calls, but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, grouping still occurs: the result is a single group row (or perhaps no rows at all, if the single row is then eliminated by &lt;code&gt;HAVING&lt;/code&gt;). The same is true if it contains a &lt;code&gt;HAVING&lt;/code&gt; clause, even without any aggregate function calls or &lt;code&gt;GROUP BY&lt;/code&gt; clause.</source>
          <target state="translated">クエリに集計関数呼び出しが含まれているが &lt;code&gt;GROUP BY&lt;/code&gt; 句がない場合でも、グループ化は行われます。結果は単一のグループ行になります（または、 &lt;code&gt;HAVING&lt;/code&gt; によって単一の行が削除された場合、おそらく行がまったくありません）。集計関数呼び出しや &lt;code&gt;GROUP BY&lt;/code&gt; 句がなくても、 &lt;code&gt;HAVING&lt;/code&gt; 句が含まれている場合も同様です。</target>
        </trans-unit>
        <trans-unit id="7e2704031f22c0864166ff4a01e062f291652c11" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g. after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">そうすることが期待されているクエリで並列プランが生成されない場合は、&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt;または&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_costを&lt;/a&gt;減らしてみてください。もちろん、この計画は計画者が好んだシリアル計画よりも遅いことが判明するかもしれませんが、これは必ずしもそうではありません。これらの設定の値が非常に小さい場合でも並列プランを取得できない場合（たとえば、両方をゼロに設定した後など）、クエリプランナーがクエリの並列プランを生成できない理由がいくつかある可能性があります。これが当てはまる理由については、&lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;セクション15.2&lt;/a&gt;および&lt;a href=&quot;parallel-safety&quot;&gt;セクション15.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e703ec1af7c6fe8daa3820fdcecb57bac64cdaff" translate="yes" xml:space="preserve">
          <source>If a query that is expected to do so does not produce a parallel plan, you can try reducing &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_cost&lt;/a&gt;. Of course, this plan may turn out to be slower than the serial plan which the planner preferred, but this will not always be the case. If you don't get a parallel plan even with very small values of these settings (e.g., after setting them both to zero), there may be some reason why the query planner is unable to generate a parallel plan for your query. See &lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;Section 15.2&lt;/a&gt; and &lt;a href=&quot;parallel-safety&quot;&gt;Section 15.4&lt;/a&gt; for information on why this may be the case.</source>
          <target state="translated">そうすることが期待されるクエリで並列プランが生成されない場合は、&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-SETUP-COST&quot;&gt;parallel_setup_cost&lt;/a&gt;または&lt;a href=&quot;runtime-config-query#GUC-PARALLEL-TUPLE-COST&quot;&gt;parallel_tuple_costを&lt;/a&gt;削減してみてください。もちろん、このプランは、プランナーが好んだシリアルプランよりも遅いことが判明する場合がありますが、常にそうであるとは限りません。これらの設定の値が非常に小さい場合でも（たとえば、両方をゼロに設定した後）並列プランを取得できない場合は、クエリプランナーがクエリの並列プランを生成できない理由が考えられます。これが当てはまる理由については、&lt;a href=&quot;when-can-parallel-query-be-used&quot;&gt;セクション15.2&lt;/a&gt;および&lt;a href=&quot;parallel-safety&quot;&gt;セクション15.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d78bc381604777d833daa7f8a441adef31412d42" translate="yes" xml:space="preserve">
          <source>If a query's results do not fit on the screen, they are piped through this command. Typical values are &lt;code&gt;more&lt;/code&gt; or &lt;code&gt;less&lt;/code&gt;. Use of the pager can be disabled by setting &lt;code&gt;PSQL_PAGER&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt; to an empty string, or by adjusting the pager-related options of the &lt;code&gt;\pset&lt;/code&gt; command. These variables are examined in the order listed; the first that is set is used. If none of them is set, the default is to use &lt;code&gt;more&lt;/code&gt; on most platforms, but &lt;code&gt;less&lt;/code&gt; on Cygwin.</source>
          <target state="translated">クエリの結果が画面に収まらない場合は、このコマンドを介してパイプ処理されます。典型的な値は &lt;code&gt;more&lt;/code&gt; または &lt;code&gt;less&lt;/code&gt; 。 &lt;code&gt;PSQL_PAGER&lt;/code&gt; または &lt;code&gt;PAGER&lt;/code&gt; を空の文字列に設定するか、 &lt;code&gt;\pset&lt;/code&gt; コマンドのページャー関連オプションを調整することにより、ページャーの使用を無効にできます。これらの変数は、リストされている順序で検査されます。最初に設定されたものが使用されます。それらのいずれも設定されていない場合、デフォルトでは、ほとんどのプラットフォームで &lt;code&gt;more&lt;/code&gt; 使用されますが、Cygwin では &lt;code&gt;less&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="3a16d1e24e65d591a8270e12d2132334cb1a5266" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt;) then the aggregate function is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE AGGREGATE myschema.myagg ...&lt;/code&gt; ）、指定されたスキーマに集計関数が作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="9221069e2f8158080f0dab328adf9a4fc4ac50a4" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt;) then the domain is created in the specified schema. Otherwise it is created in the current schema. The domain name must be unique among the types and domains existing in its schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE DOMAIN myschema.mydomain ...&lt;/code&gt; ）、ドメインは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。ドメイン名は、スキーマに存在するタイプとドメイン間で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="2b01ea3ef0736036d56ce2802cb7af1e7ac1551f" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. The name of the foreign table must be distinct from the name of any other foreign table, table, sequence, index, view, or materialized view in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（例： &lt;code&gt;CREATE FOREIGN TABLE myschema.mytable ...&lt;/code&gt; ）、テーブルは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。外部テーブルの名前は、同じスキーマ内の他の外部テーブル、テーブル、シーケンス、インデックス、ビュー、またはマテリアライズドビューの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="0017dfefecb7c7d878ccd99cec2c2243eb08f548" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt;) then the statistics object is created in the specified schema. Otherwise it is created in the current schema. The name of the statistics object must be distinct from the name of any other statistics object in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（例： &lt;code&gt;CREATE STATISTICS myschema.mystat ...&lt;/code&gt; ）、指定したスキーマに統計オブジェクトが作成されます。それ以外の場合は、現在のスキーマに作成されます。統計オブジェクトの名前は、同じスキーマ内の他の統計オブジェクトの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="d358a0109b0b0aa95ca587460e4392925dac3d64" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt;) then the table is created in the specified schema. Otherwise it is created in the current schema. Temporary tables exist in a special schema, so a schema name cannot be given when creating a temporary table. The name of the table must be distinct from the name of any other table, sequence, index, view, or foreign table in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（例： &lt;code&gt;CREATE TABLE myschema.mytable ...&lt;/code&gt; ）、テーブルは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。一時テーブルは特別なスキーマに存在するため、一時テーブルを作成するときにスキーマ名を指定することはできません。テーブルの名前は、同じスキーマ内の他のテーブル、シーケンス、インデックス、ビュー、または外部テーブルの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="93459b6de8914138c246c45451309801fa4eb75b" translate="yes" xml:space="preserve">
          <source>If a schema name is given (for example, &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt;) then the view is created in the specified schema. Otherwise it is created in the current schema. Temporary views exist in a special schema, so a schema name cannot be given when creating a temporary view. The name of the view must be distinct from the name of any other view, table, sequence, index or foreign table in the same schema.</source>
          <target state="translated">スキーマ名が指定されている場合（たとえば、 &lt;code&gt;CREATE VIEW myschema.myview ...&lt;/code&gt; ）、ビューは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。一時ビューは特別なスキーマに存在するため、一時ビューを作成するときにスキーマ名を指定することはできません。ビューの名前は、同じスキーマ内の他のビュー、テーブル、シーケンス、インデックス、または外部テーブルの名前とは異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="f45727194d879f2673b515b0704bca00c0cdc2be" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator class is created in the specified schema. Otherwise it is created in the current schema. Two operator classes in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">スキーマ名が指定された場合は、指定されたスキーマに演算子クラスが作成されます。それ以外の場合は、現在のスキーマに作成されます。同じスキーマ内の2つの演算子クラスは、異なるインデックスメソッドのためのものである場合に限り、同じ名前を持つことができます。</target>
        </trans-unit>
        <trans-unit id="924ee280ad5b0efe3a03d3f74bd950473afe0d2b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the operator family is created in the specified schema. Otherwise it is created in the current schema. Two operator families in the same schema can have the same name only if they are for different index methods.</source>
          <target state="translated">スキーマ名を指定すると、指定されたスキーマに演算子ファミリが作成されます。それ以外の場合は、現在のスキーマに作成されます。同じスキーマ内の2つの演算子ファミリーは、異なるインデックスメソッドの場合に限り、同じ名前を持つことができます。</target>
        </trans-unit>
        <trans-unit id="d43b98c46599ec5632b8b68a4c4aec5bc7c49e45" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the sequence is created in the specified schema. Otherwise it is created in the current schema. Temporary sequences exist in a special schema, so a schema name cannot be given when creating a temporary sequence. The sequence name must be distinct from the name of any other sequence, table, index, view, or foreign table in the same schema.</source>
          <target state="translated">スキーマ名を指定すると、指定したスキーマ内にシーケンスが作成されます。それ以外の場合は、現在のスキーマに作成されます。一時的なシーケンスは特別なスキーマに存在するため、一時的なシーケンスを作成する際にスキーマ名を指定することはできません。シーケンス名は、同じスキーマ内の他のシーケンス、テーブル、インデックス、ビュー、外部テーブルの名前とは区別されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="d3a817f61150e098cf1b32f5797358f478896c39" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search configuration is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索設定は指定されたスキーマに作成されます。そうでなければ、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="6aa5bd7767ed3e5d5d615c990a382ab4eccb349b" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search dictionary is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索辞書は指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="3f275ed3d77d7d07fbadd2aeff95331926c88b60" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search parser is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索パーサは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="c90f2803121a2139271a7f1f2ab6d88702071162" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the text search template is created in the specified schema. Otherwise it is created in the current schema.</source>
          <target state="translated">スキーマ名が指定された場合、テキスト検索テンプレートは指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。</target>
        </trans-unit>
        <trans-unit id="3f1b270e2011c6de6a6609606ad6c64491399611" translate="yes" xml:space="preserve">
          <source>If a schema name is given then the type is created in the specified schema. Otherwise it is created in the current schema. The type name must be distinct from the name of any existing type or domain in the same schema. (Because tables have associated data types, the type name must also be distinct from the name of any existing table in the same schema.)</source>
          <target state="translated">スキーマ名が指定された場合、その型は指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。型名は、同じスキーマ内の既存の型名またはドメイン名とは区別する必要があります。(テーブルには関連するデータ型があるため、型名も同じスキーマ内の既存のテーブル名とは区別する必要があります)。</target>
        </trans-unit>
        <trans-unit id="3270e8102f1d16bb2969879cc26ff629f7438593" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema. The name of the new function must not match any existing function or procedure with the same input argument types in the same schema. However, functions and procedures of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">スキーマ名が含まれている場合、関数は指定されたスキーマに作成されます。それ以外の場合は、現在のスキーマに作成されます。新しい関数の名前は、同じスキーマ内の同じ入力引数型を持つ既存の関数またはプロシージャと一致してはなりません。ただし、引数の型が異なる関数とプロシージャは名前を共有できます（これを&lt;em&gt;オーバーロード&lt;/em&gt;と呼びます）。</target>
        </trans-unit>
        <trans-unit id="fa9f9c34f552135ee16bf0e254ac4f8936e929d0" translate="yes" xml:space="preserve">
          <source>If a schema name is included, then the procedure is created in the specified schema. Otherwise it is created in the current schema. The name of the new procedure must not match any existing procedure or function with the same input argument types in the same schema. However, procedures and functions of different argument types can share a name (this is called &lt;em&gt;overloading&lt;/em&gt;).</source>
          <target state="translated">スキーマ名が含まれている場合、指定したスキーマにプロシージャが作成されます。それ以外の場合は、現在のスキーマに作成されます。新しいプロシージャの名前は、同じスキーマ内の同じ入力引数タイプを持つ既存のプロシージャまたは関数と一致してはなりません。ただし、異なる引数型のプロシージャと関数は名前を共有できます（これを&lt;em&gt;オーバーロード&lt;/em&gt;と呼びます）。</target>
        </trans-unit>
        <trans-unit id="dacc047d6b80f30af4e1b3c075ae268658bf910d" translate="yes" xml:space="preserve">
          <source>If a separate session key is requested, a new random key will be generated. Otherwise the S2K key will be used directly as the session key.</source>
          <target state="translated">別のセッション・キーが要求された場合、新しいランダム・キーが生成されます。それ以外の場合は、S2Kキーが直接セッションキーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="5829673b8ac4bdf9ef5ccbb615c82963b07e7a46" translate="yes" xml:space="preserve">
          <source>If a sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using special parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command; see its command reference page for more information.</source>
          <target state="translated">シーケンスオブジェクトがデフォルトのパラメーターで作成されている場合、連続する &lt;code&gt;nextval&lt;/code&gt; 呼び出しは1から始まる連続する値を返します。他の動作は、&lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt;コマンドで特別なパラメーターを使用することによって取得できます。詳細については、コマンドリファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="f45a6ad1ab211a977ca7a8e8006108f711740038" translate="yes" xml:space="preserve">
          <source>If a subscription is associated with a replication slot, then &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">サブスクリプションがレプリケーションスロットに関連付けられている場合、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; はトランザクションブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="4fefee0e29f8ef757e65c2ca97914e54656fff0f" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. In particular, privileges granted via such a command will appear to have been granted by the object owner. (For role membership, the membership appears to have been granted by the containing role itself.)</source>
          <target state="translated">スーパーユーザーが &lt;code&gt;GRANT&lt;/code&gt; または &lt;code&gt;REVOKE&lt;/code&gt; コマンドを発行することを選択した場合、コマンドは、影響を受けるオブジェクトの所有者によって発行されたかのように実行されます。特に、このようなコマンドを使用して付与された特権は、オブジェクトの所有者によって付与されたように見えます。（ロールメンバーシップの場合、メンバーシップは包含ロール自体によって付与されたようです。）</target>
        </trans-unit>
        <trans-unit id="bdba0ac2d184c2c84f2cf4f8d54b0cd35c6bae22" translate="yes" xml:space="preserve">
          <source>If a superuser chooses to issue a &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; command, the command is performed as though it were issued by the owner of the affected object. Since all privileges ultimately come from the object owner (possibly indirectly via chains of grant options), it is possible for a superuser to revoke all privileges, but this might require use of &lt;code&gt;CASCADE&lt;/code&gt; as stated above.</source>
          <target state="translated">スーパーユーザーが &lt;code&gt;GRANT&lt;/code&gt; または &lt;code&gt;REVOKE&lt;/code&gt; コマンドを発行することを選択した場合、コマンドは、影響を受けるオブジェクトの所有者によって発行されたかのように実行されます。すべての特権は最終的にオブジェクト所有者から（おそらく付与オプションのチェーンを介して間接的に）提供されるため、スーパーユーザーがすべての特権を取り消すことが可能ですが、これには上記の &lt;code&gt;CASCADE&lt;/code&gt; の使用が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="3105c963db998b17d895e80efc90a4f3ec29f6b5" translate="yes" xml:space="preserve">
          <source>If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns</source>
          <target state="translated">テーブル制約(外部キーを含むが制約トリガーではない)の場合、制約列のリスト</target>
        </trans-unit>
        <trans-unit id="d9d8db43e6826c95f740877ac4ab55e53bc6727a" translate="yes" xml:space="preserve">
          <source>If a table has any descendant tables, it is not permitted to add, rename, or change the type of a column in the parent table without doing the same to the descendants. This ensures that the descendants always have columns matching the parent. Similarly, a &lt;code&gt;CHECK&lt;/code&gt; constraint cannot be renamed in the parent without also renaming it in all descendants, so that &lt;code&gt;CHECK&lt;/code&gt; constraints also match between the parent and its descendants. (That restriction does not apply to index-based constraints, however.) Also, because selecting from the parent also selects from its descendants, a constraint on the parent cannot be marked valid unless it is also marked valid for those descendants. In all of these cases, &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; will be rejected.</source>
          <target state="translated">テーブルに子孫テーブルがある場合、子孫に対して同じことを行わずに、親テーブルの列のタイプを追加、名前変更、または変更することはできません。これにより、子孫が常に親と一致する列を持つようになります。同様に、 &lt;code&gt;CHECK&lt;/code&gt; 制約は、すべての子孫で名前を変更しない限り、親で名前を変更できません。そのため、 &lt;code&gt;CHECK&lt;/code&gt; 制約も親とその子孫の間で一致します。 （ただし、この制限はインデックスベースの制約には適用されません。）また、親からの選択はその子孫からも選択されるため、親の制約は、それらの子孫に対しても有効とマークされていない限り、有効にマークできません。これらすべてのケースで、 &lt;code&gt;ALTER TABLE ONLY&lt;/code&gt; は拒否されます。</target>
        </trans-unit>
        <trans-unit id="f72f4b4a7dd1cbe9511c2732830698755442a3ed" translate="yes" xml:space="preserve">
          <source>If a table has been grouped using &lt;code&gt;GROUP BY&lt;/code&gt;, but only certain groups are of interest, the &lt;code&gt;HAVING&lt;/code&gt; clause can be used, much like a &lt;code&gt;WHERE&lt;/code&gt; clause, to eliminate groups from the result. The syntax is:</source>
          <target state="translated">テーブルが &lt;code&gt;GROUP BY&lt;/code&gt; を使用してグループ化されているが、特定のグループのみが対象である場合、 &lt;code&gt;WHERE&lt;/code&gt; 句と同様に &lt;code&gt;HAVING&lt;/code&gt; 句を使用して、結果からグループを削除できます。構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="fd8b65709a6edce92f223fae042df5baecd19362" translate="yes" xml:space="preserve">
          <source>If a tablespace is relocated in this way, the symbolic links inside the main data directory are updated to point to the new location. So the new data directory is ready to be used for a new server instance with all tablespaces in the updated locations.</source>
          <target state="translated">このようにしてテーブルスペースが再配置されると、メインデータディレクトリ内のシンボリックリンクは新しい場所を指すように更新されます。つまり、新しいデータディレクトリは、すべてのテーブルスペースが更新された場所にある新しいサーバーインスタンスで使用する準備ができています。</target>
        </trans-unit>
        <trans-unit id="58895429ed60b7ffce3462e3dfc985d5ce11688f" translate="yes" xml:space="preserve">
          <source>If a transaction of this sort is going to change the data in the table, then it should use &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock mode instead of &lt;code&gt;SHARE&lt;/code&gt; mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire &lt;code&gt;SHARE&lt;/code&gt; mode, and then be unable to also acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode when it holds &lt;code&gt;SHARE&lt;/code&gt; mode &amp;mdash; but not if anyone else holds &lt;code&gt;SHARE&lt;/code&gt; mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first.</source>
          <target state="translated">この種の取引は、テーブル内のデータを変更しようとしている場合、それは使うべき &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; のロックモードの代わりに、 &lt;code&gt;SHARE&lt;/code&gt; のモードを。これにより、このタイプのトランザクションは一度に1つだけ実行されます。これがないと、デッドロックが発生する可能性があります。2つのトランザクションが両方とも &lt;code&gt;SHARE&lt;/code&gt; モードを取得し、 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; モードを取得して実際に更新を実行できない可能性があります。 （トランザクション自体のロックは競合しないため、 &lt;code&gt;SHARE&lt;/code&gt; モードを保持している場合、トランザクションは &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; モードを取得できますが、他の誰かが &lt;code&gt;SHARE&lt;/code&gt; を保持している場合は取得できません。モード。）デッドロックを回避するには、すべてのトランザクションが同じオブジェクトに対して同じ順序でロックを取得するようにします。単一のオブジェクトに複数のロックモードが含まれる場合、トランザクションは常に最も制限的なモードを最初に取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="2d7eb85ea844d2ba5b981dae6af94a75b4526c2e" translate="yes" xml:space="preserve">
          <source>If a user does not have the required privilege on the table or columns, then in many cases the query will ultimately receive a permission-denied error, in which case this mechanism is invisible in practice. But if the user is reading from a security-barrier view, then the planner might wish to check the statistics of an underlying table that is otherwise inaccessible to the user. In that case, the operator should be leak-proof or the statistics will not be used. There is no direct feedback about that, except that the plan might be suboptimal. If one suspects that this is the case, one could try running the query as a more privileged user, to see if a different plan results.</source>
          <target state="translated">ユーザがテーブルやカラムに対して必要な権限を持っていない場合、多くの場合、クエリは最終的にパーミッション拒否エラーを受け取りますが、この場合、このメカニズムは実際には見えません。しかし、ユーザがセキュリティバリアビューから読み込んでいる場合、プランナは、ユーザがアクセスできない基礎となるテーブルの統計情報をチェックしたいと思うかもしれません。その場合、演算子は漏洩しないようにしなければならないし、統計情報は使用されません。計画が最適ではないかもしれないということを除いて、それについての直接的なフィードバックはありません。このようなことが疑われる場合は、より権限のあるユーザでクエリを実行してみて、異なるプランの結果が得られるかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="6dba31a67ed7f0ca43338760f7f94d591211dfb7" translate="yes" xml:space="preserve">
          <source>If a user holds a privilege with grant option and has granted it to other users then the privileges held by those other users are called dependent privileges. If the privilege or the grant option held by the first user is being revoked and dependent privileges exist, those dependent privileges are also revoked if &lt;code&gt;CASCADE&lt;/code&gt; is specified; if it is not, the revoke action will fail. This recursive revocation only affects privileges that were granted through a chain of users that is traceable to the user that is the subject of this &lt;code&gt;REVOKE&lt;/code&gt; command. Thus, the affected users might effectively keep the privilege if it was also granted through other users.</source>
          <target state="translated">ユーザーが付与オプションを使用して権限を保持し、それを他のユーザーに付与した場合、他のユーザーが保持する権限は依存権限と呼ばれます。最初のユーザーが保持している特権または付与オプションが取り消され、従属特権が存在する場合、 &lt;code&gt;CASCADE&lt;/code&gt; が指定されていると、それらの従属特権も取り消されます。そうでない場合、取り消しアクションは失敗します。この再帰的な取り消しは、この &lt;code&gt;REVOKE&lt;/code&gt; コマンドの対象であるユーザーに追跡可能な一連のユーザーを通じて付与された特権にのみ影響します。したがって、影響を受けるユーザーは、他のユーザーからも権限が付与されている場合、その権限を効果的に保持する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd5f3c1cab021783ead43914fa444508c73ceec6" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not a generated column. Otherwise, &lt;code&gt;s&lt;/code&gt; = stored. (Other values might be added in the future.)</source>
          <target state="translated">ゼロバイト（ &lt;code&gt;''&lt;/code&gt; ）の場合、生成された列ではありません。それ以外の場合、 &lt;code&gt;s&lt;/code&gt; =保存されます。（将来、他の値が追加される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="a7c2f91a2488ff29789b7c51189ebdab420b3b17" translate="yes" xml:space="preserve">
          <source>If a zero byte (&lt;code&gt;''&lt;/code&gt;), then not an identity column. Otherwise, &lt;code&gt;a&lt;/code&gt; = generated always, &lt;code&gt;d&lt;/code&gt; = generated by default.</source>
          <target state="translated">ゼロバイト（ &lt;code&gt;''&lt;/code&gt; ）の場合、ID列ではありません。それ以外の場合、 &lt;code&gt;a&lt;/code&gt; =常に生成され、 &lt;code&gt;d&lt;/code&gt; =デフォルトで生成されます。</target>
        </trans-unit>
        <trans-unit id="ff9b8990736e5c895e3ff32d995dc7be0250f86a" translate="yes" xml:space="preserve">
          <source>If activated, the process writes information about database events into the current &lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;log file&lt;/a&gt;. When reaching certain time- or volume-dependent criteria, a new log file is created. Also called &lt;em&gt;syslogger&lt;/em&gt;.</source>
          <target state="translated">有効にすると、プロセスはデータベースイベントに関する情報を現在の&lt;a href=&quot;glossary#GLOSSARY-LOG-FILE&quot;&gt;ログファイルに&lt;/a&gt;書き込みます。時間またはボリュームに依存する特定の基準に達すると、新しいログファイルが作成されます。&lt;em&gt;syslogger&lt;/em&gt;とも呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5de4b09ad9373970f4d3245c8e5f5878c7360739" translate="yes" xml:space="preserve">
          <source>If all inputs are of the same type, and it is not &lt;code&gt;unknown&lt;/code&gt;, resolve as that type.</source>
          <target state="translated">すべての入力が同じタイプで、 &lt;code&gt;unknown&lt;/code&gt; ではない場合は、そのタイプとして解決してください。</target>
        </trans-unit>
        <trans-unit id="2f0d22550a877dd1e7a10ea59bd4e64873db9458" translate="yes" xml:space="preserve">
          <source>If all inputs are of type &lt;code&gt;unknown&lt;/code&gt;, resolve as type &lt;code&gt;text&lt;/code&gt; (the preferred type of the string category). Otherwise, &lt;code&gt;unknown&lt;/code&gt; inputs are ignored for the purposes of the remaining rules.</source>
          <target state="translated">すべての入力のタイプが &lt;code&gt;unknown&lt;/code&gt; の場合は、タイプ &lt;code&gt;text&lt;/code&gt; （文字列カテゴリの推奨されるタイプ）として解決します。それ以外の場合、残りのルールでは、 &lt;code&gt;unknown&lt;/code&gt; 入力は無視されます。</target>
        </trans-unit>
        <trans-unit id="aa6c40971fdf72080d58a6233c79f7c8dce2a255" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ORDER BY&lt;/code&gt; expression is a simple name that matches both an output column name and an input column name, &lt;code&gt;ORDER BY&lt;/code&gt; will interpret it as the output column name. This is the opposite of the choice that &lt;code&gt;GROUP BY&lt;/code&gt; will make in the same situation. This inconsistency is made to be compatible with the SQL standard.</source>
          <target state="translated">場合は &lt;code&gt;ORDER BY&lt;/code&gt; 式は出力列名と入力列名の両方に一致する単純な名前があり、 &lt;code&gt;ORDER BY&lt;/code&gt; は、出力列名として解釈されます。これは、 &lt;code&gt;GROUP BY&lt;/code&gt; が同じ状況で行う選択の逆です。この不整合は、SQL標準と互換性があるように作成されています。</target>
        </trans-unit>
        <trans-unit id="0ad7084c5cdd9f3be36397e8c9220c13ae237d6c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;existing_window_name&lt;/code&gt; is specified it must refer to an earlier entry in the &lt;code&gt;WINDOW&lt;/code&gt; list; the new window copies its partitioning clause from that entry, as well as its ordering clause if any. In this case the new window cannot specify its own &lt;code&gt;PARTITION BY&lt;/code&gt; clause, and it can specify &lt;code&gt;ORDER BY&lt;/code&gt; only if the copied window does not have one. The new window always uses its own frame clause; the copied window must not specify a frame clause.</source>
          <target state="translated">&lt;code&gt;existing_window_name&lt;/code&gt; を指定する場合は、 &lt;code&gt;WINDOW&lt;/code&gt; リストの前のエントリを参照する必要があります。新しいウィンドウは、そのエントリからパーティション化句をコピーし、必要に応じて順序付け句もコピーします。この場合、新しいウィンドウは独自の &lt;code&gt;PARTITION BY&lt;/code&gt; 句を指定できません。また、コピーされたウィンドウにない場合にのみ、 &lt;code&gt;ORDER BY&lt;/code&gt; を指定できます。新しいウィンドウは常に独自のフレーム句を使用します。コピーされたウィンドウはフレーム句を指定してはなりません。</target>
        </trans-unit>
        <trans-unit id="d9f4f0d891ac5ca27debdc2266324be50c274311" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;options&lt;/code&gt; string is specified it must consist of a comma-separated list of one or more &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs. The available options are:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 文字列を指定する場合は、1つ以上の &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; ペアのコンマ区切りのリストで構成する必要があります。使用可能なオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7cd30de9bbf3f8180a703c4e2d6c583071ea1a34" translate="yes" xml:space="preserve">
          <source>If an OID that does not represent an existing object is passed as argument to one of the above functions, NULL is returned.</source>
          <target state="translated">上記のいずれかの関数の引数に、既存のオブジェクトを表さないOIDが渡された場合、NULLが返されます。</target>
        </trans-unit>
        <trans-unit id="ffc31d26a07681f5637a04d968a3f5e70276453d" translate="yes" xml:space="preserve">
          <source>If an aggregate supports moving-aggregate mode, it will improve calculation efficiency when the aggregate is used as a window function for a window with moving frame start (that is, a frame start mode other than &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;). Conceptually, the forward transition function adds input values to the aggregate's state when they enter the window frame from the bottom, and the inverse transition function removes them again when they leave the frame at the top. So, when values are removed, they are always removed in the same order they were added. Whenever the inverse transition function is invoked, it will thus receive the earliest added but not yet removed argument value(s). The inverse transition function can assume that at least one row will remain in the current state after it removes the oldest row. (When this would not be the case, the window function mechanism simply starts a fresh aggregation, rather than using the inverse transition function.)</source>
          <target state="translated">集約が移動集約モードをサポートしている場合、集約が移動フレーム開始（つまり、 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 以外のフレーム開始モード）を持つウィンドウのウィンドウ関数として使用されると、計算効率が向上します。）。概念的には、順方向遷移関数は、下からウィンドウフレームに入るときに集約の状態に入力値を追加し、逆遷移関数は、フレームが一番上にあるときに再びそれらを削除します。したがって、値が削除されると、それらは常に、追加されたのと同じ順序で削除されます。したがって、逆遷移関数が呼び出されるときはいつでも、最初に追加されたがまだ削除されていない引数値を受け取ります。逆遷移関数は、最も古い行を削除した後、少なくとも1つの行が現在の状態のままであると想定できます。 （これが当てはまらない場合、ウィンドウ関数メカニズムは、逆遷移関数を使用するのではなく、単に新しい集計を開始します。）</target>
        </trans-unit>
        <trans-unit id="3eaeb85716c71ac82a1780ada62bc3bcdfffa64e" translate="yes" xml:space="preserve">
          <source>If an arbitrary value expression is used in the select list, it conceptually adds a new virtual column to the returned table. The value expression is evaluated once for each result row, with the row's values substituted for any column references. But the expressions in the select list do not have to reference any columns in the table expression of the &lt;code&gt;FROM&lt;/code&gt; clause; they can be constant arithmetic expressions, for instance.</source>
          <target state="translated">選択リストで任意の値式が使用されている場合、概念的には、返されたテーブルに新しい仮想列が追加されます。値式は結果行ごとに1回評価され、行の値は列参照に置き換えられます。ただし、選択リストの式は、 &lt;code&gt;FROM&lt;/code&gt; 句のテーブル式の列を参照する必要はありません。たとえば、定数演算式にすることができます。</target>
        </trans-unit>
        <trans-unit id="80b1d5b3ba2fcc79e9cc1eabebb22c4a831065de" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view contains a &lt;code&gt;WHERE&lt;/code&gt; condition, the condition restricts which rows of the base relation are available to be modified by &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements on the view. However, an &lt;code&gt;UPDATE&lt;/code&gt; is allowed to change a row so that it no longer satisfies the &lt;code&gt;WHERE&lt;/code&gt; condition, and thus is no longer visible through the view. Similarly, an &lt;code&gt;INSERT&lt;/code&gt; command can potentially insert base-relation rows that do not satisfy the &lt;code&gt;WHERE&lt;/code&gt; condition and thus are not visible through the view (&lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; may similarly affect an existing row not visible through the view). The &lt;code&gt;CHECK OPTION&lt;/code&gt; may be used to prevent &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands from creating such rows that are not visible through the view.</source>
          <target state="translated">自動的に更新可能なビューに &lt;code&gt;WHERE&lt;/code&gt; 条件が含まれている場合、その条件により、ビューの &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; ステートメントで変更できる基本リレーションの行が制限されます。ただし、 &lt;code&gt;UPDATE&lt;/code&gt; は行を変更することを許可されるため、行は &lt;code&gt;WHERE&lt;/code&gt; 条件を満たさなくなり、ビューからは見えなくなります。同様に、 &lt;code&gt;INSERT&lt;/code&gt; コマンドは、 &lt;code&gt;WHERE&lt;/code&gt; 条件を満たさないためにビューからは見えないベースリレーション行を挿入する可能性があります（ &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; は、ビューからは見えない既存の行にも同様に影響する可能性があります）。 &lt;code&gt;CHECK OPTION&lt;/code&gt; 防止するために使用することができる &lt;code&gt;INSERT&lt;/code&gt; と &lt;code&gt;UPDATE&lt;/code&gt; のビューを介して見えないような行を作成からコマンドを。</target>
        </trans-unit>
        <trans-unit id="2404db1fa7170a324c806fd815c2c382fbb3ff70" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">自動的に更新可能なビューが &lt;code&gt;security_barrier&lt;/code&gt; プロパティでマークされている場合、ビューのすべての &lt;code&gt;WHERE&lt;/code&gt; 条件（および &lt;code&gt;LEAKPROOF&lt;/code&gt; としてマークされている演算子を使用するすべての条件）は、ビューのユーザーが追加した条件の前に常に評価されます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;セクション40.5&lt;/a&gt;を参照してください。このため、最終的に返されない行（ユーザーの &lt;code&gt;WHERE&lt;/code&gt; 条件を渡さないため）がロックされたままになる可能性があることに注意してください。 &lt;code&gt;EXPLAIN&lt;/code&gt; を使用して、関係レベルで適用されている（したがって、行をロックしない）条件と適用されていない条件を確認できます。</target>
        </trans-unit>
        <trans-unit id="079f47cbc1cbed10c9582aabec32812c70758e86" translate="yes" xml:space="preserve">
          <source>If an automatically updatable view is marked with the &lt;code&gt;security_barrier&lt;/code&gt; property then all the view's &lt;code&gt;WHERE&lt;/code&gt; conditions (and any conditions using operators which are marked as &lt;code&gt;LEAKPROOF&lt;/code&gt;) will always be evaluated before any conditions that a user of the view has added. See &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for full details. Note that, due to this, rows which are not ultimately returned (because they do not pass the user's &lt;code&gt;WHERE&lt;/code&gt; conditions) may still end up being locked. &lt;code&gt;EXPLAIN&lt;/code&gt; can be used to see which conditions are applied at the relation level (and therefore do not lock rows) and which are not.</source>
          <target state="translated">自動的に更新可能なビューが &lt;code&gt;security_barrier&lt;/code&gt; プロパティでマークされている場合、すべてのビューの &lt;code&gt;WHERE&lt;/code&gt; 条件（および &lt;code&gt;LEAKPROOF&lt;/code&gt; としてマークされている演算子を使用する条件）は、ビューのユーザーが追加した条件の前に常に評価されます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;セクション40.5&lt;/a&gt;を参照してください。このため、最終的に返されない行（ユーザーの &lt;code&gt;WHERE&lt;/code&gt; 条件を通過しないため）がロックされてしまう可能性があることに注意してください。 &lt;code&gt;EXPLAIN&lt;/code&gt; を使用して、リレーションレベルで適用されている（したがって行をロックしない）条件と適用されていない条件を確認できます。</target>
        </trans-unit>
        <trans-unit id="5c5594932b933065e06b18f724dcf95bf8608f76" translate="yes" xml:space="preserve">
          <source>If an error in these files is detected at server start, the server will refuse to start. But if an error is detected during a configuration reload, the files are ignored and the old SSL configuration continues to be used. On Windows systems, if an error in these files is detected at backend start, that backend will be unable to establish an SSL connection. In all these cases, the error condition is reported in the server log.</source>
          <target state="translated">サーバの起動時にこれらのファイルのエラーが検出された場合、サーバは起動を拒否します。しかし、設定のリロード中にエラーが検出された場合、ファイルは無視され、古いSSL設定が引き続き使用されます。Windowsシステムでは、バックエンドの起動時にこれらのファイルのエラーが検出されると、バックエンドはSSL接続を確立できなくなります。これらの場合、エラー状態はサーバーログに報告されます。</target>
        </trans-unit>
        <trans-unit id="97b646bc602dad48858332961c1cd79032617933" translate="yes" xml:space="preserve">
          <source>If an error occurs while reading the time zone abbreviation set, no new value is applied and the old set is kept. If the error occurs while starting the database, startup fails.</source>
          <target state="translated">タイムゾーン略語セットの読み込み中にエラーが発生した場合、新しい値は適用されず、古いセットが保持されます。データベースの起動中にエラーが発生した場合、起動に失敗する。</target>
        </trans-unit>
        <trans-unit id="1de87c93627deeafcb3370199aca0fb5ecf8ffbd" translate="yes" xml:space="preserve">
          <source>If an error occurs while restoring the database schema, &lt;code&gt;pg_upgrade&lt;/code&gt; will exit and you will have to revert to the old cluster as outlined in &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;Step 16&lt;/a&gt; below. To try &lt;code&gt;pg_upgrade&lt;/code&gt; again, you will need to modify the old cluster so the pg_upgrade schema restore succeeds. If the problem is a &lt;code&gt;contrib&lt;/code&gt; module, you might need to uninstall the &lt;code&gt;contrib&lt;/code&gt; module from the old cluster and install it in the new cluster after the upgrade, assuming the module is not being used to store user data.</source>
          <target state="translated">データベーススキーマの復元中にエラーが発生した場合、 &lt;code&gt;pg_upgrade&lt;/code&gt; は終了し、以下の&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REVERT&quot;&gt;ステップ16で&lt;/a&gt;説明されているように古いクラスターに戻す必要があります。 &lt;code&gt;pg_upgrade&lt;/code&gt; を再試行するには、pg_upgradeスキーマの復元が成功するように古いクラスターを変更する必要があります。問題が &lt;code&gt;contrib&lt;/code&gt; モジュールである場合、モジュールがユーザーデータの格納に使用されていないと想定して、古いクラスターから &lt;code&gt;contrib&lt;/code&gt; モジュールをアンインストールし、アップグレード後に新しいクラスターにインストールする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="f87c733146ee0c8066dc39794ef31c58e51824d2" translate="yes" xml:space="preserve">
          <source>If an exclusion constraint, list of the per-column exclusion operators</source>
          <target state="translated">除外制約の場合、列ごとの除外演算子のリスト</target>
        </trans-unit>
        <trans-unit id="5e3f8c180f35468731cc99d8e63857d68ba52649" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of a composite type (row type), then a specific field of the row can be extracted by writing</source>
          <target state="translated">式が複合型(行の型)の値を返す場合、行の特定のフィールドを抽出するには</target>
        </trans-unit>
        <trans-unit id="4ecdcd8e3d88016c98e66e3a3a5e3c60d566e607" translate="yes" xml:space="preserve">
          <source>If an expression yields a value of an array type, then a specific element of the array value can be extracted by writing</source>
          <target state="translated">式が配列型の値を返す場合、配列値の特定の要素は</target>
        </trans-unit>
        <trans-unit id="6de9a52dce84b15b69f729bccf651727ae858f41" translate="yes" xml:space="preserve">
          <source>If an index build fails with the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option, this index is left as &amp;ldquo;invalid&amp;rdquo;. Such indexes are useless but it can be convenient to use &lt;code&gt;REINDEX&lt;/code&gt; to rebuild them. Note that only &lt;code&gt;REINDEX INDEX&lt;/code&gt; is able to perform a concurrent build on an invalid index.</source>
          <target state="translated">インデックスの作成が &lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションで失敗した場合、このインデックスは「無効」のままになります。このようなインデックスは &lt;code&gt;REINDEX&lt;/code&gt; 、REINDEXを使用して再構築すると便利です。 &lt;code&gt;REINDEX INDEX&lt;/code&gt; のみが無効なインデックスで並行ビルドを実行できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b3fe0fb957d2052bc5b183b29d4175b03f7dd244" translate="yes" xml:space="preserve">
          <source>If an input file name is just &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;ecpg&lt;/code&gt; reads the program from standard input (and writes to standard output, unless that is overridden with &lt;code&gt;-o&lt;/code&gt;).</source>
          <target state="translated">入力ファイル名が &lt;code&gt;-&lt;/code&gt; だけの場合、 &lt;code&gt;ecpg&lt;/code&gt; は標準入力からプログラムを読み取ります（ &lt;code&gt;-o&lt;/code&gt; でオーバーライドされない限り、標準出力に書き込みます）。</target>
        </trans-unit>
        <trans-unit id="2ce1cc9d13f2dd4c882f2d9159dd6b972278963b" translate="yes" xml:space="preserve">
          <source>If an option is specified that is valid, but not relevant to the selected operating mode, pg_ctl ignores it.</source>
          <target state="translated">有効なオプションが指定されているが、選択された動作モードには関係ない場合、pg_ctlはそれを無視します。</target>
        </trans-unit>
        <trans-unit id="848fca9ee8526b8eb2fb6fd4b08b921862d216f2" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt; below. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">引用符で囲まれていない場合は、コロン（ &lt;code&gt;:&lt;/code&gt; ）psqlの変数名に続く引数の中に現れるで説明したように、それは、変数の値に置き換えられます&lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL補間&lt;/a&gt;を下回ります。そこに記述されている形式 &lt;code&gt;:'variable_name'&lt;/code&gt; および &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; も同様に機能します。 &lt;code&gt;:{?variable_name}&lt;/code&gt; 構文は、変数が定義されているかどうかをテストすることができます。TRUEまたはFALSEに置き換えられます。バックスラッシュでコロンをエスケープすると、コロンが置換から保護されます。</target>
        </trans-unit>
        <trans-unit id="af23873c246a8a5e4a8cad331942f631fec99b40" translate="yes" xml:space="preserve">
          <source>If an unquoted colon (&lt;code&gt;:&lt;/code&gt;) followed by a psql variable name appears within an argument, it is replaced by the variable's value, as described in &lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL Interpolation&lt;/a&gt;. The forms &lt;code&gt;:'variable_name'&lt;/code&gt; and &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; described there work as well. The &lt;code&gt;:{?variable_name}&lt;/code&gt; syntax allows testing whether a variable is defined. It is substituted by TRUE or FALSE. Escaping the colon with a backslash protects it from substitution.</source>
          <target state="translated">（引用符で囲まれていないが、コロン場合 &lt;code&gt;:&lt;/code&gt; ）psqlの変数名に続く引数の中に現れるで説明したように、それは、変数の値によって置き換えられる&lt;a href=&quot;app-psql#APP-PSQL-INTERPOLATION&quot;&gt;SQL補間&lt;/a&gt;。そこに記述されている &lt;code&gt;:'variable_name'&lt;/code&gt; および &lt;code&gt;:&quot;variable_name&quot;&lt;/code&gt; という形式も同様に機能します。 &lt;code&gt;:{?variable_name}&lt;/code&gt; 構文は、変数が定義されているかどうかをテストすることができます。TRUEまたはFALSEに置き換えられます。コロンをバックスラッシュでエスケープすると、コロンが置換されなくなります。</target>
        </trans-unit>
        <trans-unit id="e21ea67d0d720310272c7536aaef9fbd409c780b" translate="yes" xml:space="preserve">
          <source>If an upstream standby server is promoted to become new master, downstream servers will continue to stream from the new master if &lt;code&gt;recovery_target_timeline&lt;/code&gt; is set to &lt;code&gt;'latest'&lt;/code&gt; (the default).</source>
          <target state="translated">アップストリームスタンバイサーバーが新しいマスターに昇格した場合、 &lt;code&gt;recovery_target_timeline&lt;/code&gt; が &lt;code&gt;'latest'&lt;/code&gt; （デフォルト）に設定されていれば、ダウンストリームサーバーは引き続き新しいマスターからストリーミングします。</target>
        </trans-unit>
        <trans-unit id="3bd7c108b9d4e211b151f51193b945c5454b1371" translate="yes" xml:space="preserve">
          <source>If any dimension is written as a slice, i.e., contains a colon, then all dimensions are treated as slices. Any dimension that has only a single number (no colon) is treated as being from 1 to the number specified. For example, &lt;code&gt;[2]&lt;/code&gt; is treated as &lt;code&gt;[1:2]&lt;/code&gt;, as in this example:</source>
          <target state="translated">ディメンションがスライスとして記述されている場合、つまりコロンが含まれている場合、すべてのディメンションはスライスとして扱われます。数値が1つしかない（コロンがない）ディメンションは、1から指定した数値までとして扱われます。たとえば、次の例のように、 &lt;code&gt;[2]&lt;/code&gt; は &lt;code&gt;[1:2]&lt;/code&gt; として扱われます。</target>
        </trans-unit>
        <trans-unit id="644d831a9e7d5bb7b9cf967c049a8eb98186cce0" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-function resolution.</source>
          <target state="translated">入力引数がドメイン型の場合、それ以降のすべてのステップでドメインのベース型として扱います。これにより、曖昧関数の解決のためにドメインがそのベース型と同じように動作することが保証されます。</target>
        </trans-unit>
        <trans-unit id="aa9d9b8570b39bd99c0391cf769b6b9a97f8cfdc" translate="yes" xml:space="preserve">
          <source>If any input argument is of a domain type, treat it as being of the domain's base type for all subsequent steps. This ensures that domains act like their base types for purposes of ambiguous-operator resolution.</source>
          <target state="translated">入力引数がドメイン型の場合、それ以降のすべてのステップでドメインのベース型として扱います。これにより、曖昧な演算子の解決のためにドメインがそのベース型と同じように動作することが保証されます。</target>
        </trans-unit>
        <trans-unit id="f08ac7bfcc7896ec3ccba829e9cc32f16385e939" translate="yes" xml:space="preserve">
          <source>If any input arguments are &lt;code&gt;unknown&lt;/code&gt;, check the type categories accepted at those argument positions by the remaining candidates. At each position, select the &lt;code&gt;string&lt;/code&gt; category if any candidate accepts that category. (This bias towards string is appropriate since an unknown-type literal looks like a string.) Otherwise, if all the remaining candidates accept the same type category, select that category; otherwise fail because the correct choice cannot be deduced without more clues. Now discard candidates that do not accept the selected type category. Furthermore, if any candidate accepts a preferred type in that category, discard candidates that accept non-preferred types for that argument. Keep all candidates if none survive these tests. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; な入力引数がある場合は、残りの候補がそれらの引数位置で受け入れた型カテゴリーを確認してください。各位置で、 &lt;code&gt;string&lt;/code&gt; 選択します候補者がそのカテゴリを受け入れる場合、そのカテゴリ。 （未知のタイプのリテラルはストリングのように見えるため、ストリングに対するこのバイアスは適切です。）それ以外の場合、残りのすべての候補が同じタイプのカテゴリーを受け入れる場合は、そのカテゴリーを選択します。それ以外の場合は、手がかりがなければ正しい選択を導き出すことができないため失敗します。次に、選択したタイプのカテゴリーを受け入れない候補を破棄します。さらに、いずれかの候補がそのカテゴリーの優先タイプを受け入れる場合、その引数の非優先タイプを受け入れる候補を破棄します。これらのテストに合格できなかった場合は、すべての候補者を保持します。候補が1つだけ残っている場合は、それを使用します。それ以外の場合は、次のステップに進みます。</target>
        </trans-unit>
        <trans-unit id="88a4eb3b7b2c17b935f14a3d49969dbb3c987944" translate="yes" xml:space="preserve">
          <source>If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination.</source>
          <target state="translated">いずれかの入力式が明示的な照合の派生を持つ場合、入力式の中で明示的に派生した照合はすべて同じでなければならず、そうでない場合はエラーが発生します。明示的に導出された照合が存在する場合、それは照合の組み合わせの結果です。</target>
        </trans-unit>
        <trans-unit id="848b268c3aef8e0ec228a9fd161ed5d209cdafec" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">入力がドメインタイプの場合は、以降のすべての手順でドメインの基本タイプとして扱います。&lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5b589b0a29736a2c76abe777e082206c27d9542" translate="yes" xml:space="preserve">
          <source>If any input is of a domain type, treat it as being of the domain's base type for all subsequent steps. &lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">入力がドメインタイプのものである場合、それ以降のすべてのステップで、その入力をドメインの基本タイプとして扱います。&lt;a href=&quot;#ftn.id-1.5.9.10.9.3.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.9.10.9.3.1.1&quot;&gt;[12]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062ef5413f1971acdecb4ea39fded859da884ac5" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;GROUPING SETS&lt;/code&gt;, &lt;code&gt;ROLLUP&lt;/code&gt; or &lt;code&gt;CUBE&lt;/code&gt; are present as grouping elements, then the &lt;code&gt;GROUP BY&lt;/code&gt; clause as a whole defines some number of independent &lt;code&gt;grouping sets&lt;/code&gt;. The effect of this is equivalent to constructing a &lt;code&gt;UNION ALL&lt;/code&gt; between subqueries with the individual grouping sets as their &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For further details on the handling of grouping sets see &lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;Section 7.2.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GROUPING SETS&lt;/code&gt; 、 &lt;code&gt;ROLLUP&lt;/code&gt; 、または &lt;code&gt;CUBE&lt;/code&gt; のいずれかがグループ化要素として存在する場合、 &lt;code&gt;GROUP BY&lt;/code&gt; 句は全体として、いくつかの独立した &lt;code&gt;grouping sets&lt;/code&gt; を定義します。これの効果は、個々のグループ化セットを &lt;code&gt;GROUP BY&lt;/code&gt; 句として使用して、サブクエリ間に &lt;code&gt;UNION ALL&lt;/code&gt; を構築することと同じです。グループ化セットの処理の詳細については、&lt;a href=&quot;queries-table-expressions#QUERIES-GROUPING-SETS&quot;&gt;セクション7.2.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ee7daf9476f8c0077c19fa91e9fc5b6d1dd5a0b5" translate="yes" xml:space="preserve">
          <source>If any of the child tables are foreign tables whose foreign data wrappers do not support &lt;code&gt;ANALYZE&lt;/code&gt;, those child tables are ignored while gathering inheritance statistics.</source>
          <target state="translated">子テーブルのいずれかが、外部データラッパーが &lt;code&gt;ANALYZE&lt;/code&gt; をサポートしない外部テーブルである場合、継承統計の収集中、それらの子テーブルは無視されます。</target>
        </trans-unit>
        <trans-unit id="5559a39fd47d326a14a46d78afa053af9afa62f6" translate="yes" xml:space="preserve">
          <source>If any of the columns of a table are TOAST-able, the table will have an associated TOAST table, whose OID is stored in the table's &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; entry. On-disk TOASTed values are kept in the TOAST table, as described in more detail below.</source>
          <target state="translated">テーブルのいずれかの列がTOAST可能である場合、テーブルには関連するTOASTテーブルがあり、そのOIDはテーブルの &lt;code&gt;pg_class&lt;/code&gt; に保存されます。 &lt;code&gt;reltoastrelid&lt;/code&gt; エントリ。ディスク上でTOASTされた値は、以下で詳しく説明するように、TOASTテーブルに保持されます。</target>
        </trans-unit>
        <trans-unit id="cf49cd2bc67ee3c3481f1ffe2933861356e2738f" translate="yes" xml:space="preserve">
          <source>If any of the tables referenced by the view are temporary, the view is created as a temporary view (whether &lt;code&gt;TEMPORARY&lt;/code&gt; is specified or not).</source>
          <target state="translated">ビューによって参照されるテーブルのいずれかが一時的なものである場合、ビューは一時的なビューとして作成されます（ &lt;code&gt;TEMPORARY&lt;/code&gt; が指定されているかどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="e74c2195dcb53833cfc91730aac90c474163ed9c" translate="yes" xml:space="preserve">
          <source>If any post-upgrade processing is required, pg_upgrade will issue warnings as it completes. It will also generate script files that must be run by the administrator. The script files will connect to each database that needs post-upgrade processing. Each script should be run using:</source>
          <target state="translated">アップグレード後の処理が必要な場合、pg_upgradeはそれが完了すると警告を発します。また、管理者が実行しなければならないスクリプトファイルも生成されます。このスクリプトファイルは、アップグレード後の処理が必要な各データベースに接続します。各スクリプトは、以下を使用して実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="800a2d135577a55dc7316ea712cf7f6d1165ae24" translate="yes" xml:space="preserve">
          <source>If archive storage size is a concern, you can use gzip to compress the archive files:</source>
          <target state="translated">アーカイブの保存サイズが気になる場合は、gzipを使ってアーカイブファイルを圧縮することができます。</target>
        </trans-unit>
        <trans-unit id="2e48896c1f0ace93b93a8656d8514a4835072596" translate="yes" xml:space="preserve">
          <source>If at all possible, &lt;em&gt;do not&lt;/em&gt; use &lt;code&gt;SIGKILL&lt;/code&gt; to kill the main &lt;code&gt;postgres&lt;/code&gt; server. Doing so will prevent &lt;code&gt;postgres&lt;/code&gt; from freeing the system resources (e.g., shared memory and semaphores) that it holds before terminating. This might cause problems for starting a fresh &lt;code&gt;postgres&lt;/code&gt; run.</source>
          <target state="translated">可能であれば、 &lt;code&gt;SIGKILL&lt;/code&gt; を使用してメインの &lt;code&gt;postgres&lt;/code&gt; サーバーを終了&lt;em&gt;しない&lt;/em&gt;で&lt;em&gt;ください&lt;/em&gt;。そうすることで、 &lt;code&gt;postgres&lt;/code&gt; が終了前に保持していたシステムリソース（共有メモリやセマフォなど）を解放できなくなります。これにより、新しい &lt;code&gt;postgres&lt;/code&gt; 実行を開始するときに問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed12d9d5c43a1c95cedd4f159ed6ce3a1940c1ed" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; appear, then &lt;code&gt;OFFSET&lt;/code&gt; rows are skipped before starting to count the &lt;code&gt;LIMIT&lt;/code&gt; rows that are returned.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; と &lt;code&gt;LIMIT&lt;/code&gt; の両方が表示される場合、返される &lt;code&gt;LIMIT&lt;/code&gt; 行のカウントを開始する前に、 &lt;code&gt;OFFSET&lt;/code&gt; 行はスキップされます。</target>
        </trans-unit>
        <trans-unit id="d1beaf85265bd8e8de4c00a803a4295f898d6a9d" translate="yes" xml:space="preserve">
          <source>If both standard input and standard output are a terminal, then psql sets the client encoding to &amp;ldquo;auto&amp;rdquo;, which will detect the appropriate client encoding from the locale settings (&lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable on Unix systems). If this doesn't work out as expected, the client encoding can be overridden using the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;.</source>
          <target state="translated">標準入力と標準出力の両方がターミナルである場合、psqlはクライアントエンコーディングを「auto」に設定します。これにより、ロケール設定（UNIXシステムの &lt;code&gt;LC_CTYPE&lt;/code&gt; 環境変数）から適切なクライアントエンコーディングが検出されます。これが期待どおりに機能しない場合は、環境変数 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; を使用してクライアントのエンコードをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="124d332dfa6ef76e2334514ac990a431fc574564" translate="yes" xml:space="preserve">
          <source>If cascaded replication is in use the feedback is passed upstream until it eventually reaches the primary. Standbys make no other use of feedback they receive other than to pass upstream.</source>
          <target state="translated">カスケードレプリケーションを使用している場合、フィードバックは最終的にプライマリに到達するまで上流に渡されます。スタンバイは、受信したフィードバックをアップストリームに渡す以外には使用しません。</target>
        </trans-unit>
        <trans-unit id="21ad797b1873a315d3fc0d5c790db4d1476ce970" translate="yes" xml:space="preserve">
          <source>If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt;. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., &lt;code&gt;[x]&lt;/code&gt; becomes &lt;code&gt;[xX]&lt;/code&gt; and &lt;code&gt;[^x]&lt;/code&gt; becomes &lt;code&gt;[^xX]&lt;/code&gt;.</source>
          <target state="translated">大文字と小文字を区別しない一致が指定されている場合、効果はすべての大文字と小文字の区別がアルファベットから消えたかのようになります。複数のケースに存在するアルファベットがブラケット式の外の通常の文字として表示される場合、それは両方のケースを含むブラケット式に効果的に変換されます。たとえば、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;[xX]&lt;/code&gt; になります。括弧式の内側にある場合、対応するすべての大文字小文字が括弧式に追加されます。たとえば、 &lt;code&gt;[x]&lt;/code&gt; は &lt;code&gt;[xX]&lt;/code&gt; になり、 &lt;code&gt;[^x]&lt;/code&gt; は &lt;code&gt;[^xX]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf258208ab5152d2c12b1e28ed793831fd7c461c" translate="yes" xml:space="preserve">
          <source>If column aliases are not supplied, then for a function returning a base data type, the column name is also the same as the function name. For a function returning a composite type, the result columns get the names of the individual attributes of the type.</source>
          <target state="translated">カラムのエイリアスが指定されていない場合、ベース・データ型を返す関数では、カラム名も関数名と同じになります。複合型を返す関数の場合、結果のカラムはその型の個々の属性の名前を取得します。</target>
        </trans-unit>
        <trans-unit id="6deaaf1ae6fdc8847b55dec525d8c4461d71750b" translate="yes" xml:space="preserve">
          <source>If consistent response time is more important than update speed, use of pending entries can be disabled by turning off the &lt;code&gt;fastupdate&lt;/code&gt; storage parameter for a GIN index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details.</source>
          <target state="translated">更新速度よりも一貫した応答時間が重要な場合は、GINインデックスの &lt;code&gt;fastupdate&lt;/code&gt; ストレージパラメータをオフにすることで、保留中のエントリの使用を無効にできます。詳細については、&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="41ef4d0c1740eb702f05dcbd27c8d877f11fcd3a" translate="yes" xml:space="preserve">
          <source>If csvlog is included in &lt;code&gt;log_destination&lt;/code&gt;, log entries are output in &amp;ldquo;comma separated value&amp;rdquo; (CSV) format, which is convenient for loading logs into programs. See &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;Section 19.8.4&lt;/a&gt; for details. &lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collector&lt;/a&gt; must be enabled to generate CSV-format log output.</source>
          <target state="translated">csvlogがlog_destinationに含まれている &lt;code&gt;log_destination&lt;/code&gt; 、ログエントリは「カンマ区切り値」（CSV）形式で出力されます。これは、ログをプログラムにロードするのに便利です。詳細は&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;項19.8.4&lt;/a&gt;を参照してください。CSV形式のログ出力を生成するには、&lt;a href=&quot;runtime-config-logging#GUC-LOGGING-COLLECTOR&quot;&gt;logging_collectorを&lt;/a&gt;有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="ed1042acfa5d378be31e2b80e8d7ffc7bef64f8e" translate="yes" xml:space="preserve">
          <source>If data checksums are enabled, hint bit updates are always WAL-logged and this setting is ignored. You can use this setting to test how much extra WAL-logging would occur if your database had data checksums enabled.</source>
          <target state="translated">データチェックサムが有効な場合、ヒントビットの更新は常にWAL-loggingされ、この設定は無視されます。この設定を使用して、データベースがデータチェックサムを有効にしている場合に、どれだけ余分なWAL-loggingが発生するかをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="9574b9b4b7b428cee25c96a3966fa8df72a24cd9" translate="yes" xml:space="preserve">
          <source>If different date/time types need to be compared, an implicit cast is applied. A &lt;code&gt;date&lt;/code&gt; value can be cast to &lt;code&gt;timestamp&lt;/code&gt; or &lt;code&gt;timestamptz&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt; can be cast to &lt;code&gt;timestamptz&lt;/code&gt;, and &lt;code&gt;time&lt;/code&gt; to &lt;code&gt;timetz&lt;/code&gt;. However, all but the first of these conversions depend on the current &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; setting, and thus can only be performed within timezone-aware &lt;code&gt;jsonpath&lt;/code&gt; functions.</source>
          <target state="translated">異なる日付/時刻タイプを比較する必要がある場合は、暗黙的なキャストが適用されます。 &lt;code&gt;date&lt;/code&gt; 値をにキャストすることができ &lt;code&gt;timestamp&lt;/code&gt; や &lt;code&gt;timestamptz&lt;/code&gt; 、 &lt;code&gt;timestamp&lt;/code&gt; にキャストすることができ &lt;code&gt;timestamptz&lt;/code&gt; 、および &lt;code&gt;time&lt;/code&gt; に &lt;code&gt;timetz&lt;/code&gt; 。ただし、これらの変換の最初のものを除くすべては、現在の&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;設定に依存するため、タイムゾーン対応の &lt;code&gt;jsonpath&lt;/code&gt; 関数内でのみ実行できます。</target>
        </trans-unit>
        <trans-unit id="cf0a4beca9338b9c149bc626eda6f48fc9e5c025" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;toptag&lt;/code&gt; or &lt;code&gt;itemtag&lt;/code&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">&lt;code&gt;toptag&lt;/code&gt; または &lt;code&gt;itemtag&lt;/code&gt; のいずれかが空の文字列の場合、関連するタグは省略されます。</target>
        </trans-unit>
        <trans-unit id="03df124a73c895463360e1ed34f1a74da7815fc6" translate="yes" xml:space="preserve">
          <source>If either &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt; or &lt;em&gt;&lt;code&gt;itemtag&lt;/code&gt;&lt;/em&gt; is an empty string, the relevant tag is omitted.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;toptag&lt;/code&gt; &lt;/em&gt;または&lt;em&gt; &lt;code&gt;itemtag&lt;/code&gt; の&lt;/em&gt;いずれかが空の文字列の場合、関連するタグは省略されます。</target>
        </trans-unit>
        <trans-unit id="b92d15119505820507c6255b9360f73a82ee471e" translate="yes" xml:space="preserve">
          <source>If executed during recovery, the &lt;code&gt;CHECKPOINT&lt;/code&gt; command will force a restartpoint (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;) rather than writing a new checkpoint.</source>
          <target state="translated">リカバリ中に &lt;code&gt;CHECKPOINT&lt;/code&gt; コマンドを実行すると、新しいチェックポイントを書き込むのではなく、強制的にリスタートポイント（&lt;a href=&quot;wal-configuration&quot;&gt;セクション29.4を&lt;/a&gt;参照）が作成されます。</target>
        </trans-unit>
        <trans-unit id="61ea49c86b3b55d886450b38a9cc42e4e9c69fce" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database.</source>
          <target state="translated">falseの場合、誰もこのデータベースに接続できません。</target>
        </trans-unit>
        <trans-unit id="67f61dc72a1244f231103433b1246606e94298b4" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. The default is true, allowing connections (except as restricted by other mechanisms, such as &lt;code&gt;GRANT&lt;/code&gt;/&lt;code&gt;REVOKE CONNECT&lt;/code&gt;).</source>
          <target state="translated">falseの場合、誰もこのデータベースに接続できません。デフォルトはtrueで、接続を許可します（ &lt;code&gt;GRANT&lt;/code&gt; / &lt;code&gt;REVOKE CONNECT&lt;/code&gt; などの他のメカニズムによる制限を除く）。</target>
        </trans-unit>
        <trans-unit id="068609549b5f3904794ff7927c8befaac0ac4357" translate="yes" xml:space="preserve">
          <source>If false then no one can connect to this database. This is used to protect the &lt;code&gt;template0&lt;/code&gt; database from being altered.</source>
          <target state="translated">falseの場合、誰もこのデータベースに接続できません。これは、 &lt;code&gt;template0&lt;/code&gt; データベースが変更されないように保護するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5279e693a4509d44588c8398060bdbb7e4662f3c" translate="yes" xml:space="preserve">
          <source>If false, the index is in process of being dropped, and should be ignored for all purposes (including HOT-safety decisions)</source>
          <target state="translated">虚偽の場合、インデックスは落下中であり、あらゆる目的(HOT-安全判断を含む)で無視されるべきである。</target>
        </trans-unit>
        <trans-unit id="024b18cb2d326ba0157f9b09e5a42b7967d00fb4" translate="yes" xml:space="preserve">
          <source>If fewer column aliases are specified than the actual table has columns, the remaining columns are not renamed. This syntax is especially useful for self-joins or subqueries.</source>
          <target state="translated">実際のテーブルに列があるよりも少ない列エイリアスが指定された場合、残りの列は名前が変更されません。この構文は、自己結合やサブクエリの場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="7788a3fcadf6ada52028229d6f513ec9b5a33011" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach eleven million transactions from the wraparound point:</source>
          <target state="translated">何らかの理由でautovacuumがテーブルから古いXIDをクリアできなかった場合、データベースの最も古いXIDがラップアラウンドポイントから1100万トランザクションに達すると、システムはこのような警告メッセージを発し始めます。</target>
        </trans-unit>
        <trans-unit id="8ab96b15ba19344208a4881ae65df7268a6bcc7d" translate="yes" xml:space="preserve">
          <source>If for some reason autovacuum fails to clear old XIDs from a table, the system will begin to emit warning messages like this when the database's oldest XIDs reach ten million transactions from the wraparound point:</source>
          <target state="translated">何らかの理由でautovacuumがテーブルから古いXIDをクリアできなかった場合、データベースの最も古いXIDがラップアラウンドポイントから1,000万トランザクションに達すると、システムはこのような警告メッセージを発し始めます。</target>
        </trans-unit>
        <trans-unit id="80fa6f646b83284df410a911e1de501df6e5b069" translate="yes" xml:space="preserve">
          <source>If forcing index usage does use the index, then there are two possibilities: Either the system is right and using the index is indeed not appropriate, or the cost estimates of the query plans are not reflecting reality. So you should time your query with and without indexes. The &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; command can be useful here.</source>
          <target state="translated">インデックスの使用を強制してもインデックスが使用される場合は、2つの可能性があります。システムが正しく、インデックスの使用が実際に適切でないか、クエリプランのコスト見積もりが現実を反映していないかのいずれかです。したがって、インデックスを使用する場合と使用しない場合のクエリの時間を調整する必要があります。ここでは &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; コマンドが役立ちます。</target>
        </trans-unit>
        <trans-unit id="360561360313d63c949a4bb8b50e6444752b1851" translate="yes" xml:space="preserve">
          <source>If four or six digits and a year has already been read, then interpret as a time (&lt;code&gt;HHMM&lt;/code&gt; or &lt;code&gt;HHMMSS&lt;/code&gt;).</source>
          <target state="translated">4桁または6桁で年がすでに読み取られている場合は、時刻として解釈されます（ &lt;code&gt;HHMM&lt;/code&gt; または &lt;code&gt;HHMMSS&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="42c28f0a9935826074d643ae6e75e6be762517ad" translate="yes" xml:space="preserve">
          <source>If given, createuser will issue a prompt for the password of the new user. This is not necessary if you do not plan on using password authentication.</source>
          <target state="translated">指定された場合、createuser は新しいユーザーのパスワードのプロンプトを発行します。これは、パスワード認証を使用する予定がない場合には必要ありません。</target>
        </trans-unit>
        <trans-unit id="ea4e98adccd9512cd68509c9e2207bdcbb1a1273" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value logged with a non-error statement-logging message is trimmed to this many bytes. Zero disables logging of bind parameters for non-error statement logs. &lt;code&gt;-1&lt;/code&gt; (the default) allows bind parameters to be logged in full. If this value is specified without units, it is taken as bytes. Only superusers can change this setting.</source>
          <target state="translated">ゼロより大きい場合、エラー以外のステートメントロギングメッセージでログに記録された各バインドパラメータ値は、この数バイトにトリミングされます。ゼロは、エラー以外のステートメントログのバインドパラメータのロギングを無効にします。 &lt;code&gt;-1&lt;/code&gt; （デフォルト）を使用すると、バインドパラメータを完全にログインできます。この値が単位なしで指定された場合、バイトとして扱われます。この設定を変更できるのはスーパーユーザーのみです。</target>
        </trans-unit>
        <trans-unit id="38b5cd71938c46f540f5b875d785655ef9301be2" translate="yes" xml:space="preserve">
          <source>If greater than zero, each bind parameter value reported in error messages is trimmed to this many bytes. Zero (the default) disables including bind parameters in error messages. &lt;code&gt;-1&lt;/code&gt; allows bind parameters to be printed in full. If this value is specified without units, it is taken as bytes.</source>
          <target state="translated">ゼロより大きい場合、エラーメッセージで報告される各バインドパラメータ値は、この数バイトにトリミングされます。ゼロ（デフォルト）は、エラーメッセージにバインドパラメータを含めることを無効にします。 &lt;code&gt;-1&lt;/code&gt; を使用すると、バインドパラメータを完全に出力できます。この値が単位なしで指定された場合、バイトとして扱われます。</target>
        </trans-unit>
        <trans-unit id="95adc82bd644fa7ad31393ac2f57ca7d35f902fd" translate="yes" xml:space="preserve">
          <source>If greater than zero, the estimated number of distinct values in the column. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique column in which the number of distinct values is the same as the number of rows.</source>
          <target state="translated">ゼロより大きい場合、列内の個別値の推定数。ゼロ未満の場合、個別の値の数を行数で割った負数。（ &lt;code&gt;ANALYZE&lt;/code&gt; がテーブルの増加に伴って異なる値の数が増える可能性があるとANALYZEが信じる場合、否定形式が使用されます。列が可能な値の固定数を持っていると思われる場合、正の形式が使用されます。）たとえば、-1は、個別の値の数が行の数と同じである一意の列。</target>
        </trans-unit>
        <trans-unit id="b21def7d275563964950f72033030facdc8caa8d" translate="yes" xml:space="preserve">
          <source>If indexing numbers, we can remove some fractional digits to reduce the range of possible numbers, so for example &lt;em&gt;3.14&lt;/em&gt;159265359, &lt;em&gt;3.14&lt;/em&gt;15926, &lt;em&gt;3.14&lt;/em&gt; will be the same after normalization if only two digits are kept after the decimal point.</source>
          <target state="translated">数字のインデックスを作成した場合、我々は可能な数値の範囲を減らすために、いくつかの小数点以下の桁を削除することができますので、例えば&lt;em&gt;3.14&lt;/em&gt; 159265359、&lt;em&gt;3.14&lt;/em&gt; 15926、&lt;em&gt;3.14は&lt;/em&gt; 2桁のみが小数点以下に保持されている場合は、正規化後も同じになります。</target>
        </trans-unit>
        <trans-unit id="76133018bd86f9f10167401dc275f9ef001f11b2" translate="yes" xml:space="preserve">
          <source>If inverse partial newline-sensitive matching is specified, this affects &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; as with newline-sensitive matching, but not &lt;code&gt;.&lt;/code&gt; and bracket expressions. This isn't very useful but is provided for symmetry.</source>
          <target state="translated">部分的に改行を区別する逆マッチングが指定されている場合、これは、改行を区別するマッチングと同様に &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; に影響しますが、には影響しません &lt;code&gt;.&lt;/code&gt; とブラケット式。これはあまり役に立ちませんが、対称性のために提供されています。</target>
        </trans-unit>
        <trans-unit id="dcbd0be8463498dfec58ee2ded857848642b3788" translate="yes" xml:space="preserve">
          <source>If it is necessary to have a comma or whitespace in a RADIUS parameter value, that can be done by putting double quotes around the value, but it is tedious because two layers of double-quoting are now required. An example of putting whitespace into RADIUS secret strings is:</source>
          <target state="translated">RADIUSパラメータの値にカンマや空白が必要な場合は、値の周りに二重引用符を付けることで対応できますが、二重引用符を二重にする必要があるため、面倒です。RADIUSの秘密文字列にホワイトスペースを入れる例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c82c509d031e15398bd7fe00861081d6405c8be4" translate="yes" xml:space="preserve">
          <source>If it turns out that the cost estimates are wrong, there are, again, two possibilities. The total cost is computed from the per-row costs of each plan node times the selectivity estimate of the plan node. The costs estimated for the plan nodes can be adjusted via run-time parameters (described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;). An inaccurate selectivity estimate is due to insufficient statistics. It might be possible to improve this by tuning the statistics-gathering parameters (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">コストの見積もりが間違っていることが判明した場合も、2つの可能性があります。合計コストは、各計画ノードの行ごとのコストに計画ノードの選択性推定を掛けたものから計算されます。計画ノードに見積もられたコストは、実行時パラメータを介して調整できます（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;セクション19.7.2で&lt;/a&gt;説明）。不正確な選択性推定は、統計が不十分なためです。統計収集パラメーターを調整することで、これを改善できる可能性があります（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="18729ccb1c4146c8bab4ae3596759dabf5573ab7" translate="yes" xml:space="preserve">
          <source>If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command &lt;code&gt;locale -a&lt;/code&gt; if your operating system provides it.</source>
          <target state="translated">上記の説明に従ってロケールサポートが機能しない場合は、オペレーティングシステムのロケールサポートが正しく構成されていることを確認してください。システムにインストールされているロケールを確認するには、オペレーティングシステムで提供されている場合は、コマンド &lt;code&gt;locale -a&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="742c773e01d7235a3ab536311ea18ceb446289e6" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">バックアップを作成する場合は、データベースが更新されていないことを確認してください。これはバックアップの整合性には影響しませんが、変更されたデータはもちろん含まれません。必要に応じて、ファイル &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; （または同等のファイル）の権限を編集して、自分以外の全員からのアクセスを禁止します。アクセス制御の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7635b5eb0e6be90090ac67c5260cad61569c3e50" translate="yes" xml:space="preserve">
          <source>If making a backup, make sure that your database is not being updated. This does not affect the integrity of the backup, but the changed data would of course not be included. If necessary, edit the permissions in the file &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; (or equivalent) to disallow access from everyone except you. See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for additional information on access control.</source>
          <target state="translated">バックアップを作成する場合は、データベースが更新されていないことを確認してください。これはバックアップの整合性には影響しませんが、変更されたデータはもちろん含まれません。必要に応じて、ファイル &lt;code&gt;/usr/local/pgsql/data/pg_hba.conf&lt;/code&gt; （または同等のもの）の権限を編集して、自分以外のすべてのユーザーからのアクセスを禁止します。アクセス制御の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c0a6e1d7bfcacfaf25b4fbb67794def2eb6d19f0" translate="yes" xml:space="preserve">
          <source>If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, make sure &lt;code&gt;wal_level&lt;/code&gt; is set to &lt;code&gt;replica&lt;/code&gt; or higher, &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt;, and set up an &lt;code&gt;archive_command&lt;/code&gt; that performs archiving only when a &lt;em&gt;switch file&lt;/em&gt; exists. For example:</source>
          <target state="translated">バックアップファイルをより柔軟にコピーする必要がある場合は、スタンドアロンのホットバックアップにも低レベルのプロセスを使用できます。低レベルのスタンドアロンホットバックアップを準備するには、 &lt;code&gt;wal_level&lt;/code&gt; を &lt;code&gt;replica&lt;/code&gt; 以上に設定し、 &lt;code&gt;archive_mode&lt;/code&gt; を &lt;code&gt;on&lt;/code&gt; に設定し、&lt;em&gt;スイッチファイル&lt;/em&gt;が存在する場合にのみアーカイブを実行する &lt;code&gt;archive_command&lt;/code&gt; を設定し&lt;em&gt;ます&lt;/em&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="b849cfa2234fdad4226b42e149aff052e2ec6ceb" translate="yes" xml:space="preserve">
          <source>If more than one flag bit is specified, the transformations are applied in the order listed.</source>
          <target state="translated">複数のフラグビットが指定された場合、変換はリストされた順に適用されます。</target>
        </trans-unit>
        <trans-unit id="b8368877f8014c70dc2f0a265b592212cfc0ddc8" translate="yes" xml:space="preserve">
          <source>If more than one leaf tuple is supplied, it is expected that the &lt;code&gt;picksplit&lt;/code&gt; function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the &lt;code&gt;picksplit&lt;/code&gt; function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked &lt;code&gt;allTheSame&lt;/code&gt; to signify that this has happened. The &lt;code&gt;choose&lt;/code&gt; and &lt;code&gt;inner_consistent&lt;/code&gt; functions must take suitable care with such inner tuples. See &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt; for more information.</source>
          <target state="translated">複数の &lt;code&gt;picksplit&lt;/code&gt; が指定されている場合、picksplit関数がそれらを複数のノードに分類すると予想されます。それ以外の場合、リーフタプルを複数のページに分割することはできません。これがこの操作の最終的な目的です。したがって、 &lt;code&gt;picksplit&lt;/code&gt; 関数がすべてのリーフタプルを同じノードに配置することになる場合、コアのSP-GiSTコードはその決定をオーバーライドし、リーフタプルが同じラベルの付いた複数のノードにランダムに割り当てられる内部タプルを生成します。このようなタプルには &lt;code&gt;allTheSame&lt;/code&gt; のマークが付けられ、これが発生したことを示します。 &lt;code&gt;choose&lt;/code&gt; と &lt;code&gt;inner_consistent&lt;/code&gt; 機能は、このような内部タプルで、適切な世話をする必要があります。&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;セクション65.4.3を&lt;/a&gt;参照 詳細については。</target>
        </trans-unit>
        <trans-unit id="e1854b837fa3254f90682ac28255cbd702178269" translate="yes" xml:space="preserve">
          <source>If more than one option is given, the information is printed in that order, one item per line. If no options are given, all available information is printed, with labels.</source>
          <target state="translated">複数のオプションが与えられた場合、情報はその順番で印刷され、1 行に 1 つの項目が表示されます。オプションが与えられていない場合は、利用可能なすべての情報がラベル付きで印刷されます。</target>
        </trans-unit>
        <trans-unit id="f1a02345ba89ad66d10fbdabf34539cb6dd7d98c" translate="yes" xml:space="preserve">
          <source>If more than one table has a column of the same name, the table name must also be given, as in:</source>
          <target state="translated">のように、複数のテーブルに同じ名前のカラムがある場合は、テーブル名も指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="dd5e9dbc9005fdf88d98048279bb5e957015fc29" translate="yes" xml:space="preserve">
          <source>If multiple CPUs are available in the database server, consider using pg_restore's &lt;code&gt;--jobs&lt;/code&gt; option. This allows concurrent data loading and index creation.</source>
          <target state="translated">データベースサーバーで複数のCPUが使用可能な場合は、pg_restoreの &lt;code&gt;--jobs&lt;/code&gt; オプションの使用を検討してください。これにより、データのロードとインデックスの同時作成が可能になります。</target>
        </trans-unit>
        <trans-unit id="87fac9519c05562bef87a4e35aa2a859278b1c40" translate="yes" xml:space="preserve">
          <source>If multiple grouping items are specified in a single &lt;code&gt;GROUP BY&lt;/code&gt; clause, then the final list of grouping sets is the cross product of the individual items. For example:</source>
          <target state="translated">1つの &lt;code&gt;GROUP BY&lt;/code&gt; 句で複数のグループ化項目が指定されている場合、グループ化セットの最終的なリストは、個々の項目の外積です。例えば：</target>
        </trans-unit>
        <trans-unit id="b80b5e3c45aa43e720ac77a6f9a3ef8d195c588d" translate="yes" xml:space="preserve">
          <source>If multiple savepoints have the same name, only the one that was most recently defined is released.</source>
          <target state="translated">複数のセーブポイントが同じ名前を持つ場合、最近定義されたものだけがリリースされます。</target>
        </trans-unit>
        <trans-unit id="9bb7ddb9b949ac875aa47f26b30ade97f88eab22" translate="yes" xml:space="preserve">
          <source>If multiple script files are specified, the averages are reported separately for each script file.</source>
          <target state="translated">複数のスクリプトファイルが指定された場合は、各スクリプトファイルごとに平均値が報告されます。</target>
        </trans-unit>
        <trans-unit id="e33be9af0afb6da142699266371977c598700dcd" translate="yes" xml:space="preserve">
          <source>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</source>
          <target state="translated">同じイベントに対して同じ種類の複数のトリガーが定義されている場合は、名前のアルファベット順で発行されます。</target>
        </trans-unit>
        <trans-unit id="65a4d92a17b0442c58eb3e977048325cf5830355" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;ALSO&lt;/code&gt; nor &lt;code&gt;INSTEAD&lt;/code&gt; is specified, &lt;code&gt;ALSO&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; も &lt;code&gt;INSTEAD&lt;/code&gt; も指定されていない場合、 &lt;code&gt;ALSO&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="7e603a3b3a3e88af33582419d67e19ea60ef676f" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR SEARCH&lt;/code&gt; nor &lt;code&gt;FOR ORDER BY&lt;/code&gt; is specified, &lt;code&gt;FOR SEARCH&lt;/code&gt; is the default.</source>
          <target state="translated">&lt;code&gt;FOR SEARCH&lt;/code&gt; も &lt;code&gt;FOR ORDER BY&lt;/code&gt; も指定されていない場合、 &lt;code&gt;FOR SEARCH&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="5e9aa69e6e2804ffb3ebc122107e995dd5c9a00a" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;FOR TABLE&lt;/code&gt; nor &lt;code&gt;FOR ALL TABLES&lt;/code&gt; is specified, then the publication starts out with an empty set of tables. That is useful if tables are to be added later.</source>
          <target state="translated">&lt;code&gt;FOR TABLE&lt;/code&gt; も &lt;code&gt;FOR ALL TABLES&lt;/code&gt; も指定されていない場合、パブリケーションは空のテーブルセットで開始されます。これは、テーブルを後で追加する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="89d1b1553626d39b44b8a8db61a149cf8fdc3227" translate="yes" xml:space="preserve">
          <source>If newline-sensitive matching is specified, &lt;code&gt;.&lt;/code&gt; and bracket expressions using &lt;code&gt;^&lt;/code&gt; will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; continue to match beginning or end of string &lt;em&gt;only&lt;/em&gt;.</source>
          <target state="translated">改行を区別するマッチが指定されている場合は、 &lt;code&gt;.&lt;/code&gt; および &lt;code&gt;^&lt;/code&gt; を使用したブラケット式は、改行文字と一致しません（したがって、REが明示的に配置しない限り、一致は改行と交差しません）。また、 &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; は、開始と終了での一致に加えて、改行の前後の空の文字列とそれぞれ一致します。それぞれ文字列の。ただし、AREエスケープ &lt;code&gt;\A&lt;/code&gt; および &lt;code&gt;\Z&lt;/code&gt; は、文字列の先頭または末尾&lt;em&gt;のみ&lt;/em&gt;に一致し続けます。</target>
        </trans-unit>
        <trans-unit id="eec0fa542613e1975aae2a48b92903dde3eacbb8" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;table_alias&lt;/code&gt; is specified, the function name is used as the table name; in the case of a &lt;code&gt;ROWS FROM()&lt;/code&gt; construct, the first function's name is used.</source>
          <target state="translated">&lt;code&gt;table_alias&lt;/code&gt; が指定されていない場合、関数名がテーブル名として使用されます。以下の場合には &lt;code&gt;ROWS FROM()&lt;/code&gt; 構築、最初の関数の名前が使用されます。</target>
        </trans-unit>
        <trans-unit id="5c82c2225e73852e8c357908e66b1d12e66520ab" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;weights&lt;/code&gt; are provided, then these defaults are used:</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; が指定されていない場合は、次のデフォルトが使用されます。</target>
        </trans-unit>
        <trans-unit id="0368275c8128ea23b2ee02837095ef288617003c" translate="yes" xml:space="preserve">
          <source>If no collation is explicitly specified, the database system either derives a collation from the columns involved in the expression, or it defaults to the default collation of the database if no column is involved in the expression.</source>
          <target state="translated">照合順序が明示的に指定されていない場合、データベースシステムは式に含まれる列から照合順序を導出するか、式に列が含まれていない場合はデータベースのデフォルトの照合順序をデフォルトにします。</target>
        </trans-unit>
        <trans-unit id="21307971878d081789f53c6ec3a32e0fa2a71500" translate="yes" xml:space="preserve">
          <source>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data.</source>
          <target state="translated">デフォルト値が明示的に宣言されていない場合、デフォルト値はNULL値となります。これは通常、NULL値が未知のデータを表すと考えられるため、意味のあることです。</target>
        </trans-unit>
        <trans-unit id="e6bbf77c4f367e9f49f3db1ca226b2a952882830" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">完全に一致するものが見つからない場合は、関数呼び出しが特殊な型変換要求であるように見えるかどうかを確認してください。これは、関数呼び出しに引数が1つだけあり、関数名が一部のデータ型の（内部）名前と同じである場合に発生します。さらに、関数引数は、不明な型のリテラル、名前付きデータ型にバイナリ強制可能な型、またはその型のI / O関数を適用することで名前付きデータ型に変換できる型（つまり、変換は、標準の文字列型の1つとの間で行われます）。これらの条件が満たされると、関数呼び出しは &lt;code&gt;CAST&lt;/code&gt; 仕様の形式として扱われます。&lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35149dcf4bfae750a59efc48da69e479e9799355" translate="yes" xml:space="preserve">
          <source>If no exact match is found, see if the function call appears to be a special type conversion request. This happens if the function call has just one argument and the function name is the same as the (internal) name of some data type. Furthermore, the function argument must be either an unknown-type literal, or a type that is binary-coercible to the named data type, or a type that could be converted to the named data type by applying that type's I/O functions (that is, the conversion is either to or from one of the standard string types). When these conditions are met, the function call is treated as a form of &lt;code&gt;CAST&lt;/code&gt; specification. &lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">完全に一致するものが見つからない場合は、関数呼び出しが特別な型変換要求であるかどうかを確認してください。これは、関数呼び出しの引数が1つだけで、関数名が一部のデータ型の（内部）名と同じである場合に発生します。さらに、関数の引数は、不明な型のリテラル、または名前付きデータ型にバイナリ強制変換できる型、またはその型のI / O関数を適用して名前付きデータ型に変換できる型（つまり、変換は、標準の文字列タイプの1つとの間で行われます。これらの条件が満たされると、関数呼び出しは &lt;code&gt;CAST&lt;/code&gt; 指定の形式として扱われます。&lt;a href=&quot;#ftn.id-1.5.9.8.4.4.1.2&quot;&gt;&lt;sup id=&quot;id-1.5.9.8.4.4.1.2&quot;&gt;[11]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b5e5aff6e0171effd161da742f968f9068eee6" translate="yes" xml:space="preserve">
          <source>If no explicit provision is made for a sign in &lt;code&gt;to_char()&lt;/code&gt;'s pattern, one column will be reserved for the sign, and it will be anchored to (appear just left of) the number. If &lt;code&gt;S&lt;/code&gt; appears just left of some &lt;code&gt;9&lt;/code&gt;'s, it will likewise be anchored to the number.</source>
          <target state="translated">&lt;code&gt;to_char()&lt;/code&gt; のパターンでサインに対して明示的な準備が行われていない場合、1つの列がサイン用に予約され、番号に固定されます（すぐ左に表示されます）。場合 &lt;code&gt;S&lt;/code&gt; は、単にいくつかの左に表示された &lt;code&gt;9&lt;/code&gt; さん、それは同様に、数に固定されます。</target>
        </trans-unit>
        <trans-unit id="6e409b417f72efc6d96ed16a0afc9bdc881a346a" translate="yes" xml:space="preserve">
          <source>If no function is specified, a blank &lt;code&gt;CREATE FUNCTION&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">関数が指定されていない場合、空白の &lt;code&gt;CREATE FUNCTION&lt;/code&gt; テンプレートが編集用に表示されます。</target>
        </trans-unit>
        <trans-unit id="bfdbba53034a54f85542008e5a3f670d8b001aa1" translate="yes" xml:space="preserve">
          <source>If no lock mode is specified, then &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt;, the most restrictive mode, is used.</source>
          <target state="translated">ロックモードが指定されていない場合は、最も制限的なモードである &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="e62fb9f6836054022a0013bdbc9afb997f69a82f" translate="yes" xml:space="preserve">
          <source>If no moving-aggregate implementation is supplied, the aggregate can still be used with moving frames, but PostgreSQL will recompute the whole aggregation whenever the start of the frame moves. Note that whether or not the aggregate supports moving-aggregate mode, PostgreSQL can handle a moving frame end without recalculation; this is done by continuing to add new values to the aggregate's state. This is why use of an aggregate as a window function requires that the final function be read-only: it must not damage the aggregate's state value, so that the aggregation can be continued even after an aggregate result value has been obtained for one set of frame boundaries.</source>
          <target state="translated">移動集約の実装が提供されていない場合、移動するフレームでも集約を使用することができますが、フレームの開始点が移動するたびにPostgreSQLは集約全体を再計算します。集約体が移動集約モードをサポートしているかどうかに関わらず、PostgreSQLは再計算を行わずに移動フレームの終了を扱うことができることに注意してください。これは、集合体の状態に新しい値を追加し続けることによって行われます。これが、集合体をウィンドウ関数として使用する場合、最終関数が読み取り専用であることを要求する理由です。</target>
        </trans-unit>
        <trans-unit id="f9d74d492594986bfbf1fc1386e105965c9b3fc3" translate="yes" xml:space="preserve">
          <source>If no output column name is specified using &lt;code&gt;AS&lt;/code&gt;, the system assigns a default column name. For simple column references, this is the name of the referenced column. For function calls, this is the name of the function. For complex expressions, the system will generate a generic name.</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; を使用して出力列名が指定されていない場合、システムはデフォルトの列名を割り当てます。単純な列参照の場合、これは参照される列の名前です。関数呼び出しの場合、これは関数の名前です。複雑な式の場合、システムは総称名を生成します。</target>
        </trans-unit>
        <trans-unit id="46eb45e8cda4a2fa8f3f15869002e910f361619b" translate="yes" xml:space="preserve">
          <source>If no role is specified, or the special user name &lt;code&gt;PUBLIC&lt;/code&gt; is used, then the policy applies to all users on the system. To allow all users to access only their own row in a &lt;code&gt;users&lt;/code&gt; table, a simple policy can be used:</source>
          <target state="translated">ロールが指定されていない場合、または特別なユーザー名 &lt;code&gt;PUBLIC&lt;/code&gt; が使用されている場合、ポリシーはシステム上のすべてのユーザーに適用されます。すべてのユーザーが &lt;code&gt;users&lt;/code&gt; テーブルの自分の行のみにアクセスできるようにするには、次の簡単なポリシーを使用できます。</target>
        </trans-unit>
        <trans-unit id="6d6b57e5927a5bed9026e109eaaf60a10bd5032f" translate="yes" xml:space="preserve">
          <source>If no synchronous standby names are specified here, then synchronous replication is not enabled and transaction commits will not wait for replication. This is the default configuration. Even when synchronous replication is enabled, individual transactions can be configured not to wait for replication by setting the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; parameter to &lt;code&gt;local&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">ここで同期スタンバイ名が指定されていない場合、同期レプリケーションは有効にならず、トランザクションコミットはレプリケーションを待機しません。これがデフォルトの設定です。同期レプリケーションが有効な場合でも、&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronized_commit&lt;/a&gt;パラメータを &lt;code&gt;local&lt;/code&gt; または &lt;code&gt;off&lt;/code&gt; に設定することで、個々のトランザクションがレプリケーションを待機しないように構成できます。</target>
        </trans-unit>
        <trans-unit id="b499f250be4863620a8af2772b67aa546566a3ec" translate="yes" xml:space="preserve">
          <source>If no table name is available, that is, when mapping a query or a cursor, the string &lt;code&gt;table&lt;/code&gt; is used in the first format, &lt;code&gt;row&lt;/code&gt; in the second format.</source>
          <target state="translated">使用可能なテーブル名がない場合、つまりクエリまたはカーソルをマッピングする場合、文字列 &lt;code&gt;table&lt;/code&gt; は最初の形式で使用され、 &lt;code&gt;row&lt;/code&gt; は2番目の形式で使用されます。</target>
        </trans-unit>
        <trans-unit id="31cbf099df48b49708d8e3fe1c5398bc9eb2b4ff" translate="yes" xml:space="preserve">
          <source>If no tuples were deleted from the heap, B-tree indexes are still scanned at the &lt;code&gt;VACUUM&lt;/code&gt; cleanup stage when at least one of the following conditions is met: the index statistics are stale, or the index contains deleted pages that can be recycled during cleanup. Index statistics are considered to be stale if the number of newly inserted tuples exceeds the &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; fraction of the total number of heap tuples detected by the previous statistics collection. The total number of heap tuples is stored in the index meta-page. Note that the meta-page does not include this data until &lt;code&gt;VACUUM&lt;/code&gt; finds no dead tuples, so B-tree index scan at the cleanup stage can only be skipped if the second and subsequent &lt;code&gt;VACUUM&lt;/code&gt; cycles detect no dead tuples.</source>
          <target state="translated">ヒープからタプルが削除されなかった場合でも、次の条件の少なくとも1つが満たされると、 &lt;code&gt;VACUUM&lt;/code&gt; クリーンアップ段階でBツリーインデックスがスキャンされます。 。新しく挿入されたタプルの数が、前の統計コレクションによって検出された &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; の総数のvacuum_cleanup_index_scale_factorの割合を超える場合、インデックス統計は古くなったと見なされます。ヒープタプルの総数は、インデックスメタページに格納されます。 &lt;code&gt;VACUUM&lt;/code&gt; が無効なタプルを検出しない限り、メタページにはこのデータが含まれないことに注意してください。そのため、クリーンアップ段階でのBツリーインデックススキャンは、2番目以降の &lt;code&gt;VACUUM&lt;/code&gt; の場合にのみスキップできます。 サイクルはデッドタプルを検出しません。</target>
        </trans-unit>
        <trans-unit id="a50a96a1efd9e9515cc7402b6a1585dcf6707637" translate="yes" xml:space="preserve">
          <source>If no view is specified, a blank &lt;code&gt;CREATE VIEW&lt;/code&gt; template is presented for editing.</source>
          <target state="translated">ビューが指定されていない場合、空白の &lt;code&gt;CREATE VIEW&lt;/code&gt; テンプレートが編集用に表示されます。</target>
        </trans-unit>
        <trans-unit id="b168c695895a81115afb54900077dcd6394dd9a3" translate="yes" xml:space="preserve">
          <source>If not found, search an internal table to match the token as either a special string (e.g., &lt;code&gt;today&lt;/code&gt;), day (e.g., &lt;code&gt;Thursday&lt;/code&gt;), month (e.g., &lt;code&gt;January&lt;/code&gt;), or noise word (e.g., &lt;code&gt;at&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;).</source>
          <target state="translated">見つからない場合は、内部テーブルを検索して、トークンを特別な文字列（例： &lt;code&gt;today&lt;/code&gt; ）、日（例： &lt;code&gt;Thursday&lt;/code&gt; ）、月（例： &lt;code&gt;January&lt;/code&gt; ）、またはノイズワード（例： &lt;code&gt;at&lt;/code&gt; 、 &lt;code&gt;on&lt;/code&gt; ）として照合します。</target>
        </trans-unit>
        <trans-unit id="dc5b189453f6a7ea6efcd19711a7a024dd08877c" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this entry could not be applied</source>
          <target state="translated">nullでない場合は、このエントリが適用できなかった理由を示すエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="8da51845e78e415599c49039ce6e56d900436b63" translate="yes" xml:space="preserve">
          <source>If not null, an error message indicating why this line could not be processed</source>
          <target state="translated">null でない場合は、この行が処理できなかった理由を示すエラーメッセージ。</target>
        </trans-unit>
        <trans-unit id="96520540e7decec105d922c1561ef9f2b1d6ac9b" translate="yes" xml:space="preserve">
          <source>If on, any error will terminate the current session. By default, this is set to off, so that only FATAL errors will terminate the session.</source>
          <target state="translated">オンの場合、エラーがあれば現在のセッションを終了します。デフォルトでは、これはオフに設定されており、FATALエラーのみがセッションを終了するようになっています。</target>
        </trans-unit>
        <trans-unit id="22cc3fdc7c909051830d32f3a9f4757f2bc2a2b3" translate="yes" xml:space="preserve">
          <source>If on, emit WAL-related debugging output. This parameter is only available if the &lt;code&gt;WAL_DEBUG&lt;/code&gt; macro was defined when PostgreSQL was compiled.</source>
          <target state="translated">オンの場合、WAL関連のデバッグ出力を発行します。このパラメーターは、PostgreSQLのコンパイル時に &lt;code&gt;WAL_DEBUG&lt;/code&gt; マクロが定義されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="ea0ac9e4d18cd146b0646e9f1eaaad11f3441b88" translate="yes" xml:space="preserve">
          <source>If on, emit information about lightweight lock usage. Lightweight locks are intended primarily to provide mutual exclusion of access to shared-memory data structures.</source>
          <target state="translated">オンの場合、軽量ロックの使用に関する情報を送信します。軽量ロックは、主に共有メモリデータ構造へのアクセスを相互に排除することを目的としています。</target>
        </trans-unit>
        <trans-unit id="108192b0a0e55fbd6c757081d9b7601d8b8f83e2" translate="yes" xml:space="preserve">
          <source>If on, emit information about lock usage. Information dumped includes the type of lock operation, the type of lock and the unique identifier of the object being locked or unlocked. Also included are bit masks for the lock types already granted on this object as well as for the lock types awaited on this object. For each lock type a count of the number of granted locks and waiting locks is also dumped as well as the totals. An example of the log file output is shown here:</source>
          <target state="translated">オンの場合、ロックの使用状況に関する情報を出力します。ダンプされる情報には、ロック操作のタイプ、ロックのタイプ、ロックまたはアンロックされているオブジェクトの一意の識別子が含まれます。また、このオブジェクトに既に付与されているロック・タイプと、このオブジェクトに待ち受けているロック・タイプのビット・マスクも含まれます。各ロック・タイプについて、付与されたロックと待機中のロックの数のカウントと合計がダンプされます。ログファイルの出力例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="fb4d7f85e50d03eb97a6b576612fc80288cfa67e" translate="yes" xml:space="preserve">
          <source>If on, emit information about resource usage during sort operations. This parameter is only available if the &lt;code&gt;TRACE_SORT&lt;/code&gt; macro was defined when PostgreSQL was compiled. (However, &lt;code&gt;TRACE_SORT&lt;/code&gt; is currently defined by default.)</source>
          <target state="translated">オンの場合、ソート操作中にリソースの使用状況に関する情報を出力します。このパラメーターは、PostgreSQLのコンパイル時に &lt;code&gt;TRACE_SORT&lt;/code&gt; マクロが定義されている場合にのみ使用できます。（ただし、現在デフォルトでは &lt;code&gt;TRACE_SORT&lt;/code&gt; が定義されています。）</target>
        </trans-unit>
        <trans-unit id="2d6e32677420949906412ec403c3421f5aa432cd" translate="yes" xml:space="preserve">
          <source>If on, emit information about user lock usage. Output is the same as for &lt;code&gt;trace_locks&lt;/code&gt;, only for advisory locks.</source>
          <target state="translated">オンの場合、ユーザーロックの使用に関する情報を出力します。出力は &lt;code&gt;trace_locks&lt;/code&gt; の場合と同じですが、アドバイザリロックの場合のみです。</target>
        </trans-unit>
        <trans-unit id="4f521f40c917171fc7c2808f83dd0cac811f61dc" translate="yes" xml:space="preserve">
          <source>If one PostgreSQL server cluster is planned to contain unrelated projects or users that should be, for the most part, unaware of each other, it is recommended to put them into separate databases and adjust authorizations and access controls accordingly. If the projects or users are interrelated, and thus should be able to use each other's resources, they should be put in the same database but probably into separate schemas; this provides a modular structure with namespace isolation and authorization control. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">1つのPostgreSQLサーバークラスターに無関係のプロジェクトまたはユーザーが含まれるように計画されている場合、ほとんどの場合、それらを別々のデータベースに配置し、それに応じて承認とアクセス制御を調整することをお勧めします。プロジェクトまたはユーザーが相互に関連しているため、相互のリソースを使用できる必要がある場合は、同じデータベースに配置する必要がありますが、おそらく別々のスキーマに配置する必要があります。これにより、名前空間の分離と承認制御を備えたモジュラー構造が提供されます。スキーマの管理の詳細については、&lt;a href=&quot;ddl-schemas&quot;&gt;セクション5.9を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa31b9c1a7b9373a56b5ac2143c494c8a9df5d88" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type and the other is of a domain type, next check to see if there is an operator accepting exactly the domain's base type on both sides; if so, use it.</source>
          <target state="translated">2項演算子呼び出しの1つの引数が &lt;code&gt;unknown&lt;/code&gt; 型で、もう1つの引数がドメイン型である場合は、次に、両側でドメインの基本型を正確に受け入れる演算子があるかどうかを確認します。もしそうなら、それを使用してください。</target>
        </trans-unit>
        <trans-unit id="f194f32ef831d4b3157a47fd2652de25dffaf886" translate="yes" xml:space="preserve">
          <source>If one argument of a binary operator invocation is of the &lt;code&gt;unknown&lt;/code&gt; type, then assume it is the same type as the other argument for this check. Invocations involving two &lt;code&gt;unknown&lt;/code&gt; inputs, or a unary operator with an &lt;code&gt;unknown&lt;/code&gt; input, will never find a match at this step.</source>
          <target state="translated">2項演算子呼び出しの1つの引数が &lt;code&gt;unknown&lt;/code&gt; タイプである場合、このチェックのもう1つの引数と同じタイプであると想定します。2つの関わる呼び出し &lt;code&gt;unknown&lt;/code&gt; 入力、またはと単項演算子 &lt;code&gt;unknown&lt;/code&gt; 入力は、この段階で一致するものを見つけることはありません。</target>
        </trans-unit>
        <trans-unit id="b3677d43219ced3f6fdb380478ec70536347404f" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a bit-string value to &lt;code&gt;bit(n)&lt;/code&gt;, it will be truncated or zero-padded on the right to be exactly &lt;code&gt;n&lt;/code&gt; bits, without raising an error. Similarly, if one explicitly casts a bit-string value to &lt;code&gt;bit varying(n)&lt;/code&gt;, it will be truncated on the right if it is more than &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="translated">ビット文字列の値を明示的に &lt;code&gt;bit(n)&lt;/code&gt; にキャストすると、エラーが発生することなく、右側が切り捨てられるか、右側にゼロが埋め込まれ、正確に &lt;code&gt;n&lt;/code&gt; ビットになります。同様に、ビット文字列の値を明示的に &lt;code&gt;bit varying(n)&lt;/code&gt; にキャストした場合、 &lt;code&gt;n&lt;/code&gt; ビットを超えると、右側が切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="7d503789d22d34918cc5945f90261d6c003a05f3" translate="yes" xml:space="preserve">
          <source>If one explicitly casts a value to &lt;code&gt;character varying(n)&lt;/code&gt; or &lt;code&gt;character(n)&lt;/code&gt;, then an over-length value will be truncated to &lt;code&gt;n&lt;/code&gt; characters without raising an error. (This too is required by the SQL standard.)</source>
          <target state="translated">値を明示的に &lt;code&gt;character varying(n)&lt;/code&gt; または &lt;code&gt;character(n)&lt;/code&gt; にキャストすると、長すぎる値はエラーを発生させずに &lt;code&gt;n&lt;/code&gt; 文字に切り捨てられます。（これもSQL標準では必須です。）</target>
        </trans-unit>
        <trans-unit id="1de7610e41ebab1a246a8c49a8f76058b712b92e" translate="yes" xml:space="preserve">
          <source>If one of the list items is the special name &lt;code&gt;$user&lt;/code&gt;, then the schema having the name returned by &lt;code&gt;CURRENT_USER&lt;/code&gt; is substituted, if there is such a schema and the user has &lt;code&gt;USAGE&lt;/code&gt; permission for it. (If not, &lt;code&gt;$user&lt;/code&gt; is ignored.)</source>
          <target state="translated">リストアイテムの1つが特別な名前 &lt;code&gt;$user&lt;/code&gt; である場合、そのようなスキーマがあり、ユーザーがそのスキーマの &lt;code&gt;USAGE&lt;/code&gt; 権限を持っている場合は、 &lt;code&gt;CURRENT_USER&lt;/code&gt; から返された名前を持つスキーマに置き換えられます。（そうでない場合、 &lt;code&gt;$user&lt;/code&gt; は無視されます。）</target>
        </trans-unit>
        <trans-unit id="19441d8efa255c5a903fe7f3e4cb160f4e49f55a" translate="yes" xml:space="preserve">
          <source>If only the parser is specified, then the new text search configuration initially has no mappings from token types to dictionaries, and therefore will ignore all words. Subsequent &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; commands must be used to create mappings to make the configuration useful. Alternatively, an existing text search configuration can be copied.</source>
          <target state="translated">パーサーのみが指定されている場合、新しいテキスト検索構成には、最初はトークンタイプから辞書へのマッピングがないため、すべての単語が無視されます。後続の &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; コマンドを使用してマッピングを作成し、構成を有効にする必要があります。または、既存のテキスト検索構成をコピーすることもできます。</target>
        </trans-unit>
        <trans-unit id="f8ecaaa3f305e080c140c9a79731fd19853d9256" translate="yes" xml:space="preserve">
          <source>If parentheses appear after &lt;code&gt;\g&lt;/code&gt;, they surround a space-separated list of &lt;code&gt;option&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; formatting-option clauses, which are interpreted in the same way as &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; commands, but take effect only for the duration of this query. In this list, spaces are not allowed around &lt;code&gt;=&lt;/code&gt; signs, but are required between option clauses. If &lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; is omitted, the named &lt;code&gt;option&lt;/code&gt; is changed in the same way as for &lt;code&gt;\pset&lt;/code&gt;&lt;code&gt;option&lt;/code&gt; with no explicit &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">括弧が &lt;code&gt;\g&lt;/code&gt; 後に表示される場合、括弧は &lt;code&gt;option&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; formating-option句のスペースで区切られたリストを囲みます。これは、 &lt;code&gt;\pset&lt;/code&gt; &lt;code&gt;option&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; コマンドと同じ方法で解釈されますが、このクエリの期間中のみ有効になります。このリストでは、 &lt;code&gt;=&lt;/code&gt; 記号の前後にスペースは使用できませんが、オプション句の間にスペースが必要です。場合 &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 省略されている、という名前の &lt;code&gt;option&lt;/code&gt; の場合と同じ方法で変更された &lt;code&gt;\pset&lt;/code&gt; &lt;code&gt;option&lt;/code&gt; 明示的なと &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1317b8ae94e1b0f60e57dbb20e11b92a9f8c5a7" translate="yes" xml:space="preserve">
          <source>If partial newline-sensitive matching is specified, this affects &lt;code&gt;.&lt;/code&gt; and bracket expressions as with newline-sensitive matching, but not &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">部分的に改行を区別するマッチングが指定されている場合、これはに影響し &lt;code&gt;.&lt;/code&gt; 括弧式は、改行を区別するマッチングと同様に使用できますが、 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;$&lt;/code&gt; は使用できません。</target>
        </trans-unit>
        <trans-unit id="5535f2a09b6cea90f6f2421f76ccf57b35834ee5" translate="yes" xml:space="preserve">
          <source>If pg_checksums is aborted or killed while enabling or disabling checksums, the cluster's data checksum configuration remains unchanged, and pg_checksums can be re-run to perform the same operation.</source>
          <target state="translated">チェックサムを有効または無効にしている間にpg_checksumsが中止または終了した場合、クラスタのデータチェックサム設定は変更されず、同じ操作を実行するためにpg_checksumsを再実行することができます。</target>
        </trans-unit>
        <trans-unit id="329ffa5a3154cd15ee165233a8d448dbe8dc1875" translate="yes" xml:space="preserve">
          <source>If pg_rewind fails while processing, then the data folder of the target is likely not in a state that can be recovered. In such a case, taking a new fresh backup is recommended.</source>
          <target state="translated">処理中にpg_rewindが失敗した場合、ターゲットのデータフォルダは復旧できる状態ではない可能性が高いです。このような場合は、新たに新しいバックアップを取ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="928868bbd3ab201faf3713aebe691a864c3216eb" translate="yes" xml:space="preserve">
          <source>If present, the operator class will become the default operator class for its data type. At most one operator class can be the default for a specific data type and index method.</source>
          <target state="translated">演算子クラスが存在する場合、その演算子クラスはそのデータ型のデフォルトの演算子クラスになります。特定のデータ型とインデックスメソッドのデフォルトは、最大で1つの演算子クラスになります。</target>
        </trans-unit>
        <trans-unit id="dce8d13840c91deea2eabbef36d881ff8d4820b8" translate="yes" xml:space="preserve">
          <source>If primary restarts while commits are waiting for acknowledgment, those waiting transactions will be marked fully committed once the primary database recovers. There is no way to be certain that all standbys have received all outstanding WAL data at time of the crash of the primary. Some transactions may not show as committed on the standby, even though they show as committed on the primary. The guarantee we offer is that the application will not receive explicit acknowledgment of the successful commit of a transaction until the WAL data is known to be safely received by all the synchronous standbys.</source>
          <target state="translated">コミットの確認待ち中にプライマリが再起動した場合、プライマリデータベースが回復すると、その待ち受けていたトランザクションは完全にコミットされたものとしてマークされます。プライマリがクラッシュした時点で、すべてのスタンバイがすべての未処理の WAL データを受信していることを保証する方法はありません。トランザクションによっては、プライマリ上ではコミットされていると表示されていても、スタンバイ上ではコミットされていると表示されない場合があります。我々が提供する保証は、WAL データがすべての同期スタンバイによって安全に受信されることが判明するまで、アプリケーションがトランザクションのコミットが成功したことを明示的に確認することはありません。</target>
        </trans-unit>
        <trans-unit id="cabf4b566b843e529d70b87d853fee3f06c7f4bf" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e. data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">クエリが単に変更されずにブロードキャストされる場合、 &lt;code&gt;random()&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; などの関数、およびシーケンスは、サーバーごとに異なる値を持つことができます。これは、各サーバーが独立して動作し、SQLクエリがブロードキャストされるためです（実際に変更された行ではありません）。これが受け入れられない場合、ミドルウェアまたはアプリケーションは、単一のサーバーからそのような値を照会し、それらの値を書き込み照会で使用する必要があります。別のオプションは、従来のマスタースタンバイセットアップでこのレプリケーションオプションを使用することです。つまり、データ変更クエリはマスターにのみ送信され、レプリケーションミドルウェアではなくマスタースタンバイレプリケーションを介してスタンバイサーバーに伝達されます。また、おそらく2フェーズコミット（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;および&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;を使用）を使用して、すべてのトランザクションがすべてのサーバーでコミットまたはアボートするように注意する必要があります。）。Pgpool-IIとContinuent Tungstenは、このタイプのレプリケーションの例です。</target>
        </trans-unit>
        <trans-unit id="493b00be39141f1a1aeb09adbc6c889957fa4153" translate="yes" xml:space="preserve">
          <source>If queries are simply broadcast unmodified, functions like &lt;code&gt;random()&lt;/code&gt;, &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;, and sequences can have different values on different servers. This is because each server operates independently, and because SQL queries are broadcast (and not actual modified rows). If this is unacceptable, either the middleware or the application must query such values from a single server and then use those values in write queries. Another option is to use this replication option with a traditional master-standby setup, i.e., data modification queries are sent only to the master and are propagated to the standby servers via master-standby replication, not by the replication middleware. Care must also be taken that all transactions either commit or abort on all servers, perhaps using two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;). Pgpool-II and Continuent Tungsten are examples of this type of replication.</source>
          <target state="translated">クエリが変更されずに単にブロードキャストされる場合、 &lt;code&gt;random()&lt;/code&gt; 、 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; などの関数、およびシーケンスは、サーバーごとに異なる値を持つことができます。これは、各サーバーが独立して動作し、SQLクエリがブロードキャストされるためです（実際に変更された行ではありません）。これが受け入れられない場合、ミドルウェアまたはアプリケーションのいずれかが単一のサーバーからそのような値を照会し、それらの値を書き込み照会で使用する必要があります。もう1つのオプションは、このレプリケーションオプションを従来のマスタースタンバイセットアップで使用することです。つまり、データ変更クエリはマスターにのみ送信され、レプリケーションミドルウェアではなくマスタースタンバイレプリケーションを介してスタンバイサーバーに伝播されます。また、おそらく2フェーズコミット（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARETRANSACTION&lt;/a&gt;と&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMITPREPARED）&lt;/a&gt;を使用して、すべてのトランザクションがすべてのサーバーでコミットまたは中止されるように注意する必要があります。）。Pgpool-IIとContinuentTungstenは、このタイプのレプリケーションの例です。</target>
        </trans-unit>
        <trans-unit id="f63cea3b2db7baf929d271a8512ae9d2283784c6" translate="yes" xml:space="preserve">
          <source>If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a &amp;ldquo;recovery target&amp;rdquo; before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again.</source>
          <target state="translated">リカバリーにより破損したWALデータが検出されると、リカバリーはその時点で停止し、サーバーは始動しません。このような場合、回復プロセスを最初から再実行し、破損ポイントの前に「回復ターゲット」を指定して、回復が正常に完了するようにすることができます。システムクラッシュなどの外部的な理由でリカバリが失敗した場合、またはWALアーカイブにアクセスできなくなった場合は、リカバリを再起動するだけで、ほぼどこからでも再起動できます。リカバリの再起動は、通常の操作でのチェックポイントのように機能します。サーバーは定期的にすべての状態をディスクに &lt;code&gt;pg_control&lt;/code&gt; し、pg_controlファイルを更新して、すでに処理されたWALデータを再度スキャンする必要がないことを示します。</target>
        </trans-unit>
        <trans-unit id="28dab788b6122ef3bd1cdbda4da4f94cd1b6e630" translate="yes" xml:space="preserve">
          <source>If restoring from backup, rename or delete the old installation directory if it is not version-specific. It is a good idea to rename the directory, rather than delete it, in case you have trouble and need to revert to it. Keep in mind the directory might consume significant disk space. To rename the directory, use a command like this:</source>
          <target state="translated">バックアップから復元する場合は、バージョン固有のものでない場合は、古いインストールディレクトリの名前を変更するか、削除してください。トラブルが発生して元に戻す必要がある場合に備えて、ディレクトリを削除するのではなく、名前を変更しておくと良いでしょう。ディレクトリがかなりのディスク容量を消費する可能性があることを覚えておいてください。ディレクトリの名前を変更するには、以下のようなコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="e309c571c391be62f34e7db7a0c0dec41e3362c4" translate="yes" xml:space="preserve">
          <source>If role can log in, this specifies how many concurrent connections the role can make. -1 (the default) means no limit. Note that only normal connections are counted towards this limit. Neither prepared transactions nor background worker connections are counted towards this limit.</source>
          <target state="translated">ロールがログインできる場合、ロールができる同時接続の数を指定します。-1(デフォルト)は制限なしを意味します。通常の接続のみがこの制限に向かってカウントされることに注意してください。準備されたトランザクションやバックグラウンドワーカーの接続は、この制限にはカウントされません。</target>
        </trans-unit>
        <trans-unit id="62496fbde4961b27e361cbfa11a352d993b40959" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for a table, but no applicable policies exist, a &amp;ldquo;default deny&amp;rdquo; policy is assumed, so that no rows will be visible or updatable.</source>
          <target state="translated">テーブルに対して行レベルのセキュリティが有効になっているが、適用可能なポリシーが存在しない場合、「デフォルトの拒否」ポリシーが想定されるため、行は表示されず、更新できません。</target>
        </trans-unit>
        <trans-unit id="fe157e3ff3573012872e8150157f95ab8031e531" translate="yes" xml:space="preserve">
          <source>If row-level security is enabled for the table, the relevant &lt;code&gt;SELECT&lt;/code&gt; policies will apply to &lt;code&gt;COPY table TO&lt;/code&gt; statements. Currently, &lt;code&gt;COPY FROM&lt;/code&gt; is not supported for tables with row-level security. Use equivalent &lt;code&gt;INSERT&lt;/code&gt; statements instead.</source>
          <target state="translated">テーブルで行レベルのセキュリティが有効になっている場合、関連する &lt;code&gt;SELECT&lt;/code&gt; ポリシーが &lt;code&gt;COPY table TO&lt;/code&gt; ステートメントに適用されます。現在、 &lt;code&gt;COPY FROM&lt;/code&gt; は、行レベルのセキュリティを備えたテーブルではサポートされていません。代わりに同等の &lt;code&gt;INSERT&lt;/code&gt; ステートメントを使用してください。</target>
        </trans-unit>
        <trans-unit id="a6aa638ed0fa1c0e796268aac030545b317ec979" translate="yes" xml:space="preserve">
          <source>If running in FreeBSD jails by enabling sysctl's &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt;, postmasters running in different jails should be run by different operating system users. This improves security because it prevents non-root users from interfering with shared memory or semaphores in different jails, and it allows the PostgreSQL IPC cleanup code to function properly. (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect processes in other jails, preventing the running of postmasters on the same port in different jails.)</source>
          <target state="translated">sysctlの &lt;code&gt;security.jail.sysvipc_allowed&lt;/code&gt; を有効にしてFreeBSDの刑務所で実行している場合、異なる刑務所で実行しているポストマスターは、異なるオペレーティングシステムユーザーが実行する必要があります。これにより、root以外のユーザーがさまざまな刑務所の共有メモリやセマフォに干渉することがなくなり、PostgreSQL IPCクリーンアップコードが正しく機能するようになるため、セキュリティが向上します。 （FreeBSD 6.0以降では、IPCクリーンアップコードは他のjailのプロセスを適切に検出しないため、異なるポートの同じポートでpostmasterが実行されません。）</target>
        </trans-unit>
        <trans-unit id="3d60f2762027b6b57c372852caf475ebc7475d90" translate="yes" xml:space="preserve">
          <source>If running in a FreeBSD jail, you should set its &lt;code&gt;sysvshm&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, so that it has its own separate System V shared memory namespace. (Before FreeBSD 11.0, it was necessary to enable shared access to the host's IPC namespace from jails, and take measures to avoid collisions.)</source>
          <target state="translated">FreeBSD jailで実行している場合は、 &lt;code&gt;sysvshm&lt;/code&gt; パラメータを &lt;code&gt;new&lt;/code&gt; に設定して、独自の別個のSystemV共有メモリ名前空間を持つようにする必要があります。（FreeBSD 11.0より前は、jailからホストのIPC名前空間への共有アクセスを有効にし、衝突を回避するための対策を講じる必要がありました。）</target>
        </trans-unit>
        <trans-unit id="abdee92b42312c6177118cbed677697bf85b5620" translate="yes" xml:space="preserve">
          <source>If set to 0, the realm name from the authenticated user principal is stripped off before being passed through the user name mapping (&lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;). This is discouraged and is primarily available for backwards compatibility, as it is not secure in multi-realm environments unless &lt;code&gt;krb_realm&lt;/code&gt; is also used. It is recommended to leave &lt;code&gt;include_realm&lt;/code&gt; set to the default (1) and to provide an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt; to convert principal names to PostgreSQL user names.</source>
          <target state="translated">0に設定すると、認証されたユーザープリンシパルからのレルム名は、ユーザー名マッピング（&lt;a href=&quot;auth-username-maps&quot;&gt;セクション20.2&lt;/a&gt;）を通過する前に取り除かれます。これはお勧めできません &lt;code&gt;krb_realm&lt;/code&gt; も使用しない限り、マルチレルム環境では安全ではないため、主に下位互換性のために使用できます。 &lt;code&gt;include_realm&lt;/code&gt; をデフォルト（1）に設定した &lt;code&gt;pg_ident.conf&lt;/code&gt; し、プリンシパル名をPostgreSQLユーザー名に変換するためにpg_ident.confに明示的なマッピングを提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="752bcd0b9281c38894ddeb4c193f0b06ac531341" translate="yes" xml:space="preserve">
          <source>If set to 1 or less, sending an EOF character (usually &lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;D&lt;/strong&gt;) to an interactive session of psql will terminate the application. If set to a larger numeric value, that many consecutive EOF characters must be typed to make an interactive session terminate. If the variable is set to a non-numeric value, it is interpreted as 10. The default is 0.</source>
          <target state="translated">1以下に設定した場合、psqlの対話型セッションにEOF文字（通常は&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;D&lt;/strong&gt;）を送信すると、アプリケーションが終了します。より大きい数値に設定する場合、対話型セッションを終了させるには、連続したEOF文字を多数入力する必要があります。変数が非数値に設定されている場合、10と解釈されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="f150c6b9d3460dc605d8aac9efe72846ba7bd56d" translate="yes" xml:space="preserve">
          <source>If set to 1, the domain's SAM-compatible name (also known as the NetBIOS name) is used for the &lt;code&gt;include_realm&lt;/code&gt; option. This is the default. If set to 0, the true realm name from the Kerberos user principal name is used.</source>
          <target state="translated">1に設定すると、ドメインのSAM互換名（NetBIOS名とも呼ばれる）が &lt;code&gt;include_realm&lt;/code&gt; オプションに使用されます。これがデフォルトです。0に設定すると、Kerberosユーザープリンシパル名からの真のレルム名が使用されます。</target>
        </trans-unit>
        <trans-unit id="82302c2f8409896da1eb7439e9dc154b96d3a8b4" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;all&lt;/code&gt;, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch &lt;code&gt;-a&lt;/code&gt;. If set to &lt;code&gt;queries&lt;/code&gt;, psql prints each query to standard output as it is sent to the server. The switch to select this behavior is &lt;code&gt;-e&lt;/code&gt;. If set to &lt;code&gt;errors&lt;/code&gt;, then only failed queries are displayed on standard error output. The switch for this behavior is &lt;code&gt;-b&lt;/code&gt;. If set to &lt;code&gt;none&lt;/code&gt; (the default), then no queries are displayed.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; に設定すると、空でないすべての入力行が読み取られると、標準出力に出力されます。 （これは対話的に読み取られる行には適用されません。）プログラムの起動時にこの動作を選択するには、スイッチ &lt;code&gt;-a&lt;/code&gt; を使用します。設定した場合 &lt;code&gt;queries&lt;/code&gt; がサーバーに送信されると、psqlは、標準出力に各クエリを出力します。この動作を選択するスイッチは &lt;code&gt;-e&lt;/code&gt; です。 &lt;code&gt;errors&lt;/code&gt; に設定すると、失敗したクエリのみが標準エラー出力に表示されます。この動作のスイッチは &lt;code&gt;-b&lt;/code&gt; です。 &lt;code&gt;none&lt;/code&gt; （デフォルト）に設定すると、クエリは表示されません。</target>
        </trans-unit>
        <trans-unit id="4e8e09a59b4bf762d85ca1f3a58b8a4dd3ab9bc9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;off&lt;/code&gt; (the default), detection of WAL records having references to invalid pages during recovery causes PostgreSQL to raise a PANIC-level error, aborting the recovery. Setting &lt;code&gt;ignore_invalid_pages&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt; causes the system to ignore invalid page references in WAL records (but still report a warning), and continue the recovery. This behavior may &lt;em&gt;cause crashes, data loss, propagate or hide corruption, or other serious problems&lt;/em&gt;. However, it may allow you to get past the PANIC-level error, to finish the recovery, and to cause the server to start up. The parameter can only be set at server start. It only has effect during recovery or in standby mode.</source>
          <target state="translated">&lt;code&gt;off&lt;/code&gt; （デフォルト）に設定すると、リカバリ中に無効なページへの参照を持つWALレコードが検出されると、PostgreSQLでPANICレベルのエラーが発生し、リカバリが中止されます。 &lt;code&gt;ignore_invalid_pages&lt;/code&gt; を &lt;code&gt;on&lt;/code&gt; に設定すると、システムはWALレコード内の無効なページ参照を無視し（ただし、警告を報告します）、回復を続行します。この動作&lt;em&gt;により、クラッシュ、データ損失、破損の伝播または非表示、またはその他の重大な問題&lt;/em&gt;が&lt;em&gt;発生&lt;/em&gt;する可能性が&lt;em&gt;あります&lt;/em&gt;。ただし、PANICレベルのエラーを乗り越えてリカバリを終了し、サーバーを起動させることができる場合があります。このパラメーターは、サーバーの起動時にのみ設定できます。リカバリ中またはスタンバイモードでのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="9981243abcd6bfa6b05982c27d6e7ff810b5e4a9" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes WAL files to be recycled by renaming them, avoiding the need to create new ones. On COW file systems, it may be faster to create new ones, so the option is given to disable this behavior.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; （デフォルト）に設定した場合、このオプションにより、WALファイルは名前を変更することでリサイクルされ、新しいファイルを作成する必要がなくなります。COWファイルシステムでは、新しいファイルシステムを作成する方が高速な場合があるため、この動作を無効にするオプションが提供されています。</target>
        </trans-unit>
        <trans-unit id="813f1fb7e134b84c20368173806332413bb9e2ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;on&lt;/code&gt; (the default), this option causes new WAL files to be filled with zeroes. On some file systems, this ensures that space is allocated before we need to write WAL records. However, &lt;em&gt;Copy-On-Write&lt;/em&gt; (COW) file systems may not benefit from this technique, so the option is given to skip the unnecessary work. If set to &lt;code&gt;off&lt;/code&gt;, only the final byte is written when the file is created so that it has the expected size.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; （デフォルト）に設定すると、このオプションにより、新しいWALファイルがゼロで埋められます。一部のファイルシステムでは、これにより、WALレコードを書き込む前にスペースが割り当てられます。ただし、&lt;em&gt;Copy-On-Write&lt;/em&gt;（COW）ファイルシステムはこの手法の恩恵を受けない場合があるため、不要な作業をスキップするオプションが提供されています。 &lt;code&gt;off&lt;/code&gt; に設定すると、ファイルが作成されたときに最終バイトのみが書き込まれるため、ファイルは予想されるサイズになります。</target>
        </trans-unit>
        <trans-unit id="0fba393e4d7deed9cb85ba465e5b27c9e3ab7dd3" translate="yes" xml:space="preserve">
          <source>If set to a non-existent library, JIT will not be available, but no error will be raised. This allows JIT support to be installed separately from the main PostgreSQL package.</source>
          <target state="translated">存在しないライブラリに設定した場合、JITは利用できませんが、エラーは発生しません。これにより、JITのサポートをPostgreSQLのメインパッケージとは別にインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="b3b3af4f011e1d63d9b8223219828980a0583602" translate="yes" xml:space="preserve">
          <source>If set to on, PostgreSQL will instead report an error but continue to run so that the data flushing operation can be retried in a later checkpoint. Only set it to on after investigating the operating system's treatment of buffered data in case of write-back failure.</source>
          <target state="translated">onに設定した場合、PostgreSQLはエラーを報告しますが、後のチェックポイントでデータのフラッシュ処理を再実行できるように実行を続けます。書き込みが失敗した場合のオペレーティングシステムのバッファリングされたデータの扱いを調査した後にのみ、onに設定してください。</target>
        </trans-unit>
        <trans-unit id="bbcf79a2d604d4a130bf67d3aa6808540ca830ba" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID (used to avoid output on system tables).</source>
          <target state="translated">設定されている場合、このOID以下のテーブルのロックをトレースしません(システムテーブルへの出力を回避するために使用されます)。</target>
        </trans-unit>
        <trans-unit id="7b7ecf1b7610990cb56a543c68a5259c46df2a63" translate="yes" xml:space="preserve">
          <source>If set, do not trace locks for tables below this OID. (use to avoid output on system tables)</source>
          <target state="translated">設定されている場合、このOID以下のテーブルのロックをトレースしません。(システムテーブルへの出力を避けるために使用)</target>
        </trans-unit>
        <trans-unit id="41deca852e6fe629c05086ec201225e618efe1c2" translate="yes" xml:space="preserve">
          <source>If set, dumps information about all current locks when a deadlock timeout occurs.</source>
          <target state="translated">設定すると、デッドロックのタイムアウトが発生したときに、現在のすべてのロックの情報をダンプします。</target>
        </trans-unit>
        <trans-unit id="18ea3580271535268c36ef5f8d3f6aa2461f7a29" translate="yes" xml:space="preserve">
          <source>If set, logs system resource usage statistics (memory and CPU) on various B-tree operations.</source>
          <target state="translated">設定すると、さまざまな B-tree 操作におけるシステムリソースの使用統計 (メモリと CPU)をログに記録します。</target>
        </trans-unit>
        <trans-unit id="8cd44fecb272ef12a9372f7353f761fae8a5a0b8" translate="yes" xml:space="preserve">
          <source>If set, the name of the database to create, unless overridden on the command line.</source>
          <target state="translated">セットされている場合は、コマンドラインで上書きされない限り、作成するデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="451271dfdfad4c754e04924937d10fe2728cec15" translate="yes" xml:space="preserve">
          <source>If several large tables all become eligible for vacuuming in a short amount of time, all autovacuum workers might become occupied with vacuuming those tables for a long period. This would result in other tables and databases not being vacuumed until a worker becomes available. There is no limit on how many workers might be in a single database, but workers do try to avoid repeating work that has already been done by other workers. Note that the number of running workers does not count towards &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; or &lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connections&lt;/a&gt; limits.</source>
          <target state="translated">複数の大きなテーブルがすべて短時間でバキューム処理に適格になると、すべての自動バキュームワーカーがそれらのテーブルを長期間バキューム処理することに専念する可能性があります。これにより、ワーカーが使用可能になるまで、他のテーブルとデータベースがバキュームされなくなります。 1つのデータベースに含まれる可能性のあるワーカーの数に制限はありませんが、ワーカーは、他のワーカーによって既に実行されている作業を繰り返さないようにしています。実行中のワーカーの数は、&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;または&lt;a href=&quot;runtime-config-connection#GUC-SUPERUSER-RESERVED-CONNECTIONS&quot;&gt;superuser_reserved_connectionsの&lt;/a&gt;制限にカウントされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0c0765d00a52dbd937ed1bff59efeb02a5ce2381" translate="yes" xml:space="preserve">
          <source>If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup (&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery (&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">同時スナップショットが不可能な場合、1つのオプションは、凍結されたすべてのスナップショットを確立するのに十分な時間データベースサーバーをシャットダウンすることです。別のオプションは、継続的なアーカイブベースバックアップ（&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;セクション25.3.2&lt;/a&gt;）を実行することです。このようなバックアップは、バックアップ中のファイルシステムの変更の影響を受けないためです。これには、バックアッププロセスの最中に継続的なアーカイブを有効にする必要があります。復元は、継続的なアーカイブ回復を使用して行われます（&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;セクション25.3.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7b56d1af18915d5bc67acc7e5f67cf1743ccd0db" translate="yes" xml:space="preserve">
          <source>If specific tables are named in a locking clause, then only rows coming from those tables are locked; any other tables used in the &lt;code&gt;SELECT&lt;/code&gt; are simply read as usual. A locking clause without a table list affects all tables used in the statement. If a locking clause is applied to a view or sub-query, it affects all tables used in the view or sub-query. However, these clauses do not apply to &lt;code&gt;WITH&lt;/code&gt; queries referenced by the primary query. If you want row locking to occur within a &lt;code&gt;WITH&lt;/code&gt; query, specify a locking clause within the &lt;code&gt;WITH&lt;/code&gt; query.</source>
          <target state="translated">特定のテーブルがロック句で指定されている場合、それらのテーブルからの行のみがロックされます。 &lt;code&gt;SELECT&lt;/code&gt; で使用される他のテーブルは、通常どおり単に読み取られます。テーブルリストのないロック句は、ステートメントで使用されるすべてのテーブルに影響します。ロック句がビューまたはサブクエリに適用されると、ビューまたはサブクエリで使用されるすべてのテーブルに影響します。ただし、これらの句は、プライマリクエリによって参照される &lt;code&gt;WITH&lt;/code&gt; クエリには適用されません。あなたが行ロックを内で発生する場合 &lt;code&gt;WITH&lt;/code&gt; クエリ、内ロック句を指定 &lt;code&gt;WITH&lt;/code&gt; のクエリ。</target>
        </trans-unit>
        <trans-unit id="beba3aa15b0f31c93cbfaa613e20da31b4d61852" translate="yes" xml:space="preserve">
          <source>If specified, the sequence object is created only for this session, and is automatically dropped on session exit. Existing permanent sequences with the same name are not visible (in this session) while the temporary sequence exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">指定した場合、シーケンスオブジェクトはこのセッションのためだけに作成され、セッション終了時に自動的に削除されます。同じ名前の既存のパーマネントシーケンスは、スキーマ修飾名で参照されていない限り、一時的なシーケンスが存在する間は(このセッションでは)表示されません。</target>
        </trans-unit>
        <trans-unit id="96e1f90a66af2b7d727620148bca6f42e74b9d62" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">指定した場合、テーブルは一時テーブルとして作成されます。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a93d62c01130cfe765292bae429e3354023ac5a8" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as a temporary table. Temporary tables are automatically dropped at the end of a session, or optionally at the end of the current transaction (see &lt;code&gt;ON COMMIT&lt;/code&gt; below). Existing permanent tables with the same name are not visible to the current session while the temporary table exists, unless they are referenced with schema-qualified names. Any indexes created on a temporary table are automatically temporary as well.</source>
          <target state="translated">指定した場合、テーブルは一時テーブルとして作成されます。一時テーブルは、セッションの終わりに、またはオプションで現在のトランザクションの終わりに自動的に削除されます（下記の &lt;code&gt;ON COMMIT&lt;/code&gt; を参照）。スキーマで修飾された名前で参照されない限り、一時テーブルが存在する間、同じ名前の既存の永続テーブルは現在のセッションからは見えません。一時テーブルに作成されたインデックスも自動的に一時的です。</target>
        </trans-unit>
        <trans-unit id="e56b4bad12a19e93500049e2da8fe4abf56f18b0" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">指定した場合、テーブルはログなしのテーブルとして作成されます。ログに記録されていないテーブルに書き込まれたデータは、先行書き込みログ（&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;第29章を&lt;/a&gt;参照）に書き込まれないため、通常のテーブルよりもかなり高速になります。ただし、それらはクラッシュセーフではありません。ログが記録されていないテーブルは、クラッシュまたは不適切なシャットダウンの後に自動的に切り捨てられます。ログに記録されていないテーブルの内容もスタンバイサーバーに複製されません。ログに記録されていないテーブルに作成されたインデックスも、自動的にログに記録されません。</target>
        </trans-unit>
        <trans-unit id="a8596f70e4f839c2549fada82806079e6705f6bb" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Data written to unlogged tables is not written to the write-ahead log (see &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt;), which makes them considerably faster than ordinary tables. However, they are not crash-safe: an unlogged table is automatically truncated after a crash or unclean shutdown. The contents of an unlogged table are also not replicated to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.</source>
          <target state="translated">指定した場合、テーブルはログに記録されていないテーブルとして作成されます。ログに記録されていないテーブルに書き込まれたデータは先行書き込みログに書き込まれないため（&lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;第29章を&lt;/a&gt;参照）、通常のテーブルよりも大幅に高速になります。ただし、これらはクラッシュセーフではありません。ログに記録されていないテーブルは、クラッシュまたはクリーンでないシャットダウン後に自動的に切り捨てられます。ログに記録されていないテーブルの内容も、スタンバイサーバーに複製されません。ログに記録されていないテーブルに作成されたインデックスも、自動的にログに記録されなくなります。</target>
        </trans-unit>
        <trans-unit id="498ade4fa6d89cb5e928b12b79fbd85a2d4b6bc5" translate="yes" xml:space="preserve">
          <source>If specified, the table is created as an unlogged table. Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">指定した場合、テーブルはログなしのテーブルとして作成されます。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="55118ee1dbd9adb1bf85c53f18502dc86e8b6ddb" translate="yes" xml:space="preserve">
          <source>If specified, the view is created as a temporary view. Temporary views are automatically dropped at the end of the current session. Existing permanent relations with the same name are not visible to the current session while the temporary view exists, unless they are referenced with schema-qualified names.</source>
          <target state="translated">指定した場合、ビューは一時的なビューとして作成されます。一時的なビューは、現在のセッションの終了時に自動的に削除されます。同じ名前の既存の恒久的なリレーションは、スキーマ修飾名で参照されていない限り、一時ビューが存在する間、現在のセッションからは見えません。</target>
        </trans-unit>
        <trans-unit id="6b5dcbb0812dddc20d9371b9207b1cdb23e05524" translate="yes" xml:space="preserve">
          <source>If still not found, throw an error.</source>
          <target state="translated">それでも見つからない場合は、エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="47cfc3e95fb2a4c5ace1abe2c232997982b636d2" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without a problem. If streaming replication is in progress then WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">ストリーミングレプリケーションが無効になっている場合、一時停止状態は問題なく無期限に継続することができます。ストリーミングレプリケーションが進行中の場合、WALレコードは受信され続け、一時停止の期間、WALの生成速度、利用可能なディスクスペースに応じて、最終的には利用可能なディスクスペースが一杯になります。</target>
        </trans-unit>
        <trans-unit id="07af580d9fd90f0744560609d17c425a1c0582ea" translate="yes" xml:space="preserve">
          <source>If streaming replication is disabled, the paused state may continue indefinitely without problem. While streaming replication is in progress WAL records will continue to be received, which will eventually fill available disk space, depending upon the duration of the pause, the rate of WAL generation and available disk space.</source>
          <target state="translated">ストリーミングレプリケーションが無効になっている場合、一時停止状態は問題なく無期限に継続することができます。ストリーミングレプリケーションが進行している間、WALレコードは受信され続け、一時停止の期間、WALの生成速度、利用可能なディスク容量に応じて、最終的には利用可能なディスク容量が一杯になります。</target>
        </trans-unit>
        <trans-unit id="226224ac165619e504532207642e17cb378b9939" translate="yes" xml:space="preserve">
          <source>If syslog is ultimately logging to a text file, then the effect will be the same either way, and it is best to leave the setting on, since most syslog implementations either cannot handle large messages or would need to be specially configured to handle them. But if syslog is ultimately writing into some other medium, it might be necessary or more useful to keep messages logically together.</source>
          <target state="translated">syslogが最終的にテキストファイルにログを記録する場合、どちらの方法でも効果は同じで、ほとんどのsyslog実装は大きなメッセージを扱えないか、それらを扱うために特別に設定する必要があるので、設定をオンにしたままにしておくのが最善です。しかし、syslogが最終的に何か他の媒体に書き込む場合、メッセージを論理的に一緒に保持することが必要であるか、より有用であるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5afa6f87265a39e1ce0df6a7d2ec06e5f9b70a1e" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (including shared memory) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">systemdを使用している場合は、IPCリソース（共有メモリを含む）がオペレーティングシステムによって時期尚早に削除されないように注意する必要があります。これは、PostgreSQLをソースからインストールするときに特に懸念されます。 &lt;code&gt;postgres&lt;/code&gt; ユーザーは通常システムユーザーとして作成されるため、PostgreSQLの配布パッケージのユーザーが影響を受ける可能性は低くなります。</target>
        </trans-unit>
        <trans-unit id="0c9f61d1e280ce039975396a48eef3020a367753" translate="yes" xml:space="preserve">
          <source>If systemd is in use, some care must be taken that IPC resources (shared memory and semaphores) are not prematurely removed by the operating system. This is especially of concern when installing PostgreSQL from source. Users of distribution packages of PostgreSQL are less likely to be affected, as the &lt;code&gt;postgres&lt;/code&gt; user is then normally created as a system user.</source>
          <target state="translated">systemdを使用している場合、IPCリソース（共有メモリとセマフォ）がオペレーティングシステムによって途中で削除されないように注意する必要があります。これは、PostgreSQLをソースからインストールする場合に特に問題になります。PostgreSQLの配布パッケージのユーザーは、通常 &lt;code&gt;postgres&lt;/code&gt; ユーザーがシステムユーザーとして作成されるため、影響を受ける可能性は低くなります。</target>
        </trans-unit>
        <trans-unit id="0cc78b460318c43d7e2a2ae058784201d032436a" translate="yes" xml:space="preserve">
          <source>If table is a partition (see &lt;code&gt;relispartition&lt;/code&gt;), internal representation of the partition bound</source>
          <target state="translated">テーブルがパーティションの場合（ &lt;code&gt;relispartition&lt;/code&gt; を参照）、バインドされたパーティションの内部表現</target>
        </trans-unit>
        <trans-unit id="2f2df2648f2943188802b9abf232f2ee4f995a24" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Access privileges&amp;rdquo; column is empty for a given object, it means the object has default privileges (that is, its privileges entry in the relevant system catalog is null). Default privileges always include all privileges for the owner, and can include some privileges for &lt;code&gt;PUBLIC&lt;/code&gt; depending on the object type, as explained above. The first &lt;code&gt;GRANT&lt;/code&gt; or &lt;code&gt;REVOKE&lt;/code&gt; on an object will instantiate the default privileges (producing, for example, &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt;) and then modify them per the specified request. Similarly, entries are shown in &amp;ldquo;Column privileges&amp;rdquo; only for columns with nondefault privileges. (Note: for this purpose, &amp;ldquo;default privileges&amp;rdquo; always means the built-in default privileges for the object's type. An object whose privileges have been affected by an &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; command will always be shown with an explicit privilege entry that includes the effects of the &lt;code&gt;ALTER&lt;/code&gt;.)</source>
          <target state="translated">特定のオブジェクトの「アクセス権限」列が空の場合、そのオブジェクトにはデフォルトの権限があることを意味します（つまり、関連するシステムカタログの権限エントリはnullです）。デフォルトの権限には、常に所有者のすべての権限が含まれ、上記で説明したように、オブジェクトタイプに応じて &lt;code&gt;PUBLIC&lt;/code&gt; の一部の権限を含めることができます。オブジェクトの最初の &lt;code&gt;GRANT&lt;/code&gt; または &lt;code&gt;REVOKE&lt;/code&gt; は、デフォルトの特権をインスタンス化します（たとえば、 &lt;code&gt;miriam=arwdDxt/miriam&lt;/code&gt; を生成します)）、指定されたリクエストごとに変更します。同様に、デフォルト以外の権限を持つ列についてのみ、「列の権限」にエントリが表示されます。（注：この目的のために、「デフォルト特権」は常にオブジェクトのタイプの組み込みのデフォルト特権を意味します。特権が &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; コマンドによって影響を受けたオブジェクトは、常に影響を含む明示的な特権エントリとともに表示されます &lt;code&gt;ALTER&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="ef8285ef018dbe08eadaac46ca6f457ffb7737a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--check&lt;/code&gt; option was used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">場合 &lt;code&gt;--check&lt;/code&gt; オプションを使用した、古いクラスタはそのままでした。再起動できます。</target>
        </trans-unit>
        <trans-unit id="5231ab37a455b02818813f84dceafd365dc3d243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was &lt;em&gt;not&lt;/em&gt; used, the old cluster was unmodified; it can be restarted.</source>
          <target state="translated">場合 &lt;code&gt;--link&lt;/code&gt; オプションがして&lt;em&gt;いない&lt;/em&gt;使用し、古いクラスタはそのままでした。再起動できます。</target>
        </trans-unit>
        <trans-unit id="9eaa5641cd34b4f83c2c8d2f48ba3f445ae08243" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--link&lt;/code&gt; option was used, the data files might be shared between the old and new cluster:</source>
          <target state="translated">場合 &lt;code&gt;--link&lt;/code&gt; オプションを使用した、データファイルは古いものと新しいクラスタ間で共有されることがあります。</target>
        </trans-unit>
        <trans-unit id="e5bb770bf0c6c53be90a08f4aadc13d0d045351b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DELETE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) deleted by the command.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; コマンドに &lt;code&gt;RETURNING&lt;/code&gt; 句が含まれている場合、結果は、コマンドによって削除された行に対して計算された、 &lt;code&gt;RETURNING&lt;/code&gt; リストで定義された列と値を含む &lt;code&gt;SELECT&lt;/code&gt; ステートメントの結果と同様になります。</target>
        </trans-unit>
        <trans-unit id="3edf0bee0b1a18174b6275c32dcc72778ff7f983" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;&lt;code&gt;GROUP BY&lt;/code&gt; Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;&lt;code&gt;HAVING&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合 &lt;code&gt;GROUP BY&lt;/code&gt; 句が指定された集計関数呼び出しがある場合、または、出力が1つまたは複数の値、および集約関数の結果に一致が計算されることが行のグループに結合されます。 &lt;code&gt;HAVING&lt;/code&gt; 句が存在する場合、指定された条件を満たさないグループは削除されます。（下記の&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 句&lt;/a&gt;と&lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt; &lt;code&gt;HAVING&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="8cba5ea5fe4b174dd3b26b5824e3815a353de168" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GROUP BY&lt;/code&gt; clause is specified, or if there are aggregate function calls, the output is combined into groups of rows that match on one or more values, and the results of aggregate functions are computed. If the &lt;code&gt;HAVING&lt;/code&gt; clause is present, it eliminates groups that do not satisfy the given condition. (See &lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY Clause&lt;/a&gt; and &lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合 &lt;code&gt;GROUP BY&lt;/code&gt; 句が指定された集計関数呼び出しがある場合、または、出力が1つまたは複数の値、および集約関数の結果に一致が計算されることが行のグループに結合されます。 &lt;code&gt;HAVING&lt;/code&gt; 句が存在する場合、指定された条件を満たすグループを削除します。（以下の&lt;a href=&quot;sql-select#SQL-GROUPBY&quot;&gt;GROUP BY句&lt;/a&gt;と&lt;a href=&quot;sql-select#SQL-HAVING&quot;&gt;HAVING句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="e73996306e544b116d96395fc6c635fa64541db1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) inserted or updated by the command.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; コマンドに &lt;code&gt;RETURNING&lt;/code&gt; 句が含まれている場合、結果は、コマンドによって挿入または更新された行に対して計算された、 &lt;code&gt;RETURNING&lt;/code&gt; リストで定義された列と値を含む &lt;code&gt;SELECT&lt;/code&gt; ステートメントの結果と同様になります。</target>
        </trans-unit>
        <trans-unit id="0cef0ec98d8f962ff98a56a4b6b305bd357183c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;&lt;code&gt;LIMIT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合 &lt;code&gt;LIMIT&lt;/code&gt; （または &lt;code&gt;FETCH FIRST&lt;/code&gt; ）または &lt;code&gt;OFFSET&lt;/code&gt; 句が指定され、 &lt;code&gt;SELECT&lt;/code&gt; 文は結果行の一部分のみを返します。（下記の&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt; &lt;code&gt;LIMIT&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="4a75230035fa0b522f04007a43794f1e0d2bb911" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LIMIT&lt;/code&gt; (or &lt;code&gt;FETCH FIRST&lt;/code&gt;) or &lt;code&gt;OFFSET&lt;/code&gt; clause is specified, the &lt;code&gt;SELECT&lt;/code&gt; statement only returns a subset of the result rows. (See &lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合 &lt;code&gt;LIMIT&lt;/code&gt; （または &lt;code&gt;FETCH FIRST&lt;/code&gt; ）または &lt;code&gt;OFFSET&lt;/code&gt; 句が指定され、 &lt;code&gt;SELECT&lt;/code&gt; 文は結果行の一部分のみを返します。（以下の&lt;a href=&quot;sql-select#SQL-LIMIT&quot;&gt;LIMIT句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="72d3a656a8d2961c5ae7c07dee89a103497dda43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合は &lt;code&gt;ORDER BY&lt;/code&gt; 句が指定され、返される行は指定された順にソートされています。 &lt;code&gt;ORDER BY&lt;/code&gt; が指定されていない場合、行は、システムが生成するのに最も速い順序で返されます。（下記の&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="d8ea2efbcef004128bc9ee33fa0b309eb98d431a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ORDER BY&lt;/code&gt; clause is specified, the returned rows are sorted in the specified order. If &lt;code&gt;ORDER BY&lt;/code&gt; is not given, the rows are returned in whatever order the system finds fastest to produce. (See &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合は &lt;code&gt;ORDER BY&lt;/code&gt; 句が指定され、返される行は指定された順にソートされています。 &lt;code&gt;ORDER BY&lt;/code&gt; が指定されていない場合、行は、システムが最も速く生成すると判断した順序で返されます。（以下の&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="fcc9caa8fd8396a40199c537204044cd80b03fd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; command fails for any reason, it becomes a &lt;code&gt;ROLLBACK&lt;/code&gt;: the current transaction is canceled.</source>
          <target state="translated">場合は &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; のコマンドが何らかの理由で失敗し、それはなり &lt;code&gt;ROLLBACK&lt;/code&gt; ：現在のトランザクションがキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="049a6b3315aa2fcc9292bf280d3fbac8f17f8faa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PREPARE&lt;/code&gt; statement that created the statement specified some parameters, a compatible set of parameters must be passed to the &lt;code&gt;EXECUTE&lt;/code&gt; statement, or else an error is raised. Note that (unlike functions) prepared statements are not overloaded based on the type or number of their parameters; the name of a prepared statement must be unique within a database session.</source>
          <target state="translated">ステートメントを作成した &lt;code&gt;PREPARE&lt;/code&gt; ステートメントがいくつかのパラメーターを指定した場合、互換性のあるパラメーターのセットを &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントに渡す必要があります。そうしないと、エラーが発生します。（関数とは異なり）準備されたステートメントは、パラメーターのタイプまたは数に基づいてオーバーロードされないことに注意してください。準備済みステートメントの名前は、データベースセッション内で一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="4e671e1df94a35c63462372f63dbaab316b08304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;UPDATE&lt;/code&gt; command contains a &lt;code&gt;RETURNING&lt;/code&gt; clause, the result will be similar to that of a &lt;code&gt;SELECT&lt;/code&gt; statement containing the columns and values defined in the &lt;code&gt;RETURNING&lt;/code&gt; list, computed over the row(s) updated by the command.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; コマンドに &lt;code&gt;RETURNING&lt;/code&gt; 句が含まれている場合、結果は、コマンドによって更新された行に対して計算された、 &lt;code&gt;RETURNING&lt;/code&gt; リストで定義された列と値を含む &lt;code&gt;SELECT&lt;/code&gt; ステートメントの結果と同様になります。</target>
        </trans-unit>
        <trans-unit id="e2d169320d1dac51b305dc4371af2fd872eb335a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">場合は &lt;code&gt;WHERE&lt;/code&gt; 句が指定され、条件を満たさないすべての行は出力から除外されています。（以下の&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="4af20d29d9d1228c78339d28ff758ffb08bbfc49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WHERE&lt;/code&gt; clause is specified, all rows that do not satisfy the condition are eliminated from the output. (See &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句が指定されている場合、条件を満たさないすべての行が出力から削除されます。（以下の&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;WHERE句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="92b918e82e1dbdff8d47052fc332ee8551811a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause is specified, an additional column of type &lt;code&gt;bigint&lt;/code&gt; will be added to the function result columns. This column numbers the rows of the function result set, starting from 1. (This is a generalization of the SQL-standard syntax for &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt;.) By default, the ordinal column is called &lt;code&gt;ordinality&lt;/code&gt;, but a different column name can be assigned to it using an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">場合 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; の句が指定され、型の追加の列 &lt;code&gt;bigint&lt;/code&gt; 関数の結果の列に追加されます。この列番号関数の結果の行は1から始まるセット、（これがためにSQL標準構文を一般化したものである &lt;code&gt;UNNEST ... WITH ORDINALITY&lt;/code&gt; 。）デフォルトでは、序数の列が呼ばれた &lt;code&gt;ordinality&lt;/code&gt; が、異なるカラム名 &lt;code&gt;AS&lt;/code&gt; 句を使用して割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="3a9a2b1e5b5de3befe9a4b97f742aa542e0145cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;count&lt;/code&gt; expression evaluates to NULL, it is treated as &lt;code&gt;LIMIT ALL&lt;/code&gt;, i.e., no limit. If &lt;code&gt;start&lt;/code&gt; evaluates to NULL, it is treated the same as &lt;code&gt;OFFSET 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 式がNULLと評価された場合、それは &lt;code&gt;LIMIT ALL&lt;/code&gt; として扱われます。つまり、制限はありません。 &lt;code&gt;start&lt;/code&gt; がNULLと評価された場合、 &lt;code&gt;OFFSET 0&lt;/code&gt; と同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="b469c74a0f6fb197601cf70011bbae3b5c0a8cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dictionary&lt;/code&gt; argument is omitted, the text search dictionary named &lt;code&gt;unaccent&lt;/code&gt; and appearing in the same schema as the &lt;code&gt;unaccent()&lt;/code&gt; function itself is used.</source>
          <target state="translated">&lt;code&gt;dictionary&lt;/code&gt; 引数が省略された場合、 &lt;code&gt;unaccent&lt;/code&gt; という名前で &lt;code&gt;unaccent()&lt;/code&gt; 関数自体と同じスキーマにあるテキスト検索辞書が使用されます。</target>
        </trans-unit>
        <trans-unit id="8e92f2cba043fc31ab92cbc203c691c2c492c8d7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;expression&lt;/code&gt; is row-valued, then &lt;code&gt;IS NULL&lt;/code&gt; is true when the row expression itself is null or when all the row's fields are null, while &lt;code&gt;IS NOT NULL&lt;/code&gt; is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt; do not always return inverse results for row-valued expressions; in particular, a row-valued expression that contains both null and non-null fields will return false for both tests. In some cases, it may be preferable to write &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; or &lt;code&gt;row&lt;/code&gt;&lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt;, which will simply check whether the overall row value is null without any additional tests on the row fields.</source>
          <target state="translated">場合 &lt;code&gt;expression&lt;/code&gt; 行値である場合、 &lt;code&gt;IS NULL&lt;/code&gt; 行式自体がNULLまたはときながら、すべての行のフィールドは、nullのときに真である &lt;code&gt;IS NOT NULL&lt;/code&gt; は、行式自体が非nullで、すべての行のフィールドがあるときに真でありますnull以外。この動作のため、 &lt;code&gt;IS NULL&lt;/code&gt; および &lt;code&gt;IS NOT NULL&lt;/code&gt; は常に行値式の逆の結果を返すとは限りません。特に、nullとnon-nullの両方のフィールドを含む行値式は、両方のテストでfalseを返します。いくつかのケースでは、書き込みに好ましいかもしれない &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS DISTINCT FROM NULL&lt;/code&gt; または &lt;code&gt;row&lt;/code&gt; &lt;code&gt;IS NOT DISTINCT FROM NULL&lt;/code&gt; これは、行フィールドに対する追加のテストなしで、行全体の値がnullかどうかを単純にチェックします。</target>
        </trans-unit>
        <trans-unit id="8a9d5cf7323804505a12a8a728eb4b811573a010" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;system-username&lt;/code&gt; field starts with a slash (&lt;code&gt;/&lt;/code&gt;), the remainder of the field is treated as a regular expression. (See &lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;Section 9.7.3.1&lt;/a&gt; for details of PostgreSQL's regular expression syntax.) The regular expression can include a single capture, or parenthesized subexpression, which can then be referenced in the &lt;code&gt;database-username&lt;/code&gt; field as &lt;code&gt;\1&lt;/code&gt; (backslash-one). This allows the mapping of multiple user names in a single line, which is particularly useful for simple syntax substitutions. For example, these entries</source>
          <target state="translated">&lt;code&gt;system-username&lt;/code&gt; フィールドがスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）で始まる場合、フィールドの残りの部分は正規表現として扱われます。（PostgreSQLの正規表現構文の詳細については、&lt;a href=&quot;functions-matching#POSIX-SYNTAX-DETAILS&quot;&gt;セクション9.7.3.1&lt;/a&gt;を参照してください。）正規表現には、単一のキャプチャ、または括弧で囲まれたサブ表現を含めることができ、 &lt;code&gt;database-username&lt;/code&gt; フィールドで &lt;code&gt;\1&lt;/code&gt; （バックスラッシュ1）として参照できます。これにより、複数のユーザー名を1行でマッピングできます。これは、単純な構文の置換に特に役立ちます。たとえば、これらのエントリ</target>
        </trans-unit>
        <trans-unit id="482a504d7c75e328098ffe22edcbb1378a3f6faa" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;values&lt;/code&gt;&lt;/em&gt; arrays are specified, an &lt;em&gt;armor header&lt;/em&gt; is added to the armored format for each key/value pair. Both arrays must be single-dimensional, and they must be of the same length. The keys and values cannot contain any non-ASCII characters.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/em&gt;と&lt;em&gt; &lt;code&gt;values&lt;/code&gt; &lt;/em&gt;配列が指定されている場合、各キー/値のペアの&lt;em&gt;アーマー&lt;/em&gt;形式に&lt;em&gt;アーマーヘッダー&lt;/em&gt;が追加されます。両方の配列は1次元である必要があり、同じ長さでなければなりません。キーと値に非ASCII文字を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="7327537568cbffaa257fef6fbd8b81996eaef858" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; argument is specified and has the &lt;code&gt;true&lt;/code&gt; value, these functions suppress the same errors as the &lt;code&gt;@?&lt;/code&gt; and &lt;code&gt;@@&lt;/code&gt; operators.</source>
          <target state="translated">場合は&lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt;引数が指定されていている &lt;code&gt;true&lt;/code&gt; 値を、これらの機能は同じエラー抑制 &lt;code&gt;@?&lt;/code&gt; および &lt;code&gt;@@&lt;/code&gt; 演算子。</target>
        </trans-unit>
        <trans-unit id="ceede46190dd53d528fe2b583d1ccadb6cf588b2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; argument is specified, it provides an object containing named variables to be substituted into a &lt;code&gt;jsonpath&lt;/code&gt; expression.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;vars&lt;/code&gt; の&lt;/em&gt;引数が指定され、それが代入されるという名前の変数を含むオブジェクトを提供 &lt;code&gt;jsonpath&lt;/code&gt; の表現を。</target>
        </trans-unit>
        <trans-unit id="a173c623ff67d4c364c8db6dbe6ae6c5c5c1b9dd" translate="yes" xml:space="preserve">
          <source>If the S2K key is to be used directly, then only S2K settings will be put into the session key packet. Otherwise the session key will be encrypted with the S2K key and put into the session key packet.</source>
          <target state="translated">S2K鍵を直接使用する場合は、S2Kの設定のみをセッション鍵パケットに入れます。そうでなければ、セッションキーはS2Kキーで暗号化されてセッションキーパケットに入れられます。</target>
        </trans-unit>
        <trans-unit id="cd334923ca7f6a61f76d5cc9802fe6d4f79f8249" translate="yes" xml:space="preserve">
          <source>If the Serializable transaction isolation level is used for all writes and for all reads which need a consistent view of the data, no other effort is required to ensure consistency. Software from other environments which is written to use serializable transactions to ensure consistency should &amp;ldquo;just work&amp;rdquo; in this regard in PostgreSQL.</source>
          <target state="translated">すべての書き込みと、データの一貫したビューが必要なすべての読み取りにSerializableトランザクション分離レベルが使用されている場合、一貫性を確保するために他の作業は必要ありません。PostgreSQLでこの点に関して、一貫性を保証するためにシリアライズ可能なトランザクションを使用するように作成された他の環境のソフトウェアは「そのまま動作する」はずです。</target>
        </trans-unit>
        <trans-unit id="b3a85d8941e78b61fa6dfe5e13735d5c695c638d" translate="yes" xml:space="preserve">
          <source>If the argument begins with &lt;code&gt;|&lt;/code&gt;, then the entire remainder of the line is taken to be the &lt;code&gt;command&lt;/code&gt; to execute, and neither variable interpolation nor backquote expansion are performed in it. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">引数が &lt;code&gt;|&lt;/code&gt; で始まる場合 の場合、行の残りの部分全体が実行する &lt;code&gt;command&lt;/code&gt; と見なされ、変数補間もバッククォート展開も実行されません。行の残りは単に文字通りシェルに渡されます。</target>
        </trans-unit>
        <trans-unit id="c120a5d678ef79b9fdd905518c659ce62747d5d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;json_strip_nulls&lt;/code&gt; contains duplicate field names in any object, the result could be semantically somewhat different, depending on the order in which they occur. This is not an issue for &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; since &lt;code&gt;jsonb&lt;/code&gt; values never have duplicate object field names.</source>
          <target state="translated">&lt;code&gt;json_strip_nulls&lt;/code&gt; への引数のオブジェクトに重複したフィールド名が含まれている場合、それらが発生する順序によっては、結果が意味的に多少異なる場合があります。これは問題になりません &lt;code&gt;jsonb_strip_nulls&lt;/code&gt; ので、 &lt;code&gt;jsonb&lt;/code&gt; 値が重複するオブジェクトフィールド名を持っていることはありません。</target>
        </trans-unit>
        <trans-unit id="da41d6b70ef3eb6374e923e599dfca0a856e8010" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ALL&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ALL&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no false comparison result is obtained, the result of &lt;code&gt;ALL&lt;/code&gt; will be null, not true (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">配列式がnull配列を生成する場合、 &lt;code&gt;ALL&lt;/code&gt; の結果はnullになります。左側の式がnullを生成する場合、 &lt;code&gt;ALL&lt;/code&gt; の結果は通常nullです（厳密でない比較演算子は異なる結果を生成する可能性があります）。また、右側の配列にnull要素が含まれ、偽の比較結果が得られない場合、 &lt;code&gt;ALL&lt;/code&gt; の結果は真ではなくnullになります（ここでも、厳密な比較演算子を想定しています）。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="ae942e08ca17c439fb984995bab2b3f4a2ace54c" translate="yes" xml:space="preserve">
          <source>If the array expression yields a null array, the result of &lt;code&gt;ANY&lt;/code&gt; will be null. If the left-hand expression yields null, the result of &lt;code&gt;ANY&lt;/code&gt; is ordinarily null (though a non-strict comparison operator could possibly yield a different result). Also, if the right-hand array contains any null elements and no true comparison result is obtained, the result of &lt;code&gt;ANY&lt;/code&gt; will be null, not false (again, assuming a strict comparison operator). This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">配列式がnull配列を生成する場合、 &lt;code&gt;ANY&lt;/code&gt; の結果はnullになります。左側の式がnullを生成する場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は通常nullです（厳密でない比較演算子は異なる結果を生成する可能性があります）。また、右側の配列にnull要素が含まれ、真の比較結果が得られない場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は偽ではなくnullになります（ここでも、厳密な比較演算子を想定しています）。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="f33f8fbf54f510b9f47b6952f447521e0e216bb8" translate="yes" xml:space="preserve">
          <source>If the backup process monitors and ensures that all WAL segment files required for the backup are successfully archived then the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter (which defaults to true) can be set to false to have &lt;code&gt;pg_stop_backup&lt;/code&gt; return as soon as the stop backup record is written to the WAL. By default, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait until all WAL has been archived, which can take some time. This option must be used with caution: if WAL archiving is not monitored correctly then the backup might not include all of the WAL files and will therefore be incomplete and not able to be restored.</source>
          <target state="translated">バックアッププロセスが監視し、バックアップに必要なすべてのWALセグメントファイルが正常にアーカイブされていることを &lt;code&gt;wait_for_archive&lt;/code&gt; する場合、wait_for_archiveパラメータ（デフォルトはtrue）をfalseに設定して、 &lt;code&gt;pg_stop_backup&lt;/code&gt; がバックアップの停止レコードがWALに書き込まれるとすぐに戻ることができます。。デフォルトでは、 &lt;code&gt;pg_stop_backup&lt;/code&gt; はすべてのWALがアーカイブされるまで待機します。これには時間がかかる場合があります。このオプションは注意して使用する必要があります。WALアーカイブが正しく監視されていない場合、バックアップにすべてのWALファイルが含まれていない可能性があるため、不完全であり、復元できません。</target>
        </trans-unit>
        <trans-unit id="c791af34bd6ddf53748d0f35d1bff063098edcb5" translate="yes" xml:space="preserve">
          <source>If the backup was taken with file checksums enabled, the following keys will be present:</source>
          <target state="translated">ファイルのチェックサムを有効にしてバックアップを取った場合、以下のキーが存在します。</target>
        </trans-unit>
        <trans-unit id="38dbd4a01a3f520d833ada1c842bc701e68bca1c" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; then it can be invoked implicitly when assigning a value to a column of the target data type. For example, supposing that &lt;code&gt;foo.f1&lt;/code&gt; is a column of type &lt;code&gt;text&lt;/code&gt;, then:</source>
          <target state="translated">キャストが &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; とマークされている場合、ターゲットデータ型の列に値を割り当てるときに暗黙的に呼び出すことができます。たとえば、 &lt;code&gt;foo.f1&lt;/code&gt; が &lt;code&gt;text&lt;/code&gt; 型の列であるとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="a854dcb7d27eca4b3717769b2da567eec36f84ca" translate="yes" xml:space="preserve">
          <source>If the cast is marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; then it can be invoked implicitly in any context, whether assignment or internally in an expression. (We generally use the term &lt;em&gt;implicit cast&lt;/em&gt; to describe this kind of cast.) For example, consider this query:</source>
          <target state="translated">キャストが &lt;code&gt;AS IMPLICIT&lt;/code&gt; としてマークされている場合、割り当てでも式の内部でも、どのコンテキストでも暗黙的に呼び出すことができます。（通常、この種の&lt;em&gt;キャスト&lt;/em&gt;を説明するために&lt;em&gt;暗黙的キャスト&lt;/em&gt;という用語を使用します。）たとえば、次のクエリについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="61cd1b288599e699dce186b3244d616ce3ce9c86" translate="yes" xml:space="preserve">
          <source>If the catalog's &lt;code&gt;.h&lt;/code&gt; file specifies a default value for a column, and a data entry has that same value, &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; will omit it from the data file. This keeps the data representation compact.</source>
          <target state="translated">カタログの &lt;code&gt;.h&lt;/code&gt; ファイルが列のデフォルト値を指定し、データエントリがその同じ値を持っている場合、 &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; はデータファイルからそれを省略します。これにより、データ表現がコンパクトに保たれます。</target>
        </trans-unit>
        <trans-unit id="e457eb8bdc9731b8c1605b478c130085944e5e2a" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. (However, if the server's character set is not &lt;code&gt;SQL_ASCII&lt;/code&gt;, the server will still check that incoming data is valid for that encoding; so the net effect is as though the client character set were the same as the server's.) Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">クライアントの文字セットが &lt;code&gt;SQL_ASCII&lt;/code&gt; として定義されている場合、サーバーの文字セットに関係なく、エンコード変換は無効になります。 （ただし、サーバーの文字セットが &lt;code&gt;SQL_ASCII&lt;/code&gt; でない場合でも、サーバーは受信データがそのエンコーディングに対して有効であることを確認します。したがって、最終的な効果は、クライアントの文字セットがサーバーの文字セットと同じであるかのようになります。）サーバーの場合と同様です。 、すべてASCIIデータを使用していない限り、 &lt;code&gt;SQL_ASCII&lt;/code&gt; の使用は賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="bae7f3745b8c55d9daa52727f8674ef5381e42f5" translate="yes" xml:space="preserve">
          <source>If the client character set is defined as &lt;code&gt;SQL_ASCII&lt;/code&gt;, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of &lt;code&gt;SQL_ASCII&lt;/code&gt; is unwise unless you are working with all-ASCII data.</source>
          <target state="translated">クライアントの文字セットが &lt;code&gt;SQL_ASCII&lt;/code&gt; として定義されている場合、サーバーの文字セットに関係なく、エンコーディング変換は無効になります。サーバーの場合と &lt;code&gt;SQL_ASCII&lt;/code&gt; 、すべてのASCIIデータを処理している場合を除き、SQL_ASCIIの使用は賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="0c4deed9a95ca57073b155e9cb8a0f5097708705" translate="yes" xml:space="preserve">
          <source>If the command is written as &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; and the foreign table does not exist, no error is thrown. A notice is issued in this case.</source>
          <target state="translated">コマンドが &lt;code&gt;ALTER FOREIGN TABLE IF EXISTS ...&lt;/code&gt; として記述されていて、外部テーブルが存在しない場合、エラーはスローされません。この場合、通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="63d051a50066f7b8f700301bed696001489f1857" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written and the database will proceed to start up anyway. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), the database will not proceed with startup.</source>
          <target state="translated">コマンドがゼロ以外の終了ステータスを返した場合、警告ログメッセージが書き込まれ、データベースは起動に進みます。例外として、コマンドがシグナルやシェルによるエラー(コマンドが見つかりませんでしたなど)によって終了した場合、データベースは起動を続行しません。</target>
        </trans-unit>
        <trans-unit id="557bcc8e46db9e939ccd6eb079fcf5557fc3e866" translate="yes" xml:space="preserve">
          <source>If the command returns a nonzero exit status then a warning log message will be written. An exception is that if the command was terminated by a signal or an error by the shell (such as command not found), a fatal error will be raised.</source>
          <target state="translated">コマンドがゼロ以外の終了ステータスを返した場合、警告ログメッセージが書き込まれます。例外として、コマンドがシグナルやシェルのエラー (コマンドが見つからないなど)によって終了した場合は、致命的なエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="6a74eec2662a9cc1d1ed60748980c12a4bf53d33" translate="yes" xml:space="preserve">
          <source>If the commands themselves contain &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;COMMIT&lt;/code&gt;, or &lt;code&gt;ROLLBACK&lt;/code&gt;, this option will not have the desired effects. Also, if an individual command cannot be executed inside a transaction block, specifying this option will cause the whole transaction to fail.</source>
          <target state="translated">コマンド自体に &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;COMMIT&lt;/code&gt; 、または &lt;code&gt;ROLLBACK&lt;/code&gt; が含まれている場合、このオプションは望ましい効果をもたらしません。また、トランザクションブロック内で個々のコマンドを実行できない場合、このオプションを指定すると、トランザクション全体が失敗します。</target>
        </trans-unit>
        <trans-unit id="02b4ea2a996ab5d0d7b4386241306a8c9bd92e8f" translate="yes" xml:space="preserve">
          <source>If the compared values are of a collatable data type, the appropriate collation OID will be passed to the comparison support function, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">比較された値が照合可能なデータ型である場合、適切な照合OIDが、標準の &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; メカニズムを使用して、比較サポート関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="29c5e362afd4a1ac0e7c03190fce4c0374d970bb" translate="yes" xml:space="preserve">
          <source>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a &lt;code&gt;fetch&lt;/code&gt; function.</source>
          <target state="translated">リーフエントリに対して圧縮メソッドが不可逆的である場合、演算子クラスはインデックスのみのスキャンをサポートできず、 &lt;code&gt;fetch&lt;/code&gt; 関数を定義してはなりません。</target>
        </trans-unit>
        <trans-unit id="f7447741114d4403590357da345ba571953f8d76" translate="yes" xml:space="preserve">
          <source>If the configuration file contains syntax errors or invalid parameter names, the server will not attempt to apply any settings from it, and therefore all the &lt;code&gt;applied&lt;/code&gt; fields will read as false. In such a case there will be one or more rows with non-null &lt;code&gt;error&lt;/code&gt; fields indicating the problem(s). Otherwise, individual settings will be applied if possible. If an individual setting cannot be applied (e.g., invalid value, or the setting cannot be changed after server start) it will have an appropriate message in the &lt;code&gt;error&lt;/code&gt; field. Another way that an entry might have &lt;code&gt;applied&lt;/code&gt; = false is that it is overridden by a later entry for the same parameter name; this case is not considered an error so nothing appears in the &lt;code&gt;error&lt;/code&gt; field.</source>
          <target state="translated">構成ファイルに構文エラーまたは無効なパラメーター名が含まれている場合、サーバーはそこから設定を適用しようとしないため、 &lt;code&gt;applied&lt;/code&gt; すべてのフィールドはfalseとして読み取られます。そのような場合、問題を示すnull以外の &lt;code&gt;error&lt;/code&gt; フィールドを持つ1つ以上の行が存在します。それ以外の場合は、可能であれば個別の設定が適用されます。個別の設定を適用できない場合（無効な値、サーバーの起動後に設定を変更できない場合など）は、 &lt;code&gt;error&lt;/code&gt; フィールドに適切なメッセージが表示されます。エントリが &lt;code&gt;applied&lt;/code&gt; た別の方法= falseは、同じパラメータ名の後続のエントリによって上書きされることです。何もに表示されていないので、この場合はエラーとはみなされません &lt;code&gt;error&lt;/code&gt; フィールド。</target>
        </trans-unit>
        <trans-unit id="6846426f89420f86ff7e1053a00d20ad214d1c83" translate="yes" xml:space="preserve">
          <source>If the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is &lt;code&gt;off&lt;/code&gt;, then PostgreSQL recognizes backslash escapes in both regular and escape string constants. However, as of PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt;, meaning that backslash escapes are recognized only in escape string constants. This behavior is more standards-compliant, but might break applications which rely on the historical behavior, where backslash escapes were always recognized. As a workaround, you can set this parameter to &lt;code&gt;off&lt;/code&gt;, but it is better to migrate away from using backslash escapes. If you need to use a backslash escape to represent a special character, write the string constant with an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">構成パラメーター&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;が &lt;code&gt;off&lt;/code&gt; の場合、PostgreSQLは通常の文字列定数とエスケープ文字列定数の両方でバックスラッシュエスケープを認識します。ただし、PostgreSQL 9.1以降、デフォルトは &lt;code&gt;on&lt;/code&gt; です。つまり、バックスラッシュエスケープはエスケープ文字列定数でのみ認識されます。この動作はより標準に準拠していますが、バックスラッシュエスケープが常に認識されていた履歴動作に依存するアプリケーションを壊す可能性があります。回避策として、このパラメーターを &lt;code&gt;off&lt;/code&gt; に設定できますが、バックスラッシュエスケープの使用から移行することをお勧めします。特殊文字を表すためにバックスラッシュエスケープを使用する必要がある場合は、 &lt;code&gt;E&lt;/code&gt; を使用して文字列定数を記述します。</target>
        </trans-unit>
        <trans-unit id="7e2bc2b10438374418a16365e82e01c5a0e70ba5" translate="yes" xml:space="preserve">
          <source>If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate.</source>
          <target state="translated">何らかの理由で接続ができなかった場合(権限が足りない、サーバが対象のホストで実行されていないなど)、psqlはエラーを返して終了します。</target>
        </trans-unit>
        <trans-unit id="02930b22f9d6ca1f7733ab529d9a22a91b3fe5c0" translate="yes" xml:space="preserve">
          <source>If the connection is lost, or if it cannot be initially established, with a non-fatal error, pg_receivewal will retry the connection indefinitely, and reestablish streaming as soon as possible. To avoid this behavior, use the &lt;code&gt;-n&lt;/code&gt; parameter.</source>
          <target state="translated">接続が失われた場合、または最初に確立できない場合に致命的でないエラーが発生すると、pg_receivewalは接続を無期限に再試行し、できるだけ早くストリーミングを再確立します。この動作を回避するには、 &lt;code&gt;-n&lt;/code&gt; パラメータを使用します。</target>
        </trans-unit>
        <trans-unit id="1e7cb7e5b7e9cfa96c974efa30e7317e321f657f" translate="yes" xml:space="preserve">
          <source>If the conversion of a particular character is not possible &amp;mdash; suppose you chose &lt;code&gt;EUC_JP&lt;/code&gt; for the server and &lt;code&gt;LATIN1&lt;/code&gt; for the client, and some Japanese characters are returned that do not have a representation in &lt;code&gt;LATIN1&lt;/code&gt; &amp;mdash; an error is reported.</source>
          <target state="translated">特定の文字の変換ができない場合-あなたが選択したと仮定し &lt;code&gt;EUC_JP&lt;/code&gt; をサーバとするために &lt;code&gt;LATIN1&lt;/code&gt; クライアントのための、およびいくつかの日本語の文字は、での表現はありませんが返され &lt;code&gt;LATIN1&lt;/code&gt; を -エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="5a6f84dd517ea12fd77c796a6737968d24f658ee" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is described instead.</source>
          <target state="translated">現在のクエリバッファが空の場合、代わりに最近送信されたクエリが記述されます。</target>
        </trans-unit>
        <trans-unit id="2c57feb4352b9d0e5fa18cf7867721a0200da9c9" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead.</source>
          <target state="translated">現在のクエリバッファが空の場合、最近送信されたクエリが代わりに再実行されます。</target>
        </trans-unit>
        <trans-unit id="b8dce5eee9d2655efdc5121439aeb8029c6a8bb6" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without an argument is essentially equivalent to a semicolon. A &lt;code&gt;\g&lt;/code&gt; with argument is a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command.</source>
          <target state="translated">現在のクエリバッファが空の場合、最後に送信されたクエリが代わりに再実行されます。その動作を除いて、引数なしの &lt;code&gt;\g&lt;/code&gt; は本質的にセミコロンと同等です。引数付きの &lt;code&gt;\g&lt;/code&gt; は、 &lt;code&gt;\o&lt;/code&gt; コマンドの「ワンショット」の代替手段です。</target>
        </trans-unit>
        <trans-unit id="8f856d88c69c6abc126b1520b07a26de33c6da81" translate="yes" xml:space="preserve">
          <source>If the current query buffer is empty, the most recently sent query is re-executed instead. Except for that behavior, &lt;code&gt;\g&lt;/code&gt; without any arguments is essentially equivalent to a semicolon. With arguments, &lt;code&gt;\g&lt;/code&gt; provides a &amp;ldquo;one-shot&amp;rdquo; alternative to the &lt;code&gt;\o&lt;/code&gt; command, and additionally allows one-shot adjustments of the output formatting options normally set by &lt;code&gt;\pset&lt;/code&gt;.</source>
          <target state="translated">現在のクエリバッファが空の場合、最後に送信されたクエリが代わりに再実行されます。その動作を除いて、引数のない &lt;code&gt;\g&lt;/code&gt; は本質的にセミコロンと同等です。引数を使用すると、 &lt;code&gt;\g&lt;/code&gt; は &lt;code&gt;\o&lt;/code&gt; コマンドの「ワンショット」の代替手段を提供し、さらに &lt;code&gt;\pset&lt;/code&gt; によって通常設定される出力フォーマットオプションのワンショット調整を可能にします。</target>
        </trans-unit>
        <trans-unit id="9c1be77262ade382bd3daec36a4b4f5dfa260c3f" translate="yes" xml:space="preserve">
          <source>If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See &lt;code&gt;\pset&lt;/code&gt; for a more general solution.</source>
          <target state="translated">現在のテーブル出力形式が整列されていない場合は、整列に切り替えられます。整列されていない場合は、整列されていません。このコマンドは、下位互換性のために残されています。より一般的な解決策については、 &lt;code&gt;\pset&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="e6fb10bfb27f2916d0fe2c64c42424fe0e7351c4" translate="yes" xml:space="preserve">
          <source>If the cursor's query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;, then returned rows are locked at the time they are first fetched, in the same way as for a regular &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; command with these options. In addition, the returned rows will be the most up-to-date versions; therefore these options provide the equivalent of what the SQL standard calls a &amp;ldquo;sensitive cursor&amp;rdquo;. (Specifying &lt;code&gt;INSENSITIVE&lt;/code&gt; together with &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt; is an error.)</source>
          <target state="translated">カーソルのクエリに &lt;code&gt;FOR UPDATE&lt;/code&gt; または &lt;code&gt;FOR SHARE&lt;/code&gt; が含まれている場合、返された行は、これらのオプションを指定した通常の&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;コマンドの場合と同じように、最初にフェッチされるときにロックされます。また、返される行は最新バージョンになります。したがって、これらのオプションは、SQL標準が「センシティブカーソル」と呼ぶものと同等のものを提供します。 （ &lt;code&gt;INSENSITIVE&lt;/code&gt; を &lt;code&gt;FOR UPDATE&lt;/code&gt; または &lt;code&gt;FOR SHARE&lt;/code&gt; と一緒に指定するとエラーになります。）</target>
        </trans-unit>
        <trans-unit id="41b7137b15f53bed5b5687626dcf24e407280bf1" translate="yes" xml:space="preserve">
          <source>If the data directory allows group read access then certificate files may need to be located outside of the data directory in order to conform to the security requirements outlined above. Generally, group access is enabled to allow an unprivileged user to backup the database, and in that case the backup software will not be able to read the certificate files and will likely error.</source>
          <target state="translated">データ・ディレクトリがグループ・リード・アクセスを許可している場合、上記のセキュリティ要件を満たすために、証明書ファイルをデータ・ディレクトリの外に配置する必要があるかもしれません。一般的に、グループアクセスは、権限のないユーザがデータベースをバックアップするために有効になっており、その場合、バックアップソフトウェアは証明書ファイルを読み取ることができず、エラーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a675fdbbcb3f3826a4060560a5255875fb5f5fae" translate="yes" xml:space="preserve">
          <source>If the database crashes during the risk window between an asynchronous commit and the writing of the transaction's WAL records, then changes made during that transaction &lt;em&gt;will&lt;/em&gt; be lost. The duration of the risk window is limited because a background process (the &amp;ldquo;WAL writer&amp;rdquo;) flushes unwritten WAL records to disk every &lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt; milliseconds. The actual maximum duration of the risk window is three times &lt;code&gt;wal_writer_delay&lt;/code&gt; because the WAL writer is designed to favor writing whole pages at a time during busy periods.</source>
          <target state="translated">非同期間のリスク・ウィンドウ中にデータベースがクラッシュしたコミットとトランザクションのWALレコードの書き込みした場合、そのトランザクション中に行われた変更&lt;em&gt;されます&lt;/em&gt;失われます。バックグラウンドプロセス（「WALライター」）が&lt;a href=&quot;runtime-config-wal#GUC-WAL-WRITER-DELAY&quot;&gt;wal_writer_delay&lt;/a&gt;ミリ秒ごとに書き込まれていないWALレコードをディスクにフラッシュするため、リスクウィンドウの期間は制限されます。WALライターはビジー期間中に一度にページ全体を書き込むように設計されているため、リスクウィンドウの実際の最大期間は &lt;code&gt;wal_writer_delay&lt;/code&gt; の 3倍です。</target>
        </trans-unit>
        <trans-unit id="74cf7d60a58d8b38555b75db3e52ebabab25c716" translate="yes" xml:space="preserve">
          <source>If the distance function returns &lt;code&gt;*recheck = true&lt;/code&gt; for any leaf node, the original ordering operator's return type must be &lt;code&gt;float8&lt;/code&gt; or &lt;code&gt;float4&lt;/code&gt;, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite &lt;code&gt;float8&lt;/code&gt; values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that &lt;code&gt;distance&lt;/code&gt; functions return these values.)</source>
          <target state="translated">いずれかのリーフノードに対して距離関数が &lt;code&gt;*recheck = true&lt;/code&gt; を返す場合、元の順序付け演算子の戻り値の型は &lt;code&gt;float8&lt;/code&gt; または &lt;code&gt;float4&lt;/code&gt; である必要があり、距離関数の結果値は元の順序付け演算子の結果値と同等でなければなりません。距離関数の結果と再計算された順序演算子の結果。それ以外の場合、距離関数の結果値は、結果値の相対順序が順序付け演算子によって返される順序と一致する限り、任意の有限の &lt;code&gt;float8&lt;/code&gt; 値にすることができます。 （無限大とマイナス無限大はnullなどのケースを処理するために内部的に使用されるため、 &lt;code&gt;distance&lt;/code&gt; 関数がこれらの値を返すことはお勧めしません。）</target>
        </trans-unit>
        <trans-unit id="ad60be7600e8f04e894b95d59df12f985784fcd2" translate="yes" xml:space="preserve">
          <source>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</source>
          <target state="translated">いずれかの列の式が正しいデータ型でない場合、自動型変換が試みられます。</target>
        </trans-unit>
        <trans-unit id="fd093b6fb186aee51925fae308b6305eb633a2c9" translate="yes" xml:space="preserve">
          <source>If the extension specifies a &lt;code&gt;schema&lt;/code&gt; parameter in its control file, then that schema cannot be overridden with a &lt;code&gt;SCHEMA&lt;/code&gt; clause. Normally, an error will be raised if a &lt;code&gt;SCHEMA&lt;/code&gt; clause is given and it conflicts with the extension's &lt;code&gt;schema&lt;/code&gt; parameter. However, if the &lt;code&gt;CASCADE&lt;/code&gt; clause is also given, then &lt;code&gt;schema_name&lt;/code&gt; is ignored when it conflicts. The given &lt;code&gt;schema_name&lt;/code&gt; will be used for installation of any needed extensions that do not specify &lt;code&gt;schema&lt;/code&gt; in their control files.</source>
          <target state="translated">拡張機能がその制御ファイルで &lt;code&gt;schema&lt;/code&gt; パラメータを指定している場合、そのスキーマは &lt;code&gt;SCHEMA&lt;/code&gt; 句でオーバーライドできません。通常、 &lt;code&gt;SCHEMA&lt;/code&gt; 句が指定され、拡張の &lt;code&gt;schema&lt;/code&gt; パラメータと競合する場合、エラーが発生します。ただし、 &lt;code&gt;CASCADE&lt;/code&gt; 句も指定されている場合、 &lt;code&gt;schema_name&lt;/code&gt; は競合しても無視されます。指定された &lt;code&gt;schema_name&lt;/code&gt; は、制御ファイルで &lt;code&gt;schema&lt;/code&gt; を指定しない必要な拡張機能のインストールに使用されます。</target>
        </trans-unit>
        <trans-unit id="a4e9fcc86b43f21a64730501e9eaf321852f905e" translate="yes" xml:space="preserve">
          <source>If the file name is not an absolute path, it is taken as relative to the directory containing the referencing configuration file. Inclusions can be nested.</source>
          <target state="translated">ファイル名が絶対パスでない場合は、参照する設定ファイルを含むディレクトリからの相対パスとして扱われます。インクルードは入れ子にすることができます。</target>
        </trans-unit>
        <trans-unit id="932910bcbd5980a518e91a591612aedc56d65e69" translate="yes" xml:space="preserve">
          <source>If the final function is declared &amp;ldquo;strict&amp;rdquo;, then it will not be called when the ending state value is null; instead a null result will be returned automatically. (Of course this is just the normal behavior of strict functions.) In any case the final function has the option of returning a null value. For example, the final function for &lt;code&gt;avg&lt;/code&gt; returns null when it sees there were zero input rows.</source>
          <target state="translated">最終関数が「厳密」に宣言されている場合、終了状態の値がnullのときは呼び出されません。代わりに、nullの結果が自動的に返されます。（もちろん、これは厳密な関数の通常の動作にすぎません。）いずれの場合も、最終関数にはnull値を返すオプションがあります。たとえば、 &lt;code&gt;avg&lt;/code&gt; の最後の関数は、入力行がゼロであることがわかるとnullを返します。</target>
        </trans-unit>
        <trans-unit id="8ca5420e4e4f7f8c6273c3bc64bbb9997a4e67c8" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written (nor is the first argument).</source>
          <target state="translated">最初の引数が引用符で囲まれていない &lt;code&gt;-n&lt;/code&gt; の場合、末尾の改行は書き込まれません（最初の引数も書き込まれません）。</target>
        </trans-unit>
        <trans-unit id="6a7650c2a7562a29717aee3a080c7db1eba72918" translate="yes" xml:space="preserve">
          <source>If the first argument is an unquoted &lt;code&gt;-n&lt;/code&gt; the trailing newline is not written.</source>
          <target state="translated">最初の引数が引用符で囲まれていない &lt;code&gt;-n&lt;/code&gt; の場合、末尾の改行は書き込まれません。</target>
        </trans-unit>
        <trans-unit id="62fe782183ded831fa81846fd49b8967105614ff" translate="yes" xml:space="preserve">
          <source>If the function has been defined as returning the &lt;code&gt;record&lt;/code&gt; data type, then an alias or the key word &lt;code&gt;AS&lt;/code&gt; must be present, followed by a column definition list in the form &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt;. The column definition list must match the actual number and types of columns returned by the function.</source>
          <target state="translated">関数が &lt;code&gt;record&lt;/code&gt; データ型を返すように定義されている場合、エイリアスまたはキーワード &lt;code&gt;AS&lt;/code&gt; が存在し、その後に &lt;code&gt;( column_name data_type [, ... ])&lt;/code&gt; という形式の列定義リストが続く必要があります。列定義リストは、関数によって返される列の実際の数とタイプと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="dbc510e12f6154bfb8e0fdb71a70e5f4d7892b1d" translate="yes" xml:space="preserve">
          <source>If the function name is unique in its schema, it can be referred to without an argument list:</source>
          <target state="translated">関数名がスキーマ内で一意であれば、引数リストなしで参照することができます。</target>
        </trans-unit>
        <trans-unit id="02e65f28de3d6ebb00042e2e3e922f9485dd13f2" translate="yes" xml:space="preserve">
          <source>If the index AM wishes to cache data across successive index insertions within a SQL statement, it can allocate space in &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; and store a pointer to the data in &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; (which will be NULL initially).</source>
          <target state="translated">インデックスAMがSQLステートメント内の連続するインデックス挿入にわたってデータをキャッシュしたい場合は、 &lt;code&gt;indexInfo-&amp;gt;ii_Context&lt;/code&gt; にスペースを割り当て、データへのポインターを &lt;code&gt;indexInfo-&amp;gt;ii_AmCache&lt;/code&gt; （最初はNULLになる）に格納できます。</target>
        </trans-unit>
        <trans-unit id="152cfa54f1f6aaa3c6f3e246889a7fbd92291904" translate="yes" xml:space="preserve">
          <source>If the index marked &lt;code&gt;INVALID&lt;/code&gt; is suffixed &lt;code&gt;ccnew&lt;/code&gt;, then it corresponds to the transient index created during the concurrent operation, and the recommended recovery method is to drop it using &lt;code&gt;DROP INDEX&lt;/code&gt;, then attempt &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; again. If the invalid index is instead suffixed &lt;code&gt;ccold&lt;/code&gt;, it corresponds to the original index which could not be dropped; the recommended recovery method is to just drop said index, since the rebuild proper has been successful.</source>
          <target state="translated">&lt;code&gt;INVALID&lt;/code&gt; とマークされたインデックスの末尾に &lt;code&gt;ccnew&lt;/code&gt; が付いている場合、それは並行操作中に作成された一時インデックスに対応します。推奨されるリカバリ方法は、 &lt;code&gt;DROP INDEX&lt;/code&gt; を使用してインデックスを削除してから、 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 再試行することです。無効なインデックスに &lt;code&gt;ccold&lt;/code&gt; という接尾辞が付いている場合は、削除できなかった元のインデックスに対応します。適切な再構築が成功したため、推奨される回復方法は、上記のインデックスを削除することです。</target>
        </trans-unit>
        <trans-unit id="65ff53fe7f3af3df2bf9787931d50cb513ad0685" translate="yes" xml:space="preserve">
          <source>If the index stores the original indexed data values (and not some lossy representation of them), it is useful to support &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt;, in which the index returns the actual data not just the TID of the heap tuple. This will only avoid I/O if the visibility map shows that the TID is on an all-visible page; else the heap tuple must be visited anyway to check MVCC visibility. But that is no concern of the access method's.</source>
          <target state="translated">インデックスが元のインデックス付きデータ値を格納している場合（それらの損失のある表現ではない）、&lt;a href=&quot;indexes-index-only-scans&quot;&gt;インデックスのみのスキャン&lt;/a&gt;をサポートすると便利です。この場合、インデックスはヒープタプルのTIDだけでなく実際のデータを返します。これにより、TIDがすべて表示可能なページにあることが表示マップに示されている場合にのみ、I / Oが回避されます。それ以外の場合は、MVCCの可視性を確認するためにヒープタプルにアクセスする必要があります。しかし、それはアクセス方法の問題ではありません。</target>
        </trans-unit>
        <trans-unit id="b10149280f25e55a72b1c339ba61c4a0b943ec93" translate="yes" xml:space="preserve">
          <source>If the index supports &lt;a href=&quot;indexes-index-only-scans&quot;&gt;index-only scans&lt;/a&gt; (i.e., &lt;code&gt;amcanreturn&lt;/code&gt; returns true for it), then on success the AM must also check &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt;, and if that is true it must return the originally indexed data for the index entry. The data can be returned in the form of an &lt;code&gt;IndexTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt;; or in the form of a &lt;code&gt;HeapTuple&lt;/code&gt; pointer stored at &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt;, with tuple descriptor &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt;. (The latter format should be used when reconstructing data that might possibly not fit into an &lt;code&gt;IndexTuple&lt;/code&gt;.) In either case, management of the data referenced by the pointer is the access method's responsibility. The data must remain good at least until the next &lt;code&gt;amgettuple&lt;/code&gt;, &lt;code&gt;amrescan&lt;/code&gt;, or &lt;code&gt;amendscan&lt;/code&gt; call for the scan.</source>
          <target state="translated">インデックスが&lt;a href=&quot;indexes-index-only-scans&quot;&gt;インデックスのみのスキャンを&lt;/a&gt;サポートしている場合（つまり、 &lt;code&gt;amcanreturn&lt;/code&gt; がtrueを返す場合）、成功した場合、AMは &lt;code&gt;scan-&amp;gt;xs_want_itup&lt;/code&gt; もチェックする必要があり、trueの場合、インデックスエントリの元のインデックス付きデータを返す必要があります。データは、の形式で戻すことができる &lt;code&gt;IndexTuple&lt;/code&gt; ので保存ポインタ &lt;code&gt;scan-&amp;gt;xs_itup&lt;/code&gt; タプル記述子と、 &lt;code&gt;scan-&amp;gt;xs_itupdesc&lt;/code&gt; 。またはの形で &lt;code&gt;HeapTuple&lt;/code&gt; のポインタで保存 &lt;code&gt;scan-&amp;gt;xs_hitup&lt;/code&gt; タプル記述子と、 &lt;code&gt;scan-&amp;gt;xs_hitupdesc&lt;/code&gt; 。 （後者の形式は、 &lt;code&gt;IndexTuple&lt;/code&gt; に適合しない可能性があるデータを再構築するときに使用する必要があります。）どちらの場合でも、ポインターによって参照されるデータの管理は、アクセスメソッドの責任です。データは、少なくともスキャンに対する次の &lt;code&gt;amgettuple&lt;/code&gt; 、 &lt;code&gt;amrescan&lt;/code&gt; 、または &lt;code&gt;amendscan&lt;/code&gt; の呼び出しまで、良好な状態を維持する必要があります。</target>
        </trans-unit>
        <trans-unit id="5e5145a56a8fb3d00823c8f07c0c1ff1ea7857b4" translate="yes" xml:space="preserve">
          <source>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; mechanism.</source>
          <target state="translated">インデックス付けされた列が照合可能なデータ型である場合、インデックス照合は、標準の &lt;code&gt;PG_GET_COLLATION()&lt;/code&gt; メカニズムを使用して、すべてのサポートメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="7d0af38ac011e98a3b87862ced9f4ed1d8303136" translate="yes" xml:space="preserve">
          <source>If the installation process completes without error, you can now start the server normally.</source>
          <target state="translated">エラーなくインストールが完了すれば、正常にサーバーを起動できるようになりました。</target>
        </trans-unit>
        <trans-unit id="801fad259abb36ce1c379ee710b758c893dc848e" translate="yes" xml:space="preserve">
          <source>If the internal structure of &lt;code&gt;box&lt;/code&gt; were an array of four &lt;code&gt;float4&lt;/code&gt; elements, we might instead use:</source>
          <target state="translated">&lt;code&gt;box&lt;/code&gt; の内部構造が4つの &lt;code&gt;float4&lt;/code&gt; 要素の配列である場合は、代わりに次を使用できます。</target>
        </trans-unit>
        <trans-unit id="e0cb06bd991e3803ab381ac962733573ec921a97" translate="yes" xml:space="preserve">
          <source>If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed.</source>
          <target state="translated">分離レベル、読み取り/書き込みモード、または遅延可能モードが指定されている場合、新しいトランザクションには、&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;が実行された場合と同様の特性があります。</target>
        </trans-unit>
        <trans-unit id="635140eb0238daad7904445c051be894be230f98" translate="yes" xml:space="preserve">
          <source>If the item to retrieve is an element of an array, you have to unnest this array using the &lt;code&gt;[*]&lt;/code&gt; operator. For example, the following path will return location coordinates for all the available track segments:</source>
          <target state="translated">取得する項目が配列の要素である場合、 &lt;code&gt;[*]&lt;/code&gt; 演算子を使用してこの配列をネスト解除する必要があります。たとえば、次のパスは、使用可能なすべてのトラックセグメントの位置座標を返します。</target>
        </trans-unit>
        <trans-unit id="97c86aa6976c29ec1d54566b16ef172364cf2f75" translate="yes" xml:space="preserve">
          <source>If the key is larger than the hash block size it will first be hashed and the result will be used as key.</source>
          <target state="translated">キーがハッシュブロックのサイズよりも大きい場合は、最初にハッシュ化され、その結果がキーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="1aa8d866b0b556edb093be4c9a0ab389395324da" translate="yes" xml:space="preserve">
          <source>If the last path item is an object key, it will be created if it is absent and given the new value. If the last path item is an array index, if it is positive the item to set is found by counting from the left, and if negative by counting from the right - &lt;code&gt;-1&lt;/code&gt; designates the rightmost element, and so on. If the item is out of the range -array_length .. array_length -1, and create_missing is true, the new value is added at the beginning of the array if the item is negative, and at the end of the array if it is positive.</source>
          <target state="translated">最後のパス項目がオブジェクトキーである場合、それが存在せず、新しい値が指定されると作成されます。最後のパス項目が配列インデックスである場合、それが正である場合には、設定する項目は左から計数によって発見され、右から数えによる負場合- &lt;code&gt;-1&lt;/code&gt; 右端の要素を指定する、というように。項目が-array_length .. array_length -1の範囲外であり、create_missingがtrueの場合、項目が負の場合は配列の先頭に、正の場合は配列の末尾に新しい値が追加されます。</target>
        </trans-unit>
        <trans-unit id="2188ba6147e78aaca8d5a46e0dc7277dd7c3324b" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;n&lt;/code&gt; (&amp;ldquo;nested&amp;rdquo;) is used, or a pattern is specified, then non-root partitioned relations are included, and a column is shown displaying the parent of each partitioned relation.</source>
          <target state="translated">修飾子 &lt;code&gt;n&lt;/code&gt; （「ネストされた」）が使用されているか、パターンが指定されている場合、非ルートの分割された関係が含まれ、各分割された関係の親を表示する列が表示されます。</target>
        </trans-unit>
        <trans-unit id="954bfa7fec82935e3cdcd8281374d6651335948e" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">新しい接続が成功した場合、前の接続は閉じられます。接続の試みが失敗した場合(ユーザ名が間違っている、アクセスが拒否されたなど)、前の接続はpsqlが対話型モードの場合にのみ保持されます。非対話型スクリプトを実行すると、処理は直ちにエラーで停止します。この区別は、一方ではタイプミスに対するユーザの利便性、他方ではスクリプトが誤って間違ったデータベース上で動作しないようにするための安全機構として選ばれました。</target>
        </trans-unit>
        <trans-unit id="f53d72a1eae9ceb05fc2fcc17f8301adebb27e79" translate="yes" xml:space="preserve">
          <source>If the new connection is successfully made, the previous connection is closed. If the connection attempt fails (wrong user name, access denied, etc.), the previous connection will be kept if psql is in interactive mode. But when executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand.</source>
          <target state="translated">新しい接続が成功した場合、前の接続は閉じられます。接続の試みが失敗した場合(ユーザ名が間違っている、アクセスが拒否されたなど)、psqlが対話型モードであれば、前の接続は保持されます。しかし、非対話型スクリプトを実行すると、処理は直ちにエラーで停止します。この区別は、一方ではタイプミスに対するユーザの利便性、他方ではスクリプトが誤って間違ったデータベース上で動作しないようにするための安全機構として選ばれました。</target>
        </trans-unit>
        <trans-unit id="2a5e26aea388ddd76a8f217c381769165be706df" translate="yes" xml:space="preserve">
          <source>If the new partition is a foreign table, nothing is done to verify that all the rows in the foreign table obey the partition constraint. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; about constraints on the foreign table.)</source>
          <target state="translated">新しいパーティションが外部テーブルである場合、外部テーブルのすべての行がパーティションの制約に従っていることを確認するための処理は行われません。（外部テーブルの制約については、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLEの&lt;/a&gt;説明を参照してください。）</target>
        </trans-unit>
        <trans-unit id="f277321bdd9057205b2810a53bafd6facd91f266" translate="yes" xml:space="preserve">
          <source>If the new partition is a regular table, a full table scan is performed to check that existing rows in the table do not violate the partition constraint. It is possible to avoid this scan by adding a valid &lt;code&gt;CHECK&lt;/code&gt; constraint to the table that allows only rows satisfying the desired partition constraint before running this command. The &lt;code&gt;CHECK&lt;/code&gt; constraint will be used to determine that the table need not be scanned to validate the partition constraint. This does not work, however, if any of the partition keys is an expression and the partition does not accept &lt;code&gt;NULL&lt;/code&gt; values. If attaching a list partition that will not accept &lt;code&gt;NULL&lt;/code&gt; values, also add &lt;code&gt;NOT NULL&lt;/code&gt; constraint to the partition key column, unless it's an expression.</source>
          <target state="translated">新しいパーティションが通常のテーブルの場合、テーブル内の既存の行がパーティションの制約に違反していないことを確認するために、テーブル全体のスキャンが実行されます。このコマンドを実行する前に、目的のパーティション制約を満たす行のみを許可する有効な &lt;code&gt;CHECK&lt;/code&gt; 制約をテーブルに追加することで、このスキャンを回避できます。 &lt;code&gt;CHECK&lt;/code&gt; 制約は、テーブルがパーティション制約を検証するためにスキャンする必要がないことを決定するために使用されます。ただし、パーティションキーのいずれかが式であり、パーティションが &lt;code&gt;NULL&lt;/code&gt; 値を受け入れない場合、これは機能しません。 &lt;code&gt;NULL&lt;/code&gt; 値を受け入れないリストパーティションをアタッチする場合は、 &lt;code&gt;NOT NULL&lt;/code&gt; も追加します 式でない限り、パーティションキー列への制約。</target>
        </trans-unit>
        <trans-unit id="48a04ec2659d2ed3b669f8d3fed6c4aa6cc05212" translate="yes" xml:space="preserve">
          <source>If the new value is inconsistent with the tuple prefix, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgSplitTuple&lt;/code&gt;. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set &lt;code&gt;prefixHasPrefix&lt;/code&gt; to indicate whether the new upper tuple should have a prefix, and if so set &lt;code&gt;prefixPrefixDatum&lt;/code&gt; to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set &lt;code&gt;prefixNNodes&lt;/code&gt; to the number of nodes needed in the new tuple, and set &lt;code&gt;prefixNodeLabels&lt;/code&gt; to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set &lt;code&gt;childNodeN&lt;/code&gt; to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set &lt;code&gt;postfixHasPrefix&lt;/code&gt; to indicate whether the new lower-level inner tuple should have a prefix, and if so set &lt;code&gt;postfixPrefixDatum&lt;/code&gt; to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the &lt;code&gt;choose&lt;/code&gt; function will be called again with the replacement inner tuple. That call may return an &lt;code&gt;spgAddNode&lt;/code&gt; result, if no suitable node was created by the &lt;code&gt;spgSplitTuple&lt;/code&gt; action. Eventually &lt;code&gt;choose&lt;/code&gt; must return &lt;code&gt;spgMatchNode&lt;/code&gt; to allow the insertion to descend to the next level.</source>
          <target state="translated">新しい値がタプルのプレフィックスと一致しない場合は、 &lt;code&gt;resultType&lt;/code&gt; を &lt;code&gt;spgSplitTuple&lt;/code&gt; に設定します。このアクションは、既存のすべてのノードを新しい下位レベルの内部タプルに移動し、既存の内部タプルを、新しい下位レベルの内部タプルを指す単一のダウンリンクを持つタプルに置き換えます。 &lt;code&gt;prefixHasPrefix&lt;/code&gt; を設定して、新しい上位タプルにプレフィックスを付ける必要があるかどうかを示し、必要な場合は、 &lt;code&gt;prefixPrefixDatum&lt;/code&gt; をプレフィックス値に設定します。この新しいプレフィックス値は、インデックス付けされる新しい値を受け入れるために、元のプレフィックス値よりも元の値よりも制限が十分に小さくなければなりません。セット &lt;code&gt;prefixNNodes&lt;/code&gt; 新しいタプルに必要なノード数に、設定 &lt;code&gt;prefixNodeLabels&lt;/code&gt; ラベルを保持するpallocされた配列、またはノードラベルが不要な場合はNULL。新しい上位タプルの合計サイズは、置換するタプルの合計サイズ以下でなければならないことに注意してください。これにより、新しいプレフィックスと新しいラベルの長さが制限されます。セット &lt;code&gt;childNodeN&lt;/code&gt; 新しい下位内側タプルへのダウンリンクするノードの（ゼロから）インデックス。 &lt;code&gt;postfixHasPrefix&lt;/code&gt; を設定して、新しい下位レベルの内部タプルに接頭辞を付ける必要があるかどうかを示し、必要な場合は &lt;code&gt;postfixPrefixDatum&lt;/code&gt; を設定します。プレフィックス値に。これらの2つのプレフィックスとダウンリンクノードのラベル（存在する場合）の組み合わせは、元のプレフィックスと同じ意味を持つ必要があります。これは、新しい下位レベルのタプルに移動されるノードラベルを変更したり、変更したりする機会がないためです。子インデックスエントリ。ノードが分割された後、 &lt;code&gt;choose&lt;/code&gt; した内部タプルを使用してchoose関数が再度呼び出されます。 &lt;code&gt;spgSplitTuple&lt;/code&gt; アクションによって適切なノードが作成されなかった場合、その呼び出しは &lt;code&gt;spgAddNode&lt;/code&gt; 結果を返す可能性があります。最終的に &lt;code&gt;choose&lt;/code&gt; 返さなければなりません &lt;code&gt;spgMatchNode&lt;/code&gt; を挿入が次のレベルに降りることができるように。</target>
        </trans-unit>
        <trans-unit id="cad207ddb2eaf025fe9a90fd7f853c4606a19762" translate="yes" xml:space="preserve">
          <source>If the new value matches one of the existing child nodes, set &lt;code&gt;resultType&lt;/code&gt; to &lt;code&gt;spgMatchNode&lt;/code&gt;. Set &lt;code&gt;nodeN&lt;/code&gt; to the index (from zero) of that node in the node array. Set &lt;code&gt;levelAdd&lt;/code&gt; to the increment in &lt;code&gt;level&lt;/code&gt; caused by descending through that node, or leave it as zero if the operator class does not use levels. Set &lt;code&gt;restDatum&lt;/code&gt; to equal &lt;code&gt;leafDatum&lt;/code&gt; if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as &lt;code&gt;leafDatum&lt;/code&gt; at the next level.</source>
          <target state="translated">新しい値が既存の子ノードのいずれかに一致する場合は、 &lt;code&gt;resultType&lt;/code&gt; を &lt;code&gt;spgMatchNode&lt;/code&gt; に設定します。 &lt;code&gt;nodeN&lt;/code&gt; を、ノード配列内のそのノードの（ゼロからの）インデックスに設定します。 &lt;code&gt;levelAdd&lt;/code&gt; を、そのノードを介して下降することによって生じる &lt;code&gt;level&lt;/code&gt; の増分に設定するか、演算子クラスがレベル​​を使用しない場合はゼロのままにします。セット &lt;code&gt;restDatum&lt;/code&gt; は等しい &lt;code&gt;leafDatum&lt;/code&gt; をオペレータクラスは、次の1つのレベルから基準点を変更しない場合、または他の方法として使用される変更された値に設定 &lt;code&gt;leafDatum&lt;/code&gt; 次のレベルで。</target>
        </trans-unit>
        <trans-unit id="b192c266d3e1a4a0032d805a8345acd4fec22c20" translate="yes" xml:space="preserve">
          <source>If the non-unknown inputs are not all of the same type category, fail.</source>
          <target state="translated">不明な入力がすべて同じタイプのカテゴリではない場合は失敗します。</target>
        </trans-unit>
        <trans-unit id="21b9de4f5d381ca1caadda7c1730c20093d98952" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a colon (&lt;code&gt;:&lt;/code&gt;), this is a time string. Include all subsequent digits and colons.</source>
          <target state="translated">（数値トークンにコロンが含まれている場合 &lt;code&gt;:&lt;/code&gt; ）、これは時間の文字列です。後続のすべての数字とコロンを含めます。</target>
        </trans-unit>
        <trans-unit id="31a587270029792d925fa073ce1717b2b1a5ee50" translate="yes" xml:space="preserve">
          <source>If the numeric token contains a dash (&lt;code&gt;-&lt;/code&gt;), slash (&lt;code&gt;/&lt;/code&gt;), or two or more dots (&lt;code&gt;.&lt;/code&gt;), this is a date string which might have a text month. If a date token has already been seen, it is instead interpreted as a time zone name (e.g., &lt;code&gt;America/New_York&lt;/code&gt;).</source>
          <target state="translated">数値トークンにダッシュ（ &lt;code&gt;-&lt;/code&gt; ）、スラッシュ（ &lt;code&gt;/&lt;/code&gt; ）、または2つ以上のドット（ &lt;code&gt;.&lt;/code&gt; ）が含まれている場合、これは日付の文字列で、テキストの月が含まれる場合があります。日付トークンがすでに表示されている場合は、代わりにタイムゾーン名として解釈されます（たとえば、 &lt;code&gt;America/New_York&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2ee076bf4dbead171f4fb25426abca0b1193f6e2" translate="yes" xml:space="preserve">
          <source>If the operating system provides support for using multiple locales within a single program (&lt;code&gt;newlocale&lt;/code&gt; and related functions), or if support for ICU is configured, then when a database cluster is initialized, &lt;code&gt;initdb&lt;/code&gt; populates the system catalog &lt;code&gt;pg_collation&lt;/code&gt; with collations based on all the locales it finds in the operating system at the time.</source>
          <target state="translated">オペレーティングシステムが単一のプログラム内で複数のロケールを使用するためのサポート（ &lt;code&gt;newlocale&lt;/code&gt; および関連する機能）を提供する場合、またはICUのサポートが構成されている場合、データベースクラスターが初期化されると、 &lt;code&gt;initdb&lt;/code&gt; はシステムカタログ &lt;code&gt;pg_collation&lt;/code&gt; にすべてのロケールに基づく照合順序を設定しますそれはその時オペレーティングシステムで見つけます。</target>
        </trans-unit>
        <trans-unit id="ac5399d971a7de7c9b73abf76e58c0bf1b2aae3d" translate="yes" xml:space="preserve">
          <source>If the operation does not complete within the timeout (see option &lt;code&gt;-t&lt;/code&gt;), then &lt;code&gt;pg_ctl&lt;/code&gt; exits with a nonzero exit status. But note that the operation might continue in the background and eventually succeed.</source>
          <target state="translated">操作がタイムアウト時間内に完了しない場合（オプション &lt;code&gt;-t&lt;/code&gt; を参照）、 &lt;code&gt;pg_ctl&lt;/code&gt; はゼロ以外の終了ステータスで終了します。ただし、操作はバックグラウンドで続行され、最終的には成功する場合があります。</target>
        </trans-unit>
        <trans-unit id="14ab0f7eed5fb08edbafe519f61a48bda6216b85" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;NO CYCLE&lt;/code&gt; key word is specified, any calls to &lt;code&gt;nextval&lt;/code&gt; after the sequence has reached its maximum value will return an error. If neither &lt;code&gt;CYCLE&lt;/code&gt; or &lt;code&gt;NO CYCLE&lt;/code&gt; are specified, the old cycle behavior will be maintained.</source>
          <target state="translated">オプションの &lt;code&gt;NO CYCLE&lt;/code&gt; キーワードが指定されている場合、シーケンスが最大値に達した後に &lt;code&gt;nextval&lt;/code&gt; を呼び出すと、エラーが返されます。 &lt;code&gt;CYCLE&lt;/code&gt; も &lt;code&gt;NO CYCLE&lt;/code&gt; も指定されていない場合、古いサイクルの動作が維持されます。</target>
        </trans-unit>
        <trans-unit id="2dc933189fc3de8b16aa112ce975759af1f0b257" translate="yes" xml:space="preserve">
          <source>If the optional Boolean parameter &lt;code&gt;collatable&lt;/code&gt; is true, column definitions and expressions of the type may carry collation information through use of the &lt;code&gt;COLLATE&lt;/code&gt; clause. It is up to the implementations of the functions operating on the type to actually make use of the collation information; this does not happen automatically merely by marking the type collatable.</source>
          <target state="translated">オプションのブールパラメーター &lt;code&gt;collatable&lt;/code&gt; がtrueの場合、 &lt;code&gt;COLLATE&lt;/code&gt; 句を使用して、列の定義と型の式に照合情報を含めることができます。照合情報を実際に利用するのは、型で動作する関数の実装次第です。これは、タイプを照合可能としてマークするだけでは自動的には発生しません。</target>
        </trans-unit>
        <trans-unit id="bdfeb01a261949b7092b2cbd814cde7a65edc244" translate="yes" xml:space="preserve">
          <source>If the ordering of siblings of the same parent is important, include the &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; parameter to specify which field to order siblings by. This field can be of any sortable data type. The output column list must include a final integer serial-number column, if and only if &lt;em&gt;&lt;code&gt;orderby_fld&lt;/code&gt;&lt;/em&gt; is specified.</source>
          <target state="translated">同じ親の兄弟の順序が重要な場合は、&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;パラメーターを含めて、&lt;em&gt;兄弟を順序付ける&lt;/em&gt;フィールドを指定します。このフィールドは、任意の並べ替え可能なデータ型にすることができます。&lt;em&gt; &lt;code&gt;orderby_fld&lt;/code&gt; &lt;/em&gt;が指定されている場合にのみ、出力列リストに最終整数のシリアル番号列を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="3ed5ab7fc15ec983050d9cabedbfee6290fa8126" translate="yes" xml:space="preserve">
          <source>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</source>
          <target state="translated">出力列が複合(行)型で、JSON値がJSONオブジェクトの場合、これらのルールを再帰的に適用することで、オブジェクトのフィールドが出力行型の列に変換されます。</target>
        </trans-unit>
        <trans-unit id="c25ff23eb72be3bfb20da8609dc04d07dc26b478" translate="yes" xml:space="preserve">
          <source>If the output column is of type &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;, the JSON value is just reproduced exactly.</source>
          <target state="translated">出力列のタイプが &lt;code&gt;json&lt;/code&gt; または &lt;code&gt;jsonb&lt;/code&gt; の場合、JSON値は正確に再現されます。</target>
        </trans-unit>
        <trans-unit id="50b9656459eac8e751efab8869d145ae99f220b8" translate="yes" xml:space="preserve">
          <source>If the password is encrypted with SCRAM-SHA-256, it has the format:</source>
          <target state="translated">パスワードがSCRAM-SHA-256で暗号化されている場合は、その形式になります。</target>
        </trans-unit>
        <trans-unit id="d0f9a0afdced3c84c5a56565915bd16c67d24a36" translate="yes" xml:space="preserve">
          <source>If the path expression returns an empty node-set (typically, when it does not match) for a given row, the column will be set to &lt;code&gt;NULL&lt;/code&gt;, unless a &lt;code&gt;default_expression&lt;/code&gt; is specified; then the value resulting from evaluating that expression is used.</source>
          <target state="translated">パス式が特定の行に対して空のノードセットを返す場合（通常、一致しない場合）、 &lt;code&gt;default_expression&lt;/code&gt; が指定されていない限り、列は &lt;code&gt;NULL&lt;/code&gt; に設定されます。次に、その式を評価した結果の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="e0c947f55da31c1d5c1555adf98bd354dc366c84" translate="yes" xml:space="preserve">
          <source>If the primary is isolated from remaining standby servers you should fail over to the best candidate of those other remaining standby servers.</source>
          <target state="translated">プライマリが残りのスタンバイサーバから分離されている場合は、残りのスタンバイサーバの中で最も優れた候補にフェイルオーバーする必要があります。</target>
        </trans-unit>
        <trans-unit id="fa67ddcebd2151f0eb68edd839f12d39677af43a" translate="yes" xml:space="preserve">
          <source>If the primary server fails and the standby server becomes the new primary, and then the old primary restarts, you must have a mechanism for informing the old primary that it is no longer the primary. This is sometimes known as STONITH (Shoot The Other Node In The Head), which is necessary to avoid situations where both systems think they are the primary, which will lead to confusion and ultimately data loss.</source>
          <target state="translated">プライマリサーバが故障してスタンバイサーバが新しいプライマリになり、古いプライマリが再起動した場合、古いプライマリがプライマリではなくなったことを古いプライマリに知らせる仕組みが必要です。これは STONITH (Shoot The Other Node In The Head)と呼ばれることもありますが、両方のシステムが自分たちがプライマリだと思い込んでしまい、混乱を招き、最終的にはデータの損失につながるような状況を避けるために必要です。</target>
        </trans-unit>
        <trans-unit id="5ef10647b0698fbedd9383d4669217342caae5e0" translate="yes" xml:space="preserve">
          <source>If the primary server fails then the standby server should begin failover procedures.</source>
          <target state="translated">プライマリサーバに障害が発生した場合、スタンバイサーバはフェイルオーバー手順を開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="3c8481924c3ba4dda86247ddbf4dd7292be6f835" translate="yes" xml:space="preserve">
          <source>If the private key is protected with a passphrase, the server will prompt for the passphrase and will not start until it has been entered. Using a passphrase by default disables the ability to change the server's SSL configuration without a server restart, but see &lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reload&lt;/a&gt;. Furthermore, passphrase-protected private keys cannot be used at all on Windows.</source>
          <target state="translated">秘密鍵がパスフレーズで保護されている場合、サーバーはパスフレーズの入力を要求し、パスフレーズが入力されるまで起動しません。デフォルトでパスフレーズを使用すると、サーバーを再起動せずにサーバーのSSL構成を変更する機能が無効になりますが、&lt;a href=&quot;runtime-config-connection#GUC-SSL-PASSPHRASE-COMMAND-SUPPORTS-RELOAD&quot;&gt;ssl_passphrase_command_supports_reloadを&lt;/a&gt;参照してください。さらに、パスフレーズで保護された秘密鍵は、Windowsではまったく使用できません。</target>
        </trans-unit>
        <trans-unit id="48f80ecbcca6b903e77ef9cdbab43d62afcd07ee" translate="yes" xml:space="preserve">
          <source>If the procedure has any output parameters, then a result row will be returned, containing the values of those parameters.</source>
          <target state="translated">プロシージャに出力パラメータがある場合は、それらのパラメータの値を含む結果行が返されます。</target>
        </trans-unit>
        <trans-unit id="1290513a0720d5678ce9e07e692a24b4a58d5efd" translate="yes" xml:space="preserve">
          <source>If the products table is set up so that, say, &lt;code&gt;product_id&lt;/code&gt; is the primary key, then it would be enough to group by &lt;code&gt;product_id&lt;/code&gt; in the above example, since name and price would be &lt;em&gt;functionally dependent&lt;/em&gt; on the product ID, and so there would be no ambiguity about which name and price value to return for each product ID group.</source>
          <target state="translated">たとえば、 &lt;code&gt;product_id&lt;/code&gt; が主キーであるように製品テーブルが設定されている場合、名前と価格は&lt;em&gt;機能的&lt;/em&gt;に製品IDに&lt;em&gt;依存&lt;/em&gt;するため、上記の例では &lt;code&gt;product_id&lt;/code&gt; でグループ化すれば十分です。各製品IDグループに対してどの名前と価格の値を返すかについてのあいまいさはありません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e03a5d6f408539b4e08801b317931a00ecee94a9" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">クエリにウィンドウ関数が含まれている場合（&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.21&lt;/a&gt;、および&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8を&lt;/a&gt;参照）、これらの関数は、グループ化、集計、および &lt;code&gt;HAVING&lt;/code&gt; フィルタリングが実行された後に評価されます。つまり、クエリで集計、 &lt;code&gt;GROUP BY&lt;/code&gt; 、または &lt;code&gt;HAVING&lt;/code&gt; が使用されている場合、ウィンドウ関数によって表示される行は、 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; からの元のテーブル行ではなく、グループ行です。</target>
        </trans-unit>
        <trans-unit id="a48d893df2efd76b2d73680b987bd53b81b2adad" translate="yes" xml:space="preserve">
          <source>If the query contains any window functions (see &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt; and &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;), these functions are evaluated after any grouping, aggregation, and &lt;code&gt;HAVING&lt;/code&gt; filtering is performed. That is, if the query uses any aggregates, &lt;code&gt;GROUP BY&lt;/code&gt;, or &lt;code&gt;HAVING&lt;/code&gt;, then the rows seen by the window functions are the group rows instead of the original table rows from &lt;code&gt;FROM&lt;/code&gt;/&lt;code&gt;WHERE&lt;/code&gt;.</source>
          <target state="translated">クエリにウィンドウ関数が含まれている場合（&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.22&lt;/a&gt;、および&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8を&lt;/a&gt;参照）、これらの関数は、グループ化、集計、および &lt;code&gt;HAVING&lt;/code&gt; フィルタリングが実行された後に評価されます。つまり、クエリが集計、 &lt;code&gt;GROUP BY&lt;/code&gt; 、または &lt;code&gt;HAVING&lt;/code&gt; を使用している場合、ウィンドウ関数によって表示される行は、 &lt;code&gt;FROM&lt;/code&gt; / &lt;code&gt;WHERE&lt;/code&gt; の元のテーブル行ではなく、グループ行になります。</target>
        </trans-unit>
        <trans-unit id="e83ebc0874906fce6a1aa2d76fdc21590b6b98b1" translate="yes" xml:space="preserve">
          <source>If the query fails or does not return one row, no variables are changed.</source>
          <target state="translated">クエリが失敗した場合や、1行を返さなかった場合は、変数は変更されません。</target>
        </trans-unit>
        <trans-unit id="baf42f0acc3f09fcc4a0d0dd54cac78d65c286a5" translate="yes" xml:space="preserve">
          <source>If the query requires joining two or more relations, plans for joining relations are considered after all feasible plans have been found for scanning single relations. The three available join strategies are:</source>
          <target state="translated">クエリが2つ以上の関係を結合する必要がある場合、1つの関係をスキャンして実現可能なプランがすべて見つかった後で、関係を結合するプランが検討されます。利用可能な結合戦略は以下の3つです。</target>
        </trans-unit>
        <trans-unit id="2e9c3a0d6f1b6d02143aa6739bb627c7730a051b" translate="yes" xml:space="preserve">
          <source>If the query uses fewer than &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; relations, a near-exhaustive search is conducted to find the best join sequence. The planner preferentially considers joins between any two relations for which there exist a corresponding join clause in the &lt;code&gt;WHERE&lt;/code&gt; qualification (i.e., for which a restriction like &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; exists). Join pairs with no join clause are considered only when there is no other choice, that is, a particular relation has no available join clauses to any other relation. All possible plans are generated for every join pair considered by the planner, and the one that is (estimated to be) the cheapest is chosen.</source>
          <target state="translated">クエリが&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;未満の関係を使用する場合、ほぼ完全な検索が実行され、最適な結合シーケンスが検索されます。プランナは、 &lt;code&gt;WHERE&lt;/code&gt; 修飾に対応する結合句が存在する（つまり、 &lt;code&gt;where rel1.attr1=rel2.attr2&lt;/code&gt; ような制限がある）2つの関係間の結合を優先的に検討します。結合句のない結合ペアは、他に選択肢がない場合、つまり特定のリレーションに他のリレーションへの使用可能な結合句がない場合にのみ考慮されます。プランナーが検討したすべての結合ペアについて、可能なすべてのプランが生成され、最も安い（推定される）ペアが選択されます。</target>
        </trans-unit>
        <trans-unit id="fcb1910db08273fa485c28070ee9179ceccf3c73" translate="yes" xml:space="preserve">
          <source>If the referenced column(s) are changed frequently, it might be wise to add an index to the referencing column(s) so that referential actions associated with the foreign key constraint can be performed more efficiently.</source>
          <target state="translated">参照される列が頻繁に変更される場合は、外部キー制約に関連する参照アクションをより効率的に実行できるように、参照する列にインデックスを追加するのが賢明かもしれません。</target>
        </trans-unit>
        <trans-unit id="2e6cbc38cc65944231eb0e20f1c30488fbd5652a" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;GRANT&lt;/code&gt; holds the required privileges indirectly via more than one role membership path, it is unspecified which containing role will be recorded as having done the grant. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;GRANT&lt;/code&gt; as.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; を実行するロールが複数のロールメンバーシップパスを介して間接的に必要な特権を保持する場合、どのロールが付与を実行したと記録されるかは指定されていません。このような場合、 &lt;code&gt;SET ROLE&lt;/code&gt; を使用して、 &lt;code&gt;GRANT&lt;/code&gt; を実行したい特定の役割になることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="24d9b80ef7c6da193a9a22333ae220223fd8b0ac" translate="yes" xml:space="preserve">
          <source>If the role executing &lt;code&gt;REVOKE&lt;/code&gt; holds privileges indirectly via more than one role membership path, it is unspecified which containing role will be used to perform the command. In such cases it is best practice to use &lt;code&gt;SET ROLE&lt;/code&gt; to become the specific role you want to do the &lt;code&gt;REVOKE&lt;/code&gt; as. Failure to do so might lead to revoking privileges other than the ones you intended, or not revoking anything at all.</source>
          <target state="translated">&lt;code&gt;REVOKE&lt;/code&gt; を実行するロールが複数のロールメンバーシップパスを介して間接的に特権を保持している場合、コマンドを実行するために使用されるロールが含まれるかどうかは指定されていません。そのような場合、 &lt;code&gt;SET ROLE&lt;/code&gt; を使用して、 &lt;code&gt;REVOKE&lt;/code&gt; を実行する特定の役割になることをお勧めします。そうしないと、意図した特権以外の特権が取り消されるか、まったく何も取り消されない可能性があります。</target>
        </trans-unit>
        <trans-unit id="9127d1a2bf0d40475f431a0daa0c09f299f8d847" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times from the same transaction with identical payload strings, the database server can decide to deliver a single notification only. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">同一のペイロード文字列を使用して、同じトランザクションから同じチャネル名が複数回通知された場合、データベースサーバーは単一の通知のみを配信することを決定できます。一方、個別のペイロード文字列を持つ通知は、常に個別の通知として配信されます。同様に、異なるトランザクションからの通知が1つの通知にまとめられることはありません。重複する通知のそれ以降のインスタンスを削除することを除いて、 &lt;code&gt;NOTIFY&lt;/code&gt; は同じトランザクションからの通知が送信された順に配信されることを保証します。また、さまざまなトランザクションからのメッセージが、トランザクションがコミットされた順序で配信されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="eed847052fd81f5459f65863d508269d92317295" translate="yes" xml:space="preserve">
          <source>If the same channel name is signaled multiple times with identical payload strings within the same transaction, only one instance of the notification event is delivered to listeners. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, &lt;code&gt;NOTIFY&lt;/code&gt; guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.</source>
          <target state="translated">同じチャネル名が同じトランザクション内で同じペイロード文字列で複数回通知された場合、通知イベントの1つのインスタンスのみがリスナーに配信されます。一方、個別のペイロード文字列を持つ通知は、常に個別の通知として配信されます。同様に、異なるトランザクションからの通知が1つの通知にまとめられることはありません。重複する通知の後でインスタンスを削除することを除いて、 &lt;code&gt;NOTIFY&lt;/code&gt; は、同じトランザクションからの通知が送信された順序で配信されることを保証します。また、さまざまなトランザクションからのメッセージが、トランザクションがコミットされた順序で配信されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="25d36a41307a4d14aa722349a681e2f2a7b7eb16" translate="yes" xml:space="preserve">
          <source>If the same column name exists in more than one parent table, an error is reported unless the data types of the columns match in each of the parent tables. If there is no conflict, then the duplicate columns are merged to form a single column in the new table. If the column name list of the new table contains a column name that is also inherited, the data type must likewise match the inherited column(s), and the column definitions are merged into one. If the new table explicitly specifies a default value for the column, this default overrides any defaults from inherited declarations of the column. Otherwise, any parents that specify default values for the column must all specify the same default, or an error will be reported.</source>
          <target state="translated">複数の親テーブルに同じ列名が存在する場合、各親テーブルで列のデータ型が一致しない限り、エラーが報告されます。競合がない場合は、重複した列がマージされて新しいテーブルの単一の列が形成されます。新しいテーブルのカラム名リストに継承されたカラム名が含まれている場合、データ型も継承されたカラムと一致しなければならず、カラム定義は1つにマージされます。新しいテーブルでカラムのデフォルト値が明示的に指定されている場合、このデフォルト値は継承されたカラムの宣言のデフォルト値を上書きします。そうでない場合は、カラムのデフォルト値を指定する親はすべて同じデフォルト値を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="52777f31338be443c8719518578a441085b3242b" translate="yes" xml:space="preserve">
          <source>If the scale of a value to be stored is greater than the declared scale of the column, the system will round the value to the specified number of fractional digits. Then, if the number of digits to the left of the decimal point exceeds the declared precision minus the declared scale, an error is raised.</source>
          <target state="translated">保存される値の縮尺が、その列の宣言された縮尺よりも大きい場合、システムは値を指定された小数点以下の桁数に丸めます。そして、小数点以下の桁数が宣言された精度から宣言されたスケールを差し引いた値を超える場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="02e920dfe841eca3127cd2deda87b1b0038bf35c" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple functions of identical argument types, only the one appearing earliest in the path is considered. Functions of different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">検索パスが同一の引数型の関数を複数見つけた場合、パス内で最も早く出現した関数のみを考慮します。異なる引数型の関数は、検索パスの位置に関係なく同等に考慮されます。</target>
        </trans-unit>
        <trans-unit id="846c48a5a96c2f9f31d852fa93bd025a2ae37209" translate="yes" xml:space="preserve">
          <source>If the search path finds multiple operators with identical argument types, only the one appearing earliest in the path is considered. Operators with different argument types are considered on an equal footing regardless of search path position.</source>
          <target state="translated">検索パスが同一の引数型を持つ複数の演算子を見つけた場合、パス内で最も早く出現した演算子のみを考慮します。異なる引数型を持つ演算子は、検索パスの位置に関係なく、同等に扱われます。</target>
        </trans-unit>
        <trans-unit id="2b252638ccabfce3f83bfcd21c45870e0c2d0f5f" translate="yes" xml:space="preserve">
          <source>If the server encoding is not UTF-8, the Unicode code point identified by one of these escape sequences is converted to the actual server encoding; an error is reported if that's not possible.</source>
          <target state="translated">サーバエンコーディングが UTF-8 でない場合、これらのエスケープシーケンスのいずれかで識別された Unicode コードポイントが実際のサーバエンコーディングに変換されます。</target>
        </trans-unit>
        <trans-unit id="d768fe47d52ad5a0b026e7ffb256e492ca409f05" translate="yes" xml:space="preserve">
          <source>If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, psql will prompt for a password in any case. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing &lt;code&gt;-W&lt;/code&gt; to avoid the extra connection attempt.</source>
          <target state="translated">サーバーがパスワード認証を必要とし、パスワードが &lt;code&gt;.pgpass&lt;/code&gt; ファイルなどの他のソースから入手できない場合、psqlはどのような場合でもパスワードの入力を求めます。ただし、psqlは、サーバーがパスワードを必要としていることを検出する接続試行を無駄にします。場合によっては、余分な接続の試行を避けるために &lt;code&gt;-W&lt;/code&gt; と入力する価値があります。</target>
        </trans-unit>
        <trans-unit id="3c9b16d6feb91ed4af38eb28e886ad3416c7d722" translate="yes" xml:space="preserve">
          <source>If the session user is a database superuser, then a &lt;code&gt;#&lt;/code&gt;, otherwise a &lt;code&gt;&amp;gt;&lt;/code&gt;. (The expansion of this value might change during a database session as the result of the command &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt;.)</source>
          <target state="translated">セッションユーザーがデータベースのスーパーユーザーの場合は &lt;code&gt;#&lt;/code&gt; 、それ以外の場合は &lt;code&gt;&amp;gt;&lt;/code&gt; 。（この値の拡張は、 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; コマンドの結果として、データベースセッション中に変更される場合があります。）</target>
        </trans-unit>
        <trans-unit id="21d4dfd38c56bb0f6178a7f714085ed7cf4b3207" translate="yes" xml:space="preserve">
          <source>If the specified table is a partitioned table, each row is routed to the appropriate partition and inserted into it. If the specified table is a partition, an error will occur if one of the input rows violates the partition constraint.</source>
          <target state="translated">指定されたテーブルがパーティショニングされたテーブルの場合,各行は適切なパーティションにルーティングされ,その中に挿入されます.指定されたテーブルがパーティションである場合、入力された行の一つがパーティション制約に違反するとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="1b245f2cb2a99bf0f8cbbb31a4d055f1ead828c3" translate="yes" xml:space="preserve">
          <source>If the standard and predefined collations are not sufficient, users can create their own collation objects using the SQL command &lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;.</source>
          <target state="translated">標準および事前定義の照合が十分でない場合、ユーザーはSQLコマンド&lt;a href=&quot;sql-createcollation&quot;&gt;CREATE COLLATION&lt;/a&gt;を使用して独自の照合オブジェクトを作成できます。</target>
        </trans-unit>
        <trans-unit id="3b1c783904332e93ac1d7897a9080ae105b88d5b" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to be primary during backup, the backup fails.</source>
          <target state="translated">バックアップ中にスタンバイがプライマリに昇格した場合、バックアップは失敗します。</target>
        </trans-unit>
        <trans-unit id="ae6c2a2f4f7ec1ece5d1140f847b0d38361211e2" translate="yes" xml:space="preserve">
          <source>If the standby is promoted to the master during online backup, the backup fails.</source>
          <target state="translated">オンラインバックアップ中にスタンバイがマスターに昇格した場合、バックアップは失敗します。</target>
        </trans-unit>
        <trans-unit id="170908acbec1d5cb0f56e23febc172e3426f4e91" translate="yes" xml:space="preserve">
          <source>If the standby server fails then no failover need take place. If the standby server can be restarted, even some time later, then the recovery process can also be restarted immediately, taking advantage of restartable recovery. If the standby server cannot be restarted, then a full new standby server instance should be created.</source>
          <target state="translated">待機サーバに障害が発生した場合は、フェイルオーバーを行う必要はありません。待機サーバが再起動可能であれば、再起動可能なリカバリの利点を利用して、リカバリプロセスも直ちに再起動することができる。待機サーバが再起動できない場合は、完全な新しい待機サーバのインスタンスを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="05b0c76b7db4a1477637a64b2d47050fce69810a" translate="yes" xml:space="preserve">
          <source>If the standby servers are still running, stop them now using the above instructions.</source>
          <target state="translated">待機サーバーがまだ稼働している場合は、上記の手順で停止させてください。</target>
        </trans-unit>
        <trans-unit id="6049edf261150bf348be6f8bb80514f565d9d8f9" translate="yes" xml:space="preserve">
          <source>If the state transition function is declared &amp;ldquo;strict&amp;rdquo;, then it cannot be called with null inputs. With such a transition function, aggregate execution behaves as follows. Rows with any null input values are ignored (the function is not called and the previous state value is retained). If the initial state value is null, then at the first row with all-nonnull input values, the first argument value replaces the state value, and the transition function is invoked at each subsequent row with all-nonnull input values. This is handy for implementing aggregates like &lt;code&gt;max&lt;/code&gt;. Note that this behavior is only available when &lt;code&gt;state_data_type&lt;/code&gt; is the same as the first &lt;code&gt;arg_data_type&lt;/code&gt;. When these types are different, you must supply a nonnull initial condition or use a nonstrict transition function.</source>
          <target state="translated">状態遷移関数が「厳密」に宣言されている場合、ヌル入力で呼び出すことはできません。このような遷移関数では、集計実行は次のように動作します。null入力値を持つ行は無視されます（関数は呼び出されず、前の状態値が保持されます）。初期状態値がnullの場合、すべてnull以外の入力値を持つ最初の行で最初の引数値が状態値を置き換え、すべてのnull以外の入力値を持つ後続の各行で遷移関数が呼び出されます。これは、 &lt;code&gt;max&lt;/code&gt; のような集計を実装するのに便利です。この動作は、 &lt;code&gt;state_data_type&lt;/code&gt; が最初の &lt;code&gt;arg_data_type&lt;/code&gt; と同じ場合にのみ使用できることに注意してください。。これらのタイプが異なる場合は、null以外の初期条件を指定するか、非厳密な遷移関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b6d30b33fa764833043e35a291ca75c71eaca53e" translate="yes" xml:space="preserve">
          <source>If the state transition function is not strict, then it will be called unconditionally at each input row, and must deal with null inputs and null state values for itself. This allows the aggregate author to have full control over the aggregate's handling of null values.</source>
          <target state="translated">状態遷移関数が厳密でない場合は、各入力行で無条件に呼び出され、それ自身でヌル入力とヌル状態値を処理しなければなりません。これにより、集合体の作成者は、集合体によるヌル値の処理を完全に制御することができます。</target>
        </trans-unit>
        <trans-unit id="244bd5a12cbdca1f48ebb0a6febfdca5da532447" translate="yes" xml:space="preserve">
          <source>If the string is declared to be of type &lt;code&gt;varchar&lt;/code&gt;, as might be the case if it comes from a table, then the parser will try to convert it to become &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">文字列が &lt;code&gt;varchar&lt;/code&gt; 型であると宣言されている場合、それがテーブルからのものである場合のように、パーサーはそれを &lt;code&gt;text&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2dcfcecbf90e5089ccafce06b4b0be1f8904c94c" translate="yes" xml:space="preserve">
          <source>If the subtype is considered to have discrete rather than continuous values, the &lt;code&gt;CREATE TYPE&lt;/code&gt; command should specify a &lt;code&gt;canonical&lt;/code&gt; function. The canonicalization function takes an input range value, and must return an equivalent range value that may have different bounds and formatting. The canonical output for two ranges that represent the same set of values, for example the integer ranges &lt;code&gt;[1, 7]&lt;/code&gt; and &lt;code&gt;[1, 8)&lt;/code&gt;, must be identical. It doesn't matter which representation you choose to be the canonical one, so long as two equivalent values with different formattings are always mapped to the same value with the same formatting. In addition to adjusting the inclusive/exclusive bounds format, a canonicalization function might round off boundary values, in case the desired step size is larger than what the subtype is capable of storing. For instance, a range type over &lt;code&gt;timestamp&lt;/code&gt; could be defined to have a step size of an hour, in which case the canonicalization function would need to round off bounds that weren't a multiple of an hour, or perhaps throw an error instead.</source>
          <target state="translated">サブタイプが連続値ではなく離散値を持つと見なされる場合、 &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドで &lt;code&gt;canonical&lt;/code&gt; 関数を指定する必要があります。正規化関数は入力範囲値を取り、異なる境界とフォーマットを持つ可能性のある同等の範囲値を返す必要があります。同じ値のセットを表す2つの範囲の標準出力、たとえば整数範囲 &lt;code&gt;[1, 7]&lt;/code&gt; 1、7 ]および &lt;code&gt;[1, 8)&lt;/code&gt; 、同一でなければなりません。フォーマットが異なる2つの同等の値が常に同じフォーマットで同じ値にマッピングされている限り、どの表現を正規表現として選択してもかまいません。包含/排他境界形式を調整することに加えて、正規化関数は、希望するステップサイズがサブタイプが格納できるものより大きい場合、境界値を四捨五入する場合があります。たとえば、 &lt;code&gt;timestamp&lt;/code&gt; 上の範囲タイプは、1時間のステップサイズを持つように定義できます。その場合、正規化関数は、1時間の倍数ではない境界を丸めるか、代わりにエラーをスローする必要があります。</target>
        </trans-unit>
        <trans-unit id="417d560f70c3f29f36f195f746fd3ca8a01a2c42" translate="yes" xml:space="preserve">
          <source>If the system administrator for the server's machine cannot be trusted, it is necessary for the client to encrypt the data; this way, unencrypted data never appears on the database server. Data is encrypted on the client before being sent to the server, and database results have to be decrypted on the client before being used.</source>
          <target state="translated">サーバのマシンのシステム管理者が信頼できない場合は、クライアント側でデータを暗号化する必要があります。データはサーバに送信される前にクライアントで暗号化され、データベースの結果は使用される前にクライアントで復号化されなければなりません。</target>
        </trans-unit>
        <trans-unit id="2b3f5f95bd715dfe464206f06b66a58f56802c50" translate="yes" xml:space="preserve">
          <source>If the table as a whole is exclusive-locked by someone else, &lt;code&gt;pgrowlocks&lt;/code&gt; will be blocked.</source>
          <target state="translated">テーブル全体が他の &lt;code&gt;pgrowlocks&lt;/code&gt; によって排他ロックされている場合、pgrowlockはブロックされます。</target>
        </trans-unit>
        <trans-unit id="b50348338bc555a4ab7d45126bfb8dabd633e20f" translate="yes" xml:space="preserve">
          <source>If the table being analyzed has one or more children, &lt;code&gt;ANALYZE&lt;/code&gt; will gather statistics twice: once on the rows of the parent table only, and a second time on the rows of the parent table with all of its children. This second set of statistics is needed when planning queries that traverse the entire inheritance tree. The autovacuum daemon, however, will only consider inserts or updates on the parent table itself when deciding whether to trigger an automatic analyze for that table. If that table is rarely inserted into or updated, the inheritance statistics will not be up to date unless you run &lt;code&gt;ANALYZE&lt;/code&gt; manually.</source>
          <target state="translated">分析対象のテーブルに1つ以上の子がある場合、 &lt;code&gt;ANALYZE&lt;/code&gt; は統計を2回収集します。1 回は親テーブルの行のみで、2回目はすべての子を持つ親テーブルの行でです。この2番目の統計セットは、継承ツリー全体を走査するクエリを計画するときに必要です。ただし、autovacuumデーモンは、そのテーブルの自動分析をトリガーするかどうかを決定するときに、親テーブル自体に対する挿入または更新のみを考慮します。そのテーブルがめったに挿入または更新されない場合、手動で &lt;code&gt;ANALYZE&lt;/code&gt; を実行しない限り、継承統計は最新の状態になりません。</target>
        </trans-unit>
        <trans-unit id="b96d4460f730e99ad2f5da4b8998b3d561a93287" translate="yes" xml:space="preserve">
          <source>If the table being analyzed is completely empty, &lt;code&gt;ANALYZE&lt;/code&gt; will not record new statistics for that table. Any existing statistics will be retained.</source>
          <target state="translated">分析中のテーブルが完全に空の場合、 &lt;code&gt;ANALYZE&lt;/code&gt; はそのテーブルの新しい統計を記録しません。既存の統計は保持されます。</target>
        </trans-unit>
        <trans-unit id="52dc63831209a4c7bb3899cf1fb2ddca1ef42d36" translate="yes" xml:space="preserve">
          <source>If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero.</source>
          <target state="translated">テーブルがインデックスを使用してスキャンされている場合、これは使用されているインデックスのOIDです。</target>
        </trans-unit>
        <trans-unit id="dd0fa542dae151db3f272ca82de26368bfb9872f" translate="yes" xml:space="preserve">
          <source>If the target directory is specified as &lt;code&gt;-&lt;/code&gt; (dash), the tar contents will be written to standard output, suitable for piping to (for example) gzip. This is only allowed if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">ターゲットディレクトリが &lt;code&gt;-&lt;/code&gt; （ダッシュ）として指定されている場合、tarの内容は標準出力に書き込まれ、（たとえば）gzipへのパイピングに適しています。これは、クラスターに追加の表領域がなく、WALストリーミングが使用されていない場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="9dfb9ffd9573334faeebb68db3d3df9b1f1f0724" translate="yes" xml:space="preserve">
          <source>If the token is an alphabetic string, match up with possible strings:</source>
          <target state="translated">トークンがアルファベット文字列の場合は、可能性のある文字列と一致させます。</target>
        </trans-unit>
        <trans-unit id="4f40be80901959628e05aea1c30e86478bf9dbb2" translate="yes" xml:space="preserve">
          <source>If the token is numeric only, then it is either a single field or an ISO 8601 concatenated date (e.g., &lt;code&gt;19990113&lt;/code&gt; for January 13, 1999) or time (e.g., &lt;code&gt;141516&lt;/code&gt; for 14:15:16).</source>
          <target state="translated">トークンが数値のみの場合、それは単一のフィールド、またはISO 8601連結日付（たとえば、1999年1月13日の場合は &lt;code&gt;19990113&lt;/code&gt; ）または時刻（たとえば、 &lt;code&gt;141516&lt;/code&gt; ：15：16の場合は141516）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="003398a89e69d2198b671a9677907bb24f534582" translate="yes" xml:space="preserve">
          <source>If the token is three digits and a year has already been read, then interpret as day of year.</source>
          <target state="translated">トークンが3桁で、すでに年が読み込まれている場合は、年の日と解釈します。</target>
        </trans-unit>
        <trans-unit id="d3ac616dded1315bedadfd2b91efaa1cf49163f8" translate="yes" xml:space="preserve">
          <source>If the token starts with a plus (&lt;code&gt;+&lt;/code&gt;) or minus (&lt;code&gt;-&lt;/code&gt;), then it is either a numeric time zone or a special field.</source>
          <target state="translated">トークンがプラス（ &lt;code&gt;+&lt;/code&gt; ）またはマイナス（ &lt;code&gt;-&lt;/code&gt; ）で始まる場合、それは数値のタイムゾーンまたは特別なフィールドです。</target>
        </trans-unit>
        <trans-unit id="611739a43cf34a105bb65434365f4074cf8756df" translate="yes" xml:space="preserve">
          <source>If the transaction modified any run-time parameters with &lt;code&gt;SET&lt;/code&gt; (without the &lt;code&gt;LOCAL&lt;/code&gt; option), those effects persist after &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, and will not be affected by any later &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. Thus, in this one respect &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; acts more like &lt;code&gt;COMMIT&lt;/code&gt; than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">トランザクションが &lt;code&gt;SET&lt;/code&gt; （ &lt;code&gt;LOCAL&lt;/code&gt; オプションなし）を使用して実行時パラメーターを変更した場合、それらの影響は &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; の後も持続し、その後の &lt;code&gt;COMMIT PREPARED&lt;/code&gt; または &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; の影響を受けません。したがって、この点で &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; は &lt;code&gt;ROLLBACK&lt;/code&gt; よりも &lt;code&gt;COMMIT&lt;/code&gt; のように機能します。</target>
        </trans-unit>
        <trans-unit id="07ad8422becd50d9414841f3815863dc01f955f6" translate="yes" xml:space="preserve">
          <source>If the type being ordered (&lt;code&gt;type1&lt;/code&gt;) is collatable, the appropriate collation OID will be passed to the &lt;code&gt;in_range&lt;/code&gt; function, using the standard PG_GET_COLLATION() mechanism.</source>
          <target state="translated">順序付けされる型（ &lt;code&gt;type1&lt;/code&gt; ）が照合可能である場合、標準のPG_GET_COLLATION（）メカニズムを使用して、適切な照合OIDが &lt;code&gt;in_range&lt;/code&gt; 関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="0affc2c3fcf33ac8518f76b37e69d5d8764c5216" translate="yes" xml:space="preserve">
          <source>If the unique constraint is deferrable, there is additional complexity: we need to be able to insert an index entry for a new row, but defer any uniqueness-violation error until end of statement or even later. To avoid unnecessary repeat searches of the index, the index access method should do a preliminary uniqueness check during the initial insertion. If this shows that there is definitely no conflicting live tuple, we are done. Otherwise, we schedule a recheck to occur when it is time to enforce the constraint. If, at the time of the recheck, both the inserted tuple and some other tuple with the same key are live, then the error must be reported. (Note that for this purpose, &amp;ldquo;live&amp;rdquo; actually means &amp;ldquo;any tuple in the index entry's HOT chain is live&amp;rdquo;.) To implement this, the &lt;code&gt;aminsert&lt;/code&gt; function is passed a &lt;code&gt;checkUnique&lt;/code&gt; parameter having one of the following values:</source>
          <target state="translated">一意制約が延期可能である場合、さらに複雑になります。新しい行のインデックスエントリを挿入できるようにする必要がありますが、一意性違反エラーはステートメントの最後まで、または後で延期する必要があります。インデックスの不要な繰り返し検索を回避するために、インデックスアクセスメソッドは、最初の挿入時に予備的な一意性チェックを行う必要があります。これにより、競合するライブタプルがないことが確実に示されれば、完了です。それ以外の場合は、制約を適用するときに再チェックが行われるようにスケジュールします。再チェック時に、挿入されたタプルと同じキーを持つ他のタプルの両方がライブである場合、エラーを報告する必要があります。 （この目的のために、「ライブ」は実際には「インデックスエントリのHOTチェーン内のすべてのタプルがライブである」ことを意味することに注意してください。）これを実装するには、 &lt;code&gt;aminsert&lt;/code&gt; 関数に &lt;code&gt;checkUnique&lt;/code&gt; 次のいずれかの値を持つcheckUniqueパラメータ：</target>
        </trans-unit>
        <trans-unit id="0ccba0a1dbc7e9db8732870253e268a51ede19e4" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;-&lt;/code&gt; (dash) is specified as target directory, the tar contents will be written to standard output, suitable for piping to for example gzip. This is only possible if the cluster has no additional tablespaces and WAL streaming is not used.</source>
          <target state="translated">値 &lt;code&gt;-&lt;/code&gt; （ダッシュ）がターゲットディレクトリとして指定されている場合、tarの内容は標準出力に書き込まれ、gzipなどへのパイプに適しています。これは、クラスターに追加のテーブルスペースがなく、WALストリーミングが使用されていない場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="444b2da78b5aef7c45b208ec5e7f996fc4602364" translate="yes" xml:space="preserve">
          <source>If the value is 1 (the default) or above, float values are output in shortest-precise format; see &lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;Section 8.1.3&lt;/a&gt;. The actual number of digits generated depends only on the value being output, not on the value of this parameter. At most 17 digits are required for &lt;code&gt;float8&lt;/code&gt; values, and 9 for &lt;code&gt;float4&lt;/code&gt; values. This format is both fast and precise, preserving the original binary float value exactly when correctly read. For historical compatibility, values up to 3 are permitted.</source>
          <target state="translated">値が1（デフォルト）以上の場合、float値は最短精度の形式で出力されます。&lt;a href=&quot;datatype-numeric#DATATYPE-FLOAT&quot;&gt;セクション8.1.3を&lt;/a&gt;参照してください。生成される実際の桁数は、出力される値にのみ依存し、このパラメーターの値には依存しません。 &lt;code&gt;float8&lt;/code&gt; 値には最大17桁、 &lt;code&gt;float4&lt;/code&gt; 値には最大 9 桁が必要です。この形式は高速かつ正確であり、正しく読み取られたときに元のバイナリfloat値を正確に保持します。過去の互換性のために、3までの値が許可されています。</target>
        </trans-unit>
        <trans-unit id="7b8c00d10368663be17d060a1553cbcac67af360" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;always&lt;/code&gt;, then color is used.</source>
          <target state="translated">値が &lt;code&gt;always&lt;/code&gt; 場合、色が使用されます。</target>
        </trans-unit>
        <trans-unit id="a3241b1b5ac7bee371703180a8744c53db79636d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;auto&lt;/code&gt; and the standard error stream is associated with a terminal device, then color is used.</source>
          <target state="translated">値が &lt;code&gt;auto&lt;/code&gt; で、標準エラーストリームが端末デバイスに関連付けられている場合、色が使用されます。</target>
        </trans-unit>
        <trans-unit id="a0cc84e480979f938d4633f92cd03d8f6fccf694" translate="yes" xml:space="preserve">
          <source>If the value is zero or negative, then the output is rounded to a given decimal precision. The precision used is the standard number of digits for the type (&lt;code&gt;FLT_DIG&lt;/code&gt; or &lt;code&gt;DBL_DIG&lt;/code&gt; as appropriate) reduced according to the value of this parameter. (For example, specifying -1 will cause &lt;code&gt;float4&lt;/code&gt; values to be output rounded to 5 significant digits, and &lt;code&gt;float8&lt;/code&gt; values rounded to 14 digits.) This format is slower and does not preserve all the bits of the binary float value, but may be more human-readable.</source>
          <target state="translated">値がゼロまたは負の場合、出力は指定された小数精度に丸められます。使用される精度は、このパラメーターの値に応じて削減された型（ &lt;code&gt;FLT_DIG&lt;/code&gt; または &lt;code&gt;DBL_DIG&lt;/code&gt; のいずれか適切なもの）の標準の桁数です。 （たとえば、-1を指定すると、 &lt;code&gt;float4&lt;/code&gt; 値は有効数字5桁に丸められ、 &lt;code&gt;float8&lt;/code&gt; 値は14桁に丸められます。）この形式は低速で、バイナリfloat値のすべてのビットを保持しませんが、人間が読める。</target>
        </trans-unit>
        <trans-unit id="1bde8627196fca1b915cdbfcafe6a9bc91cc16ce" translate="yes" xml:space="preserve">
          <source>If the value written for an element is &lt;code&gt;NULL&lt;/code&gt; (in any case variant), the element is taken to be NULL. The presence of any quotes or backslashes disables this and allows the literal string value &amp;ldquo;NULL&amp;rdquo; to be entered. Also, for backward compatibility with pre-8.2 versions of PostgreSQL, the &lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt; configuration parameter can be turned &lt;code&gt;off&lt;/code&gt; to suppress recognition of &lt;code&gt;NULL&lt;/code&gt; as a NULL.</source>
          <target state="translated">要素に書き込まれた値が &lt;code&gt;NULL&lt;/code&gt; の場合（どのような場合でも）、要素はNULLと見なされます。引用符やバックスラッシュがあるとこれが無効になり、リテラル文字列値「NULL」を入力できます。また、8.2より前のバージョンのPostgreSQLとの下位互換性のために、&lt;a href=&quot;runtime-config-compatible#GUC-ARRAY-NULLS&quot;&gt;array_nulls&lt;/a&gt;構成パラメーターを &lt;code&gt;off&lt;/code&gt; して、NULL を &lt;code&gt;NULL&lt;/code&gt; として認識しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="c41c4c976de57b5cc72ea9d7bfdcc6564b8b256b" translate="yes" xml:space="preserve">
          <source>If the view is automatically updatable the system will convert any &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; statement on the view into the corresponding statement on the underlying base relation. &lt;code&gt;INSERT&lt;/code&gt; statements that have an &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; clause are fully supported.</source>
          <target state="translated">ビューが自動的に更新可能な場合、システムはビューの &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; ステートメントを、基礎となる基本リレーションの対応するステートメントに変換します。 &lt;code&gt;ON CONFLICT UPDATE&lt;/code&gt; 句を持つ &lt;code&gt;INSERT&lt;/code&gt; ステートメントは完全にサポートされています。</target>
        </trans-unit>
        <trans-unit id="650d690f75ae406d20b34e538980576f232072f4" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">幅が関数の引数に由来する場合、その引数は、書式指定子の値に使用される引数の前に消費されます。width引数が負の場合、結果は（ &lt;code&gt;-&lt;/code&gt; フラグが指定された場合と同様に）長さ &lt;code&gt;abs&lt;/code&gt; （ &lt;code&gt;width&lt;/code&gt; ）のフィールド内で左揃えになります。</target>
        </trans-unit>
        <trans-unit id="8438b6c9a8a0c469032906dcee3641b321408b8e" translate="yes" xml:space="preserve">
          <source>If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the &lt;code&gt;-&lt;/code&gt; flag had been specified) within a field of length &lt;code&gt;abs&lt;/code&gt;(&lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt;).</source>
          <target state="translated">幅が関数引数からのものである場合、その引数は、フォーマット指定子の値に使用される引数の前に消費されます。width引数が負の場合、結果は長さ &lt;code&gt;abs&lt;/code&gt; （&lt;em&gt; &lt;code&gt;width&lt;/code&gt; &lt;/em&gt;）のフィールド内で（ &lt;code&gt;-&lt;/code&gt; フラグが指定されているかのように）左揃えになります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ee835cdf2017b10d24cc5c26f6abffc684a96735" translate="yes" xml:space="preserve">
          <source>If there are both &lt;code&gt;unknown&lt;/code&gt; and known-type arguments, and all the known-type arguments have the same type, assume that the &lt;code&gt;unknown&lt;/code&gt; arguments are also of that type, and check which candidates can accept that type at the &lt;code&gt;unknown&lt;/code&gt;-argument positions. If exactly one candidate passes this test, use it. Otherwise, fail.</source>
          <target state="translated">両方がある場合は &lt;code&gt;unknown&lt;/code&gt; および既知の型の引数、およびすべての既知の型の引数は、同じ型を持っていることを前提とし &lt;code&gt;unknown&lt;/code&gt; 引数はまた、そのタイプのものであり、候補者にそのタイプ受け入れることができ、チェック &lt;code&gt;unknown&lt;/code&gt; -argument位置を。正確に1人の候補者がこのテストに合格した場合、それを使用します。そうでなければ、失敗します。</target>
        </trans-unit>
        <trans-unit id="13cac4b83f93f0a857eb5390b899f2b2b2cbf1c2" translate="yes" xml:space="preserve">
          <source>If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time.</source>
          <target state="translated">入力式の中にデフォルト以外の暗黙の照合が競合する場合、その組み合わせは不確定な照合を持っているとみなされます。これは、呼び出される特定の関数が適用すべき照合の知識を必要としない限り、エラー条件ではありません。その場合、実行時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="28d65a2d08624ffa80deb6c7246a1682969ee379" translate="yes" xml:space="preserve">
          <source>If there are eight or six digits, and if no other date fields have been previously read, then interpret as a &amp;ldquo;concatenated date&amp;rdquo; (e.g., &lt;code&gt;19990118&lt;/code&gt; or &lt;code&gt;990118&lt;/code&gt;). The interpretation is &lt;code&gt;YYYYMMDD&lt;/code&gt; or &lt;code&gt;YYMMDD&lt;/code&gt;.</source>
          <target state="translated">8桁または6桁の数字があり、以前に他の日付フィールドが読み取られていない場合は、「連結日付」として解釈されます（例： &lt;code&gt;19990118&lt;/code&gt; または &lt;code&gt;990118&lt;/code&gt; ）。解釈は &lt;code&gt;YYYYMMDD&lt;/code&gt; または &lt;code&gt;YYMMDD&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="06c3232f6496ea373f86e0b58b23d8cc590947a5" translate="yes" xml:space="preserve">
          <source>If there are separate indexes on several of the columns referenced in &lt;code&gt;WHERE&lt;/code&gt;, the planner might choose to use an AND or OR combination of the indexes:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; で参照されるいくつかの列に個別のインデックスがある場合、プランナはインデックスのANDまたはORの組み合わせを使用することを選択できます。</target>
        </trans-unit>
        <trans-unit id="99c2725fb0d24809952a5ff770d9ef79057a3c26" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">ターゲット表にトリガー（&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;第38章&lt;/a&gt;）がある場合、 &lt;code&gt;RETURNING&lt;/code&gt; に使用可能なデータは、トリガーによって変更された行です。したがって、トリガーによって計算された列の検査は、 &lt;code&gt;RETURNING&lt;/code&gt; のもう1つの一般的な使用例です。</target>
        </trans-unit>
        <trans-unit id="531c18479c37e8661718c4bf106b66a87df84c58" translate="yes" xml:space="preserve">
          <source>If there are triggers (&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;Chapter 38&lt;/a&gt;) on the target table, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as modified by the triggers. Thus, inspecting columns computed by triggers is another common use-case for &lt;code&gt;RETURNING&lt;/code&gt;.</source>
          <target state="translated">ターゲットテーブルにトリガー（&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;第38章&lt;/a&gt;）がある場合、 &lt;code&gt;RETURNING&lt;/code&gt; で使用できるデータは、トリガーによって変更された行です。したがって、トリガーによって計算された列の検査は、 &lt;code&gt;RETURNING&lt;/code&gt; のもう1つの一般的なユースケースです。</target>
        </trans-unit>
        <trans-unit id="5b8c31e042fe2150c30030dae6c6269655420443" translate="yes" xml:space="preserve">
          <source>If there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:</source>
          <target state="translated">ウィンドウ計算が実行された後に、行をフィルタリングしたりグループ化したりする必要がある場合は、サブセレクトを使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="cffa77db1a4b360ae7233f9c0f0ce7a0bc209389" translate="yes" xml:space="preserve">
          <source>If there is a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be processed.</source>
          <target state="translated">LSNが &lt;code&gt;lsn&lt;/code&gt; と完全に等しいレコードがある場合、そのレコードが処理されます。</target>
        </trans-unit>
        <trans-unit id="83cce96057188d3a7386156bf2623596a5029da8" translate="yes" xml:space="preserve">
          <source>If there is an index and we use a query with an indexable &lt;code&gt;WHERE&lt;/code&gt; condition, &lt;code&gt;EXPLAIN&lt;/code&gt; might show a different plan:</source>
          <target state="translated">インデックスがあり、インデックス付け可能な &lt;code&gt;WHERE&lt;/code&gt; 条件でクエリを使用する場合、 &lt;code&gt;EXPLAIN&lt;/code&gt; は異なるプランを表示する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed6480e8e6205c3cafadde0e83045f72ff5c9888" translate="yes" xml:space="preserve">
          <source>If there is more than one direct parent for a child table (multiple inheritance), this number tells the order in which the inherited columns are to be arranged. The count starts at 1.</source>
          <target state="translated">子テーブルの直接の親が複数ある場合(多重継承)、この数は継承された列を配置する順番を示します。カウントは 1 から始まります。</target>
        </trans-unit>
        <trans-unit id="b83d35fcbb1d8a1926cc7ad31b3e2d51f2485b81" translate="yes" xml:space="preserve">
          <source>If there is no setting named &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt;という名前の設定がない場合、&lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt;が指定されて &lt;code&gt;true&lt;/code&gt; でない限り、 &lt;code&gt;current_setting&lt;/code&gt; はエラーをスローします。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="993f6bab11125bc0a23a8d9c66d2ae0ec051d5b8" translate="yes" xml:space="preserve">
          <source>If there's a record with LSN exactly equal to &lt;code&gt;lsn&lt;/code&gt;, the record will be output.</source>
          <target state="translated">LSNが &lt;code&gt;lsn&lt;/code&gt; と完全に等しいレコードがある場合、そのレコードが出力されます。</target>
        </trans-unit>
        <trans-unit id="51e95a5e2098ab1866ec414690874be8c0926635" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">これら2つの基本的な要件が満たされている場合、クエリで必要なすべてのデータ値がインデックスから取得できるため、物理的にインデックスのみのスキャンが可能です。ただし、PostgreSQLのテーブルスキャンには追加の要件があります。&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章で&lt;/a&gt;説明したように、取得した各行がクエリのMVCCスナップショットに「可視」であることを確認する必要があります。。可視性情報は、ヒープエントリにのみ保存され、インデックスエントリには保存されません。そのため、一見すると、すべての行の取得にはとにかくヒープアクセスが必要であるように見えます。そして、テーブルの行が最近変更された場合、これは確かにそうです。ただし、データをほとんど変更しない場合は、この問題を回避する方法があります。 PostgreSQLは、テーブルのヒープ内の各ページについて、そのページに格納されているすべての行が、現在および将来のすべてのトランザクションで認識できるほど古いかどうかを追跡します。この情報は、テーブルの&lt;em&gt;可視性マップ&lt;/em&gt;のビットに格納され&lt;em&gt;ます&lt;/em&gt;。インデックスのみのスキャンは、候補インデックスエントリを見つけた後、対応するヒープページの可視性マップビットをチェックします。設定されている場合、行は可視であることがわかっているため、追加の作業なしでデータを返すことができます。設定されていない場合は、ヒープエントリにアクセスして、それが表示されているかどうかを確認する必要があるため、標準のインデックススキャンよりもパフォーマンス上の利点はありません。成功した場合でも、このアプローチは可視性マップアクセスとヒープアクセスを交換します。しかし、可視性マップはそれが説明するヒープより4桁小さいため、それにアクセスするために必要な物理I / Oははるかに少なくなります。ほとんどの場合、可視性マップは常にメモリにキャッシュされたままです。</target>
        </trans-unit>
        <trans-unit id="56f8e9d448a32277ad7decf19037ed4798402174" translate="yes" xml:space="preserve">
          <source>If these two fundamental requirements are met, then all the data values required by the query are available from the index, so an index-only scan is physically possible. But there is an additional requirement for any table scan in PostgreSQL: it must verify that each retrieved row be &amp;ldquo;visible&amp;rdquo; to the query's MVCC snapshot, as discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;. Visibility information is not stored in index entries, only in heap entries; so at first glance it would seem that every row retrieval would require a heap access anyway. And this is indeed the case, if the table row has been modified recently. However, for seldom-changing data there is a way around this problem. PostgreSQL tracks, for each page in a table's heap, whether all rows stored in that page are old enough to be visible to all current and future transactions. This information is stored in a bit in the table's &lt;em&gt;visibility map&lt;/em&gt;. An index-only scan, after finding a candidate index entry, checks the visibility map bit for the corresponding heap page. If it's set, the row is known visible and so the data can be returned with no further work. If it's not set, the heap entry must be visited to find out whether it's visible, so no performance advantage is gained over a standard index scan. Even in the successful case, this approach trades visibility map accesses for heap accesses; but since the visibility map is four orders of magnitude smaller than the heap it describes, far less physical I/O is needed to access it. In most situations the visibility map remains cached in memory all the time.</source>
          <target state="translated">これらの2つの基本的な要件が満たされている場合、クエリに必要なすべてのデータ値がインデックスから利用できるため、インデックスのみのスキャンが物理的に可能です。ただし、PostgreSQLのテーブルスキャンには追加の要件があります。&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章で&lt;/a&gt;説明されているように、取得された各行がクエリのMVCCスナップショットに「表示」されていることを確認する必要があります。。可視性情報はインデックスエントリには保存されず、ヒープエントリにのみ保存されます。したがって、一見すると、すべての行の取得にはとにかくヒープアクセスが必要であるように見えます。そして、テーブルの行が最近変更された場合、これは確かに当てはまります。ただし、めったに変更されないデータの場合、この問題を回避する方法があります。 PostgreSQLは、テーブルのヒープ内の各ページについて、そのページに格納されているすべての行が、現在および将来のすべてのトランザクションで表示できるほど古いかどうかを追跡します。この情報は、テーブルの&lt;em&gt;可視性マップ&lt;/em&gt;のビットに格納され&lt;em&gt;ます&lt;/em&gt;。インデックスのみのスキャンは、候補インデックスエントリを見つけた後、対応するヒープページの可視性マップビットをチェックします。設定されている場合、行は表示されていることがわかっているため、それ以上の作業なしでデータを返すことができます。設定されていない場合は、ヒープエントリにアクセスして表示されているかどうかを確認する必要があるため、標準のインデックススキャンよりもパフォーマンス上の利点は得られません。成功した場合でも、このアプローチは可視性マップアクセスをヒープアクセスと交換します。ただし、可視性マップは、それが記述するヒープよりも4桁小さいため、アクセスに必要な物理I / Oははるかに少なくなります。ほとんどの場合、可視性マップは常にメモリにキャッシュされたままです。</target>
        </trans-unit>
        <trans-unit id="8eca355b7b540d6c38ac123a39e5c7bfe77f82a8" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">この句が指定された場合、identity 列に指定された値は無視され、既定のシーケンス生成値が適用されます。</target>
        </trans-unit>
        <trans-unit id="c547d5a570870983467a7ef7a622b57db3de5cb6" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns defined as &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; are ignored and the default sequence-generated values are applied.</source>
          <target state="translated">この句が指定されている場合、 &lt;code&gt;GENERATED BY DEFAULT&lt;/code&gt; として定義されているID列に指定された値はすべて無視され、デフォルトのシーケンス生成値が適用されます。</target>
        </trans-unit>
        <trans-unit id="33eceb951fc008dd28e5a104ea6147dca30fa083" translate="yes" xml:space="preserve">
          <source>If this clause is specified, then any values supplied for identity columns will override the default sequence-generated values.</source>
          <target state="translated">この節が指定された場合、identity 列に指定された値はすべて、既定のシーケンス生成値を上書きします。</target>
        </trans-unit>
        <trans-unit id="bc20641c7b7db884166e9f2d507911850e3a7612" translate="yes" xml:space="preserve">
          <source>If this file exists in the data directory, pg_ctl (in &lt;code&gt;restart&lt;/code&gt; mode) will pass the contents of the file as options to postgres, unless overridden by the &lt;code&gt;-o&lt;/code&gt; option. The contents of this file are also displayed in &lt;code&gt;status&lt;/code&gt; mode.</source>
          <target state="translated">このファイルがデータディレクトリに存在する場合、pg_ctl（ &lt;code&gt;restart&lt;/code&gt; モード）は、 &lt;code&gt;-o&lt;/code&gt; オプションでオーバーライドされない限り、ファイルの内容をオプションとしてpostgresに渡します。このファイルの内容は、 &lt;code&gt;status&lt;/code&gt; モードでも表示されます。</target>
        </trans-unit>
        <trans-unit id="50767742cba8dcb6350d1c58ae8e0156ac5a9fe6" translate="yes" xml:space="preserve">
          <source>If this happens, you will see a kernel message that looks like this (consult your system documentation and configuration on where to look for such a message):</source>
          <target state="translated">これが起こると、このようなカーネルメッセージが表示されます (このようなメッセージがどこにあるかは、システムのドキュメントや設定を参照してください)。</target>
        </trans-unit>
        <trans-unit id="2441da5aa28be6dd0d7fce7180a9ead106be298e" translate="yes" xml:space="preserve">
          <source>If this is a composite type (see &lt;code&gt;typtype&lt;/code&gt;), then this column points to the &lt;code&gt;pg_class&lt;/code&gt; entry that defines the corresponding table. (For a free-standing composite type, the &lt;code&gt;pg_class&lt;/code&gt; entry doesn't really represent a table, but it is needed anyway for the type's &lt;code&gt;pg_attribute&lt;/code&gt; entries to link to.) Zero for non-composite types.</source>
          <target state="translated">これが複合タイプ（ &lt;code&gt;typtype&lt;/code&gt; を参照）の場合、この列は対応するテーブルを定義する &lt;code&gt;pg_class&lt;/code&gt; エントリを指します。（独立型の複合型の場合、 &lt;code&gt;pg_class&lt;/code&gt; エントリは実際にはテーブルを表しませんが、いずれにしても型の &lt;code&gt;pg_attribute&lt;/code&gt; エントリがリンクするために必要です。）非複合型の場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="e7bc989c1a71dcf27e6c15912a9e239eb02b9ff1" translate="yes" xml:space="preserve">
          <source>If this is a domain (see &lt;code&gt;typtype&lt;/code&gt;), then &lt;code&gt;typbasetype&lt;/code&gt; identifies the type that this one is based on. Zero if this type is not a domain.</source>
          <target state="translated">このドメインは、（参照している場合 &lt;code&gt;typtype&lt;/code&gt; を）、次いで &lt;code&gt;typbasetype&lt;/code&gt; もこれが基づいているタイプを識別し。このタイプがドメインでない場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="69cd51fd1807ea0656502f0a70cd88e1db17db63" translate="yes" xml:space="preserve">
          <source>If this is a table or an index, the access method used (heap, B-tree, hash, etc.)</source>
          <target state="translated">これがテーブルやインデックスの場合は、使用したアクセス方法(ヒープ、Bツリー、ハッシュなど)。</target>
        </trans-unit>
        <trans-unit id="a337fd1770acfe173207c700a1060f857464ec35" translate="yes" xml:space="preserve">
          <source>If this is enabled, &lt;code&gt;TRUNCATE&lt;/code&gt; operations performed directly on partitions are not replicated.</source>
          <target state="translated">これが有効になっている場合、パーティションで直接実行される &lt;code&gt;TRUNCATE&lt;/code&gt; 操作は複製されません。</target>
        </trans-unit>
        <trans-unit id="6657b3960fa7e0cd88d2aa8dcc3b355ae7df8c2d" translate="yes" xml:space="preserve">
          <source>If this is on, you should create users as &lt;code&gt;username@dbname&lt;/code&gt;. When &lt;code&gt;username&lt;/code&gt; is passed by a connecting client, &lt;code&gt;@&lt;/code&gt; and the database name are appended to the user name and that database-specific user name is looked up by the server. Note that when you create users with names containing &lt;code&gt;@&lt;/code&gt; within the SQL environment, you will need to quote the user name.</source>
          <target state="translated">これがオンになっている場合は、ユーザーを &lt;code&gt;username@dbname&lt;/code&gt; として作成する必要があります。場合は &lt;code&gt;username&lt;/code&gt; 接続しているクライアントによって渡され、 &lt;code&gt;@&lt;/code&gt; とデータベース名、ユーザー名に付加され、そのデータベース固有のユーザー名は、サーバーによって検索されます。SQL環境で &lt;code&gt;@&lt;/code&gt; を含む名前のユーザーを作成する場合は、ユーザー名を引用符で囲む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8483faa9a2017341557263992633a169be114a21" translate="yes" xml:space="preserve">
          <source>If this option is enabled along with &lt;code&gt;compat_realm&lt;/code&gt;, the user name from the Kerberos UPN is used for authentication. If it is disabled (the default), the SAM-compatible user name is used. By default, these two names are identical for new user accounts.</source>
          <target state="translated">このオプションを &lt;code&gt;compat_realm&lt;/code&gt; とともに有効にすると、Kerberos UPNからのユーザー名が認証に使用されます。無効（デフォルト）の場合、SAM互換のユーザー名が使用されます。デフォルトでは、これら2つの名前は新しいユーザーアカウントで同一です。</target>
        </trans-unit>
        <trans-unit id="371ee180f233c6aad73716af3849b71651b391c0" translate="yes" xml:space="preserve">
          <source>If this option is not specified and the server supports temporary replication slots (version 10 and later), then a temporary replication slot is automatically used for WAL streaming.</source>
          <target state="translated">このオプションが指定されておらず、サーバが一時的なレプリケーションスロット(バージョン10以降)をサポートしている場合、一時的なレプリケーションスロットが自動的にWALストリーミングに使用されます。</target>
        </trans-unit>
        <trans-unit id="2f8215b3963efef20de5d0e001e32b15d0b1fd74" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;Section 33.1&lt;/a&gt; for more information.</source>
          <target state="translated">このパラメーターに &lt;code&gt;=&lt;/code&gt; 記号が含まれているか、有効なURIプレフィックス（ &lt;code&gt;postgresql://&lt;/code&gt; または &lt;code&gt;postgres://&lt;/code&gt; ）で始まっている場合、それは&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;文字列として扱われます。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html&quot;&gt;項33.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="eb980e2e2f9be562491c46b5659937146807845b" translate="yes" xml:space="preserve">
          <source>If this parameter contains an &lt;code&gt;=&lt;/code&gt; sign or starts with a valid URI prefix (&lt;code&gt;postgresql://&lt;/code&gt; or &lt;code&gt;postgres://&lt;/code&gt;), it is treated as a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string. See &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;Section 33.1.1&lt;/a&gt; for more information.</source>
          <target state="translated">このパラメーターに &lt;code&gt;=&lt;/code&gt; 記号が含まれているか、有効なURIプレフィックス（ &lt;code&gt;postgresql://&lt;/code&gt; または &lt;code&gt;postgres://&lt;/code&gt; ）で始まっている場合、それは&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;文字列として扱われます。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNSTRING&quot;&gt;項33.1.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e5a94a371e1e757fb5a74a0f350e7a31fdc8b2c2" translate="yes" xml:space="preserve">
          <source>If this parameter is on, the PostgreSQL server will try to make sure that updates are physically written to disk, by issuing &lt;code&gt;fsync()&lt;/code&gt; system calls or various equivalent methods (see &lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;wal_sync_method&lt;/a&gt;). This ensures that the database cluster can recover to a consistent state after an operating system or hardware crash.</source>
          <target state="translated">このパラメーターがオンの場合、PostgreSQLサーバーは、&lt;a href=&quot;runtime-config-wal#GUC-WAL-SYNC-METHOD&quot;&gt;fsync &lt;/a&gt; &lt;code&gt;fsync()&lt;/code&gt; システムコールまたはさまざまな同等のメソッド（wal_sync_methodを参照）を発行して、更新が物理的にディスクに書き込まれるようにします。これにより、オペレーティングシステムまたはハードウェアのクラッシュ後に、データベースクラスターを一貫した状態に回復できます。</target>
        </trans-unit>
        <trans-unit id="fdad70218c14320d183b5258a94b057b0b9b82eb" translate="yes" xml:space="preserve">
          <source>If this produces no response then this step was successful and you can skip over the remainder of this section.</source>
          <target state="translated">これで応答がない場合は、このステップは成功したことになり、このセクションの残りの部分はスキップできます。</target>
        </trans-unit>
        <trans-unit id="3214ef4d2c8d678533f9cd4aff300140581f95e6" translate="yes" xml:space="preserve">
          <source>If this table is a partition, one cannot perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on a column if it is marked &lt;code&gt;NOT NULL&lt;/code&gt; in the parent table. To drop the &lt;code&gt;NOT NULL&lt;/code&gt; constraint from all the partitions, perform &lt;code&gt;DROP NOT NULL&lt;/code&gt; on the parent table. Even if there is no &lt;code&gt;NOT NULL&lt;/code&gt; constraint on the parent, such a constraint can still be added to individual partitions, if desired; that is, the children can disallow nulls even if the parent allows them, but not the other way around.</source>
          <target state="translated">このテーブルがパーティションの場合、親テーブルで &lt;code&gt;NOT NULL&lt;/code&gt; とマークされていると、列で &lt;code&gt;DROP NOT NULL&lt;/code&gt; を実行できません。すべてのパーティションから &lt;code&gt;NOT NULL&lt;/code&gt; 制約を削除するには、親テーブルで &lt;code&gt;DROP NOT NULL&lt;/code&gt; を実行します。親に &lt;code&gt;NOT NULL&lt;/code&gt; 制約がない場合でも、そのような制約は必要に応じて個々のパーティションに追加できます。つまり、親はnullを許可しても、子はnullを禁止できますが、その逆はできません。</target>
        </trans-unit>
        <trans-unit id="8738e67f4faaa26be7e54ea9f241452e99abdc6a" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">この値を単位なしで指定すると、ミリ秒として扱われます。ゼロ(デフォルト)を指定すると、タイムアウトは無効になります。</target>
        </trans-unit>
        <trans-unit id="f32c0180b724efe2a022fcb4332eb4cf7431bae9" translate="yes" xml:space="preserve">
          <source>If this value is specified without units, it is taken as minutes. A value of &lt;code&gt;-1&lt;/code&gt; (the default) disables this feature, effectively setting the snapshot age limit to infinity. This parameter can only be set at server start.</source>
          <target state="translated">この値が単位なしで指定された場合、分として扱われます。値 &lt;code&gt;-1&lt;/code&gt; （デフォルト）はこの機能を無効にし、スナップショットの保存期間を無限に効果的に設定します。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="a8ab1040fa10ec473399bfff4fa508c435a17bc0" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;ignorespace&lt;/code&gt;, lines which begin with a space are not entered into the history list. If set to a value of &lt;code&gt;ignoredups&lt;/code&gt;, lines matching the previous history line are not entered. A value of &lt;code&gt;ignoreboth&lt;/code&gt; combines the two options. If set to &lt;code&gt;none&lt;/code&gt; (the default), all lines read in interactive mode are saved on the history list.</source>
          <target state="translated">この変数が &lt;code&gt;ignorespace&lt;/code&gt; に設定されている場合、スペースで始まる行は履歴リストに入力されません。 &lt;code&gt;ignoredups&lt;/code&gt; 値に設定すると、前の履歴行と一致する行は入力されません。 &lt;code&gt;ignoreboth&lt;/code&gt; の値は、2つのオプションを組み合わせたものです。 &lt;code&gt;none&lt;/code&gt; （デフォルト）に設定すると、インタラクティブモードで読み込まれたすべての行が履歴リストに保存されます。</target>
        </trans-unit>
        <trans-unit id="7d49403e63b47e4513b7ffed0983ad8f1cca01fe" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;true&lt;/code&gt;, a table's access method details are not displayed. This is mainly useful for regression tests.</source>
          <target state="translated">この変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、テーブルのアクセス方法の詳細は表示されません。これは主に回帰テストに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a5769546d2d4414640c8fa6c471f59d18a32f49e" translate="yes" xml:space="preserve">
          <source>If this variable is set to an integer value greater than zero, the results of &lt;code&gt;SELECT&lt;/code&gt; queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows.</source>
          <target state="translated">この変数がゼロより大きい整数値に設定されている場合、 &lt;code&gt;SELECT&lt;/code&gt; クエリの結果は、表示前に結果セット全体を収集するデフォルトの動作ではなく、その数の行のグループでフェッチおよび表示されます。したがって、結果セットのサイズに関係なく、限られた量のメモリのみが使用されます。この機能を有効にする場合、100〜1000の設定が一般的に使用されます。この機能を使用する場合、すでにいくつかの行を表示した後でクエリが失敗する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76778bde620595af53b04af23a5daa5bc5441843" translate="yes" xml:space="preserve">
          <source>If three or more digits and no date fields have yet been found, interpret as a year (this forces yy-mm-dd ordering of the remaining date fields).</source>
          <target state="translated">3桁以上の数字で日付フィールドがまだ見つからない場合は、年と解釈します(これは残りの日付フィールドの順番を強制的にyy-mm-ddにします)。</target>
        </trans-unit>
        <trans-unit id="81e3a3432036cda1be2139bb1761dc976c1a75c5" translate="yes" xml:space="preserve">
          <source>If true this index has been chosen as &amp;ldquo;replica identity&amp;rdquo; using &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt;</source>
          <target state="translated">trueの場合、このインデックスは、 &lt;code&gt;ALTER TABLE ... REPLICA IDENTITY USING INDEX ...&lt;/code&gt; を使用して「レプリカID」として選択されています。</target>
        </trans-unit>
        <trans-unit id="fb3a87dcd25f91900b7d1fcaa4ea022c5ef4621a" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;DELETE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;DELETE&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="31ebf4870608c0167855b7d0283c52cc09a7d931" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;INSERT&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;INSERT&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="16194e2fdde132d1c172f912b491836e60827cdc" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TRUNCATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;TRUNCATE&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="1ad3497d81a37523e3d7068e040be2588a6f2a7f" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;UPDATE&lt;/code&gt; operations are replicated for tables in the publication.</source>
          <target state="translated">trueの場合、パブリケーション内のテーブルに対して &lt;code&gt;UPDATE&lt;/code&gt; 操作が複製されます。</target>
        </trans-unit>
        <trans-unit id="f3f8473e6cf008d85556519e04a9be2df3d673dd" translate="yes" xml:space="preserve">
          <source>If true, operations on a leaf partition are replicated using the identity and schema of its topmost partitioned ancestor mentioned in the publication instead of its own.</source>
          <target state="translated">true の場合、リーフパーティションの操作は、自分のパーティションではなく、出版物に記載されている一番上のパーティションの祖先の ID とスキーマを使用してレプリケートされます。</target>
        </trans-unit>
        <trans-unit id="ec6d4eb0a14744c8cf642983fb247ca8af2c665e" translate="yes" xml:space="preserve">
          <source>If true, queries must not use the index until the &lt;code&gt;xmin&lt;/code&gt; of this &lt;code&gt;pg_index&lt;/code&gt; row is below their &lt;code&gt;TransactionXmin&lt;/code&gt; event horizon, because the table may contain broken HOT chains with incompatible rows that they can see</source>
          <target state="translated">trueの場合、この &lt;code&gt;pg_index&lt;/code&gt; 行の &lt;code&gt;xmin&lt;/code&gt; が &lt;code&gt;TransactionXmin&lt;/code&gt; イベント期間より下になるまで、クエリはインデックスを使用してはなりません。これは、テーブルに、互換性のない行を含む壊れたHOTチェーンが含まれているためです。</target>
        </trans-unit>
        <trans-unit id="e8ec7f29c2269b6f390b904f6368378dd35f78e8" translate="yes" xml:space="preserve">
          <source>If true, the index is currently ready for inserts. False means the index must be ignored by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations.</source>
          <target state="translated">trueの場合、インデックスは現在挿入の準備ができています。Falseは、 &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 操作でインデックスを無視する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="6c0fcf74070493f9e01640902cbfc0c6b38f7360" translate="yes" xml:space="preserve">
          <source>If true, the index is currently valid for queries. False means the index is possibly incomplete: it must still be modified by &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt; operations, but it cannot safely be used for queries. If it is unique, the uniqueness property is not guaranteed true either.</source>
          <target state="translated">trueの場合、インデックスは現在クエリに対して有効です。falseは、インデックスが不完全である可能性があることを意味します &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; 操作で変更する必要がありますが、クエリに安全に使用することはできません。一意である場合、一意性プロパティも真であるとは保証されません。</target>
        </trans-unit>
        <trans-unit id="ab6de0df41664d3b3675c49edb64211adc3a12b2" translate="yes" xml:space="preserve">
          <source>If true, the stats include inheritance child columns, not just the values in the specified relation</source>
          <target state="translated">true の場合、統計情報には、指定されたリレーションの値だけでなく、継承された子カラムも含まれます。</target>
        </trans-unit>
        <trans-unit id="ee7718b7881ae44cc98ca7be7fa2735272d5a098" translate="yes" xml:space="preserve">
          <source>If true, the subscription is enabled and should be replicating.</source>
          <target state="translated">true の場合、サブスクリプションが有効になっており、レプリケートされている必要があります。</target>
        </trans-unit>
        <trans-unit id="aa9a0941d117d4d0d6546de8ecf8d6c048b76081" translate="yes" xml:space="preserve">
          <source>If true, the table was last clustered on this index</source>
          <target state="translated">true の場合、テーブルがこのインデックスで最後にクラスタ化されたのは</target>
        </trans-unit>
        <trans-unit id="0629da4ff91f39f869bbe66ce6c66a0e0b5d1ffd" translate="yes" xml:space="preserve">
          <source>If true, the uniqueness check is enforced immediately on insertion (irrelevant if &lt;code&gt;indisunique&lt;/code&gt; is not true)</source>
          <target state="translated">trueの場合、挿入時にただちに一意性チェックが実行されます（ &lt;code&gt;indisunique&lt;/code&gt; がtrueでない場合は関係ありません）。</target>
        </trans-unit>
        <trans-unit id="588ebeeb8e4b96440c5bf3cc0c1bd5854026d4e7" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false (the default), then only superusers or the owner of the database can clone it.</source>
          <target state="translated">trueの場合、このデータベースは &lt;code&gt;CREATEDB&lt;/code&gt; 特権を持つ任意のユーザーが複製できます。false（デフォルト）の場合、スーパーユーザーまたはデータベースの所有者のみがクローンを作成できます。</target>
        </trans-unit>
        <trans-unit id="7d71cd9fec73126b99ae1f7d42db7f62a2b72e24" translate="yes" xml:space="preserve">
          <source>If true, then this database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if false, then only superusers or the owner of the database can clone it.</source>
          <target state="translated">trueの場合、このデータベースは &lt;code&gt;CREATEDB&lt;/code&gt; 特権を持つ任意のユーザーが複製できます。falseの場合、スーパーユーザーまたはデータベースの所有者のみが複製できます。</target>
        </trans-unit>
        <trans-unit id="1accbb6daee5f69b5c0f42943992a092e4ba1074" translate="yes" xml:space="preserve">
          <source>If true, this index represents the primary key of the table (&lt;code&gt;indisunique&lt;/code&gt; should always be true when this is true)</source>
          <target state="translated">trueの場合、このインデックスはテーブルの主キーを表します（これがtrueの場合、 &lt;code&gt;indisunique&lt;/code&gt; は常にtrueである必要があります）</target>
        </trans-unit>
        <trans-unit id="0f6e2116d6074f49b9f7bdf86e12bdd873ed8149" translate="yes" xml:space="preserve">
          <source>If true, this index supports an exclusion constraint</source>
          <target state="translated">真の場合、このインデックスは除外制約をサポートします。</target>
        </trans-unit>
        <trans-unit id="eb9d897ba2f316e5badcbcf694b6980e5d7c7ad0" translate="yes" xml:space="preserve">
          <source>If true, this is a unique index</source>
          <target state="translated">true の場合、これは一意のインデックスです。</target>
        </trans-unit>
        <trans-unit id="6763aa747866133b7f56f2197fde582b044036d1" translate="yes" xml:space="preserve">
          <source>If true, this publication automatically includes all tables in the database, including any that will be created in the future.</source>
          <target state="translated">true の場合、この出版物には、将来作成されるテーブルも含めて、データベース内のすべてのテーブルが自動的に含まれます。</target>
        </trans-unit>
        <trans-unit id="2b4a0e4917a40fa5601228c6bffce7ba0283b004" translate="yes" xml:space="preserve">
          <source>If true, this row includes inheritance child columns, not just the values in the specified table</source>
          <target state="translated">true の場合、この行には、指定されたテーブルの値だけでなく、継承された子カラムも含まれます。</target>
        </trans-unit>
        <trans-unit id="b5af22ae5132cfdb3c63b86048053d7c0759cd52" translate="yes" xml:space="preserve">
          <source>If two such transactions concurrently try to change the balance of account 12345, we clearly want the second transaction to start with the updated version of the account's row. Because each command is affecting only a predetermined row, letting it see the updated version of the row does not create any troublesome inconsistency.</source>
          <target state="translated">このような2つのトランザクションが同時に12345口座の残高を変更しようとする場合、2番目のトランザクションは明らかにその口座の行の更新されたバージョンから開始したいと思います。それぞれのコマンドはあらかじめ決められた行にのみ影響を与えているので、行の更新されたバージョンを表示させても、面倒な矛盾は生じません。</target>
        </trans-unit>
        <trans-unit id="286da9748bbda59905be5dc346e8fae92aa0edfb" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, begin your session by removing publicly-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. One can add &lt;code&gt;options=-csearch_path=&lt;/code&gt; to the connection string or issue &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; before other SQL commands. This consideration is not specific to psql; it applies to every interface for executing arbitrary SQL commands.</source>
          <target state="translated">信頼できないユーザーが、&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;安全なスキーマ使用パターンを&lt;/a&gt;採用していないデータベースにアクセスできる場合は、 &lt;code&gt;search_path&lt;/code&gt; からパブリックに書き込み可能なスキーマを削除して、セッションを開始します。他のSQLコマンドの前に &lt;code&gt;SELECT pg_catalog.set_config('search_path', '', false)&lt;/code&gt; &lt;code&gt;options=-csearch_path=&lt;/code&gt; を接続文字列に追加するか、SELECT pg_catalog.set_config（ 'search_path'、 ''、false）を発行できます。この考慮事項は、psqlに固有のものではありません。これは、任意のSQLコマンドを実行するためのすべてのインターフェースに適用されます。</target>
        </trans-unit>
        <trans-unit id="768ed7df41fe42c9b25945d5dff896541bf55b4f" translate="yes" xml:space="preserve">
          <source>If untrusted users have access to a database that has not adopted a &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;secure schema usage pattern&lt;/a&gt;, do not run pgbench in that database. pgbench uses unqualified names and does not manipulate the search path.</source>
          <target state="translated">信頼できないユーザーが、&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;安全なスキーマ使用パターンを&lt;/a&gt;採用していないデータベースにアクセスできる場合は、そのデータベースでpgbenchを実行しないでください。pgbenchは非修飾名を使用し、検索パスを操作しません。</target>
        </trans-unit>
        <trans-unit id="91d0d0478151e73c50542244d9425b00c1130633" translate="yes" xml:space="preserve">
          <source>If using WAL archiving or streaming replication, consider disabling them during the restore. To do that, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;minimal&lt;/code&gt;, and &lt;code&gt;max_wal_senders&lt;/code&gt; to zero before loading the dump. Afterwards, set them back to the right values and take a fresh base backup.</source>
          <target state="translated">WALアーカイブまたはストリーミングレプリケーションを使用している場合は、復元中にそれらを無効にすることを検討してください。これを行うには、ダンプをロードする前に、 &lt;code&gt;archive_mode&lt;/code&gt; を &lt;code&gt;off&lt;/code&gt; に、 &lt;code&gt;wal_level&lt;/code&gt; を &lt;code&gt;minimal&lt;/code&gt; に、 &lt;code&gt;max_wal_senders&lt;/code&gt; をゼロに設定します。その後、それらを正しい値に設定し直して、新しいベースバックアップを作成します。</target>
        </trans-unit>
        <trans-unit id="82f833ab3393a0e44827283b4406b6a15d35b9df" translate="yes" xml:space="preserve">
          <source>If using a pre-9.1 old server that is using a non-default Unix-domain socket directory or a default that differs from the default of the new cluster, set &lt;code&gt;PGHOST&lt;/code&gt; to point to the old server's socket location. (This is not relevant on Windows.)</source>
          <target state="translated">デフォルト以外のUnixドメインソケットディレクトリを使用している9.1より前の古いサーバー、または新しいクラスターのデフォルトとは異なるデフォルトを使用する場合は、 &lt;code&gt;PGHOST&lt;/code&gt; を設定して古いサーバーのソケットの場所を指定します。（これはWindowsでは関係ありません。）</target>
        </trans-unit>
        <trans-unit id="1fc1fe1aaf9532782aa2ed49cabaa7db59b86f4e" translate="yes" xml:space="preserve">
          <source>If waiting is disabled, the requested action is triggered, but there is no feedback about its success. In that case, the server log file or an external monitoring system would have to be used to check the progress and success of the operation.</source>
          <target state="translated">待機が無効になっている場合、要求されたアクションはトリガされますが、その成功に関するフィードバックはありません。その場合、サーバーのログファイルや外部監視システムを使用して操作の進捗と成功をチェックしなければなりません。</target>
        </trans-unit>
        <trans-unit id="7b03befc0afa9f43bd61408ea6224efc69f041cf" translate="yes" xml:space="preserve">
          <source>If we change the query's selectivity a bit, we might get a very different join plan:</source>
          <target state="translated">クエリの選択性を少し変えれば、まったく異なる結合プランが得られるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3514492aa3ac15aedee53bae788660dc8e748122" translate="yes" xml:space="preserve">
          <source>If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a &lt;em&gt;warm standby&lt;/em&gt; system: at any point we can bring up the second machine and it will have a nearly-current copy of the database.</source>
          <target state="translated">同じ基本バックアップファイルがロードされている別のマシンに一連のWALファイルを継続的にフィードする場合、&lt;em&gt;ウォームスタンバイ&lt;/em&gt;システムがあります。いつでも2番目のマシンを起動でき、ほぼ最新のコピーが作成されます。データベース。</target>
        </trans-unit>
        <trans-unit id="a739f17951b6e075a348a61e8bb0affec3a10686" translate="yes" xml:space="preserve">
          <source>If we declared &lt;code&gt;cities&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; to be &lt;code&gt;UNIQUE&lt;/code&gt; or a &lt;code&gt;PRIMARY KEY&lt;/code&gt;, this would not stop the &lt;code&gt;capitals&lt;/code&gt; table from having rows with names duplicating rows in &lt;code&gt;cities&lt;/code&gt;. And those duplicate rows would by default show up in queries from &lt;code&gt;cities&lt;/code&gt;. In fact, by default &lt;code&gt;capitals&lt;/code&gt; would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to &lt;code&gt;capitals&lt;/code&gt;, but this would not prevent duplication compared to &lt;code&gt;cities&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cities&lt;/code&gt; を宣言した場合。 &lt;code&gt;name&lt;/code&gt; を &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; にする必要があります。これにより、 &lt;code&gt;capitals&lt;/code&gt; テーブルに名前の付いた行が &lt;code&gt;cities&lt;/code&gt; 行と重複するのを防ぐことはできません。そして、これらの重複する行は、デフォルトで &lt;code&gt;cities&lt;/code&gt; からのクエリに表示されます。実際、デフォルトでは、 &lt;code&gt;capitals&lt;/code&gt; は一意の制約がまったくないため、同じ名前の複数の行を含めることができます。 &lt;code&gt;capitals&lt;/code&gt; に一意の制約を追加することもできますが、 &lt;code&gt;cities&lt;/code&gt; と比較して重複を防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="347337a04b51d83bd4c64fbb8fed60949423b25a" translate="yes" xml:space="preserve">
          <source>If we wanted to know what city (or cities) that reading occurred in, we might try:</source>
          <target state="translated">もし、その読書がどの都市(または都市)で起こったのかを知りたいと思ったら、試してみるといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="d101ff564aae9ba45b998f26d6b5819ae89be6cf" translate="yes" xml:space="preserve">
          <source>If we were to declare this index &lt;code&gt;UNIQUE&lt;/code&gt;, it would prevent creation of rows whose &lt;code&gt;col1&lt;/code&gt; values differ only in case, as well as rows whose &lt;code&gt;col1&lt;/code&gt; values are actually identical. Thus, indexes on expressions can be used to enforce constraints that are not definable as simple unique constraints.</source>
          <target state="translated">このインデックスを &lt;code&gt;UNIQUE&lt;/code&gt; と宣言すると、 &lt;code&gt;col1&lt;/code&gt; の値が大文字と小文字のみが異なる行や、 &lt;code&gt;col1&lt;/code&gt; の値が実際に同じ行が作成されなくなります。したがって、式のインデックスを使用して、単純な一意の制約として定義できない制約を適用できます。</target>
        </trans-unit>
        <trans-unit id="26385616d9682a5e8b9897f0b99ebecc8622b226" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">継続的に維持される一貫性の保証ではなく、行挿入時に他の行に対する1回限りのチェックが必要な場合は、カスタム&lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;トリガー&lt;/a&gt;を使用してそれを実装できます。（このアプローチでは、データの再読み込みが完了するまでpg_dumpがトリガーを再インストールしないため、ダンプ/再読み込みの問題が回避され、ダンプ/再読み込み中にチェックが強制されません。）</target>
        </trans-unit>
        <trans-unit id="bccf2a93440f14e5520a966b4714acd9fc9f1297" translate="yes" xml:space="preserve">
          <source>If what you desire is a one-time check against other rows at row insertion, rather than a continuously-maintained consistency guarantee, a custom &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;trigger&lt;/a&gt; can be used to implement that. (This approach avoids the dump/reload problem because pg_dump does not reinstall triggers until after reloading data, so that the check will not be enforced during a dump/reload.)</source>
          <target state="translated">継続的に維持される整合性の保証ではなく、行の挿入時に他の行に対する1回限りのチェックが必要な場合は、カスタム&lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;トリガー&lt;/a&gt;を使用してそれを実装できます。（このアプローチでは、データをリロードするまでpg_dumpがトリガーを再インストールしないため、ダンプ/リロードの問題が回避されます。そのため、ダンプ/リロード中にチェックが実行されません。）</target>
        </trans-unit>
        <trans-unit id="1a14ecb62361bc225683313f20ed64062f67ccd0" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">孤立したラージオブジェクトをすでに持っているか、持っていると思われる場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/vacuumlo.html&quot;&gt;vacuumulo&lt;/a&gt;モジュールを参照して、それらをクリーンアップしてください。 &lt;code&gt;lo_manage&lt;/code&gt; トリガーへのバックストップとして時折vacuumloを実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9d59e957767c53445cccc5f8621efd7719624cb5" translate="yes" xml:space="preserve">
          <source>If you already have, or suspect you have, orphaned large objects, see the &lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuumlo&lt;/a&gt; module to help you clean them up. It's a good idea to run vacuumlo occasionally as a back-stop to the &lt;code&gt;lo_manage&lt;/code&gt; trigger.</source>
          <target state="translated">孤立した大きなオブジェクトをすでに持っている、または持っている疑いがある場合は、&lt;a href=&quot;https://www.postgresql.org/docs/13/vacuumlo.html&quot;&gt;vacuolo&lt;/a&gt;モジュールを参照してそれらをクリーンアップしてください。 &lt;code&gt;lo_manage&lt;/code&gt; トリガーのバックストップとして、vacuumloを時々実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f390f29503d5d3e24b107064bb2a33c6ee6ea964" translate="yes" xml:space="preserve">
          <source>If you are adding large amounts of data to an existing table, it might be a win to drop the indexes, load the table, and then recreate the indexes. Of course, the database performance for other users might suffer during the time the indexes are missing. One should also think twice before dropping a unique index, since the error checking afforded by the unique constraint will be lost while the index is missing.</source>
          <target state="translated">既存のテーブルに大量のデータを追加する場合は、インデックスを落としてテーブルをロードしてからインデックスを作り直すのが得策かもしれません。もちろん、インデックスがない間は他のユーザーのデータベースのパフォーマンスが低下するかもしれません。また、ユニークなインデックスを削除する前には、ユニークな制約によって与えられたエラーチェックがインデックスがない間に失われてしまうので、二度考えてみるべきです。</target>
        </trans-unit>
        <trans-unit id="f9e2dec1d154e8ddecdda1dfc7964b3ebcabb443" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">PostgreSQLを自分でインストールする場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章を&lt;/a&gt;参照してインストール手順を確認し、インストールが完了したらこのガイドに戻ってください。適切な環境変数の設定に関するセクションに必ず従ってください。</target>
        </trans-unit>
        <trans-unit id="cd8e24142c807e0a347a699916b6cae27e9af283" translate="yes" xml:space="preserve">
          <source>If you are installing PostgreSQL yourself, then refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;Chapter 16&lt;/a&gt; for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.</source>
          <target state="translated">PostgreSQLを自分でインストールする場合は、インストールの手順について&lt;a href=&quot;https://www.postgresql.org/docs/13/installation.html&quot;&gt;第16章を&lt;/a&gt;参照し、インストールが完了したらこのガイドに戻ってください。適切な環境変数の設定に関するセクションに必ず従ってください。</target>
        </trans-unit>
        <trans-unit id="deb64bee8b7a2efcbeba6cf8a6dff70e83085729" translate="yes" xml:space="preserve">
          <source>If you are loading a freshly created table, the fastest method is to create the table, bulk load the table's data using &lt;code&gt;COPY&lt;/code&gt;, then create any indexes needed for the table. Creating an index on pre-existing data is quicker than updating it incrementally as each row is loaded.</source>
          <target state="translated">新しく作成したテーブルをロードする場合、最速の方法はテーブルを作成し、 &lt;code&gt;COPY&lt;/code&gt; を使用してテーブルのデータを一括でロードしてから、テーブルに必要なインデックスを作成することです。既存のデータにインデックスを作成する方が、各行がロードされるときに増分的に更新するよりも高速です。</target>
        </trans-unit>
        <trans-unit id="d87d9e34c581612e87603daaced88774ab9fe111" translate="yes" xml:space="preserve">
          <source>If you are not planning to use prepared transactions, this parameter should be set to zero to prevent accidental creation of prepared transactions. If you are using prepared transactions, you will probably want &lt;code&gt;max_prepared_transactions&lt;/code&gt; to be at least as large as &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;, so that every session can have a prepared transaction pending.</source>
          <target state="translated">準備済みトランザクションを使用する予定がない場合は、このパラメーターをゼロに設定して、準備済みトランザクションが誤って作成されないようにする必要があります。準備済みトランザクションを使用している場合は、おそらく &lt;code&gt;max_prepared_transactions&lt;/code&gt; を少なくとも&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;と同じ大きさにして、すべてのセッションが準備済みトランザクションを保留できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="ca7f65648bc353887b727a182f8f612fdb9429de" translate="yes" xml:space="preserve">
          <source>If you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.</source>
          <target state="translated">PostgreSQLがすでに利用可能かどうかわからない場合や、実験に使えるかどうかわからない場合は、自分でインストールすることができます。これは難しいことではありませんし、良い練習にもなります。PostgreSQLは権限のないユーザであれば誰でもインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="6c854ded65666fb7e53665772a506fafbd718961" translate="yes" xml:space="preserve">
          <source>If you are running file-based log shipping (&quot;warm standby&quot;), you might need to wait until the next WAL file arrives, which could be as long as the &lt;code&gt;archive_timeout&lt;/code&gt; setting on the primary.</source>
          <target state="translated">ファイルベースのログ配布（「ウォームスタンバイ」）を実行している場合は、次のWALファイルが到着するまで待機する必要があります。これは、プライマリの &lt;code&gt;archive_timeout&lt;/code&gt; 設定と同じ長さになる場合があります。</target>
        </trans-unit>
        <trans-unit id="100df6210b436366664b5674494d353d329c78c1" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g. &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">設定ファイルのみのディレクトリを使用するPostgreSQL 9.2より前のクラスターをアップグレードする場合、実際のデータディレクトリの場所をpg_upgradeに渡し、設定ディレクトリの場所をサーバーに渡す必要があります（例： &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc55bda54288eb26294b0ebbfc29f843e85f5f66" translate="yes" xml:space="preserve">
          <source>If you are upgrading a pre-PostgreSQL 9.2 cluster that uses a configuration-file-only directory, you must pass the real data directory location to pg_upgrade, and pass the configuration directory location to the server, e.g., &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt;.</source>
          <target state="translated">構成ファイルのみのディレクトリを使用するPostgreSQL9.2より前のクラスタをアップグレードする場合は、実際のデータディレクトリの場所をpg_upgradeに渡し、構成ディレクトリの場所をサーバーに渡す必要があります（例： &lt;code&gt;-d /real-data-directory -o '-D /configuration-directory'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6433dfa1c8ec93408de2c79d0f13ec3cb038d812" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, change &lt;code&gt;wal_level&lt;/code&gt; to &lt;code&gt;replica&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">セクション&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;10&lt;/a&gt;で概説されている方法を使用してスタンバイサーバーをアップグレードする場合は、古いプライマリクラスターとスタンバイクラスターに対してpg_controldataを実行して、古いスタンバイサーバーが追いついていることを確認します。「最新のチェックポイントの場所」の値がすべてのクラスターで一致していることを確認します。（古いスタンバイサーバーが古いプライマリサーバーの前にシャットダウンされた場合、または古いスタンバイサーバーがまだ実行されている場合は、不一致になります。）また、新しいプライマリクラスターの &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルで &lt;code&gt;wal_level&lt;/code&gt; を &lt;code&gt;replica&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="a25fedf0ac6ffff68a2762449d5371eee093e033" translate="yes" xml:space="preserve">
          <source>If you are upgrading standby servers using methods outlined in section &lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;Step 10&lt;/a&gt;, verify that the old standby servers are caught up by running pg_controldata against the old primary and standby clusters. Verify that the &amp;ldquo;Latest checkpoint location&amp;rdquo; values match in all clusters. (There will be a mismatch if old standby servers were shut down before the old primary or if the old standby servers are still running.) Also, make sure &lt;code&gt;wal_level&lt;/code&gt; is not set to &lt;code&gt;minimal&lt;/code&gt; in the &lt;code&gt;postgresql.conf&lt;/code&gt; file on the new primary cluster.</source>
          <target state="translated">セクション&lt;a href=&quot;pgupgrade#PGUPGRADE-STEP-REPLICAS&quot;&gt;ステップ10&lt;/a&gt;で概説されている方法を使用してスタンバイサーバーをアップグレードする場合は、古いプライマリクラスターとスタンバイクラスターに対してpg_controldataを実行して、古いスタンバイサーバーが追いついていることを確認します。 「最新のチェックポイントの場所」の値がすべてのクラスターで一致することを確認します。 （古いスタンバイサーバは古いプライマリの前または古いスタンバイサーバがまだ実行されている場合はシャットダウンした場合のミスマッチがあります。）また、確認してください &lt;code&gt;wal_level&lt;/code&gt; がに設定されていない &lt;code&gt;minimal&lt;/code&gt; に &lt;code&gt;postgresql.conf&lt;/code&gt; のの新しい主クラスタ上のファイル。</target>
        </trans-unit>
        <trans-unit id="4f73d78215cef8d2ef14222445477bdca411ef71" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;-X none&lt;/code&gt;, there is no guarantee that all WAL files required for the backup are archived at the end of backup.</source>
          <target state="translated">&lt;code&gt;-X none&lt;/code&gt; を使用している場合、バックアップに必要なすべてのWALファイルがバックアップの最後にアーカイブされる保証はありません。</target>
        </trans-unit>
        <trans-unit id="9d0f772d8182283e7e8eeabb4a80f986e054e96a" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, and you used its provisions for starting the server, then you should also use its provisions for stopping the server. Consult the package-level documentation for details.</source>
          <target state="translated">事前にパッケージ化されたバージョンのPostgreSQLを使用していて、サーバを起動するためにその規定を使用している場合、サーバを停止するためにもその規定を使用すべきです。詳細はパッケージレベルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="cc432d389e68b3790013be9ab641ccb60838ff96" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it almost certainly includes provisions for running the server as a background task according to the conventions of your operating system. Using the package's infrastructure to start the server will be much less work than figuring out how to do this yourself. Consult the package-level documentation for details.</source>
          <target state="translated">PostgreSQLの事前にパッケージ化されたバージョンを使用している場合、ほとんどの場合、オペレーティングシステムの規約に従ってバックグラウンドタスクとしてサーバを実行するための規定が含まれています。パッケージのインフラストラクチャを使用してサーバを起動することは、自分でこれを行う方法を考えるよりもはるかに少ない労力で済みます。詳細はパッケージレベルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="4ec81265be63b85cd110675b546ea20c69a22e29" translate="yes" xml:space="preserve">
          <source>If you are using a pre-packaged version of PostgreSQL, it may well have a specific convention for where to place the data directory, and it may also provide a script for creating the data directory. In that case you should use that script in preference to running &lt;code&gt;initdb&lt;/code&gt; directly. Consult the package-level documentation for details.</source>
          <target state="translated">事前にパッケージ化されたバージョンのPostgreSQLを使用している場合は、データディレクトリを配置する場所について特定の規則があり、データディレクトリを作成するためのスクリプトも提供される場合があります。その場合、 &lt;code&gt;initdb&lt;/code&gt; を直接実行するよりも、そのスクリプトを使用する必要があります。詳細については、パッケージレベルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e87540bbfb46f5ca553285a02a78a4413f99dfe1" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g. &lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">&lt;code&gt;/opt/PostgreSQL/12&lt;/code&gt; などのバージョン固有のインストールディレクトリを使用している場合は、古いクラスターを移動する必要はありません。グラフィカルインストーラはすべて、バージョン固有のインストールディレクトリを使用します。</target>
        </trans-unit>
        <trans-unit id="d8bbcc7b0eac5395154e7966b802a1726a037170" translate="yes" xml:space="preserve">
          <source>If you are using a version-specific installation directory, e.g., &lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt;, you do not need to move the old cluster. The graphical installers all use version-specific installation directories.</source>
          <target state="translated">&lt;code&gt;/opt/PostgreSQL/13&lt;/code&gt; などのバージョン固有のインストールディレクトリを使用している場合は、古いクラスタを移動する必要はありません。グラフィカルインストーラーはすべて、バージョン固有のインストールディレクトリを使用します。</target>
        </trans-unit>
        <trans-unit id="afb6b5bbb35f9c84113d155adac8b2ce50841366" translate="yes" xml:space="preserve">
          <source>If you are using manual &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; commands, don't forget that you need to run them on each child table individually. A command like:</source>
          <target state="translated">手動の &lt;code&gt;VACUUM&lt;/code&gt; または &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを使用している場合は、各子テーブルで個別に実行する必要があることを忘れないでください。次のようなコマンド：</target>
        </trans-unit>
        <trans-unit id="657742cf08661b004524bce37cea4f60251b3473" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g. solid-state drives, might also be better modeled with a lower value for random_page_cost.</source>
          <target state="translated">90%のキャッシュ率がワークロードの前提として正しくないと考えている場合、ランダムストレージの読み込みの真のコストをより良く反映するために random_page_cost を増加させることができます。これに対応して、データベースがサーバの総メモリよりも小さい場合など、データが完全にキャッシュされる可能性が高い場合は、random_page_costを減少させることが適切な場合があります。ソリッドステートドライブなど、シーケンシャルに比べてランダムリードコストが低いストレージは、random_page_costの値を下げてモデル化する方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="01590de3b1a45b503095ec546feb704e9b7a0246" translate="yes" xml:space="preserve">
          <source>If you believe a 90% cache rate is an incorrect assumption for your workload, you can increase random_page_cost to better reflect the true cost of random storage reads. Correspondingly, if your data is likely to be completely in cache, such as when the database is smaller than the total server memory, decreasing random_page_cost can be appropriate. Storage that has a low random read cost relative to sequential, e.g., solid-state drives, might also be better modeled with a lower value for random_page_cost, e.g., &lt;code&gt;1.1&lt;/code&gt;.</source>
          <target state="translated">90％のキャッシュ率がワークロードの誤った仮定であると思われる場合は、random_page_costを増やして、ランダムストレージ読み取りの実際のコストをより適切に反映させることができます。同様に、データベースがサーバーの合計メモリよりも小さい場合など、データが完全にキャッシュにある可能性が高い場合は、random_page_costを減らすことが適切な場合があります。シーケンシャルドライブ（ソリッドステートドライブなど）に比べてランダム読み取りコストが低いストレージも、random_page_costの値を低くしてモデル化する方が適切な場合があります（例： &lt;code&gt;1.1&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="de352785d4d320deb71e5335924b75625cf49620" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;\set&lt;/code&gt; without a second argument, the variable is set to an empty-string value. To unset (i.e., delete) a variable, use the command &lt;code&gt;\unset&lt;/code&gt;. To show the values of all variables, call &lt;code&gt;\set&lt;/code&gt; without any argument.</source>
          <target state="translated">2番目の引数なしで &lt;code&gt;\set&lt;/code&gt; を呼び出すと、変数は空の文字列値に設定されます。変数を設定解除（削除）するには、コマンド &lt;code&gt;\unset&lt;/code&gt; 使用します。すべての変数の値を表示するには、引数なしで &lt;code&gt;\set&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="0259699cb6f3b30e1cd0e413c4e39248024e19a0" translate="yes" xml:space="preserve">
          <source>If you cannot free up additional space on the disk by deleting other things, you can move some of the database files to other file systems by making use of tablespaces. See &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt; for more information about that.</source>
          <target state="translated">他のものを削除してもディスク上の追加スペースを解放できない場合は、テーブルスペースを利用して、データベースファイルの一部を他のファイルシステムに移動できます。詳細については、&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;セクション22.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a6b2ee409cca3f880cf89818705f66642823737c" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;code&gt;COPY&lt;/code&gt;, it might help to use &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt; to create a prepared &lt;code&gt;INSERT&lt;/code&gt; statement, and then use &lt;code&gt;EXECUTE&lt;/code&gt; as many times as required. This avoids some of the overhead of repeatedly parsing and planning &lt;code&gt;INSERT&lt;/code&gt;. Different interfaces provide this facility in different ways; look for &amp;ldquo;prepared statements&amp;rdquo; in the interface documentation.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; を使用できない場合は、&lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;を使用して準備済み &lt;code&gt;INSERT&lt;/code&gt; ステートメントを作成し、 &lt;code&gt;EXECUTE&lt;/code&gt; を必要な回数だけ使用すると役立つ場合があります。これにより、 &lt;code&gt;INSERT&lt;/code&gt; を繰り返し解析および計画するオーバーヘッドの一部が回避されます。この機能は、インターフェイスごとに異なる方法で提供されます。インターフェイスのドキュメントで「準備されたステートメント」を探します。</target>
        </trans-unit>
        <trans-unit id="f74f5e82fb19007ba8087ea69c4af7c169641fbd" translate="yes" xml:space="preserve">
          <source>If you cannot, then better do crypto inside client application.</source>
          <target state="translated">できない場合は、クライアントアプリケーションの内部で暗号化を行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c6938a67160fbaea3812e5c1afc009d637ef7fc7" translate="yes" xml:space="preserve">
          <source>If you declare a column as &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt;, the implicitly generated index is case-sensitive. So it's useless for case-insensitive searches, and it won't enforce uniqueness case-insensitively.</source>
          <target state="translated">列を &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; として宣言する場合、暗黙的に生成されるインデックスでは大文字と小文字が区別されます。したがって、大文字と小文字を区別しない検索では役に立たず、大文字と小文字を区別せずに一意性を強制しません。</target>
        </trans-unit>
        <trans-unit id="bab8b24944cb37a1a0e9e93c41e90f5a2cb6ccb4" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; start the new cluster, the old cluster was unmodified except that, when linking started, a &lt;code&gt;.old&lt;/code&gt; suffix was appended to &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;. To reuse the old cluster, remove the &lt;code&gt;.old&lt;/code&gt; suffix from &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt;; you can then restart the old cluster.</source>
          <target state="translated">新しいクラスターを開始し&lt;em&gt;なかった&lt;/em&gt;場合、リンクの開始時に &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; &lt;code&gt;.old&lt;/code&gt; サフィックスが追加されたことを除いて、古いクラスターは変更されていません。古いクラスターを再利用するには、 &lt;code&gt;$PGDATA/global/pg_control&lt;/code&gt; から &lt;code&gt;.old&lt;/code&gt; サフィックスを削除します。その後、古いクラスターを再起動できます。</target>
        </trans-unit>
        <trans-unit id="62b2adb362a08de49cfa1c83dea8a83d9bb2213c" translate="yes" xml:space="preserve">
          <source>If you did &lt;em&gt;not&lt;/em&gt; use link mode, do not have or do not want to use rsync, or want an easier solution, skip the instructions in this section and simply recreate the standby servers once pg_upgrade completes and the new primary is running.</source>
          <target state="translated">あなたがいなければ&lt;em&gt;いない&lt;/em&gt;リンクモードを使用し、持っていないかのrsyncを使用したくない、または容易に解決をしたい、このセクションの手順を省略し、単にpg_upgradeのは完了し、新しいプライマリが実行されている一度スタンバイサーバを再作成します。</target>
        </trans-unit>
        <trans-unit id="90981d7a01c90cf36de6cae3508f26abcc450f7b" translate="yes" xml:space="preserve">
          <source>If you did start the new cluster, it has written to shared files and it is unsafe to use the old cluster. The old cluster will need to be restored from backup in this case.</source>
          <target state="translated">新しいクラスタを起動した場合、共有ファイルに書き込まれており、古いクラスタを使用することは安全ではありません。この場合、古いクラスタをバックアップから復元する必要があります。</target>
        </trans-unit>
        <trans-unit id="47fd87d8debe284e9f481467ae1affc261e54ea8" translate="yes" xml:space="preserve">
          <source>If you do not like the output format for &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; values, try the functions &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, and &lt;code&gt;abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; または &lt;code&gt;cidr&lt;/code&gt; 値の出力形式が気に入らない場合は、関数 &lt;code&gt;host&lt;/code&gt; 、 &lt;code&gt;text&lt;/code&gt; 、および &lt;code&gt;abbrev&lt;/code&gt; を試してください。</target>
        </trans-unit>
        <trans-unit id="f96a8ec302a42bc03e998712a66f544972ee1509" translate="yes" xml:space="preserve">
          <source>If you do not succeed in adjusting the costs to be more appropriate, then you might have to resort to forcing index usage explicitly. You might also want to contact the PostgreSQL developers to examine the issue.</source>
          <target state="translated">コストをより適切なものに調整することに成功しない場合は、明示的にインデックスの使用を強制することに頼らざるを得ないかもしれません。また、PostgreSQLの開発者に問い合わせて検討してみるのも良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="b4cd7de986e411178ee91fc3fe47680a23518cd4" translate="yes" xml:space="preserve">
          <source>If you do not supply the database name then it will default to your user account name. You already discovered this scheme in the previous section using &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">データベース名を指定しない場合、デフォルトでユーザーアカウント名になります。このスキームは、前のセクションで &lt;code&gt;createdb&lt;/code&gt; を使用してすでに発見しています。</target>
        </trans-unit>
        <trans-unit id="be339a6a88d4d2b9b65bab603b8e3c0d2fd399fd" translate="yes" xml:space="preserve">
          <source>If you do not want to use your database anymore you can remove it. For example, if you are the owner (creator) of the database &lt;code&gt;mydb&lt;/code&gt;, you can destroy it using the following command:</source>
          <target state="translated">データベースを使用したくない場合は、データベースを削除できます。たとえば、データベース &lt;code&gt;mydb&lt;/code&gt; の所有者（作成者）であれば、次のコマンドを使用してデータベースを破棄できます。</target>
        </trans-unit>
        <trans-unit id="08e08381cd8f923213bb0bae5a2a61f673142186" translate="yes" xml:space="preserve">
          <source>If you don't have values for all the columns, you can omit some of them. In that case, the columns will be filled with their default values. For example:</source>
          <target state="translated">すべてのカラムに値がない場合は、いくつかのカラムを省略することができます。その場合、その列はデフォルト値で埋められます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="404e82d0a58303983c4b5022b612f1fb6248be48" translate="yes" xml:space="preserve">
          <source>If you drop and then recreate a function, the new function is not the same entity as the old; you will have to drop existing rules, views, triggers, etc. that refer to the old function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; to change a function definition without breaking objects that refer to the function. Also, &lt;code&gt;ALTER FUNCTION&lt;/code&gt; can be used to change most of the auxiliary properties of an existing function.</source>
          <target state="translated">関数を削除してから再作成すると、新しい関数は古い関数と同じエンティティではありません。古い関数を参照する既存のルール、ビュー、トリガーなどを削除する必要があります。 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; を使用して、関数を参照するオブジェクトを壊すことなく関数定義を変更します。また、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; を使用して、既存の関数のほとんどの補助プロパティを変更できます。</target>
        </trans-unit>
        <trans-unit id="be307ca6bbc030429d0d787ca8543b0973b17c65" translate="yes" xml:space="preserve">
          <source>If you encounter problems starting &lt;code&gt;psql&lt;/code&gt; then go back to the previous section. The diagnostics of &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;psql&lt;/code&gt; are similar, and if the former worked the latter should work as well.</source>
          <target state="translated">&lt;code&gt;psql&lt;/code&gt; の起動時に問題が発生した場合は、前のセクションに戻ってください。 &lt;code&gt;createdb&lt;/code&gt; と &lt;code&gt;psql&lt;/code&gt; の診断は似ており、前者が機能すれば後者も機能するはずです。</target>
        </trans-unit>
        <trans-unit id="b13cd3cf02514f3a86f3431f0fe84ad64d68a6f3" translate="yes" xml:space="preserve">
          <source>If you feel you need more introductory material, please visit the PostgreSQL &lt;a href=&quot;https://www.postgresql.org&quot;&gt;web site&lt;/a&gt; for links to more resources.</source>
          <target state="translated">さらに入門的な資料が必要だと思われる場合は、PostgreSQLの&lt;a href=&quot;https://www.postgresql.org&quot;&gt;Webサイトにアクセス&lt;/a&gt;して、その他のリソースへのリンクを確認してください。</target>
        </trans-unit>
        <trans-unit id="27223facca9dbba24447f51ca3cc46e2a4d4b2ed" translate="yes" xml:space="preserve">
          <source>If you get an &amp;ldquo;illegal system call&amp;rdquo; error, it is likely that shared memory or semaphores are not supported in your kernel at all. In that case your only option is to reconfigure the kernel to enable these features.</source>
          <target state="translated">「不正なシステムコール」エラーが発生した場合は、カーネルで共有メモリまたはセマフォがサポートされていない可能性があります。その場合、あなたの唯一の選択肢は、これらの機能を有効にするためにカーネルを再構成することです。</target>
        </trans-unit>
        <trans-unit id="7aa554ad85b0e28436475081421e4e00eaf4dd3c" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; turned off, any backslashes you write in literal string constants will need to be doubled. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_stringsを&lt;/a&gt;オフにしている場合は、リテラル文字列定数に書き込むバックスラッシュを2倍にする必要があります。詳細については、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;セクション4.1.2.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f61cc65bca02db4eb1ea500b6eae076fd93f0491" translate="yes" xml:space="preserve">
          <source>If you have a dedicated database server with 1GB or more of RAM, a reasonable starting value for &lt;code&gt;shared_buffers&lt;/code&gt; is 25% of the memory in your system. There are some workloads where even larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; are effective, but because PostgreSQL also relies on the operating system cache, it is unlikely that an allocation of more than 40% of RAM to &lt;code&gt;shared_buffers&lt;/code&gt; will work better than a smaller amount. Larger settings for &lt;code&gt;shared_buffers&lt;/code&gt; usually require a corresponding increase in &lt;code&gt;max_wal_size&lt;/code&gt;, in order to spread out the process of writing large quantities of new or changed data over a longer period of time.</source>
          <target state="translated">1 GB以上のRAMを備えた専用データベースサーバーがある場合、 &lt;code&gt;shared_buffers&lt;/code&gt; の適切な開始値は、システムのメモリの25％です。 &lt;code&gt;shared_buffers&lt;/code&gt; のさらに大きな設定が有効なワークロードもいくつかありますが、PostgreSQLもオペレーティングシステムのキャッシュに依存しているため、 &lt;code&gt;shared_buffers&lt;/code&gt; へのRAMの割り当てが40％を超えると、少ない量よりもうまく機能する可能性は低くなります。 &lt;code&gt;shared_buffers&lt;/code&gt; の設定を大きくするには、通常、新しいデータや変更されたデータを大量に書き込むプロセスを長期間にわたって分散させるために、対応する &lt;code&gt;max_wal_size&lt;/code&gt; の増加が必要です。</target>
        </trans-unit>
        <trans-unit id="5955ce4878872fc7d42a5cf4a3feceaf0ce085c2" translate="yes" xml:space="preserve">
          <source>If you have a table that contains both billed and unbilled orders, where the unbilled orders take up a small fraction of the total table and yet those are the most-accessed rows, you can improve performance by creating an index on just the unbilled rows. The command to create the index would look like this:</source>
          <target state="translated">請求済みの注文と請求されていない注文の両方を含むテーブルがあり、請求されていない注文がテーブル全体のごく一部を占めているにもかかわらず、最もアクセスの多い行である場合、請求されていない行だけにインデックスを作成することでパフォーマンスを向上させることができます。インデックスを作成するコマンドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3db868f1aa52b4182eabc5a6aaef64ca58b29be3" translate="yes" xml:space="preserve">
          <source>If you have a table whose entire contents are deleted on a periodic basis, consider doing it with &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; rather than using &lt;code&gt;DELETE&lt;/code&gt; followed by &lt;code&gt;VACUUM&lt;/code&gt;. &lt;code&gt;TRUNCATE&lt;/code&gt; removes the entire content of the table immediately, without requiring a subsequent &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt; to reclaim the now-unused disk space. The disadvantage is that strict MVCC semantics are violated.</source>
          <target state="translated">内容全体が定期的に削除されるテーブルがある場合は、 &lt;code&gt;DELETE&lt;/code&gt; の後に &lt;code&gt;VACUUM&lt;/code&gt; を続けて使用するのではなく、&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;を使用してテーブルを実行することを検討してください。 &lt;code&gt;TRUNCATE&lt;/code&gt; は、テーブルの内容全体をすぐに削除します。現在使用されていないディスク領域を再利用するために後続の &lt;code&gt;VACUUM&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; を要求する必要はありません。短所は、厳密なMVCCセマンティクスに違反することです。</target>
        </trans-unit>
        <trans-unit id="edada2f4a0ea8a1fe6f35435a51d724440a997b9" translate="yes" xml:space="preserve">
          <source>If you have a user account but it does not have the privileges required to create a database, you will see the following:</source>
          <target state="translated">ユーザーアカウントを持っていても、データベースを作成するのに必要な権限を持っていない場合は、以下のように表示されます。</target>
        </trans-unit>
        <trans-unit id="6e1ffd7834998be91b2b3ef3885c4c95ac1fca94" translate="yes" xml:space="preserve">
          <source>If you have an embedded SQL C source file named &lt;code&gt;prog1.pgc&lt;/code&gt;, you can create an executable program using the following sequence of commands:</source>
          <target state="translated">&lt;code&gt;prog1.pgc&lt;/code&gt; という名前の埋め込みSQL Cソースファイルがある場合、次の一連のコマンドを使用して実行可能プログラムを作成できます。</target>
        </trans-unit>
        <trans-unit id="3a617edae0e90918be65ecbfa41a4edb3f6fbb0d" translate="yes" xml:space="preserve">
          <source>If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will &lt;em&gt;not&lt;/em&gt; work because the information contained in these files is not usable without the commit log files, &lt;code&gt;pg_xact/*&lt;/code&gt;, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated &lt;code&gt;pg_xact&lt;/code&gt; data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster.</source>
          <target state="translated">データベースのファイルシステムレイアウトの詳細を調べた場合、特定の個別のテーブルまたはデータベースのみをそれぞれのファイルまたはディレクトリからバックアップまたは復元しようとする傾向があるかもしれません。これらのファイルに含まれる情報は、すべてのトランザクションのコミットステータスを含むコミットログファイル &lt;code&gt;pg_xact/*&lt;/code&gt; がないと使用できないため、これは機能し&lt;em&gt;ません&lt;/em&gt;。テーブルファイルは、この情報でのみ使用できます。もちろん、テーブルとそれに関連する &lt;code&gt;pg_xact&lt;/code&gt; データのみを復元することも不可能です。データベースクラスター内の他のすべてのテーブルが役に立たなくなるためです。そのため、ファイルシステムバックアップは、データベースクラスタ全体の完全なバックアップと復元に対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="b1fdfd0de9a85f5bba1c48c08c54c2308c8c0754" translate="yes" xml:space="preserve">
          <source>If you have not set up an external transaction manager to track prepared transactions and ensure they get closed out promptly, it is best to keep the prepared-transaction feature disabled by setting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt; to zero. This will prevent accidental creation of prepared transactions that might then be forgotten and eventually cause problems.</source>
          <target state="translated">準備されたトランザクションを追跡するために外部トランザクションマネージャーを設定しておらず、それらがすぐに閉じられるようにする場合は、&lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;をゼロに設定して準備トランザクション機能を無効にしておくことをお勧めします。これにより、忘れられて最終的に問題が発生する可能性のある準備済みトランザクションが誤って作成されるのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4113594099b8ceaba5516ae6559f67b321dd3f1a" translate="yes" xml:space="preserve">
          <source>If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl.</source>
          <target state="translated">これを超えるパターンマッチングのニーズがある場合は、Perl や Tcl でユーザー定義関数を書くことを検討してください。</target>
        </trans-unit>
        <trans-unit id="aedcf3e1663bdb52e36d3e2d02ae7396863fa330" translate="yes" xml:space="preserve">
          <source>If you have relocated &lt;code&gt;pg_wal&lt;/code&gt; outside the data directories, rsync must be run on those directories too.</source>
          <target state="translated">&lt;code&gt;pg_wal&lt;/code&gt; をデータディレクトリの外に移動した場合は、それらのディレクトリでもrsyncを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="66e124e77e26c68b2716b8eb55653604cd884707" translate="yes" xml:space="preserve">
          <source>If you have set &lt;code&gt;shared_memory_type&lt;/code&gt; to &lt;code&gt;sysv&lt;/code&gt;, you might also want to configure your kernel to lock System V shared memory into RAM and prevent it from being paged out to swap. This can be accomplished using the &lt;code&gt;sysctl&lt;/code&gt; setting &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_memory_type&lt;/code&gt; を &lt;code&gt;sysv&lt;/code&gt; に設定している場合は、System V共有メモリをRAMにロックし、ページアウトされてスワップされないようにカーネルを構成することもできます。これは、 &lt;code&gt;sysctl&lt;/code&gt; 設定 &lt;code&gt;kern.ipc.shm_use_phys&lt;/code&gt; を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="a07426ce8ecfc80c9d7a4edfcb98cf0ba611138f" translate="yes" xml:space="preserve">
          <source>If you have tablespaces, you will need to run a similar rsync command for each tablespace directory, e.g.:</source>
          <target state="translated">テーブルスペースがある場合は、各テーブルスペースディレクトリに対して同様の rsync コマンドを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="74d92589027830b748d75a72665251c799371e5f" translate="yes" xml:space="preserve">
          <source>If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's &lt;code&gt;pg_wal&lt;/code&gt; subdirectory, as it might contain logs which were not archived before the system went down.</source>
          <target state="translated">そのためのスペースがある場合は、後で必要になる場合に備えて、クラスターデータディレクトリ全体とすべてのテーブルスペースを一時的な場所にコピーします。この予防措置には、既存のデータベースの2つのコピーを保持するための十分な空きスペースがシステムに必要であることに注意してください。十分なスペースがない場合は、システムがダウンする前にアーカイブされなかったログが含まれている可能性があるため、少なくともクラスターの &lt;code&gt;pg_wal&lt;/code&gt; サブディレクトリの内容を保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="c405c350a4bec28b591f01ed6531218b06904979" translate="yes" xml:space="preserve">
          <source>If you have to &amp;ldquo;hop&amp;rdquo; to the database server via some login host, one possible setup could look like this:</source>
          <target state="translated">ログインホストを介してデータベースサーバーに「ホップ」する必要がある場合、考えられる設定の1つは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e1467a82f0f1d2aed2302c816a743bd03ff5d6fe" translate="yes" xml:space="preserve">
          <source>If you have turned off &lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt; then the activity indicator is not updated; the process title is set only once when a new process is launched. On some platforms this saves a measurable amount of per-command overhead; on others it's insignificant.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-UPDATE-PROCESS-TITLE&quot;&gt;update_process_title&lt;/a&gt;をオフにした場合、アクティビティインジケーターは更新されません。プロセスのタイトルは、新しいプロセスが起動されたときに一度だけ設定されます。一部のプラットフォームでは、これにより、コマンドあたりのオーバーヘッドがかなり節約されます。他の人にはそれは取るに足らないです。</target>
        </trans-unit>
        <trans-unit id="cdc8af27dd93a99e3339ed60a27d59629c7d68fb" translate="yes" xml:space="preserve">
          <source>If you have unarchived WAL segment files that you saved in step 2, copy them into &lt;code&gt;pg_wal/&lt;/code&gt;. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)</source>
          <target state="translated">手順2で保存したアーカイブされていないWALセグメントファイルがある場合は、それらを &lt;code&gt;pg_wal/&lt;/code&gt; コピーします。（それらを移動するのではなく、コピーすることをお勧めします。そのため、問題が発生して最初からやり直す必要がある場合でも、変更されていないファイルが残っています。）</target>
        </trans-unit>
        <trans-unit id="f602421c44c7955b1682bc7b3fca54acb52d429c" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; を変更した場合は、元の設定に戻します。新しいクラスター内の他の構成ファイルを調整して、古いクラスターと一致させる必要がある場合もあります（例： &lt;code&gt;postgresql.conf&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="dbf1fa6cfeb52f4146529fb315f1682db9559aaa" translate="yes" xml:space="preserve">
          <source>If you modified &lt;code&gt;pg_hba.conf&lt;/code&gt;, restore its original settings. It might also be necessary to adjust other configuration files in the new cluster to match the old cluster, e.g., &lt;code&gt;postgresql.conf&lt;/code&gt; (and any files included by it), &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; を変更した場合は、元の設定に戻します。また、 &lt;code&gt;postgresql.conf&lt;/code&gt; （およびそれに含まれるすべてのファイル）、 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; など、古いクラスターと一致するように新しいクラスター内の他の構成ファイルを調整する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="9316b03fae64e8c508527fbd0a6b640ef4256fda" translate="yes" xml:space="preserve">
          <source>If you modify files in &lt;code&gt;.../share/timezonesets/&lt;/code&gt;, it is up to you to make backups &amp;mdash; a normal database dump will not include this directory.</source>
          <target state="translated">&lt;code&gt;.../share/timezonesets/&lt;/code&gt; 内のファイルを変更する場合、バックアップを作成するかどうかはユーザー次第です。通常のデータベースダンプには、このディレクトリは含まれません。</target>
        </trans-unit>
        <trans-unit id="a80020f6d5771b4994b2b6087bde0a758b0dbcc3" translate="yes" xml:space="preserve">
          <source>If you need to modify a table that already exists, see &lt;a href=&quot;ddl-alter&quot;&gt;Section 5.6&lt;/a&gt; later in this chapter.</source>
          <target state="translated">すでに存在するテーブルを変更する必要がある場合は、この章の後半の&lt;a href=&quot;ddl-alter&quot;&gt;セクション5.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2efd34e960254e7fbc24d4c21228c55d47bceff1" translate="yes" xml:space="preserve">
          <source>If you need to re-create a standby server while transactions are waiting, make sure that the commands pg_start_backup() and pg_stop_backup() are run in a session with &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt;, otherwise those requests will wait forever for the standby to appear.</source>
          <target state="translated">トランザクションの待機中にスタンバイサーバーを再作成する必要がある場合は、コマンドpg_start_backup（）およびpg_stop_backup（）が &lt;code&gt;synchronous_commit&lt;/code&gt; = &lt;code&gt;off&lt;/code&gt; のセッションで実行されることを確認してください。そうでない場合、これらのリクエストはスタンバイが表示されるまで永久に待機します。</target>
        </trans-unit>
        <trans-unit id="335eb5a28fe752ac43ab7d0bdb87c591351c3327" translate="yes" xml:space="preserve">
          <source>If you no longer need a table, you can remove it using the &lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt; command. For example:</source>
          <target state="translated">テーブルが不要になった場合は、&lt;a href=&quot;sql-droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドを使用して削除できます。例えば：</target>
        </trans-unit>
        <trans-unit id="4b094a7de4e477575e2b8864dd2a1871a2ac7be9" translate="yes" xml:space="preserve">
          <source>If you only need randomly-generated (version 4) UUIDs, consider using the &lt;code&gt;gen_random_uuid()&lt;/code&gt; function from the &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module instead.</source>
          <target state="translated">ランダムに生成された（バージョン4）UUIDのみが必要な場合は、代わりに&lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt;モジュールの &lt;code&gt;gen_random_uuid()&lt;/code&gt; 関数を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="c7ec64742024abd88ac376b90c1b4516681087ea" translate="yes" xml:space="preserve">
          <source>If you really cannot keep as many synchronous standbys as requested then you should decrease the number of synchronous standbys that transaction commits must wait for responses from in &lt;code&gt;synchronous_standby_names&lt;/code&gt; (or disable it) and reload the configuration file on the primary server.</source>
          <target state="translated">要求された数の同期スタンバイを本当に維持できない場合は、トランザクションコミットが &lt;code&gt;synchronous_standby_names&lt;/code&gt; での応答を待機する（または無効にする）必要がある同期スタンバイの数を減らし、プライマリサーバーで構成ファイルを再ロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="afb9b1746ef64ef43e1c6a611287b8838f8bab6f" translate="yes" xml:space="preserve">
          <source>If you really need to do something like that, you can either write a custom operator or add explicit casts to your query:</source>
          <target state="translated">どうしてもそのようなことが必要な場合は、カスタム演算子を書くか、クエリに明示的なキャストを追加します。</target>
        </trans-unit>
        <trans-unit id="4c6cec6fc682547181945340072f15c49a175a52" translate="yes" xml:space="preserve">
          <source>If you require exact storage and calculations (such as for monetary amounts), use the &lt;code&gt;numeric&lt;/code&gt; type instead.</source>
          <target state="translated">正確な保管と計算が必要な場合（金額など）は、代わりに &lt;code&gt;numeric&lt;/code&gt; タイプを使用してください。</target>
        </trans-unit>
        <trans-unit id="dda0ebbf2c21ed8ce369ceb9f7962ccab8e8d4c2" translate="yes" xml:space="preserve">
          <source>If you see a message similar to:</source>
          <target state="translated">似たようなメッセージが表示されたら</target>
        </trans-unit>
        <trans-unit id="5944bf42cb7e9bed827543dce0bb5da3eb25aaf4" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;select-only&lt;/code&gt; built-in (also &lt;code&gt;-S&lt;/code&gt;), only the &lt;code&gt;SELECT&lt;/code&gt; is issued.</source>
          <target state="translated">あなたが選択した場合 &lt;code&gt;select-only&lt;/code&gt; ビルトイン（また &lt;code&gt;-S&lt;/code&gt; ）、唯一の &lt;code&gt;SELECT&lt;/code&gt; が発行されます。</target>
        </trans-unit>
        <trans-unit id="c440cbb3c75274ef5533f9dc20d09bc792bb4404" translate="yes" xml:space="preserve">
          <source>If you select the &lt;code&gt;simple-update&lt;/code&gt; built-in (also &lt;code&gt;-N&lt;/code&gt;), steps 4 and 5 aren't included in the transaction. This will avoid update contention on these tables, but it makes the test case even less like TPC-B.</source>
          <target state="translated">&lt;code&gt;simple-update&lt;/code&gt; ビルトイン（または &lt;code&gt;-N&lt;/code&gt; ）を選択した場合、ステップ4と5はトランザクションに含まれません。これにより、これらのテーブルでの更新の競合は回避されますが、テストケースがTPC-Bのようになります。</target>
        </trans-unit>
        <trans-unit id="2410e185ebe01d4bbafd07fc62d71b97897582e4" translate="yes" xml:space="preserve">
          <source>If you set a nonempty value for &lt;code&gt;log_line_prefix&lt;/code&gt;, you should usually make its last character be a space, to provide visual separation from the rest of the log line. A punctuation character can be used too.</source>
          <target state="translated">&lt;code&gt;log_line_prefix&lt;/code&gt; に空でない値を設定する場合は、通常、最後の文字をスペースにして、ログ行の残りの部分から視覚的に分離する必要があります。句読文字も使用できます。</target>
        </trans-unit>
        <trans-unit id="293043269744dfe0b2be9f58f146808d29c819d1" translate="yes" xml:space="preserve">
          <source>If you simply direct the stderr of &lt;code&gt;postgres&lt;/code&gt; into a file, you will have log output, but the only way to truncate the log file is to stop and restart the server. This might be acceptable if you are using PostgreSQL in a development environment, but few production servers would find this behavior acceptable.</source>
          <target state="translated">単に &lt;code&gt;postgres&lt;/code&gt; のstderrをファイルに送ると、ログが出力されますが、ログファイルを切り捨てる唯一の方法は、サーバーを停止して再起動することです。これは、開発環境でPostgreSQLを使用している場合は許容できるかもしれませんが、この動作を許容できると感じる運用サーバーはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="9ce920b3e4b27527a0945161fb81196b0962a822" translate="yes" xml:space="preserve">
          <source>If you simply write:</source>
          <target state="translated">単純に書けば</target>
        </trans-unit>
        <trans-unit id="86278d59973a9bff1da8685bc91d01d4bca2172c" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;prefix&lt;/code&gt;, that string is prepended to the query's column names to create the variable names to use:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; を指定すると、その文字列がクエリの列名の前に付加され、使用する変数名が作成されます。</target>
        </trans-unit>
        <trans-unit id="4293f633ad719b6229d97888e7c493efba01b4c4" translate="yes" xml:space="preserve">
          <source>If you specify a file name without escapes, you should plan to use a log rotation utility to avoid eventually filling the entire disk. In releases prior to 8.4, if no &lt;code&gt;%&lt;/code&gt; escapes were present, PostgreSQL would append the epoch of the new log file's creation time, but this is no longer the case.</source>
          <target state="translated">エスケープなしでファイル名を指定する場合は、ログローテーションユーティリティを使用して、最終的にディスク全体がいっぱいにならないようにする必要があります。8.4より前のリリースでは、 &lt;code&gt;%&lt;/code&gt; エスケープが存在しない場合、PostgreSQLは新しいログファイルの作成時刻のエポックを追加しますが、これは当てはまりません。</target>
        </trans-unit>
        <trans-unit id="cd2bed205787104a93fce03bc6421721af1bc122" translate="yes" xml:space="preserve">
          <source>If you specify columns, you probably have to escape the parentheses from the shell. (See examples below.)</source>
          <target state="translated">カラムを指定する場合は、おそらくシェルから括弧をエスケープする必要があると思います。(以下の例を参照してください)。</target>
        </trans-unit>
        <trans-unit id="c697983f7b5aa306c7f0f7a672c31b1b3cec3536" translate="yes" xml:space="preserve">
          <source>If you suspect corruption of an index on a user table, you can simply rebuild that index, or all indexes on the table, using &lt;code&gt;REINDEX INDEX&lt;/code&gt; or &lt;code&gt;REINDEX TABLE&lt;/code&gt;.</source>
          <target state="translated">ユーザーテーブルのインデックスの破損が疑われる場合は、 &lt;code&gt;REINDEX INDEX&lt;/code&gt; または &lt;code&gt;REINDEX TABLE&lt;/code&gt; を使用して、そのインデックスまたはテーブルのすべてのインデックスを再構築できます。</target>
        </trans-unit>
        <trans-unit id="634ba98da8d49a37a8349e78baa14c6e91b78095" translate="yes" xml:space="preserve">
          <source>If you use link mode, the upgrade will be much faster (no file copying) and use less disk space, but you will not be able to access your old cluster once you start the new cluster after the upgrade. Link mode also requires that the old and new cluster data directories be in the same file system. (Tablespaces and &lt;code&gt;pg_wal&lt;/code&gt; can be on different file systems.) Clone mode provides the same speed and disk space advantages but does not cause the old cluster to be unusable once the new cluster is started. Clone mode also requires that the old and new data directories be in the same file system. This mode is only available on certain operating systems and file systems.</source>
          <target state="translated">リンクモードを使用すると、アップグレードははるかに高速になり（ファイルのコピーなし）、使用するディスク領域が少なくなりますが、アップグレード後に新しいクラスターを起動すると、古いクラスターにアクセスできなくなります。リンクモードでは、古いクラスターデータディレクトリと新しいクラスターデータディレクトリが同じファイルシステムにある必要もあります。 （テーブルスペースと &lt;code&gt;pg_wal&lt;/code&gt; は異なるファイルシステム上にあってもかまいません。）クローンモードは同じ速度とディスクスペースの利点を提供しますが、新しいクラスターが起動すると古いクラスターが使用できなくなることはありません。また、クローンモードでは、古いデータディレクトリと新しいデータディレクトリが同じファイルシステムにある必要があります。このモードは、特定のオペレーティングシステムとファイルシステムでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fe9e0a997d4a5f8ab6d05deb3608c7b48d1004eb" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_segments&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">ファイルベースの継続的アーカイブなしでストリーミングレプリケーションを使用する場合、スタンバイが受信する前にサーバーが古いWALセグメントをリサイクルする可能性があります。これが発生した場合は、スタンバイを新しいベースバックアップから再初期化する必要があります。これを回避するには、 &lt;code&gt;wal_keep_segments&lt;/code&gt; を十分に大きな値に設定して、WALセグメントが早くリサイクルされないようにするか、スタンバイ用のレプリケーションスロットを構成します。スタンバイからアクセス可能なWALアーカイブをセットアップする場合、スタンバイが十分なセグメントを保持している場合、スタンバイは常にアーカイブを使用して追いつくことができるため、これらのソリューションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="3198519c857584cca4870e5482467b87f1de4701" translate="yes" xml:space="preserve">
          <source>If you use streaming replication without file-based continuous archiving, the server might recycle old WAL segments before the standby has received them. If this occurs, the standby will need to be reinitialized from a new base backup. You can avoid this by setting &lt;code&gt;wal_keep_size&lt;/code&gt; to a value large enough to ensure that WAL segments are not recycled too early, or by configuring a replication slot for the standby. If you set up a WAL archive that's accessible from the standby, these solutions are not required, since the standby can always use the archive to catch up provided it retains enough segments.</source>
          <target state="translated">ファイルベースの連続アーカイブなしでストリーミングレプリケーションを使用する場合、サーバーは、スタンバイが古いWALセグメントを受信する前にそれらをリサイクルする可能性があります。これが発生した場合は、スタンバイを新しいベースバックアップから再初期化する必要があります。これを回避するには、 &lt;code&gt;wal_keep_size&lt;/code&gt; を十分に大きい値に設定して、WALセグメントのリサイクルが早すぎないようにするか、スタンバイ用のレプリケーションスロットを構成します。スタンバイからアクセス可能なWALアーカイブを設定する場合、スタンバイは十分なセグメントを保持していれば、いつでもアーカイブを使用して追いつくことができるため、これらのソリューションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="410c6fd96b75590acd8e3654ea56e9babc9667ce" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command.</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; コマンドを使用してクエリ出力をリダイレクトする場合は、このコマンドの代わりに &lt;code&gt;\qecho&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="0373a56e2165e1341cdef2084a1dbcf9d28e7801" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\o&lt;/code&gt; command to redirect your query output you might wish to use &lt;code&gt;\qecho&lt;/code&gt; instead of this command. See also &lt;code&gt;\warn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\o&lt;/code&gt; コマンドを使用してクエリ出力をリダイレクトする場合は、このコマンドの代わりに &lt;code&gt;\qecho&lt;/code&gt; を使用することをお勧めします。 &lt;code&gt;\warn&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="dacf2afd67d1d9e6693b9e34a44e3f31343f07b9" translate="yes" xml:space="preserve">
          <source>If you used link mode and have Streaming Replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) or Log-Shipping (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) standby servers, you can follow these steps to quickly upgrade them. You will not be running pg_upgrade on the standby servers, but rather rsync on the primary. Do not start any servers yet.</source>
          <target state="translated">リンクモードを使用していて、ストリーミングレプリケーション（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）またはログ配布（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2を&lt;/a&gt;参照）スタンバイサーバーがある場合は、次の手順に従って、それらをすばやくアップグレードできます。スタンバイサーバーでpg_upgradeを実行するのではなく、プライマリサーバーでrsyncを実行します。まだサーバーを起動しないでください。</target>
        </trans-unit>
        <trans-unit id="46579b8a1d951df62d56dbc7236dffbdfa323aee" translate="yes" xml:space="preserve">
          <source>If you want an empty string rather than NULL, write double quotes:</source>
          <target state="translated">NULLではなく空文字列にしたい場合は、二重引用符で囲みます。</target>
        </trans-unit>
        <trans-unit id="e23816131f85edfcf8ebf4baf1b8f5a4f82e1a1c" translate="yes" xml:space="preserve">
          <source>If you want the digest as a hexadecimal string, use &lt;code&gt;encode()&lt;/code&gt; on the result. For example:</source>
          <target state="translated">16進数の文字列としてダイジェストが必要な場合は、結果に対して &lt;code&gt;encode()&lt;/code&gt; を使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="c7212923c1936242a3a328b31eba624a84bab3c5" translate="yes" xml:space="preserve">
          <source>If you want the system to behave as if it had no locale support, use the special locale name &lt;code&gt;C&lt;/code&gt;, or equivalently &lt;code&gt;POSIX&lt;/code&gt;.</source>
          <target state="translated">システムがロケールをサポートしていないかのように動作させたい場合は、特別なロケール名 &lt;code&gt;C&lt;/code&gt; または同等の &lt;code&gt;POSIX&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4f51609486b727fbe8393280c5551d1122917313" translate="yes" xml:space="preserve">
          <source>If you want to add a new method of making the data representation smaller, you must implement it in &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; and also teach &lt;code&gt;Catalog::ParseData()&lt;/code&gt; how to expand the data back into the full representation.</source>
          <target state="translated">あなたがデータ表現を小さくすることの新しい方法を追加したい場合は、それを実装する必要があります &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; ともティーチ &lt;code&gt;Catalog::ParseData()&lt;/code&gt; 完全な表現へのデータのバックを展開する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="7f058b6974f7c4fc1a4fda33213fb953c4c820d2" translate="yes" xml:space="preserve">
          <source>If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.</source>
          <target state="translated">何か重要なことのためにこれらの型を使って複雑な計算をしたい場合、特に境界ケース(無限大、アンダーフロー)での特定の動作に依存している場合は、実装を慎重に評価する必要があります。</target>
        </trans-unit>
        <trans-unit id="f8d0dd9f6c3474fc520b6c68678cb5772392894d" translate="yes" xml:space="preserve">
          <source>If you want to have a double quote in the output you must precede it with a backslash, for example &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt;. Backslashes are not otherwise special outside of double-quoted strings. Within a double-quoted string, a backslash causes the next character to be taken literally, whatever it is (but this has no special effect unless the next character is a double quote or another backslash).</source>
          <target state="translated">出力に二重引用符を含める場合は、その前にバックスラッシュを付ける必要があります（例： &lt;code&gt;'\&quot;YYYY Month\&quot;'&lt;/code&gt; 。バックスラッシュは、二重引用符で囲まれた文字列以外では特別なものではありません。二重引用符で囲まれた文字列内では、バックスラッシュによって次の文字が文字どおりに解釈されます（ただし、次の文字が二重引用符または別のバックスラッシュでない限り、これは特別な効果はありません）。</target>
        </trans-unit>
        <trans-unit id="b08912c8afafc035000c2b91395d4762ff623ba7" translate="yes" xml:space="preserve">
          <source>If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;stopping point&lt;/a&gt;. You can specify the stop point, known as the &amp;ldquo;recovery target&amp;rdquo;, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use.</source>
          <target state="translated">以前のある時点（たとえば、ジュニアDBAがメイントランザクションテーブルを削除する直前）に回復する場合は、必要な&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-RECOVERY-TARGET&quot;&gt;停止ポイントを&lt;/a&gt;指定するだけです。日付/時刻、名前付きの復元ポイント、または特定のトランザクションIDの完了によって、「復元ターゲット」と呼ばれる停止ポイントを指定できます。これを書いている時点では、使用するトランザクションIDを正確に識別するためのツールがないため、日付/時刻と名前付き復元ポイントオプションのみが非常に便利です。</target>
        </trans-unit>
        <trans-unit id="f2799eac42b252d1fdead69c5594bb2d3a2059fa" translate="yes" xml:space="preserve">
          <source>If you want to run a parallel dump of a pre-9.2 server, you need to make sure that the database content doesn't change from between the time the master connects to the database until the last worker job has connected to the database. The easiest way to do this is to halt any data modifying processes (DDL and DML) accessing the database before starting the backup. You also need to specify the &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; parameter when running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 PostgreSQL server.</source>
          <target state="translated">9.2より前のサーバーの並列ダンプを実行する場合は、マスターがデータベースに接続してから最後のワーカージョブがデータベースに接続するまでの間に、データベースの内容が変化しないことを確認する必要があります。これを行う最も簡単な方法は、バックアップを開始する前に、データベースにアクセスするデータ変更プロセス（DDLおよびDML）を停止することです。9.2より前のPostgreSQLサーバーに対して &lt;code&gt;pg_dump -j&lt;/code&gt; を実行する場合は、 &lt;code&gt;--no-synchronized-snapshots&lt;/code&gt; パラメーターも指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1235d6c60bdf10ad9cf9d8bf29ece023d11255aa" translate="yes" xml:space="preserve">
          <source>If you want to see the lines on the screen as they are read you must set the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">行が読み取られたときに画面に表示されるようにするには、変数 &lt;code&gt;ECHO&lt;/code&gt; を &lt;code&gt;all&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d777fa853e95af192514bf1aeb804e6308b39ad2" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g. &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">リンクモードを使用し、新しいクラスターの起動時に古いクラスターを変更したくない場合は、クローンモードの使用を検討してください。それが利用できない場合は、古いクラスターのコピーを作成し、リンクモードでアップグレードします。古いクラスターの有効なコピーを作成するには、サーバーの実行中に &lt;code&gt;rsync&lt;/code&gt; を使用して古いクラスターのダーティーコピーを作成し、古いサーバーをシャットダウンして &lt;code&gt;rsync --checksum&lt;/code&gt; を再度実行し、変更を加えてコピーを更新します。一貫した。 （ &lt;code&gt;--checksum&lt;/code&gt; があるため必要である &lt;code&gt;rsync&lt;/code&gt; は 1秒間だけのファイル更新時の細かさを持っています。）あなたは例えば、いくつかのファイルを除外したい場合があります &lt;code&gt;postmaster.pid&lt;/code&gt; に記載されているように、&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;セクション25.3.3&lt;/a&gt;。ファイルシステムがファイルシステムスナップショットまたはコピーオンライトファイルコピーをサポートしている場合、それを使用して古いクラスターとテーブルスペースのバックアップを作成できますが、スナップショットとコピーは同時にまたはデータベースサーバーがダウンしているときに作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="a968160add8cfcbfd7bfae07842aa9c1a4f8617c" translate="yes" xml:space="preserve">
          <source>If you want to use link mode and you do not want your old cluster to be modified when the new cluster is started, consider using the clone mode. If that is not available, make a copy of the old cluster and upgrade that in link mode. To make a valid copy of the old cluster, use &lt;code&gt;rsync&lt;/code&gt; to create a dirty copy of the old cluster while the server is running, then shut down the old server and run &lt;code&gt;rsync --checksum&lt;/code&gt; again to update the copy with any changes to make it consistent. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) You might want to exclude some files, e.g., &lt;code&gt;postmaster.pid&lt;/code&gt;, as documented in &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;Section 25.3.3&lt;/a&gt;. If your file system supports file system snapshots or copy-on-write file copies, you can use that to make a backup of the old cluster and tablespaces, though the snapshot and copies must be created simultaneously or while the database server is down.</source>
          <target state="translated">リンクモードを使用する必要があり、新しいクラスターの開始時に古いクラスターを変更したくない場合は、クローンモードの使用を検討してください。それが利用できない場合は、古いクラスターのコピーを作成し、リンクモードでアップグレードします。古いクラスターの有効なコピーを作成するには、サーバーの実行中に &lt;code&gt;rsync&lt;/code&gt; を使用して古いクラスターのダーティコピーを作成し、古いサーバーをシャットダウンして &lt;code&gt;rsync --checksum&lt;/code&gt; を再度実行し、コピーを更新して変更を加えます。一貫性があります。 （ &lt;code&gt;rsync&lt;/code&gt; のファイル変更時間の粒度は1秒しかないため、 &lt;code&gt;--checksum&lt;/code&gt; が必要です。）&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP&quot;&gt;セクション25.3.3に&lt;/a&gt;記載されているように、 &lt;code&gt;postmaster.pid&lt;/code&gt; などの一部のファイルを除外したい場合があります。。ファイルシステムがファイルシステムスナップショットまたはコピーオンライトファイルコピーをサポートしている場合は、それを使用して古いクラスターとテーブルスペースのバックアップを作成できますが、スナップショットとコピーは同時に、またはデータベースサーバーがダウンしているときに作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="548498a07974c2669fa7d265bb5ed01fd29f2726" translate="yes" xml:space="preserve">
          <source>If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep around a copy of psql from each major version and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary.</source>
          <target state="translated">psqlを使ってメジャーバージョンの異なる複数のサーバに接続したい場合は、最新バージョンのpsqlを使うことをお勧めします。あるいは、各メジャーバージョンのpsqlのコピーを持っておき、それぞれのサーバに合ったバージョンを使うようにしてもいいでしょう。しかし、実際には、このような追加の煩わしさは必要ないはずです。</target>
        </trans-unit>
        <trans-unit id="c83197bfbed6d42e302edf49770400c3bb7ffc90" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, fill in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; with a libpq connection string, including the host name (or IP address) and any additional details needed to connect to the primary server. If the primary needs a password for authentication, the password needs to be specified in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt; as well.</source>
          <target state="translated">ストリーミングレプリケーションを使用する場合は、プライマリサーバーへの接続に必要なホスト名（またはIPアドレス）とその他の詳細を含むlibpq接続文字列を&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfoに入力&lt;/a&gt;します。プライマリで認証にパスワードが必要な場合は、パスワードを&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-CONNINFO&quot;&gt;primary_conninfo&lt;/a&gt;でも指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8304e11449eef667491dd46bf0e842007ab0620d" translate="yes" xml:space="preserve">
          <source>If you want to use streaming replication, set up authentication on the primary server to allow replication connections from the standby server(s); that is, create a role and provide a suitable entry or entries in &lt;code&gt;pg_hba.conf&lt;/code&gt; with the database field set to &lt;code&gt;replication&lt;/code&gt;. Also ensure &lt;code&gt;max_wal_senders&lt;/code&gt; is set to a sufficiently large value in the configuration file of the primary server. If replication slots will be used, ensure that &lt;code&gt;max_replication_slots&lt;/code&gt; is set sufficiently high as well.</source>
          <target state="translated">ストリーミングレプリケーションを使用する場合は、プライマリサーバーで認証を設定して、スタンバイサーバーからのレプリケーション接続を許可します。つまり、ロールを作成し、データベースフィールドを &lt;code&gt;replication&lt;/code&gt; に設定して、 &lt;code&gt;pg_hba.conf&lt;/code&gt; に適切なエントリを提供します。また、プライマリサーバーの構成ファイルで &lt;code&gt;max_wal_senders&lt;/code&gt; が十分に大きな値に設定されていることを確認してください。レプリケーションスロットを使用する場合は、 &lt;code&gt;max_replication_slots&lt;/code&gt; も十分に高く設定してください。</target>
        </trans-unit>
        <trans-unit id="d505643f0e154d892e49d0ce311315a8a63b86fd" translate="yes" xml:space="preserve">
          <source>If you wish to create a new superuser, you must connect as a superuser, not merely with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. Being a superuser implies the ability to bypass all access permission checks within the database, so superuserdom should not be granted lightly.</source>
          <target state="translated">新しいスーパーユーザーを作成したい場合は、単に &lt;code&gt;CREATEROLE&lt;/code&gt; 特権ではなく、スーパーユーザーとして接続する必要があります。スーパーユーザーであるということは、データベース内のすべてのアクセス許可チェックをバイパスする機能を意味するため、スーパーユーザーを軽く許可するべきではありません。</target>
        </trans-unit>
        <trans-unit id="dba6f63305bb053e32c8873d900ab4a929146d0b" translate="yes" xml:space="preserve">
          <source>If you wish to drop a role for which the default privileges have been altered, it is necessary to reverse the changes in its default privileges or use &lt;code&gt;DROP OWNED BY&lt;/code&gt; to get rid of the default privileges entry for the role.</source>
          <target state="translated">デフォルトの権限が変更されたロールを削除する場合は、デフォルトの権限の変更を元に戻すか、 &lt;code&gt;DROP OWNED BY&lt;/code&gt; を使用してロールのデフォルトの権限エントリを削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe513e6fe150eda65f8a240b4c5ab71cf30d3ea3" translate="yes" xml:space="preserve">
          <source>If you wish to keep the configuration files elsewhere than the data directory, the &lt;code&gt;postgres&lt;/code&gt;&lt;code&gt;-D&lt;/code&gt; command-line option or &lt;code&gt;PGDATA&lt;/code&gt; environment variable must point to the directory containing the configuration files, and the &lt;code&gt;data_directory&lt;/code&gt; parameter must be set in &lt;code&gt;postgresql.conf&lt;/code&gt; (or on the command line) to show where the data directory is actually located. Notice that &lt;code&gt;data_directory&lt;/code&gt; overrides &lt;code&gt;-D&lt;/code&gt; and &lt;code&gt;PGDATA&lt;/code&gt; for the location of the data directory, but not for the location of the configuration files.</source>
          <target state="translated">構成ファイルをデータディレクトリ以外の場所に保持する場合は、 &lt;code&gt;postgres&lt;/code&gt; &lt;code&gt;-D&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;PGDATA&lt;/code&gt; 環境変数が構成ファイルを含むディレクトリを指している必要があり、 &lt;code&gt;data_directory&lt;/code&gt; パラメータを &lt;code&gt;postgresql.conf&lt;/code&gt; （またはコマンドライン）を使用して、データディレクトリが実際に配置されている場所を表示します。 &lt;code&gt;data_directory&lt;/code&gt; は、データディレクトリの場所では &lt;code&gt;-D&lt;/code&gt; および &lt;code&gt;PGDATA&lt;/code&gt; をオーバーライドしますが、構成ファイルの場所ではオーバーライドしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5e43ef9c20e530883e37f2ea188b5ba2ab7b89db" translate="yes" xml:space="preserve">
          <source>If you wish, you can specify the configuration file names and locations individually using the parameters &lt;code&gt;config_file&lt;/code&gt;, &lt;code&gt;hba_file&lt;/code&gt; and/or &lt;code&gt;ident_file&lt;/code&gt;. &lt;code&gt;config_file&lt;/code&gt; can only be specified on the &lt;code&gt;postgres&lt;/code&gt; command line, but the others can be set within the main configuration file. If all three parameters plus &lt;code&gt;data_directory&lt;/code&gt; are explicitly set, then it is not necessary to specify &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">ご希望の場合は、個別に設定ファイルの名前と場所のパラメータを使用して指定することができ &lt;code&gt;config_file&lt;/code&gt; 、 &lt;code&gt;hba_file&lt;/code&gt; および/または &lt;code&gt;ident_file&lt;/code&gt; を。 &lt;code&gt;config_file&lt;/code&gt; は &lt;code&gt;postgres&lt;/code&gt; コマンドラインでのみ指定できますが、その他はメインの構成ファイル内で設定できます。 3つのパラメーターと &lt;code&gt;data_directory&lt;/code&gt; のすべてが明示的に設定されている場合、 &lt;code&gt;-D&lt;/code&gt; または &lt;code&gt;PGDATA&lt;/code&gt; を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="32daceaa2cf366c2fe6d0715c4458443ee88a963" translate="yes" xml:space="preserve">
          <source>If you're setting up the standby server for high availability purposes, set up WAL archiving, connections and authentication like the primary server, because the standby server will work as a primary server after failover.</source>
          <target state="translated">高可用性を目的として待機サーバーを設定する場合は、フェイルオーバー後に待機サーバーがプライマリーサーバーとして動作するため、プライマリーサーバーと同様にWALアーカイブ、接続、認証を設定してください。</target>
        </trans-unit>
        <trans-unit id="c5ac9027a677c31c54f143f0fe38940b45904e3a" translate="yes" xml:space="preserve">
          <source>If you're using a WAL archive, its size can be minimized using the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt; parameter to remove files that are no longer required by the standby server. The pg_archivecleanup utility is designed specifically to be used with &lt;code&gt;archive_cleanup_command&lt;/code&gt; in typical single-standby configurations, see &lt;a href=&quot;pgarchivecleanup&quot;&gt;pg_archivecleanup&lt;/a&gt;. Note however, that if you're using the archive for backup purposes, you need to retain files needed to recover from at least the latest base backup, even if they're no longer needed by the standby.</source>
          <target state="translated">WALアーカイブを使用している場合は、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-CLEANUP-COMMAND&quot;&gt;archive_cleanup_command&lt;/a&gt;パラメータを使用してそのサイズを最小化し、スタンバイサーバーで不要になったファイルを削除できます。 pg_archivecleanupユーティリティは、典型的なシングルスタンバイ構成で &lt;code&gt;archive_cleanup_command&lt;/code&gt; と共に使用するように特別に設計されています&lt;a href=&quot;pgarchivecleanup&quot;&gt;。pg_archivecleanupを&lt;/a&gt;参照してください。ただし、アーカイブをバックアップの目的で使用している場合は、スタンバイで不要になった場合でも、少なくとも最新の基本バックアップからの復元に必要なファイルを保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="eede8f4eab7ac7c7f42522f0f50f00f83f33b103" translate="yes" xml:space="preserve">
          <source>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and &lt;code&gt;UNION ALL&lt;/code&gt; views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</source>
          <target state="translated">アプリケーションが上記にリストされていない他の形式のパーティショニングを使用する必要がある場合は、継承や &lt;code&gt;UNION ALL&lt;/code&gt; ビューなどの代替方法を代わりに使用できます。このようなメソッドは柔軟性を提供しますが、組み込みの宣言型パーティション分割のパフォーマンス上の利点はありません。</target>
        </trans-unit>
        <trans-unit id="693883e4d7e5062d3b1b4e420d1dcd21d56fe252" translate="yes" xml:space="preserve">
          <source>If your database cluster has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to restore the output of pg_dump into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">データベースクラスターに &lt;code&gt;template1&lt;/code&gt; データベースへのローカルな追加がある場合、pg_dumpの出力を本当に空のデータベースに復元するように注意してください。そうしないと、追加されたオブジェクトの定義が重複しているためにエラーが発生する可能性があります。以下からのコピー、ローカルな追加せずに空のデータベースを作成するには &lt;code&gt;template0&lt;/code&gt; ない &lt;code&gt;template1&lt;/code&gt; を例えば、：</target>
        </trans-unit>
        <trans-unit id="bfe8c7a1e0073145cfd43127c90a639a57c975f4" translate="yes" xml:space="preserve">
          <source>If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots &lt;em&gt;must&lt;/em&gt; be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations.</source>
          <target state="translated">データベースが複数のファイルシステムに分散している場合、すべてのボリュームの正確に同時に凍結されたスナップショットを取得する方法がない場合があります。たとえば、データファイルとWALログが異なるディスク上にある場合、またはテーブルスペースが異なるファイルシステム上にある場合、スナップショット&lt;em&gt;は&lt;/em&gt;同時で&lt;em&gt;なければならない&lt;/em&gt;ため、スナップショットバックアップを使用できない場合が&lt;em&gt;あり&lt;/em&gt;ます。このような状況でコンシステントスナップショット手法を信頼する前に、ファイルシステムのドキュメントをよく読んでください。</target>
        </trans-unit>
        <trans-unit id="89affde528d7a785d4590b760f08553f5fba2e5e" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g. &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">&lt;code&gt;/usr/local/pgsql&lt;/code&gt; など、インストールディレクトリがバージョン固有でない場合は、現在のPostgreSQLインストールディレクトリを移動して、新しいPostgreSQLインストールの妨げにならないようにする必要があります。現在のPostgreSQLサーバーがシャットダウンしたら、PostgreSQLインストールディレクトリの名前を変更しても安全です。古いディレクトリが &lt;code&gt;/usr/local/pgsql&lt;/code&gt; であるとすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b225941ba48c705a72d951ae004bd3007fba63eb" translate="yes" xml:space="preserve">
          <source>If your installation directory is not version-specific, e.g., &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, it is necessary to move the current PostgreSQL install directory so it does not interfere with the new PostgreSQL installation. Once the current PostgreSQL server is shut down, it is safe to rename the PostgreSQL installation directory; assuming the old directory is &lt;code&gt;/usr/local/pgsql&lt;/code&gt;, you can do:</source>
          <target state="translated">インストールディレクトリがバージョン固有でない場合（たとえば、 &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ）、新しいPostgreSQLのインストールに干渉しないように、現在のPostgreSQLインストールディレクトリを移動する必要があります。現在のPostgreSQLサーバーがシャットダウンされたら、PostgreSQLインストールディレクトリの名前を変更しても安全です。古いディレクトリが &lt;code&gt;/usr/local/pgsql&lt;/code&gt; であると仮定すると、次のことができます。</target>
        </trans-unit>
        <trans-unit id="cd01544b621df2f2698aa331ec7e1d502c246c7e" translate="yes" xml:space="preserve">
          <source>If your installation has any local additions to the &lt;code&gt;template1&lt;/code&gt; database, be careful to load the output of pg_restore into a truly empty database; otherwise you are likely to get errors due to duplicate definitions of the added objects. To make an empty database without any local additions, copy from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, for example:</source>
          <target state="translated">ご使用のシステムに &lt;code&gt;template1&lt;/code&gt; データベースへのローカルな追加がある場合は、pg_restoreの出力を本当に空のデータベースにロードするように注意してください。そうしないと、追加されたオブジェクトの定義が重複しているためにエラーが発生する可能性があります。以下からのコピー、ローカルな追加せずに空のデータベースを作成するには &lt;code&gt;template0&lt;/code&gt; ない &lt;code&gt;template1&lt;/code&gt; を例えば、：</target>
        </trans-unit>
        <trans-unit id="fb5ad20ebf8b8594ba828c2e14073cc42a290699" translate="yes" xml:space="preserve">
          <source>If your needs go beyond the capabilities of these conditional expressions, you might want to consider writing a server-side function in a more expressive programming language.</source>
          <target state="translated">ニーズがこれらの条件式の機能を超えている場合は、より表現力の高いプログラミング言語でサーバーサイドの関数を書くことを検討してみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="092f5bf3a3fbeb060b8f061dfe4479d40fe497ca" translate="yes" xml:space="preserve">
          <source>If your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the &lt;code&gt;PGHOST&lt;/code&gt; environment variable to the name of the database server machine. The environment variable &lt;code&gt;PGPORT&lt;/code&gt; might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.</source>
          <target state="translated">サイト管理者がデフォルトの方法で設定していない場合は、さらに作業が必要になる可能性があります。たとえば、データベースサーバーマシンがリモートマシンの場合、 &lt;code&gt;PGHOST&lt;/code&gt; 環境変数をデータベースサーバーマシンの名前に設定する必要があります。環境変数 &lt;code&gt;PGPORT&lt;/code&gt; も設定する必要がある場合があります。つまり、アプリケーションプログラムを起動しようとして、データベースに接続できないというメッセージが表示された場合は、サイト管理者に問い合わせるか、その場合はドキュメントを参照して、環境が適切に設定されていることを確認してください。 。前の段落を理解していない場合は、次のセクションを読んでください。</target>
        </trans-unit>
        <trans-unit id="0e26c0628db89c4d17246b09878aa1c2d36a0d98" translate="yes" xml:space="preserve">
          <source>If your system supports per-user disk quotas, then the database will naturally be subject to whatever quota is placed on the user the server runs as. Exceeding the quota will have the same bad effects as running out of disk space entirely.</source>
          <target state="translated">システムがユーザごとのディスククォータをサポートしている場合、データベースは当然のことながら、サーバを実行しているユーザに割り当てられたクォータの影響を受けることになります。クォータを超えてしまうと、ディスク容量を完全に使い果たしてしまうのと同じような悪影響があります。</target>
        </trans-unit>
        <trans-unit id="e7e317a782d39f676e51dc31fbaf9497cd40b79f" translate="yes" xml:space="preserve">
          <source>If your table is large enough that a single index really is a bad idea, you should look into using partitioning instead (see &lt;a href=&quot;ddl-partitioning&quot;&gt;Section 5.11&lt;/a&gt;). With that mechanism, the system does understand that the tables and indexes are non-overlapping, so far better performance is possible.</source>
          <target state="translated">テーブルが十分に大きく、単一のインデックスが本当に悪い考えである場合は、代わりにパーティショニングの使用を検討する必要があります（&lt;a href=&quot;ddl-partitioning&quot;&gt;セクション5.11を&lt;/a&gt;参照）。このメカニズムにより、システムはテーブルとインデックスが重複していないことを認識しているため、パフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="db517070c58b7073cbfea804db0649d1169a5342" translate="yes" xml:space="preserve">
          <source>If, after running &lt;code&gt;pg_upgrade&lt;/code&gt;, you wish to revert to the old cluster, there are several options:</source>
          <target state="translated">&lt;code&gt;pg_upgrade&lt;/code&gt; の実行後に古いクラスターに戻したい場合は、いくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="1101febd9e8e65c65ae1f196aecd9bf8175188c4" translate="yes" xml:space="preserve">
          <source>If, partway through the transaction, we decide we do not want to commit (perhaps we just noticed that Alice's balance went negative), we can issue the command &lt;code&gt;ROLLBACK&lt;/code&gt; instead of &lt;code&gt;COMMIT&lt;/code&gt;, and all our updates so far will be canceled.</source>
          <target state="translated">トランザクションの途中でコミットしないことを決定した場合（おそらく、アリスの残高がマイナスになったことに気付いただけかもしれません）、 &lt;code&gt;COMMIT&lt;/code&gt; の代わりにコマンド &lt;code&gt;ROLLBACK&lt;/code&gt; を発行できます。これまでのすべての更新はキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="f5024d286e4914e76d806049ed9ed5a9adde6b60" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables (but still update the indexes when modifying the tables). This is useful when recovering from damaged system indexes. This parameter cannot be changed after session start.</source>
          <target state="translated">システムテーブルを読み込む際にシステムインデックスを無視します(ただし、テーブルを修正する際にはインデックスを更新します)。これは、破損したシステムインデックスから回復するときに便利です。このパラメータは、セッション開始後に変更することはできません。</target>
        </trans-unit>
        <trans-unit id="71db18d1300170d2010c351c48755c19862c8762" translate="yes" xml:space="preserve">
          <source>Ignore system indexes when reading system tables, but still update the indexes when modifying the tables. This is useful when recovering from damaged system indexes.</source>
          <target state="translated">システムテーブルの読み込み時にはシステムインデックスを無視しますが、テーブルの修正時にはインデックスを更新します。これは、破損したシステムインデックスから復旧するときに便利です。</target>
        </trans-unit>
        <trans-unit id="e6a48d212210667b487bb3381daba46c6747f8cd" translate="yes" xml:space="preserve">
          <source>Ignore the specified file or directory, which should be expressed as a relative path name, when comparing the list of data files actually present in the backup to those listed in the &lt;code&gt;backup_manifest&lt;/code&gt; file. If a directory is specified, this option affects the entire subtree rooted at that location. Complaints about extra files, missing files, file size differences, or checksum mismatches will be suppressed if the relative path name matches the specified path name. This option can be specified multiple times.</source>
          <target state="translated">バックアップに実際に存在するデータファイルのリストを &lt;code&gt;backup_manifest&lt;/code&gt; ファイルにリストされているものと比較するときは、相対パス名として表現する必要がある指定されたファイルまたはディレクトリを無視します。ディレクトリが指定されている場合、このオプションはその場所をルートとするサブツリー全体に影響します。相対パス名が指定されたパス名と一致する場合、余分なファイル、不足しているファイル、ファイルサイズの違い、またはチェックサムの不一致に関する苦情は抑制されます。このオプションは複数回指定できます。</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="0bbd8cc216c54e73f7ea687a30b566c0b2c97cbb" translate="yes" xml:space="preserve">
          <source>Ignored for compatibility. Use of these keywords is deprecated; refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">互換性のために無視されます。これらのキーワードの使用は非推奨です。参照&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEを&lt;/a&gt;詳細については。</target>
        </trans-unit>
        <trans-unit id="b3a3e33cda0750b99611590eb50e57574fe1fbbc" translate="yes" xml:space="preserve">
          <source>Ignored for conformance with the SQL standard.</source>
          <target state="translated">SQL標準への適合性のために無視されます。</target>
        </trans-unit>
        <trans-unit id="007d15b16f1f1a7b26e745777a0d9b8f646f2090" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt;, below.</source>
          <target state="translated">これらのさまざまな形式がどのように見えるかの図は、以下の&lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;例&lt;/a&gt;で見ることができます。</target>
        </trans-unit>
        <trans-unit id="61522d42e0f29a20214f69c85ea7d7e480669670" translate="yes" xml:space="preserve">
          <source>Illustrations of how these different formats look can be seen in the &lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;Examples&lt;/a&gt; section.</source>
          <target state="translated">これらのさまざまな形式がどのように表示されるかを示す&lt;a href=&quot;app-psql#APP-PSQL-EXAMPLES&quot;&gt;例&lt;/a&gt;は、例のセクションにあります。</target>
        </trans-unit>
        <trans-unit id="ce170f0162eadf29cca12cc3cb0e2275dc4e6504" translate="yes" xml:space="preserve">
          <source>Image equality is &lt;em&gt;almost&lt;/em&gt; the same condition as simple bitwise equality. There is one subtle difference: When indexing a varlena data type, the on-disk representation of two image equal datums may not be bitwise equal due to inconsistent application of TOAST compression on input. Formally, when an operator class's &lt;code&gt;equalimage&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt;, it is safe to assume that the &lt;code&gt;datum_image_eq()&lt;/code&gt; C function will always agree with the operator class's &lt;code&gt;order&lt;/code&gt; function (provided that the same collation OID is passed to both the &lt;code&gt;equalimage&lt;/code&gt; and &lt;code&gt;order&lt;/code&gt; functions).</source>
          <target state="translated">画像の等式は、単純なビット単位の等式と&lt;em&gt;ほぼ&lt;/em&gt;同じ条件です。微妙な違いが1つあります。varlenaデータ型にインデックスを付ける場合、入力でのTOAST圧縮の適用に一貫性がないため、2つの画像が等しいデータのディスク上の表現がビット単位で等しくない場合があります。正式には、演算子クラスの &lt;code&gt;equalimage&lt;/code&gt; 関数が &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;datum_image_eq()&lt;/code&gt; C関数は常に演算子クラスの &lt;code&gt;order&lt;/code&gt; 関数と一致すると想定しても安全です（同じ照合OIDが &lt;code&gt;equalimage&lt;/code&gt; 関数と &lt;code&gt;order&lt;/code&gt; 関数の両方に渡される場合）。</target>
        </trans-unit>
        <trans-unit id="bf50e138c7fa8f736f41cea1cb795eaf265d80f2" translate="yes" xml:space="preserve">
          <source>Immediately after connecting as role &lt;code&gt;joe&lt;/code&gt;, a database session will have use of privileges granted directly to &lt;code&gt;joe&lt;/code&gt; plus any privileges granted to &lt;code&gt;admin&lt;/code&gt;, because &lt;code&gt;joe&lt;/code&gt;&amp;ldquo;inherits&amp;rdquo;&lt;code&gt;admin&lt;/code&gt;'s privileges. However, privileges granted to &lt;code&gt;wheel&lt;/code&gt; are not available, because even though &lt;code&gt;joe&lt;/code&gt; is indirectly a member of &lt;code&gt;wheel&lt;/code&gt;, the membership is via &lt;code&gt;admin&lt;/code&gt; which has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. After:</source>
          <target state="translated">&lt;code&gt;joe&lt;/code&gt; として接続した直後、データベースセッションでは、 &lt;code&gt;joe&lt;/code&gt; に直接付与された特権と &lt;code&gt;admin&lt;/code&gt; に付与されたすべての特権が使用されます。これは、 &lt;code&gt;joe&lt;/code&gt; が &lt;code&gt;admin&lt;/code&gt; の特権を「継承」しているためです。ただし、 &lt;code&gt;joe&lt;/code&gt; は間接的に &lt;code&gt;wheel&lt;/code&gt; のメンバーであるにもかかわらず、メンバーシップは &lt;code&gt;NOINHERIT&lt;/code&gt; 属性を持つ &lt;code&gt;admin&lt;/code&gt; を介しているため、 &lt;code&gt;wheel&lt;/code&gt; に付与された特権は使用できません。後：</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="23167d1539b634954643857fda589f9a1f99fc34" translate="yes" xml:space="preserve">
          <source>Implementation language or call interface of this function</source>
          <target state="translated">この関数の実装言語または呼び出しインターフェース</target>
        </trans-unit>
        <trans-unit id="41f7b8a75bd6e29a246db5c9ce4b0884fc5122fa" translate="yes" xml:space="preserve">
          <source>Implementation: B-Tree Structure</source>
          <target state="translated">実装しています。B木の構造</target>
        </trans-unit>
        <trans-unit id="4bd8f1da2c7641aff5a1e24cb79dcae5ba805a8b" translate="yes" xml:space="preserve">
          <source>Implementation: Deduplication</source>
          <target state="translated">実装しています。重複排除</target>
        </trans-unit>
        <trans-unit id="261a75d84276a41b101b0b0b2ac4d845072c8241" translate="yes" xml:space="preserve">
          <source>Implicit conversions should never have surprising or unpredictable outcomes.</source>
          <target state="translated">暗黙の変換は、決して驚くべき結果や予測不可能な結果をもたらすべきではありません。</target>
        </trans-unit>
        <trans-unit id="4a78c79f95926318ef6fec9862a700583e71fbd0" translate="yes" xml:space="preserve">
          <source>Implicit unit of the parameter</source>
          <target state="translated">パラメータの暗黙の単位</target>
        </trans-unit>
        <trans-unit id="60fa0aba1042461c4c2f1fe75e803d3f36549dc2" translate="yes" xml:space="preserve">
          <source>Import only foreign tables matching one of the given table names. Other tables existing in the foreign schema will be ignored.</source>
          <target state="translated">指定されたテーブル名のいずれかに一致する外部テーブルのみをインポートします。外部スキーマに存在する他のテーブルは無視されます。</target>
        </trans-unit>
        <trans-unit id="2775c7ad42c3e8d71ae7e18124278fff473728e1" translate="yes" xml:space="preserve">
          <source>Import operating system collations</source>
          <target state="translated">オペレーティングシステムの照合順序のインポート</target>
        </trans-unit>
        <trans-unit id="bd09d7d5cbde0f6a55b8befe57d5d6baee4d6f2b" translate="yes" xml:space="preserve">
          <source>Import table definitions from a remote schema &lt;code&gt;foreign_films&lt;/code&gt; on server &lt;code&gt;film_server&lt;/code&gt;, creating the foreign tables in local schema &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">サーバー &lt;code&gt;film_server&lt;/code&gt; のリモートスキーマ &lt;code&gt;foreign_films&lt;/code&gt; からテーブル定義をインポートし、ローカルスキーマ &lt;code&gt;films&lt;/code&gt; 外部テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="40baa6b48d8c1dc060a4acaef47611a694c99ef3" translate="yes" xml:space="preserve">
          <source>Importing behavior can be customized with the following options (given in the &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; command):</source>
          <target state="translated">インポート動作は、次のオプションでカスタマイズできます（ &lt;code&gt;IMPORT FOREIGN SCHEMA&lt;/code&gt; コマンドで指定）。</target>
        </trans-unit>
        <trans-unit id="6cdac824d2a40a7779c6dcbb8d843dee4847ebb5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;Table F.26&lt;/a&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; denote floating-point numbers. &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but not &lt;code&gt;delta&lt;/code&gt;, can be preceded by a certainty indicator.</source>
          <target state="translated">で&lt;a href=&quot;seg#SEG-REPR-TABLE&quot;&gt;表F.26&lt;/a&gt;、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、および &lt;code&gt;delta&lt;/code&gt; 表す浮動小数点数。 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; 、ただし &lt;code&gt;delta&lt;/code&gt; の前には、確実性インジケータを付けることができます。</target>
        </trans-unit>
        <trans-unit id="42729a410f5a9327e00095fef5d98f4dbb7419a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; in the column for PostgreSQL we classify as &amp;ldquo;non-reserved&amp;rdquo; those key words that are explicitly known to the parser but are allowed as column or table names. Some key words that are otherwise non-reserved cannot be used as function or data type names and are marked accordingly. (Most of these words represent built-in functions or data types with special syntax. The function or type is still available but it cannot be redefined by the user.) Labeled &amp;ldquo;reserved&amp;rdquo; are those tokens that are not allowed as column or table names. Some reserved key words are allowable as names for functions or data types; this is also shown in the table. If not so marked, a reserved key word is only allowed as an &amp;ldquo;AS&amp;rdquo; column label name.</source>
          <target state="translated">で&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;表C.1&lt;/a&gt; PostgreSQLの列で、我々は明示的にパーサーに知られているが、列名やテーブル名として許可されている「非予約」これらのキーワードとして分類します。それ以外の場合は予約されていない一部のキーワードは、関数またはデータ型の名前として使用できず、それに応じてマークされます。 （これらの単語のほとんどは、特別な構文を持つ組み込み関数またはデータ型を表しています。関数または型は引き続き使用できますが、ユーザーが再定義することはできません。）ラベル付きの「予約済み」は、列またはテーブル名として許可されていないトークンです。一部の予約済みキーワードは、関数またはデータ型の名前として使用できます。これも表に示されています。マークされていない場合、予約キーワードは「AS」列のラベル名としてのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="5fee127e33ba4c6342d0b89b7e063498409c73cb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN. If specified when not in &lt;code&gt;--start&lt;/code&gt; mode, an error is raised.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; 正常終了ステータス0のモード、自動的に停止複製および出口到達指定LSNを受信した場合。 &lt;code&gt;--start&lt;/code&gt; モードでないときに指定すると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="3bfcd6bf2f68dc3b43c9cf872d41f5d653495d00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; モードでは、与えられたLSNからレプリケーションを開始。この影響の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4の&lt;/a&gt;ドキュメントを参照してください。他のモードでは無視されます。</target>
        </trans-unit>
        <trans-unit id="0f9c2a488b212b2dfc605f566bbd946f2f95b3b7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, start replication from the given LSN. For details on the effect of this, see the documentation in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;. Ignored in other modes.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; モードでは、与えられたLSNからレプリケーションを開始。この影響の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;セクション52.4の&lt;/a&gt;ドキュメントを参照してください。他のモードでは無視されます。</target>
        </trans-unit>
        <trans-unit id="12bbea7ca03f59c395276fdbf0ca262376507500" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--start&lt;/code&gt; mode, use the existing logical replication slot named &lt;code&gt;slot_name&lt;/code&gt;. In &lt;code&gt;--create-slot&lt;/code&gt; mode, create the slot with this name. In &lt;code&gt;--drop-slot&lt;/code&gt; mode, delete the slot with this name.</source>
          <target state="translated">で &lt;code&gt;--start&lt;/code&gt; モードでは、既存の論理複製スロットという名前の使用 &lt;code&gt;slot_name&lt;/code&gt; 。で &lt;code&gt;--create-slot&lt;/code&gt; モード、この名前のスロットを作成します。で &lt;code&gt;--drop-slot&lt;/code&gt; モード、この名前のスロットを削除します。</target>
        </trans-unit>
        <trans-unit id="18d7da29e783f36fa5dffa6644b2287183a78875" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CSV&lt;/code&gt; format, all characters are significant. A quoted value surrounded by white space, or any characters other than &lt;code&gt;DELIMITER&lt;/code&gt;, will include those characters. This can cause errors if you import data from a system that pads &lt;code&gt;CSV&lt;/code&gt; lines with white space out to some fixed width. If such a situation arises you might need to preprocess the &lt;code&gt;CSV&lt;/code&gt; file to remove the trailing white space, before importing the data into PostgreSQL.</source>
          <target state="translated">&lt;code&gt;CSV&lt;/code&gt; 形式で、すべての文字が重要です。空白または &lt;code&gt;DELIMITER&lt;/code&gt; 以外の文字で囲まれた引用符付きの値には、それらの文字が含まれます。これにより、 &lt;code&gt;CSV&lt;/code&gt; 行に空白を埋め込んで固定幅にするシステムからデータをインポートすると、エラーが発生する可能性があります。このような状況が発生した場合、PostgreSQLにデータをインポートする前に、 &lt;code&gt;CSV&lt;/code&gt; ファイルを前処理して末尾の空白を削除する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="0153f75e36e8f0039d3aa08af5bcc40422e9783b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;FROM&lt;/code&gt; items, both the standard and PostgreSQL allow &lt;code&gt;AS&lt;/code&gt; to be omitted before an alias that is an unreserved keyword. But this is impractical for output column names, because of syntactic ambiguities.</source>
          <target state="translated">では &lt;code&gt;FROM&lt;/code&gt; アイテム、標準とPostgreSQLの両方ができるように &lt;code&gt;AS&lt;/code&gt; が予約されていないキーワードである別名の前に省略できるようになりました。しかし、構文のあいまいさのため、これは出力列名には非現実的です。</target>
        </trans-unit>
        <trans-unit id="0a49988bfaefe7a720bbc33d73d20e3ed846b39f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;GROUPS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; again must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of &lt;em&gt;peer groups&lt;/em&gt; before or after the current row's peer group, where a peer group is a set of rows that are equivalent in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering. (There must be an &lt;code&gt;ORDER BY&lt;/code&gt; clause in the window definition to use &lt;code&gt;GROUPS&lt;/code&gt; mode.)</source>
          <target state="translated">&lt;code&gt;GROUPS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; 再び非ヌル、非負整数であり、オプション手段を得なければならないフレームの開始または終了の指定された数の&lt;em&gt;ピアグループの&lt;/em&gt;ピアグループが現在の行のピアグループ、前または後 &lt;code&gt;ORDER BY&lt;/code&gt; 順序付けで同等の行のセット。 （ &lt;code&gt;GROUPS&lt;/code&gt; モードを使用するには、ウィンドウ定義に &lt;code&gt;ORDER BY&lt;/code&gt; 句が必要です。）</target>
        </trans-unit>
        <trans-unit id="948c542b2b357818bb888566376ebb0a4005a123" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; mode, these options require that the &lt;code&gt;ORDER BY&lt;/code&gt; clause specify exactly one column. The &lt;code&gt;offset&lt;/code&gt; specifies the maximum difference between the value of that column in the current row and its value in preceding or following rows of the frame. The data type of the &lt;code&gt;offset&lt;/code&gt; expression varies depending on the data type of the ordering column. For numeric ordering columns it is typically of the same type as the ordering column, but for datetime ordering columns it is an &lt;code&gt;interval&lt;/code&gt;. For example, if the ordering column is of type &lt;code&gt;date&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt;, one could write &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt;. The &lt;code&gt;offset&lt;/code&gt; is still required to be non-null and non-negative, though the meaning of &amp;ldquo;non-negative&amp;rdquo; depends on its data type.</source>
          <target state="translated">では &lt;code&gt;RANGE&lt;/code&gt; のモードでは、これらのオプションがあることが必要です &lt;code&gt;ORDER BY&lt;/code&gt; 句は、正確に1列を指定します。 &lt;code&gt;offset&lt;/code&gt; を指定し、現在の行のその列の値とフレームの行の前又は後に、その値の最大差。データ・タイプ &lt;code&gt;offset&lt;/code&gt; 発現は順序付け列のデータ・タイプに応じて変化します。数値の順序付け列の場合、これは通常、順序付け列と同じタイプですが、日時順序付け列の場合は、 &lt;code&gt;interval&lt;/code&gt; です。たとえば、順序付け列のタイプが &lt;code&gt;date&lt;/code&gt; または &lt;code&gt;timestamp&lt;/code&gt; 場合、 &lt;code&gt;RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING&lt;/code&gt; 記述できます。の &lt;code&gt;offset&lt;/code&gt; 「非負」の意味はそのデータ型に依存しますが、オフセットは引き続き非nullおよび非負である必要があります。</target>
        </trans-unit>
        <trans-unit id="1408d5e7e21bd209b1b9bfad149903cd4485729a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;RANGE&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt; mode, a &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame starts with the current row's first &lt;em&gt;peer&lt;/em&gt; row (a row that the window's &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts as equivalent to the current row), while a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;CURRENT ROW&lt;/code&gt; means the frame ends with the current row's last peer row. In &lt;code&gt;ROWS&lt;/code&gt; mode, &lt;code&gt;CURRENT ROW&lt;/code&gt; simply means the current row.</source>
          <target state="translated">&lt;code&gt;RANGE&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; モード、 &lt;code&gt;frame_start&lt;/code&gt; の &lt;code&gt;CURRENT ROW&lt;/code&gt; 現在の行の最初のフレームの開始を意味する&lt;em&gt;ピア&lt;/em&gt;行（行ウィンドウのその &lt;code&gt;ORDER BY&lt;/code&gt; 現在の行に相当するような句のソート）しながら &lt;code&gt;frame_end&lt;/code&gt; の &lt;code&gt;CURRENT ROW&lt;/code&gt; フレームの終了を意味します現在の行の最後のピア行。 &lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;CURRENT ROW&lt;/code&gt; 単に現在の行を意味します。</target>
        </trans-unit>
        <trans-unit id="30675f2bd0c7573e3e074baf89463cecdcac064e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ROWS&lt;/code&gt; mode, the &lt;code&gt;offset&lt;/code&gt; must yield a non-null, non-negative integer, and the option means that the frame starts or ends the specified number of rows before or after the current row.</source>
          <target state="translated">&lt;code&gt;ROWS&lt;/code&gt; モード、 &lt;code&gt;offset&lt;/code&gt; 非ヌル、非負整数を得なければならず、オプション手段そのフレームの開始または終了の行の指定された数の以前または現在の行の後。</target>
        </trans-unit>
        <trans-unit id="8f056c7130dbabcd038c08071d28f6253ddeb0d1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt; and &lt;code&gt;array_positions&lt;/code&gt;, each array element is compared to the searched value using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics.</source>
          <target state="translated">&lt;code&gt;array_position&lt;/code&gt; と &lt;code&gt;array_positions&lt;/code&gt; 使用して検索値が、各アレイ要素が比較され、 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 意味論。</target>
        </trans-unit>
        <trans-unit id="58eb966bf75cf56a14e39b6e0b483088ba13994e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_position&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned if the value is not found.</source>
          <target state="translated">で &lt;code&gt;array_position&lt;/code&gt; 、 &lt;code&gt;NULL&lt;/code&gt; は値が見つからない場合に返されます。</target>
        </trans-unit>
        <trans-unit id="6fb1576a237f50776165c9127d1d61a80997b7ea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;array_positions&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned instead.</source>
          <target state="translated">&lt;code&gt;array_positions&lt;/code&gt; 、 &lt;code&gt;NULL&lt;/code&gt; は、アレイがある場合にのみ戻される &lt;code&gt;NULL&lt;/code&gt; 。値が配列で見つからない場合は、代わりに空の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="42867f00aff6799a35548d7b4a45bb429b8b6f41" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;encrypt_iv&lt;/code&gt; and &lt;code&gt;decrypt_iv&lt;/code&gt;, the &lt;em&gt;&lt;code&gt;iv&lt;/code&gt;&lt;/em&gt; parameter is the initial value for the CBC mode; it is ignored for ECB. It is clipped or padded with zeroes if not exactly block size. It defaults to all zeroes in the functions without this parameter.</source>
          <target state="translated">&lt;code&gt;encrypt_iv&lt;/code&gt; と &lt;code&gt;decrypt_iv&lt;/code&gt; 、&lt;em&gt; &lt;code&gt;iv&lt;/code&gt; &lt;/em&gt;パラメータはCBCモードの初期値です。ECBでは無視されます。正確にブロックサイズでない場合は、クリップされるか、ゼロが埋め込まれます。このパラメーターのない関数では、デフォルトですべてゼロになります。</target>
        </trans-unit>
        <trans-unit id="74b9c4f74b2383573102ae88dc002c3f78bfc6aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;init&lt;/code&gt; mode, this option analogously specifies the location of the &lt;code&gt;initdb&lt;/code&gt; executable.</source>
          <target state="translated">で &lt;code&gt;init&lt;/code&gt; モードでは、このオプションは同様の場所を指定 &lt;code&gt;initdb&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="4b893445cf37926dce5c6e98df69fc0726a60722" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">&lt;code&gt;latex-longtable&lt;/code&gt; 左揃えデータタイプを含む各列の形式、この制御は、比例幅。空白で区切られた値のリストとして指定されます（例： &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; )。未指定の出力列は、最後に指定された値を使用します。</target>
        </trans-unit>
        <trans-unit id="cf4911342f242c7e8a426e1e90cc4a102540577f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latex-longtable&lt;/code&gt; format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g., &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt;. Unspecified output columns use the last specified value.</source>
          <target state="translated">&lt;code&gt;latex-longtable&lt;/code&gt; 左揃えデータタイプを含む各列の形式、この制御は、比例幅。これは、空白で区切られた値のリストとして指定されます（例： &lt;code&gt;'0.2 0.2 0.6'&lt;/code&gt; )。指定されていない出力列は、最後に指定された値を使用します。</target>
        </trans-unit>
        <trans-unit id="9860fa02b7dab9c5038f80534079df8148445840" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;logical&lt;/code&gt; level, the same information is logged as with &lt;code&gt;replica&lt;/code&gt;, plus information needed to allow extracting logical change sets from the WAL. Using a level of &lt;code&gt;logical&lt;/code&gt; will increase the WAL volume, particularly if many tables are configured for &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; and many &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; statements are executed.</source>
          <target state="translated">&lt;code&gt;logical&lt;/code&gt; レベル、同一の情報を有するように記録され &lt;code&gt;replica&lt;/code&gt; 、プラス情報がWALから論理変更セットを抽出できるようにする必要がありました。 &lt;code&gt;logical&lt;/code&gt; レベルを使用すると、特に多くのテーブルが &lt;code&gt;REPLICA IDENTITY FULL&lt;/code&gt; 用に構成され、多くの &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; ステートメントが実行される場合に、WALボリュームが増加します。</target>
        </trans-unit>
        <trans-unit id="19415b9e6aa0d531e04e643500bbdc24d23674cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, WAL-logging of some bulk operations can be safely skipped, which can make those operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations in which this optimization can be applied include:</source>
          <target state="translated">では &lt;code&gt;minimal&lt;/code&gt; レベル、いくつかの一括操作のWAL-ログは安全にはるかに高速にこれらの操作を行うことができ、スキップすることができます（&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;セクション14.4.7を&lt;/a&gt;）。この最適化を適用できる操作は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4b6bdb288d87683bcb61f09bf26e72e3f74194ad" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;minimal&lt;/code&gt; level, no information is logged for permanent relations for the remainder of a transaction that creates or rewrites them. This can make operations much faster (see &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;). Operations that initiate this optimization include:</source>
          <target state="translated">&lt;code&gt;minimal&lt;/code&gt; レベル、何の情報は、それらを作成又は書き換えるトランザクションの残りの永久的な関係のために記録されません。これにより、操作がはるかに高速になります（&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;セクション14.4.7を&lt;/a&gt;参照）。この最適化を開始する操作は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="61bcfc364ae05487e8e54b4d5f3e06b75ec150ff" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;psql&lt;/code&gt;, you will be greeted with the following message:</source>
          <target state="translated">で &lt;code&gt;psql&lt;/code&gt; を、次のメッセージで迎えられるでしょう。</target>
        </trans-unit>
        <trans-unit id="d81bf71ad3ee9adb26530d123722b695887e96a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the delimiter parameter is NULL, each character in the input string will become a separate element in the resulting array. If the delimiter is an empty string, then the entire input string is returned as a one-element array. Otherwise the input string is split at each occurrence of the delimiter string.</source>
          <target state="translated">で &lt;code&gt;string_to_array&lt;/code&gt; デリミタパラメータがNULLの場合、入力文字列の各文字は、結果の配列内の別の要素となるであろう。区切り文字が空の文字列の場合、入力文字列全体が1要素の配列として返されます。それ以外の場合、入力文字列は、区切り文字列が出現するたびに分割されます。</target>
        </trans-unit>
        <trans-unit id="ecd995c62df4a3324cc5c0dfdf5609bb28cc962a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;string_to_array&lt;/code&gt;, if the null-string parameter is omitted or NULL, none of the substrings of the input will be replaced by NULL. In &lt;code&gt;array_to_string&lt;/code&gt;, if the null-string parameter is omitted or NULL, any null elements in the array are simply skipped and not represented in the output string.</source>
          <target state="translated">で &lt;code&gt;string_to_array&lt;/code&gt; ヌル文字列パラメータを省略またはNULLである場合、入力のサブストリングのいずれもNULLで置き換えられません。で &lt;code&gt;array_to_string&lt;/code&gt; ヌル文字列パラメータを省略するかnullの場合、アレイ内の任意のヌル要素は、単にスキップされ、出力文字列で表されていません。</target>
        </trans-unit>
        <trans-unit id="b1222507b269ef568691d0a9d753a3eda5a5d8e5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_number&lt;/code&gt;, if non-data template patterns such as &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;TH&lt;/code&gt; are used, the corresponding number of input characters are skipped, whether or not they match the template pattern, unless they are data characters (that is, digits, sign, decimal point, or comma). For example, &lt;code&gt;TH&lt;/code&gt; would skip two non-data characters.</source>
          <target state="translated">&lt;code&gt;to_number&lt;/code&gt; などの非データ・テンプレート・パターン場合、 &lt;code&gt;L&lt;/code&gt; または &lt;code&gt;TH&lt;/code&gt; が使用されている、入力文字の対応する数は、彼らがデータ文字（ある、数字、記号、小数点がある場合を除き、彼らは、テンプレートパターンに一致するか否か、スキップされます、またはカンマ）。たとえば、 &lt;code&gt;TH&lt;/code&gt; は2つの非データ文字をスキップします。</target>
        </trans-unit>
        <trans-unit id="da01a26180a4b78ca506a4e26d673346bc64efee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, an ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified in one of two ways:</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、（グレゴリオ日付異なる）ISO 8601週番号日付は、2つの方法のいずれかで指定することができます。</target>
        </trans-unit>
        <trans-unit id="f9d931e068d7388b5b9791ba73a39ccc4330b961" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g. &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 年フォーマット仕様は、以下4桁、例えばよりもされている場合、 &lt;code&gt;YYY&lt;/code&gt; 、および指定された年未満4桁で、今年は2020年に最も近くなるように調整され、例えば &lt;code&gt;95&lt;/code&gt; は 1995となります。</target>
        </trans-unit>
        <trans-unit id="d8f4914c4ba597d9e2b92d0c671f4d7641758160" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, if the year format specification is less than four digits, e.g., &lt;code&gt;YYY&lt;/code&gt;, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g., &lt;code&gt;95&lt;/code&gt; becomes 1995.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、年の形式仕様は以下4桁以上であれば、例えば、 &lt;code&gt;YYY&lt;/code&gt; 、および指定された年は、以下4桁以上、今年は、例えば、2020年に最も近いように調整されている &lt;code&gt;95&lt;/code&gt; が1995になります。</target>
        </trans-unit>
        <trans-unit id="551a2fa16ad6836b39b0369ec3903da168ff58bb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, negative years are treated as signifying BC. If you write both a negative year and an explicit &lt;code&gt;BC&lt;/code&gt; field, you get AD again. An input of year zero is treated as 1 BC.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、負の年はBCを意味するものとして扱われています。負の年と明示的な &lt;code&gt;BC&lt;/code&gt; フィールドの両方を書き込むと、ADが再び取得されます。ゼロ年の入力は紀元前1年として扱われます。</target>
        </trans-unit>
        <trans-unit id="4dcc47dcfb30c72df039620b4818cb5cae63885b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;CC&lt;/code&gt; (century) field is accepted but ignored if there is a &lt;code&gt;YYY&lt;/code&gt;, &lt;code&gt;YYYY&lt;/code&gt; or &lt;code&gt;Y,YYY&lt;/code&gt; field. If &lt;code&gt;CC&lt;/code&gt; is used with &lt;code&gt;YY&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt; then the result is computed as that year in the specified century. If the century is specified but the year is not, the first year of the century is assumed.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、 &lt;code&gt;CC&lt;/code&gt; （世紀）フィールドは受け入れられますが存在する場合には無視され &lt;code&gt;YYY&lt;/code&gt; 、 &lt;code&gt;YYYY&lt;/code&gt; または &lt;code&gt;Y,YYY&lt;/code&gt; フィールド。 &lt;code&gt;CC&lt;/code&gt; が &lt;code&gt;YY&lt;/code&gt; または &lt;code&gt;Y&lt;/code&gt; と共に使用される場合、結果は指定された世紀のその年として計算されます。世紀が指定されているが年が指定されていない場合、世紀の最初の年が想定されます。</target>
        </trans-unit>
        <trans-unit id="34928f49bb5512bad729a0eba587c351c3b66a70" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; conversion has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after &lt;code&gt;YYYY&lt;/code&gt;, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; or &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、 &lt;code&gt;YYYY&lt;/code&gt; の変換は4つの以上の桁で年間処理制限を有します。 &lt;code&gt;YYYY&lt;/code&gt; の後に数字以外の文字またはテンプレートを使用する必要があります。そうしないと、年は常に4桁として解釈されます。たとえば（年20000の場合）： &lt;code&gt;to_date('200001131', 'YYYYMMDD')&lt;/code&gt; は4桁の年として解釈されます。代わりに、 &lt;code&gt;to_date('20000-1131', 'YYYY-MMDD')&lt;/code&gt; または &lt;code&gt;to_date('20000Nov31', 'YYYYMonDD')&lt;/code&gt; ように、年の後に数字以外の区切り文字を使用してください。</target>
        </trans-unit>
        <trans-unit id="544ec57993b0d566b29bfdeb2a8cf47932beafef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt;, weekday names or numbers (&lt;code&gt;DAY&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and related field types) are accepted but are ignored for purposes of computing the result. The same is true for quarter (&lt;code&gt;Q&lt;/code&gt;) fields.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; と &lt;code&gt;to_date&lt;/code&gt; 、曜日の名前または番号（ &lt;code&gt;DAY&lt;/code&gt; 、 &lt;code&gt;D&lt;/code&gt; 、および関連するフィールドタイプ）が受け入れられるが、結果を計算する目的のために無視されます。同じことが四半期（ &lt;code&gt;Q&lt;/code&gt; ）フィールドにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="8902e096eb8211a3103ef8a03507a1e1c0b7839c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;to_timestamp&lt;/code&gt;, millisecond (&lt;code&gt;MS&lt;/code&gt;) or microsecond (&lt;code&gt;US&lt;/code&gt;) fields are used as the seconds digits after the decimal point. For example &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; is not 3 milliseconds, but 300, because the conversion treats it as 12 + 0.3 seconds. So, for the format &lt;code&gt;SS.MS&lt;/code&gt;, the input values &lt;code&gt;12.3&lt;/code&gt;, &lt;code&gt;12.30&lt;/code&gt;, and &lt;code&gt;12.300&lt;/code&gt; specify the same number of milliseconds. To get three milliseconds, one must write &lt;code&gt;12.003&lt;/code&gt;, which the conversion treats as 12 + 0.003 = 12.003 seconds.</source>
          <target state="translated">で &lt;code&gt;to_timestamp&lt;/code&gt; 、ミリ秒（ &lt;code&gt;MS&lt;/code&gt; ）またはマイクロ秒（ &lt;code&gt;US&lt;/code&gt; ）のフィールドは、小数点の後の秒桁として使用されています。たとえば、 &lt;code&gt;to_timestamp('12.3', 'SS.MS')&lt;/code&gt; は3ミリ秒ではなく300です。これは、変換で12 + 0.3秒として扱われるためです。だから、フォーマットのため &lt;code&gt;SS.MS&lt;/code&gt; 、入力値 &lt;code&gt;12.3&lt;/code&gt; 、 &lt;code&gt;12.30&lt;/code&gt; 、および &lt;code&gt;12.300&lt;/code&gt; は、ミリ秒単位の同じ数を指定します。 3ミリ秒を取得するには、 &lt;code&gt;12.003&lt;/code&gt; を書き込む必要があります。変換では、12 + 0.003 = 12.003秒として処理されます。</target>
        </trans-unit>
        <trans-unit id="64a9c48229747c676385712712a92e7a02f4a20e" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases.</source>
          <target state="translated">AREでは、 &lt;code&gt;\&lt;/code&gt; の後に英数字が続くものはエスケープまたはエラーのいずれかですが、以前のリリースでは、これは英数字を記述するもう1つの方法でした。以前のリリースではそのようなシーケンスを記述する理由がなかったため、これはそれほど問題にはなりません。</target>
        </trans-unit>
        <trans-unit id="9fd039b2f7ce31cb27cef33f4f533a9fac0c1fbd" translate="yes" xml:space="preserve">
          <source>In AREs, &lt;code&gt;\&lt;/code&gt; remains a special character within &lt;code&gt;[]&lt;/code&gt;, so a literal &lt;code&gt;\&lt;/code&gt; within a bracket expression must be written &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">AREでは、 &lt;code&gt;\&lt;/code&gt; は &lt;code&gt;[]&lt;/code&gt; 内の特殊文字のままであるため、ブラケット式内のリテラル &lt;code&gt;\&lt;/code&gt; は &lt;code&gt;\\&lt;/code&gt; と記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="cb3ffc95899379ce4e17b50af19efa046a482415" translate="yes" xml:space="preserve">
          <source>In HTML format, this specifies attributes to be placed inside the &lt;code&gt;table&lt;/code&gt; tag. This could for example be &lt;code&gt;cellpadding&lt;/code&gt; or &lt;code&gt;bgcolor&lt;/code&gt;. Note that you probably don't want to specify &lt;code&gt;border&lt;/code&gt; here, as that is already taken care of by &lt;code&gt;\pset border&lt;/code&gt;. If no &lt;code&gt;value&lt;/code&gt; is given, the table attributes are unset.</source>
          <target state="translated">HTML形式では、 &lt;code&gt;table&lt;/code&gt; タグ内に配置する属性を指定します。たとえば、これは &lt;code&gt;cellpadding&lt;/code&gt; や &lt;code&gt;bgcolor&lt;/code&gt; です。 &lt;code&gt;\pset border&lt;/code&gt; によって既に処理されているので、おそらくここで &lt;code&gt;border&lt;/code&gt; を指定したくないことに注意してください。 &lt;code&gt;value&lt;/code&gt; を指定しない場合、テーブル属性は設定されません。</target>
        </trans-unit>
        <trans-unit id="814a324a3771e36f5c269dff83adcdc2f6482fa5" translate="yes" xml:space="preserve">
          <source>In Linux 2.4 and later, the default virtual memory behavior is not optimal for PostgreSQL. Because of the way that the kernel implements memory overcommit, the kernel might terminate the PostgreSQL postmaster (the master server process) if the memory demands of either PostgreSQL or another process cause the system to run out of virtual memory.</source>
          <target state="translated">Linux 2.4以降では、デフォルトの仮想メモリの動作はPostgreSQLに最適ではありません。カーネルがメモリオーバーコミットを実装する方法のため、PostgreSQLまたは他のプロセスのメモリ要求によりシステムが仮想メモリを使い果たした場合、カーネルはPostgreSQLのポストマスタ(マスタサーバプロセス)を終了させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f9db993d9ed52b850a8119db5ab8d068b60a0509" translate="yes" xml:space="preserve">
          <source>In NetBSD 5.0 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">NetBSD 5.0以降では、次のように &lt;code&gt;sysctl&lt;/code&gt; を使用してIPCパラメーターを調整できます。</target>
        </trans-unit>
        <trans-unit id="33cf5a32119e2012e85b594bd01ed746ff893ad5" translate="yes" xml:space="preserve">
          <source>In OpenBSD 3.3 and later, IPC parameters can be adjusted using &lt;code&gt;sysctl&lt;/code&gt;, for example:</source>
          <target state="translated">OpenBSD 3.3以降では、次のように &lt;code&gt;sysctl&lt;/code&gt; を使用してIPCパラメータを調整できます。</target>
        </trans-unit>
        <trans-unit id="d469c640f950b7673c7ae58a9ecc0f315265b7c1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.0, large objects did not have access privileges and were, therefore, always readable and writable by all users. Setting this variable to &lt;code&gt;on&lt;/code&gt; disables the new privilege checks, for compatibility with prior releases. The default is &lt;code&gt;off&lt;/code&gt;. Only superusers can change this setting.</source>
          <target state="translated">9.0より前のPostgreSQLリリースでは、ラージオブジェクトにはアクセス権限がなかったため、すべてのユーザーが常に読み取りと書き込みが可能でした。この変数を &lt;code&gt;on&lt;/code&gt; に設定すると、以前のリリースとの互換性のために、新しい特権チェックが無効になります。デフォルトは &lt;code&gt;off&lt;/code&gt; です。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="22cd8a67509e8ca7db080a3ecd0b854c45395a98" translate="yes" xml:space="preserve">
          <source>In PostgreSQL releases prior to 9.3, &lt;code&gt;commit_delay&lt;/code&gt; behaved differently and was much less effective: it affected only commits, rather than all WAL flushes, and waited for the entire configured delay even if the WAL flush was completed sooner. Beginning in PostgreSQL 9.3, the first process that becomes ready to flush waits for the configured interval, while subsequent processes wait only until the leader completes the flush operation.</source>
          <target state="translated">9.3より前のPostgreSQLリリースでは、 &lt;code&gt;commit_delay&lt;/code&gt; の動作が異なり、効果がはるかに低かった。すべてのWALフラッシュではなく、コミットのみに影響し、WALフラッシュがより早く完了した場合でも、設定された遅延全体を待機した。PostgreSQL 9.3以降、フラッシュの準備ができた最初のプロセスは、設定された間隔だけ待機しますが、後続のプロセスは、リーダーがフラッシュ操作を完了するまで待機します。</target>
        </trans-unit>
        <trans-unit id="b3a09d320c0eb1af5ebf6fc539b70645d7fbc828" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions 8.0 through 8.2, the effects of a &lt;code&gt;SET LOCAL&lt;/code&gt; would be canceled by releasing an earlier savepoint, or by successful exit from a PL/pgSQL exception block. This behavior has been changed because it was deemed unintuitive.</source>
          <target state="translated">PostgreSQLバージョン8.0〜8.2では、以前のセーブポイントを解放するか、PL / pgSQL例外ブロックを正常に終了することにより、 &lt;code&gt;SET LOCAL&lt;/code&gt; の影響が取り消されます。この動作は、直感的でないと見なされたため変更されました。</target>
        </trans-unit>
        <trans-unit id="a2a2f1f614c98ca12a5b32b40e076079264d9c76" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was customary to avoid creating a shell type at all, by replacing the functions' forward references to the type name with the placeholder pseudo-type &lt;code&gt;opaque&lt;/code&gt;. The &lt;code&gt;cstring&lt;/code&gt; arguments and results also had to be declared as &lt;code&gt;opaque&lt;/code&gt; before 7.3. To support loading of old dump files, &lt;code&gt;CREATE TYPE&lt;/code&gt; will accept I/O functions declared using &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function declarations to use the correct types.</source>
          <target state="translated">7.3より前のバージョンのPostgreSQLでは、型名への関数の前方参照をプレースホルダーの疑似型 &lt;code&gt;opaque&lt;/code&gt; に置き換えることで、シェル型の作成をまったく回避するのが慣習でした。 &lt;code&gt;cstring&lt;/code&gt; 引数と結果もとして宣言されなければならなかった &lt;code&gt;opaque&lt;/code&gt; 7.3の前に。古いダンプファイルのロードをサポートするために、 &lt;code&gt;CREATE TYPE&lt;/code&gt; は &lt;code&gt;opaque&lt;/code&gt; を使用して宣言されたI / O関数を受け入れますが、通知を発行し、関数の宣言を変更して正しい型を使用します。</target>
        </trans-unit>
        <trans-unit id="b355acb666b0ad4cd57d90f2927cbffb2b6ed9ef" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare handler functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;language_handler&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">7.3より前のバージョンのPostgreSQLでは、ハンドラー関数を、 &lt;code&gt;language_handler&lt;/code&gt; ではなく、プレースホルダータイプ &lt;code&gt;opaque&lt;/code&gt; を返すものとして宣言する必要がありました。古いダンプファイルのロードをサポートするために、 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; は &lt;code&gt;opaque&lt;/code&gt; を返すと宣言された関数を受け入れますが、通知を発行し、関数の宣言された戻り値の型を &lt;code&gt;language_handler&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="c16c4aa970c78b968d9f432a8088edb5d24051d5" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 7.3, it was necessary to declare trigger functions as returning the placeholder type &lt;code&gt;opaque&lt;/code&gt;, rather than &lt;code&gt;trigger&lt;/code&gt;. To support loading of old dump files, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; will accept a function declared as returning &lt;code&gt;opaque&lt;/code&gt;, but it will issue a notice and change the function's declared return type to &lt;code&gt;trigger&lt;/code&gt;.</source>
          <target state="translated">7.3より前のバージョンのPostgreSQL では、 &lt;code&gt;trigger&lt;/code&gt; ではなく、プレースホルダー型 &lt;code&gt;opaque&lt;/code&gt; を返すようにトリガー関数を宣言する必要がありました。古いダンプファイルのロードをサポートするために、 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; は &lt;code&gt;opaque&lt;/code&gt; を返すと宣言された関数を受け入れますが、通知を発行し、関数の宣言された戻り値の型を &lt;code&gt;trigger&lt;/code&gt; に変更します。</target>
        </trans-unit>
        <trans-unit id="3c68aa880bfe2dcd90559cbb12f6681d9282ddb1" translate="yes" xml:space="preserve">
          <source>In PostgreSQL versions before 9.4, freezing was implemented by actually replacing a row's insertion XID with &lt;code&gt;FrozenTransactionId&lt;/code&gt;, which was visible in the row's &lt;code&gt;xmin&lt;/code&gt; system column. Newer versions just set a flag bit, preserving the row's original &lt;code&gt;xmin&lt;/code&gt; for possible forensic use. However, rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;FrozenTransactionId&lt;/code&gt; (2) may still be found in databases pg_upgrade'd from pre-9.4 versions.</source>
          <target state="translated">9.4より前のバージョンのPostgreSQLでは、行の挿入XIDを行の &lt;code&gt;xmin&lt;/code&gt; システム列に表示されていた &lt;code&gt;FrozenTransactionId&lt;/code&gt; に実際に置き換えることにより、フリーズが実装されました。新しいバージョンでは、フラグビットを設定するだけで、行の元の &lt;code&gt;xmin&lt;/code&gt; を法医学的な使用のために保持します。ただし、 &lt;code&gt;xmin&lt;/code&gt; が &lt;code&gt;FrozenTransactionId&lt;/code&gt; （2）に等しい行は、9.4より前のバージョンからpg_upgradeされたデータベースでまだ見つかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="671f1f8fc18839cfcffc25653d6a82f0e2f7003b" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, &lt;em&gt;Class&lt;/em&gt; is an archaic synonym for &lt;em&gt;relation&lt;/em&gt;.</source>
          <target state="translated">PostgreSQLでは、&lt;em&gt;Class&lt;/em&gt;は&lt;em&gt;relationの&lt;/em&gt;古風な同義語です。</target>
        </trans-unit>
        <trans-unit id="eadad43cc831b2ff40334680f58601d4f7a10c43" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a reference to a table name (or alias) in a query is effectively a reference to the composite value of the table's current row. For example, if we had a table &lt;code&gt;inventory_item&lt;/code&gt; as shown &lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;above&lt;/a&gt;, we could write:</source>
          <target state="translated">PostgreSQLでは、クエリ内のテーブル名（またはエイリアス）への参照は、事実上、テーブルの現在の行の複合値への参照です。たとえば、&lt;a href=&quot;rowtypes#ROWTYPES-DECLARING&quot;&gt;上記の&lt;/a&gt;表の &lt;code&gt;inventory_item&lt;/code&gt; がある場合、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="4a86fbee986217732dc6e120d53c8e8d4a6c9100" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet:</source>
          <target state="translated">PostgreSQLでは、テーブルは0個以上の他のテーブルを継承することができ、問い合わせはテーブルの全行を参照するか、テーブルの全行とその子孫テーブルの全行のいずれかを参照することができます。後者の動作がデフォルトです。例えば、以下のクエリは、州都を含む、標高500フィート以上の場所にあるすべての都市の名前を検索します。</target>
        </trans-unit>
        <trans-unit id="5bbc940645cf942038016bf2339fe7d4f2c180e0" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an elevation over 500 feet:</source>
          <target state="translated">PostgreSQLでは、テーブルは0個以上の他のテーブルを継承することができ、問い合わせはテーブルの全行を参照するか、テーブルの全行とその子孫テーブルの全行のいずれかを参照することができます。後者の動作がデフォルトです。例えば、以下のクエリは、州都を含む、標高500フィート以上の場所にあるすべての都市の名前を検索します。</target>
        </trans-unit>
        <trans-unit id="74efdce9636de27e76a8b8265ce6cb497dd89fdf" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, a transaction is set up by surrounding the SQL commands of the transaction with &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; commands. So our banking transaction would actually look like:</source>
          <target state="translated">PostgreSQLでは、トランザクションは、トランザクションのSQLコマンドを &lt;code&gt;BEGIN&lt;/code&gt; コマンドと &lt;code&gt;COMMIT&lt;/code&gt; コマンドで囲むことによって設定されます。したがって、銀行取引は実際には次のようになります。</target>
        </trans-unit>
        <trans-unit id="ba3eb2b425968ebc072af7dd5475bc71e9126bfd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLでは、行の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; で古いバージョンの行がすぐに削除されるわけではありません。このアプローチは、マルチバージョン同時実行制御（MVCC、&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）の利点を得るのに必要です。行バージョンは、他のトランザクションから見えている間は削除しないでください。ただし、最終的には、古いバージョンまたは削除された行のバージョンは、どのトランザクションにとっても関心がなくなります。次に、ディスク領域の要件が無制限に増大するのを防ぐために、それが占める領域を再利用して新しい行で再利用する必要があります。これは &lt;code&gt;VACUUM&lt;/code&gt; を実行することによって行われます。</target>
        </trans-unit>
        <trans-unit id="6391c36f8926e9d031902999f670ae49ff9d23c6" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; of a row does not immediately remove the old version of the row. This approach is necessary to gain the benefits of multiversion concurrency control (MVCC, see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;): the row version must not be deleted while it is still potentially visible to other transactions. But eventually, an outdated or deleted row version is no longer of interest to any transaction. The space it occupies must then be reclaimed for reuse by new rows, to avoid unbounded growth of disk space requirements. This is done by running &lt;code&gt;VACUUM&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLでは、行の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; は、古いバージョンの行をすぐには削除しません。このアプローチは、マルチバージョン同時実行制御（MVCC、&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）の利点を得るのに必要です。行バージョンは、他のトランザクションから見える可能性がある間は削除しないでください。しかし、最終的には、古い行バージョンまたは削除された行バージョンは、どのトランザクションにも関係しなくなります。次に、ディスクスペース要件の無制限の増加を回避するために、それが占有するスペースを新しい行で再利用するために再利用する必要があります。これは、 &lt;code&gt;VACUUM&lt;/code&gt; を実行することによって実行されます。</target>
        </trans-unit>
        <trans-unit id="b304e14a0ece97ffe0ae3c2773ba82b02c4d00d4" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, the term &lt;em&gt;cluster&lt;/em&gt; is also sometimes used to refer to an instance. (Don't confuse this term with the SQL command &lt;code&gt;CLUSTER&lt;/code&gt;.)</source>
          <target state="translated">PostgreSQLでは、&lt;em&gt;クラスター&lt;/em&gt;という用語はインスタンスを指すために使用されることもあります。（この用語をSQLコマンド &lt;code&gt;CLUSTER&lt;/code&gt; と混同しないでください。）</target>
        </trans-unit>
        <trans-unit id="bbda6fce7f63ccb95f1398e8c5c8a9c6bb83f492" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e. PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">PostgreSQLでは、4つの標準トランザクション分離レベルのいずれかを要求することができますが、内部的には3つの異なる分離レベルしか実装されていません。これは、標準の分離レベルをPostgreSQLの多バージョン同時実行制御アーキテクチャにマッピングする唯一の賢明な方法だからです。</target>
        </trans-unit>
        <trans-unit id="83cd5c09f1c331276300cecbfba985d6b8844acd" translate="yes" xml:space="preserve">
          <source>In PostgreSQL, you can request any of the four standard transaction isolation levels, but internally only three distinct isolation levels are implemented, i.e., PostgreSQL's Read Uncommitted mode behaves like Read Committed. This is because it is the only sensible way to map the standard isolation levels to PostgreSQL's multiversion concurrency control architecture.</source>
          <target state="translated">PostgreSQLでは、4つの標準トランザクション分離レベルのいずれかを要求することができますが、内部的には3つの異なる分離レベルしか実装されていません。これは、標準の分離レベルをPostgreSQLの多バージョン同時実行制御アーキテクチャにマッピングする唯一の賢明な方法だからです。</target>
        </trans-unit>
        <trans-unit id="759eb406805a5a1c000f22431f41b882c8790352" translate="yes" xml:space="preserve">
          <source>In SCRAM without channel binding, the server chooses a random number that is transmitted to the client to be mixed with the user-supplied password in the transmitted password hash. While this prevents the password hash from being successfully retransmitted in a later session, it does not prevent a fake server between the real server and client from passing through the server's random value and successfully authenticating.</source>
          <target state="translated">チャネルバインディングのないSCRAMでは、サーバはクライアントに送信される乱数を選択して、送信されるパスワードハッシュの中でユーザが提供したパスワードと混合します。これにより、後のセッションでパスワードハッシュが正常に再送されることを防ぐことができますが、本物のサーバとクライアントの間の偽サーバがサーバの乱数値を通過して認証に成功することを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="bbe3d8277f59658a3be0c65846387947fe489961" translate="yes" xml:space="preserve">
          <source>In SQL:2006 and later, both directions of conversion between standard SQL data types and the XML Schema types are specified precisely. However, the rules are expressed using the types and semantics of XQuery/XPath, and have no direct application to the different data model of XPath 1.0.</source>
          <target state="translated">SQL:2006 以降では、標準 SQL データ型と XML スキーマ型の間の変換の両方向が正確に規定されています。ただし、このルールはXQuery/XPathの型とセマンティクスを使って表現されており、XPath 1.0の異なるデータモデルに直接適用されるものではありません。</target>
        </trans-unit>
        <trans-unit id="1cddd15d85853fd05a956af5b4c400072d8cd616" translate="yes" xml:space="preserve">
          <source>In Solaris 10 and later, and OpenSolaris, the default shared memory and semaphore settings are good enough for most PostgreSQL applications. Solaris now defaults to a &lt;code&gt;SHMMAX&lt;/code&gt; of one-quarter of system RAM. To further adjust this setting, use a project setting associated with the &lt;code&gt;postgres&lt;/code&gt; user. For example, run the following as &lt;code&gt;root&lt;/code&gt;:</source>
          <target state="translated">Solaris 10以降とOpenSolarisでは、デフォルトの共有メモリとセマフォの設定で、ほとんどのPostgreSQLアプリケーションに十分対応できます。 Solarisのデフォルトは、システムRAMの4分の1の &lt;code&gt;SHMMAX&lt;/code&gt; です。この設定をさらに調整するには、 &lt;code&gt;postgres&lt;/code&gt; ユーザーに関連付けられたプロジェクト設定を使用します。たとえば、 &lt;code&gt;root&lt;/code&gt; として以下を実行します。</target>
        </trans-unit>
        <trans-unit id="f2711fad286d67111c91bf5304258de9bff55609" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;BEFORE&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just before the function is or would be executed, so using &lt;code&gt;WHEN&lt;/code&gt; is not materially different from testing the same condition at the beginning of the trigger function. Note in particular that the &lt;code&gt;NEW&lt;/code&gt; row seen by the condition is the current value, as possibly modified by earlier triggers. Also, a &lt;code&gt;BEFORE&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition is not allowed to examine the system columns of the &lt;code&gt;NEW&lt;/code&gt; row (such as &lt;code&gt;ctid&lt;/code&gt;), because those won't have been set yet.</source>
          <target state="translated">で &lt;code&gt;BEFORE&lt;/code&gt; トリガー、 &lt;code&gt;WHEN&lt;/code&gt; 条件は関数であるか、そう使用して実行される直前に評価される &lt;code&gt;WHEN&lt;/code&gt; トリガ機能の開始時に同じ条件をテストすると著しく異なりません。特に、条件によって表示される &lt;code&gt;NEW&lt;/code&gt; 行は現在の値であり、以前のトリガーによって変更された可能性があることに注意してください。また、 &lt;code&gt;BEFORE&lt;/code&gt; トリガーの &lt;code&gt;WHEN&lt;/code&gt; 条件では、まだ設定されていないため、 &lt;code&gt;NEW&lt;/code&gt; 行のシステム列（ &lt;code&gt;ctid&lt;/code&gt; など）を調べることはできません。</target>
        </trans-unit>
        <trans-unit id="9ce810944c17541339c741b40b793201537de044" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DELETE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the content of the deleted row. For example:</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 、に利用可能なデータ &lt;code&gt;RETURNING&lt;/code&gt; は、削除された行の内容です。例えば：</target>
        </trans-unit>
        <trans-unit id="0d3bf14e9dc0493ac82721df4faae7ba81c88992" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;DROP FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support must be specified.</source>
          <target state="translated">&lt;code&gt;DROP FUNCTION&lt;/code&gt; 句、オペランド・データ・タイプ（複数可）機能をサポートすることを意図されている指定されなければなりません。</target>
        </trans-unit>
        <trans-unit id="85532f42163c3739d7f5a6244714ead077b8baea" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">&lt;code&gt;FUNCTION&lt;/code&gt; 句、オペランド・データ・タイプ（複数可）関数をサポートすることを意図されている、のための（（Bツリー比較関数及びハッシュ関数の）関数の入力データ型（S）またはクラスのデータ・タイプと異なる場合Bツリーソートサポート関数およびGiST、SP-GiST、GIN、BRIN演算子クラスのすべての関数）。これらのデフォルトは正しいため、データ型間の比較をサポートするためのBツリーソートサポート関数の場合を除いて、 &lt;code&gt;FUNCTION&lt;/code&gt; 句で &lt;code&gt;op_type&lt;/code&gt; を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="48b115e1e3ffc8870fd0440011ed57528dd63c06" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function (for B-tree comparison functions and hash functions) or the class's data type (for B-tree sort support functions, B-tree equal image functions, and all functions in GiST, SP-GiST, GIN and BRIN operator classes). These defaults are correct, and so &lt;code&gt;op_type&lt;/code&gt; need not be specified in &lt;code&gt;FUNCTION&lt;/code&gt; clauses, except for the case of a B-tree sort support function that is meant to support cross-data-type comparisons.</source>
          <target state="translated">&lt;code&gt;FUNCTION&lt;/code&gt; 句、オペランド・データ・タイプ（複数可）関数をサポートすることを意図されている、のための（（Bツリー比較関数及びハッシュ関数の）関数の入力データ型（S）またはクラスのデータ・タイプと異なる場合Bツリーソートサポート関数、Bツリーイコールイメージ関数、およびGiST、SP-GiST、GIN、BRIN演算子クラスのすべての関数）。これらのデフォルトは正しいため、データ型間の比較をサポートすることを目的としたBツリーソートサポート関数の場合を除いて、 &lt;code&gt;FUNCTION&lt;/code&gt; 句で &lt;code&gt;op_type&lt;/code&gt; を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="6f9bb9a1e74c73e631d5463da369a9644506e4f0" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SELECT&lt;/code&gt; command, these two policies are combined using &lt;code&gt;OR&lt;/code&gt;, with the net effect being that all rows can be selected. In other command types, only the second policy applies, so that the effects are the same as before.</source>
          <target state="translated">では &lt;code&gt;SELECT&lt;/code&gt; コマンドは、これら2つのポリシーを使用して結合されている &lt;code&gt;OR&lt;/code&gt; 、正味の効果は、すべての行を選択することができていると。他のコマンドタイプでは、2番目のポリシーのみが適用されるため、効果は以前と同じです。</target>
        </trans-unit>
        <trans-unit id="300ce212406203fa6b094fb383bde2b25f44a159" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;pg_hba.conf&lt;/code&gt; record specifying certificate authentication, the authentication option &lt;code&gt;clientcert&lt;/code&gt; is assumed to be &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;, and it cannot be turned off since a client certificate is necessary for this method. What the &lt;code&gt;cert&lt;/code&gt; method adds to the basic &lt;code&gt;clientcert&lt;/code&gt; certificate validity test is a check that the &lt;code&gt;cn&lt;/code&gt; attribute matches the database user name.</source>
          <target state="translated">証明書認証を指定する &lt;code&gt;pg_hba.conf&lt;/code&gt; レコードでは、認証オプション &lt;code&gt;clientcert&lt;/code&gt; は &lt;code&gt;verify-ca&lt;/code&gt; または &lt;code&gt;verify-full&lt;/code&gt; であると想定されており、このメソッドにはクライアント証明書が必要なのでオフにすることはできません。どのような &lt;code&gt;cert&lt;/code&gt; 方法は、基本的に追加 &lt;code&gt;clientcert&lt;/code&gt; 証明書の有効性をテストすると、そのチェックです &lt;code&gt;cn&lt;/code&gt; 属性は、データベースのユーザー名と一致します。</target>
        </trans-unit>
        <trans-unit id="f05e815aa51edd32e8f243de544f1a7fed6f4907" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;to_char&lt;/code&gt; output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string. If there are characters in the template string that are not template patterns, the corresponding characters in the input data string are simply skipped over (whether or not they are equal to the template string characters).</source>
          <target state="translated">で &lt;code&gt;to_char&lt;/code&gt; 出力テンプレート文字列、認識及び所定の値に基づいて、適切にフォーマットされたデータで置き換えられる特定のパターンがあります。テンプレートパターンではないテキストは、そのままそのままコピーされます。同様に、（他の関数の）入力テンプレート文字列では、テンプレートパターンは入力データ文字列によって提供される値を識別します。テンプレートパターンではない文字がテンプレート文字列にある場合、入力データ文字列の対応する文字は（テンプレート文字列の文字と等しいかどうかに関係なく）単にスキップされます。</target>
        </trans-unit>
        <trans-unit id="78e3bba2064f9d9c2fee2733a54ca75d990eba66" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;hash join&lt;/em&gt; (without the &quot;parallel&quot; prefix), the inner side is executed in full by every cooperating process to build identical copies of the hash table. This may be inefficient if the hash table is large or the plan is expensive. In a &lt;em&gt;parallel hash join&lt;/em&gt;, the inner side is a &lt;em&gt;parallel hash&lt;/em&gt; that divides the work of building a shared hash table over the cooperating processes.</source>
          <target state="translated">&lt;em&gt;ハッシュジョイン&lt;/em&gt;（「平行」接頭辞なし）、内側には、ハッシュテーブルの同一のコピーを構築するためにすべての協働プロセスによって完全に実行されます。これは、ハッシュテーブルが大きい場合、または計画が高額な場合に非効率的です。&lt;em&gt;並列ハッシュジョイン&lt;/em&gt;、内部側は&lt;em&gt;並列ハッシュ&lt;/em&gt;協働プロセスを介して共有ハッシュテーブルを構築する作業を分割します。</target>
        </trans-unit>
        <trans-unit id="3480286d445961d6181c445c4ffd40322b928fd9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;merge join&lt;/em&gt;, the inner side is always a non-parallel plan and therefore executed in full. This may be inefficient, especially if a sort must be performed, because the work and resulting data are duplicated in every cooperating process.</source>
          <target state="translated">&lt;em&gt;マージジョイン&lt;/em&gt;、内側が常に非平行平面であるため、完全に実行されます。これは、特にソートを実行する必要がある場合、作業と結果のデータがすべての協調プロセスで複製されるため、非効率的です。</target>
        </trans-unit>
        <trans-unit id="400e7c200fdc3546ddf00f5c7ed10cb2ab42e4c0" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;nested loop join&lt;/em&gt;, the inner side is always non-parallel. Although it is executed in full, this is efficient if the inner side is an index scan, because the outer tuples and thus the loops that look up values in the index are divided over the cooperating processes.</source>
          <target state="translated">&lt;em&gt;ネストされたループ結合&lt;/em&gt;、内側が常に非平行です。これは完全に実行されますが、内部がインデックススキャンの場合は効率的です。これは、外部タプル、つまりインデックス内の値を検索するループが協調プロセスに分割されるためです。</target>
        </trans-unit>
        <trans-unit id="dea6a7ade41e8f01fb686c080220d4159b567183" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel bitmap heap scan&lt;/em&gt;, one process is chosen as the leader. That process performs a scan of one or more indexes and builds a bitmap indicating which table blocks need to be visited. These blocks are then divided among the cooperating processes as in a parallel sequential scan. In other words, the heap scan is performed in parallel, but the underlying index scan is not.</source>
          <target state="translated">では&lt;em&gt;、並列ビットマップヒープスキャン&lt;/em&gt;、一つのプロセスは、リーダーとして選ばれます。そのプロセスは、1つ以上のインデックスのスキャンを実行し、どのテーブルブロックにアクセスする必要があるかを示すビットマップを作成します。これらのブロックは、並列順次スキャンの場合と同様に、連携するプロセス間で分割されます。つまり、ヒープスキャンは並列に実行されますが、基になるインデックススキャンは実行されません。</target>
        </trans-unit>
        <trans-unit id="8227deba10aefb19ed8caa11f69ff745de460ae7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other process can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">&lt;em&gt;並列索引スキャン&lt;/em&gt;または&lt;em&gt;並列インデックスのみスキャン&lt;/em&gt;、協働プロセスは、インデックスからデータを読み出す交代します。現在、並列インデックススキャンはbtreeインデックスでのみサポートされています。各プロセスは単一のインデックスブロックを要求し、そのブロックによって参照されるすべてのタプルをスキャンして返します。他のプロセスが同時に別のインデックスブロックからタプルを返す可能性があります。並列btreeスキャンの結果は、各ワーカープロセス内でソートされた順序で返されます。</target>
        </trans-unit>
        <trans-unit id="76601edb0fbc4f9ce17e08d79102a74db01983a7" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel index scan&lt;/em&gt; or &lt;em&gt;parallel index-only scan&lt;/em&gt;, the cooperating processes take turns reading data from the index. Currently, parallel index scans are supported only for btree indexes. Each process will claim a single index block and will scan and return all tuples referenced by that block; other processes can at the same time be returning tuples from a different index block. The results of a parallel btree scan are returned in sorted order within each worker process.</source>
          <target state="translated">&lt;em&gt;並列索引スキャン&lt;/em&gt;または&lt;em&gt;並列インデックスのみスキャン&lt;/em&gt;、協働プロセスは、インデックスからデータを読み出す交代します。現在、並列インデックススキャンはbtreeインデックスでのみサポートされています。各プロセスは単一のインデックスブロックを要求し、そのブロックによって参照されるすべてのタプルをスキャンして返します。他のプロセスは、同時に別のインデックスブロックからタプルを返すことができます。並列btreeスキャンの結果は、各ワーカープロセス内でソートされた順序で返されます。</target>
        </trans-unit>
        <trans-unit id="9434bbdc8aace98fbdb811c879672bca3c9b835e" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;parallel sequential scan&lt;/em&gt;, the table's blocks will be divided among the cooperating processes. Blocks are handed out one at a time, so that access to the table remains sequential.</source>
          <target state="translated">&lt;em&gt;平行シーケンシャルスキャン&lt;/em&gt;、テーブルのブロックが協働プロセス間で分割されます。ブロックは一度に1つずつ配布されるため、テーブルへのアクセスは順次に行われます。</target>
        </trans-unit>
        <trans-unit id="f3fefb800e2db94c9c9a41bf996e2bc5c5260e63" translate="yes" xml:space="preserve">
          <source>In a B-tree leaf page, &lt;code&gt;ctid&lt;/code&gt; points to a heap tuple. In an internal page, the block number part of &lt;code&gt;ctid&lt;/code&gt; points to another page in the index itself, while the offset part (the second number) is ignored and is usually 1.</source>
          <target state="translated">Bツリーリーフページでは、 &lt;code&gt;ctid&lt;/code&gt; はヒープタプルを指します。内部ページでは、 &lt;code&gt;ctid&lt;/code&gt; のブロック番号部分はインデックス自体の別のページを指していますが、オフセット部分（2番目の番号）は無視され、通常は1です。</target>
        </trans-unit>
        <trans-unit id="d0a6087a10f85c3bb150e6308e3861061574aa67" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">並行インデックス作成では、インデックスは実際には1つのトランザクションでシステムカタログに入力され、次に2つのトランザクションで2つのテーブルスキャンが発生します。各テーブルスキャンの前に、インデックスビルドは、テーブルを変更した既存のトランザクションが終了するのを待つ必要があります。 2回目のスキャンの後、インデックスの作成は、2回目のスキャンが終了する前のスナップショット（&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）を持つトランザクションが終了するまで待機する必要があります。最後に、インデックスを使用できるようにマークを付けることができ、 &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドは終了します。ただし、その場合でも、インデックスはクエリですぐに使用できない場合があります。最悪の場合、インデックスの作成の開始より前のトランザクションが存在する限り、インデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="c15278182867851c1af83a8c951f5ef55e2fcbe1" translate="yes" xml:space="preserve">
          <source>In a concurrent index build, the index is actually entered into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate. Then finally the index can be marked ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.</source>
          <target state="translated">同時インデックスビルドでは、インデックスは実際には1つのトランザクションでシステムカタログに入力され、その後2つのテーブルスキャンがさらに2つのトランザクションで発生します。各テーブルスキャンの前に、インデックスビルドは、テーブルを変更した既存のトランザクションが終了するのを待つ必要があります。 2回目のスキャンの後、インデックスビルドは、2回目のスキャンより前のスナップショット（&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）を持つトランザクションが終了するのを待つ必要があります。その後、最後にインデックスを使用可能としてマークでき、 &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドが終了します。ただし、その場合でも、インデックスをクエリにすぐに使用できない場合があります。最悪の場合、インデックスの作成開始より前のトランザクションが存在する限り、インデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="f4a542d58c1d654f7da71e85731698e5120795a1" translate="yes" xml:space="preserve">
          <source>In a default installation, none of the above parameters are set explicitly. Instead, the data directory is specified by the &lt;code&gt;-D&lt;/code&gt; command-line option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable, and the configuration files are all found within the data directory.</source>
          <target state="translated">デフォルトのインストールでは、上記のパラメーターは明示的に設定されていません。代わりに、データディレクトリは &lt;code&gt;-D&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;PGDATA&lt;/code&gt; 環境変数で指定され、構成ファイルはすべてデータディレクトリ内にあります。</target>
        </trans-unit>
        <trans-unit id="ade0e33e559fe0711e0dbe8eb460618e29475014" translate="yes" xml:space="preserve">
          <source>In a dropped column's &lt;code&gt;pg_attribute&lt;/code&gt; entry, &lt;code&gt;atttypid&lt;/code&gt; is reset to zero, but &lt;code&gt;attlen&lt;/code&gt; and the other fields copied from &lt;code&gt;pg_type&lt;/code&gt; are still valid. This arrangement is needed to cope with the situation where the dropped column's data type was later dropped, and so there is no &lt;code&gt;pg_type&lt;/code&gt; row anymore. &lt;code&gt;attlen&lt;/code&gt; and the other fields can be used to interpret the contents of a row of the table.</source>
          <target state="translated">ドロップされた列の &lt;code&gt;pg_attribute&lt;/code&gt; エントリでは、 &lt;code&gt;atttypid&lt;/code&gt; はゼロにリセットされますが、 &lt;code&gt;attlen&lt;/code&gt; と &lt;code&gt;pg_type&lt;/code&gt; からコピーされた他のフィールドは引き続き有効です。この配置は、ドロップされた列のデータ型が後でドロップされ、 &lt;code&gt;pg_type&lt;/code&gt; 行がなくなった状況に対処するために必要です。 &lt;code&gt;attlen&lt;/code&gt; およびその他のフィールドを使用して、テーブルの行の内容を解釈できます。</target>
        </trans-unit>
        <trans-unit id="919410546242ad36460212f72d578356bff6291e" translate="yes" xml:space="preserve">
          <source>In a literal that has been determined to be &lt;code&gt;timestamp without time zone&lt;/code&gt;, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; 判断されたリテラルでは、PostgreSQLはタイムゾーンの指示を黙って無視します。つまり、結果の値は入力値の日付/時刻フィールドから導出され、タイムゾーンに合わせて調整されません。</target>
        </trans-unit>
        <trans-unit id="fe8c5382c7df4fd888e297e6990fce336207e731" translate="yes" xml:space="preserve">
          <source>In a priority-based synchronous replication, the standbys whose names appear earlier in the list will be used as synchronous standbys. Standbys listed after these will take over the role of synchronous standby if one of current ones should fail.</source>
          <target state="translated">優先度ベースの同期レプリケーションでは、リストの前に名前が表示されているスタンバイが同期スタンバイとして使用されます。これらの後にリストアップされたスタンバイは、現在のスタンバイのいずれかに障害が発生した場合、同期スタンバイの役割を引き継ぎます。</target>
        </trans-unit>
        <trans-unit id="6be13ad3386e50cb4bfa2ce22e78dd04cec9a6ab" translate="yes" xml:space="preserve">
          <source>In a quorum-based synchronous replication, all the standbys appearing in the list will be used as candidates for synchronous standbys. Even if one of them should fail, the other standbys will keep performing the role of candidates of synchronous standby.</source>
          <target state="translated">クォーラムベースの同期レプリケーションでは、リストに表示されているすべてのスタンバイが同期スタンバイの候補として使用されます。そのうちの1つに障害が発生した場合でも、他のスタンバイは同期スタンバイの候補としての役割を果たし続けます。</target>
        </trans-unit>
        <trans-unit id="a6cdb6331798b6847433d71683fa652dae3c0858" translate="yes" xml:space="preserve">
          <source>In a rule for &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; on a view, you can add a &lt;code&gt;RETURNING&lt;/code&gt; clause that emits the view's columns. This clause will be used to compute the outputs if the rule is triggered by an &lt;code&gt;INSERT RETURNING&lt;/code&gt;, &lt;code&gt;UPDATE RETURNING&lt;/code&gt;, or &lt;code&gt;DELETE RETURNING&lt;/code&gt; command respectively. When the rule is triggered by a command without &lt;code&gt;RETURNING&lt;/code&gt;, the rule's &lt;code&gt;RETURNING&lt;/code&gt; clause will be ignored. The current implementation allows only unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules to contain &lt;code&gt;RETURNING&lt;/code&gt;; furthermore there can be at most one &lt;code&gt;RETURNING&lt;/code&gt; clause among all the rules for the same event. (This ensures that there is only one candidate &lt;code&gt;RETURNING&lt;/code&gt; clause to be used to compute the results.) &lt;code&gt;RETURNING&lt;/code&gt; queries on the view will be rejected if there is no &lt;code&gt;RETURNING&lt;/code&gt; clause in any available rule.</source>
          <target state="translated">ビューに対する &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; のルールでは、ビューの列を出力する &lt;code&gt;RETURNING&lt;/code&gt; 句を追加できます。ルールが &lt;code&gt;INSERT RETURNING&lt;/code&gt; 、 &lt;code&gt;UPDATE RETURNING&lt;/code&gt; 、または &lt;code&gt;DELETE RETURNING&lt;/code&gt; コマンドによってそれぞれトリガーされた場合、この句を使用して出力が計算されます。ルールが &lt;code&gt;RETURNING&lt;/code&gt; なしのコマンドによってトリガーされた場合、ルールの &lt;code&gt;RETURNING&lt;/code&gt; 句は無視されます。現在の実装では、無条件の &lt;code&gt;INSTEAD&lt;/code&gt; ルールのみに &lt;code&gt;RETURNING&lt;/code&gt; を含めることができます。さらに、最大で1つの &lt;code&gt;RETURNING&lt;/code&gt; 同じイベントのすべてのルールの中で句。（これにより、結果の計算に使用される &lt;code&gt;RETURNING&lt;/code&gt; 句の候補が1つだけあることが保証されます。）使用可能なルールに &lt;code&gt;RETURNING&lt;/code&gt; 句がない場合、ビューに対する &lt;code&gt;RETURNING&lt;/code&gt; クエリは拒否されます。</target>
        </trans-unit>
        <trans-unit id="b30170def17c750dae562bb19e988c5bae9da5a7" translate="yes" xml:space="preserve">
          <source>In a simple join query, such as:</source>
          <target state="translated">のような単純な結合クエリでは</target>
        </trans-unit>
        <trans-unit id="3e1f4464d1af94cd74998edaeff888eee6d91174" translate="yes" xml:space="preserve">
          <source>In a standby server that exists primarily for high availability, it's best to set the delay parameters relatively short, so that the server cannot fall far behind the primary due to delays caused by standby queries. However, if the standby server is meant for executing long-running queries, then a high or even infinite delay value may be preferable. Keep in mind however that a long-running query could cause other sessions on the standby server to not see recent changes on the primary, if it delays application of WAL records.</source>
          <target state="translated">主に高可用性を目的としたスタンバイサーバでは、スタンバイクエリによる遅延のためにサーバがプライマリよりも大きく遅れないように、遅延パラメータを比較的短く設定するのが最善です。しかし、スタンバイサーバが長期的なクエリの実行を目的としている場合は、遅延パラメータを高く設定したり、無限に設定したりすることが望ましいかもしれません。ただし、長時間実行されるクエリによってWALレコードの適用が遅れると、待機サーバ上の他のセッションがプライマリ上の最近の変更を表示しなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0a9a7bd917eb1db2204b6427584eda8a4fd3adfe" translate="yes" xml:space="preserve">
          <source>In a table definition, default values are listed after the column data type. For example:</source>
          <target state="translated">テーブル定義では、デフォルト値は列データ型の後にリストされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ea0511eba225911c6d4bd1330fecc7bed6e9ecc3" translate="yes" xml:space="preserve">
          <source>In addition these settings can be preserved between reboots in the file &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. Doing that is highly recommended.</source>
          <target state="translated">さらに、これらの設定は、ファイル &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; のリブート間で保持できます。そうすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="096299b269c3119f5fd70cea143f131c4bf07844" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;postgresql.conf&lt;/code&gt;, a PostgreSQL data directory contains a file &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, which has the same format as &lt;code&gt;postgresql.conf&lt;/code&gt; but is intended to be edited automatically, not manually. This file holds settings provided through the &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command. This file is read whenever &lt;code&gt;postgresql.conf&lt;/code&gt; is, and its settings take effect in the same way. Settings in &lt;code&gt;postgresql.auto.conf&lt;/code&gt; override those in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">加え &lt;code&gt;postgresql.conf&lt;/code&gt; の、PostgreSQLのデータディレクトリにはファイル含ま &lt;code&gt;postgresql.auto.conf&lt;/code&gt; と同じフォーマットを有する、 &lt;code&gt;postgresql.conf&lt;/code&gt; のではなく、手動で、自動的に編集されることが意図されます。このファイルには、&lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt;コマンドによって提供される設定が保持されます。このファイルは &lt;code&gt;postgresql.conf&lt;/code&gt; が読み込まれるたびに読み込まれ、その設定は同じ方法で有効になります。設定 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; はのものより優先 &lt;code&gt;postgresql.conf&lt;/code&gt; のを。</target>
        </trans-unit>
        <trans-unit id="8b72ebbfc32b5c7dc9d476e5e61c36ae4f704bc0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;public&lt;/code&gt; and user-created schemas, each database contains a &lt;code&gt;pg_catalog&lt;/code&gt; schema, which contains the system tables and all the built-in data types, functions, and operators. &lt;code&gt;pg_catalog&lt;/code&gt; is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched &lt;em&gt;before&lt;/em&gt; searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place &lt;code&gt;pg_catalog&lt;/code&gt; at the end of your search path if you prefer to have user-defined names override built-in names.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; スキーマとユーザー作成スキーマに加えて、各データベースには、システムテーブルとすべての組み込みデータ型、関数、および演算子を含む &lt;code&gt;pg_catalog&lt;/code&gt; スキーマが含まれています。 &lt;code&gt;pg_catalog&lt;/code&gt; は、事実上常に検索パスの一部です。パスで明示的に名前が付けられていない場合は、パスのスキーマを検索&lt;em&gt;する前に&lt;/em&gt;暗黙的に検索されます。これにより、組み込み名が常に検索可能になります。ただし、ユーザー定義の名前で組み込みの名前を上書きする場合は、 &lt;code&gt;pg_catalog&lt;/code&gt; を検索パスの最後に明示的に配置できます。</target>
        </trans-unit>
        <trans-unit id="f70bc34b6f3d01fe499b2933dfc1efba4688427d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;standard_conforming_strings&lt;/code&gt;, the configuration parameters &lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warning&lt;/a&gt; and &lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quote&lt;/a&gt; govern treatment of backslashes in string constants.</source>
          <target state="translated">加え &lt;code&gt;standard_conforming_strings&lt;/code&gt; は、構成パラメータ&lt;a href=&quot;runtime-config-compatible#GUC-ESCAPE-STRING-WARNING&quot;&gt;escape_string_warningを&lt;/a&gt;と&lt;a href=&quot;runtime-config-compatible#GUC-BACKSLASH-QUOTE&quot;&gt;backslash_quoteにより、&lt;/a&gt;文字列定数内のバックスラッシュの治療を支配します。</target>
        </trans-unit>
        <trans-unit id="ca198320ff48380e299bcbd7319925ded5a95535" translate="yes" xml:space="preserve">
          <source>In addition to individual parameter settings, the &lt;code&gt;postgresql.conf&lt;/code&gt; file can contain &lt;em&gt;include directives&lt;/em&gt;, which specify another file to read and process as if it were inserted into the configuration file at this point. This feature allows a configuration file to be divided into physically separate parts. Include directives simply look like:</source>
          <target state="translated">個々のパラメータ設定に加えて、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルには&lt;em&gt;includeディレクティブ&lt;/em&gt;を含めることができます。この&lt;em&gt;ディレクティブは&lt;/em&gt;、この時点で構成ファイルに挿入されたかのように、読み取りおよび処理する別のファイルを指定します。この機能により、構成ファイルを物理的に別々の部分に分割できます。インクルードディレクティブは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e670e7bf52fa0455274db822ce4cd6907d528db9" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the &lt;code&gt;numeric&lt;/code&gt; type allows the special value &lt;code&gt;NaN&lt;/code&gt;, meaning &amp;ldquo;not-a-number&amp;rdquo;. Any operation on &lt;code&gt;NaN&lt;/code&gt; yields another &lt;code&gt;NaN&lt;/code&gt;. When writing this value as a constant in an SQL command, you must put quotes around it, for example &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt;. On input, the string &lt;code&gt;NaN&lt;/code&gt; is recognized in a case-insensitive manner.</source>
          <target state="translated">通常の数値に加えて、 &lt;code&gt;numeric&lt;/code&gt; タイプは、「非数」を意味する特別な値 &lt;code&gt;NaN&lt;/code&gt; を許可します。 &lt;code&gt;NaN&lt;/code&gt; に対する操作は、別の &lt;code&gt;NaN&lt;/code&gt; を生成します。 SQLコマンドでこの値を定数として書き込む場合は、値を引用符で囲む必要があります（例： &lt;code&gt;UPDATE table SET x = 'NaN'&lt;/code&gt; 。入力では、文字列 &lt;code&gt;NaN&lt;/code&gt; は大文字と小文字を区別しない方法で認識されます。</target>
        </trans-unit>
        <trans-unit id="e4bbcc684e36efbca1c2d0b6de3932866401bc9a" translate="yes" xml:space="preserve">
          <source>In addition to ordinary numeric values, the floating-point types have several special values:</source>
          <target state="translated">浮動小数点型には、通常の数値に加えて、いくつかの特殊な値があります。</target>
        </trans-unit>
        <trans-unit id="19311d87cac186ad5be7afccb28d88535be2bd00" translate="yes" xml:space="preserve">
          <source>In addition to setting global defaults or attaching overrides at the database or role level, you can pass settings to PostgreSQL via shell facilities. Both the server and libpq client library accept parameter values via the shell.</source>
          <target state="translated">グローバルデフォルトの設定やデータベースやロールレベルでのオーバーライドの添付に加えて、シェル機能を使ってPostgreSQLに設定を渡すことができます。サーバとlibpqクライアントライブラリの両方とも、シェル経由でパラメータ値を受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="a22166b5786a29ccaf8b6526c1e48730c5b76cde" translate="yes" xml:space="preserve">
          <source>In addition to simply finding the rows to be returned by a query, an index may be able to deliver them in a specific sorted order. This allows a query's &lt;code&gt;ORDER BY&lt;/code&gt; specification to be honored without a separate sorting step. Of the index types currently supported by PostgreSQL, only B-tree can produce sorted output &amp;mdash; the other index types return matching rows in an unspecified, implementation-dependent order.</source>
          <target state="translated">インデックスは、クエリによって返される行を単に見つけることに加えて、特定のソートされた順序でそれらを配信できる場合があります。これにより、クエリの &lt;code&gt;ORDER BY&lt;/code&gt; 仕様を、個別の並べ替え手順なしで使用できます。現在PostgreSQLでサポートされているインデックスタイプのうち、Bツリーのみがソートされた出力を生成できます。他のインデックスタイプは、指定された実装依存の順序で一致する行を返します。</target>
        </trans-unit>
        <trans-unit id="4ba1e6913eefc780040c670e81ceade68f518709" translate="yes" xml:space="preserve">
          <source>In addition to supporting ordinary index scans, some types of index may wish to support &lt;em&gt;parallel index scans&lt;/em&gt;, which allow multiple backends to cooperate in performing an index scan. The index access method should arrange things so that each cooperating process returns a subset of the tuples that would be performed by an ordinary, non-parallel index scan, but in such a way that the union of those subsets is equal to the set of tuples that would be returned by an ordinary, non-parallel index scan. Furthermore, while there need not be any global ordering of tuples returned by a parallel scan, the ordering of that subset of tuples returned within each cooperating backend must match the requested ordering. The following functions may be implemented to support parallel index scans:</source>
          <target state="translated">通常のインデックススキャンのサポートに加えて、一部のタイプのインデックスでは、複数のバックエンドが連携してインデックススキャンを実行できるようにする&lt;em&gt;並列インデックススキャンの&lt;/em&gt;サポートが必要になる場合があります。インデックスアクセスメソッドは、各協調プロセスが通常の非並列インデックススキャンによって実行されるタプルのサブセットを返すように、ただし、これらのサブセットの結合がタプルのセットと等しくなるように調整する必要があります。これは、通常の非並列インデックススキャンによって返されます。さらに、並列スキャンによって返されるタプルのグローバルな順序は必要ありませんが、各協調バックエンド内で返されるタプルのサブセットの順序は、要求された順序と一致する必要があります。並列インデックススキャンをサポートするために、次の関数を実装できます。</target>
        </trans-unit>
        <trans-unit id="2240e6efaaf6aaec400aa311d695b65a5cb9013d" translate="yes" xml:space="preserve">
          <source>In addition to table and row locks, page-level share/exclusive locks are used to control read/write access to table pages in the shared buffer pool. These locks are released immediately after a row is fetched or updated. Application developers normally need not be concerned with page-level locks, but they are mentioned here for completeness.</source>
          <target state="translated">テーブルと行のロックに加えて、ページレベルの共有/排他ロックは、共有バッファプール内のテーブルページへの読み書きアクセスを制御するために使用されます。これらのロックは、行がフェッチされたり更新されたりするとすぐに解除されます。アプリケーション開発者は通常、ページレベルのロックを気にする必要はありませんが、ここでは完全性を確保するために言及しています。</target>
        </trans-unit>
        <trans-unit id="87509ac7479eedd6c62071274770036abf56ee4c" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row.</source>
          <target state="translated">テーブルレベルのロックに加えて、行レベルのロックがあります。これらは、PostgreSQLによって自動的に使用されるコンテキストとともに以下にリストされています。行レベルのロック競合の完全な表については、&lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;表13.3&lt;/a&gt;を参照してください。トランザクションは、異なるサブトランザクションであっても、同じ行で競合するロックを保持できることに注意してください。それ以外は、2つのトランザクションが同じ行に競合するロックを保持することはできません。行レベルのロックはデータのクエリに影響しません。同じ行の&lt;em&gt;ライターとロッカー&lt;/em&gt;のみをブロックします。</target>
        </trans-unit>
        <trans-unit id="af43dbc6cfa4c0067d413cdf9c6cdab394d34e58" translate="yes" xml:space="preserve">
          <source>In addition to table-level locks, there are row-level locks, which are listed as below with the contexts in which they are used automatically by PostgreSQL. See &lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;Table 13.3&lt;/a&gt; for a complete table of row-level lock conflicts. Note that a transaction can hold conflicting locks on the same row, even in different subtransactions; but other than that, two transactions can never hold conflicting locks on the same row. Row-level locks do not affect data querying; they block only &lt;em&gt;writers and lockers&lt;/em&gt; to the same row. Row-level locks are released at transaction end or during savepoint rollback, just like table-level locks.</source>
          <target state="translated">テーブルレベルのロックに加えて、行レベルのロックがあります。これらは、PostgreSQLによって自動的に使用されるコンテキストとともに以下にリストされています。行レベルのロック競合の完全な表については、&lt;a href=&quot;explicit-locking#ROW-LOCK-COMPATIBILITY&quot;&gt;表13.3&lt;/a&gt;を参照してください。トランザクションは、異なるサブトランザクションであっても、同じ行で競合するロックを保持できることに注意してください。ただし、それ以外の場合、2つのトランザクションが同じ行で競合するロックを保持することはできません。行レベルのロックはデータクエリに影響しません。同じ行への&lt;em&gt;ライターとロッカー&lt;/em&gt;のみをブロックします。行レベルのロックは、テーブルレベルのロックと同様に、トランザクションの終了時またはセーブポイントのロールバック中に解放されます。</target>
        </trans-unit>
        <trans-unit id="eefa082a90a01551ee9f7be83fe0ecef6e330ce1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">PostgreSQLは、すでに述べた &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルに加えて、手動で編集された他の2つの構成ファイルを使用します。これらの構成ファイルは、クライアント認証を制御します（その使用については、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章&lt;/a&gt;で説明します）。デフォルトでは、3つの構成ファイルはすべてデータベースクラスタのデータディレクトリに保存されます。このセクションで説明するパラメーターを使用すると、構成ファイルを別の場所に配置できます。 （そうすることで、管理が容易になります。特に、構成ファイルが別々に保管されている場合は、構成ファイルが適切にバックアップされることを確認する方が簡単な場合があります。）</target>
        </trans-unit>
        <trans-unit id="c048077d9e3551a271c60d45220784829e1b676a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;postgresql.conf&lt;/code&gt; file already mentioned, PostgreSQL uses two other manually-edited configuration files, which control client authentication (their use is discussed in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;). By default, all three configuration files are stored in the database cluster's data directory. The parameters described in this section allow the configuration files to be placed elsewhere. (Doing so can ease administration. In particular it is often easier to ensure that the configuration files are properly backed-up when they are kept separate.)</source>
          <target state="translated">すでに述べた &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルに加えて、PostgreSQLはクライアント認証を制御する他の2つの手動編集構成ファイルを使用します（それらの使用については&lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;第20章&lt;/a&gt;で説明します）。デフォルトでは、3つの構成ファイルはすべてデータベースクラスターのデータディレクトリに保存されます。このセクションで説明するパラメーターを使用すると、構成ファイルを別の場所に配置できます。 （そうすることで、管理が容易になります。特に、構成ファイルが別々に保持されている場合は、構成ファイルが適切にバックアップされていることを確認する方が簡単な場合がよくあります。）</target>
        </trans-unit>
        <trans-unit id="06a5b24df3b5e27969bb36917a3a17ae8bb1189b" translate="yes" xml:space="preserve">
          <source>In addition to the SQL-standard &lt;a href=&quot;ddl-priv&quot;&gt;privilege system&lt;/a&gt; available through &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;, tables can have &lt;em&gt;row security policies&lt;/em&gt; that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as &lt;em&gt;Row-Level Security&lt;/em&gt;. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</source>
          <target state="translated">&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;を介して利用できるSQL標準の&lt;a href=&quot;ddl-priv&quot;&gt;特権システムに&lt;/a&gt;加えて、テーブルには、ユーザーごとに、通常のクエリによって返される行、またはデータ変更コマンドによって挿入、更新、または削除できる行を制限する&lt;em&gt;行セキュリティポリシー&lt;/em&gt;を設定できます。この機能は、&lt;em&gt;行レベルのセキュリティ&lt;/em&gt;とも呼ばれます。デフォルトでは、テーブルにはポリシーがありません。そのため、ユーザーがSQL特権システムに従ってテーブルへのアクセス権を持っている場合、テーブル内のすべての行がクエリまたは更新に等しく利用できます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d446f6389cb4793dfefdac41ed8ee8243d8cf0f3" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;cube&lt;/code&gt;. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column. Otherwise, this ordering is not of much practical use.</source>
          <target state="translated">上記の演算子に加えて、&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示す通常の比較演算子をタイプ &lt;code&gt;cube&lt;/code&gt; で使用できます。これらの演算子は最初に最初の座標を比較し、それらが等しい場合は2番目の座標を比較します。これらは主に &lt;code&gt;cube&lt;/code&gt; のbツリーインデックス演算子クラスをサポートするために存在します。これは、たとえば、次のUNIQUE制約が必要な場合に役立ちます。 &lt;code&gt;cube&lt;/code&gt; の列。それ以外の場合、この順序はあまり実用的ではありません。</target>
        </trans-unit>
        <trans-unit id="3a9f075e58ee1768924e20835361c077d43e9c97" translate="yes" xml:space="preserve">
          <source>In addition to the above operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for type &lt;code&gt;seg&lt;/code&gt;. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">上記の演算子に加えて、&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示す通常の比較演算子をタイプ &lt;code&gt;seg&lt;/code&gt; で使用できます。これらの演算子は、最初に（a）と（c）を比較し、これらが等しい場合は、（b）と（d）を比較します。これにより、ほとんどの場合、適切な並べ替えが可能になります。これは、このタイプでORDERBYを使用する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="58a68bf9280d646b1a85ebb074d2b6ecfecda3df" translate="yes" xml:space="preserve">
          <source>In addition to the format specifiers described above, the special sequence &lt;code&gt;%%&lt;/code&gt; may be used to output a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">上記のフォーマット指定子に加えて、特殊なシーケンス &lt;code&gt;%%&lt;/code&gt; を使用して、リテラル &lt;code&gt;%&lt;/code&gt; 文字を出力できます。</target>
        </trans-unit>
        <trans-unit id="8bfea922b7478af1fb30846a7ffdd145169e7fe7" translate="yes" xml:space="preserve">
          <source>In addition to the functions listed in this section, there are a number of functions related to the statistics system that also provide system information. See &lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;Section 27.2.2&lt;/a&gt; for more information.</source>
          <target state="translated">このセクションにリストされている関数に加えて、システム情報も提供する統計システムに関連するいくつかの関数があります。詳細は&lt;a href=&quot;monitoring-stats#MONITORING-STATS-VIEWS&quot;&gt;項27.2.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2dc53d9aa025a55feab0c728607a475dd6480573" translate="yes" xml:space="preserve">
          <source>In addition to the generic lookup mechanisms, there is a special convention that &lt;code&gt;PGNSP&lt;/code&gt; is replaced by the OID of the &lt;code&gt;pg_catalog&lt;/code&gt; schema, and &lt;code&gt;PGUID&lt;/code&gt; is replaced by the OID of the bootstrap superuser role. These usages are somewhat historical but so far there hasn't been a need to generalize them.</source>
          <target state="translated">一般的な検索メカニズムに加えて、 &lt;code&gt;PGNSP&lt;/code&gt; は &lt;code&gt;pg_catalog&lt;/code&gt; スキーマのOIDに置き換えられ、 &lt;code&gt;PGUID&lt;/code&gt; はブートストラップスーパーユーザーロールのOIDに置き換えられるという特別な規則があります。これらの使用法は多少歴史的ですが、これまではそれらを一般化する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="671caebf932d9cdddfa02cea4a21319996df3fc1" translate="yes" xml:space="preserve">
          <source>In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available.</source>
          <target state="translated">上述した主構文の他にも、特殊な形式や雑多な構文機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="cfdcb8c233fbe99bb0dea34235cb119f257b9a78" translate="yes" xml:space="preserve">
          <source>In addition to the method-specific options listed below, there is one method-independent authentication option &lt;code&gt;clientcert&lt;/code&gt;, which can be specified in any &lt;code&gt;hostssl&lt;/code&gt; record. This option can be set to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. Both options require the client to present a valid (trusted) SSL certificate, while &lt;code&gt;verify-full&lt;/code&gt; additionally enforces that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the username or an applicable mapping. This behavior is similar to the &lt;code&gt;cert&lt;/code&gt; authentication method (see &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt;) but enables pairing the verification of client certificates with any authentication method that supports &lt;code&gt;hostssl&lt;/code&gt; entries.</source>
          <target state="translated">以下にリストするメソッド固有のオプションに加えて、メソッドに依存しない認証オプション &lt;code&gt;clientcert&lt;/code&gt; が1つあります。これは、任意の &lt;code&gt;hostssl&lt;/code&gt; レコードで指定できます。このオプションは、 &lt;code&gt;verify-ca&lt;/code&gt; または &lt;code&gt;verify-full&lt;/code&gt; に設定できます。どちらのオプションでも、クライアントは有効な（信頼できる）SSL証明書を提示する必要がありますが、 &lt;code&gt;verify-full&lt;/code&gt; はさらに、証明書の &lt;code&gt;cn&lt;/code&gt; （共通名）がユーザー名または適用可能なマッピングと一致することを強制します。この動作は、 &lt;code&gt;cert&lt;/code&gt; 認証方法（&lt;a href=&quot;auth-cert&quot;&gt;セクション20.12を&lt;/a&gt;参照）に似ていますが、クライアント証明書の検証と、 &lt;code&gt;hostssl&lt;/code&gt; をサポートする任意の認証方法を組み合わせることができます。 エントリ。</target>
        </trans-unit>
        <trans-unit id="ddf91010c34fa3b26374dd73b3df519e9da0fd2a" translate="yes" xml:space="preserve">
          <source>In addition to the operators shown in the table, the ordinary B-tree comparison operators (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, etc) are defined for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">表に示されている演算子に加えて、通常のBツリー比較演算子（ &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&lt;/code&gt; など）が &lt;code&gt;tsvector&lt;/code&gt; 型と &lt;code&gt;tsquery&lt;/code&gt; 型に対して定義されています。これらはテキスト検索にはあまり役立ちませんが、たとえば、これらのタイプの列に一意のインデックスを構築できます。</target>
        </trans-unit>
        <trans-unit id="31c46db92025ad200f49ee2517827b67ca69ce01" translate="yes" xml:space="preserve">
          <source>In addition to the socket file itself, which is named &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; where &lt;code&gt;nnnn&lt;/code&gt; is the server's port number, an ordinary file named &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; will be created in each of the &lt;code&gt;unix_socket_directories&lt;/code&gt; directories. Neither file should ever be removed manually.</source>
          <target state="translated">命名されたソケットファイル自体に加えて、 &lt;code&gt;.s.PGSQL.nnnn&lt;/code&gt; &lt;code&gt;nnnn&lt;/code&gt; は名前の通常のファイルサーバのポート番号、ある &lt;code&gt;.s.PGSQL.nnnn.lock&lt;/code&gt; がそれぞれに作成されます &lt;code&gt;unix_socket_directories&lt;/code&gt; のディレクトリを。どちらのファイルも手動で削除しないでください。</target>
        </trans-unit>
        <trans-unit id="f961899526c4ec4b91a471972a05e3809476d8c4" translate="yes" xml:space="preserve">
          <source>In addition to the system catalogs, PostgreSQL provides a number of built-in views. Some system views provide convenient access to some commonly used queries on the system catalogs. Other views provide access to internal server state.</source>
          <target state="translated">システムカタログに加えて、PostgreSQLは多くの組み込みビューを提供しています。いくつかのシステムビューは、システムカタログ上で一般的に使用されるいくつかの問い合わせへの便利なアクセスを提供します。その他のビューは、サーバの内部状態へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="3e99de7dbe2b503398057fb045bf3c995d4ba6e3" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications of the form &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;STD&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;DST&lt;/code&gt;, where &lt;code&gt;STD&lt;/code&gt; is a zone abbreviation, &lt;code&gt;offset&lt;/code&gt; is a numeric offset in hours west from UTC, and &lt;code&gt;DST&lt;/code&gt; is an optional daylight-savings zone abbreviation, assumed to stand for one hour ahead of the given offset. For example, if &lt;code&gt;EST5EDT&lt;/code&gt; were not already a recognized zone name, it would be accepted and would be functionally equivalent to United States East Coast time. In this syntax, a zone abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;). When a daylight-savings zone abbreviation is present, it is assumed to be used according to the same daylight-savings transition rules used in the IANA time zone database's &lt;code&gt;posixrules&lt;/code&gt; entry. In a standard PostgreSQL installation, &lt;code&gt;posixrules&lt;/code&gt; is the same as &lt;code&gt;US/Eastern&lt;/code&gt;, so that POSIX-style time zone specifications follow USA daylight-savings rules. If needed, you can adjust this behavior by replacing the &lt;code&gt;posixrules&lt;/code&gt; file.</source>
          <target state="translated">タイムゾーン名と省略形に加えて、PostgreSQLは、 &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; または &lt;code&gt;STD&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;DST&lt;/code&gt; の形式のPOSIXスタイルのタイムゾーン指定を受け入れます。ここで、 &lt;code&gt;STD&lt;/code&gt; はゾーンの省略形、 &lt;code&gt;offset&lt;/code&gt; はUTCからの西の時間での数値オフセット、 &lt;code&gt;DST&lt;/code&gt; はオプションの夏時間ゾーンの省略形。指定されたオフセットより1時間進んでいると見なされます。たとえば、 &lt;code&gt;EST5EDT&lt;/code&gt; がまだ認識されていないゾーン名である場合、それは受け入れられ、米国東海岸の時間と機能的に同等になります。この構文では、ゾーンの省略形は、文字列、または山括弧（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; )で囲まれた任意の文字列にすることができます。）。サマータイムゾーンの省略形が存在する場合、IANAタイムゾーンデータベースの &lt;code&gt;posixrules&lt;/code&gt; エントリで使用されているのと同じサマータイム移行ルールに従って使用されると想定されます。標準のPostgreSQLインストールでは、 &lt;code&gt;posixrules&lt;/code&gt; は &lt;code&gt;US/Eastern&lt;/code&gt; と同じであるため、POSIXスタイルのタイムゾーン指定は米国の夏時間規則に従います。必要に応じて、 &lt;code&gt;posixrules&lt;/code&gt; ファイルを置き換えることにより、この動作を調整できます。</target>
        </trans-unit>
        <trans-unit id="fea3b58443a344cc0a50c8d3b3c320b181f8be81" translate="yes" xml:space="preserve">
          <source>In addition to the timezone names and abbreviations, PostgreSQL will accept POSIX-style time zone specifications, as described in &lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;Section B.5&lt;/a&gt;. This option is not normally preferable to using a named time zone, but it may be necessary if no suitable IANA time zone entry is available.</source>
          <target state="translated">&lt;a href=&quot;datetime-posix-timezone-specs&quot;&gt;セクションB.5で&lt;/a&gt;説明されているように、タイムゾーン名と略語に加えて、PostgreSQLはPOSIXスタイルのタイムゾーン仕様を受け入れます。このオプションは通常、名前付きタイムゾーンを使用するよりも好ましくありませんが、適切なIANAタイムゾーンエントリが利用できない場合に必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="5639f9b8e3c76507298cdef9442456212dc91a3a" translate="yes" xml:space="preserve">
          <source>In addition to the typical B-tree search operators, &lt;code&gt;btree_gist&lt;/code&gt; also provides index support for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (&amp;ldquo;not equals&amp;rdquo;). This may be useful in combination with an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt;, as described below.</source>
          <target state="translated">一般的なBツリー検索演算子に加えて、 &lt;code&gt;btree_gist&lt;/code&gt; は &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; （「等しくない」）のインデックスサポートも提供します。これは、以下で説明するように、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;除外制約&lt;/a&gt;と組み合わせると便利です。</target>
        </trans-unit>
        <trans-unit id="b7456acfa95fcaf383cf25fda8119cc53ab8322a" translate="yes" xml:space="preserve">
          <source>In addition to the usual (&lt;em&gt;tight&lt;/em&gt;) RE syntax, in which all characters are significant, there is an &lt;em&gt;expanded&lt;/em&gt; syntax, available by specifying the embedded &lt;code&gt;x&lt;/code&gt; option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a &lt;code&gt;#&lt;/code&gt; and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule:</source>
          <target state="translated">すべての文字が重要である通常の（&lt;em&gt;タイト&lt;/em&gt;）RE構文に加えて、埋め込まれた &lt;code&gt;x&lt;/code&gt; オプションを指定することで使用できる&lt;em&gt;拡張&lt;/em&gt;構文があります。拡張構文では、RE内の空白文字は無視され、 &lt;code&gt;#&lt;/code&gt; と次の改行の間（またはREの末尾）のすべての文字も無視されます。これにより、複雑なREをパラグラフ化してコメントを付けることができます。この基本ルールには3つの例外があります。</target>
        </trans-unit>
        <trans-unit id="da522f31f6ebf1b8a6e0efd3ead6600864945861" translate="yes" xml:space="preserve">
          <source>In addition to these facilities borrowed from &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; supports these pattern-matching metacharacters borrowed from POSIX regular expressions:</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; から借用したこれらの機能に加えて、 &lt;code&gt;SIMILAR TO&lt;/code&gt; は、POSIX正規表現から借用したこれらのパターンマッチングメタ文字をサポートします。</target>
        </trans-unit>
        <trans-unit id="d5ad168deb41cb8cd3104e11c297f4193822a79b" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined general-purpose or statistical aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as non-window aggregates and return a single row for the entire set.</source>
          <target state="translated">これらの関数に加えて、組み込み関数またはユーザー定義の汎用または統計集合（つまり、順序集合または仮集合集合ではない）をウィンドウ関数として使用できます。組み込み集計のリストについては、&lt;a href=&quot;functions-aggregate&quot;&gt;9.20項を&lt;/a&gt;参照してください。集計関数は、 &lt;code&gt;OVER&lt;/code&gt; 句が呼び出しに続く場合にのみウィンドウ関数として機能します。それ以外の場合は、ウィンドウ以外の集計として機能し、セット全体の単一行を返します。</target>
        </trans-unit>
        <trans-unit id="ac449e0956beab252b7444b739cfec2b77010587" translate="yes" xml:space="preserve">
          <source>In addition to these functions, any built-in or user-defined ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates) can be used as a window function; see &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for a list of the built-in aggregates. Aggregate functions act as window functions only when an &lt;code&gt;OVER&lt;/code&gt; clause follows the call; otherwise they act as plain aggregates and return a single row for the entire set.</source>
          <target state="translated">これらの関数に加えて、組み込みまたはユーザー定義の通常の集計（つまり、順序集合または仮想集合ではない集計）をウィンドウ関数として使用できます。組み込みアグリゲートのリストについては、&lt;a href=&quot;functions-aggregate&quot;&gt;セクション9.21&lt;/a&gt;を参照してください。集計関数は、 &lt;code&gt;OVER&lt;/code&gt; 句が呼び出しの後に続く場合にのみウィンドウ関数として機能します。それ以外の場合は、プレーンな集計として機能し、セット全体に対して単一の行を返します。</target>
        </trans-unit>
        <trans-unit id="3b254c4c7b10faf7e76791fc77c4b40ffb55a623" translate="yes" xml:space="preserve">
          <source>In addition to these functions, the SQL &lt;code&gt;OVERLAPS&lt;/code&gt; operator is supported:</source>
          <target state="translated">これらの関数に加えて、SQL &lt;code&gt;OVERLAPS&lt;/code&gt; 演算子がサポートされています。</target>
        </trans-unit>
        <trans-unit id="8ce6df37789f3f1d085846c8faae3d98a71b95bb" translate="yes" xml:space="preserve">
          <source>In addition to these specialized operators, the usual comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for types &lt;code&gt;tsvector&lt;/code&gt; and &lt;code&gt;tsquery&lt;/code&gt;. These are not very useful for text searching but allow, for example, unique indexes to be built on columns of these types.</source>
          <target state="translated">これらの特殊な演算子に加えて、&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示す通常の比較演算子は、タイプ &lt;code&gt;tsvector&lt;/code&gt; および &lt;code&gt;tsquery&lt;/code&gt; で使用できます。これらはテキスト検索にはあまり役立ちませんが、たとえば、これらのタイプの列に一意のインデックスを作成できます。</target>
        </trans-unit>
        <trans-unit id="918debfa135a3ee3b32c08e005bfe3898a987217" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">このリストに加えて、式として分類できるが、一般的な構文規則には従わない構成がいくつかあります。これらは通常、関数または演算子のセマンティクスを持ち、&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章の&lt;/a&gt;適切な場所で説明されています。例は、 &lt;code&gt;IS NULL&lt;/code&gt; 句です。</target>
        </trans-unit>
        <trans-unit id="81a1f6a58eced1ed99e15fcd136cfd9bbcd242dd" translate="yes" xml:space="preserve">
          <source>In addition to this list, there are a number of constructs that can be classified as an expression but do not follow any general syntax rules. These generally have the semantics of a function or operator and are explained in the appropriate location in &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;. An example is the &lt;code&gt;IS NULL&lt;/code&gt; clause.</source>
          <target state="translated">このリストに加えて、式として分類できるが、一般的な構文規則に従わない構造がいくつかあります。これらは通常、関数または演算子のセマンティクスを持ち、&lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;第9章の&lt;/a&gt;適切な場所で説明されています。例として、 &lt;code&gt;IS NULL&lt;/code&gt; 句があります。</target>
        </trans-unit>
        <trans-unit id="1eea807026cd270d625f43d7ed3f99bcbf28a0f1" translate="yes" xml:space="preserve">
          <source>In addition, B-tree and hash indexes can be created for table columns of range types. For these index types, basically the only useful range operation is equality. There is a B-tree sort ordering defined for range values, with corresponding &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators, but the ordering is rather arbitrary and not usually useful in the real world. Range types' B-tree and hash support is primarily meant to allow sorting and hashing internally in queries, rather than creation of actual indexes.</source>
          <target state="translated">さらに、範囲型のテーブル列に対してBツリーインデックスとハッシュインデックスを作成できます。これらのインデックスタイプの場合、基本的に唯一有効な範囲演算は等式です。範囲値に対して定義されたBツリーソート順序があり、対応する &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子がありますが、順序はかなり恣意的であり、通常、現実の世界では役に立ちません。範囲型のBツリーとハッシュのサポートは、実際のインデックスを作成するのではなく、クエリの内部で並べ替えとハッシュを許可することを主な目的としています。</target>
        </trans-unit>
        <trans-unit id="ec168afc08cf14d67db79d5a556441966649b178" translate="yes" xml:space="preserve">
          <source>In addition, GIN must have a way to sort the key values stored in the index. The operator class can define the sort ordering by specifying a comparison method:</source>
          <target state="translated">さらに、GINはインデックスに格納されているキー値をソートする方法を持っていなければなりません。演算子クラスは比較方法を指定することでソート順を定義することができます。</target>
        </trans-unit>
        <trans-unit id="9f602065328e166c6745869bc0a8f779ad09a07b" translate="yes" xml:space="preserve">
          <source>In addition, PostgreSQL provides the &lt;code&gt;text&lt;/code&gt; type, which stores strings of any length. Although the type &lt;code&gt;text&lt;/code&gt; is not in the SQL standard, several other SQL database management systems have it as well.</source>
          <target state="translated">さらに、PostgreSQLは、任意の長さの文字列を格納する &lt;code&gt;text&lt;/code&gt; タイプを提供します。タイプ &lt;code&gt;text&lt;/code&gt; はSQL標準にはありませんが、他のいくつかのSQLデータベース管理システムにもあります。</target>
        </trans-unit>
        <trans-unit id="17853e1fa32c480ecb510d4ac68c8ac2c772dace" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;cube&lt;/code&gt; GiST index can be used to find nearest neighbors using the metric operators &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; in &lt;code&gt;ORDER BY&lt;/code&gt; clauses. For example, the nearest neighbor of the 3-D point (0.5, 0.5, 0.5) could be found efficiently with:</source>
          <target state="translated">さらに、 &lt;code&gt;cube&lt;/code&gt; GiSTインデックスを使用して、 &lt;code&gt;ORDER BY&lt;/code&gt; 句でメトリック演算子 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;#&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; を使用して最近傍を検索できます。たとえば、3次元点（0.5、0.5、0.5）の最も近い近傍は、次のようにして効率的に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="cd5ace0daf0d94ba630977ad9ab486e9b148c9ae" translate="yes" xml:space="preserve">
          <source>In addition, any range type that is meant to be used with GiST or SP-GiST indexes should define a subtype difference, or &lt;code&gt;subtype_diff&lt;/code&gt;, function. (The index will still work without &lt;code&gt;subtype_diff&lt;/code&gt;, but it is likely to be considerably less efficient than if a difference function is provided.) The subtype difference function takes two input values of the subtype, and returns their difference (i.e., &lt;code&gt;X&lt;/code&gt; minus &lt;code&gt;Y&lt;/code&gt;) represented as a &lt;code&gt;float8&lt;/code&gt; value. In our example above, the function &lt;code&gt;float8mi&lt;/code&gt; that underlies the regular &lt;code&gt;float8&lt;/code&gt; minus operator can be used; but for any other subtype, some type conversion would be necessary. Some creative thought about how to represent differences as numbers might be needed, too. To the greatest extent possible, the &lt;code&gt;subtype_diff&lt;/code&gt; function should agree with the sort ordering implied by the selected operator class and collation; that is, its result should be positive whenever its first argument is greater than its second according to the sort ordering.</source>
          <target state="translated">さらに、GiSTまたはSP-GiSTインデックスで使用されることを意図した範囲タイプは、サブタイプの差、または &lt;code&gt;subtype_diff&lt;/code&gt; 関数を定義する必要があります。 （インデックスは &lt;code&gt;subtype_diff&lt;/code&gt; がなくても機能しますが、差分関数が提供されている場合よりも効率が大幅に低下する可能性があります。）サブタイプ差分関数は、サブタイプの2つの入力値を取り、それらの差分（つまり &lt;code&gt;X&lt;/code&gt; - &lt;code&gt;Y&lt;/code&gt; ）を返します。 &lt;code&gt;float8&lt;/code&gt; 値として表されます。この例では上記、機能 &lt;code&gt;float8mi&lt;/code&gt; 通常の根底に &lt;code&gt;float8&lt;/code&gt; 型をマイナス演算子を使用できます。ただし、他のサブタイプの場合、何らかのタイプ変換が必要になります。数値が必要になる場合があるので、違いを表現する方法についての創造的な考えも必要です。可能な限り、 &lt;code&gt;subtype_diff&lt;/code&gt; 関数は、選択した演算子クラスと照合順序が意味する並べ替え順序と一致する必要があります。つまり、ソート順序に従って、最初の引数が2番目の引数より大きい場合は常に、その結​​果は正になります。</target>
        </trans-unit>
        <trans-unit id="f89a62ed614652316ac7f29133e1961a27612ba6" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Casting an integer to &lt;code&gt;bit(n)&lt;/code&gt; copies the rightmost &lt;code&gt;n&lt;/code&gt; bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left. Some examples:</source>
          <target state="translated">さらに、型 &lt;code&gt;bit&lt;/code&gt; との間で整数値をキャストすることができます。整数を &lt;code&gt;bit(n)&lt;/code&gt; にキャストすると、右端の &lt;code&gt;n&lt;/code&gt; ビットがコピーされます。整数自体よりも広いビット文字列幅に整数をキャストすると、左側で符号拡張されます。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="64cf011fc0c858e7c59c2382a3c5f7cd4046f0f4" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to cast integral values to and from type &lt;code&gt;bit&lt;/code&gt;. Some examples:</source>
          <target state="translated">さらに、 &lt;code&gt;bit&lt;/code&gt; 型との間で整数値をキャストできます。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="326abf040e9ce0b0f36784412502b6466458ab9f" translate="yes" xml:space="preserve">
          <source>In addition, the following functions are available to produce analogous mappings of entire schemas or the entire current database:</source>
          <target state="translated">さらに、スキーマ全体または現在のデータベース全体の類似マッピングを生成するために、以下の関数が利用可能です。</target>
        </trans-unit>
        <trans-unit id="63461f5526d594ea86f45b63caca8ffcfa146455" translate="yes" xml:space="preserve">
          <source>In addition, the system must not be running in single-user mode. Since the entire database system is running in single process in this situation, no background workers will be available.</source>
          <target state="translated">さらに、システムをシングルユーザーモードで実行してはいけません。この状況では、データベースシステム全体が単一プロセスで実行されているため、バックグラウンドワーカーは利用できません。</target>
        </trans-unit>
        <trans-unit id="860432a001dab9d2b568ed0f1f81316664226bda" translate="yes" xml:space="preserve">
          <source>In addition, the system view &lt;a href=&quot;view-pg-settings&quot;&gt;&lt;code&gt;pg_settings&lt;/code&gt;&lt;/a&gt; can be used to view and change session-local values:</source>
          <target state="translated">さらに、システムビュー&lt;a href=&quot;view-pg-settings&quot;&gt; &lt;code&gt;pg_settings&lt;/code&gt; &lt;/a&gt;を使用して、セッションローカル値を表示および変更できます。</target>
        </trans-unit>
        <trans-unit id="22f9e194dfe6bf7349c8ee21bf8580964a36a952" translate="yes" xml:space="preserve">
          <source>In addition, triggers may be defined to fire for &lt;code&gt;TRUNCATE&lt;/code&gt;, though only &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt;.</source>
          <target state="translated">さらに、トリガーは、 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; のみですが、 &lt;code&gt;TRUNCATE&lt;/code&gt; に対して起動するように定義できます。</target>
        </trans-unit>
        <trans-unit id="d4414e8f828cfe6654891bf2913265775446349f" translate="yes" xml:space="preserve">
          <source>In addition, when the data in the referenced columns is changed, certain actions are performed on the data in this table's columns. The &lt;code&gt;ON DELETE&lt;/code&gt; clause specifies the action to perform when a referenced row in the referenced table is being deleted. Likewise, the &lt;code&gt;ON UPDATE&lt;/code&gt; clause specifies the action to perform when a referenced column in the referenced table is being updated to a new value. If the row is updated, but the referenced column is not actually changed, no action is done. Referential actions other than the &lt;code&gt;NO ACTION&lt;/code&gt; check cannot be deferred, even if the constraint is declared deferrable. There are the following possible actions for each clause:</source>
          <target state="translated">さらに、参照される列のデータが変更されると、このテーブルの列のデータに対して特定のアクションが実行されます。 &lt;code&gt;ON DELETE&lt;/code&gt; 句は、参照されるテーブルで参照される行が削除されているときに実行するアクションを指定します。同様に、 &lt;code&gt;ON UPDATE&lt;/code&gt; 句は、参照されるテーブルの参照される列が新しい値に更新されるときに実行するアクションを指定します。行が更新されても、参照された列が実際には変更されていない場合、アクションは実行されません。 &lt;code&gt;NO ACTION&lt;/code&gt; チェック以外の参照アクションは、制約が延期可能であると宣言されていても延期できません。各句には、次の可能なアクションがあります。</target>
        </trans-unit>
        <trans-unit id="1b40467991cf35c44406fccb1f30c153b6ab6d3c" translate="yes" xml:space="preserve">
          <source>In addition, you can define your own range types; see &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information.</source>
          <target state="translated">さらに、独自の範囲タイプを定義できます。詳細については、「&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b2973b0fbaf7ec1930d4939e2d5982623781db68" translate="yes" xml:space="preserve">
          <source>In addition, you can find rows where the array has all values equal to 10000 with:</source>
          <target state="translated">さらに、配列のすべての値が10000に等しい行を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="0f950ca6f038e5a1c55d020b4e0e3f34ce9c10d7" translate="yes" xml:space="preserve">
          <source>In all binary operations on differently-dimensioned cubes, I assume the lower-dimensional one to be a Cartesian projection, i. e., having zeroes in place of coordinates omitted in the string representation. The above examples are equivalent to:</source>
          <target state="translated">次元の異なる立方体に対するすべての2値演算において、低次元のものをデカルト投影、すなわち文字列表現で省略された座標の代わりにゼロを持つものとする。上記の例は次のように等価である。</target>
        </trans-unit>
        <trans-unit id="c1f9a66372442ec0201db0ed9f98b148d01d359a" translate="yes" xml:space="preserve">
          <source>In all but the simplest applications, there are various combinations of indexes that might be useful, and the database developer must make trade-offs to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it's better to create separate indexes and rely on the index-combination feature. For example, if your workload includes a mix of queries that sometimes involve only column &lt;code&gt;x&lt;/code&gt;, sometimes only column &lt;code&gt;y&lt;/code&gt;, and sometimes both columns, you might choose to create two separate indexes on &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, relying on index combination to process the queries that use both columns. You could also create a multicolumn index on &lt;code&gt;(x, y)&lt;/code&gt;. This index would typically be more efficient than index combination for queries involving both columns, but as discussed in &lt;a href=&quot;indexes-multicolumn&quot;&gt;Section 11.3&lt;/a&gt;, it would be almost useless for queries involving only &lt;code&gt;y&lt;/code&gt;, so it should not be the only index. A combination of the multicolumn index and a separate index on &lt;code&gt;y&lt;/code&gt; would serve reasonably well. For queries involving only &lt;code&gt;x&lt;/code&gt;, the multicolumn index could be used, though it would be larger and hence slower than an index on &lt;code&gt;x&lt;/code&gt; alone. The last alternative is to create all three indexes, but this is probably only reasonable if the table is searched much more often than it is updated and all three types of query are common. If one of the types of query is much less common than the others, you'd probably settle for creating just the two indexes that best match the common types.</source>
          <target state="translated">最も単純なアプリケーションを除いて、役立つインデックスにはさまざまな組み合わせがあり、データベース開発者はトレードオフを行って、提供するインデックスを決定する必要があります。複数列のインデックスが最適な場合もありますが、個別のインデックスを作成し、インデックスの組み合わせ機能を利用する方が良い場合もあります。たとえば、ワークロードに、列 &lt;code&gt;x&lt;/code&gt; のみ、場合によっては列 &lt;code&gt;y&lt;/code&gt; のみ、場合によっては両方の列が関係するクエリが混在する場合、インデックスの組み合わせに依存するクエリを処理するために、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; に2つの別々のインデックスを作成することを選択できます。両方の列を使用します。 &lt;code&gt;(x, y)&lt;/code&gt; 複数列のインデックスを作成することもできます。このインデックスは通常、両方の列を含むクエリのインデックスの組み合わせよりも効率的ですが、&lt;a href=&quot;indexes-multicolumn&quot;&gt;セクション11.3&lt;/a&gt;で説明したように、 &lt;code&gt;y&lt;/code&gt; のみを含むクエリではほとんど役に立たないため、唯一のインデックスではありません。複数列のインデックスと &lt;code&gt;y&lt;/code&gt; の個別のインデックスの組み合わせは、適度に機能します。 &lt;code&gt;x&lt;/code&gt; のみを含むクエリの場合、マルチカラムインデックスを使用できますが、 &lt;code&gt;x&lt;/code&gt; のインデックスよりも大きいため、低速です。一人で。最後の選択肢は3つすべてのインデックスを作成することですが、これはおそらく、テーブルが更新されるよりもはるかに頻繁に検索され、3つのタイプのクエリすべてが共通である場合にのみ妥当です。クエリのタイプの1つが他のタイプよりも一般的でない場合は、一般的なタイプに最も一致する2つのインデックスのみを作成することで解決するでしょう。</target>
        </trans-unit>
        <trans-unit id="56df2ff3801249dc12f58c24112c401131ecca16" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_depend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">すべての場合において、 &lt;code&gt;pg_depend&lt;/code&gt; エントリは、参照されるオブジェクトを依存オブジェクトも削除せずに削除できないことを示します。しかし、で識別されるいくつかのsubflavorsがある &lt;code&gt;deptype&lt;/code&gt; は：</target>
        </trans-unit>
        <trans-unit id="05533c0a7856fcfbbc14bb309ca83a1575bf0034" translate="yes" xml:space="preserve">
          <source>In all cases, a &lt;code&gt;pg_shdepend&lt;/code&gt; entry indicates that the referenced object cannot be dropped without also dropping the dependent object. However, there are several subflavors identified by &lt;code&gt;deptype&lt;/code&gt;:</source>
          <target state="translated">すべての場合において、 &lt;code&gt;pg_shdepend&lt;/code&gt; エントリは、依存オブジェクトも削除せずに参照オブジェクトを削除できないことを示します。しかし、で識別されるいくつかのsubflavorsがある &lt;code&gt;deptype&lt;/code&gt; は：</target>
        </trans-unit>
        <trans-unit id="dbd9abe4557bc81e394c2c9fabde17d6899807f9" translate="yes" xml:space="preserve">
          <source>In all cases, the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node will have exactly one child plan, which is the portion of the plan that will be executed in parallel. If the &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt; node is at the very top of the plan tree, then the entire query will execute in parallel. If it is somewhere else in the plan tree, then only the portion of the plan below it will run in parallel. In the example above, the query accesses only one table, so there is only one plan node other than the &lt;code&gt;Gather&lt;/code&gt; node itself; since that plan node is a child of the &lt;code&gt;Gather&lt;/code&gt; node, it will run in parallel.</source>
          <target state="translated">すべての場合において、 &lt;code&gt;Gather&lt;/code&gt; ノードまたは &lt;code&gt;Gather Merge&lt;/code&gt; ノードには、並列で実行されるプランの一部である子プランが1つだけあります。場合 &lt;code&gt;Gather&lt;/code&gt; や &lt;code&gt;Gather Merge&lt;/code&gt; ノードは、計画ツリーの最上部にある、その後、クエリ全体が並行して実行されます。プランツリーの別の場所にある場合は、その下のプランの部分のみが並列で実行されます。上記の例では、クエリは1つのテーブルのみにアクセスするため、 &lt;code&gt;Gather&lt;/code&gt; ノード自体以外の計画ノードは1つしかありません。その計画ノードは &lt;code&gt;Gather&lt;/code&gt; ノードの子であるため、並行して実行されます。</target>
        </trans-unit>
        <trans-unit id="d4cf1068a339ca5023c2d3ccdb75130df4a1abc8" translate="yes" xml:space="preserve">
          <source>In all cases, the UTC offset associated with a timestamp can be specified explicitly, using either a numeric UTC offset or a time zone abbreviation that corresponds to a fixed UTC offset. The rule just given applies only when it is necessary to infer a UTC offset for a time zone in which the offset varies.</source>
          <target state="translated">全ての場合において、タイムスタンプに関連付けられたUTCオフセットは、数値のUTCオフセットか、固定のUTCオフセットに対応するタイムゾーンの略語を使って、明示的に指定することができます。このルールは、オフセットが変化するタイムゾーンのUTCオフセットを推論する必要がある場合にのみ適用される。</target>
        </trans-unit>
        <trans-unit id="14ea16f2c03b44cd074521f1c44532d0da377b9a" translate="yes" xml:space="preserve">
          <source>In all cases, timezone names and abbreviations are recognized case-insensitively. (This is a change from PostgreSQL versions prior to 8.2, which were case-sensitive in some contexts but not others.)</source>
          <target state="translated">すべての場合において、タイムゾーン名と略語は大文字小文字を区別せずに認識されます。(これは、8.2以前のPostgreSQLのバージョンからの変更点です。)</target>
        </trans-unit>
        <trans-unit id="e488767cd28888258245f00283eb8b0744ce50a3" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">で &lt;code&gt;ADD FUNCTION&lt;/code&gt; 関数の入力データ型（複数可）とは異なる場合句、オペランド・データ・タイプ（S）関数は、支持体に意図されます。 Bツリー比較関数とハッシュ関数の場合、関数の入力データ型は常に正しいものであるため、 &lt;code&gt;op_type&lt;/code&gt; を指定する必要はありません。 Bツリーソートサポート関数およびGiST、SP-GiST、GIN演算子クラスのすべての関数の場合、関数で使用するオペランドのデータ型を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6fcb4d0603695c9c5c79f801a2ccda42d2230338" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;ADD FUNCTION&lt;/code&gt; clause, the operand data type(s) the function is intended to support, if different from the input data type(s) of the function. For B-tree comparison functions and hash functions it is not necessary to specify &lt;code&gt;op_type&lt;/code&gt; since the function's input data type(s) are always the correct ones to use. For B-tree sort support functions, B-Tree equal image functions, and all functions in GiST, SP-GiST and GIN operator classes, it is necessary to specify the operand data type(s) the function is to be used with.</source>
          <target state="translated">で &lt;code&gt;ADD FUNCTION&lt;/code&gt; 関数の入力データ型（複数可）とは異なる場合句、オペランド・データ・タイプ（S）関数は、支持体に意図されます。 Bツリー比較関数とハッシュ関数の場合、関数の入力データ型は常に正しいものであるため、 &lt;code&gt;op_type&lt;/code&gt; を指定する必要はありません。 Bツリーソートサポート関数、Bツリーイコールイメージ関数、およびGiST、SP-GiST、およびGIN演算子クラスのすべての関数の場合、関数を使用するオペランドデータ型を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe60e9f5f727af57aa7582cb64633b2e4aa0e193" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;AFTER&lt;/code&gt; trigger, the &lt;code&gt;WHEN&lt;/code&gt; condition is evaluated just after the row update occurs, and it determines whether an event is queued to fire the trigger at the end of statement. So when an &lt;code&gt;AFTER&lt;/code&gt; trigger's &lt;code&gt;WHEN&lt;/code&gt; condition does not return true, it is not necessary to queue an event nor to re-fetch the row at end of statement. This can result in significant speedups in statements that modify many rows, if the trigger only needs to be fired for a few of the rows.</source>
          <target state="translated">で &lt;code&gt;AFTER&lt;/code&gt; のトリガー、 &lt;code&gt;WHEN&lt;/code&gt; 条件は行の更新が発生した直後に評価し、そのイベントが文の終わりにトリガーを起動するためにキューイングされているか否かを判断します。したがって、 &lt;code&gt;AFTER&lt;/code&gt; トリガーの &lt;code&gt;WHEN&lt;/code&gt; 条件がtrueを返さない場合、イベントをキューに入れる必要も、ステートメントの最後に行を再フェッチする必要もありません。これにより、いくつかの行に対してのみトリガーを起動する必要がある場合、多くの行を変更するステートメントの速度が大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="9e75cc4e94385e5f68a8354a430b322f15ebd9bc" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, a user-specified value is only accepted if the &lt;code&gt;INSERT&lt;/code&gt; statement specifies &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt;. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, then the user-specified value takes precedence. See &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; for details. (In the &lt;code&gt;COPY&lt;/code&gt; command, user-specified values are always used regardless of this setting.)</source>
          <target state="translated">では &lt;code&gt;INSERT&lt;/code&gt; の場合、コマンド、 &lt;code&gt;ALWAYS&lt;/code&gt; が選択されている場合、ユーザーが指定した値のみが受け入れられ &lt;code&gt;INSERT&lt;/code&gt; 文指定は &lt;code&gt;OVERRIDING SYSTEM VALUE&lt;/code&gt; 。 &lt;code&gt;BY DEFAULT&lt;/code&gt; が選択されている場合、ユーザー指定の値が優先されます。詳細については、&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;を参照してください。 （ &lt;code&gt;COPY&lt;/code&gt; コマンドでは、この設定に関係なく、常にユーザー指定の値が使用されます。）</target>
        </trans-unit>
        <trans-unit id="14d94f7fbda5ba6b714c8d7012a6a4025037bb6e" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;INSERT&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the row as it was inserted. This is not so useful in trivial inserts, since it would just repeat the data provided by the client. But it can be very handy when relying on computed default values. For example, when using a &lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt;&lt;code&gt;serial&lt;/code&gt;&lt;/a&gt; column to provide unique identifiers, &lt;code&gt;RETURNING&lt;/code&gt; can return the ID assigned to a new row:</source>
          <target state="translated">で &lt;code&gt;INSERT&lt;/code&gt; 、に利用可能なデータ &lt;code&gt;RETURNING&lt;/code&gt; は、それが挿入されたように行です。これは、クライアントから提供されたデータを繰り返すだけなので、簡単な挿入ではあまり役に立ちません。ただし、計算されたデフォルト値に依存している場合は非常に便利です。たとえば、&lt;a href=&quot;datatype-numeric#DATATYPE-SERIAL&quot;&gt; &lt;code&gt;serial&lt;/code&gt; &lt;/a&gt;列を使用して一意の識別子を提供する場合、 &lt;code&gt;RETURNING&lt;/code&gt; は新しい行に割り当てられたIDを返すことができます。</target>
        </trans-unit>
        <trans-unit id="1b88536e851b3251cb15ede193475eddbb40caec" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. The operand data types can be omitted in the normal case where they are the same as the operator class's data type.</source>
          <target state="translated">で &lt;code&gt;OPERATOR&lt;/code&gt; の句、演算子のオペランド・データ・タイプ（複数可）、または &lt;code&gt;NONE&lt;/code&gt; 単項左または右単項演算子を意味します。オペランドのデータ型は、演算子クラスのデータ型と同じである通常の場合は省略できます。</target>
        </trans-unit>
        <trans-unit id="3136757e2f5b87e470c589e7ef9c299933261292" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;OPERATOR&lt;/code&gt; clause, the operand data type(s) of the operator, or &lt;code&gt;NONE&lt;/code&gt; to signify a left-unary or right-unary operator. Unlike the comparable syntax in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;, the operand data types must always be specified.</source>
          <target state="translated">で &lt;code&gt;OPERATOR&lt;/code&gt; の句、演算子のオペランド・データ・タイプ（複数可）、または &lt;code&gt;NONE&lt;/code&gt; 単項左または右単項演算子を意味します。 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; の同等の構文とは異なり、オペランドのデータ型は常に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ec2c43425fabe719ab28338af92c22c87b424e40" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt; command, if &lt;code&gt;ALWAYS&lt;/code&gt; is selected, any update of the column to any value other than &lt;code&gt;DEFAULT&lt;/code&gt; will be rejected. If &lt;code&gt;BY DEFAULT&lt;/code&gt; is selected, the column can be updated normally. (There is no &lt;code&gt;OVERRIDING&lt;/code&gt; clause for the &lt;code&gt;UPDATE&lt;/code&gt; command.)</source>
          <target state="translated">で &lt;code&gt;UPDATE&lt;/code&gt; の場合、コマンド、 &lt;code&gt;ALWAYS&lt;/code&gt; が選択されている以外の任意の値の列の任意の更新 &lt;code&gt;DEFAULT&lt;/code&gt; が拒否されます。場合は &lt;code&gt;BY DEFAULT&lt;/code&gt; 選択され、列は正常に更新することができます。（ &lt;code&gt;UPDATE&lt;/code&gt; コマンドには &lt;code&gt;OVERRIDING&lt;/code&gt; 句はありません。）</target>
        </trans-unit>
        <trans-unit id="4f4865a4556be6b18a0efd231e79cc53e7a18167" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;UPDATE&lt;/code&gt;, the data available to &lt;code&gt;RETURNING&lt;/code&gt; is the new content of the modified row. For example:</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; に利用可能なデータ &lt;code&gt;RETURNING&lt;/code&gt; は、変更された行の新しい内容です。例えば：</target>
        </trans-unit>
        <trans-unit id="a9d42b6946ae8752c916da7ef8c706a7f5db4d3a" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;amgetbitmap&lt;/code&gt; index scan, the access method does not keep an index pin on any of the returned tuples. Therefore it is only safe to use such scans with MVCC-compliant snapshots.</source>
          <target state="translated">で &lt;code&gt;amgetbitmap&lt;/code&gt; インデックス・スキャン、アクセスメソッドは返されるタプルのいずれかのインデックスピンを保持しません。したがって、MVCC準拠のスナップショットでこのようなスキャンを使用するのは安全です。</target>
        </trans-unit>
        <trans-unit id="565ae755fcf3f7ba63623b03ac7404b46ed4ecef" translate="yes" xml:space="preserve">
          <source>In an abstract sense, a running PostgreSQL system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL &lt;em&gt;segment files&lt;/em&gt;, which are normally 16MB apiece (although the segment size can be altered during initdb). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then &amp;ldquo;recycles&amp;rdquo; them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the last checkpoint are no longer of interest and can be recycled.</source>
          <target state="translated">抽象的に言えば、実行中のPostgreSQLシステムは、無制限に長いWALレコードのシーケンスを生成します。システムはこのシーケンスを物理的にWAL &lt;em&gt;セグメントファイル&lt;/em&gt;に&lt;em&gt;分割します&lt;/em&gt;。WAL &lt;em&gt;セグメントファイル&lt;/em&gt;は通常、それぞれ16MBです（ただし、セグメントサイズはinitdb中に変更できます）。セグメントファイルには、抽象的なWALシーケンスでの位置を反映する数値名が付けられます。 WALアーカイブを使用しない場合、システムは通常、いくつかのセグメントファイルを作成し、不要になったセグメントファイルの名前を大きいセグメント番号に変更することで、それらを「リサイクル」します。内容が最後のチェックポイントの前にあるセグメントファイルは、不要になり、リサイクルできると想定されています。</target>
        </trans-unit>
        <trans-unit id="f8ac0a1e1d2b4929b34c74cce531be5f95182b00" translate="yes" xml:space="preserve">
          <source>In an exclusive backup, &lt;code&gt;pg_stop_backup&lt;/code&gt; removes the label file and, if it exists, the &lt;code&gt;tablespace_map&lt;/code&gt; file created by &lt;code&gt;pg_start_backup&lt;/code&gt;. In a non-exclusive backup, the contents of the &lt;code&gt;backup_label&lt;/code&gt; and &lt;code&gt;tablespace_map&lt;/code&gt; are returned in the result of the function, and should be written to files in the backup (and not in the data directory). There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If false, the &lt;code&gt;pg_stop_backup&lt;/code&gt; will return immediately after the backup is completed without waiting for WAL to be archived. This behavior is only useful for backup software which independently monitors WAL archiving. Otherwise, WAL required to make the backup consistent might be missing and make the backup useless. When this parameter is set to true, &lt;code&gt;pg_stop_backup&lt;/code&gt; will wait for WAL to be archived when archiving is enabled; on the standby, this means that it will wait only when &lt;code&gt;archive_mode = always&lt;/code&gt;. If write activity on the primary is low, it may be useful to run &lt;code&gt;pg_switch_wal&lt;/code&gt; on the primary in order to trigger an immediate segment switch.</source>
          <target state="translated">排他バックアップでは、 &lt;code&gt;pg_stop_backup&lt;/code&gt; はラベルファイルを削除し、存在する場合は &lt;code&gt;pg_start_backup&lt;/code&gt; によって作成された &lt;code&gt;tablespace_map&lt;/code&gt; ファイルを削除します。非排他バックアップでは、関数の結果として &lt;code&gt;backup_label&lt;/code&gt; および &lt;code&gt;tablespace_map&lt;/code&gt; の内容が返され、バックアップ内の（データディレクトリではなく）ファイルに書き込む必要があります。 &lt;code&gt;boolean&lt;/code&gt; 型のオプションの2番目のパラメーターがあります。 falseの場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; WALがアーカイブされるのを待たずに、バックアップが完了するとすぐに戻ります。この動作は、WALアーカイブを個別に監視するバックアップソフトウェアでのみ役立ちます。そうしないと、バックアップを整合させるために必要なWALが欠落して、バックアップが役に立たなくなる可能性があります。このパラメーターがtrueに設定されている場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; はアーカイブが有効になっているときにWALがアーカイブされるのを待ちます。スタンバイでは、これは &lt;code&gt;archive_mode = always&lt;/code&gt; 場合にのみ待機することを意味します。プライマリでの書き込みアクティビティが少ない場合、すぐにセグメントの切り替えをトリガーするために、プライマリで &lt;code&gt;pg_switch_wal&lt;/code&gt; を実行すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="e7db342c2003b24a0078e3f7501e15f251fcabd3" translate="yes" xml:space="preserve">
          <source>In an index scan, the index access method is responsible for regurgitating the TIDs of all the tuples it has been told about that match the &lt;em&gt;scan keys&lt;/em&gt;. The access method is &lt;em&gt;not&lt;/em&gt; involved in actually fetching those tuples from the index's parent table, nor in determining whether they pass the scan's visibility test or other conditions.</source>
          <target state="translated">インデックススキャンでは、インデックスアクセスメソッドは、&lt;em&gt;スキャンキー&lt;/em&gt;と一致することが通知されたすべてのタプルのTIDを逆流させる責任があり&lt;em&gt;ます&lt;/em&gt;。アクセス方法は、インデックスの親テーブルからこれらのタプルを実際にフェッチすることにも、スキャンの可視性テストやその他の条件に合格するかを決定することにも関与して&lt;em&gt;いません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2aea61eca91fb7f3cae5718d047d4ef52faf5a35" translate="yes" xml:space="preserve">
          <source>In an internal page (not shown), the block number part of &lt;code&gt;ctid&lt;/code&gt; is a &amp;ldquo;downlink&amp;rdquo;, which is a block number of another page in the index itself. The offset part (the second number) of &lt;code&gt;ctid&lt;/code&gt; stores encoded information about the tuple, such as the number of columns present (suffix truncation may have removed unneeded suffix columns). Truncated columns are treated as having the value &amp;ldquo;minus infinity&amp;rdquo;.</source>
          <target state="translated">内部ページ（図示せず）では、 &lt;code&gt;ctid&lt;/code&gt; のブロック番号部分は「ダウンリンク」であり、これはインデックス自体の別のページのブロック番号です。 &lt;code&gt;ctid&lt;/code&gt; のオフセット部分（2番目の番号）には、存在する列の数など、タプルに関するエンコードされた情報が格納されます（サフィックスの切り捨てにより、不要なサフィックス列が削除された可能性があります）。切り捨てられた列は、「マイナス無限大」の値を持つものとして扱われます。</target>
        </trans-unit>
        <trans-unit id="f28fd11104e5b0da0e35b4fc535d8db587de4795" translate="yes" xml:space="preserve">
          <source>In an unmodified installation, the file &lt;code&gt;Default&lt;/code&gt; contains all the non-conflicting time zone abbreviations for most of the world. Additional files &lt;code&gt;Australia&lt;/code&gt; and &lt;code&gt;India&lt;/code&gt; are provided for those regions: these files first include the &lt;code&gt;Default&lt;/code&gt; file and then add or modify abbreviations as needed.</source>
          <target state="translated">変更されていないインストールでは、ファイル &lt;code&gt;Default&lt;/code&gt; に、ほとんどの世界で競合しないすべてのタイムゾーン省略形が含まれています。これらの地域には &lt;code&gt;Australia&lt;/code&gt; と &lt;code&gt;India&lt;/code&gt; 追加ファイルが用意されています。これらのファイルには最初に &lt;code&gt;Default&lt;/code&gt; ファイルが含まれており、必要に応じて略語を追加または変更します。</target>
        </trans-unit>
        <trans-unit id="f4e4ae3ee0675010eaef475c4b41d41082a6a6e7" translate="yes" xml:space="preserve">
          <source>In any case, if a recovery target is configured but the archive recovery ends before the target is reached, the server will shut down with a fatal error.</source>
          <target state="translated">いずれにしても、リカバリーターゲットを設定していても、ターゲットに到達する前にアーカイブリカバリーが終了してしまうと、致命的なエラーでサーバがシャットダウンしてしまいます。</target>
        </trans-unit>
        <trans-unit id="6faf2b1db0e643ecf8d471d0c7a2c045089265e3" translate="yes" xml:space="preserve">
          <source>In any case, the distance to the end of the frame is limited by the distance to the end of the partition, so that for rows near the partition ends the frame might contain fewer rows than elsewhere.</source>
          <target state="translated">いずれにしても、フレームの端までの距離は、パーティションの端までの距離によって制限されるので、パーティションの端に近い行については、フレームは他の場所よりも少ない行を含んでいるかもしれません。</target>
        </trans-unit>
        <trans-unit id="25a8baad62a92191ed853f5bfffb689d16144b1a" translate="yes" xml:space="preserve">
          <source>In archive recovery or standby mode, the server periodically performs &lt;em&gt;restartpoints&lt;/em&gt;, which are similar to checkpoints in normal operation: the server forces all its state to disk, updates the &lt;code&gt;pg_control&lt;/code&gt; file to indicate that the already-processed WAL data need not be scanned again, and then recycles any old log segment files in the &lt;code&gt;pg_wal&lt;/code&gt; directory. Restartpoints can't be performed more frequently than checkpoints in the master because restartpoints can only be performed at checkpoint records. A restartpoint is triggered when a checkpoint record is reached if at least &lt;code&gt;checkpoint_timeout&lt;/code&gt; seconds have passed since the last restartpoint, or if WAL size is about to exceed &lt;code&gt;max_wal_size&lt;/code&gt;. However, because of limitations on when a restartpoint can be performed, &lt;code&gt;max_wal_size&lt;/code&gt; is often exceeded during recovery, by up to one checkpoint cycle's worth of WAL. (&lt;code&gt;max_wal_size&lt;/code&gt; is never a hard limit anyway, so you should always leave plenty of headroom to avoid running out of disk space.)</source>
          <target state="translated">アーカイブリカバリまたはスタンバイモードでは、サーバーは定期的に&lt;em&gt;restartpointsを&lt;/em&gt;実行し&lt;em&gt;ます&lt;/em&gt;。これは通常の操作のチェックポイントと同様です。サーバーはすべての状態をディスクに &lt;code&gt;pg_control&lt;/code&gt; し、pg_controlファイルを更新して、すでに処理されたWALデータを再度スキャンする必要がないことを示します。次に、 &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリ内の古いログセグメントファイルをリサイクルします。リスタートポイントはチェックポイントレコードでのみ実行できるため、マスターのチェックポイントよりも頻繁にリスタートポイントを実行することはできません。最後のリスタート &lt;code&gt;checkpoint_timeout&lt;/code&gt; から少なくともcheckpoint_timeout秒が経過した場合、またはWALサイズが &lt;code&gt;max_wal_size&lt;/code&gt; を超えようとしている場合、チェックポイントレコードに到達すると、リスタートポイントがトリガーされます。ただし、リスタートポイントを実行できるタイミングに制限があるため、リカバリ中に &lt;code&gt;max_wal_size&lt;/code&gt; を超えることがよくあり、最大で1チェックポイントサイクルに相当するWALになります。（ &lt;code&gt;max_wal_size&lt;/code&gt; ても、max_wal_sizeがハードリミットになることはないため、ディスク領域が不足しないように、常に十分な余裕を残してください。）</target>
        </trans-unit>
        <trans-unit id="e983613b50e43472d70dff9ae2842d52027c35fe" translate="yes" xml:space="preserve">
          <source>In autocommit-off mode, you must explicitly abandon any failed transaction by entering &lt;code&gt;ABORT&lt;/code&gt; or &lt;code&gt;ROLLBACK&lt;/code&gt;. Also keep in mind that if you exit the session without committing, your work will be lost.</source>
          <target state="translated">自動コミットオフモードでは、 &lt;code&gt;ABORT&lt;/code&gt; または &lt;code&gt;ROLLBACK&lt;/code&gt; を入力して、失敗したトランザクションを明示的に破棄する必要があります。また、コミットせずにセッションを終了すると、作業が失われることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="b247fa1a8bf50d6b99053c3d0eeaa42c7ba06baa" translate="yes" xml:space="preserve">
          <source>In both cases, the current row of &lt;code&gt;inventory_item&lt;/code&gt; is passed to the function as a single composite-valued argument. Even though &lt;code&gt;.*&lt;/code&gt; does nothing in such cases, using it is good style, since it makes clear that a composite value is intended. In particular, the parser will consider &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;c.*&lt;/code&gt; to refer to a table name or alias, not to a column name, so that there is no ambiguity; whereas without &lt;code&gt;.*&lt;/code&gt;, it is not clear whether &lt;code&gt;c&lt;/code&gt; means a table name or a column name, and in fact the column-name interpretation will be preferred if there is a column named &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;inventory_item&lt;/code&gt; の現在の行は、単一の複合値引数として関数に渡されます。にもかかわらず &lt;code&gt;.*&lt;/code&gt; このような場合には何もしません、それは複合値が意図されていることを明らかにしているので、それを使用して、良いスタイルです。特に、パーサは検討する &lt;code&gt;c&lt;/code&gt; で &lt;code&gt;c.*&lt;/code&gt; テーブル名またはエイリアスに、いない列名を参照するために、あいまいがないのでこと。一方、 &lt;code&gt;.*&lt;/code&gt; がないと、 &lt;code&gt;c&lt;/code&gt; がテーブル名を意味するのか、列名を意味するのかは明確ではありません。実際、 &lt;code&gt;c&lt;/code&gt; という名前の列がある場合、列名の解釈が優先されます。</target>
        </trans-unit>
        <trans-unit id="f76739639f03e7f45a4a9297ea3a846e096a82c7" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、潜在的な問題とエラーメッセージについて、&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="5db2bd59ec0063d8b571ff86647485295dec81a2" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合、潜在的な問題とエラーメッセージの説明については、&lt;a href=&quot;sql-createdatabase&quot;&gt;CREATE DATABASE&lt;/a&gt;および&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="9ba5e7fcf43f6a46fa23c849e18652c98a11d276" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、潜在的な問題とエラーメッセージについて、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="6eaaf99e6c52738ae42a85a2ea51714fc0796916" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;および&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照して、潜在的な問題とエラーメッセージの説明を確認してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="94b403e1d0cfae4a4d06e5a4c5a48eb222d916e0" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照して、潜在的な問題とエラーメッセージの説明を確認してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="e7c380013a6560b8ccf88c49ec21236d61ed865e" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合は、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;で潜在的な問題とエラーメッセージの説明を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="a390aa69b768b09463593395199c846120ecabb8" translate="yes" xml:space="preserve">
          <source>In case of difficulty, see &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; for discussions of potential problems and error messages. The database server must be running at the targeted host. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">問題が発生した場合、潜在的な問題とエラーメッセージの説明については、&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;と&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を参照してください。データベースサーバーはターゲットホストで実行されている必要があります。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="2030ab1905e77cb31a87a361f54b214bc88ef0f8" translate="yes" xml:space="preserve">
          <source>In case of multiple inheritance, if one parent column is a generated column, then all parent columns must be generated columns and with the same expression.</source>
          <target state="translated">複数継承の場合、1つの親カラムが生成カラムである場合は、すべての親カラムが生成カラムであり、同じ式を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="93f46ad3e6977f8b4097e1a0c73d806eccff9805" translate="yes" xml:space="preserve">
          <source>In cases where you are accessing single rows randomly within a table, the actual order of the data in the table is unimportant. However, if you tend to access some data more than others, and there is an index that groups them together, you will benefit from using &lt;code&gt;CLUSTER&lt;/code&gt;. If you are requesting a range of indexed values from a table, or a single indexed value that has multiple rows that match, &lt;code&gt;CLUSTER&lt;/code&gt; will help because once the index identifies the table page for the first row that matches, all other rows that match are probably already on the same table page, and so you save disk accesses and speed up the query.</source>
          <target state="translated">テーブル内の単一の行にランダムにアクセスする場合、テーブル内のデータの実際の順序は重要ではありません。ただし、一部のデータに他のデータよりもアクセスする傾向があり、それらをグループ化するインデックスがある場合は、 &lt;code&gt;CLUSTER&lt;/code&gt; を使用するとメリットがあります。あなたがテーブルからインデックスの値の範囲やマッチ、という複数の行保有する1つのインデックスの値を要求している場合は &lt;code&gt;CLUSTER&lt;/code&gt; が役立つのインデックスは、最初の行のテーブルページを識別したらので試合、他のすべての行に一致はおそらくあることすでに同じテーブルページ上にあるため、ディスクアクセスを節約し、クエリを高速化できます。</target>
        </trans-unit>
        <trans-unit id="74c2cf6ed852f4b751c92fd9888cb548968dc00d" translate="yes" xml:space="preserve">
          <source>In certain cases using advisory locking methods, especially in queries involving explicit ordering and &lt;code&gt;LIMIT&lt;/code&gt; clauses, care must be taken to control the locks acquired because of the order in which SQL expressions are evaluated. For example:</source>
          <target state="translated">アドバイザリロックメソッドを使用する特定の場合、特に明示的な順序付けと &lt;code&gt;LIMIT&lt;/code&gt; 句を含むクエリでは、SQL式が評価される順序のため、取得されるロックを制御するように注意する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="a44c40b70d09319f4150cf272b9356e9931bfa6f" translate="yes" xml:space="preserve">
          <source>In combination with the &lt;code&gt;convert_from&lt;/code&gt; function, this function can be used to read a text file in a specified encoding and convert to the database's encoding:</source>
          <target state="translated">&lt;code&gt;convert_from&lt;/code&gt; 関数と組み合わせて、この関数を使用して、指定されたエンコーディングでテキストファイルを読み取り、データベースのエンコーディングに変換できます。</target>
        </trans-unit>
        <trans-unit id="c672c01926d5e97ed50c99a3d3247bc55643b756" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, &lt;code&gt;SELECT INTO&lt;/code&gt; does not allow to specify properties like a table's access method with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt;&lt;code&gt;USING method&lt;/code&gt;&lt;/a&gt; or the table's tablespace with &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt;&lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE AS&lt;/a&gt; if necessary. Therefore, the default table access method is chosen for the new table. See &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;CREATE TABLE AS&lt;/code&gt; とは対照的に、 &lt;code&gt;SELECT INTO&lt;/code&gt; では、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-METHOD&quot;&gt; &lt;code&gt;USING method&lt;/code&gt; &lt;/a&gt;使用したテーブルのアクセス方法や&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-TABLESPACE&quot;&gt; &lt;code&gt;TABLESPACE tablespace_name&lt;/code&gt; &lt;/a&gt;を使用したテーブルのテーブルスペースなどのプロパティを指定できません。必要に応じて&lt;a href=&quot;sql-createtableas&quot;&gt;CREATE TABLE ASを&lt;/a&gt;使用します。したがって、新しいテーブルにはデフォルトのテーブルアクセス方法が選択されます。詳細については、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLE-ACCESS-METHOD&quot;&gt;default_table_access_method&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="61279093682c79c9f5568d5da222628b6973c973" translate="yes" xml:space="preserve">
          <source>In contrast to a &lt;code&gt;setval&lt;/code&gt; call, a &lt;code&gt;RESTART&lt;/code&gt; operation on a sequence is transactional and blocks concurrent transactions from obtaining numbers from the same sequence. If that's not the desired mode of operation, &lt;code&gt;setval&lt;/code&gt; should be used.</source>
          <target state="translated">&lt;code&gt;setval&lt;/code&gt; 呼び出しとは対照的に、シーケンスの &lt;code&gt;RESTART&lt;/code&gt; 操作はトランザクション対応であり、同時トランザクションが同じシーケンスから番号を取得するのをブロックします。それが望ましい動作モードでない場合は、 &lt;code&gt;setval&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c8047479f58f45c6933e1e0d8cbc566b58e46ed0" translate="yes" xml:space="preserve">
          <source>In database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):</source>
          <target state="translated">データベースの専門用語では、PostgreSQLはクライアント/サーバモデルを使用します。PostgreSQLのセッションは以下の協力プロセス(プログラム)で構成されています。</target>
        </trans-unit>
        <trans-unit id="4ebcdbe0c3b4b06ac68e78641d8a5ee88bcf9f9b" translate="yes" xml:space="preserve">
          <source>In each round, no more than this many buffers will be written by the background writer. Setting this to zero disables background writing. (Note that checkpoints, which are managed by a separate, dedicated auxiliary process, are unaffected.) The default value is 100 buffers. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">各ラウンドでは、バックグラウンドライターによって書き込まれるバッファーはこれだけです。これをゼロに設定すると、バックグラウンド書き込みが無効になります。（独立した専用の補助プロセスによって管理されるチェックポイントは影響を受けないことに注意してください。）デフォルト値は100バッファーです。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ccd9c3c470f6cf3a148b1b2c45132bef7b97eb77" translate="yes" xml:space="preserve">
          <source>In either case the data to be encrypted is processed as follows:</source>
          <target state="translated">いずれの場合も、暗号化するデータは以下のように処理されます。</target>
        </trans-unit>
        <trans-unit id="306aa7e6b40f133245f13ca709da9e87be03e6ed" translate="yes" xml:space="preserve">
          <source>In either input mode, if you type a semicolon that is not just before or part of a command entry terminator, it is considered a command separator. When you do type a command entry terminator, the multiple statements you've entered will be executed as a single transaction.</source>
          <target state="translated">どちらの入力モードでも、コマンド入力のターミネータの直前または一部ではないセミコロンを入力した場合、それはコマンドの区切り文字とみなされます。コマンド入力のターミネータを入力した場合、入力した複数のステートメントは単一のトランザクションとして実行されます。</target>
        </trans-unit>
        <trans-unit id="52ebde367582fd620a8c225e745609692ba01e89" translate="yes" xml:space="preserve">
          <source>In either notation, parameters that have default values given in the function declaration need not be written in the call at all. But this is particularly useful in named notation, since any combination of parameters can be omitted; while in positional notation parameters can only be omitted from right to left.</source>
          <target state="translated">どちらの記法でも、関数宣言で与えられたデフォルト値を持つパラメータは、呼び出しの中に記述する必要はありません。しかし、これは名前付き記法の場合に特に便利です。 なぜなら、パラメータの任意の組み合わせを省略することができるからです。</target>
        </trans-unit>
        <trans-unit id="d831af293a1db32dece4f56906f01bbc94d110b4" translate="yes" xml:space="preserve">
          <source>In fact all the options that can be applied to a column description in &lt;code&gt;CREATE TABLE&lt;/code&gt; can be used here. Keep in mind however that the default value must satisfy the given constraints, or the &lt;code&gt;ADD&lt;/code&gt; will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly.</source>
          <target state="translated">実際、 &lt;code&gt;CREATE TABLE&lt;/code&gt; の列の説明に適用できるすべてのオプションをここで使用できます。ただし、デフォルト値は指定された制約を満たす必要があることに注意してください。そうしないと、 &lt;code&gt;ADD&lt;/code&gt; が失敗します。または、新しい列に正しく入力した後で、制約を追加することもできます（下記を参照）。</target>
        </trans-unit>
        <trans-unit id="783e59eb801df832fa056e21e4887ace28a8cded" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. The data directory must be initialized before being used, using the program &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt; which is installed with PostgreSQL.</source>
          <target state="translated">ファイルシステムの用語では、データベースクラスタは、すべてのデータが保存される単一のディレクトリです。これを&lt;em&gt;データディレクトリ&lt;/em&gt;または&lt;em&gt;データ領域&lt;/em&gt;と呼びます。データをどこに保存するかは完全にあなた次第です。 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; や &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; などの場所が一般的ですが、デフォルトはありません。データディレクトリは、PostgreSQLとともにインストールされるプログラム&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;を使用して、使用する前に初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="5989a14e7d9d5d4126144b5b3e9ac84c1a4ebc4b" translate="yes" xml:space="preserve">
          <source>In file system terms, a database cluster is a single directory under which all data will be stored. We call this the &lt;em&gt;data directory&lt;/em&gt; or &lt;em&gt;data area&lt;/em&gt;. It is completely up to you where you choose to store your data. There is no default, although locations such as &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; or &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; are popular. To initialize a database cluster, use the command &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;, which is installed with PostgreSQL. The desired file system location of your database cluster is indicated by the &lt;code&gt;-D&lt;/code&gt; option, for example:</source>
          <target state="translated">ファイルシステムの用語では、データベースクラスターは、すべてのデータが格納される単一のディレクトリです。これを&lt;em&gt;データディレクトリ&lt;/em&gt;または&lt;em&gt;データ領域&lt;/em&gt;と呼びます。データの保存場所は完全にあなた次第です。デフォルトはありませんが、 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; や &lt;code&gt;/var/lib/pgsql/data&lt;/code&gt; などの場所が一般的です。データベースクラスタを初期化するには、PostgreSQLとともにインストールされる&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;コマンドを使用します。データベースクラスターの目的のファイルシステムの場所は、 &lt;code&gt;-D&lt;/code&gt; オプションで指定します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="c6dec459ff41edebdbf286e5c7e7fa61bacc87ff" translate="yes" xml:space="preserve">
          <source>In general it is unsafe to access tables referenced in rebuild scripts until the rebuild scripts have run to completion; doing so could yield incorrect results or poor performance. Tables not referenced in rebuild scripts can be accessed immediately.</source>
          <target state="translated">一般的に、再構築スクリプトの実行が完了するまで、再構築スクリプトで参照されているテーブルにアクセスすることは安全ではありません。再構築スクリプトで参照されていないテーブルは、すぐにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d3d408ce8d9c6617962a7ddfab014057b11931d1" translate="yes" xml:space="preserve">
          <source>In general the array &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be subscripted is just a column reference or positional parameter. Also, multiple subscripts can be concatenated when the original array is multidimensional. For example:</source>
          <target state="translated">一般に、配列 &lt;code&gt;expression&lt;/code&gt; は括弧で囲む必要がありますが、添え字を付ける式が列参照または位置パラメーターだけの場合は括弧を省略できます。また、元の配列が多次元の場合、複数の添え字を連結できます。例えば：</target>
        </trans-unit>
        <trans-unit id="a233c74a23b1b0f950c13008071a2c4108299433" translate="yes" xml:space="preserve">
          <source>In general the row &lt;code&gt;expression&lt;/code&gt; must be parenthesized, but the parentheses can be omitted when the expression to be selected from is just a table reference or positional parameter. For example:</source>
          <target state="translated">一般に、行 &lt;code&gt;expression&lt;/code&gt; は括弧で囲む必要がありますが、選択する式がテーブル参照または位置パラメータだけの場合は括弧を省略できます。例えば：</target>
        </trans-unit>
        <trans-unit id="8c0b63d62e29b9c5a3a626356a3b517fe18e88f9" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;amcheck&lt;/code&gt; can only prove the presence of corruption; it cannot prove its absence.</source>
          <target state="translated">一般に、 &lt;code&gt;amcheck&lt;/code&gt; は破損の存在を証明することしかできません。それが存在しないことを証明することはできません。</target>
        </trans-unit>
        <trans-unit id="9e2bc9fd37cc10d6d4e2c0ce13c42250e4fbbee6" translate="yes" xml:space="preserve">
          <source>In general, a unique constraint is violated if there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are never considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable.</source>
          <target state="translated">一般的に、一意制約は、制約に含まれるすべての列の値が等しい表の行が1つ以上ある場合に違反します。しかし、この比較では、2つのヌル値が等しいとみなされることはありません。つまり、一意の制約が存在する場合でも、制約のある列の少なくとも1つにヌル値を含む重複した行を格納することが可能であることを意味します。この動作はSQL標準に準拠していますが、他のSQLデータベースではこのルールに従わない場合があると聞いています。そのため、移植性を目的としたアプリケーションを開発する際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="2348b93b2ef61033a339bed35843085ef2b630c2" translate="yes" xml:space="preserve">
          <source>In general, if a function is labeled as being safe when it is restricted or unsafe, or if it is labeled as being restricted when it is in fact unsafe, it may throw errors or produce wrong answers when used in a parallel query. C-language functions could in theory exhibit totally undefined behavior if mislabeled, since there is no way for the system to protect itself against arbitrary C code, but in most likely cases the result will be no worse than for any other function. If in doubt, it is probably best to label functions as &lt;code&gt;UNSAFE&lt;/code&gt;.</source>
          <target state="translated">一般に、制限付きまたは安全でないときに関数が安全であるとラベル付けされている場合、または実際に安全ではないときに関数が制限付きであるとラベル付けされている場合、並列クエリで使用すると、エラーがスローされるか、間違った回答が生成されることがあります。システムが任意のCコードからシステムを保護する方法がないため、C言語関数は理論上、誤ったラベルが付けられた場合、完全に未定義の動作を示す可能性がありますが、ほとんどの場合、他の関数よりも結果が悪くなることはありません。疑わしい場合は、関数に &lt;code&gt;UNSAFE&lt;/code&gt; のラベルを付けるのがおそらく最善です。</target>
        </trans-unit>
        <trans-unit id="a7edd5220f4e78ad60a17c1f93de6471bf8d5e1f" translate="yes" xml:space="preserve">
          <source>In general, if a table is grouped, columns that are not listed in &lt;code&gt;GROUP BY&lt;/code&gt; cannot be referenced except in aggregate expressions. An example with aggregate expressions is:</source>
          <target state="translated">一般に、テーブルがグループ化されている場合、 &lt;code&gt;GROUP BY&lt;/code&gt; にリストされていない列は、集計式以外では参照できません。集計式の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d1c3c9f3417fc6beedd0acdb2d294853319e6a73" translate="yes" xml:space="preserve">
          <source>In general, log shipping between servers running different major PostgreSQL release levels is not possible. It is the policy of the PostgreSQL Global Development Group not to make changes to disk formats during minor release upgrades, so it is likely that running different minor release levels on primary and standby servers will work successfully. However, no formal support for that is offered and you are advised to keep primary and standby servers at the same release level as much as possible. When updating to a new minor release, the safest policy is to update the standby servers first &amp;mdash; a new minor release is more likely to be able to read WAL files from a previous minor release than vice versa.</source>
          <target state="translated">一般に、PostgreSQLの主要なリリースレベルが異なるサーバー間でログ配布を行うことはできません。 PostgreSQLグローバル開発グループのポリシーは、マイナーリリースのアップグレード中にディスクフォーマットを変更しないことです。そのため、プライマリサーバーとスタンバイサーバーで異なるマイナーリリースレベルを実行しても問題なく動作する可能性があります。ただし、そのための正式なサポートは提供されていません。プライマリサーバーとスタンバイサーバーをできるだけ同じリリースレベルに保つことをお勧めします。新しいマイナーリリースに更新する場合、最も安全なポリシーは、最初にスタンバイサーバーを更新することです。新しいマイナーリリースは、以前のマイナーリリースからWALファイルを読み取ることができる可能性が高く、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="379f9f035821f16216f7bd05e1c59664a2c062ce" translate="yes" xml:space="preserve">
          <source>In general, most applications should prefer to store JSON data as &lt;code&gt;jsonb&lt;/code&gt;, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys.</source>
          <target state="translated">一般に、ほとんどのアプリケーションは、オブジェクトキーの順序付けに関する従来の前提など、特別なニーズがない限り、JSONデータを &lt;code&gt;jsonb&lt;/code&gt; として保存することを選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="b5f07f22b350f8a6e38078060fd0e008a551cf3e" translate="yes" xml:space="preserve">
          <source>In general, refer to the documentation of a specific module for the recommended way to load that module.</source>
          <target state="translated">一般的には、そのモジュールをロードするための推奨される方法については、特定のモジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ee2e987300579f41179429fff2833d7671d0a6f4" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they are useful for GIN testing and as a base for developing other GIN operator classes. Also, for queries that test both a GIN-indexable column and a B-tree-indexable column, it might be more efficient to create a multicolumn GIN index that uses one of these operator classes than to create two separate indexes that would have to be combined via bitmap ANDing.</source>
          <target state="translated">一般的に、これらの演算子クラスは同等の標準B-treeインデックスメソッドを上回る性能を発揮することはなく、標準B-treeコードの主要な機能である一意性を強制する機能を欠いています。しかし、これらの演算子クラスはGINのテストや、他のGIN演算子クラスを開発するためのベースとして有用です。また、GINインデックス可能なカラムとB-treeインデックス可能なカラムの両方をテストするクエリの場合、ビットマップANDで結合しなければならない2つの別々のインデックスを作成するよりも、これらの演算子クラスのいずれかを使用する複数カラムのGINインデックスを作成した方が効率的かもしれません。</target>
        </trans-unit>
        <trans-unit id="d2aa893456da765ab903af76d8c63108ae26c6ce" translate="yes" xml:space="preserve">
          <source>In general, these operator classes will not outperform the equivalent standard B-tree index methods, and they lack one major feature of the standard B-tree code: the ability to enforce uniqueness. However, they provide some other features that are not available with a B-tree index, as described below. Also, these operator classes are useful when a multicolumn GiST index is needed, wherein some of the columns are of data types that are only indexable with GiST but other columns are just simple data types. Lastly, these operator classes are useful for GiST testing and as a base for developing other GiST operator classes.</source>
          <target state="translated">一般的に、これらの演算子クラスは、同等の標準 B-tree インデックスメソッドを凌駕することはなく、標準 B-tree コードの主要な機能の 1 つである一意性を強制する機能を欠いています。しかし、以下で説明するように、これらの演算子クラスは、B-tree インデックスでは利用できない他の機能を提供します。また、これらの演算子クラスは、複数列のGiSTインデックスが必要な場合に便利です。最後に、これらの演算子クラスは、GiSTのテストや他のGiST演算子クラスを開発するためのベースとして有用です。</target>
        </trans-unit>
        <trans-unit id="050ef9f5f9df87b4cced8b5539a1b041812d5f42" translate="yes" xml:space="preserve">
          <source>In large tables, performance will be poor unless there is an index on the parent-key field.</source>
          <target state="translated">大きなテーブルでは、親キーフィールドにインデックスがないとパフォーマンスが悪くなります。</target>
        </trans-unit>
        <trans-unit id="4765e35412cfd4a863f019aa0033f2c20c5f4705" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. An advantage of these methods is that they bound the space requirement for &lt;code&gt;pg_wal&lt;/code&gt;; there is currently no way to do this using replication slots.</source>
          <target state="translated">レプリケーションスロットを使用する代わりに、&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;を使用するか、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;を使用してアーカイブにセグメントを格納することにより、古いWALセグメントが削除されないようにすることができます。ただし、これらの方法では、多くの場合、必要以上に多くのWALセグメントが保持されますが、複製スロットには、必要であることがわかっている数のセグメントのみが保持されます。これらのメソッドの利点は、それらが &lt;code&gt;pg_wal&lt;/code&gt; のスペース要件を制限することです。現在、複製スロットを使用してこれを行う方法はありません。</target>
        </trans-unit>
        <trans-unit id="29c3b7a7ac22ed19dd75a4554e5969e671d90aa0" translate="yes" xml:space="preserve">
          <source>In lieu of using replication slots, it is possible to prevent the removal of old WAL segments using &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;, or by storing the segments in an archive using &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. However, these methods often result in retaining more WAL segments than required, whereas replication slots retain only the number of segments known to be needed. On the other hand, replication slots can retain so many WAL segments that they fill up the space allocated for &lt;code&gt;pg_wal&lt;/code&gt;; &lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt; limits the size of WAL files retained by replication slots.</source>
          <target state="translated">レプリケーションスロットを使用する代わりに、&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;を使用して、または&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;を使用してアーカイブにセグメントを保存することにより、古いWALセグメントの削除を防ぐことができます。ただし、これらの方法では、多くの場合、必要以上のWALセグメントが保持されますが、レプリケーションスロットは、必要であることがわかっているセグメントの数だけを保持します。一方、レプリケーションスロットは、 &lt;code&gt;pg_wal&lt;/code&gt; に割り当てられたスペースを埋めるほど多くのWALセグメントを保持できます。&lt;a href=&quot;runtime-config-replication#GUC-MAX-SLOT-WAL-KEEP-SIZE&quot;&gt;max_slot_wal_keep_size&lt;/a&gt;は、レプリケーションスロットによって保持されるWALファイルのサイズを制限します。</target>
        </trans-unit>
        <trans-unit id="84baf4a0766c72c5ea2542a507182c8520343dbe" translate="yes" xml:space="preserve">
          <source>In macOS 10.2 and earlier, instead edit these commands in the file &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt;.</source>
          <target state="translated">macOS 10.2以前では、代わりに &lt;code&gt;/System/Library/StartupItems/SystemTuning/SystemTuning&lt;/code&gt; ファイルでこれらのコマンドを編集します。</target>
        </trans-unit>
        <trans-unit id="6203855ca7fcb59eaeec22abadb1b2a4087a8203" translate="yes" xml:space="preserve">
          <source>In many practical situations, this assumption is usually satisfied; for example, there might be a GUI in the application that only allows selecting compatible city and ZIP code values to use in a query. But if that's not the case, functional dependencies may not be a viable option.</source>
          <target state="translated">多くの実用的な状況では、この仮定は通常満たされています。例えば、アプリケーションの中には、クエリで使用するために互換性のある都市や郵便番号の値のみを選択できるGUIがあるかもしれません。しかし、そうでない場合、機能的な依存関係は実行可能なオプションではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="4b1075485e703bf16e8ab73df82eb829ce78c033" translate="yes" xml:space="preserve">
          <source>In many situations, turning off &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; for noncritical transactions can provide much of the potential performance benefit of turning off &lt;code&gt;fsync&lt;/code&gt;, without the attendant risks of data corruption.</source>
          <target state="translated">多くの状況で、重要でないトランザクションの&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;Synchronous_commit&lt;/a&gt;をオフにすると、データが破損するリスクを伴うことなく、 &lt;code&gt;fsync&lt;/code&gt; をオフにした場合のパフォーマンス上の利点の多くが得られます。</target>
        </trans-unit>
        <trans-unit id="194f1c0784b754fb38f29c78dc946b25933f09f6" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;regexp_matches()&lt;/code&gt; should be used with the &lt;code&gt;g&lt;/code&gt; flag, since if you only want the first match, it's easier and more efficient to use &lt;code&gt;regexp_match()&lt;/code&gt;. However, &lt;code&gt;regexp_match()&lt;/code&gt; only exists in PostgreSQL version 10 and up. When working in older versions, a common trick is to place a &lt;code&gt;regexp_matches()&lt;/code&gt; call in a sub-select, for example:</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;regexp_matches()&lt;/code&gt; は &lt;code&gt;g&lt;/code&gt; フラグと一緒に使用する必要があります。最初の一致のみが必要な場合は、 &lt;code&gt;regexp_match()&lt;/code&gt; を使用する方が簡単で効率的です。ただし、 &lt;code&gt;regexp_match()&lt;/code&gt; はPostgreSQLバージョン10以降にのみ存在します。古いバージョンで作業する場合の一般的なトリックは、 &lt;code&gt;regexp_matches()&lt;/code&gt; 呼び出しを副選択に配置することです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="d60a20da168de2a263b74b28aa44a9c52da8b217" translate="yes" xml:space="preserve">
          <source>In most cases a &lt;code&gt;DELETE&lt;/code&gt; command also needs to read data from columns in the relation that it is deleting from (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;DELETE&lt;/code&gt; policies. Thus the user must have access to the row(s) being deleted through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to delete the row(s) via a &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;DELETE&lt;/code&gt; コマンドは、削除元のリレーション（たとえば、 &lt;code&gt;WHERE&lt;/code&gt; 句または &lt;code&gt;RETURNING&lt;/code&gt; 句）の列からデータを読み取る必要もあります。この場合、リレーションに対して &lt;code&gt;SELECT&lt;/code&gt; 権限も必要であり、 &lt;code&gt;DELETE&lt;/code&gt; ポリシーに加えて適切な &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーが適用されます。したがって、ユーザーは、 &lt;code&gt;DELETE&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーを介して行を削除する権限が付与されていることに加えて、 &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーを介して削除される行にアクセスできる必要があります。</target>
        </trans-unit>
        <trans-unit id="82c5561a0275adcd2a2a51ebef8a40a5f37109da" translate="yes" xml:space="preserve">
          <source>In most database designs the majority of columns should be marked not null.</source>
          <target state="translated">ほとんどのデータベース設計では、大部分のカラムはNULLではないとマークされるべきです。</target>
        </trans-unit>
        <trans-unit id="158c99420a44bba9aff343cb614d9616cbae7fa4" translate="yes" xml:space="preserve">
          <source>In most implementations of the &amp;ldquo;not-a-number&amp;rdquo; concept, &lt;code&gt;NaN&lt;/code&gt; is not considered equal to any other numeric value (including &lt;code&gt;NaN&lt;/code&gt;). In order to allow &lt;code&gt;numeric&lt;/code&gt; values to be sorted and used in tree-based indexes, PostgreSQL treats &lt;code&gt;NaN&lt;/code&gt; values as equal, and greater than all non-&lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">「非数」の概念のほとんどの実装では、 &lt;code&gt;NaN&lt;/code&gt; は他の数値（ &lt;code&gt;NaN&lt;/code&gt; を含む）と等しいとは見なされません。 &lt;code&gt;numeric&lt;/code&gt; をソートしてツリーベースのインデックスで使用できるようにするために、PostgreSQLは &lt;code&gt;NaN&lt;/code&gt; 値をすべての非 &lt;code&gt;NaN&lt;/code&gt; 値よりも大きく、等しいものとして扱います。</target>
        </trans-unit>
        <trans-unit id="cd61e39655eeef5b9bf240531ec53c538d27ed8e" translate="yes" xml:space="preserve">
          <source>In named notation, each argument's name is specified using &lt;code&gt;=&amp;gt;&lt;/code&gt; to separate it from the argument expression. For example:</source>
          <target state="translated">名前付き表記では、各引数の名前は &lt;code&gt;=&amp;gt;&lt;/code&gt; を使用して指定され、引数式と区別されます。例えば：</target>
        </trans-unit>
        <trans-unit id="3a49a039bda09447cda5b6ba6fb7b5f06a1662cb" translate="yes" xml:space="preserve">
          <source>In nearly all cases, you'll need some options to make a useful test. The most important options are &lt;code&gt;-c&lt;/code&gt; (number of clients), &lt;code&gt;-t&lt;/code&gt; (number of transactions), &lt;code&gt;-T&lt;/code&gt; (time limit), and &lt;code&gt;-f&lt;/code&gt; (specify a custom script file). See below for a full list.</source>
          <target state="translated">ほとんどすべての場合、有用なテストを行うにはいくつかのオプションが必要になります。最も重要なオプションは、 &lt;code&gt;-c&lt;/code&gt; （クライアント数）、- &lt;code&gt;-t&lt;/code&gt; （トランザクション数）、- &lt;code&gt;-T&lt;/code&gt; （時間制限）、および &lt;code&gt;-f&lt;/code&gt; （カスタムスクリプトファイルを指定）です。完全なリストについては、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="5a8686c8bc573efc7c7f314b50a2faaa5e4253e1" translate="yes" xml:space="preserve">
          <source>In non-fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates matches for the given &lt;code&gt;query&lt;/code&gt; and chooses a single one to display, preferring matches that have more query words within the allowed headline length. In fragment-based headline generation, &lt;code&gt;ts_headline&lt;/code&gt; locates the query matches and splits each match into &amp;ldquo;fragments&amp;rdquo; of no more than &lt;code&gt;MaxWords&lt;/code&gt; words each, preferring fragments with more query words, and when possible &amp;ldquo;stretching&amp;rdquo; fragments to include surrounding words. The fragment-based mode is thus more useful when the query matches span large sections of the document, or when it's desirable to display multiple matches. In either mode, if no query matches can be identified, then a single fragment of the first &lt;code&gt;MinWords&lt;/code&gt; words in the document will be displayed.</source>
          <target state="translated">非フラグメントベースのヘッドライン生成では、 &lt;code&gt;ts_headline&lt;/code&gt; は指定された &lt;code&gt;query&lt;/code&gt; 一致するものを見つけ、表示するものを1つ選択して、許可されたヘッドラインの長さ内により多くのクエリワードを持つ一致を優先します。フラグメントベースのヘッドライン生成では、 &lt;code&gt;ts_headline&lt;/code&gt; はクエリの一致を検索し、各一致をそれぞれ &lt;code&gt;MaxWords&lt;/code&gt; ワード以下の「フラグメント」に分割し、クエリワードの多いフラグメントを優先し、可能な場合はフラグメントを「ストレッチ」して周囲のワードを含めます。したがって、フラグメントベースモードは、クエリの一致がドキュメントの大きなセクションにまたがる場合、または複数の一致を表示することが望ましい場合に役立ちます。どちらのモードでも、一致するクエリが識別できない場合は、最初のフラグメントの1つが &lt;code&gt;MinWords&lt;/code&gt; ドキュメント内のMinWordsの単語が表示されます。</target>
        </trans-unit>
        <trans-unit id="fac5d16972792c7bd805065c712c623a51151c8c" translate="yes" xml:space="preserve">
          <source>In none of these cases is there any provision for schema-qualification; all objects created during bootstrap are expected to be in the &lt;code&gt;pg_catalog&lt;/code&gt; schema.</source>
          <target state="translated">これらのいずれの場合も、スキーマ修飾の規定はありません。ブートストラップ中に作成されたすべてのオブジェクトは、 &lt;code&gt;pg_catalog&lt;/code&gt; スキーマにあることが期待されます。</target>
        </trans-unit>
        <trans-unit id="f2409be7cd8d4efc7e947e3b436a132ef0c47174" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user &amp;mdash; they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">あなたが発行した場合、通常の（非回復）モードでは、 &lt;code&gt;DROP USER&lt;/code&gt; または &lt;code&gt;DROP ROLE&lt;/code&gt; のを、そのユーザーがまだ接続されている間にログイン機能と役割のために何も接続されているユーザーに起こりません-彼らが接続されたまま。ただし、ユーザーは再接続できません。この動作はリカバリにも適用されるため、プライマリの &lt;code&gt;DROP USER&lt;/code&gt; はスタンバイのそのユーザーを切断しません。</target>
        </trans-unit>
        <trans-unit id="909fab97f09523721a77cc835152b274f406d63c" translate="yes" xml:space="preserve">
          <source>In normal (non-recovery) mode, if you issue &lt;code&gt;DROP USER&lt;/code&gt; or &lt;code&gt;DROP ROLE&lt;/code&gt; for a role with login capability while that user is still connected then nothing happens to the connected user - they remain connected. The user cannot reconnect however. This behavior applies in recovery also, so a &lt;code&gt;DROP USER&lt;/code&gt; on the primary does not disconnect that user on the standby.</source>
          <target state="translated">通常（非リカバリー）モードでは、そのユーザーがまだ接続しているときに、ログイン機能を持つ &lt;code&gt;DROP ROLE&lt;/code&gt; に対して &lt;code&gt;DROP USER&lt;/code&gt; またはDROP ROLEを発行すると、接続しているユーザーには何も起こりません-接続されたままです。ただし、ユーザーは再接続できません。この動作はリカバリにも適用されるため、プライマリの &lt;code&gt;DROP USER&lt;/code&gt; はスタンバイのそのユーザーを切断しません。</target>
        </trans-unit>
        <trans-unit id="b1729ae1f718e0b63bffb08ae3066f0eb0e77ca2" translate="yes" xml:space="preserve">
          <source>In normal operation, &amp;ldquo;read-only&amp;rdquo; transactions are allowed to use &lt;code&gt;LISTEN&lt;/code&gt; and &lt;code&gt;NOTIFY&lt;/code&gt;, so Hot Standby sessions operate under slightly tighter restrictions than ordinary read-only sessions. It is possible that some of these restrictions might be loosened in a future release.</source>
          <target state="translated">通常の操作では、「読み取り専用」トランザクションは &lt;code&gt;LISTEN&lt;/code&gt; および &lt;code&gt;NOTIFY&lt;/code&gt; を使用できます。そのため、ホットスタンバイセッションは、通常の読み取り専用セッションよりもわずかに厳しい制限の下で動作します。これらの制限の一部は、将来のリリースで緩和される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d3560745e5e4a4c446630441931abacb2898af6f" translate="yes" xml:space="preserve">
          <source>In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string &lt;code&gt;=&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">通常の操作では、psqlは、psqlが現在接続されているデータベースの名前と、その後に文字列 &lt;code&gt;=&amp;gt;&lt;/code&gt; が続くプロンプトを提供します。例えば：</target>
        </trans-unit>
        <trans-unit id="cd286c2214fff2e0be18b3ddfb09dfdd0278ddbf" translate="yes" xml:space="preserve">
          <source>In older OpenBSD versions, you will need to build a custom kernel to change the IPC parameters. Make sure that the options &lt;code&gt;SYSVSHM&lt;/code&gt; and &lt;code&gt;SYSVSEM&lt;/code&gt; are enabled, too. (They are by default.) The following shows an example of how to set the various parameters in the kernel configuration file:</source>
          <target state="translated">古いOpenBSDバージョンでは、IPCパラメータを変更するためにカスタムカーネルを構築する必要があります。オプション &lt;code&gt;SYSVSHM&lt;/code&gt; および &lt;code&gt;SYSVSEM&lt;/code&gt; も有効になっていることを確認してください。（これらはデフォルトです。）以下は、カーネル構成ファイルでさまざまなパラメーターを設定する方法の例を示しています。</target>
        </trans-unit>
        <trans-unit id="43d5f374be9ab2b9f725372748b33884cde122b3" translate="yes" xml:space="preserve">
          <source>In older macOS versions, you will need to reboot to have changes in the shared memory parameters take effect. As of 10.5 it is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">古いバージョンのmacOSでは、共有メモリパラメータの変更を有効にするには、再起動する必要があります。10.5以降、sysctlを使用して、 &lt;code&gt;SHMMNI&lt;/code&gt; を除くすべてをその場で変更することができます。ただし、再起動後も値が保持されるように、/ &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; を介して優先値を設定するのが依然として最善です。</target>
        </trans-unit>
        <trans-unit id="882a1a9442374dfd65845651f73b92d43f44074e" translate="yes" xml:space="preserve">
          <source>In order for the tunnel setup to succeed you must be allowed to connect via &lt;code&gt;ssh&lt;/code&gt; as &lt;code&gt;joe@foo.com&lt;/code&gt;, just as if you had attempted to use &lt;code&gt;ssh&lt;/code&gt; to create a terminal session.</source>
          <target state="translated">トンネルのセットアップを成功させるには、 &lt;code&gt;ssh&lt;/code&gt; を使用してターミナルセッションを作成しようとした場合と同じように、 &lt;code&gt;ssh&lt;/code&gt; を介して &lt;code&gt;joe@foo.com&lt;/code&gt; として接続できる必要があります。</target>
        </trans-unit>
        <trans-unit id="d646fc6f64023e87f7f5096950ae7ce2f2e80423" translate="yes" xml:space="preserve">
          <source>In order to access any schema object, &lt;code&gt;db_schema:search&lt;/code&gt; permission is required on the containing schema. When an object is referenced without schema qualification, schemas on which this permission is not present will not be searched (just as if the user did not have &lt;code&gt;USAGE&lt;/code&gt; privilege on the schema). If an explicit schema qualification is present, an error will occur if the user does not have the requisite permission on the named schema.</source>
          <target state="translated">スキーマオブジェクトにアクセスするには、含まれているスキーマに対する &lt;code&gt;db_schema:search&lt;/code&gt; 権限が必要です。スキーマ修飾なしでオブジェクトが参照されると、この権限が存在しないスキーマは検索されません（ユーザーがスキーマに対する &lt;code&gt;USAGE&lt;/code&gt; 特権を持っていない場合と同様に）。明示的なスキーマ修飾が存在する場合、ユーザーが名前付きスキーマに対する必要な権限を持っていないとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="233299fd5dfd7550c24147ba5661abe08d2d0d86" translate="yes" xml:space="preserve">
          <source>In order to allow the PostgreSQL query planner to make reasonably informed decisions when optimizing queries, the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; data should be up-to-date for all tables used in the query. Normally the &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuum daemon&lt;/a&gt; will take care of that automatically. But if a table has recently had substantial changes in its contents, you might need to do a manual &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; rather than wait for autovacuum to catch up with the changes.</source>
          <target state="translated">PostgreSQLクエリプランナーがクエリを最適化する際に十分な情報に基づいた決定を行えるようにするには、クエリで使用されるすべてのテーブルの&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;データを最新にする必要があります。通常、&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;autovacuumデーモン&lt;/a&gt;が自動的に処理します。ただし、テーブルの内容が最近大幅に変更された場合は、autovacuumが変更に追いつくのを待つのではなく、手動で&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bbf891d4248cf5667df821377cc8cc7768e14e9" translate="yes" xml:space="preserve">
          <source>In order to be able to copy the initial table data, the role used for the replication connection must have the &lt;code&gt;SELECT&lt;/code&gt; privilege on a published table (or be a superuser).</source>
          <target state="translated">初期テーブルデータをコピーできるようにするには、レプリケーション接続に使用されるロールに、パブリッシュされたテーブルに対する &lt;code&gt;SELECT&lt;/code&gt; 権限が必要です（またはスーパーユーザーである必要があります）。</target>
        </trans-unit>
        <trans-unit id="fcaf64f5cce00b8df1baf8d751f9011467d9dba7" translate="yes" xml:space="preserve">
          <source>In order to bootstrap the database system, a freshly initialized system always contains one predefined role. This role is always a &amp;ldquo;superuser&amp;rdquo;, and by default (unless altered when running &lt;code&gt;initdb&lt;/code&gt;) it will have the same name as the operating system user that initialized the database cluster. Customarily, this role will be named &lt;code&gt;postgres&lt;/code&gt;. In order to create more roles you first have to connect as this initial role.</source>
          <target state="translated">データベースシステムをブートストラップするために、新しく初期化されたシステムには、常に1つの事前定義されたロールが含まれています。このロールは常に「スーパーユーザー」であり、デフォルトでは（ &lt;code&gt;initdb&lt;/code&gt; の実行時に変更されない限り）、データベースクラスターを初期化したオペレーティングシステムユーザーと同じ名前になります。通常、このロールの名前は &lt;code&gt;postgres&lt;/code&gt; になります。さらに多くのロールを作成するには、最初にこの初期ロールとして接続する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0b6ace4aa733c9f867afeaddbd70b1a3a0b54f3" translate="yes" xml:space="preserve">
          <source>In order to calculate the union, intersection, or difference of two queries, the two queries must be &amp;ldquo;union compatible&amp;rdquo;, which means that they return the same number of columns and the corresponding columns have compatible data types, as described in &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;.</source>
          <target state="translated">2つのクエリのユニオン、インターセクション、または差異を計算するには、2つのクエリが「ユニオン互換」である必要があります。これは、&lt;a href=&quot;typeconv-union-case&quot;&gt;10.5節で&lt;/a&gt;説明するように、同じ数の列を返し、対応する列に互換性のあるデータ型があることを意味します。</target>
        </trans-unit>
        <trans-unit id="4415b6dbba894170e74bcc6996dbfa1fb24cd8d1" translate="yes" xml:space="preserve">
          <source>In order to create a database, the PostgreSQL server must be up and running (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;).</source>
          <target state="translated">データベースを作成するには、PostgreSQLサーバーが稼働している必要があります（&lt;a href=&quot;server-start&quot;&gt;セクション18.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3f22ae189397eeb8d6d5706a9610e0f700d2bec8" translate="yes" xml:space="preserve">
          <source>In order to emulate a case-insensitive collation as closely as possible, there are &lt;code&gt;citext&lt;/code&gt;-specific versions of a number of string-processing operators and functions. So, for example, the regular expression operators &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; exhibit the same behavior when applied to &lt;code&gt;citext&lt;/code&gt;: they both match case-insensitively. The same is true for &lt;code&gt;!~&lt;/code&gt; and &lt;code&gt;!~*&lt;/code&gt;, as well as for the &lt;code&gt;LIKE&lt;/code&gt; operators &lt;code&gt;~~&lt;/code&gt; and &lt;code&gt;~~*&lt;/code&gt;, and &lt;code&gt;!~~&lt;/code&gt; and &lt;code&gt;!~~*&lt;/code&gt;. If you'd like to match case-sensitively, you can cast the operator's arguments to &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">大文字と小文字を区別しない照合をできるだけ厳密にエミュレートするために、いくつかの文字列処理演算子と関数の &lt;code&gt;citext&lt;/code&gt; 固有のバージョンがあります。したがって、たとえば、正規表現演算子 &lt;code&gt;~&lt;/code&gt; と &lt;code&gt;~*&lt;/code&gt; は、 &lt;code&gt;citext&lt;/code&gt; に適用すると同じ動作を示します。どちらも大文字と小文字を区別せずに一致します。同じことが &lt;code&gt;!~&lt;/code&gt; と &lt;code&gt;!~*&lt;/code&gt; 、および &lt;code&gt;LIKE&lt;/code&gt; 演算子 &lt;code&gt;~~&lt;/code&gt; と &lt;code&gt;~~*&lt;/code&gt; 、および &lt;code&gt;!~~&lt;/code&gt; と &lt;code&gt;!~~*&lt;/code&gt; も当てはまります。大文字と小文字を区別して一致させたい場合は、演算子の引数を &lt;code&gt;text&lt;/code&gt; にキャストできます。</target>
        </trans-unit>
        <trans-unit id="13c4603c579f552910275f0bbcb4deae55ef3a7a" translate="yes" xml:space="preserve">
          <source>In order to function, this module must be loaded via &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">機能させるには、このモジュールを &lt;code&gt;postgresql.conf&lt;/code&gt; の&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;経由でロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="d81c2662b5a84aa8d5b82fab0b4d606e39ebda86" translate="yes" xml:space="preserve">
          <source>In order to measure the run-time cost of each node in the execution plan, the current implementation of &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; adds profiling overhead to query execution. As a result, running &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on a query can sometimes take significantly longer than executing the query normally. The amount of overhead depends on the nature of the query, as well as the platform being used. The worst case occurs for plan nodes that in themselves require very little time per execution, and on machines that have relatively slow operating system calls for obtaining the time of day.</source>
          <target state="translated">実行プランの各ノードのランタイムコストを測定するために、 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; の現在の実装では、クエリ実行にプロファイリングオーバーヘッドが追加されます。その結果、クエリで &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を実行すると、通常のクエリの実行よりも大幅に時間がかかる場合があります。オーバーヘッドの量は、クエリの性質、および使用されているプラ​​ットフォームによって異なります。最悪のケースは、実行ごとにほとんど時間を必要としない計画ノード、および時刻を取得するためのオペレーティングシステム呼び出しが比較的遅いマシンで発生します。</target>
        </trans-unit>
        <trans-unit id="8ef25cb15d96bc5ee47cb922c3476dbfcb096c17" translate="yes" xml:space="preserve">
          <source>In order to prevent this, the following applies to all built-in selectivity estimation functions. When planning a query, in order to be able to use stored statistics, the current user must either have &lt;code&gt;SELECT&lt;/code&gt; privilege on the table or the involved columns, or the operator used must be &lt;code&gt;LEAKPROOF&lt;/code&gt; (more accurately, the function that the operator is based on). If not, then the selectivity estimator will behave as if no statistics are available, and the planner will proceed with default or fall-back assumptions.</source>
          <target state="translated">これを防ぐために、以下はすべての組み込み選択性推定関数に適用されます。クエリを計画するとき、保存された統計を使用できるようにするには、現在のユーザーがテーブルまたは関連する列に対する &lt;code&gt;SELECT&lt;/code&gt; 権限を持っているか、使用する演算子が &lt;code&gt;LEAKPROOF&lt;/code&gt; （より正確には、演算子が基づいている関数）である必要があります）。そうでない場合、選択性推定器は統計が利用できないかのように動作し、プランナはデフォルトまたはフォールバックの仮定を続行します。</target>
        </trans-unit>
        <trans-unit id="6b9560d0a190cd0915dff71499a691135e350ab1" translate="yes" xml:space="preserve">
          <source>In ordinary usage, these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt;, although superusers can alter them on-the-fly within their own sessions. Typical usage might be:</source>
          <target state="translated">通常の使用では、これらのパラメーターは &lt;code&gt;postgresql.conf&lt;/code&gt; で設定されますが、スーパーユーザーは自分のセッション内でオンザフライで変更できます。一般的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="70a9b455eedcd0013740b57c24d0da08e7b71441" translate="yes" xml:space="preserve">
          <source>In parameters that specify support function names, you can write a schema name if needed, for example &lt;code&gt;SFUNC = public.sum&lt;/code&gt;. Do not write argument types there, however &amp;mdash; the argument types of the support functions are determined from other parameters.</source>
          <target state="translated">サポート関数名を指定するパラメーターでは、必要に応じてスキーマ名を記述できます（例： &lt;code&gt;SFUNC = public.sum&lt;/code&gt; 。ただし、引数の型をそこに記述しないでください。サポート関数の引数の型は、他のパラメーターから決定されます。</target>
        </trans-unit>
        <trans-unit id="e6503b355c17e530acb3ce1cf1b630a12d5c662a" translate="yes" xml:space="preserve">
          <source>In particular, if there's an index on &lt;code&gt;key&lt;/code&gt;, it will probably be used to fetch just the rows having &lt;code&gt;key = 123&lt;/code&gt;. On the other hand, in</source>
          <target state="translated">特に、 &lt;code&gt;key&lt;/code&gt; にインデックスがある場合、それはおそらく &lt;code&gt;key = 123&lt;/code&gt; を持つ行だけをフェッチするために使用されます。一方、</target>
        </trans-unit>
        <trans-unit id="e4a5dbfbe9955b3dd014a081adfefb7a2337bd07" translate="yes" xml:space="preserve">
          <source>In particular, when a superuser chooses to &lt;code&gt;SET ROLE&lt;/code&gt; to a non-superuser role, they lose their superuser privileges.</source>
          <target state="translated">特に、スーパーユーザーがスーパーユーザー以外の役割に &lt;code&gt;SET ROLE&lt;/code&gt; を設定することを選択すると、スーパーユーザーの特権が失われます。</target>
        </trans-unit>
        <trans-unit id="f584b379c3631dcc4c7bd92f0443efdccb5ba563" translate="yes" xml:space="preserve">
          <source>In plain format, tablespaces will be backed up to the same path they have on the source server, unless the option &lt;code&gt;--tablespace-mapping&lt;/code&gt; is used. Without this option, running a plain format base backup on the same host as the server will not work if tablespaces are in use, because the backup would have to be written to the same directory locations as the original tablespaces.</source>
          <target state="translated">プレーン形式では、オプション &lt;code&gt;--tablespace-mapping&lt;/code&gt; が使用されていない限り、テーブルスペースはソースサーバーと同じパスにバックアップされます。このオプションがないと、テーブルスペースが使用されている場合、サーバーと同じホストでプレーン形式のベースバックアップを実行できません。これは、バックアップを元のテーブルスペースと同じディレクトリの場所に書き込む必要があるためです。</target>
        </trans-unit>
        <trans-unit id="cc733581aa12ac8119d8135b89e36cf1d9d3b31b" translate="yes" xml:space="preserve">
          <source>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that.</source>
          <target state="translated">実際には、通常は演算子の検索パスに依存しているので、これほど醜いことを書く必要はありません。</target>
        </trans-unit>
        <trans-unit id="a48f8184fbeadfd296ca8b91bd2766492182e822" translate="yes" xml:space="preserve">
          <source>In practice the &lt;em&gt;&lt;code&gt;source_sql&lt;/code&gt;&lt;/em&gt; query should always specify &lt;code&gt;ORDER BY 1&lt;/code&gt; to ensure that values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together. However, ordering of the categories within a group is not important. Also, it is essential to be sure that the order of the &lt;em&gt;&lt;code&gt;category_sql&lt;/code&gt;&lt;/em&gt; query's output matches the specified output column order.</source>
          <target state="translated">実際には、&lt;em&gt; &lt;code&gt;source_sql&lt;/code&gt; &lt;/em&gt;クエリは常に &lt;code&gt;ORDER BY 1&lt;/code&gt; を指定して、同じ &lt;code&gt;row_name&lt;/code&gt; の値が確実にまとめられるようにする必要があります。ただし、グループ内のカテゴリの順序は重要ではありません。また、&lt;em&gt; &lt;code&gt;category_sql&lt;/code&gt; &lt;/em&gt;クエリの出力の順序が、指定された出力列の順序と一致していることを確認することも重要です。</target>
        </trans-unit>
        <trans-unit id="1937c987be0e7b4e7465a2a7029e3f9255be3a60" translate="yes" xml:space="preserve">
          <source>In practice the SQL query should always specify &lt;code&gt;ORDER BY 1,2&lt;/code&gt; to ensure that the input rows are properly ordered, that is, values with the same &lt;code&gt;row_name&lt;/code&gt; are brought together and correctly ordered within the row. Notice that &lt;code&gt;crosstab&lt;/code&gt; itself does not pay any attention to the second column of the query result; it's just there to be ordered by, to control the order in which the third-column values appear across the page.</source>
          <target state="translated">実際には、SQLクエリは常に &lt;code&gt;ORDER BY 1,2&lt;/code&gt; を指定して、入力行が適切に順序付けられるようにする必要があります。つまり、同じ &lt;code&gt;row_name&lt;/code&gt; の値がまとめられ、行内で正しく順序付けされます。お知らせ &lt;code&gt;crosstab&lt;/code&gt; クエリ結果の2番目の列に注意を払っていない自分自身を。 3番目の列の値がページ全体に表示される順序を制御するために、順序付けされる場所があります。</target>
        </trans-unit>
        <trans-unit id="81fbb389dcb4a22896ff56ba2f6a26d52f9a0053" translate="yes" xml:space="preserve">
          <source>In practice, it might be best to check the newest child first, if most inserts go into that child. For simplicity, we have shown the trigger's tests in the same order as in other parts of this example.</source>
          <target state="translated">実際には、ほとんどの挿入がその子に入るのであれば、最初に新しい子をチェックするのがベストかもしれません。簡単にするために、この例の他の部分と同じ順番でトリガーのテストを表示しています。</target>
        </trans-unit>
        <trans-unit id="06e0b2a62cd9f4eb01f119bc558152c7a9b61c4c" translate="yes" xml:space="preserve">
          <source>In practice, these commands would be wrapped up in an extension.</source>
          <target state="translated">実際には、これらのコマンドは拡張機能に包まれています。</target>
        </trans-unit>
        <trans-unit id="79f48feff09a5e6beb49de65d5ed928eb6a28410" translate="yes" xml:space="preserve">
          <source>In principle, cross-references from one initial catalog row to another could be written just by writing the preassigned OID of the referenced row in the referencing field. However, that is against project policy, because it is error-prone, hard to read, and subject to breakage if a newly-assigned OID is renumbered. Therefore &lt;code&gt;genbki.pl&lt;/code&gt; provides mechanisms to write symbolic references instead. The rules are as follows:</source>
          <target state="translated">原則として、最初のカタログ行から別の行への相互参照は、参照されるフィールドの事前に割り当てられたOIDを参照フィールドに書き込むだけで書き込むことができます。ただし、エラーが発生しやすく、読みにくく、新しく割り当てられたOIDの番号が変更されると破損する可能性があるため、これはプロジェクトポリシーに違反します。したがって、 &lt;code&gt;genbki.pl&lt;/code&gt; は、代わりにシンボリック参照を書き込むメカニズムを提供します。ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="760cef4da4decce6f6d9b7cb2f206b14f10f3fa4" translate="yes" xml:space="preserve">
          <source>In principle, index-only scans can be used with expression indexes. For example, given an index on &lt;code&gt;f(x)&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a table column, it should be possible to execute</source>
          <target state="translated">原則として、インデックスのみのスキャンは式インデックスで使用できます。たとえば、 &lt;code&gt;x&lt;/code&gt; がテーブル列である &lt;code&gt;f(x)&lt;/code&gt; のインデックスを指定すると、次のように実行できるはずです。</target>
        </trans-unit>
        <trans-unit id="50939af3586cb58faf973e37d044bc572b91198e" translate="yes" xml:space="preserve">
          <source>In principle, one can use &lt;code&gt;to_tsquery&lt;/code&gt; if you quote the argument:</source>
          <target state="translated">原則として、引数を引用する場合は、 &lt;code&gt;to_tsquery&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="25c4a2a950655d8b26ffa359e0be687cbb7c81cd" translate="yes" xml:space="preserve">
          <source>In principle, we could do an index-only scan on this index to satisfy a query like</source>
          <target state="translated">原理的には、以下のようなクエリを満たすために、このインデックスに対してインデックスのみのスキャンを行うことができます。</target>
        </trans-unit>
        <trans-unit id="5a138e4bb79a7d66b0d4bfaffdffcdcbb5964acf" translate="yes" xml:space="preserve">
          <source>In prior releases of PostgreSQL, this was the default except for the &lt;code&gt;stop&lt;/code&gt; mode.</source>
          <target state="translated">PostgreSQLの以前のリリースでは、これは &lt;code&gt;stop&lt;/code&gt; モードを除いてデフォルトでした。</target>
        </trans-unit>
        <trans-unit id="75324ba26fc4965d2196117750a2a1059aac25a6" translate="yes" xml:space="preserve">
          <source>In prompt 1 normally &lt;code&gt;=&lt;/code&gt;, but &lt;code&gt;@&lt;/code&gt; if the session is in an inactive branch of a conditional block, or &lt;code&gt;^&lt;/code&gt; if in single-line mode, or &lt;code&gt;!&lt;/code&gt; if the session is disconnected from the database (which can happen if &lt;code&gt;\connect&lt;/code&gt; fails). In prompt 2 &lt;code&gt;%R&lt;/code&gt; is replaced by a character that depends on why psql expects more input: &lt;code&gt;-&lt;/code&gt; if the command simply wasn't terminated yet, but &lt;code&gt;*&lt;/code&gt; if there is an unfinished &lt;code&gt;/* ... */&lt;/code&gt; comment, a single quote if there is an unfinished quoted string, a double quote if there is an unfinished quoted identifier, a dollar sign if there is an unfinished dollar-quoted string, or &lt;code&gt;(&lt;/code&gt; if there is an unmatched left parenthesis. In prompt 3 &lt;code&gt;%R&lt;/code&gt; doesn't produce anything.</source>
          <target state="translated">プロンプト1では通常 &lt;code&gt;=&lt;/code&gt; ですが、セッションが条件付きブロックの非アクティブなブランチにある場合は &lt;code&gt;@&lt;/code&gt; 、単一行モードの場合は &lt;code&gt;^&lt;/code&gt; 、または &lt;code&gt;!&lt;/code&gt; セッションがデータベースから切断された場合（ &lt;code&gt;\connect&lt;/code&gt; が失敗した場合に発生する可能性があります）。 2プロンプトで &lt;code&gt;%R&lt;/code&gt; は：psqlのは、複数の入力を期待する理由に依存文字に置き換えられます &lt;code&gt;-&lt;/code&gt; コマンドは、単にまだ終了していなかった場合は、しかし、 &lt;code&gt;*&lt;/code&gt; 未完がある場合は &lt;code&gt;/* ... */&lt;/code&gt; コメント単一引用符であれば未完成の引用符付き文字列、未完成の引用符付き識別子がある場合は二重引用符、未完成のドル引用符付き文字列がある場合はドル記号、または &lt;code&gt;(&lt;/code&gt; 一致しない左括弧がある場合。プロンプト3では、 &lt;code&gt;%R&lt;/code&gt; は何も生成しません。</target>
        </trans-unit>
        <trans-unit id="55492f505092f7907e8e04b3d9f069e610e9bef1" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt;: the fact that its value cannot be broken down into smaller components.</source>
          <target state="translated">参考に&lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;基準&lt;/a&gt;：その値が小さい成分に分解することができないという事実。</target>
        </trans-unit>
        <trans-unit id="e2af2f18b8bb379f6a3aaec125d379cfd0547daa" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;partitioned table&lt;/a&gt;: One of the tables that each contain part of the data of the partitioned table, which is said to be the &lt;em&gt;parent&lt;/em&gt;. The partition is itself a table, so it can also be queried directly; at the same time, a partition can sometimes be a partitioned table, allowing hierarchies to be created.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-PARTITIONED-TABLE&quot;&gt;パーティションテーブルを&lt;/a&gt;参照する場合：それぞれがパーティションテーブルのデータの一部を含むテーブルの1つであり、&lt;em&gt;親&lt;/em&gt;と呼ばれます。パーティション自体はテーブルであるため、直接クエリすることもできます。同時に、パーティションをパーティション化されたテーブルにして、階層を作成できる場合もあります。</target>
        </trans-unit>
        <trans-unit id="5c9e089ab97a2e09bac9e2f25d906ab6733e4ee0" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;database transaction&lt;/a&gt;: see &lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;atomicity&lt;/a&gt;.</source>
          <target state="translated">参照するには&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;、データベース・トランザクション&lt;/a&gt;：参照&lt;a href=&quot;glossary#GLOSSARY-ATOMICITY&quot;&gt;アトミックを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f06a3856f982e3b72fb625608048db8b0f9e532d" translate="yes" xml:space="preserve">
          <source>In reference to a &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;window function&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt;, a partition is a user-defined criterion that identifies which neighboring &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;query's result set&lt;/a&gt; can be considered by the function.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;クエリ&lt;/a&gt;内の&lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;ウィンドウ関数を&lt;/a&gt;参照すると、パーティションは、&lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;クエリの結果セットの&lt;/a&gt;どの隣接&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;行&lt;/a&gt;を関数で検討できるかを識別するユーザー定義の基準です。</target>
        </trans-unit>
        <trans-unit id="ce53e0d0da47b411803cd409013625a3f9ae5431" translate="yes" xml:space="preserve">
          <source>In releases of PostgreSQL before 13 there was no &lt;code&gt;xid8&lt;/code&gt; type, so variants of these functions were provided that used &lt;code&gt;bigint&lt;/code&gt; to represent a 64-bit XID, with a correspondingly distinct snapshot data type &lt;code&gt;txid_snapshot&lt;/code&gt;. These older functions have &lt;code&gt;txid&lt;/code&gt; in their names. They are still supported for backward compatibility, but may be removed from a future release. See &lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;Table 9.76&lt;/a&gt;.</source>
          <target state="translated">13より前のPostgreSQLのリリースでは、 &lt;code&gt;xid8&lt;/code&gt; タイプがなかったため、 &lt;code&gt;bigint&lt;/code&gt; を使用して64ビットXIDを表し、それに対応して異なるスナップショットデータタイプ &lt;code&gt;txid_snapshot&lt;/code&gt; を使用するこれらの関数のバリアントが提供されました。これらの古い関数の名前には &lt;code&gt;txid&lt;/code&gt; が含まれています。これらは下位互換性のために引き続きサポートされていますが、将来のリリースから削除される可能性があります。&lt;a href=&quot;functions-info#FUNCTIONS-TXID-SNAPSHOT&quot;&gt;表9.76を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d2a64129f0b1da1e51ed964ad4579c4ce899b50b" translate="yes" xml:space="preserve">
          <source>In releases prior to 9.6, this parameter also allowed the values &lt;code&gt;archive&lt;/code&gt; and &lt;code&gt;hot_standby&lt;/code&gt;. These are still accepted but mapped to &lt;code&gt;replica&lt;/code&gt;.</source>
          <target state="translated">9.6より前のリリースでは、このパラメーターは値 &lt;code&gt;archive&lt;/code&gt; および &lt;code&gt;hot_standby&lt;/code&gt; も許可していました。これらは引き続き受け入れられますが、 &lt;code&gt;replica&lt;/code&gt; マップされます。</target>
        </trans-unit>
        <trans-unit id="aa88d3807e10330acdc1940359127a25a966338d" translate="yes" xml:space="preserve">
          <source>In short then, the most general recipe for removing a role that has been used to own objects is:</source>
          <target state="translated">要するに、その後、オブジェクトを所有するために使用されている役割を削除するための最も一般的なレシピです。</target>
        </trans-unit>
        <trans-unit id="d436b991362b7fed721dd789926c009b129d872d" translate="yes" xml:space="preserve">
          <source>In short, this is the difference between abbreviations and full names: abbreviations represent a specific offset from UTC, whereas many of the full names imply a local daylight-savings time rule, and so have two possible UTC offsets. As an example, &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; represents noon local time in New York, which for this particular date was Eastern Daylight Time (UTC-4). So &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; specifies that same time instant. But &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was nominally in effect on that date.</source>
          <target state="translated">つまり、これは略語とフルネームの違いです。略語はUTCからの特定のオフセットを表しますが、フルネームの多くはローカルの夏時間規則を意味するため、2つのUTCオフセットが考えられます。例として、 &lt;code&gt;2014-06-04 12:00 America/New_York&lt;/code&gt; はニューヨークの正午の現地時間を表し、この特定の日付では東部夏時間（UTC-4）でした。したがって、 &lt;code&gt;2014-06-04 12:00 EDT&lt;/code&gt; は同じ時刻を指定しています。しかし、 &lt;code&gt;2014-06-04 12:00 EST&lt;/code&gt; は、夏時間が名目上有効であったかどうかに関係なく、正午の東部標準時（UTC-5）を指定します。</target>
        </trans-unit>
        <trans-unit id="6f11576d9f6f09df7ddccd8a08208061f234c7e9" translate="yes" xml:space="preserve">
          <source>In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to &amp;ldquo;eat&amp;rdquo; relative to each other.</source>
          <target state="translated">つまり、REに貪欲な部分式と貪欲でない部分式の両方が含まれている場合、RE全体に割り当てられている属性に応じて、一致の長さの合計は可能な限り長くなるか、できるだけ短くなります。部分式に割り当てられた属性は、それらが互いに対して相対的に「食べる」ことが許可されている一致の程度にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="aee830ec2c7b69b7f24b10ee81fb051f88d3ea9e" translate="yes" xml:space="preserve">
          <source>In short, while an index-only scan is possible given the two fundamental requirements, it will be a win only if a significant fraction of the table's heap pages have their all-visible map bits set. But tables in which a large fraction of the rows are unchanging are common enough to make this type of scan very useful in practice.</source>
          <target state="translated">要するに、2つの基本的な要件を満たせばインデックスのみのスキャンは可能ですが、テーブルのヒープページのかなりの部分が全可視マップビットが設定されている場合にのみ有効になります。しかし、行の大部分が変更されていないテーブルは、このタイプのスキャンを実際に非常に有用にするのに十分に一般的です。</target>
        </trans-unit>
        <trans-unit id="81308d755ee35ef99db2fb46ff2f6ea4fdc54a8b" translate="yes" xml:space="preserve">
          <source>In simple cases, the concatenation operator discussed above is preferred over direct use of these functions. However, because the concatenation operator is overloaded to serve all three cases, there are situations where use of one of the functions is helpful to avoid ambiguity. For example consider:</source>
          <target state="translated">単純なケースでは、これらの関数を直接使用するよりも、上で説明した連結演算子を使用する方が好ましいです。しかし、連結演算子は3つのケースすべてに対応するためにオーバーロードされているため、曖昧さを避けるためには、いずれかの関数を使用することが有用な状況もあります。例えば、次のように考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4e5a889e9ac805b7a61b2cef1759227b4c01dc82" translate="yes" xml:space="preserve">
          <source>In some cases &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; shows additional execution statistics beyond the plan node execution times and row counts. For example, Sort and Hash nodes provide extra information:</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; は、計画ノードの実行時間と行数を超えた追加の実行統計を表示する場合があります。たとえば、SortノードとHashノードは追加情報を提供します。</target>
        </trans-unit>
        <trans-unit id="e8c81b00bcb69c8ee6819bdd31891ee097641a10" translate="yes" xml:space="preserve">
          <source>In some cases it is possible for a single SQL command to fire more than one kind of trigger. For instance an &lt;code&gt;INSERT&lt;/code&gt; with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause may cause both insert and update operations, so it will fire both kinds of triggers as needed. The transition relations supplied to triggers are specific to their event type; thus an &lt;code&gt;INSERT&lt;/code&gt; trigger will see only the inserted rows, while an &lt;code&gt;UPDATE&lt;/code&gt; trigger will see only the updated rows.</source>
          <target state="translated">場合によっては、単一のSQLコマンドが複数の種類のトリガーを起動する可能性があります。たとえば、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句を指定した &lt;code&gt;INSERT&lt;/code&gt; は挿入操作と更新操作の両方を引き起こす可能性があるため、必要に応じて両方の種類のトリガーを起動します。トリガーに提供される遷移関係は、そのイベントタイプに固有です。したがって、 &lt;code&gt;INSERT&lt;/code&gt; トリガーは挿入された行のみを表示し、 &lt;code&gt;UPDATE&lt;/code&gt; トリガーは更新された行のみを表示します。</target>
        </trans-unit>
        <trans-unit id="f8731dce3dc14a003f46fc2608e777589eba29c9" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt; with no &lt;code&gt;OUT&lt;/code&gt; parameters. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">場合によっては、呼び出される方法に応じて異なる列セットを返すことができるテーブル関数を定義すると便利です。これをサポートするために、テーブル関数は、 &lt;code&gt;OUT&lt;/code&gt; パラメータのない疑似型 &lt;code&gt;record&lt;/code&gt; を返すものとして宣言できます。このような関数をクエリで使用する場合、システムがクエリを解析および計画する方法を認識できるように、期待される行構造をクエリ自体で指定する必要があります。この構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="200831069c2086edb298c7a6b5677910ac8d156b" translate="yes" xml:space="preserve">
          <source>In some cases it is useful to define table functions that can return different column sets depending on how they are invoked. To support this, the table function can be declared as returning the pseudo-type &lt;code&gt;record&lt;/code&gt;. When such a function is used in a query, the expected row structure must be specified in the query itself, so that the system can know how to parse and plan the query. This syntax looks like:</source>
          <target state="translated">呼び出される方法に応じて異なる列セットを返すことができるテーブル関数を定義すると便利な場合があります。これをサポートするために、疑似タイプの &lt;code&gt;record&lt;/code&gt; を返すように表関数を宣言できます。このような関数をクエリで使用する場合、システムはクエリを解析および計画する方法を認識できるように、予想される行構造をクエリ自体に指定する必要があります。この構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="6d89a4f32e25e9b6f4b0aae8fa4c3b33eb2b87fd" translate="yes" xml:space="preserve">
          <source>In some cases it might also be necessary to increase &lt;code&gt;SEMMAP&lt;/code&gt; to be at least on the order of &lt;code&gt;SEMMNS&lt;/code&gt;. If the system has this parameter (many do not), it defines the size of the semaphore resource map, in which each contiguous block of available semaphores needs an entry. When a semaphore set is freed it is either added to an existing entry that is adjacent to the freed block or it is registered under a new map entry. If the map is full, the freed semaphores get lost (until reboot). Fragmentation of the semaphore space could over time lead to fewer available semaphores than there should be.</source>
          <target state="translated">場合によっては、少なくとも &lt;code&gt;SEMMNS&lt;/code&gt; のオーダーになるように &lt;code&gt;SEMMAP&lt;/code&gt; を増やす必要がある場合もあります。システムにこのパラメータがある場合（多くの場合はありません）、セマフォリソースマップのサイズを定義します。使用可能なセマフォの連続する各ブロックにエントリが必要です。セマフォセットが解放されると、解放されたブロックに隣接する既存のエントリに追加されるか、新しいマップエントリの下に登録されます。マップがいっぱいの場合、解放されたセマフォは（再起動するまで）失われます。セマフォスペースの断片化により、時間の経過により、使用可能なセマフォが本来よりも少なくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c2c835a0ebddfd298ae5463818241acfed988912" translate="yes" xml:space="preserve">
          <source>In some cases several distinct distributions are needed which don't correlate with each other and this is when implicit seed parameter comes in handy:</source>
          <target state="translated">場合によっては、互いに相関しないいくつかの異なる分布が必要な場合があり、このような場合に暗黙のシードパラメータが便利です。</target>
        </trans-unit>
        <trans-unit id="b659c8baf607682082fc2a028333f1abc817539f" translate="yes" xml:space="preserve">
          <source>In some cases the join style is easier to write or faster to execute than the sub-select style.</source>
          <target state="translated">場合によっては、結合スタイルの方がサブセレクトスタイルよりも書きやすく、実行が速いこともあります。</target>
        </trans-unit>
        <trans-unit id="cc280a2801256511a801ad6396d782aaf11a1fd5" translate="yes" xml:space="preserve">
          <source>In some cases the planner will prefer a &amp;ldquo;simple&amp;rdquo; index scan plan:</source>
          <target state="translated">場合によっては、プランナは「単純な」インデックススキャンプランを好むでしょう。</target>
        </trans-unit>
        <trans-unit id="0752bfbb1e8e2f35c9e16d26381cb349bc520d2f" translate="yes" xml:space="preserve">
          <source>In some cases you might wish to know which table a particular row originated from. There is a system column called &lt;code&gt;tableoid&lt;/code&gt; in each table which can tell you the originating table:</source>
          <target state="translated">場合によっては、特定の行がどのテーブルから発生したかを知りたいことがあります。各テーブルには &lt;code&gt;tableoid&lt;/code&gt; と呼ばれるシステム列があり、元のテーブルを確認できます。</target>
        </trans-unit>
        <trans-unit id="85aa180babf965f446d9b4ca6c81be1df71986fd" translate="yes" xml:space="preserve">
          <source>In some cases, a user will know that a given XPath query will return only a single result (perhaps a unique document identifier) &amp;mdash; if used alongside an XPath query returning multiple results, the single-valued result will appear only on the first row of the result. The solution to this is to use the key field as part of a join against a simpler XPath query. As an example:</source>
          <target state="translated">場合によっては、ユーザーは特定のXPathクエリが単一の結果（おそらく一意のドキュメント識別子）しか返さないことを知っています。複数の結果を返すXPathクエリと一緒に使用すると、単一値の結果は最初の行にのみ表示されます結果。これに対する解決策は、より単純なXPathクエリに対する結合の一部としてキーフィールドを使用することです。例として：</target>
        </trans-unit>
        <trans-unit id="ca377880ca6732de73ffe88d7d610d10f88a2a04" translate="yes" xml:space="preserve">
          <source>In some cases, an external storage product can be accessed either via NFS or a lower-level protocol such as iSCSI. In the latter case, the storage appears as a block device and any available file system can be created on it. That approach might relieve the DBA from having to deal with some of the idiosyncrasies of NFS, but of course the complexity of managing remote storage then happens at other levels.</source>
          <target state="translated">場合によっては、外部ストレージ製品は、NFS または iSCSI などの下位レベルのプロトコルを介してアクセスすることができます。後者の場合、ストレージはブロックデバイスとして表示され、利用可能なファイルシステムを作成することができます。このアプローチにより、DBAはNFSの特殊性に対処する必要がなくなるかもしれませんが、もちろんリモートストレージの管理の複雑さは他のレベルで発生します。</target>
        </trans-unit>
        <trans-unit id="4cdce5fe180ac016fd38728542336a4cccb6659d" translate="yes" xml:space="preserve">
          <source>In some cases, queries with visibly different texts might get merged into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry. Normally this will happen only for semantically equivalent queries, but there is a small chance of hash collisions causing unrelated queries to be merged into one entry. (This cannot happen for queries belonging to different users or databases, however.)</source>
          <target state="translated">場合によっては、見かけ上異なるテキストを持つクエリが単一の &lt;code&gt;pg_stat_statements&lt;/code&gt; エントリにマージされることがあります。通常、これは意味的に同等のクエリでのみ発生しますが、ハッシュの衝突により、無関係なクエリが1つのエントリにマージされる可能性はわずかです。 （ただし、これは、異なるユーザーまたはデータベースに属するクエリでは発生しません。）</target>
        </trans-unit>
        <trans-unit id="3587765c2705ba8328ac5e625d50c99ae816e4fe" translate="yes" xml:space="preserve">
          <source>In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the &lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt; configuration parameter to &lt;code&gt;off&lt;/code&gt;. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</source>
          <target state="translated">状況によっては、行のセキュリティが適用されていないことを確認することが重要です。たとえば、バックアップを取るときに、行のセキュリティが原因で一部の行がバックアップから省略された場合、それは悲惨な結果になる可能性があります。このような状況では、&lt;a href=&quot;runtime-config-client#GUC-ROW-SECURITY&quot;&gt;row_security&lt;/a&gt;構成パラメーターを &lt;code&gt;off&lt;/code&gt; に設定できます。これ自体は行セキュリティをバイパスしません。クエリの結果がポリシーによってフィルターされる場合は、エラーがスローされます。その後、エラーの理由を調査して修正できます。</target>
        </trans-unit>
        <trans-unit id="b9ce77934cf9885a03a2ac3b7887461d3a1cb010" translate="yes" xml:space="preserve">
          <source>In some contexts, backslashes must be doubled compared to what is shown above, because the generic string-literal parser will also reduce pairs of backslashes to one data character; see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;.</source>
          <target state="translated">一部のコンテキストでは、上に示したものと比較して、バックスラッシュを2倍にする必要があります。これは、汎用文字列リテラルパーサーがバックスラッシュのペアを1つのデータ文字に減らすためです。&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ad2914b6fce7d3aa951198848f0bae1a566122fb" translate="yes" xml:space="preserve">
          <source>In some query plans, it is possible for a subplan node to be executed more than once. For example, the inner index scan will be executed once per outer row in the above nested-loop plan. In such cases, the &lt;code&gt;loops&lt;/code&gt; value reports the total number of executions of the node, and the actual time and rows values shown are averages per-execution. This is done to make the numbers comparable with the way that the cost estimates are shown. Multiply by the &lt;code&gt;loops&lt;/code&gt; value to get the total time actually spent in the node. In the above example, we spent a total of 0.220 milliseconds executing the index scans on &lt;code&gt;tenk2&lt;/code&gt;.</source>
          <target state="translated">一部のクエリプランでは、サブプランノードが複数回実行される可能性があります。たとえば、内部インデックススキャンは、上記のネストされたループプランの外部行ごとに1回実行されます。このような場合、 &lt;code&gt;loops&lt;/code&gt; 値はノードの合計実行数を報告し、表示される実際の時間と行の値は実行ごとの平均です。これは、コスト見積もりが表示される方法と比較できるようにするために行われます。 &lt;code&gt;loops&lt;/code&gt; 値を掛けて、ノードで実際に費やされた合計時間を取得します。上記の例では、 &lt;code&gt;tenk2&lt;/code&gt; でインデックススキャンを実行するのに合計0.220ミリ秒かかりました。</target>
        </trans-unit>
        <trans-unit id="225981494667f7eae039a8f3a624ead9ac2ba414" translate="yes" xml:space="preserve">
          <source>In some situations it is worthwhile to rebuild indexes periodically with the &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; command or a series of individual rebuilding steps.</source>
          <target state="translated">状況によっては、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;コマンドまたは一連の個別の再構築ステップを使用して、定期的にインデックスを再構築する価値があります。</target>
        </trans-unit>
        <trans-unit id="c7e0f45ec00183e0785ecaf537d621d39641ace7" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">状況によっては、クエリを実行する可能な方法をそれぞれ調査するために、過度の時間とメモリ領域が必要になる場合があります。特に、これは、多数の結合操作を含むクエリを実行するときに発生します。妥当な時間内に妥当な（必ずしも最適ではない）クエリプランを決定するために、結合の数がしきい値（&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_thresholdを&lt;/a&gt;参照）を超えると、PostgreSQLは&lt;em&gt;Genetic Query Optimizer&lt;/em&gt;（&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章を&lt;/a&gt;参照）を使用します。</target>
        </trans-unit>
        <trans-unit id="02656e92c47f92204fc3dc37bed1c7e28f95de50" translate="yes" xml:space="preserve">
          <source>In some situations, examining each possible way in which a query can be executed would take an excessive amount of time and memory space. In particular, this occurs when executing queries involving large numbers of join operations. In order to determine a reasonable (not necessarily optimal) query plan in a reasonable amount of time, PostgreSQL uses a &lt;em&gt;Genetic Query Optimizer&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;) when the number of joins exceeds a threshold (see &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;).</source>
          <target state="translated">状況によっては、クエリを実行できる可能性のある各方法を調べると、過度の時間とメモリスペースが必要になります。特に、これは、多数の結合操作を含むクエリを実行するときに発生します。妥当な（必ずしも最適ではない）クエリプランを妥当な時間内に決定するために、PostgreSQLは、結合の数がしきい値（&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_thresholdを&lt;/a&gt;参照）を超えると、&lt;em&gt;Genetic Query Optimizer&lt;/em&gt;（&lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;第59章を&lt;/a&gt;参照）を使用します。</target>
        </trans-unit>
        <trans-unit id="b44a40fdd52559ad494c2c8c248a6de473d41182" translate="yes" xml:space="preserve">
          <source>In standby mode, the server continuously applies WAL received from the master server. The standby server can read WAL from a WAL archive (see &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;) or directly from the master over a TCP connection (streaming replication). The standby server will also attempt to restore any WAL found in the standby cluster's &lt;code&gt;pg_wal&lt;/code&gt; directory. That typically happens after a server restart, when the standby replays again WAL that was streamed from the master before the restart, but you can also manually copy files to &lt;code&gt;pg_wal&lt;/code&gt; at any time to have them replayed.</source>
          <target state="translated">スタンバイモードでは、サーバーはマスターサーバーから受信したWALを継続的に適用します。スタンバイサーバーは、WALアーカイブ（&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_commandを&lt;/a&gt;参照）から、またはTCP接続を介してマスターから直接（ストリーミングレプリケーション）WALを読み取ることができます。スタンバイサーバーは、スタンバイクラスターの &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリにあるWALの復元も試みます。これは通常、サーバーの再起動後、再起動前にマスターからストリーミングされたWALがスタンバイで再度再生されるときに発生しますが、いつでも手動でファイルを &lt;code&gt;pg_wal&lt;/code&gt; に手動でコピーして再生することもできます。</target>
        </trans-unit>
        <trans-unit id="fe531d3ac4f289af249052c7bd344a8eccac974a" translate="yes" xml:space="preserve">
          <source>In strict SQL, &lt;code&gt;GROUP BY&lt;/code&gt; can only group by columns of the source table but PostgreSQL extends this to also allow &lt;code&gt;GROUP BY&lt;/code&gt; to group by columns in the select list. Grouping by value expressions instead of simple column names is also allowed.</source>
          <target state="translated">厳密なSQLでは、 &lt;code&gt;GROUP BY&lt;/code&gt; はソーステーブルの列でのみグループ化できますが、PostgreSQLはこれを拡張して、 &lt;code&gt;GROUP BY&lt;/code&gt; が選択リストの列でグループ化できるようにします。単純な列名の代わりに値式でグループ化することもできます。</target>
        </trans-unit>
        <trans-unit id="925d63461b4ad93eaf09cda8debcd8a2f6185160" translate="yes" xml:space="preserve">
          <source>In such a column, all entries must use the symbolic format except when writing &lt;code&gt;0&lt;/code&gt; for InvalidOid. (If the column is declared &lt;code&gt;regproc&lt;/code&gt;, you can optionally write &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;.) &lt;code&gt;genbki.pl&lt;/code&gt; will warn about unrecognized names.</source>
          <target state="translated">このような列では、InvalidOidに &lt;code&gt;0&lt;/code&gt; を書き込む場合を除いて、すべてのエントリでシンボリック形式を使用する必要があります。（カラムが宣言されている場合 &lt;code&gt;regproc&lt;/code&gt; 、必要に応じて書くことができます &lt;code&gt;-&lt;/code&gt; ではなく &lt;code&gt;0&lt;/code&gt; 。） &lt;code&gt;genbki.pl&lt;/code&gt; が認識されない名前について警告します。</target>
        </trans-unit>
        <trans-unit id="f44470ab677292f080ad629e5021dd422bb50329" translate="yes" xml:space="preserve">
          <source>In synchronous multimaster replication, each server can accept write requests, and modified data is transmitted from the original server to every other server before each transaction commits. Heavy write activity can cause excessive locking and commit delays, leading to poor performance. Read requests can be sent to any server. Some implementations use shared disk to reduce the communication overhead. Synchronous multimaster replication is best for mostly read workloads, though its big advantage is that any server can accept write requests &amp;mdash; there is no need to partition workloads between master and standby servers, and because the data changes are sent from one server to another, there is no problem with non-deterministic functions like &lt;code&gt;random()&lt;/code&gt;.</source>
          <target state="translated">同期マルチマスターレプリケーションでは、各サーバーは書き込み要求を受け入れることができ、変更されたデータは各トランザクションがコミットする前に元のサーバーから他のすべてのサーバーに送信されます。書き込みアクティビティが多いと、過度のロックとコミットの遅延が発生し、パフォーマンスが低下する可能性があります。読み取り要求は任意のサーバーに送信できます。一部の実装では、共有ディスクを使用して通信オーバーヘッドを削減しています。同期マルチマスターレプリケーションは、ほとんどの読み取りワークロードに最適ですが、その大きな利点は、任意のサーバーが書き込み要求を受け入れることができることです。マスターサーバーとスタンバイサーバーの間でワークロードを分割する必要がなく、データの変更がサーバー間で送信されるため、 &lt;code&gt;random()&lt;/code&gt; のような非決定的な関数では問題ありません。</target>
        </trans-unit>
        <trans-unit id="7c4b878fdf07a28c13f143cacc8a5bb3f8880019" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.affix&lt;/code&gt; file every affix flag is described in the following format:</source>
          <target state="translated">で &lt;code&gt;.affix&lt;/code&gt; のファイルすべての接辞フラグは、次の形式で記述されています。</target>
        </trans-unit>
        <trans-unit id="08a1ad04eb220026fbfc94b398836d4cbc2cae8c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame options, the &lt;code&gt;offset&lt;/code&gt; must be an expression not containing any variables, aggregate functions, or window functions. The meaning of the &lt;code&gt;offset&lt;/code&gt; depends on the frame mode:</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; フレームオプション、 &lt;code&gt;offset&lt;/code&gt; 任意の変数、集合関数、又はウィンドウ関数を含まない式でなければなりません。 &lt;code&gt;offset&lt;/code&gt; の意味は、フレームモードによって異なります。</target>
        </trans-unit>
        <trans-unit id="27bf78dd19410e50d81449e21eeb4a9c340ecbaa" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;prepared&lt;/code&gt; mode, pgbench reuses the parse analysis result starting from the second query iteration, so pgbench runs faster than in other modes.</source>
          <target state="translated">で &lt;code&gt;prepared&lt;/code&gt; モード、にpgbenchはこれにpgbench実行速く他のモードに比べて、2番目のクエリ反復から開始解析の解析結果を再利用します。</target>
        </trans-unit>
        <trans-unit id="7dd20a44a8914e7e3854e6b8cc2dd765d950b1b2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;template0&lt;/code&gt; database, it could be useful to create collations whose encoding does not match the database encoding, since they could match the encodings of databases later cloned from &lt;code&gt;template0&lt;/code&gt;. This would currently have to be done manually.</source>
          <target state="translated">で &lt;code&gt;template0&lt;/code&gt; データベース、そのエンコーディング、彼らが後でからクローン化されたデータベースのエンコーディングと一致する可能性があるため、データベースのエンコーディングと一致しない照合順序を作成するために有用である可能性が &lt;code&gt;template0&lt;/code&gt; 。これは現在、手動で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="ee7442c19df868ba3ec76972f6eb3be85838007a" translate="yes" xml:space="preserve">
          <source>In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, &lt;code&gt;2005-01-01&lt;/code&gt; is part of the 53rd week of year 2004, and &lt;code&gt;2006-01-01&lt;/code&gt; is part of the 52nd week of year 2005, while &lt;code&gt;2012-12-31&lt;/code&gt; is part of the first week of 2013. It's recommended to use the &lt;code&gt;isoyear&lt;/code&gt; field together with &lt;code&gt;week&lt;/code&gt; to get consistent results.</source>
          <target state="translated">ISO週番号システムでは、1月上旬の日付を前年の52週目または53週目の一部とし、12月下旬の日付を翌年の最初の週の一部とすることができます。たとえば、 &lt;code&gt;2005-01-01&lt;/code&gt; は2004年の第53週の一部であり、 &lt;code&gt;2006-01-01&lt;/code&gt; は2005年の第52週の一部であり、 &lt;code&gt;2012-12-31&lt;/code&gt; は2013年の第1週の一部です。一貫した結果を得るために、 &lt;code&gt;isoyear&lt;/code&gt; フィールドを &lt;code&gt;week&lt;/code&gt; と一緒に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e2cd521bd47287d9192e9d5c00cd5e2a6b143afe" translate="yes" xml:space="preserve">
          <source>In the PostgreSQL parser life is a bit more complicated. There are several different classes of tokens ranging from those that can never be used as an identifier to those that have absolutely no special status in the parser as compared to an ordinary identifier. (The latter is usually the case for functions specified by SQL.) Even reserved key words are not completely reserved in PostgreSQL, but can be used as column labels (for example, &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt;, even though &lt;code&gt;CHECK&lt;/code&gt; is a reserved key word).</source>
          <target state="translated">PostgreSQLのパーサーライフは少し複雑です。識別子として決して使用できないものから、通常の識別子と比較してパーサーで特別なステータスがまったくないものまで、トークンにはいくつかの異なるクラスがあります。 （後者は、通常、SQLで指定された関数の場合である。）であってもキーワードが完全にはPostgreSQLに予約されていない予約が、（例えば、列ラベルとして使用することができる &lt;code&gt;SELECT 55 AS CHECK&lt;/code&gt; にもかかわらず、 &lt;code&gt;CHECK&lt;/code&gt; 予約キー・ワードです） 。</target>
        </trans-unit>
        <trans-unit id="c06a771ae535ebcc1c02437d6d6edcaa369ff63e" translate="yes" xml:space="preserve">
          <source>In the SQL and POSTGRES styles, day appears before month if DMY field ordering has been specified, otherwise month appears before day. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;Section 8.5.1&lt;/a&gt; for how this setting also affects interpretation of input values.) &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;Table 8.15&lt;/a&gt; shows examples.</source>
          <target state="translated">SQLおよびPOSTGRESスタイルでは、DMYフィールドの順序が指定されている場合、日は月の前に表示されます。それ以外の場合、月は日の前に表示されます。（この設定が入力値の解釈にどのように影響するかについては、&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-INPUT&quot;&gt;8.5.1&lt;/a&gt;項を参照してください。）&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-OUTPUT2-TABLE&quot;&gt;表8.15に&lt;/a&gt;例を示します。</target>
        </trans-unit>
        <trans-unit id="84b70dca4dd2a2a4e41665aeb47157cc98221d20" translate="yes" xml:space="preserve">
          <source>In the SQL standard, sequences only have a &lt;code&gt;USAGE&lt;/code&gt; privilege, which controls the use of the &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression, which is equivalent to the function &lt;code&gt;nextval&lt;/code&gt; in PostgreSQL. The sequence privileges &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; are PostgreSQL extensions. The application of the sequence &lt;code&gt;USAGE&lt;/code&gt; privilege to the &lt;code&gt;currval&lt;/code&gt; function is also a PostgreSQL extension (as is the function itself).</source>
          <target state="translated">SQL標準では、シーケンスには &lt;code&gt;USAGE&lt;/code&gt; 特権のみがあり、これは &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 式の使用を制御します。これは、PostgreSQLの関数 &lt;code&gt;nextval&lt;/code&gt; と同等です。 &lt;code&gt;SELECT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; のシーケンス権限は、PostgreSQLの拡張機能です。シーケンス &lt;code&gt;USAGE&lt;/code&gt; 特権を &lt;code&gt;currval&lt;/code&gt; 関数に適用することも、PostgreSQL関数の拡張です（関数自体と同様）。</target>
        </trans-unit>
        <trans-unit id="fcd4626eefede972e087ae6e07462757a1b0e1ce" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmlexists&lt;/code&gt; function evaluates an expression in the XML Query language, but PostgreSQL allows only an XPath 1.0 expression, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;xmlexists&lt;/code&gt; 関数はXMLクエリ言語で式を評価しますが、&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;セクションD.3.1で&lt;/a&gt;説明されているように、PostgreSQLではXPath1.0式のみが許可されます。</target>
        </trans-unit>
        <trans-unit id="58d7a869224d4569093b25b6e2276773eb285b56" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the &lt;code&gt;xmltable&lt;/code&gt; function evaluates expressions in the XML Query language, but PostgreSQL allows only XPath 1.0 expressions, as discussed in &lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;Section D.3.1&lt;/a&gt;.</source>
          <target state="translated">SQL標準では、 &lt;code&gt;xmltable&lt;/code&gt; 関数はXMLクエリ言語の式を評価しますが、&lt;a href=&quot;xml-limits-conformance#FUNCTIONS-XML-LIMITS-XPATH1&quot;&gt;セクションD.3.1で&lt;/a&gt;説明されているように、PostgreSQLではXPath1.0式のみが許可されます。</target>
        </trans-unit>
        <trans-unit id="9660d94d0a1b58a81d974d699a1bce336010b697" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of &lt;code&gt;user_name.table_name&lt;/code&gt;. This is how PostgreSQL will effectively behave if you create a per-user schema for every user.</source>
          <target state="translated">SQL標準では、同じスキーマ内のオブジェクトが異なるユーザーによって所有されているという概念は存在しません。さらに、一部の実装では、所有者とは異なる名前のスキーマを作成できません。実際、スキーマとユーザーの概念は、標準で指定された基本的なスキーマサポートのみを実装するデータベースシステムではほぼ同等です。したがって、多くのユーザーは、修飾名が実際には &lt;code&gt;user_name.table_name&lt;/code&gt; で構成されていると見なします。これは、ユーザーごとにユーザーごとのスキーマを作成した場合に、PostgreSQLが効果的に動作する方法です。</target>
        </trans-unit>
        <trans-unit id="bce55523e60490fd9a9b255e77d45bae3da990ba" translate="yes" xml:space="preserve">
          <source>In the SQL standard, the optional key word &lt;code&gt;AS&lt;/code&gt; can be omitted before an output column name whenever the new column name is a valid column name (that is, not the same as any reserved keyword). PostgreSQL is slightly more restrictive: &lt;code&gt;AS&lt;/code&gt; is required if the new column name matches any keyword at all, reserved or not. Recommended practice is to use &lt;code&gt;AS&lt;/code&gt; or double-quote output column names, to prevent any possible conflict against future keyword additions.</source>
          <target state="translated">SQL標準では、新しい列名が有効な列名である（つまり、予約済みキーワードと同じではない）場合、出力列名の前にオプションのキーワード &lt;code&gt;AS&lt;/code&gt; を省略できます。 PostgreSQLは少し制限的です。新しい列名が予約済みかどうかにかかわらず、キーワードに一致する場合は &lt;code&gt;AS&lt;/code&gt; が必要です。推奨される方法は、 &lt;code&gt;AS&lt;/code&gt; または二重引用符で囲まれた出力列名を使用して、将来のキーワードの追加との競合を防ぐことです。</target>
        </trans-unit>
        <trans-unit id="60fb33ea7714daeb182a1d8cf938445a4efd08dd" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is a clear distinction between users and roles, and users do not automatically inherit privileges while roles do. This behavior can be obtained in PostgreSQL by giving roles being used as SQL roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, while giving roles being used as SQL users the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute. However, PostgreSQL defaults to giving all roles the &lt;code&gt;INHERIT&lt;/code&gt; attribute, for backward compatibility with pre-8.1 releases in which users always had use of permissions granted to groups they were members of.</source>
          <target state="translated">SQL標準では、ユーザーとロールは明確に区別されており、ユーザーがロールを継承しているときに自動的に特権を継承することはありません。この動作は、SQLの役割として使用されている役割を与えることにより、PostgreSQLので得ることができる &lt;code&gt;INHERIT&lt;/code&gt; の SQLユーザーとして使用されている役割与えながら、属性を &lt;code&gt;NOINHERIT&lt;/code&gt; 属性を。ただし、PostgreSQLはデフォルトで、すべてのロールに &lt;code&gt;INHERIT&lt;/code&gt; 属性を付与します。これは、ユーザーがメンバーであるグループに付与された権限を常に使用できる8.1より前のリリースとの下位互換性のためです。</target>
        </trans-unit>
        <trans-unit id="4d55ecfda5316639c09ff6bb19e9602eb2f98338" translate="yes" xml:space="preserve">
          <source>In the SQL standard, there is one other transaction characteristic that can be set with these commands: the size of the diagnostics area. This concept is specific to embedded SQL, and therefore is not implemented in the PostgreSQL server.</source>
          <target state="translated">標準SQLでは、これらのコマンドで設定できるトランザクション特性として、診断領域のサイズがあります。この概念は組み込みSQLに特有のものであり、PostgreSQLサーバには実装されていません。</target>
        </trans-unit>
        <trans-unit id="ed36ad7d98cb4d8fee32b855fb6fed744837b0e0" translate="yes" xml:space="preserve">
          <source>In the SQL-92 standard, an &lt;code&gt;ORDER BY&lt;/code&gt; clause can only use output column names or numbers, while a &lt;code&gt;GROUP BY&lt;/code&gt; clause can only use expressions based on input column names. PostgreSQL extends each of these clauses to allow the other choice as well (but it uses the standard's interpretation if there is ambiguity). PostgreSQL also allows both clauses to specify arbitrary expressions. Note that names appearing in an expression will always be taken as input-column names, not as output-column names.</source>
          <target state="translated">SQL-92標準では、 &lt;code&gt;ORDER BY&lt;/code&gt; 句は出力列名または数値のみを使用できますが、 &lt;code&gt;GROUP BY&lt;/code&gt; 句は入力列名に基づく式のみを使用できます。 PostgreSQLはこれらの各句を拡張して、他の選択も可能にします（ただし、あいまいな場合は標準の解釈を使用します）。 PostgreSQLでは、両方の句で任意の式を指定することもできます。式に現れる名前は、常に出力列名としてではなく、入力列名として解釈されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b054bfec2bce610e705197d361e44d3c2768bb83" translate="yes" xml:space="preserve">
          <source>In the XQuery/XPath data model, a &lt;em&gt;document node&lt;/em&gt; can have either document form (i.e., exactly one top-level element, with only comments and processing instructions outside of it) or content form (with those constraints relaxed). Its equivalent in XPath 1.0, the &lt;em&gt;root node&lt;/em&gt;, can only be in document form. This is part of the reason an &lt;code&gt;xml&lt;/code&gt; value passed as the context item to any PostgreSQL XPath-based function must be in document form.</source>
          <target state="translated">XQuery / XPathデータモデルでは、&lt;em&gt;ドキュメントノード&lt;/em&gt;はドキュメントフォーム（つまり、コメントと処理命令のみが含まれる1つの最上位要素）またはコンテンツフォーム（制約が緩和されたもの）のいずれかを持つことができます。XPath 1.0での同等の&lt;em&gt;ルートノードは&lt;/em&gt;、ドキュメント形式にすることができ&lt;em&gt;ます&lt;/em&gt;。これは、PostgreSQL XPathベースの関数にコンテキスト項目として渡される &lt;code&gt;xml&lt;/code&gt; 値がドキュメント形式でなければならない理由の一部です。</target>
        </trans-unit>
        <trans-unit id="907c04147bb1d71b5f0459b5e753db080d794777" translate="yes" xml:space="preserve">
          <source>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">上記の例では、毎月新しいパーティションを作成しているので、必要なDDLを自動的に生成するスクリプトを書くのが賢明かもしれません。</target>
        </trans-unit>
        <trans-unit id="652407089ebdeac3fe06a048bf54ac1385a35fc9" translate="yes" xml:space="preserve">
          <source>In the above example, the new password isn't actually echoed when typed, but we show what was typed for clarity. As you see, the password is encrypted before it is sent to the client.</source>
          <target state="translated">上の例では、新しいパスワードが入力されても実際にはエコーされませんが、わかりやすくするために入力された内容を表示しています。ご覧のように、パスワードはクライアントに送信される前に暗号化されています。</target>
        </trans-unit>
        <trans-unit id="a28671e837ffe13c54dd539a74a6f7de604de65e" translate="yes" xml:space="preserve">
          <source>In the above output, the free space figures may not match the &lt;code&gt;pgstattuple&lt;/code&gt; output exactly, because the free space map gives us an exact figure, but is not guaranteed to be accurate to the byte.</source>
          <target state="translated">上記の出力では、フリースペースマップは正確な数値を提供しますが、バイトに対して正確であることが保証されていないため、フリースペースの数値は &lt;code&gt;pgstattuple&lt;/code&gt; の出力と正確に一致しない場合があります。</target>
        </trans-unit>
        <trans-unit id="cfee998fb713aa32e0b0a461f86fb14fa87aa018" translate="yes" xml:space="preserve">
          <source>In the above queries, the second form is dangerous because the &lt;code&gt;LIMIT&lt;/code&gt; is not guaranteed to be applied before the locking function is executed. This might cause some locks to be acquired that the application was not expecting, and hence would fail to release (until it ends the session). From the point of view of the application, such locks would be dangling, although still viewable in &lt;code&gt;pg_locks&lt;/code&gt;.</source>
          <target state="translated">上記のクエリでは、ロック関数が実行される前に &lt;code&gt;LIMIT&lt;/code&gt; が適用されることが保証されていないため、2番目の形式は危険です。これにより、アプリケーションが予期していなかったいくつかのロックが取得される可能性があり、そのため（セッションが終了するまで）解放に失敗します。アプリケーションの観点から見ると、このようなロックはぶら下がっていますが、 &lt;code&gt;pg_locks&lt;/code&gt; では引き続き表示されます。</target>
        </trans-unit>
        <trans-unit id="0422400fe004db1267465196296a34921629ca1c" translate="yes" xml:space="preserve">
          <source>In the above query, the arguments &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are specified positionally, while &lt;code&gt;uppercase&lt;/code&gt; is specified by name. In this example, that adds little except documentation. With a more complex function having numerous parameters that have default values, named or mixed notation can save a great deal of writing and reduce chances for error.</source>
          <target state="translated">上記のクエリでは、引数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は位置的に指定されてい &lt;code&gt;uppercase&lt;/code&gt; が、大文字は名前で指定されています。この例では、ドキュメント以外はほとんど追加されていません。デフォルト値を持つ多数のパラメーターを持つより複雑な関数を使用すると、名前付き表記または混合表記により、大量の書き込みを節約し、エラーの可能性を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="523e1fdbf28526b9fd09539320b970501acbeb30" translate="yes" xml:space="preserve">
          <source>In the absence of any explicit quantifier, the default for a star symbol is to match any number of labels (that is, &lt;code&gt;{,}&lt;/code&gt;) while the default for a non-star item is to match exactly once (that is, &lt;code&gt;{1}&lt;/code&gt;).</source>
          <target state="translated">明示的な数量詞がない場合、スター記号のデフォルトは任意の数のラベル（つまり、 &lt;code&gt;{,}&lt;/code&gt; ）に一致し、スター以外のアイテムのデフォルトは1回だけ一致します（つまり、 &lt;code&gt;{1}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="12fe4f57925256d624bd6eb274cf2330b45da284" translate="yes" xml:space="preserve">
          <source>In the absence of fatal errors, pg_receivewal will run until terminated by the SIGINT signal (&lt;strong&gt;Control&lt;/strong&gt;+&lt;strong&gt;C&lt;/strong&gt;).</source>
          <target state="translated">致命的なエラーがない場合、pg_receivewalはSIGINTシグナル（&lt;strong&gt;Control&lt;/strong&gt; + &lt;strong&gt;C&lt;/strong&gt;）によって終了されるまで実行されます。</target>
        </trans-unit>
        <trans-unit id="e6c9650fa107be76e508c9f6a766e1575673cf8c" translate="yes" xml:space="preserve">
          <source>In the alternative format:</source>
          <target state="translated">代替フォーマットで</target>
        </trans-unit>
        <trans-unit id="c2e1ceee33301b36828cf2caae1f68eec137b740" translate="yes" xml:space="preserve">
          <source>In the case of a parallel dump, the snapshot name defined by this option is used rather than taking a new snapshot.</source>
          <target state="translated">並列ダンプの場合、新しいスナップショットを取るのではなく、このオプションで定義されたスナップショット名が使用されます。</target>
        </trans-unit>
        <trans-unit id="2a04ddae39deed0bb63ddc81c6701d5c2ad86b55" translate="yes" xml:space="preserve">
          <source>In the case of a partitioned table, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation.</source>
          <target state="translated">パーティション化されたテーブルの場合、行を更新すると、それが含まれているパーティションのパーティション制約を満たさなくなる可能性があります。その場合、この行がそのパーティション制約を満たすパーティションツリーに他のパーティションがある場合、行はそのパーティションに移動されます。そのようなパーティションがない場合、エラーが発生します。舞台裏では、行の移動は実際には &lt;code&gt;DELETE&lt;/code&gt; および &lt;code&gt;INSERT&lt;/code&gt; 操作です。</target>
        </trans-unit>
        <trans-unit id="5544906e3d293a0a9ad12a92567f1204d11f1dd6" translate="yes" xml:space="preserve">
          <source>In the case of an exclusion constraint, &lt;code&gt;conkey&lt;/code&gt; is only useful for constraint elements that are simple column references. For other cases, a zero appears in &lt;code&gt;conkey&lt;/code&gt; and the associated index must be consulted to discover the expression that is constrained. (&lt;code&gt;conkey&lt;/code&gt; thus has the same contents as &lt;code&gt;pg_index&lt;/code&gt;.&lt;code&gt;indkey&lt;/code&gt; for the index.)</source>
          <target state="translated">除外制約の場合、 &lt;code&gt;conkey&lt;/code&gt; は単純な列参照である制約要素にのみ役立ちます。その他の場合、 &lt;code&gt;conkey&lt;/code&gt; にゼロが表示され、制約されている式を見つけるために関連するインデックスを調べる必要があります。（ &lt;code&gt;conkey&lt;/code&gt; は従って同様の内容を有する &lt;code&gt;pg_index&lt;/code&gt; 。 &lt;code&gt;indkey&lt;/code&gt; インデックスために）。</target>
        </trans-unit>
        <trans-unit id="e4fef774ebd3ff2e38db3236bd03a350ace1f35c" translate="yes" xml:space="preserve">
          <source>In the common case where you just want the whole matching substring or &lt;code&gt;NULL&lt;/code&gt; for no match, write something like</source>
          <target state="translated">一致する部分文字列全体または一致しない場合は &lt;code&gt;NULL&lt;/code&gt; が必要な一般的なケースでは、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="d8de3d9b49ffb3cc570c884fc7d3dde953f8a262" translate="yes" xml:space="preserve">
          <source>In the context of &lt;code&gt;INSERT&lt;/code&gt;, entries of a &lt;code&gt;VALUES&lt;/code&gt; list can be &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the column default should be used here instead of specifying a value:</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; のコンテキストでは、 &lt;code&gt;VALUES&lt;/code&gt; リストのエントリを &lt;code&gt;DEFAULT&lt;/code&gt; にして、値を指定する代わりに列のデフォルトをここで使用する必要があることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="0a8a6bb89f9ea4433f27de55629e036adfed0508" translate="yes" xml:space="preserve">
          <source>In the current implementation, the fitness of each candidate join sequence is estimated by running the standard planner's join selection and cost estimation code from scratch. To the extent that different candidates use similar sub-sequences of joins, a great deal of work will be repeated. This could be made significantly faster by retaining cost estimates for sub-joins. The problem is to avoid expending unreasonable amounts of memory on retaining that state.</source>
          <target state="translated">現在の実装では、各候補の結合シーケンスの適合性は、標準プランナーの結合選択とコスト推定コードをスクラッチから実行することで推定されます。異なる候補が類似した部分結合列を使用する範囲では、多くの作業が繰り返されます。これは、部分結合のコスト見積もりを保持することで、大幅に高速化することができます。問題は、その状態を保持するために不合理な量のメモリを消費しないようにすることです。</target>
        </trans-unit>
        <trans-unit id="7b88d112fefbb18a9a94530a4a12e322eca2805d" translate="yes" xml:space="preserve">
          <source>In the default PostgreSQL configuration, the autovacuum daemon (see &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;) takes care of automatic analyzing of tables when they are first loaded with data, and as they change throughout regular operation. When autovacuum is disabled, it is a good idea to run &lt;code&gt;ANALYZE&lt;/code&gt; periodically, or just after making major changes in the contents of a table. Accurate statistics will help the planner to choose the most appropriate query plan, and thereby improve the speed of query processing. A common strategy for read-mostly databases is to run &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; once a day during a low-usage time of day. (This will not be sufficient if there is heavy update activity.)</source>
          <target state="translated">デフォルトのPostgreSQL構成では、autovacuumデーモン（&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6を&lt;/a&gt;参照）は、テーブルに最初にデータがロードされたとき、および通常の操作を通じて変更されるときに、テーブルの自動分析を処理します。自動バキュームが無効になっている場合は、定期的に、またはテーブルの内容に大きな変更を加えた直後に &lt;code&gt;ANALYZE&lt;/code&gt; を実行することをお勧めします。正確な統計は、プランナが最も適切なクエリプランを選択するのに役立ち、クエリ処理の速度を向上させます。 read-mostlyデータベースの一般的な戦略は、1日1回、使用率の低い時間帯に&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;と &lt;code&gt;ANALYZE&lt;/code&gt; を実行することです。 （これは、大量の更新アクティビティがある場合は十分ではありません。）</target>
        </trans-unit>
        <trans-unit id="4ce2b63a8b5343bbf7125e0114e2a04ce0d2bde8" translate="yes" xml:space="preserve">
          <source>In the default setup this returns:</source>
          <target state="translated">デフォルトの設定では、この値が返されます。</target>
        </trans-unit>
        <trans-unit id="596bcd2b70e5eeabccdcbaf0d79d2c517c798e21" translate="yes" xml:space="preserve">
          <source>In the event of a binary upgrade, upward compatibility is maintained by having the new code recognize old-format data. This will entail a slight performance penalty when processing data that has not yet been modified by the new code. It is possible to force an upgrade of all values in a table column by doing an &lt;code&gt;UPDATE&lt;/code&gt; statement as follows:</source>
          <target state="translated">バイナリアップグレードの場合、新しいコードに古い形式のデータを認識させることにより、上位互換性が維持されます。これにより、新しいコードによってまだ変更されていないデータを処理するときに、パフォーマンスがわずかに低下します。次のように &lt;code&gt;UPDATE&lt;/code&gt; ステートメントを実行すると、テーブル列のすべての値を強制的にアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="b3a7ad5f630b85b752ae07e66abff996aa3b1a24" translate="yes" xml:space="preserve">
          <source>In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is &lt;em&gt;greedy&lt;/em&gt; or &lt;em&gt;non-greedy&lt;/em&gt;.</source>
          <target state="translated">REが特定の文字列の複数の部分文字列に一致する可能性がある場合、REは文字列の最初の文字列に一致します。REは、その時点で始まるサブストリングつ以上一致することができれば、可能な最長一致もしくは最短一致のいずれかをREであるかどうかに応じて、取られる&lt;em&gt;貪欲&lt;/em&gt;または&lt;em&gt;非貪欲&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="474b9960977cbbea61dc4ac5b333f0b736c6264c" translate="yes" xml:space="preserve">
          <source>In the example above we see that the resulting &lt;code&gt;tsvector&lt;/code&gt; does not contain the words &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, or &lt;code&gt;it&lt;/code&gt;, the word &lt;code&gt;rats&lt;/code&gt; became &lt;code&gt;rat&lt;/code&gt;, and the punctuation sign &lt;code&gt;-&lt;/code&gt; was ignored.</source>
          <target state="translated">上記の例では、結果の &lt;code&gt;tsvector&lt;/code&gt; に &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;on&lt;/code&gt; 、または &lt;code&gt;it&lt;/code&gt; という単語が含まれておらず、 &lt;code&gt;rats&lt;/code&gt; という単語が &lt;code&gt;rat&lt;/code&gt; になり、句読記号 &lt;code&gt;-&lt;/code&gt; が無視されたことがわかります。</target>
        </trans-unit>
        <trans-unit id="200ce56337643046a5aa2dd5558bb50f57584421" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;WHERE&lt;/code&gt; clause is selecting rows by a column that is not grouped (the expression is only true for sales during the last four weeks), while the &lt;code&gt;HAVING&lt;/code&gt; clause restricts the output to groups with total gross sales over 5000. Note that the aggregate expressions do not necessarily need to be the same in all parts of the query.</source>
          <target state="translated">上記の例では、 &lt;code&gt;WHERE&lt;/code&gt; 句はグループ化されていない列によって行を選択しています（式は過去4週間の売上高にのみ当てはまります）が、 &lt;code&gt;HAVING&lt;/code&gt; 句は総売上高が5000を超えるグループに出力を制限します。集計式は必ずしもクエリのすべての部分で同じである必要はありません。</target>
        </trans-unit>
        <trans-unit id="31c0dc4f6c95bec1ccb804da7ba6806c38ecea92" translate="yes" xml:space="preserve">
          <source>In the example above, the working table has just a single row in each step, and it takes on the values from 1 through 100 in successive steps. In the 100th step, there is no output because of the &lt;code&gt;WHERE&lt;/code&gt; clause, and so the query terminates.</source>
          <target state="translated">上記の例では、作業テーブルには各ステップで1つの行しかなく、連続するステップで1から100までの値を取ります。 100番目のステップでは、 &lt;code&gt;WHERE&lt;/code&gt; 句のために出力がないため、クエリは終了します。</target>
        </trans-unit>
        <trans-unit id="652a8b18a910fe23a9af73c94ce5d441558f1e6b" translate="yes" xml:space="preserve">
          <source>In the examples above, the parser sees an integer array on one side of the concatenation operator, and a constant of undetermined type on the other. The heuristic it uses to resolve the constant's type is to assume it's of the same type as the operator's other input &amp;mdash; in this case, integer array. So the concatenation operator is presumed to represent &lt;code&gt;array_cat&lt;/code&gt;, not &lt;code&gt;array_append&lt;/code&gt;. When that's the wrong choice, it could be fixed by casting the constant to the array's element type; but explicit use of &lt;code&gt;array_append&lt;/code&gt; might be a preferable solution.</source>
          <target state="translated">上記の例では、パーサーは連結演算子の一方の側に整数配列を、もう一方の側に不定型の定数を認識しています。定数の型を解決するために使用するヒューリスティックは、定数が演算子の他の入力と同じ型（この場合は整数配列）であると想定することです。したがって、連結演算子は &lt;code&gt;array_cat&lt;/code&gt; ではなく &lt;code&gt;array_append&lt;/code&gt; を表すと想定されます。それが間違った選択である場合、定数を配列の要素型にキャストすることで修正できます。ただし、 &lt;code&gt;array_append&lt;/code&gt; を明示的に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cfb28c6ea0190f478c6d1ce0ce5ab123177f2281" translate="yes" xml:space="preserve">
          <source>In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub-&lt;code&gt;SELECT&lt;/code&gt;s, or functions that contain &lt;code&gt;SELECT&lt;/code&gt;s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:</source>
          <target state="translated">上記の例では、ポリシー式は、行内の現在の値のみがアクセスまたは更新されると見なします。これは最も単純で最もパフォーマンスの高いケースです。可能であれば、この方法で機能するように行セキュリティアプリケーションを設計することをお勧めします。ポリシーの決定を行うために他の行または他のテーブルを調べる必要がある場合は、ポリシー式でサブ &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;SELECT&lt;/code&gt; を含む関数を使用して実行できます。ただし、このようなアクセスは競合状態を引き起こし、注意を怠ると情報漏えいを引き起こす可能性があることに注意してください。例として、次のテーブルデザインを考えます。</target>
        </trans-unit>
        <trans-unit id="2808c388963b5d35c9a7c014fc0aef8465d89479" translate="yes" xml:space="preserve">
          <source>In the examples that follow, we assume that you have created a database named &lt;code&gt;mydb&lt;/code&gt;, as described in the previous chapter, and have been able to start psql.</source>
          <target state="translated">次の例では、前の章で説明したように &lt;code&gt;mydb&lt;/code&gt; という名前のデータベースを作成し、psqlを起動できたと想定しています。</target>
        </trans-unit>
        <trans-unit id="4bb59306b891fbea63056e89cb36560d344851b8" translate="yes" xml:space="preserve">
          <source>In the first case, the RE as a whole is greedy because &lt;code&gt;Y*&lt;/code&gt; is greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the longest possible string starting there, i.e., &lt;code&gt;Y123&lt;/code&gt;. The output is the parenthesized part of that, or &lt;code&gt;123&lt;/code&gt;. In the second case, the RE as a whole is non-greedy because &lt;code&gt;Y*?&lt;/code&gt; is non-greedy. It can match beginning at the &lt;code&gt;Y&lt;/code&gt;, and it matches the shortest possible string starting there, i.e., &lt;code&gt;Y1&lt;/code&gt;. The subexpression &lt;code&gt;[0-9]{1,3}&lt;/code&gt; is greedy but it cannot change the decision as to the overall match length; so it is forced to match just &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">最初のケースでは、 &lt;code&gt;Y*&lt;/code&gt; は貪欲であるため、REは全体として貪欲です。 &lt;code&gt;Y&lt;/code&gt; から始まり、そこから始まる可能な限り長い文字列、つまり &lt;code&gt;Y123&lt;/code&gt; に一致します。出力は、括弧で囲まれた部分、つまり &lt;code&gt;123&lt;/code&gt; です。 2番目のケースでは、REは &lt;code&gt;Y*?&lt;/code&gt; ため、全体として貪欲ではありません。貪欲ではありません。 &lt;code&gt;Y&lt;/code&gt; から始まり、 &lt;code&gt;Y1&lt;/code&gt; から始まる可能な限り短い文字列に一致します。部分式 &lt;code&gt;[0-9]{1,3}&lt;/code&gt; は貪欲ですが、全体の一致の長さに関する決定を変更することはできません。したがって、 &lt;code&gt;1&lt;/code&gt; にのみ一致することが強制されます。</target>
        </trans-unit>
        <trans-unit id="0afff82ca92cc5d65344944313d08b5825c3e875" translate="yes" xml:space="preserve">
          <source>In the first place, &lt;em&gt;never&lt;/em&gt; believe any test that runs for only a few seconds. Use the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-T&lt;/code&gt; option to make the run last at least a few minutes, so as to average out noise. In some cases you could need hours to get numbers that are reproducible. It's a good idea to try the test run a few times, to find out if your numbers are reproducible or not.</source>
          <target state="translated">まず第一に、&lt;em&gt;決して&lt;/em&gt;ほんの数秒間実行するすべてのテストを信じていません。 &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;-T&lt;/code&gt; オプションを使用して、実行を少なくとも数分持続させ、ノイズを平均化します。場合によっては、再現可能な数値を取得するのに数時間かかることがあります。数回テストを実行して、数値が再現可能かどうかを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d312d02ebaa05f528de247ffd592135c96644932" translate="yes" xml:space="preserve">
          <source>In the first string, the set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt;. In the second string, the ordered set of trigrams is &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;. The most similar extent of an ordered set of trigrams in the second string is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt;, and the similarity is &lt;code&gt;0.8&lt;/code&gt;.</source>
          <target state="translated">最初の文字列では、トライグラムのセットは &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rd &quot;}&lt;/code&gt; です。 2番目の文字列では、順序付けられたトライグラムのセットは &lt;code&gt;{&quot; t&quot;,&quot; tw&quot;,&quot;two&quot;,&quot;wo &quot;,&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; 。2番目の文字列内の順序付けられたトライグラムのセットの最も類似した範囲は &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;}&lt;/code&gt; であり、類似度は &lt;code&gt;0.8&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="56225072f8eae4ad3b64ee516719e58b357f9e0a" translate="yes" xml:space="preserve">
          <source>In the following explanation, a &lt;em&gt;byte&lt;/em&gt; is assumed to contain 8 bits. In addition, the term &lt;em&gt;item&lt;/em&gt; refers to an individual data value that is stored on a page. In a table, an item is a row; in an index, an item is an index entry.</source>
          <target state="translated">以下の説明では、1 &lt;em&gt;バイト&lt;/em&gt;は8ビットを含むと想定しています。さらに、&lt;em&gt;アイテム&lt;/em&gt;という用語は、ページに格納される個々のデータ値を指します。テーブルでは、アイテムは行です。インデックスでは、アイテムはインデックスエントリです。</target>
        </trans-unit>
        <trans-unit id="fe808d43052245254bcdc480fec58d6c194f111b" translate="yes" xml:space="preserve">
          <source>In the following sections we will cover each of the above listed items in more detail to give a better understanding of PostgreSQL's internal control and data structures.</source>
          <target state="translated">以下のセクションでは、PostgreSQLの内部制御とデータ構造をよりよく理解するために、上記の各項目をより詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="f022f75654e730419aa401f110023452d899d615" translate="yes" xml:space="preserve">
          <source>In the following we describe the implementation of a &lt;em&gt;genetic algorithm&lt;/em&gt; to solve the join ordering problem in a manner that is efficient for queries involving large numbers of joins.</source>
          <target state="translated">以下では、多数の結合を含むクエリに対して効率的な方法で結合順序の問題を解決するための&lt;em&gt;遺伝的アルゴリズムの&lt;/em&gt;実装について説明します。</target>
        </trans-unit>
        <trans-unit id="294ebe645001a682897e9beebf5caf16a1bf1ca5" translate="yes" xml:space="preserve">
          <source>In the general case where more than one field needs to be checked to recognize a cycle, use an array of rows. For example, if we needed to compare fields &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:</source>
          <target state="translated">サイクルを認識するために複数のフィールドをチェックする必要がある一般的なケースでは、行の配列を使用します。たとえば、フィールド &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;f2&lt;/code&gt; を比較する必要がある場合：</target>
        </trans-unit>
        <trans-unit id="919090babfd7b1e0453e16ae1bb909dd12feef28" translate="yes" xml:space="preserve">
          <source>In the old syntax for &lt;code&gt;CREATE AGGREGATE&lt;/code&gt;, the input data type is specified by a &lt;code&gt;basetype&lt;/code&gt; parameter rather than being written next to the aggregate name. Note that this syntax allows only one input parameter. To define a zero-argument aggregate function with this syntax, specify the &lt;code&gt;basetype&lt;/code&gt; as &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; (not &lt;code&gt;*&lt;/code&gt;). Ordered-set aggregates cannot be defined with the old syntax.</source>
          <target state="translated">&lt;code&gt;CREATE AGGREGATE&lt;/code&gt; の古い構文では、入力データ型は、集約名の横に書き込まれるのではなく、 &lt;code&gt;basetype&lt;/code&gt; パラメーターによって指定されます。この構文では1つの入力パラメーターしか使用できないことに注意してください。この構文で引数なしの集計関数を定義するには、 &lt;code&gt;basetype&lt;/code&gt; を（ &lt;code&gt;*&lt;/code&gt; ではなく） &lt;code&gt;&quot;ANY&quot;&lt;/code&gt; として指定します。順序付き集合の集計は、古い構文では定義できません。</target>
        </trans-unit>
        <trans-unit id="405922ab6e8351d0cf2aca13f11379b1afd63c78" translate="yes" xml:space="preserve">
          <source>In the previous chapter we have covered the basics of using SQL to store and access your data in PostgreSQL. We will now discuss some more advanced features of SQL that simplify management and prevent loss or corruption of your data. Finally, we will look at some PostgreSQL extensions.</source>
          <target state="translated">前の章では、SQLを使用してPostgreSQLにデータを保存し、アクセスするための基本を説明しました。ここでは、管理を簡素化し、データの損失や破損を防ぐためのSQLのより高度な機能について説明します。最後に、PostgreSQLの拡張機能について見ていきます。</target>
        </trans-unit>
        <trans-unit id="a8c0fa4c3a367177ef284ccecde1c150bc096697" translate="yes" xml:space="preserve">
          <source>In the previous example, we can apply the city name restriction in &lt;code&gt;WHERE&lt;/code&gt;, since it needs no aggregate. This is more efficient than adding the restriction to &lt;code&gt;HAVING&lt;/code&gt;, because we avoid doing the grouping and aggregate calculations for all rows that fail the &lt;code&gt;WHERE&lt;/code&gt; check.</source>
          <target state="translated">前の例では、集約が必要ないため、 &lt;code&gt;WHERE&lt;/code&gt; で都市名の制限を適用できます。これは、 &lt;code&gt;HAVING&lt;/code&gt; に制限を追加するよりも効率的です。これは、 &lt;code&gt;WHERE&lt;/code&gt; チェックに失敗したすべての行に対してグループ化と集計の計算を行わないためです。</target>
        </trans-unit>
        <trans-unit id="9f29ede0900e9fd39d495275c897cbd33557a707" translate="yes" xml:space="preserve">
          <source>In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named &amp;ldquo;public&amp;rdquo;. Every new database contains such a schema. Thus, the following are equivalent:</source>
          <target state="translated">前のセクションでは、スキーマ名を指定せずにテーブルを作成しました。デフォルトでは、このようなテーブル（およびその他のオブジェクト）は自動的に「public」というスキーマに入れられます。すべての新しいデータベースには、そのようなスキーマが含まれています。したがって、以下は同等です。</target>
        </trans-unit>
        <trans-unit id="0e8d742b91769afdfb8fcfcc89d91cd8ba42839b" translate="yes" xml:space="preserve">
          <source>In the remote sessions opened by &lt;code&gt;postgres_fdw&lt;/code&gt;, the &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; parameter is set to just &lt;code&gt;pg_catalog&lt;/code&gt;, so that only built-in objects are visible without schema qualification. This is not an issue for queries generated by &lt;code&gt;postgres_fdw&lt;/code&gt; itself, because it always supplies such qualification. However, this can pose a hazard for functions that are executed on the remote server via triggers or rules on remote tables. For example, if a remote table is actually a view, any functions used in that view will be executed with the restricted search path. It is recommended to schema-qualify all names in such functions, or else attach &lt;code&gt;SET search_path&lt;/code&gt; options (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;) to such functions to establish their expected search path environment.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; によって開かれたリモートセッションでは、&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;パラメータが &lt;code&gt;pg_catalog&lt;/code&gt; だけに設定されているため、スキーマ修飾なしで組み込みオブジェクトのみが表示されます。これは常に &lt;code&gt;postgres_fdw&lt;/code&gt; 自体によって生成されるクエリの問題ではありません。なぜなら、このような修飾が常に提供されるためです。ただし、これは、リモートテーブルのトリガーまたはルールを介してリモートサーバーで実行される関数に危険をもたらす可能性があります。たとえば、リモートテーブルが実際にビューである場合、そのビューで使用されるすべての関数は、制限された検索パスで実行されます。そのような関数のすべての名前をスキーマ修飾するか、 &lt;code&gt;SET search_path&lt;/code&gt; オプションをアタッチすることをお勧めします（&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONを&lt;/a&gt;参照））そのような機能に期待される検索パス環境を確立する。</target>
        </trans-unit>
        <trans-unit id="251756f685410e433b657f5b30520cf41b101c14" translate="yes" xml:space="preserve">
          <source>In the same connection as before, issue the command:</source>
          <target state="translated">先ほどと同じ接続で、コマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="9a85cd84a5c1ae886a05b3cc6a64ec7fb7c99a58" translate="yes" xml:space="preserve">
          <source>In the second form of &lt;code&gt;ALTER POLICY&lt;/code&gt;, the role list, &lt;code&gt;using_expression&lt;/code&gt;, and &lt;code&gt;check_expression&lt;/code&gt; are replaced independently if specified. When one of those clauses is omitted, the corresponding part of the policy is unchanged.</source>
          <target state="translated">&lt;code&gt;ALTER POLICY&lt;/code&gt; の 2番目の形式では、ロールリスト、 &lt;code&gt;using_expression&lt;/code&gt; 、および &lt;code&gt;check_expression&lt;/code&gt; が指定されている場合、個別に置き換えられます。これらの句のいずれかが省略された場合、ポリシーの対応する部分は変更されません。</target>
        </trans-unit>
        <trans-unit id="2c142401003467ed2967cc5251153e2a0bab24fa" translate="yes" xml:space="preserve">
          <source>In the second mode, which we will call the search+bind mode, the server first binds to the LDAP directory with a fixed user name and password, specified with &lt;code&gt;ldapbinddn&lt;/code&gt; and &lt;code&gt;ldapbindpasswd&lt;/code&gt;, and performs a search for the user trying to log in to the database. If no user and password is configured, an anonymous bind will be attempted to the directory. The search will be performed over the subtree at &lt;code&gt;ldapbasedn&lt;/code&gt;, and will try to do an exact match of the attribute specified in &lt;code&gt;ldapsearchattribute&lt;/code&gt;. Once the user has been found in this search, the server disconnects and re-binds to the directory as this user, using the password specified by the client, to verify that the login is correct. This mode is the same as that used by LDAP authentication schemes in other software, such as Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; and &lt;code&gt;pam_ldap&lt;/code&gt;. This method allows for significantly more flexibility in where the user objects are located in the directory, but will cause two separate connections to the LDAP server to be made.</source>
          <target state="translated">検索+バインドモードと呼ばれる2番目のモードでは、サーバーは最初に、 &lt;code&gt;ldapbinddn&lt;/code&gt; および &lt;code&gt;ldapbindpasswd&lt;/code&gt; で指定された固定ユーザー名とパスワードを使用してLDAPディレクトリにバインドし、ログインしようとしているユーザーの検索を実行します。データベース。ユーザーとパスワードが設定されていない場合、匿名バインドがディレクトリに試行されます。検索は &lt;code&gt;ldapbasedn&lt;/code&gt; のサブツリーに対して実行され、 &lt;code&gt;ldapsearchattribute&lt;/code&gt; で指定された属性の完全一致を試みます。この検索で​​ユーザーが見つかると、サーバーは接続を切断し、クライアントが指定したパスワードを使用してこのユーザーとしてディレクトリに再バインドし、ログインが正しいことを確認します。このモードは、Apache &lt;code&gt;mod_authnz_ldap&lt;/code&gt; や &lt;code&gt;pam_ldap&lt;/code&gt; などの他のソフトウェアのLDAP認証方式で使用されるモードと同じです。この方法では、ユーザーオブジェクトをディレクトリに配置する際の柔軟性が大幅に向上しますが、LDAPサーバーへの2つの別々の接続が行われます。</target>
        </trans-unit>
        <trans-unit id="138833bfe13a3d8412530f69bb62c741e625ccde" translate="yes" xml:space="preserve">
          <source>In the second query, we could not have written &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt;, because there is no single value for the column &lt;code&gt;y&lt;/code&gt; that could be associated with each group. The grouped-by columns can be referenced in the select list since they have a single value in each group.</source>
          <target state="translated">2番目のクエリでは、各グループに関連付けることができる列 &lt;code&gt;y&lt;/code&gt; の単一の値がないため、 &lt;code&gt;SELECT * FROM test1 GROUP BY x&lt;/code&gt; を書き込むことができませんでした。グループ化された列は、各グループに単一の値を持つため、選択リストで参照できます。</target>
        </trans-unit>
        <trans-unit id="a3f53fb06ae3c0e076406bae29678cb14017000e" translate="yes" xml:space="preserve">
          <source>In the standard, it is not necessary to issue &lt;code&gt;START TRANSACTION&lt;/code&gt; to start a transaction block: any SQL command implicitly begins a block. PostgreSQL's behavior can be seen as implicitly issuing a &lt;code&gt;COMMIT&lt;/code&gt; after each command that does not follow &lt;code&gt;START TRANSACTION&lt;/code&gt; (or &lt;code&gt;BEGIN&lt;/code&gt;), and it is therefore often called &amp;ldquo;autocommit&amp;rdquo;. Other relational database systems might offer an autocommit feature as a convenience.</source>
          <target state="translated">標準では、トランザクションブロックを開始するために &lt;code&gt;START TRANSACTION&lt;/code&gt; を発行する必要はありません。SQLコマンドは暗黙的にブロックを開始します。PostgreSQLの動作は、 &lt;code&gt;START TRANSACTION&lt;/code&gt; （または &lt;code&gt;BEGIN&lt;/code&gt; ）に続かない各コマンドの後に暗黙的に &lt;code&gt;COMMIT&lt;/code&gt; を発行するものと見なすことができるため、しばしば「自動コミット」と呼ばれます。他のリレーショナルデータベースシステムでは、便宜上、自動コミット機能が提供されている場合があります。</target>
        </trans-unit>
        <trans-unit id="127829a1cca08de1cd77d4d1d0c73fe0bf22ed39" translate="yes" xml:space="preserve">
          <source>In the standard, the &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; clause is required; in PostgreSQL it is optional.</source>
          <target state="translated">標準では、 &lt;code&gt;WITH [ NO ] DATA&lt;/code&gt; 句は必須です。PostgreSQLではオプションです。</target>
        </trans-unit>
        <trans-unit id="7f27aa8e0141e367b925aa8c528ef6250799f203" translate="yes" xml:space="preserve">
          <source>In the strict mode, the specified path must exactly match the structure of the queried JSON document to return an SQL/JSON item, so using this path expression will cause an error. To get the same result as in the lax mode, you have to explicitly unwrap the &lt;code&gt;segments&lt;/code&gt; array:</source>
          <target state="translated">厳密モードでは、SQL / JSONアイテムを返すには、指定されたパスがクエリされたJSONドキュメントの構造と正確に一致する必要があるため、このパス式を使用するとエラーが発生します。laxモードと同じ結果を得るには、 &lt;code&gt;segments&lt;/code&gt; 配列を明示的にアンラップする必要があります。</target>
        </trans-unit>
        <trans-unit id="351d4063e5553403441da5e92374ad1230527978" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; の構文では、キーワード &lt;code&gt;FUNCTION&lt;/code&gt; と &lt;code&gt;PROCEDURE&lt;/code&gt; は同等ですが、参照される関数は、いずれの場合もプロシージャではなく関数でなければなりません。ここでのキーワード &lt;code&gt;PROCEDURE&lt;/code&gt; の使用は歴史的なものであり、非推奨です。</target>
        </trans-unit>
        <trans-unit id="78472b8a63814954829d3aaff5becf4efc83edf2" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE OPERATOR&lt;/code&gt; の構文では、キーワード &lt;code&gt;FUNCTION&lt;/code&gt; と &lt;code&gt;PROCEDURE&lt;/code&gt; は同等ですが、参照される関数はいずれの場合もプロシージャではなく関数でなければなりません。ここでのキーワード &lt;code&gt;PROCEDURE&lt;/code&gt; の使用は歴史的なものであり、非推奨です。</target>
        </trans-unit>
        <trans-unit id="57ba8dd34e548ca54ffce2f60f391e867e594c9e" translate="yes" xml:space="preserve">
          <source>In the syntax of &lt;code&gt;CREATE TRIGGER&lt;/code&gt;, the keywords &lt;code&gt;FUNCTION&lt;/code&gt; and &lt;code&gt;PROCEDURE&lt;/code&gt; are equivalent, but the referenced function must in any case be a function, not a procedure. The use of the keyword &lt;code&gt;PROCEDURE&lt;/code&gt; here is historical and deprecated.</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; の構文では、キーワード &lt;code&gt;FUNCTION&lt;/code&gt; と &lt;code&gt;PROCEDURE&lt;/code&gt; は同等ですが、参照される関数は、いずれの場合もプロシージャではなく関数でなければなりません。ここでのキーワード &lt;code&gt;PROCEDURE&lt;/code&gt; の使用は歴史的なものであり、非推奨です。</target>
        </trans-unit>
        <trans-unit id="e9e4c8cc0471f863f66674a10b7573f32e28c279" translate="yes" xml:space="preserve">
          <source>In the text form of a range, an inclusive lower bound is represented by &amp;ldquo;&lt;code&gt;[&lt;/code&gt;&amp;rdquo; while an exclusive lower bound is represented by &amp;ldquo;&lt;code&gt;(&lt;/code&gt;&amp;rdquo;. Likewise, an inclusive upper bound is represented by &amp;ldquo;&lt;code&gt;]&lt;/code&gt;&amp;rdquo;, while an exclusive upper bound is represented by &amp;ldquo;&lt;code&gt;)&lt;/code&gt;&amp;rdquo;. (See &lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;Section 8.17.5&lt;/a&gt; for more details.)</source>
          <target state="translated">テキスト形式の範囲では、包括的下限は「 &lt;code&gt;[&lt;/code&gt; 」で表され、排他的下限は「 &lt;code&gt;(&lt;/code&gt; 」で表されます。同様に、包括的上限は「 &lt;code&gt;]&lt;/code&gt; 」で表され、排他的上限は表されます「 &lt;code&gt;)&lt;/code&gt; 」。 （詳細については、&lt;a href=&quot;rangetypes#RANGETYPES-IO&quot;&gt;セクション8.17.5&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="87e71fe4fdbdcfebf301c0661fd38f3ccfa52a22" translate="yes" xml:space="preserve">
          <source>In the verbose input format, and in some fields of the more compact input formats, field values can have fractional parts; for example &lt;code&gt;'1.5 week'&lt;/code&gt; or &lt;code&gt;'01:02:03.45'&lt;/code&gt;. Such input is converted to the appropriate number of months, days, and seconds for storage. When this would result in a fractional number of months or days, the fraction is added to the lower-order fields using the conversion factors 1 month = 30 days and 1 day = 24 hours. For example, &lt;code&gt;'1.5 month'&lt;/code&gt; becomes 1 month and 15 days. Only seconds will ever be shown as fractional on output.</source>
          <target state="translated">詳細な入力形式、およびよりコンパクトな入力形式の一部のフィールドでは、フィールド値に小数部を含めることができます。たとえば、 &lt;code&gt;'1.5 week'&lt;/code&gt; または「 &lt;code&gt;'01:02:03.45'&lt;/code&gt; 。そのような入力は、ストレージのために適切な月、日、秒の数に変換されます。その結果、月または日が小数になる場合、1か月= 30日および1日= 24時間の変換係数を使用して、小数が下位フィールドに追加されます。たとえば、 &lt;code&gt;'1.5 month'&lt;/code&gt; は1か月と15日になります。出力では、秒のみが小数として表示されます。</target>
        </trans-unit>
        <trans-unit id="352c1b7bd2689ed0c741aae1f8598e4432b2e419" translate="yes" xml:space="preserve">
          <source>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same.</source>
          <target state="translated">計測の世界では、6.50と6.5では 批判的に違うこともあります。実験者は通常、信頼できる数字を書き留めて(公開して)います。6.50は、実際には、より大きく、さらにファジーな6.5の中に含まれるファジーな区間であり、それらの中心点が(おそらく)唯一の共通の特徴です。このような異なるデータ項目が同じように見えることは絶対に避けたいものです。</target>
        </trans-unit>
        <trans-unit id="d16185ffce558efd6646fae1f89738ca57d3dd9c" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text string (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;.</source>
          <target state="translated">これらの式では、目的のタイムゾーン &lt;code&gt;zone&lt;/code&gt; をテキスト文字列（例： &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ）または間隔（例 &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; ）として指定できます。テキストの場合、タイムゾーン名は、&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3項&lt;/a&gt;で説明されている方法のいずれかで指定できます。</target>
        </trans-unit>
        <trans-unit id="ccebf94cbd61b9484dc9b7fa83da6e0dd760a88b" translate="yes" xml:space="preserve">
          <source>In these expressions, the desired time zone &lt;code&gt;zone&lt;/code&gt; can be specified either as a text value (e.g., &lt;code&gt;'America/Los_Angeles'&lt;/code&gt;) or as an interval (e.g., &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt;). In the text case, a time zone name can be specified in any of the ways described in &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt;. The interval case is only useful for zones that have fixed offsets from UTC, so it is not very common in practice.</source>
          <target state="translated">これらの式では、目的のタイムゾーン &lt;code&gt;zone&lt;/code&gt; をテキスト値（例： &lt;code&gt;'America/Los_Angeles'&lt;/code&gt; ）または間隔（例 &lt;code&gt;INTERVAL '-08:00'&lt;/code&gt; -08 ：00 '）として指定できます。テキストの場合、タイムゾーン名は&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;セクション8.5.3&lt;/a&gt;で説明されている任意の方法で指定できます。間隔の場合は、UTCからのオフセットが固定されているゾーンでのみ役立つため、実際にはあまり一般的ではありません。</target>
        </trans-unit>
        <trans-unit id="13d5bca14d2cfde080255e10973a28114214ea10" translate="yes" xml:space="preserve">
          <source>In this case the parser looks to see if there is an operator taking &lt;code&gt;text&lt;/code&gt; for both arguments. Since there is, it assumes that the second argument should be interpreted as type &lt;code&gt;text&lt;/code&gt;.</source>
          <target state="translated">この場合、パーサーは、両方の引数の &lt;code&gt;text&lt;/code&gt; を受け取る演算子があるかどうかを確認します。あるので、2番目の引数は &lt;code&gt;text&lt;/code&gt; 型として解釈されると想定しています。</target>
        </trans-unit>
        <trans-unit id="d2822670753f6c1107e46ff79d0892389494ad1a" translate="yes" xml:space="preserve">
          <source>In this case there is no MCV information for &lt;code&gt;unique2&lt;/code&gt; because all the values appear to be unique, so we use an algorithm that relies only on the number of distinct values for both relations together with their null fractions:</source>
          <target state="translated">この場合、すべての値が一意であるように見えるため、 &lt;code&gt;unique2&lt;/code&gt; のMCV情報はありません。そのため、両方のリレーションの個別の値の数とそれらのnull分数のみに依存するアルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="454dfb68a36b15232f0a47fef88c353fb8b457de" translate="yes" xml:space="preserve">
          <source>In this case there is no initial hint for which type to use, since no types are specified in the query. So, the parser looks for all candidate operators and finds that there are candidates accepting both string-category and bit-string-category inputs. Since string category is preferred when available, that category is selected, and then the preferred type for strings, &lt;code&gt;text&lt;/code&gt;, is used as the specific type to resolve the unknown-type literals as.</source>
          <target state="translated">この場合、クエリでタイプが指定されていないため、使用するタイプの初期ヒントはありません。したがって、パーサーはすべての候補演算子を探し、文字列カテゴリとビット文字列カテゴリの両方の入力を受け入れる候補があることを見つけます。利用可能な場合は文字列カテゴリが優先されるため、そのカテゴリが選択され、不明なタイプのリテラルを解決するための特定のタイプとして、文字列の優先タイプ &lt;code&gt;text&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="643fc82591ff3cc1a1f002cde4bff205b2405706" translate="yes" xml:space="preserve">
          <source>In this case, a regular user cannot reference &lt;code&gt;customer.credit&lt;/code&gt; directly, but a trusted procedure &lt;code&gt;show_credit&lt;/code&gt; allows the user to print the credit card numbers of customers with some of the digits masked out.</source>
          <target state="translated">この場合、通常のユーザーは &lt;code&gt;customer.credit&lt;/code&gt; を直接参照することはできませんが、信頼できるプロシージャ &lt;code&gt;show_credit&lt;/code&gt; を使用すると、一部の桁がマスクされた状態で顧客のクレジットカード番号を印刷できます。</target>
        </trans-unit>
        <trans-unit id="d737c289d22cb958cf827fb7f26271e5be10a1e7" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;altitude&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. State capitals have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">この場合、 &lt;code&gt;capitals&lt;/code&gt; 行は、その&lt;em&gt;親&lt;/em&gt;である &lt;code&gt;cities&lt;/code&gt; からすべての列（ &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;population&lt;/code&gt; 、 &lt;code&gt;altitude&lt;/code&gt; ）を&lt;em&gt;継承&lt;/em&gt;します。列 &lt;code&gt;name&lt;/code&gt; のタイプは &lt;code&gt;text&lt;/code&gt; であり、可変長文字列のネイティブPostgreSQLタイプです。州都には、 &lt;code&gt;state&lt;/code&gt; を示す追加の列stateがあります。PostgreSQLでは、テーブルは0個以上の他のテーブルから継承できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5c8500d7c402e7f06456adc9676ed53904411ff" translate="yes" xml:space="preserve">
          <source>In this case, a row of &lt;code&gt;capitals&lt;/code&gt;&lt;em&gt;inherits&lt;/em&gt; all columns (&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;population&lt;/code&gt;, and &lt;code&gt;elevation&lt;/code&gt;) from its &lt;em&gt;parent&lt;/em&gt;, &lt;code&gt;cities&lt;/code&gt;. The type of the column &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;text&lt;/code&gt;, a native PostgreSQL type for variable length character strings. The &lt;code&gt;capitals&lt;/code&gt; table has an additional column, &lt;code&gt;state&lt;/code&gt;, which shows its state abbreviation. In PostgreSQL, a table can inherit from zero or more other tables.</source>
          <target state="translated">この場合、 &lt;code&gt;capitals&lt;/code&gt; 行は、その&lt;em&gt;親&lt;/em&gt;である &lt;code&gt;cities&lt;/code&gt; からすべての列（ &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;population&lt;/code&gt; 、および &lt;code&gt;elevation&lt;/code&gt; ）を&lt;em&gt;継承&lt;/em&gt;します。列 &lt;code&gt;name&lt;/code&gt; のタイプは &lt;code&gt;text&lt;/code&gt; で、可変長文字列のネイティブPostgreSQLタイプです。 &lt;code&gt;capitals&lt;/code&gt; テーブルには、追加の列有し、 &lt;code&gt;state&lt;/code&gt; 、その状態の略語を示します。 PostgreSQLでは、テーブルは0個以上の他のテーブルから継承できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="613ba4c32d099503d94bd47a030a2a2ad44892dd" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;capitals&lt;/code&gt; table &lt;em&gt;inherits&lt;/em&gt; all the columns of its parent table, &lt;code&gt;cities&lt;/code&gt;. State capitals also have an extra column, &lt;code&gt;state&lt;/code&gt;, that shows their state.</source>
          <target state="translated">この場合、 &lt;code&gt;capitals&lt;/code&gt; テーブルは、その親テーブルである &lt;code&gt;cities&lt;/code&gt; すべての列を&lt;em&gt;継承&lt;/em&gt;します。州都には、 &lt;code&gt;state&lt;/code&gt; を示す追加の列stateもあります。</target>
        </trans-unit>
        <trans-unit id="af318a98fb799d225d9e923e2e4473ff3043a3f6" translate="yes" xml:space="preserve">
          <source>In this configuration, the sample &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; above takes 115.9 ms. That's 1061 ns of timing overhead, again a small multiple of what's measured directly by this utility. That much timing overhead means the actual query itself is only taking a tiny fraction of the accounted for time, most of it is being consumed in overhead instead. In this configuration, any &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; totals involving many timed operations would be inflated significantly by timing overhead.</source>
          <target state="translated">この構成では、上記のサンプル &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; は115.9ミリ秒かかります。これは1061 nsのタイミングオーバーヘッドであり、このユーティリティで直接測定されるものの数倍です。タイミングのオーバーヘッドが大きいということは、実際のクエリ自体が時間の一部を占めるだけであり、そのほとんどがオーバーヘッドで消費されていることを意味します。この構成では、多くの時限操作を含む &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; の合計は、タイミングオーバーヘッドによって大幅に増大します。</target>
        </trans-unit>
        <trans-unit id="abed36bdd05542db8e718c1091a76817a77d802e" translate="yes" xml:space="preserve">
          <source>In this example above we were allowed to switch from the larger MCS range &lt;code&gt;c1.c1023&lt;/code&gt; to the smaller range &lt;code&gt;c1.c4&lt;/code&gt;, but switching back was denied.</source>
          <target state="translated">上記の例では、より大きなMCS範囲 &lt;code&gt;c1.c1023&lt;/code&gt; からより小さな範囲 &lt;code&gt;c1.c4&lt;/code&gt; に切り替えることが許可されていましたが、元に戻すことは拒否されました。</target>
        </trans-unit>
        <trans-unit id="e7326012a121c41d2c47ed971d8505d7a7de76bf" translate="yes" xml:space="preserve">
          <source>In this example the Update node needs to consider three child tables as well as the originally-mentioned parent table. So there are four input scanning subplans, one per table. For clarity, the Update node is annotated to show the specific target tables that will be updated, in the same order as the corresponding subplans. (These annotations are new as of PostgreSQL 9.5; in prior versions the reader had to intuit the target tables by inspecting the subplans.)</source>
          <target state="translated">この例では、Updateノードは、最初に述べた親テーブルだけでなく、3つの子テーブルを考慮する必要があります。したがって、テーブルごとに1つずつ、4つの入力スキャンサブプランがあります。わかりやすくするために、Updateノードは、対応するサブプランと同じ順序で、更新される特定の対象テーブルを示すようにアノテーションされています(これらのアノテーションはPostgreSQL 9.5;から新しくなりました)。(これらの注釈はPostgreSQL 9.5から新しくなりました。以前のバージョンでは、読者はサブプランを調べて対象テーブルを直感的に理解する必要がありました。)</target>
        </trans-unit>
        <trans-unit id="90020459ceef361caea70168cdc85c26559a0eb6" translate="yes" xml:space="preserve">
          <source>In this example the join's output row count is the same as the product of the two scans' row counts, but that's not true in all cases because there can be additional &lt;code&gt;WHERE&lt;/code&gt; clauses that mention both tables and so can only be applied at the join point, not to either input scan. Here's an example:</source>
          <target state="translated">この例では、結合の出力行数は2つのスキャンの行数の積と同じですが、両方のテーブルを言及する追加の &lt;code&gt;WHERE&lt;/code&gt; 句があり、結合ポイントでのみ適用できるため、すべての場合に当てはまるわけではありません。、どちらのスキャンも入力しません。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="f68e5dbd48ccbde70e786ec3f6ee97430aeb6b1e" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;(none)&lt;/code&gt;, null is returned, otherwise the value of &lt;code&gt;value&lt;/code&gt; is returned.</source>
          <target state="translated">この例では、 &lt;code&gt;value&lt;/code&gt; が &lt;code&gt;(none)&lt;/code&gt; の場合はnullが返され、それ以外の場合はvalueの &lt;code&gt;value&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6956c57a06842052520c448c372cfcf4ca7298a5" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, the two standbys &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; will be chosen as synchronous standbys because their names appear early in the list of standby names. &lt;code&gt;s3&lt;/code&gt; is a potential synchronous standby and will take over the role of synchronous standby when either of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; fails. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">この例では、4つのスタンバイサーバー &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; が実行されている場合、2つのスタンバイ &lt;code&gt;s1&lt;/code&gt; および &lt;code&gt;s2&lt;/code&gt; が同期スタンバイとして選択されます。それらの名前がスタンバイ名のリストの最初に表示されるためです。 &lt;code&gt;s3&lt;/code&gt; は潜在的な同期スタンバイであり、 &lt;code&gt;s1&lt;/code&gt; または &lt;code&gt;s2&lt;/code&gt; のいずれかに障害が発生すると同期スタンバイの役割を引き継ぎます。 &lt;code&gt;s4&lt;/code&gt; はその名前がリストにないため、非同期スタンバイです。</target>
        </trans-unit>
        <trans-unit id="5ecb1dc9291b661bf70c843bbe812e41c22f83de" translate="yes" xml:space="preserve">
          <source>In this example, if four standby servers &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt;, &lt;code&gt;s3&lt;/code&gt; and &lt;code&gt;s4&lt;/code&gt; are running, transaction commits will wait for replies from at least any two standbys of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. &lt;code&gt;s4&lt;/code&gt; is an asynchronous standby since its name is not in the list.</source>
          <target state="translated">この例では、4つのスタンバイサーバー &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、 &lt;code&gt;s3&lt;/code&gt; 、および &lt;code&gt;s4&lt;/code&gt; が実行されている場合、トランザクションコミットは、 &lt;code&gt;s1&lt;/code&gt; 、 &lt;code&gt;s2&lt;/code&gt; 、および &lt;code&gt;s3&lt;/code&gt; の少なくとも2つのスタンバイからの応答を待機します。 &lt;code&gt;s4&lt;/code&gt; はその名前がリストにないため、非同期スタンバイです。</target>
        </trans-unit>
        <trans-unit id="52a2cd0a65091e20d376dc71b4672a80c22c4d96" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TEMPLATE template0&lt;/code&gt; clause is required if the specified locale is different from the one in &lt;code&gt;template1&lt;/code&gt;. (If it is not, then specifying the locale explicitly is redundant.)</source>
          <target state="translated">この例では、指定されたロケールが &lt;code&gt;template1&lt;/code&gt; のロケールと異なる場合、 &lt;code&gt;TEMPLATE template0&lt;/code&gt; 句が必要です。（そうでない場合、ロケールを明示的に指定することは冗長です。）</target>
        </trans-unit>
        <trans-unit id="8c5f7d8e9b592b4d5a3f718483f7acd727a00e09" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;len&lt;/code&gt; column is omitted and therefore it will have the default value:</source>
          <target state="translated">この例では、 &lt;code&gt;len&lt;/code&gt; 列は省略されているため、デフォルト値になります。</target>
        </trans-unit>
        <trans-unit id="3694c54d9cfcf70eda6933c152be42b7c937c601" translate="yes" xml:space="preserve">
          <source>In this example, the columns &lt;code&gt;product_id&lt;/code&gt;, &lt;code&gt;p.name&lt;/code&gt;, and &lt;code&gt;p.price&lt;/code&gt; must be in the &lt;code&gt;GROUP BY&lt;/code&gt; clause since they are referenced in the query select list (but see below). The column &lt;code&gt;s.units&lt;/code&gt; does not have to be in the &lt;code&gt;GROUP BY&lt;/code&gt; list since it is only used in an aggregate expression (&lt;code&gt;sum(...)&lt;/code&gt;), which represents the sales of a product. For each product, the query returns a summary row about all sales of the product.</source>
          <target state="translated">この例では、列 &lt;code&gt;product_id&lt;/code&gt; 、 &lt;code&gt;p.name&lt;/code&gt; 、および &lt;code&gt;p.price&lt;/code&gt; は、クエリ選択リストで参照されるため（ただし、以下を参照）、 &lt;code&gt;GROUP BY&lt;/code&gt; 句に含まれている必要があります。列 &lt;code&gt;s.units&lt;/code&gt; は、製品の売上を表す集計式（ &lt;code&gt;sum(...)&lt;/code&gt; ）でのみ使用されるため、 &lt;code&gt;GROUP BY&lt;/code&gt; リストにある必要はありません。クエリは製品ごとに、製品のすべての売上に関する要約行を返します。</target>
        </trans-unit>
        <trans-unit id="08a0e2d4d5bc94672e2506daf9e09dfe471fae09" translate="yes" xml:space="preserve">
          <source>In this example, the data type of the second parameter is not specified, so it is inferred from the context in which &lt;code&gt;$2&lt;/code&gt; is used.</source>
          <target state="translated">この例では、2番目のパラメーターのデータ型は指定されていないため、 &lt;code&gt;$2&lt;/code&gt; が使用されているコンテキストから推測されます。</target>
        </trans-unit>
        <trans-unit id="9ecac118ba12d038d39cec07567975d6d66efcef" translate="yes" xml:space="preserve">
          <source>In this example, the sort order isn't fully specified, and so you might get the San Francisco rows in either order. But you'd always get the results shown above if you do:</source>
          <target state="translated">この例では、ソート順は完全には指定されていないので、サンフランシスコの行はどちらの順番でも取得できるかもしれません。しかし、そうすると常に上記のような結果が得られます。</target>
        </trans-unit>
        <trans-unit id="afe2100b24dbf1294da5f781636d42d62e4bc563" translate="yes" xml:space="preserve">
          <source>In this example, the word &lt;code&gt;Brightest&lt;/code&gt; was recognized by the parser as an &lt;code&gt;ASCII word&lt;/code&gt; (alias &lt;code&gt;asciiword&lt;/code&gt;). For this token type the dictionary list is &lt;code&gt;english_ispell&lt;/code&gt; and &lt;code&gt;english_stem&lt;/code&gt;. The word was recognized by &lt;code&gt;english_ispell&lt;/code&gt;, which reduced it to the noun &lt;code&gt;bright&lt;/code&gt;. The word &lt;code&gt;supernovaes&lt;/code&gt; is unknown to the &lt;code&gt;english_ispell&lt;/code&gt; dictionary so it was passed to the next dictionary, and, fortunately, was recognized (in fact, &lt;code&gt;english_stem&lt;/code&gt; is a Snowball dictionary which recognizes everything; that is why it was placed at the end of the dictionary list).</source>
          <target state="translated">この例では、 &lt;code&gt;Brightest&lt;/code&gt; という単語がパーサーによって &lt;code&gt;ASCII word&lt;/code&gt; （別名 &lt;code&gt;asciiword&lt;/code&gt; ）として認識されました。このトークンタイプのディクショナリリストは、 &lt;code&gt;english_ispell&lt;/code&gt; および &lt;code&gt;english_stem&lt;/code&gt; です。この単語は &lt;code&gt;english_ispell&lt;/code&gt; によって認識され、名詞 &lt;code&gt;bright&lt;/code&gt; に減少しました。 &lt;code&gt;supernovaes&lt;/code&gt; という単語は、 &lt;code&gt;english_ispell&lt;/code&gt; 辞書では認識されていないため、次の辞書に渡され、幸いにも認識されました（実際、 &lt;code&gt;english_stem&lt;/code&gt; はすべてを認識するSnowball辞書です。そのため、辞書リストの最後に配置されました。 ）。</target>
        </trans-unit>
        <trans-unit id="3c50776020e0abdc78addf8fd7c7082700a16f21" translate="yes" xml:space="preserve">
          <source>In this example, transaction 82 was late, because its latency (6.173 ms) was over the 5 ms limit. The next two transactions were skipped, because they were already late before they were even started.</source>
          <target state="translated">この例では、トランザクション82のレイテンシ(6.173ミリ秒)が5ミリ秒の制限を超えていたため、トランザクション82は遅れていた。次の2つのトランザクションは、開始前にすでに遅れていたため、スキップされました。</target>
        </trans-unit>
        <trans-unit id="25785dae89df6c58b5b98e5a8b5a16cf8ba5c166" translate="yes" xml:space="preserve">
          <source>In this form, &lt;code&gt;n&lt;/code&gt; counts from 1 to 365, and February 29 is not counted even if it is present. (Thus, a transition occurring on February 29 could not be specified this way. However, days after February have the same numbers whether it's a leap year or not, so that this form is usually more useful than the plain-integer form for transitions on fixed dates.)</source>
          <target state="translated">この形式では、 &lt;code&gt;n&lt;/code&gt; は1から365までカウントされ、2月29日は存在してもカウントされません。 （したがって、2月29日に発生する遷移は、この方法で指定できませんでした。ただし、うるう年であるかどうかに関係なく、2月以降の日数は同じであるため、通常、この形式は、次の遷移のプレーン整数形式よりも便利です。決まった日付。）</target>
        </trans-unit>
        <trans-unit id="630dd124cc8b0f85590f44f07e341462147cb0a6" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dit&lt;/code&gt; lists indexes and tables. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">このコマンドグループでは、文字 &lt;code&gt;E&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;m&lt;/code&gt; 、 &lt;code&gt;s&lt;/code&gt; 、 &lt;code&gt;t&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は、それぞれ外部テーブル、インデックス、マテリアライズドビュー、シーケンス、テーブル、およびビューを表します。これらの文字の一部またはすべてを任意の順序で指定して、これらのタイプのオブジェクトのリストを取得できます。たとえば、 &lt;code&gt;\dit&lt;/code&gt; はインデックスとテーブルをリストします。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、ディスク上の物理サイズと関連する説明（ある場合）とともに一覧表示されます。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するオブジェクトのみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。パターンまたは &lt;code&gt;S&lt;/code&gt; を指定します システムオブジェクトを含める修飾子。</target>
        </trans-unit>
        <trans-unit id="e1a2b0abebbac2543bf7c44bb0372db4d5e5c034" translate="yes" xml:space="preserve">
          <source>In this group of commands, the letters &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, &lt;code&gt;\dti&lt;/code&gt; lists tables and indexes. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its persistence status (permanent, temporary, or unlogged), physical size on disk, and associated description if any. If &lt;code&gt;pattern&lt;/code&gt; is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">このコマンドグループでは、文字 &lt;code&gt;E&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;m&lt;/code&gt; 、 &lt;code&gt;s&lt;/code&gt; 、 &lt;code&gt;t&lt;/code&gt; 、および &lt;code&gt;v&lt;/code&gt; は、それぞれ外部テーブル、インデックス、マテリアライズドビュー、シーケンス、テーブル、およびビューを表します。これらの文字のいずれかまたはすべてを任意の順序で指定して、これらのタイプのオブジェクトのリストを取得できます。たとえば、 &lt;code&gt;\dti&lt;/code&gt; はテーブルとインデックスを一覧表示します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、その永続性ステータス（永続的、一時的、またはログに記録されていない）、ディスク上の物理サイズ、および関連する説明（存在する場合）とともにリストされます。 &lt;code&gt;pattern&lt;/code&gt; 場合が指定されている場合、名前がパターンと一致するオブジェクトのみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるためのパターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。</target>
        </trans-unit>
        <trans-unit id="76a2e5dcbe213e98e1493b7e930a93660a65d1fc" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">このモジュールでは、地球は完全に球形であると想定されています。 （それが不正確である場合は、&lt;a href=&quot;http://postgis.net/&quot;&gt;PostGIS&lt;/a&gt;プロジェクトを確認することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="d0ed0a5a7df9c6e41189a38e83864f5642c8ac48" translate="yes" xml:space="preserve">
          <source>In this module, the Earth is assumed to be perfectly spherical. (If that's too inaccurate for you, you might want to look at the &lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt; project.)</source>
          <target state="translated">このモジュールでは、地球は完全に球形であると想定されています。（それがあなたにとってあまりにも不正確であるならば、あなたは&lt;a href=&quot;https://postgis.net/&quot;&gt;PostGIS&lt;/a&gt;プロジェクトを見たいかもしれません。）</target>
        </trans-unit>
        <trans-unit id="fdbad3a8ee3be25a94e567ee2f1c55ff6b62875e" translate="yes" xml:space="preserve">
          <source>In this particular example, the correction from the MCV list is fairly small, because the column distribution is actually quite flat (the statistics showing these particular values as being more common than others are mostly due to sampling error). In a more typical case where some values are significantly more common than others, this complicated process gives a useful improvement in accuracy because the selectivity for the most common values is found exactly.</source>
          <target state="translated">この特定の例では,列の分布が実際には非常に平坦であるため,MCVリストからの補正はかなり小さい(これらの特定の値が他の値よりも一般的であることを示す統計量は,ほとんどがサンプリング誤差によるものです).いくつかの値が他の値よりも有意に一般的な場合、最も一般的な値の選択性が正確に見出されるので、この複雑なプロセスは精度の有用な向上をもたらします。</target>
        </trans-unit>
        <trans-unit id="35b50273596d3b9b0a5ab879d1dff2a027177930" translate="yes" xml:space="preserve">
          <source>In this plan, we have a nested-loop join node with two table scans as inputs, or children. The indentation of the node summary lines reflects the plan tree structure. The join's first, or &amp;ldquo;outer&amp;rdquo;, child is a bitmap scan similar to those we saw before. Its cost and row count are the same as we'd get from &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; because we are applying the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; at that node. The &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; clause is not relevant yet, so it doesn't affect the row count of the outer scan. The nested-loop join node will run its second, or &amp;ldquo;inner&amp;rdquo; child once for each row obtained from the outer child. Column values from the current outer row can be plugged into the inner scan; here, the &lt;code&gt;t1.unique2&lt;/code&gt; value from the outer row is available, so we get a plan and costs similar to what we saw above for a simple &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; case. (The estimated cost is actually a bit lower than what was seen above, as a result of caching that's expected to occur during the repeated index scans on &lt;code&gt;t2&lt;/code&gt;.) The costs of the loop node are then set on the basis of the cost of the outer scan, plus one repetition of the inner scan for each outer row (10 * 7.91, here), plus a little CPU time for join processing.</source>
          <target state="translated">この計画では、入力または子として2つのテーブルスキャンを持つネストループ結合ノードがあります。ノードサマリー行のインデントは、プランツリー構造を反映しています。結合の最初の「外部」子は、前に見たものと同様のビットマップスキャンです。そのノードで &lt;code&gt;WHERE&lt;/code&gt; 句 &lt;code&gt;unique1 &amp;lt; 10&lt;/code&gt; を適用しているので、そのコストと行数は &lt;code&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/code&gt; から得られるものと同じです。 &lt;code&gt;t1.unique2 = t2.unique2&lt;/code&gt; それは外側のスキャンの行数に影響を与えないように句は、まだ関係ありません。ネストされたループ結合ノードは、外側の子から取得した行ごとに、2番目の「内側」の子を1回実行します。現在の外部行の列値を内部スキャンに組み込むことができます。ここでは、 &lt;code&gt;t1.unique2&lt;/code&gt; 外側の行の値を使用できるため、上記の単純な &lt;code&gt;SELECT ... WHERE t2.unique2 = constant&lt;/code&gt; 場合と同じような計画とコストが得られます。 （ &lt;code&gt;t2&lt;/code&gt; でのインデックススキャンの繰り返し中に予想されるキャッシュの結果として、実際の見積もりコストは上記の値よりも少し低くなっています。）次に、ループノードのコストは、コストのコストに基づいて設定されます。外部スキャン、および各外部行の内部スキャンの1回の繰り返し（ここでは10 * 7.91）、および結合処理のための少しのCPU時間。</target>
        </trans-unit>
        <trans-unit id="92ba779e5f5f15aa09f4dc327e10902ae3870fba" translate="yes" xml:space="preserve">
          <source>In this syntax, a zone abbreviation can be a string of letters, such as &lt;code&gt;EST&lt;/code&gt;, or an arbitrary string surrounded by angle brackets, such as &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt;. Note that the zone abbreviations given here are only used for output, and even then only in some timestamp output formats. The zone abbreviations recognized in timestamp input are determined as explained in &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;.</source>
          <target state="translated">この構文では、ゾーンの省略形は、 &lt;code&gt;EST&lt;/code&gt; などの文字列、または &lt;code&gt;&amp;lt;UTC-05&amp;gt;&lt;/code&gt; などの山かっこで囲まれた任意の文字列にすることができます。ここに示されているゾーンの省略形は、出力にのみ使用され、それでも一部のタイムスタンプ出力形式でのみ使用されることに注意してください。タイムスタンプ入力で認識されるゾーンの略語は、&lt;a href=&quot;datetime-config-files&quot;&gt;セクションB.4で&lt;/a&gt;説明されているように決定されます。</target>
        </trans-unit>
        <trans-unit id="2a65ed7368072bf4eca944cd69c42b40f3442c1c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">この構文では、 &lt;code&gt;start&lt;/code&gt; 値または &lt;code&gt;count&lt;/code&gt; 値は、標準でリテラル定数、パラメーター、または変数名である必要があります。 PostgreSQLの拡張機能として、他の式を使用できますが、あいまいさを避けるために、通常は括弧で囲む必要があります。場合は &lt;code&gt;count&lt;/code&gt; で省略されている &lt;code&gt;FETCH&lt;/code&gt; 句、それ1.デフォルト &lt;code&gt;ROW&lt;/code&gt; および &lt;code&gt;ROWS&lt;/code&gt; だけでなく、 &lt;code&gt;FIRST&lt;/code&gt; と &lt;code&gt;NEXT&lt;/code&gt; は、これらの句の効果に影響しないノイズワードです。規格によると、両方が存在する場合、 &lt;code&gt;OFFSET&lt;/code&gt; 句は &lt;code&gt;FETCH&lt;/code&gt; 句の前に置く必要があります。しかし、PostgreSQLは緩いため、どちらの順序でも使用できます。</target>
        </trans-unit>
        <trans-unit id="1aad7367e4cf00d23ec40e47a1df35bb1446273c" translate="yes" xml:space="preserve">
          <source>In this syntax, the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; value is required by the standard to be a literal constant, a parameter, or a variable name; as a PostgreSQL extension, other expressions are allowed, but will generally need to be enclosed in parentheses to avoid ambiguity. If &lt;code&gt;count&lt;/code&gt; is omitted in a &lt;code&gt;FETCH&lt;/code&gt; clause, it defaults to 1. The &lt;code&gt;WITH TIES&lt;/code&gt; option is used to return any additional rows that tie for the last place in the result set according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause; &lt;code&gt;ORDER BY&lt;/code&gt; is mandatory in this case. &lt;code&gt;ROW&lt;/code&gt; and &lt;code&gt;ROWS&lt;/code&gt; as well as &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;NEXT&lt;/code&gt; are noise words that don't influence the effects of these clauses. According to the standard, the &lt;code&gt;OFFSET&lt;/code&gt; clause must come before the &lt;code&gt;FETCH&lt;/code&gt; clause if both are present; but PostgreSQL is laxer and allows either order.</source>
          <target state="translated">この構文では、 &lt;code&gt;start&lt;/code&gt; 値または &lt;code&gt;count&lt;/code&gt; 値は、標準でリテラル定数、パラメーター、または変数名である必要があります。 PostgreSQLの拡張機能として、他の式も使用できますが、あいまいさを避けるために、通常は括弧で囲む必要があります。場合は &lt;code&gt;count&lt;/code&gt; で省略されている &lt;code&gt;FETCH&lt;/code&gt; 1に句は、デフォルトを &lt;code&gt;WITH TIES&lt;/code&gt; オプション追加の行を返すために使用されることに応じて、結果セットの最後の位タイ &lt;code&gt;ORDER BY&lt;/code&gt; 句。この場合、 &lt;code&gt;ORDER BY&lt;/code&gt; は必須です。 &lt;code&gt;ROW&lt;/code&gt; と &lt;code&gt;ROWS&lt;/code&gt; 、および &lt;code&gt;FIRST&lt;/code&gt; と &lt;code&gt;NEXT&lt;/code&gt; これらの句の効果に影響を与えないノイズワードです。標準によれば、両方が存在する場合、 &lt;code&gt;OFFSET&lt;/code&gt; 句は &lt;code&gt;FETCH&lt;/code&gt; 句の前になければなりません。しかし、PostgreSQLは緩く、どちらの順序でも使用できます。</target>
        </trans-unit>
        <trans-unit id="6b9893e81c5b40e27434e52e7429139f563d867e" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;.</source>
          <target state="translated">このタイプのプランでは、テーブルの行がインデックス順にフェッチされるため、読み取りがさらに高価になりますが、行の場所をソートするための追加のコストは価値がありません。ほとんどの場合、単一の行のみをフェッチするクエリに対してこのプランタイプが表示されます。また、インデックスの順序に一致する &lt;code&gt;ORDER BY&lt;/code&gt; 条件を持つクエリにもよく使用されます。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を満たすために追加の並べ替え手順が必要ないためです。</target>
        </trans-unit>
        <trans-unit id="f14120df06086beebf2309a0093abef8ae36a3dc" translate="yes" xml:space="preserve">
          <source>In this type of plan the table rows are fetched in index order, which makes them even more expensive to read, but there are so few that the extra cost of sorting the row locations is not worth it. You'll most often see this plan type for queries that fetch just a single row. It's also often used for queries that have an &lt;code&gt;ORDER BY&lt;/code&gt; condition that matches the index order, because then no extra sorting step is needed to satisfy the &lt;code&gt;ORDER BY&lt;/code&gt;. In this example, adding &lt;code&gt;ORDER BY unique1&lt;/code&gt; would use the same plan because the index already implicitly provides the requested ordering.</source>
          <target state="translated">このタイプのプランでは、テーブルの行がインデックス順にフェッチされるため、読み取りにさらにコストがかかりますが、行の場所を並べ替える追加のコストに見合うだけの価値はありません。このプランタイプは、1行だけをフェッチするクエリでよく見られます。また、インデックスの順序に一致する &lt;code&gt;ORDER BY&lt;/code&gt; 条件を持つクエリにもよく使用されます。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; を満たすために追加の並べ替え手順が必要ないためです。この例では、インデックスがすでに要求された順序を暗黙的に提供しているため、 &lt;code&gt;ORDER BY unique1&lt;/code&gt; を追加すると同じプランが使用されます。</target>
        </trans-unit>
        <trans-unit id="84eb5898e8d8ec4083399d85009281a59b8ba4c6" translate="yes" xml:space="preserve">
          <source>In versions prior to PostgreSQL 9.6, this flag matched only tables, not any other type of relation.</source>
          <target state="translated">PostgreSQL 9.6以前のバージョンでは、このフラグはテーブルのみにマッチし、他のタイプのリレーションにはマッチしませんでした。</target>
        </trans-unit>
        <trans-unit id="cccb2030fa433816cbfff6cfc31e7b85686eadc9" translate="yes" xml:space="preserve">
          <source>In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path (&lt;code&gt;%p&lt;/code&gt;) but it is necessary to preserve the file name (&lt;code&gt;%f&lt;/code&gt;).</source>
          <target state="translated">アーカイブコマンドを記述する場合、アーカイブするファイル名は最大64文字で、ASCII文字、数字、ドットの任意の組み合わせを含むことができると想定する必要があります。元の相対パス（ &lt;code&gt;%p&lt;/code&gt; ）を保持する必要はありませんが、ファイル名（ &lt;code&gt;%f&lt;/code&gt; ）を保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="faddf9df2a3466cccf3377b581482849c1fd5256" translate="yes" xml:space="preserve">
          <source>Inaccurate time keeping can result in system instability. Test any change to the clock source very carefully. Operating system defaults are sometimes made to favor reliability over best accuracy. And if you are using a virtual machine, look into the recommended time sources compatible with it. Virtual hardware faces additional difficulties when emulating timers, and there are often per operating system settings suggested by vendors.</source>
          <target state="translated">不正確な時刻の保持は、システムを不安定にする可能性があります。クロックソースの変更は慎重にテストしてください。オペレーティングシステムのデフォルトは、最高の精度よりも信頼性を優先するように設定されていることがあります。また、仮想マシンを使用している場合は、そのマシンと互換性のある推奨された時間ソースを調べてください。仮想ハードウェアはタイマーをエミュレートする際にさらなる困難に直面し、ベンダーが推奨するオペレーティングシステムの設定が存在することがよくあります。</target>
        </trans-unit>
        <trans-unit id="b4bae0608aa0bb22c524d2d34a5bb2a1f5386f27" translate="yes" xml:space="preserve">
          <source>Incidentally, the &lt;code&gt;BEGIN&lt;/code&gt; key word is used for a different purpose in embedded SQL. You are advised to be careful about the transaction semantics when porting database applications.</source>
          <target state="translated">ちなみに、 &lt;code&gt;BEGIN&lt;/code&gt; キーワードは、埋め込みSQLでは別の目的で使用されます。データベースアプリケーションを移植するときは、トランザクションのセマンティクスに注意することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f56a8df3508e9ed5684baab06fa5e61cef26eebf" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;pg_trace.h&lt;/code&gt; if it is not already present in the module(s) containing the probe points, and insert &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; probe macros at the desired locations in the source code</source>
          <target state="translated">&lt;code&gt;pg_trace.h&lt;/code&gt; がプローブポイントを含むモジュールにまだ存在していない場合はインクルードし、ソースコードの目的の場所に &lt;code&gt;TRACE_POSTGRESQL&lt;/code&gt; プローブマクロを挿入します。</target>
        </trans-unit>
        <trans-unit id="2d8b7df7f5c4b05fc8f7d8518fd909017b7c32d2" translate="yes" xml:space="preserve">
          <source>Include SQL commands to clean (drop) databases before recreating them. &lt;code&gt;DROP&lt;/code&gt; commands for roles and tablespaces are added as well.</source>
          <target state="translated">データベースを再作成する前にデータベースをクリーン（ドロップ）するSQLコマンドを含めます。ロールとテーブルスペースの &lt;code&gt;DROP&lt;/code&gt; コマンドも追加されます。</target>
        </trans-unit>
        <trans-unit id="15af567ab13e6ebab28e457206713f05e4dcc212" translate="yes" xml:space="preserve">
          <source>Include actual startup time and time spent in each node in the output. The overhead of repeatedly reading the system clock can slow down the query significantly on some systems, so it may be useful to set this parameter to &lt;code&gt;FALSE&lt;/code&gt; when only actual row counts, and not exact times, are needed. Run time of the entire statement is always measured, even when node-level timing is turned off with this option. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">実際の起動時間と各ノードで費やされた時間を出力に含めます。一部のシステムでは、システムクロックを繰り返し読み取るオーバーヘッドによってクエリの速度が大幅に低下する可能性があるため、正確な時間ではなく実際の行数のみが必要な &lt;code&gt;FALSE&lt;/code&gt; 、このパラメーターをFALSEに設定すると便利です。このオプションでノードレベルのタイミングがオフになっている場合でも、ステートメント全体の実行時間は常に測定されます。このパラメーターは、 &lt;code&gt;ANALYZE&lt;/code&gt; も有効になっている場合にのみ使用できます。デフォルトは &lt;code&gt;TRUE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="69fd997380e1370b3a2e3a89721390495f72294b" translate="yes" xml:space="preserve">
          <source>Include files or directories can be used to logically separate portions of the database configuration, rather than having a single large &lt;code&gt;postgresql.conf&lt;/code&gt; file. Consider a company that has two database servers, each with a different amount of memory. There are likely elements of the configuration both will share, for things such as logging. But memory-related parameters on the server will vary between the two. And there might be server specific customizations, too. One way to manage this situation is to break the custom configuration changes for your site into three files. You could add this to the end of your &lt;code&gt;postgresql.conf&lt;/code&gt; file to include them:</source>
          <target state="translated">インクルードファイルまたはディレクトリを使用すると、単一の大きな &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルを作成するのではなく、データベース構成の部分を論理的に分離できます。 2つのデータベースサーバーがあり、それぞれが異なるメモリ容量を備えている会社を考えてみます。ロギングなどのために、両方の構成要素が共有する可能性があります。ただし、サーバー上のメモリ関連のパラメーターは2つで異なります。また、サーバー固有のカスタマイズもあるかもしれません。この状況を管理する1つの方法は、サイトのカスタム構成の変更を3つのファイルに分割することです。これを &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルの最後に追加して、それらを含めることができます。</target>
        </trans-unit>
        <trans-unit id="12ee2acead9dafe36942e1a0338b4e8cb8ee012c" translate="yes" xml:space="preserve">
          <source>Include information on WAL record generation. Specifically, include the number of records, number of full page images (fpi) and amount of WAL bytes generated. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">WALレコードの生成に関する情報を含めます。具体的には、レコード数、フルページイメージ（fpi）の数、および生成されたWALバイトの量を含めます。テキスト形式では、ゼロ以外の値のみが出力されます。このパラメーターは、 &lt;code&gt;ANALYZE&lt;/code&gt; も有効になっている場合にのみ使用できます。デフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="47b7156430746d586783036a5e783795b65f9965" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, and the number of temp blocks read and written. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. This parameter may only be used when &lt;code&gt;ANALYZE&lt;/code&gt; is also enabled. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">バッファーの使用に関する情報を含めます。具体的には、ヒット、読み取り、ダーティ、書き込みされた共有ブロックの数、ヒット、読み取り、ダーティ、書き込みされたローカルブロックの数、および読み書きされた一時ブロックの数を含めます。 Aは&lt;em&gt;ヒット&lt;/em&gt;、必要なときにブロックがすでにキャッシュ内に見つかったため、読み取りが回避されたことを意味します。共有ブロックには、通常のテーブルとインデックスからのデータが含まれています。ローカルブロックには、一時テーブルとインデックスからのデータが含まれます。一時ブロックには、ソート、ハッシュ、マテリアライズ計画ノードなどで使用される短期的な作業データが含まれています。&lt;em&gt;ダーティ&lt;/em&gt;になったブロックの数は、このクエリによって変更された、以前に変更されていないブロックの数を示します。&lt;em&gt;書き込まれた&lt;/em&gt;ブロックの数&lt;em&gt;&lt;/em&gt;クエリ処理中にこのバックエンドによってキャッシュから削除された、以前にダーティになったブロックの数を示します。上位レベルのノードに表示されるブロックの数には、そのすべての子ノードで使用されるブロックが含まれます。テキスト形式では、ゼロ以外の値のみが出力されます。このパラメーターは、 &lt;code&gt;ANALYZE&lt;/code&gt; も有効になっている場合にのみ使用できます。デフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="42e6828248f4c65573605405eae9a72feadb86b8" translate="yes" xml:space="preserve">
          <source>Include information on buffer usage. Specifically, include the number of shared blocks hit, read, dirtied, and written, the number of local blocks hit, read, dirtied, and written, the number of temp blocks read and written, and the time spent reading and writing data file blocks (in milliseconds) if &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt; is enabled. A &lt;em&gt;hit&lt;/em&gt; means that a read was avoided because the block was found already in cache when needed. Shared blocks contain data from regular tables and indexes; local blocks contain data from temporary tables and indexes; while temp blocks contain short-term working data used in sorts, hashes, Materialize plan nodes, and similar cases. The number of blocks &lt;em&gt;dirtied&lt;/em&gt; indicates the number of previously unmodified blocks that were changed by this query; while the number of blocks &lt;em&gt;written&lt;/em&gt; indicates the number of previously-dirtied blocks evicted from cache by this backend during query processing. The number of blocks shown for an upper-level node includes those used by all its child nodes. In text format, only non-zero values are printed. It defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">バッファー使用量に関する情報を含めます。具体的には、ヒット、読み取り、ダーティ、書き込みの共有ブロックの数、ヒット、読み取り、ダーティ、書き込みのローカルブロックの数、読み取りと書き込みの一時ブロックの数、データファイルブロックの読み取りと書き込みに費やした時間を含めます。 （ミリ秒単位）&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-IO-TIMING&quot;&gt;track_io_timing&lt;/a&gt;が有効になっている場合。 Aは&lt;em&gt;ヒット&lt;/em&gt;、必要なときにブロックがすでにキャッシュ内に見つかったため、読み取りが回避されたことを意味します。共有ブロックには、通常のテーブルとインデックスからのデータが含まれています。ローカルブロックには、一時テーブルとインデックスからのデータが含まれます。一方、一時ブロックには、並べ替え、ハッシュ、マテリアライズプランノードなどで使用される短期間の作業データが含まれます。&lt;em&gt;汚れた&lt;/em&gt;ブロックの数&lt;em&gt;&lt;/em&gt;このクエリによって変更された、以前に変更されていないブロックの数を示します。一方、&lt;em&gt;書き込ま&lt;/em&gt;れたブロックの数は、クエリ処理中にこのバックエンドによってキャッシュから削除された以前にダーティされたブロックの数を示します。上位ノードに表示されるブロック数には、そのすべての子ノードで使用されるブロックが含まれます。テキスト形式では、ゼロ以外の値のみが出力されます。デフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5cf950011b674c52ed53fd1187206feef3854c98" translate="yes" xml:space="preserve">
          <source>Include information on configuration parameters. Specifically, include options affecting query planning with value different from the built-in default value. This parameter defaults to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">構成パラメーターに関する情報を含めます。具体的には、組み込みのデフォルト値とは異なる値でクエリ計画に影響するオプションを含めます。このパラメーターのデフォルトは &lt;code&gt;FALSE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bd7df900c420c99916abebaeb86bc9b9487e3ff6" translate="yes" xml:space="preserve">
          <source>Include information on the estimated startup and total cost of each plan node, as well as the estimated number of rows and the estimated width of each row. This parameter defaults to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">各計画ノードの推定起動と合計コスト、および各行の推定行数と推定幅に関する情報を含めます。このパラメーターのデフォルトは &lt;code&gt;TRUE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b5b5e034a15e397016c3928803cda54f49c8fb74" translate="yes" xml:space="preserve">
          <source>Include large objects in the dump. This is the default behavior except when &lt;code&gt;--schema&lt;/code&gt;, &lt;code&gt;--table&lt;/code&gt;, or &lt;code&gt;--schema-only&lt;/code&gt; is specified. The &lt;code&gt;-b&lt;/code&gt; switch is therefore only useful to add large objects to dumps where a specific schema or table has been requested. Note that blobs are considered data and therefore will be included when &lt;code&gt;--data-only&lt;/code&gt; is used, but not when &lt;code&gt;--schema-only&lt;/code&gt; is.</source>
          <target state="translated">大きなオブジェクトをダンプに含めます。 &lt;code&gt;--schema&lt;/code&gt; 、-- &lt;code&gt;--table&lt;/code&gt; 、または &lt;code&gt;--schema-only&lt;/code&gt; が指定されている場合を除いて、これはデフォルトの動作です。 &lt;code&gt;-b&lt;/code&gt; スイッチは、特定のスキーマまたはテーブルが要求されたダンプにラージ・オブジェクトを追加することが唯一有用です。ブロブは、データとみなされ、場合従って含まれることに留意されたい &lt;code&gt;--data-only&lt;/code&gt; 場合に使用されないが、 &lt;code&gt;--schema-only&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="08c7d11c8d4a8d10c948989b5a35951818754be1" translate="yes" xml:space="preserve">
          <source>Include summary information (e.g., totaled timing information) after the query plan. Summary information is included by default when &lt;code&gt;ANALYZE&lt;/code&gt; is used but otherwise is not included by default, but can be enabled using this option. Planning time in &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; includes the time required to fetch the plan from the cache and the time required for re-planning, if necessary.</source>
          <target state="translated">クエリプランの後に概要情報（たとえば、合計タイミング情報）を含めます。概要情報は、 &lt;code&gt;ANALYZE&lt;/code&gt; を使用するとデフォルトで含まれますが、それ以外の場合はデフォルトでは含まれませんが、このオプションを使用して有効にできます。 &lt;code&gt;EXPLAIN EXECUTE&lt;/code&gt; の計画時間には、キャッシュから計画をフェッチするのに必要な時間と、必要に応じて再計画に必要な時間が含まれます。</target>
        </trans-unit>
        <trans-unit id="2f2cb48cc7645d02e5f49dead86862d11be771ed" translate="yes" xml:space="preserve">
          <source>Includes the required WAL (write-ahead log) files in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster in the target directory without the need to consult the log archive, thus making the output a completely standalone backup.</source>
          <target state="translated">必要なWAL（先行書き込みログ）ファイルをバックアップに含めます。これには、バックアップ中に生成されたすべての先行書き込みログが含まれます。メソッド &lt;code&gt;none&lt;/code&gt; が指定されていない限り、ログアーカイブを参照せずに、ターゲットディレクトリでポストマスターを起動できるため、出力は完全にスタンドアロンのバックアップになります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
