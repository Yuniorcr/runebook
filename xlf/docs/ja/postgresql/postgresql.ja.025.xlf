<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1daf3db24fd8109b791952bf2bea84cc95a73e77" translate="yes" xml:space="preserve">
          <source>Two parameterized GiST index operator classes are provided: &lt;code&gt;gist__int_ops&lt;/code&gt; (used by default) is suitable for small- to medium-size data sets, while &lt;code&gt;gist__intbig_ops&lt;/code&gt; uses a larger signature and is more suitable for indexing large data sets (i.e., columns containing a large number of distinct array values). The implementation uses an RD-tree data structure with built-in lossy compression.</source>
          <target state="translated">2つのパラメーター化されたGiSTインデックス演算子クラスが提供されます &lt;code&gt;gist__int_ops&lt;/code&gt; （デフォルトで使用）は中小規模のデータセットに &lt;code&gt;gist__intbig_ops&lt;/code&gt; おり、gist__intbig_opsはより大きな署名を使用し、大きなデータセット（つまり、多数を含む列）のインデックス付けに適しています。個別の配列値の）。実装では、不可逆圧縮が組み込まれたRDツリーデータ構造を使用します。</target>
        </trans-unit>
        <trans-unit id="662248ac968d8ab661b9569a6e6849ae788e24f8" translate="yes" xml:space="preserve">
          <source>Two significant incompatibilities exist between AREs and the ERE syntax recognized by pre-7.4 releases of PostgreSQL:</source>
          <target state="translated">PostgreSQLの7.4以前のリリースで認識されているIRE構文とARESの間には、2つの重要な非互換性が存在します。</target>
        </trans-unit>
        <trans-unit id="6a32f2ed2800b3a048eac6f3c98ed4d6f0004a87" translate="yes" xml:space="preserve">
          <source>Two string constants that are only separated by whitespace &lt;em&gt;with at least one newline&lt;/em&gt; are concatenated and effectively treated as if the string had been written as one constant. For example:</source>
          <target state="translated">空白&lt;em&gt;で&lt;/em&gt;区切られた&lt;em&gt;改行&lt;/em&gt;が&lt;em&gt;1つ以上ある&lt;/em&gt; 2つの文字列定数は連結され、文字列が1つの定数として記述されているかのように効果的に処理されます。例えば：</target>
        </trans-unit>
        <trans-unit id="90b63e2a4e205cf20d0c53869ecd885349050bdf" translate="yes" xml:space="preserve">
          <source>Two tablespaces are automatically created when the database cluster is initialized. The &lt;code&gt;pg_global&lt;/code&gt; tablespace is used for shared system catalogs. The &lt;code&gt;pg_default&lt;/code&gt; tablespace is the default tablespace of the &lt;code&gt;template1&lt;/code&gt; and &lt;code&gt;template0&lt;/code&gt; databases (and, therefore, will be the default tablespace for other databases as well, unless overridden by a &lt;code&gt;TABLESPACE&lt;/code&gt; clause in &lt;code&gt;CREATE DATABASE&lt;/code&gt;).</source>
          <target state="translated">データベースクラスタが初期化されると、2つのテーブルスペースが自動的に作成されます。 &lt;code&gt;pg_global&lt;/code&gt; 表領域は共有システムカタログに使用されます。 &lt;code&gt;pg_default&lt;/code&gt; 表領域は、デフォルトの表領域である &lt;code&gt;template1&lt;/code&gt; と &lt;code&gt;template0&lt;/code&gt; データベース（と、によって上書きされない限り、したがって、同様に他のデータベースのデフォルトの表領域であろう &lt;code&gt;TABLESPACE&lt;/code&gt; における句 &lt;code&gt;CREATE DATABASE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c5b854b5685b242cd142ae86c5c04afbc5fc30b6" translate="yes" xml:space="preserve">
          <source>Two types can be &lt;em&gt;binary coercible&lt;/em&gt;, which means that the conversion can be performed &amp;ldquo;for free&amp;rdquo; without invoking any function. This requires that corresponding values use the same internal representation. For instance, the types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;varchar&lt;/code&gt; are binary coercible both ways. Binary coercibility is not necessarily a symmetric relationship. For example, the cast from &lt;code&gt;xml&lt;/code&gt; to &lt;code&gt;text&lt;/code&gt; can be performed for free in the present implementation, but the reverse direction requires a function that performs at least a syntax check. (Two types that are binary coercible both ways are also referred to as binary compatible.)</source>
          <target state="translated">2つのタイプは&lt;em&gt;バイナリ強制&lt;/em&gt;型にできます。&lt;em&gt;つまり&lt;/em&gt;、関数を呼び出さずに「無料で」変換を実行できます。これには、対応する値が同じ内部表現を使用する必要があります。たとえば、タイプ &lt;code&gt;text&lt;/code&gt; と &lt;code&gt;varchar&lt;/code&gt; は、どちらの方法でもバイナリ強制可能です。バイナリ強制可能性は、必ずしも対称関係ではありません。たとえば、現在の実装では &lt;code&gt;xml&lt;/code&gt; から &lt;code&gt;text&lt;/code&gt; へのキャストは無料で実行できますが、逆方向には少なくとも構文チェックを実行する関数が必要です。 （双方向で強制型変換可能な2つの型は、バイナリー互換とも呼ばれます。）</target>
        </trans-unit>
        <trans-unit id="51632bd25b09e4b06271cc8939c29fce73a7a60c" translate="yes" xml:space="preserve">
          <source>Two useful flags exist in &lt;code&gt;pg_database&lt;/code&gt; for each database: the columns &lt;code&gt;datistemplate&lt;/code&gt; and &lt;code&gt;datallowconn&lt;/code&gt;. &lt;code&gt;datistemplate&lt;/code&gt; can be set to indicate that a database is intended as a template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. If this flag is set, the database can be cloned by any user with &lt;code&gt;CREATEDB&lt;/code&gt; privileges; if it is not set, only superusers and the owner of the database can clone it. If &lt;code&gt;datallowconn&lt;/code&gt; is false, then no new connections to that database will be allowed (but existing sessions are not terminated simply by setting the flag false). The &lt;code&gt;template0&lt;/code&gt; database is normally marked &lt;code&gt;datallowconn = false&lt;/code&gt; to prevent its modification. Both &lt;code&gt;template0&lt;/code&gt; and &lt;code&gt;template1&lt;/code&gt; should always be marked with &lt;code&gt;datistemplate = true&lt;/code&gt;.</source>
          <target state="translated">各データベースの &lt;code&gt;pg_database&lt;/code&gt; には、列 &lt;code&gt;datistemplate&lt;/code&gt; と &lt;code&gt;datallowconn&lt;/code&gt; の 2つの便利なフラグがあります。 &lt;code&gt;datistemplate&lt;/code&gt; は、データベースが &lt;code&gt;CREATE DATABASE&lt;/code&gt; のテンプレートとして意図されていることを示すように設定できます。このフラグが設定されている場合、 &lt;code&gt;CREATEDB&lt;/code&gt; 特権を持つ任意のユーザーがデータベースを複製できます。設定されていない場合は、スーパーユーザーとデータベースの所有者のみがクローンを作成できます。 &lt;code&gt;datallowconn&lt;/code&gt; がfalseの場合、そのデータベースへの新しい接続は許可されません（ただし、フラグをfalseに設定するだけでは既存のセッションは終了しません）。通常、 &lt;code&gt;template0&lt;/code&gt; データベースは &lt;code&gt;datallowconn = false&lt;/code&gt; マークされていますその変更を防ぐため。どちらも &lt;code&gt;template0&lt;/code&gt; と &lt;code&gt;template1&lt;/code&gt; が常にでマークする必要があります &lt;code&gt;datistemplate = true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba8214ba00d79461864d0001c2912a5c18b7b9a" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands - &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">2フェーズコミットコマンド &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 、 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 、 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; は、読み取り専用トランザクションでも準備フェーズ（2フェーズコミットの最初のフェーズ）でWALを書き込む必要があるためです。</target>
        </trans-unit>
        <trans-unit id="2e2bfc913787b0e6ea8551f81e2791cd42f7a318" translate="yes" xml:space="preserve">
          <source>Two-phase commit commands: &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt;, &lt;code&gt;COMMIT PREPARED&lt;/code&gt;, &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; because even read-only transactions need to write WAL in the prepare phase (the first phase of two phase commit).</source>
          <target state="translated">2フェーズコミットコマンド： &lt;code&gt;PREPARE TRANSACTION&lt;/code&gt; 、 &lt;code&gt;COMMIT PREPARED&lt;/code&gt; 、 &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; 。読み取り専用トランザクションでも準備フェーズ（2フェーズコミットの最初のフェーズ）でWALを書き込む必要があるためです。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="caa2352205156323130852be37f36d8839e386c6" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;ltree&lt;/code&gt; has the usual comparison operators &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;. Comparison sorts in the order of a tree traversal, with the children of a node sorted by label text. In addition, the specialized operators shown in &lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;Table F.13&lt;/a&gt; are available.</source>
          <target state="translated">タイプ &lt;code&gt;ltree&lt;/code&gt; には、通常の比較演算子 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; があります。比較はツリートラバーサルの順序で並べ替えられ、ノードの子はラベルテキストで並べ替えられます。さらに、&lt;a href=&quot;ltree#LTREE-OP-TABLE&quot;&gt;表F.13に&lt;/a&gt;示す特殊な演算子を使用できます。</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">タイプ変換</target>
        </trans-unit>
        <trans-unit id="0f621c80a40b4c3bb2242b9a8d5ab32c97b28181" translate="yes" xml:space="preserve">
          <source>Type modifier input function, or 0 if type does not support modifiers</source>
          <target state="translated">タイプの修飾子入力関数、またはタイプが修飾子をサポートしていない場合は0</target>
        </trans-unit>
        <trans-unit id="49427798b611e70520545325588242b32904d7b8" translate="yes" xml:space="preserve">
          <source>Type modifier output function, or 0 to use the standard format</source>
          <target state="translated">タイプ修飾子出力関数、または標準フォーマットを使用する場合は0</target>
        </trans-unit>
        <trans-unit id="13f4f7c42905c25fa5436f830df968dd5cfd652c" translate="yes" xml:space="preserve">
          <source>Type of connection</source>
          <target state="translated">接続の種類</target>
        </trans-unit>
        <trans-unit id="4a864d40476979903a17a15ee7653201ddd8043f" translate="yes" xml:space="preserve">
          <source>Type of current backend. Possible types are &lt;code&gt;autovacuum launcher&lt;/code&gt;, &lt;code&gt;autovacuum worker&lt;/code&gt;, &lt;code&gt;logical replication launcher&lt;/code&gt;, &lt;code&gt;logical replication worker&lt;/code&gt;, &lt;code&gt;parallel worker&lt;/code&gt;, &lt;code&gt;background writer&lt;/code&gt;, &lt;code&gt;client backend&lt;/code&gt;, &lt;code&gt;checkpointer&lt;/code&gt;, &lt;code&gt;startup&lt;/code&gt;, &lt;code&gt;walreceiver&lt;/code&gt;, &lt;code&gt;walsender&lt;/code&gt; and &lt;code&gt;walwriter&lt;/code&gt;. In addition, background workers registered by extensions may have additional types.</source>
          <target state="translated">現在のバックエンドのタイプ。可能なタイプは、 &lt;code&gt;autovacuum launcher&lt;/code&gt; 、 &lt;code&gt;autovacuum worker&lt;/code&gt; 、 &lt;code&gt;logical replication launcher&lt;/code&gt; 、 &lt;code&gt;logical replication worker&lt;/code&gt; 、 &lt;code&gt;parallel worker&lt;/code&gt; 、 &lt;code&gt;background writer&lt;/code&gt; 、 &lt;code&gt;client backend&lt;/code&gt; 、 &lt;code&gt;checkpointer&lt;/code&gt; 、 &lt;code&gt;startup&lt;/code&gt; 、 &lt;code&gt;walreceiver&lt;/code&gt; 、 &lt;code&gt;walsender&lt;/code&gt; と &lt;code&gt;walwriter&lt;/code&gt; 。さらに、拡張機能によって登録されたバックグラウンドワーカーには、追加のタイプがある場合があります。</target>
        </trans-unit>
        <trans-unit id="c82ff0d03f044b1bc03e6d585b2bc9ad0f83dd9c" translate="yes" xml:space="preserve">
          <source>Type of data stored in index, or zero if same as &lt;code&gt;opcintype&lt;/code&gt;</source>
          <target state="translated">インデックスに格納されているデータのタイプ、または &lt;code&gt;opcintype&lt;/code&gt; と同じ場合はゼロ</target>
        </trans-unit>
        <trans-unit id="4055eb85cfd66c39ef30f33fb4b4a5d50d592112" translate="yes" xml:space="preserve">
          <source>Type of object this entry is for: &lt;code&gt;r&lt;/code&gt; = relation (table, view), &lt;code&gt;S&lt;/code&gt; = sequence, &lt;code&gt;f&lt;/code&gt; = function, &lt;code&gt;T&lt;/code&gt; = type, &lt;code&gt;n&lt;/code&gt; = schema</source>
          <target state="translated">このエントリが対象とするオブジェクトのタイプ： &lt;code&gt;r&lt;/code&gt; =リレーション（テーブル、ビュー）、 &lt;code&gt;S&lt;/code&gt; =シーケンス、 &lt;code&gt;f&lt;/code&gt; =関数、 &lt;code&gt;T&lt;/code&gt; =タイプ、 &lt;code&gt;n&lt;/code&gt; =スキーマ</target>
        </trans-unit>
        <trans-unit id="3399c96b222ffc038be1234147fc38489a358880" translate="yes" xml:space="preserve">
          <source>Type of the JSON item (see &lt;code&gt;json_typeof&lt;/code&gt;)</source>
          <target state="translated">JSONアイテムのタイプ（ &lt;code&gt;json_typeof&lt;/code&gt; を参照）</target>
        </trans-unit>
        <trans-unit id="c6f5ec2f1c5458817693d6d76b369073909c045e" translate="yes" xml:space="preserve">
          <source>Type of the SQL/JSON item</source>
          <target state="translated">SQL/JSON項目の型</target>
        </trans-unit>
        <trans-unit id="00a9fa45d41b5ea65aa7f18aa2626b820f2f9cef" translate="yes" xml:space="preserve">
          <source>Type of the left operand</source>
          <target state="translated">左のオペランドの型</target>
        </trans-unit>
        <trans-unit id="21ac751dedd0b562597b93f21b2acf37d95f8772" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;frozenid&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;spectoken&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;. (See also &lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;Table 27.11&lt;/a&gt;.)</source>
          <target state="translated">ロック可能なオブジェクトのタイプ： &lt;code&gt;relation&lt;/code&gt; 、 &lt;code&gt;extend&lt;/code&gt; 、 &lt;code&gt;frozenid&lt;/code&gt; 、 &lt;code&gt;page&lt;/code&gt; 、 &lt;code&gt;tuple&lt;/code&gt; 、 &lt;code&gt;transactionid&lt;/code&gt; 、 &lt;code&gt;virtualxid&lt;/code&gt; 、 &lt;code&gt;spectoken&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 、 &lt;code&gt;userlock&lt;/code&gt; 、または &lt;code&gt;advisory&lt;/code&gt; 。（&lt;a href=&quot;monitoring-stats#WAIT-EVENT-LOCK-TABLE&quot;&gt;表27.11&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="767fb9969a4cc64a16553ca389e0f0b5a4e5c458" translate="yes" xml:space="preserve">
          <source>Type of the lockable object: &lt;code&gt;relation&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;page&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt;, &lt;code&gt;transactionid&lt;/code&gt;, &lt;code&gt;virtualxid&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;userlock&lt;/code&gt;, or &lt;code&gt;advisory&lt;/code&gt;</source>
          <target state="translated">ロック可能なオブジェクトのタイプ： &lt;code&gt;relation&lt;/code&gt; 、 &lt;code&gt;extend&lt;/code&gt; 、 &lt;code&gt;page&lt;/code&gt; 、 &lt;code&gt;tuple&lt;/code&gt; 、 &lt;code&gt;transactionid&lt;/code&gt; 、 &lt;code&gt;virtualxid&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 、 &lt;code&gt;userlock&lt;/code&gt; 、または &lt;code&gt;advisory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="727af93962dbd00f156d10d2619e6fe4d2766070" translate="yes" xml:space="preserve">
          <source>Type of the result</source>
          <target state="translated">結果の種類</target>
        </trans-unit>
        <trans-unit id="4b171dbb72682b90735ae1019128b1fa8fc68223" translate="yes" xml:space="preserve">
          <source>Type of the right operand</source>
          <target state="translated">右のオペランドの型</target>
        </trans-unit>
        <trans-unit id="886a7edda3ba752fafb210f2d1fc042903763b8a" translate="yes" xml:space="preserve">
          <source>Type of the server (optional)</source>
          <target state="translated">サーバーの種類(オプション</target>
        </trans-unit>
        <trans-unit id="b84c44ea065844d42eb4ff46ceca0a63ebb5fb0f" translate="yes" xml:space="preserve">
          <source>Typed Tables</source>
          <target state="translated">タイピングされたテーブル</target>
        </trans-unit>
        <trans-unit id="0e36cf7838eed64c7c287419b5db638ff701a9f7" translate="yes" xml:space="preserve">
          <source>Typed tables implement a subset of the SQL standard. According to the standard, a typed table has columns corresponding to the underlying composite type as well as one other column that is the &amp;ldquo;self-referencing column&amp;rdquo;. PostgreSQL does not support self-referencing columns explicitly.</source>
          <target state="translated">型付きテーブルは、SQL標準のサブセットを実装します。標準によれば、型付きテーブルには、基になる複合型に対応する列と、「自己参照列」である他の1つの列があります。PostgreSQLは、自己参照列を明示的にサポートしていません。</target>
        </trans-unit>
        <trans-unit id="5754e4191a491637e871b6ade422b1bcee16cbbf" translate="yes" xml:space="preserve">
          <source>Types of extended statistics enabled for this record</source>
          <target state="translated">このレコードで有効な拡張統計の種類</target>
        </trans-unit>
        <trans-unit id="30b55d03eac01f6040e3abe9feb9e154100f2081" translate="yes" xml:space="preserve">
          <source>Typical examples of an IPv4 address range specified this way are &lt;code&gt;172.20.143.89/32&lt;/code&gt; for a single host, or &lt;code&gt;172.20.143.0/24&lt;/code&gt; for a small network, or &lt;code&gt;10.6.0.0/16&lt;/code&gt; for a larger one. An IPv6 address range might look like &lt;code&gt;::1/128&lt;/code&gt; for a single host (in this case the IPv6 loopback address) or &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; for a small network. &lt;code&gt;0.0.0.0/0&lt;/code&gt; represents all IPv4 addresses, and &lt;code&gt;::0/0&lt;/code&gt; represents all IPv6 addresses. To specify a single host, use a mask length of 32 for IPv4 or 128 for IPv6. In a network address, do not omit trailing zeroes.</source>
          <target state="translated">IPv4アドレス範囲の典型的な例は、この方法で指定され &lt;code&gt;172.20.143.89/32&lt;/code&gt; 単一のホストのための、または &lt;code&gt;172.20.143.0/24&lt;/code&gt; 小規模ネットワーク用の、または &lt;code&gt;10.6.0.0/16&lt;/code&gt; 大きい方のために。IPv6アドレスの範囲は、単一のホストの場合は &lt;code&gt;::1/128&lt;/code&gt; （この場合はIPv6ループバックアドレス）、または小規模ネットワークの場合は &lt;code&gt;fe80::7a31:c1ff:0000:0000/96&lt;/code&gt; になります。 &lt;code&gt;0.0.0.0/0&lt;/code&gt; はすべてのIPv4アドレスを表し、 &lt;code&gt;::0/0&lt;/code&gt; はすべてのIPv6アドレスを表します。単一のホストを指定するには、IPv4の場合は32、IPv6の場合は128のマスク長を使用します。ネットワークアドレスでは、末尾のゼロを省略しないでください。</target>
        </trans-unit>
        <trans-unit id="3ba7280f9a6416aff842d582d030dc0d547a8079" translate="yes" xml:space="preserve">
          <source>Typical examples would be:</source>
          <target state="translated">典型的な例としては、次のようなものがあるでしょう。</target>
        </trans-unit>
        <trans-unit id="c3ae6c139f98be74a60c4eaf214c1269190843b0" translate="yes" xml:space="preserve">
          <source>Typical output from pgbench looks like:</source>
          <target state="translated">pgbenchからの典型的な出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4f215729680a38802cfd4b9559a7e299252d552b" translate="yes" xml:space="preserve">
          <source>Typical output from this plugin, used over the SQL logical decoding interface, might be:</source>
          <target state="translated">このプラグインからの典型的な出力は、SQL論理デコーディング・インターフェイス上で使用されます。</target>
        </trans-unit>
        <trans-unit id="5d9380cc46b3004a735b71b1ddc5769ac9cc9d80" translate="yes" xml:space="preserve">
          <source>Typically a role being used as a group would not have the &lt;code&gt;LOGIN&lt;/code&gt; attribute, though you can set it if you wish.</source>
          <target state="translated">通常、グループとして使用されるロールには &lt;code&gt;LOGIN&lt;/code&gt; 属性はありませんが、必要に応じて設定できます。</target>
        </trans-unit>
        <trans-unit id="0c79e0bb5747a47177b68165db0b8e29d1e90432" translate="yes" xml:space="preserve">
          <source>Typically an &lt;code&gt;UPDATE&lt;/code&gt; command also needs to read data from columns in the relation being updated (e.g., in a &lt;code&gt;WHERE&lt;/code&gt; clause or a &lt;code&gt;RETURNING&lt;/code&gt; clause, or in an expression on the right hand side of the &lt;code&gt;SET&lt;/code&gt; clause). In this case, &lt;code&gt;SELECT&lt;/code&gt; rights are also required on the relation being updated, and the appropriate &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policies will be applied in addition to the &lt;code&gt;UPDATE&lt;/code&gt; policies. Thus the user must have access to the row(s) being updated through a &lt;code&gt;SELECT&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy in addition to being granted permission to update the row(s) via an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;ALL&lt;/code&gt; policy.</source>
          <target state="translated">通常、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドは、更新されるリレーション（たとえば、 &lt;code&gt;WHERE&lt;/code&gt; 句または &lt;code&gt;RETURNING&lt;/code&gt; 句、または &lt;code&gt;SET&lt;/code&gt; 句の右側の式）の列からデータを読み取る必要もあります。この場合、更新されるリレーションに対して &lt;code&gt;SELECT&lt;/code&gt; 権限も必要です &lt;code&gt;UPDATE&lt;/code&gt; ポリシーに加えて、適切な &lt;code&gt;SELECT&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; ポリシーが適用されます。したがって、ユーザーは、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;ALL&lt;/code&gt; を介して行を更新する権限が付与されていることに加えて、 &lt;code&gt;SELECT&lt;/code&gt; またはALLポリシーを介して更新されている行にアクセスできる必要があります。 &lt;code&gt;ALL&lt;/code&gt; ポリシー。</target>
        </trans-unit>
        <trans-unit id="4a5dff53d37ef582f6443160c6077ab3c024f6ad" translate="yes" xml:space="preserve">
          <source>Typically libraries like libpq only add new functionality, again unless mentioned in the release notes.</source>
          <target state="translated">通常、libpqのようなライブラリは、リリースノートに記載されていない限り、新しい機能を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="74be98305cce33f0717978700ff85879bd035ba2" translate="yes" xml:space="preserve">
          <source>Typically that would be written in an extension's creation script, and users would do this to install the extension:</source>
          <target state="translated">通常、これは拡張機能の作成スクリプトに記述され、ユーザーはこれを実行して拡張機能をインストールします。</target>
        </trans-unit>
        <trans-unit id="d506067679b9e62e7a37578f7129dcc3d999cc58" translate="yes" xml:space="preserve">
          <source>Typically this includes new SQL command capabilities and not changes in behavior, unless specifically mentioned in the release notes.</source>
          <target state="translated">通常、これには新しいSQLコマンド機能が含まれており、特にリリースノートに記載されていない限り、動作の変更はありません。</target>
        </trans-unit>
        <trans-unit id="3822092fc5f3e669e643e30f8ce5e23c88a10d9c" translate="yes" xml:space="preserve">
          <source>Typically weights are used to mark words from special areas of the document, like the title or an initial abstract, so they can be treated with more or less importance than words in the document body.</source>
          <target state="translated">一般的に、タイトルや最初の抄録のように、文書の特別な領域から単語をマークするために重みが使用されます。</target>
        </trans-unit>
        <trans-unit id="75ec6d184c198c058b18b104c2264bc1718aff70" translate="yes" xml:space="preserve">
          <source>UNION, CASE, and Related Constructs</source>
          <target state="translated">ユニオン、ケース、および関連する構成要素</target>
        </trans-unit>
        <trans-unit id="e85ec09bfd030dc1a5734a458795c226244fc313" translate="yes" xml:space="preserve">
          <source>UNLISTEN</source>
          <target state="translated">UNLISTEN</target>
        </trans-unit>
        <trans-unit id="4e75e16efe1381bdf958afc52921070dcac9674c" translate="yes" xml:space="preserve">
          <source>UNLISTEN &amp;mdash; stop listening for a notification</source>
          <target state="translated">UNLISTEN &amp;mdash;通知の待機を停止する</target>
        </trans-unit>
        <trans-unit id="e42fbf3248836a2bda1822a0f26f66440fa0c899" translate="yes" xml:space="preserve">
          <source>UPC &amp;lt;=&amp;gt; EAN13</source>
          <target state="translated">UPC &amp;lt;=&amp;gt; EAN13</target>
        </trans-unit>
        <trans-unit id="8ea457eae40d594e81201972c4abd897fed37408" translate="yes" xml:space="preserve">
          <source>UPC numbers are a subset of the EAN13 numbers (they are basically EAN13 without the first &lt;code&gt;0&lt;/code&gt; digit).</source>
          <target state="translated">UPC番号は、EAN13番号のサブセットです（基本的に、最初の &lt;code&gt;0&lt;/code&gt; 桁がないEAN13 です）。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="391f048e928d94ac0bc9a0124d925ff0ab247d37" translate="yes" xml:space="preserve">
          <source>UPDATE &amp;mdash; update rows of a table</source>
          <target state="translated">UPDATE &amp;mdash;テーブルの行を更新する</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="5bc5065b4243467de49ffd6feb4dc052247ba467" translate="yes" xml:space="preserve">
          <source>URL locations can be canonicalized to make equivalent URLs match:</source>
          <target state="translated">URL の場所を正規化して、同等の URL を一致させることができます。</target>
        </trans-unit>
        <trans-unit id="5e1156d91b64895766702da1dac1a03bdacc18d8" translate="yes" xml:space="preserve">
          <source>URL path</source>
          <target state="translated">URLパス</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="618f65101275eae124d9a7c9c7a5431c588e88d8" translate="yes" xml:space="preserve">
          <source>UTF</source>
          <target state="translated">UTF</target>
        </trans-unit>
        <trans-unit id="006a48ffb6b1c6d449c6f984e56102797a110071" translate="yes" xml:space="preserve">
          <source>UTF-8 (8-bit UCS/Unicode Transformation Format) is defined here.</source>
          <target state="translated">ここでは、UTF-8(8ビットUCS/Unicode変換フォーマット)が定義されています。</target>
        </trans-unit>
        <trans-unit id="7fa9ad7f9065e92883a9407e908d043b05c218a2" translate="yes" xml:space="preserve">
          <source>UTF8</source>
          <target state="translated">UTF8</target>
        </trans-unit>
        <trans-unit id="21bf75a5255af008f6315cb6aca4bb3bdccee521" translate="yes" xml:space="preserve">
          <source>UUID</source>
          <target state="translated">UUID</target>
        </trans-unit>
        <trans-unit id="cd5f8485e99e1466105fe2ccda1a6e32ac64f458" translate="yes" xml:space="preserve">
          <source>UUID Functions</source>
          <target state="translated">UUID関数</target>
        </trans-unit>
        <trans-unit id="0b3aa0aafa91ea5c6d6154167ed0f9530a1ec26c" translate="yes" xml:space="preserve">
          <source>UUID Type</source>
          <target state="translated">UUIDタイプ</target>
        </trans-unit>
        <trans-unit id="0a7e35cb9fd13ab0f8bc30cc95fe3965c0075fa2" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation)</source>
          <target state="translated">単項プラス(操作なし)</target>
        </trans-unit>
        <trans-unit id="c93712543c02319baab11b2b81799e7e791b6f5f" translate="yes" xml:space="preserve">
          <source>Unary plus (no operation); unlike addition, this can iterate over multiple values</source>
          <target state="translated">単項プラス(演算なし);足し算とは異なり、複数の値を繰り返し処理することができます。</target>
        </trans-unit>
        <trans-unit id="bbfa247ab63ebe054b1f625efaac8d7d2ed2786f" translate="yes" xml:space="preserve">
          <source>Unconditionally trace locks on this table (OID).</source>
          <target state="translated">このテーブル(OID)のロックを無条件にトレースします。</target>
        </trans-unit>
        <trans-unit id="1a26494bd46f598c2d3b286cc32f8f8da4c3c529" translate="yes" xml:space="preserve">
          <source>Undo that, restoring whatever setting was effective in &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">元に戻し、 &lt;code&gt;postgresql.conf&lt;/code&gt; で有効だった設定を復元します。</target>
        </trans-unit>
        <trans-unit id="d82f20269a7ba351c65d96d467573f44ed2241db" translate="yes" xml:space="preserve">
          <source>Undo the above, so that subsequently-created tables won't have any more permissions than normal:</source>
          <target state="translated">上記を元に戻して、その後に作成されたテーブルが通常よりも多くのパーミッションを持たないようにします。</target>
        </trans-unit>
        <trans-unit id="69537adb0c6a954242641822e574baa70cf65b67" translate="yes" xml:space="preserve">
          <source>Unexpected results might be obtained if a &lt;code&gt;cache&lt;/code&gt; setting greater than one is used for a sequence object that will be used concurrently by multiple sessions. Each session will allocate and cache successive sequence values during one access to the sequence object and increase the sequence object's &lt;code&gt;last_value&lt;/code&gt; accordingly. Then, the next &lt;code&gt;cache&lt;/code&gt;-1 uses of &lt;code&gt;nextval&lt;/code&gt; within that session simply return the preallocated values without touching the sequence object. So, any numbers allocated but not used within a session will be lost when that session ends, resulting in &amp;ldquo;holes&amp;rdquo; in the sequence.</source>
          <target state="translated">複数のセッションで同時に使用されるシーケンスオブジェクトに1より大きい &lt;code&gt;cache&lt;/code&gt; 設定を使用すると、予期しない結果が得られる可能性があります。各セッションは、シーケンスオブジェクトへの1回のアクセス中に連続するシーケンス値を割り当ててキャッシュし、それに応じてシーケンスオブジェクトの &lt;code&gt;last_value&lt;/code&gt; を増やします。次に、そのセッション内で次の &lt;code&gt;cache&lt;/code&gt; -1が &lt;code&gt;nextval&lt;/code&gt; を使用すると、シーケンスオブジェクトに触れることなく、事前に割り当てられた値が返されます。そのため、セッション内で割り当てられたが使用されなかった番号は、そのセッションが終了すると失われ、シーケンスに「穴」ができます。</target>
        </trans-unit>
        <trans-unit id="bac601add3bc88ae7a8e23e81f98747db513fcef" translate="yes" xml:space="preserve">
          <source>Unfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky.</source>
          <target state="translated">残念ながら、コスト変数の理想的な値を決定するための明確に定義された方法はありません。それらは、特定のインストレーションが受け取るであろうクエリの全体の平均値として扱われるのがベストです。つまり、数回の実験に基づいて変更することは非常にリスクが高いということです。</target>
        </trans-unit>
        <trans-unit id="5477f70b1eea785630b35cd84e386522cded5715" translate="yes" xml:space="preserve">
          <source>Unicode Transformation Format</source>
          <target state="translated">ユニコード変換形式</target>
        </trans-unit>
        <trans-unit id="8de2de87fc64e84d8c1aa641cad76e717bc7b29c" translate="yes" xml:space="preserve">
          <source>Unicode, 8-bit</source>
          <target state="translated">Unicode、8ビット</target>
        </trans-unit>
        <trans-unit id="93a858d6fa1dc81e7eaad3250789d05cb036b8fa" translate="yes" xml:space="preserve">
          <source>Unified Hangul Code</source>
          <target state="translated">統一ハングルコード</target>
        </trans-unit>
        <trans-unit id="67ef7a3b2dde1ee8d6d2f80347f89266789839b9" translate="yes" xml:space="preserve">
          <source>Uniform Resource Locator</source>
          <target state="translated">ユニフォームリソースロケータ</target>
        </trans-unit>
        <trans-unit id="86a932dd65a48b174d2aada36f1bfffd412deac8" translate="yes" xml:space="preserve">
          <source>Unique Indexes</source>
          <target state="translated">ユニークなインデックス</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">ユニークな制約</target>
        </trans-unit>
        <trans-unit id="94adb10ebc944ac8b8156528bb8fd8dc3337202a" translate="yes" xml:space="preserve">
          <source>Unique constraints (and hence primary keys) on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">パーティショニングされたテーブルの一意性制約(したがって主キー)は、すべてのパーティションキー列を含まなければなりません。PostgreSQLは各パーティションで個別に一意性を強制することしかできないため、この制限が存在します。</target>
        </trans-unit>
        <trans-unit id="b4e5e39c7a8efbcd5a2b7282c47950080c8841cd" translate="yes" xml:space="preserve">
          <source>Unique constraints and primary keys are not inherited in the current implementation. This makes the combination of inheritance and unique constraints rather dysfunctional.</source>
          <target state="translated">現在の実装では、一意制約と主キーは継承されていません。このため、継承と一意制約の組み合わせはむしろ機能不全に陥っています。</target>
        </trans-unit>
        <trans-unit id="a46827700fc4ef4d046ba4ec7203d49efc58d66f" translate="yes" xml:space="preserve">
          <source>Unique constraints ensure that the data contained in a column, or a group of columns, is unique among all the rows in the table. The syntax is:</source>
          <target state="translated">一意制約は、列または列のグループに含まれるデータが、テーブル内のすべての行の中で一意であることを保証します。構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b9aef8c8c0041d90e74399130137479516c8ba5f" translate="yes" xml:space="preserve">
          <source>Unique constraints on partitioned tables must include all the partition key columns. This limitation exists because PostgreSQL can only enforce uniqueness in each partition individually.</source>
          <target state="translated">パーティショニングされたテーブルに対する一意性制約は、すべてのパーティションキー列を含まなければなりません。PostgreSQLは各パーティションで個別に一意性を強制することしかできないため、この制限が存在します。</target>
        </trans-unit>
        <trans-unit id="9ef954009038fb621257b004ec6cd8cd826ed58e" translate="yes" xml:space="preserve">
          <source>Unique prefixes of these strings are also accepted, for example &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt;. Leading or trailing whitespace is ignored, and case does not matter.</source>
          <target state="translated">これらの文字列の一意のプレフィックスも受け入れられます（例： &lt;code&gt;t&lt;/code&gt; または &lt;code&gt;n&lt;/code&gt; )。先頭または末尾の空白は無視され、大文字と小文字は区別されません。</target>
        </trans-unit>
        <trans-unit id="f49788f44915bd3a94e16e6f26e2424dc403e286" translate="yes" xml:space="preserve">
          <source>Universal Product Codes</source>
          <target state="translated">ユニバーサル製品コード</target>
        </trans-unit>
        <trans-unit id="b3357a0d067580c052d7ebc854b226e0d5262199" translate="yes" xml:space="preserve">
          <source>Universally Unique Identifier</source>
          <target state="translated">普遍的一意識別子</target>
        </trans-unit>
        <trans-unit id="49e71ce661ccc6dfcd03e849d0ea4cd3cac1c011" translate="yes" xml:space="preserve">
          <source>Unix System V</source>
          <target state="translated">ユニックスシステムV</target>
        </trans-unit>
        <trans-unit id="356c3f979b3eb09e01dc5a248ce81de4df5a2076" translate="yes" xml:space="preserve">
          <source>Unix-like operating systems enforce various kinds of resource limits that might interfere with the operation of your PostgreSQL server. Of particular importance are limits on the number of processes per user, the number of open files per process, and the amount of memory available to each process. Each of these have a &amp;ldquo;hard&amp;rdquo; and a &amp;ldquo;soft&amp;rdquo; limit. The soft limit is what actually counts but it can be changed by the user up to the hard limit. The hard limit can only be changed by the root user. The system call &lt;code&gt;setrlimit&lt;/code&gt; is responsible for setting these parameters. The shell's built-in command &lt;code&gt;ulimit&lt;/code&gt; (Bourne shells) or &lt;code&gt;limit&lt;/code&gt; (csh) is used to control the resource limits from the command line. On BSD-derived systems the file &lt;code&gt;/etc/login.conf&lt;/code&gt; controls the various resource limits set during login. See the operating system documentation for details. The relevant parameters are &lt;code&gt;maxproc&lt;/code&gt;, &lt;code&gt;openfiles&lt;/code&gt;, and &lt;code&gt;datasize&lt;/code&gt;. For example:</source>
          <target state="translated">Unixライクなオペレーティングシステムは、PostgreSQLサーバーの動作を妨害する可能性のあるさまざまな種類のリソース制限を適用します。特に重要なのは、ユーザーごとのプロセス数、プロセスごとの開いているファイルの数、および各プロセスで使用可能なメモリ量の制限です。これらにはそれぞれ「ハード」と「ソフト」の制限があります。ソフト制限は実際にカウントされるものですが、ユーザーがハード制限まで変更できます。ハード制限は、rootユーザーのみが変更できます。システムコール &lt;code&gt;setrlimit&lt;/code&gt; は、これらのパラメータの設定を担当します。シェルの組み込みコマンド &lt;code&gt;ulimit&lt;/code&gt; （Bourneシェル）または &lt;code&gt;limit&lt;/code&gt; （csh）を使用して、コマンドラインからリソース制限を制御します。 BSD派生システムでは、ファイル &lt;code&gt;/etc/login.conf&lt;/code&gt; ログイン中に設定されるさまざまなリソース制限を制御します。詳細については、オペレーティングシステムのドキュメントを参照してください。関連するパラメータは、 &lt;code&gt;maxproc&lt;/code&gt; 、 &lt;code&gt;openfiles&lt;/code&gt; 、および &lt;code&gt;datasize&lt;/code&gt; です。例えば：</target>
        </trans-unit>
        <trans-unit id="3a738963ffda0371927d9ea96b648a8947fa84b5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;WITH HOLD&lt;/code&gt; is specified, the cursor created by this command can only be used within the current transaction. Thus, &lt;code&gt;DECLARE&lt;/code&gt; without &lt;code&gt;WITH HOLD&lt;/code&gt; is useless outside a transaction block: the cursor would survive only to the completion of the statement. Therefore PostgreSQL reports an error if such a command is used outside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; (or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;) to define a transaction block.</source>
          <target state="translated">&lt;code&gt;WITH HOLD&lt;/code&gt; が指定されていない限り、このコマンドで作成されたカーソルは、現在のトランザクション内でのみ使用できます。したがって、 &lt;code&gt;WITH HOLD&lt;/code&gt; のない &lt;code&gt;DECLARE&lt;/code&gt; はトランザクションブロックの外では役に立たない。カーソルはステートメントの完了までしか存続しない。したがって、そのようなコマンドがトランザクションブロックの外で使用された場合、PostgreSQLはエラーを報告します。使用して、&lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt;と&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;（または&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;トランザクションブロックを定義します）。</target>
        </trans-unit>
        <trans-unit id="f36df6a348af57e59d7545a3e535407a26fb9186" translate="yes" xml:space="preserve">
          <source>Unless it is passed an &lt;code&gt;-X&lt;/code&gt; option, psql attempts to read and execute commands from the system-wide startup file (&lt;code&gt;psqlrc&lt;/code&gt;) and then the user's personal startup file (&lt;code&gt;~/.psqlrc&lt;/code&gt;), after connecting to the database but before accepting normal commands. These files can be used to set up the client and/or the server to taste, typically with &lt;code&gt;\set&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;-X&lt;/code&gt; オプションが渡されない限り、psqlは、データベースに接続した後、通常のコマンドを受け入れる前に、システム全体の起動ファイル（ &lt;code&gt;psqlrc&lt;/code&gt; ）からユーザーの個人起動ファイル（ &lt;code&gt;~/.psqlrc&lt;/code&gt; ）からコマンドを読み取って実行しようとします。 。これらのファイルを使用して、通常は &lt;code&gt;\set&lt;/code&gt; および &lt;code&gt;SET&lt;/code&gt; コマンドを使用して、クライアントまたはサーバー、あるいはその両方を好みに合わせて設定できます。</target>
        </trans-unit>
        <trans-unit id="6ebac9c6005801410e118c32c680d55ed8b8c195" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;, there is no large performance advantage to loading a library at session start rather than when it is first used. There is some advantage, however, when connection pooling is used.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-SHARED-PRELOAD-LIBRARIES&quot;&gt;shared_preload_libraries&lt;/a&gt;とは異なり、ライブラリを最初に使用するときではなく、セッションの開始時にライブラリをロードしても、大きなパフォーマンス上の利点はありません。ただし、接続プーリングを使用すると、いくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="36f97215c9ceadf639797c9ff18cfda7e2adaae5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INHERITS&lt;/code&gt;, the new table and original table are completely decoupled after creation is complete. Changes to the original table will not be applied to the new table, and it is not possible to include data of the new table in scans of the original table.</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; とは異なり、作成が完了すると、新しいテーブルと元のテーブルは完全に分離されます。元のテーブルへの変更は新しいテーブルには適用されず、元のテーブルのスキャンに新しいテーブルのデータを含めることはできません。</target>
        </trans-unit>
        <trans-unit id="155a510971d12c46f75bfa7a5024bf809f98a32b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;statement_timeout&lt;/code&gt;, this timeout can only occur while waiting for locks. Note that if &lt;code&gt;statement_timeout&lt;/code&gt; is nonzero, it is rather pointless to set &lt;code&gt;lock_timeout&lt;/code&gt; to the same or larger value, since the statement timeout would always trigger first. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will be logged.</source>
          <target state="translated">&lt;code&gt;statement_timeout&lt;/code&gt; とは異なり、このタイムアウトはロックの待機中にのみ発生します。ステートメントのタイムアウトが常に最初にトリガーされるため、 &lt;code&gt;statement_timeout&lt;/code&gt; がゼロ以外の場合、 &lt;code&gt;lock_timeout&lt;/code&gt; を同じまたはより大きな値に設定しても意味がないことに注意してください。 &lt;code&gt;log_min_error_statement&lt;/code&gt; が &lt;code&gt;ERROR&lt;/code&gt; 以下に設定されている場合、タイムアウトしたステートメントがログに記録されます。</target>
        </trans-unit>
        <trans-unit id="01f67f25338b64081817dcfc5c06974c9678164c" translate="yes" xml:space="preserve">
          <source>Unlike an XQuery/XPath sequence, which can contain any desired items in any desired order, an XPath 1.0 node-set has no guaranteed order and, like any set, does not allow multiple appearances of the same item.</source>
          <target state="translated">任意の順序で任意の項目を含むことができる XQuery/XPath シーケンスとは異なり、XPath 1.0 ノードセットには順序が保証されておらず、他のセットと同様に、同じ項目の複数出現は許可されていません。</target>
        </trans-unit>
        <trans-unit id="7bd39bd8bedec3e142d1db4767a229ec44898026" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\!&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments. The rest of the line is simply passed literally to the shell.</source>
          <target state="translated">他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\!&lt;/code&gt; の引数と見なされます。、および変数補間もバッククォート展開も引数では実行されません。行の残りは単に文字通りシェルに渡されます。</target>
        </trans-unit>
        <trans-unit id="f03bc80a9071747274c116c1e2637b147c1236d6" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ef&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\ef&lt;/code&gt; の引数であると見なされ、変数の補間もバッククォート展開も引数で実行されません。</target>
        </trans-unit>
        <trans-unit id="2ad59f5d51ac2d51e40eadad80e70c35b9563ffa" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\ev&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\ev&lt;/code&gt; の引数であると見なされ、変数の補間もバッククォート展開も引数で実行されません。</target>
        </trans-unit>
        <trans-unit id="969a2dc5b4f67a3964fc411e75789aab5f823e51" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\help&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\help&lt;/code&gt; の引数と見なされ、変数の補間や逆引用符の展開は引数で実行されません。</target>
        </trans-unit>
        <trans-unit id="1bcb7b9bd68e7cf599cb0566f121f159d3638a90" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sf&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\sf&lt;/code&gt; の引数であると見なされ、変数の補間もバッククォート展開も引数で実行されません。</target>
        </trans-unit>
        <trans-unit id="b3d8189c59a9d485c225bb21085a7dacfbf70328" translate="yes" xml:space="preserve">
          <source>Unlike most other meta-commands, the entire remainder of the line is always taken to be the argument(s) of &lt;code&gt;\sv&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\sv&lt;/code&gt; の引数と見なされ、変数の補間もバッククォート展開も引数で実行されません。</target>
        </trans-unit>
        <trans-unit id="af5b4f9ec65cdc48545903249d2323c25ceebafa" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_database&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_database&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_database&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_database&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="b4e709aa40757d88375a6ee47a77d6e0698e4303" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_db_role_setting&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_db_role_setting&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_db_role_setting&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_db_role_setting&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つではありません。</target>
        </trans-unit>
        <trans-unit id="2dbf1c1060e2c0aacae52353ec7fcd45b3ccceac" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_pltemplate&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_pltemplate&lt;/code&gt; per cluster, not one per database. This allows the information to be accessible in each database as it is needed.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_pltemplate&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_pltemplate&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。これにより、必要に応じて各データベースで情報にアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="90ff2576b542214d688a9eed4987d1a4510c063b" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_replication_origin&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_replication_origin&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_replication_origin&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_replication_origin&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="091dfd81e1c158b99b74cd5401b694679d3d2a31" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdepend&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdepend&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_shdepend&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_shdepend&lt;/code&gt; コピーは、クラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="b1cd5b470b7693ec3b4e72d1482e8ab6f1102fe7" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shdescription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shdescription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_shdescription&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_shdescription&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="45f9981f7d01238e6386247ed7e8c9b367559cb4" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_shseclabel&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_shseclabel&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_shseclabel&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_shseclabel&lt;/code&gt; コピーは、クラスターごとに1 つだけであり、データベースごとに1つではありません。</target>
        </trans-unit>
        <trans-unit id="eec8ee0cfbfbe1f6f908ff68c376680c64650f41" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_subscription&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_subscription&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_subscription&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_subscription&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="0b07b56a669f78b6086b457c5748686a76e734e9" translate="yes" xml:space="preserve">
          <source>Unlike most system catalogs, &lt;code&gt;pg_tablespace&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_tablespace&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ほとんどのシステムカタログとは異なり、 &lt;code&gt;pg_tablespace&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_tablespace&lt;/code&gt; コピーは、クラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="92c63faeedbf5e16bc5b93cceba5f7d683c79fc1" translate="yes" xml:space="preserve">
          <source>Unlike the WAL receiver of a PostgreSQL standby server, pg_receivewal by default flushes WAL data only when a WAL file is closed. The option &lt;code&gt;--synchronous&lt;/code&gt; must be specified to flush WAL data in real time. Since pg_receivewal does not apply WAL, you should not allow it to become a synchronous standby when &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; equals &lt;code&gt;remote_apply&lt;/code&gt;. If it does, it will appear to be a standby that never catches up, and will cause transaction commits to block. To avoid this, you should either configure an appropriate value for &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt;, or specify &lt;code&gt;application_name&lt;/code&gt; for pg_receivewal that does not match it, or change the value of &lt;code&gt;synchronous_commit&lt;/code&gt; to something other than &lt;code&gt;remote_apply&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLスタンバイサーバーのWALレシーバーとは異なり、pg_receivewalはデフォルトで、WALファイルが閉じられている場合にのみWALデータをフラッシュします。WALデータをリアルタイムでフラッシュするには、オプション &lt;code&gt;--synchronous&lt;/code&gt; を指定する必要があります。 pg_receivewalはWALを適用しないため、&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronized_commit&lt;/a&gt;が &lt;code&gt;remote_apply&lt;/code&gt; と等しい場合に同期スタンバイになることを許可しないでください。その場合、それは追い付かないスタンバイであるように見え、トランザクションのコミットをブロックします。これを回避するには、&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronized_standby_names&lt;/a&gt;に適切な値を設定するか、それに一致しないpg_receivewalに &lt;code&gt;application_name&lt;/code&gt; を指定するか、 &lt;code&gt;synchronous_commit&lt;/code&gt; の値を &lt;code&gt;remote_apply&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="209b27f026f1a4e49e27f779263f8527ec3c4bc5" translate="yes" xml:space="preserve">
          <source>Unlike the case when adding a constraint to a regular table, nothing is done to verify the constraint is correct; rather, this action simply declares that some new condition should be assumed to hold for all rows in the foreign table. (See the discussion in &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.) If the constraint is marked &lt;code&gt;NOT VALID&lt;/code&gt;, then it isn't assumed to hold, but is only recorded for possible future use.</source>
          <target state="translated">通常のテーブルに制約を追加する場合とは異なり、制約が正しいことを確認するための処理は行われません。むしろ、このアクションは、いくつかの新しい条件が外部テーブルのすべての行を保持すると想定される必要があることを単に宣言します。（&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLEの&lt;/a&gt;説明を参照してください。）制約に &lt;code&gt;NOT VALID&lt;/code&gt; のマークが付けられている場合、その制約は保持されているとは見なされず、将来の使用のためにのみ記録されます。</target>
        </trans-unit>
        <trans-unit id="8b364554eb1587843dacba831a236e3430803901" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="translated">特権の場合とは異なり、ロールのメンバーシップを &lt;code&gt;PUBLIC&lt;/code&gt; に付与することはできません。この形式のコマンドでは、 &lt;code&gt;role_specification&lt;/code&gt; のノイズワード &lt;code&gt;GROUP&lt;/code&gt; は許可されないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="4e0b1d236f8fe0f3fb7bccf02c7559e609f29c15" translate="yes" xml:space="preserve">
          <source>Unlike the case with privileges, membership in a role cannot be granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">特権の場合とは異なり、ロールのメンバーシップは &lt;code&gt;PUBLIC&lt;/code&gt; に付与できません。この形式のコマンドでは、ノイズワード &lt;code&gt;GROUP&lt;/code&gt; を使用できないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="d61210b660dd2a2ba353539f0d486b1b1e1ca0f9" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;code&gt;position&lt;/code&gt; fields to be mixed in the same format string. A format specifier without a &lt;code&gt;position&lt;/code&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">標準のC関数 &lt;code&gt;sprintf&lt;/code&gt; とは異なり、PostgreSQLの &lt;code&gt;format&lt;/code&gt; 関数では、 &lt;code&gt;position&lt;/code&gt; フィールドの有無にかかわらず、フォーマット指定子を同じフォーマット文字列に混在させることができます。 &lt;code&gt;position&lt;/code&gt; フィールドのないフォーマット指定子は、最後に使用された引数の後に常に次の引数を使用します。また、 &lt;code&gt;format&lt;/code&gt; 関数では、すべての関数引数をフォーマット文字列で使用する必要はありません。例えば：</target>
        </trans-unit>
        <trans-unit id="42d22ba12e56f3a8c0a56dce7ddb132f01963118" translate="yes" xml:space="preserve">
          <source>Unlike the standard C function &lt;code&gt;sprintf&lt;/code&gt;, PostgreSQL's &lt;code&gt;format&lt;/code&gt; function allows format specifiers with and without &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; fields to be mixed in the same format string. A format specifier without a &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; field always uses the next argument after the last argument consumed. In addition, the &lt;code&gt;format&lt;/code&gt; function does not require all function arguments to be used in the format string. For example:</source>
          <target state="translated">標準のC関数 &lt;code&gt;sprintf&lt;/code&gt; とは異なり、PostgreSQLの &lt;code&gt;format&lt;/code&gt; 関数では、&lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt;フィールドがある場合とない場合のフォーマット指定子を同じフォーマット文字列に混在させることができます。&lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt;フィールドのないフォーマット指定子は、最後の引数が消費された後、常に次の引数を使用します。さらに、 &lt;code&gt;format&lt;/code&gt; 関数では、すべての関数の引数をフォーマット文字列で使用する必要はありません。例えば：</target>
        </trans-unit>
        <trans-unit id="56340fd933fcc44d2d615474f7eee7f478fca5bb" translate="yes" xml:space="preserve">
          <source>Unlogged</source>
          <target state="translated">Unlogged</target>
        </trans-unit>
        <trans-unit id="b45f16ac00bccd2d97ad31eb4586a8a733d1ed1a" translate="yes" xml:space="preserve">
          <source>Unsets (deletes) the psql variable &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">psql変数 &lt;code&gt;name&lt;/code&gt; の設定を解除（削除）します。</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">符号なし整数</target>
        </trans-unit>
        <trans-unit id="50b79815e623c9d659af2f6f4f16ea14ba889265" translate="yes" xml:space="preserve">
          <source>Unused column contain zeroes. For example, &lt;code&gt;oprleft&lt;/code&gt; is zero for a prefix operator.</source>
          <target state="translated">未使用の列にはゼロが含まれています。たとえば、前置演算子の &lt;code&gt;oprleft&lt;/code&gt; はゼロです。</target>
        </trans-unit>
        <trans-unit id="2038bdec9210202d0d9d74839e3925ff0cd91ba1" translate="yes" xml:space="preserve">
          <source>Up</source>
          <target state="translated">Up</target>
        </trans-unit>
        <trans-unit id="d7530c6545fdfa9b651c7e47222acdb144b78573" translate="yes" xml:space="preserve">
          <source>Updatable Views</source>
          <target state="translated">更新可能なビュー</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="6f08e7604a29958aee71de0f6521d5ea65d07570" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;autoprewarm.blocks&lt;/code&gt; immediately. This may be useful if the autoprewarm worker is not running but you anticipate running it after the next restart. The return value is the number of records written to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoprewarm.blocks&lt;/code&gt; をすぐに更新します。これは、自動予熱ワーカーが実行されていなくても、次回の再起動後に実行される可能性がある場合に役立ちます。戻り値は、 &lt;code&gt;autoprewarm.blocks&lt;/code&gt; に書き込まれたレコードの数です。</target>
        </trans-unit>
        <trans-unit id="dd357ab63dd67dab2769f9aad042acbec503d583" translate="yes" xml:space="preserve">
          <source>Update a pre-9.1 installation of &lt;code&gt;hstore&lt;/code&gt; into extension style:</source>
          <target state="translated">9.1より前の &lt;code&gt;hstore&lt;/code&gt; のインストールを拡張スタイルに更新します。</target>
        </trans-unit>
        <trans-unit id="155fdafe50a3b57765513f60c5758d6496a123b2" translate="yes" xml:space="preserve">
          <source>Update contact names in an accounts table to match the currently assigned salesmen:</source>
          <target state="translated">現在割り当てられている営業マンに合わせて、アカウントテーブルの連絡先を更新します。</target>
        </trans-unit>
        <trans-unit id="a54b58d6201c8e67be3e5d043168cab0aaf4bd7b" translate="yes" xml:space="preserve">
          <source>Update statistics in a summary table to match the current data:</source>
          <target state="translated">サマリーテーブルの統計情報を現在のデータに合わせて更新します。</target>
        </trans-unit>
        <trans-unit id="a72e347972a409d75e922a98a8cb86184a8c091e" translate="yes" xml:space="preserve">
          <source>Update the collation's version. See &lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;Notes&lt;/a&gt; below.</source>
          <target state="translated">照合順序のバージョンを更新します。下記の&lt;a href=&quot;sql-altercollation#SQL-ALTERCOLLATION-NOTES&quot;&gt;注を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="886aa2619ee6c1b5dcabc291df392328e61fad29" translate="yes" xml:space="preserve">
          <source>Update the sequence value after a &lt;code&gt;COPY FROM&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; の後にシーケンス値を更新します。</target>
        </trans-unit>
        <trans-unit id="40cf1fe41c48155dea09e4ac1106c72553cfd43c" translate="yes" xml:space="preserve">
          <source>Updates statistics used by the planner to determine the most efficient way to execute a query.</source>
          <target state="translated">クエリを実行する最も効率的な方法を決定するためにプランナが使用する統計情報を更新します。</target>
        </trans-unit>
        <trans-unit id="dd8ce06e479993fd7940ea48abaafb1c49415931" translate="yes" xml:space="preserve">
          <source>Updating Data</source>
          <target state="translated">データの更新</target>
        </trans-unit>
        <trans-unit id="bbfacc342802549d59dc86ad3b2d308cd32c8b65" translate="yes" xml:space="preserve">
          <source>Updating a GIN index tends to be slow because of the intrinsic nature of inverted indexes: inserting or updating one heap row can cause many inserts into the index (one for each key extracted from the indexed item). As of PostgreSQL 8.4, GIN is capable of postponing much of this work by inserting new tuples into a temporary, unsorted list of pending entries. When the table is vacuumed or autoanalyzed, or when &lt;code&gt;gin_clean_pending_list&lt;/code&gt; function is called, or if the pending list becomes larger than &lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt;, the entries are moved to the main GIN data structure using the same bulk insert techniques used during initial index creation. This greatly improves GIN index update speed, even counting the additional vacuum overhead. Moreover the overhead work can be done by a background process instead of in foreground query processing.</source>
          <target state="translated">GINインデックスの更新は、逆インデックスの本質的な性質のために遅くなる傾向があります。1つのヒープ行を挿入または更新すると、インデックスに多数の挿入が発生する可能性があります（インデックス付きアイテムから抽出されたキーごとに1つ）。 PostgreSQL 8.4以降、GINは新しいタプルを保留中のエントリのソートされていない一時的なリストに挿入することで、この作業の多くを延期できます。テーブルが &lt;code&gt;gin_clean_pending_list&lt;/code&gt; または自動分析されたとき、またはgin_clean_pending_list関数が呼び出されたとき、または保留リストが&lt;a href=&quot;runtime-config-client#GUC-GIN-PENDING-LIST-LIMIT&quot;&gt;gin_pending_list_limit&lt;/a&gt;より大きくなったとき、エントリは、最初のインデックス作成時に使用されたのと同じ一括挿入手法を使用して、メインGINデータ構造に移動されます。これにより、追加のバキュームオーバーヘッドを含めて、GINインデックスの更新速度が大幅に向上します。さらに、オーバーヘッドの作業は、フォアグラウンドクエリ処理ではなく、バックグラウンドプロセスで実行できます。</target>
        </trans-unit>
        <trans-unit id="f5a2d3257a7cb0893d951688c3d6595c16276249" translate="yes" xml:space="preserve">
          <source>Updating the partition key of a row might cause it to be moved into a different partition where this row satisfies the partition bounds.</source>
          <target state="translated">行のパーティションキーを更新すると、その行がパーティションの境界を満たす別のパーティションに移動されることがあります。</target>
        </trans-unit>
        <trans-unit id="cf5d0b369531663af264541c44e93e18c3ec6ca5" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster</source>
          <target state="translated">PostgreSQLクラスタのアップグレード</target>
        </trans-unit>
        <trans-unit id="953812b4543e49a3e367bde451848478a686a885" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via Replication</source>
          <target state="translated">PostgreSQLクラスタのアップグレード レプリケーションによるデータのアップグレード</target>
        </trans-unit>
        <trans-unit id="2a87484838982cc6d197b8aae2ccdf6a9936eca6" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_dumpall</source>
          <target state="translated">PostgreSQLクラスタのアップグレード pg_dumpallによるデータのアップグレード</target>
        </trans-unit>
        <trans-unit id="725bfd4bce7d201deda730473db6dfc713d4524b" translate="yes" xml:space="preserve">
          <source>Upgrading a PostgreSQL Cluster: Upgrading Data via pg_upgrade</source>
          <target state="translated">PostgreSQLクラスタのアップグレード pg_upgradeによるデータのアップグレード</target>
        </trans-unit>
        <trans-unit id="4b80cb33cf9b567178f3f5855946aac8c80e285f" translate="yes" xml:space="preserve">
          <source>Upon creation, a constraint is given one of three characteristics: &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt;, &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt;, or &lt;code&gt;NOT DEFERRABLE&lt;/code&gt;. The third class is always &lt;code&gt;IMMEDIATE&lt;/code&gt; and is not affected by the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. The first two classes start every transaction in the indicated mode, but their behavior can be changed within a transaction by &lt;code&gt;SET CONSTRAINTS&lt;/code&gt;.</source>
          <target state="translated">制約は作成時に、 &lt;code&gt;DEFERRABLE INITIALLY DEFERRED&lt;/code&gt; 、 &lt;code&gt;DEFERRABLE INITIALLY IMMEDIATE&lt;/code&gt; 、 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; の3つの特性のいずれかが与えられます。3番目のクラスは常に &lt;code&gt;IMMEDIATE&lt;/code&gt; であり、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; コマンドの影響を受けません。最初の2つのクラスは指定されたモードですべてのトランザクションを開始しますが、それらの動作は &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; によってトランザクション内で変更できます。</target>
        </trans-unit>
        <trans-unit id="2d7a654640c2b50b3e7df60aeeabb5b08422ed24" translate="yes" xml:space="preserve">
          <source>Upper Limit</source>
          <target state="translated">上限</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="b4f04a10cb842d23a6e0c14dfb525ccfc19a7eeb" translate="yes" xml:space="preserve">
          <source>Usage notes for date/time formatting:</source>
          <target state="translated">日付・時刻の書式設定の使用上の注意</target>
        </trans-unit>
        <trans-unit id="c18762bb9fd2f772e7a3cc1038dad6521a3cdc73" translate="yes" xml:space="preserve">
          <source>Usage notes for numeric formatting:</source>
          <target state="translated">数値フォーマットの使用上の注意</target>
        </trans-unit>
        <trans-unit id="c17fd067f164433138f454d194adc8307cae8bca" translate="yes" xml:space="preserve">
          <source>Usage of &lt;em&gt;edge recombination crossover&lt;/em&gt; which is especially suited to keep edge losses low for the solution of the TSP by means of a GA;</source>
          <target state="translated">GAによるTSPのソリューションのエッジ損失を低く保つのに特に適した&lt;em&gt;エッジ再結合クロスオーバーの&lt;/em&gt;使用。</target>
        </trans-unit>
        <trans-unit id="8cb6064dc167ff3a0e3b42195a78e15770baa73c" translate="yes" xml:space="preserve">
          <source>Usage of a &lt;em&gt;steady state&lt;/em&gt; GA (replacement of the least fit individuals in a population, not whole-generational replacement) allows fast convergence towards improved query plans. This is essential for query handling with reasonable time;</source>
          <target state="translated">使い方&lt;em&gt;定常状態&lt;/em&gt; GA（人口の少なくともフィット個人ではなく、全体の世代交換の交換）が改良された問い合わせ計画へ素早い収束を可能にします。これは、妥当な時間でのクエリ処理に不可欠です。</target>
        </trans-unit>
        <trans-unit id="fc32adaef16ee6908ebadfca82b7126506f9473f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;'s &lt;code&gt;\ddp&lt;/code&gt; command to obtain information about existing assignments of default privileges. The meaning of the privilege display is the same as explained for &lt;code&gt;\dp&lt;/code&gt; in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;の &lt;code&gt;\ddp&lt;/code&gt; コマンドを使用して、デフォルト権限の既存の割り当てに関する情報を取得します。特権の表示の意味は、&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7の&lt;/a&gt; &lt;code&gt;\dp&lt;/code&gt; で説明したものと同じです。</target>
        </trans-unit>
        <trans-unit id="6ba1f539905474c7406568a7a7f9b3f0d11b5735" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; to change the attributes of a role, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role. All the attributes specified by &lt;code&gt;CREATE ROLE&lt;/code&gt; can be modified by later &lt;code&gt;ALTER ROLE&lt;/code&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;sql-alterrole&quot;&gt;ロール&lt;/a&gt;の属性を変更するにはALTER ROLEを使用し、&lt;a href=&quot;sql-droprole&quot;&gt;ロール&lt;/a&gt;を削除するにはDROP ROLEを使用します。 &lt;code&gt;CREATE ROLE&lt;/code&gt; で指定されたすべての属性は、後の &lt;code&gt;ALTER ROLE&lt;/code&gt; コマンドで変更できます。</target>
        </trans-unit>
        <trans-unit id="c7488ebe056d7926158f410bc5c4336c809c61a3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt; to execute a procedure.</source>
          <target state="translated">&lt;a href=&quot;sql-call&quot;&gt;CALL&lt;/a&gt;を使用してプロシージャを実行します。</target>
        </trans-unit>
        <trans-unit id="63fbf455d11c44c5877b87a971f27977e59c85ca" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to terminate a transaction block.</source>
          <target state="translated">トランザクションブロックを終了するには、&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;または&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="aa95bc5e0df28b02065365fe45c3e1b0d1eafbd6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt; to successfully terminate a transaction.</source>
          <target state="translated">&lt;a href=&quot;sql-commit&quot;&gt;COMMIT&lt;/a&gt;を使用して、トランザクションを正常に終了します。</target>
        </trans-unit>
        <trans-unit id="66e6213ccf4796834fff65a2132381a6fc00d716" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; to load all the rows in one command, instead of using a series of &lt;code&gt;INSERT&lt;/code&gt; commands. The &lt;code&gt;COPY&lt;/code&gt; command is optimized for loading large numbers of rows; it is less flexible than &lt;code&gt;INSERT&lt;/code&gt;, but incurs significantly less overhead for large data loads. Since &lt;code&gt;COPY&lt;/code&gt; is a single command, there is no need to disable autocommit if you use this method to populate a table.</source>
          <target state="translated">一連の &lt;code&gt;INSERT&lt;/code&gt; コマンドを使用する代わりに、&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;を使用してすべての行を1つのコマンドでロードします。 &lt;code&gt;COPY&lt;/code&gt; コマンドは、行の多数をロードするために最適化されています。 &lt;code&gt;INSERT&lt;/code&gt; よりも柔軟性は低くなりますが、大規模なデータロードのオーバーヘッドは大幅に少なくなります。以来 &lt;code&gt;COPY&lt;/code&gt; は単一のコマンドでは、テーブルを移入するために、このメソッドを使用している場合は、無効に自動コミットする必要はありません。</target>
        </trans-unit>
        <trans-unit id="09047c3a617e15ed6b5d857521bdd8e734e0300e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; to add new roles, and &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt; to remove a role.</source>
          <target state="translated">&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;を使用して新しいロールを追加し、&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;を使用してロールを削除します。</target>
        </trans-unit>
        <trans-unit id="9b4d3d6618c9949a9ad76ab0ddb5874169d923d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt; to remove user-defined casts.</source>
          <target state="translated">&lt;a href=&quot;sql-dropcast&quot;&gt;DROP CAST&lt;/a&gt;を使用して、ユーザー定義のキャストを削除します。</target>
        </trans-unit>
        <trans-unit id="f593b5e915433730446b465706be5f4af789f7c8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; to remove a database.</source>
          <target state="translated">&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt;を使用してデータベースを削除します。</target>
        </trans-unit>
        <trans-unit id="f6d31dd4270e5743088ace63fb2eb93db009e693" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt; to remove an index.</source>
          <target state="translated">&lt;a href=&quot;sql-dropindex&quot;&gt;DROP INDEX&lt;/a&gt;を使用してインデックスを削除します。</target>
        </trans-unit>
        <trans-unit id="c243eaa6db16e01a7e2d96464804f5badfa4a886" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt; to drop procedural languages.</source>
          <target state="translated">&lt;a href=&quot;sql-droplanguage&quot;&gt;DROP LANGUAGE&lt;/a&gt;を使用して、手続き型言語を削除します。</target>
        </trans-unit>
        <trans-unit id="611b170ec13c2b52270c3dae6f1ab02cf82d138c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt; to delete user-defined operators from a database. Use &lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt; to modify operators in a database.</source>
          <target state="translated">&lt;a href=&quot;sql-dropoperator&quot;&gt;DROP OPERATOR&lt;/a&gt;を使用して、データベースからユーザー定義演算子を削除します。&lt;a href=&quot;sql-alteroperator&quot;&gt;ALTER OPERATOR&lt;/a&gt;を使用して、データベースの演算子を変更します。</target>
        </trans-unit>
        <trans-unit id="58497b86e7746a484024506bf39de0e9955831f3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt; to remove transforms.</source>
          <target state="translated">&lt;a href=&quot;sql-droptransform&quot;&gt;DROP TRANSFORM&lt;/a&gt;を使用して変換を削除します。</target>
        </trans-unit>
        <trans-unit id="b075359ef1491da7c72c666849ad06ca28042837" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; to remove a trigger.</source>
          <target state="translated">&lt;a href=&quot;sql-droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;を使用してトリガーを削除します。</target>
        </trans-unit>
        <trans-unit id="e27e35b2729f99b5a4d57cb1356ed22041def512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint without discarding the effects of commands executed after it was established.</source>
          <target state="translated">&lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt;を使用すると、確立後に実行されたコマンドの影響を破棄せずにセーブポイントを破棄できます。</target>
        </trans-unit>
        <trans-unit id="54340c6db432893de03388140d111cf79cc5bd33" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt; to abort a transaction.</source>
          <target state="translated">&lt;a href=&quot;sql-rollback&quot;&gt;ROLLBACK&lt;/a&gt;を使用してトランザクションを中止します。</target>
        </trans-unit>
        <trans-unit id="b54ec80fcdd9c1cc0a780b0c3e10b24a114e978c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt; to rollback to a savepoint. Use &lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt; to destroy a savepoint, keeping the effects of commands executed after it was established.</source>
          <target state="translated">セーブポイントにロールバックするには、&lt;a href=&quot;sql-rollback-to&quot;&gt;ROLLBACK TO SAVEPOINT&lt;/a&gt;を使用します。&lt;a href=&quot;sql-release-savepoint&quot;&gt;RELEASE SAVEPOINT&lt;/a&gt;を使用してセーブポイントを破棄し、確立後に実行されたコマンドの効果を維持します。</target>
        </trans-unit>
        <trans-unit id="f8f348396f663d6710748aac99721ad4f0c1192d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP COLLATION&lt;/code&gt; to remove user-defined collations.</source>
          <target state="translated">&lt;code&gt;DROP COLLATION&lt;/code&gt; を使用して、ユーザー定義の照合を削除します。</target>
        </trans-unit>
        <trans-unit id="f84b3986ffc86a297e493d0aa18ef741b0d79725" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP CONVERSION&lt;/code&gt; to remove user-defined conversions.</source>
          <target state="translated">&lt;code&gt;DROP CONVERSION&lt;/code&gt; を使用して、ユーザー定義の変換を削除します。</target>
        </trans-unit>
        <trans-unit id="ff15db4e13f780cb214c1fb5755bb245ba8cdda8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;DROP SEQUENCE&lt;/code&gt; to remove a sequence.</source>
          <target state="translated">&lt;code&gt;DROP SEQUENCE&lt;/code&gt; を使用してシーケンスを削除します。</target>
        </trans-unit>
        <trans-unit id="15726e7944bcacfcfd9200215f0e42b66131bfdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;OUT&lt;/code&gt; parameters to define the return type implicitly. The same example could also be done this way:</source>
          <target state="translated">使用 &lt;code&gt;OUT&lt;/code&gt; 暗黙的に戻り値の型を定義するためのパラメータを。同じ例を次のように行うこともできます。</target>
        </trans-unit>
        <trans-unit id="67538321bf9a606c6338bda53e8523a0fee89c08" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;\lo_list&lt;/code&gt; to find out the large object's OID.</source>
          <target state="translated">&lt;code&gt;\lo_list&lt;/code&gt; を使用して、ラージオブジェクトのOIDを見つけます。</target>
        </trans-unit>
        <trans-unit id="2965f87f5b2b233b83696be719d6f81a6a38ddaa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;restore_command&lt;/code&gt; defined in the target cluster configuration to retrieve WAL files from the WAL archive if these files are no longer available in the &lt;code&gt;pg_wal&lt;/code&gt; directory.</source>
          <target state="translated">これらのファイルが &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリで使用できなくなった場合は、ターゲットクラスタ構成で定義された &lt;code&gt;restore_command&lt;/code&gt; を使用して、WALアーカイブからWALファイルを取得します。</target>
        </trans-unit>
        <trans-unit id="5c1ddd9e45a36cc1cb06c4712dd45f333163ae53" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the field separator for unaligned output. This is equivalent to &lt;code&gt;\pset fieldsep&lt;/code&gt; or &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="translated">位置合わせされていない出力のフィールド区切り &lt;code&gt;separator&lt;/code&gt; としてセパレータを使用します。これは、 &lt;code&gt;\pset fieldsep&lt;/code&gt; または &lt;code&gt;\f&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="7f33f5b37daa8a924b75643b07be4642a71a3839" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;separator&lt;/code&gt; as the record separator for unaligned output. This is equivalent to &lt;code&gt;\pset recordsep&lt;/code&gt;.</source>
          <target state="translated">アライメントされていない出力のレコード &lt;code&gt;separator&lt;/code&gt; としてセパレータを使用します。これは &lt;code&gt;\pset recordsep&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="d5d5c3e044f569ed4a54b5c8b2aeebf1c2b6cc75" translate="yes" xml:space="preserve">
          <source>Use GSSAPI to authenticate the user. This is only available for TCP/IP connections. See &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt; for details. It can be used in conjunction with GSSAPI encryption.</source>
          <target state="translated">GSSAPIを使用してユーザーを認証します。これは、TCP / IP接続でのみ使用できます。詳細は&lt;a href=&quot;gssapi-auth&quot;&gt;項20.6&lt;/a&gt;を参照してください。GSSAPI暗号化と組み合わせて使用​​できます。</target>
        </trans-unit>
        <trans-unit id="aeb12709af5299bd1b78d1fc87510677adf5e4d9" translate="yes" xml:space="preserve">
          <source>Use SSPI to authenticate the user. This is only available on Windows. See &lt;a href=&quot;sspi-auth&quot;&gt;Section 20.7&lt;/a&gt; for details.</source>
          <target state="translated">SSPIを使用してユーザーを認証します。これはWindowsでのみ使用できます。詳細は&lt;a href=&quot;sspi-auth&quot;&gt;項20.7&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="09a0b632c4471d6df190780101d005ba97319161" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">ダンプに &lt;code&gt;serializable&lt;/code&gt; トランザクションを使用して、使用するスナップショットが後のデータベースの状態と一致するようにします。ただし、これを行うには、トランザクションストリームで異常が発生しないポイントを待機することで、ダンプが失敗したり、他のトランザクションが &lt;code&gt;serialization_failure&lt;/code&gt; でロールバックしたりするリスクを回避します。トランザクションの分離と同時実行制御の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9ca5d4bab09764f17142fbf20ac5e71fb208ada4" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;serializable&lt;/code&gt; transaction for the dump, to ensure that the snapshot used is consistent with later database states; but do this by waiting for a point in the transaction stream at which no anomalies can be present, so that there isn't a risk of the dump failing or causing other transactions to roll back with a &lt;code&gt;serialization_failure&lt;/code&gt;. See &lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">ダンプに &lt;code&gt;serializable&lt;/code&gt; トランザクションを使用して、使用されるスナップショットが後のデータベースの状態と一致するようにします。ただし、これを行うには、トランザクションストリーム内で異常が存在しないポイントを待機します。これにより、ダンプが失敗したり、 &lt;code&gt;serialization_failure&lt;/code&gt; で他のトランザクションがロールバックしたりするリスクがなくなります。トランザクションの分離と同時実行制御の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2c1cd79ab101e360e9a13e652ea38bf6edc2d76e" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;exclusion constraint&lt;/a&gt; to enforce the rule that a cage at a zoo can contain only one kind of animal:</source>
          <target state="translated">&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;除外制約&lt;/a&gt;を使用して、動物園のケージには1種類の動物しか入れることができないという規則を適用します。</target>
        </trans-unit>
        <trans-unit id="f3ff396f1aa38be47c72d90438e9b5c8fc599d4d" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt;&lt;code&gt;pg_stat_database&lt;/code&gt;&lt;/a&gt; view.</source>
          <target state="translated">データページでチェックサムを使用して、I / Oシステムによる破損を検出します。チェックサムを有効にすると、パフォーマンスが著しく低下する可能性があります。設定されている場合、チェックサムはすべてのデータベースのすべてのオブジェクトに対して計算されます。すべてのチェックサムの失敗は、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-VIEW&quot;&gt; &lt;code&gt;pg_stat_database&lt;/code&gt; &lt;/a&gt;ビューで報告されます。</target>
        </trans-unit>
        <trans-unit id="ed495ec2e832a44d27151818dc3a53eb05f6485b" translate="yes" xml:space="preserve">
          <source>Use checksums on data pages to help detect corruption by the I/O system that would otherwise be silent. Enabling checksums may incur a noticeable performance penalty. If set, checksums are calculated for all objects, in all databases. All checksum failures will be reported in the &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; view.</source>
          <target state="translated">データページのチェックサムを使用して、通常はサイレントであるI / Oシステムによる破損を検出します。チェックサムを有効にすると、パフォーマンスが著しく低下する可能性があります。設定すると、すべてのデータベースのすべてのオブジェクトのチェックサムが計算されます。すべてのチェックサムエラーは&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;ビューで報告されます。</target>
        </trans-unit>
        <trans-unit id="ce023d8439552305d2edc6e2bf4149ad204ec26c" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">条件付きコマンドを使用して（つまり、 &lt;code&gt;IF EXISTS&lt;/code&gt; 句を追加して）、データベースオブジェクトを削除します。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="d755e67717cdd34225a86cde8e3134de7095e52a" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">条件付きコマンド（つまり、 &lt;code&gt;IF EXISTS&lt;/code&gt; 句を追加）を使用して、データベースやその他のオブジェクトを削除します。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="723b15fd565cd7b73cc4c9f69508e6bb65d787d0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e. add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">データベースオブジェクトをクリーン &lt;code&gt;IF EXISTS&lt;/code&gt; ときは、条件付きコマンドを使用します（IF EXISTS句を追加します）。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="e393204f90a01988137d09cb6497fb713cc35dc8" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">データベースオブジェクトを削除するには、条件付きコマンドを使用します（つまり、 &lt;code&gt;IF EXISTS&lt;/code&gt; 句を追加します）。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="03fb63958860db5f3f91183fba351eaf47350bb0" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) to drop databases and other objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">データベースやその他のオブジェクトを削除するには、条件付きコマンドを使用します（つまり、 &lt;code&gt;IF EXISTS&lt;/code&gt; 句を追加します）。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="7dab14262df7a0d62d0ac14dd30b69bdadab90b1" translate="yes" xml:space="preserve">
          <source>Use conditional commands (i.e., add an &lt;code&gt;IF EXISTS&lt;/code&gt; clause) when cleaning database objects. This option is not valid unless &lt;code&gt;--clean&lt;/code&gt; is also specified.</source>
          <target state="translated">データベースオブジェクトをクリーン &lt;code&gt;IF EXISTS&lt;/code&gt; ときは、条件付きコマンドを使用します（つまり、IF EXISTS句を追加します）。 &lt;code&gt;--clean&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="f8dc23b011f6f1a62e695d4c31ea4636fb489dcc" translate="yes" xml:space="preserve">
          <source>Use efficient file cloning (also known as &amp;ldquo;reflinks&amp;rdquo; on some systems) instead of copying files to the new cluster. This can result in near-instantaneous copying of the data files, giving the speed advantages of &lt;code&gt;-k&lt;/code&gt;/&lt;code&gt;--link&lt;/code&gt; while leaving the old cluster untouched.</source>
          <target state="translated">新しいクラスターにファイルをコピーする代わりに、効率的なファイルのクローン作成（一部のシステムでは「reflinks」とも呼ばれます）を使用します。これにより、データファイルのコピーがほぼ瞬時に行われ、古いクラスターに影響を与えずに &lt;code&gt;-k&lt;/code&gt; / &lt;code&gt;--link&lt;/code&gt; の速度の利点が得られます。</target>
        </trans-unit>
        <trans-unit id="717457386c7410d1c0caadadb8bcf5cee9b94ef2" translate="yes" xml:space="preserve">
          <source>Use genetic query optimization to plan queries with at least this many &lt;code&gt;FROM&lt;/code&gt; items involved. (Note that a &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; construct counts as only one &lt;code&gt;FROM&lt;/code&gt; item.) The default is 12. For simpler queries it is usually best to use the regular, exhaustive-search planner, but for queries with many tables the exhaustive search takes too long, often longer than the penalty of executing a suboptimal plan. Thus, a threshold on the size of the query is a convenient way to manage use of GEQO.</source>
          <target state="translated">遺伝的クエリ最適化を使用して、少なくともこの数の &lt;code&gt;FROM&lt;/code&gt; アイテムが含まれるクエリを計画します。（ &lt;code&gt;FULL OUTER JOIN&lt;/code&gt; 構文は1つの &lt;code&gt;FROM&lt;/code&gt; アイテムとしてのみカウントされることに注意してください。）デフォルトは12です。単純なクエリの場合、通常、完全な検索プランナーを使用するのが最適ですが、多くのテーブルを含むクエリの場合、完全な検索に時間がかかりすぎます多くの場合、次善の計画を実行するペナルティよりも長くなります。したがって、クエリのサイズのしきい値は、GEQOの使用を管理する便利な方法です。</target>
        </trans-unit>
        <trans-unit id="a0976de4de13332a56e83de88d1173b0054dd784" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;INHERITS&lt;/code&gt; creates a persistent relationship between the new child table and its parent table(s). Schema modifications to the parent(s) normally propagate to children as well, and by default the data of the child table is included in scans of the parent(s).</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; を使用すると、新しい子テーブルとその親テーブルの間に永続的な関係が作成されます。親へのスキーマの変更は通常、子にも反映されます。デフォルトでは、子テーブルのデータは親のスキャンに含まれます。</target>
        </trans-unit>
        <trans-unit id="9e4eb26aa371684361e3e419e078890b371282ac" translate="yes" xml:space="preserve">
          <source>Use of most of these functions requires PostgreSQL to have been built with &lt;code&gt;configure --with-libxml&lt;/code&gt;.</source>
          <target state="translated">これらの関数のほとんどを使用するには、PostgreSQLが &lt;code&gt;configure --with-libxml&lt;/code&gt; で構築されている必要があります。</target>
        </trans-unit>
        <trans-unit id="c68e27d415e6287dfc4c6988546eee3d268cda34" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g. &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">記号参照の使用は、 &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; を列の定義にアタッチすることにより、特定のカタログ列で有効になります。ここで、 &lt;code&gt;lookuprule&lt;/code&gt; は、参照されるカタログの名前です（例： &lt;code&gt;pg_proc&lt;/code&gt; )。 &lt;code&gt;BKI_LOOKUP&lt;/code&gt; は、型の列に取り付けることができる &lt;code&gt;Oid&lt;/code&gt; 、 &lt;code&gt;regproc&lt;/code&gt; 、 &lt;code&gt;oidvector&lt;/code&gt; 、または &lt;code&gt;Oid[]&lt;/code&gt; 。後者の2つのケースでは、配列の各要素に対してルックアップを実行することを意味します。</target>
        </trans-unit>
        <trans-unit id="3fb4ce36062b56e26da7090e374ab7610c6e2ceb" translate="yes" xml:space="preserve">
          <source>Use of symbolic references is enabled in a particular catalog column by attaching &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; to the column's definition, where &lt;code&gt;lookuprule&lt;/code&gt; is the name of the referenced catalog, e.g., &lt;code&gt;pg_proc&lt;/code&gt;. &lt;code&gt;BKI_LOOKUP&lt;/code&gt; can be attached to columns of type &lt;code&gt;Oid&lt;/code&gt;, &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;oidvector&lt;/code&gt;, or &lt;code&gt;Oid[]&lt;/code&gt;; in the latter two cases it implies performing a lookup on each element of the array.</source>
          <target state="translated">シンボリック参照の使用は、 &lt;code&gt;BKI_LOOKUP(lookuprule)&lt;/code&gt; を列の定義に付加することにより、特定のカタログ列で有効になります。ここで、 &lt;code&gt;lookuprule&lt;/code&gt; は、参照されるカタログの名前です（例： &lt;code&gt;pg_proc&lt;/code&gt; )。 &lt;code&gt;BKI_LOOKUP&lt;/code&gt; は、タイプ &lt;code&gt;Oid&lt;/code&gt; 、 &lt;code&gt;regproc&lt;/code&gt; 、 &lt;code&gt;oidvector&lt;/code&gt; 、または &lt;code&gt;Oid[]&lt;/code&gt; 列にアタッチできます。後者の2つのケースでは、配列の各要素でルックアップを実行することを意味します。</target>
        </trans-unit>
        <trans-unit id="7de245d3c3aa0bf5e90f594f4cb93e3038943a92" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;RETURNING&lt;/code&gt; clause requires &lt;code&gt;SELECT&lt;/code&gt; privilege on all columns mentioned in &lt;code&gt;RETURNING&lt;/code&gt;. If you use the &lt;code&gt;query&lt;/code&gt; clause to insert rows from a query, you of course need to have &lt;code&gt;SELECT&lt;/code&gt; privilege on any table or column used in the query.</source>
          <target state="translated">使用 &lt;code&gt;RETURNING&lt;/code&gt; 句が必要です &lt;code&gt;SELECT&lt;/code&gt; で言及したすべての列の特権 &lt;code&gt;RETURNING&lt;/code&gt; を。 &lt;code&gt;query&lt;/code&gt; 句を使用してクエリから行を挿入する場合は、もちろん、クエリで使用されるすべてのテーブルまたは列に対する &lt;code&gt;SELECT&lt;/code&gt; 権限が必要です。</target>
        </trans-unit>
        <trans-unit id="2aa84cc2dc2791298c5a401376b7bb182eec75e7" translate="yes" xml:space="preserve">
          <source>Use real data for experimentation. Using test data for setting up indexes will tell you what indexes you need for the test data, but that is all.</source>
          <target state="translated">実データを実験に使う インデックスの設定にテストデータを使えば、テストデータに必要なインデックスがわかりますが、それだけです。</target>
        </trans-unit>
        <trans-unit id="740a1a424b9afbaad4fd5f97eac328593356e696" translate="yes" xml:space="preserve">
          <source>Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.</source>
          <target state="translated">コマンド入力の終端には、改行だけではなく、セミコロンと改行2行を使用してください。</target>
        </trans-unit>
        <trans-unit id="493672dde3eb1e21802c93c463663707684dc28f" translate="yes" xml:space="preserve">
          <source>Use separate session key. Public-key encryption always uses a separate session key; this option is for symmetric-key encryption, which by default uses the S2K key directly.</source>
          <target state="translated">別々のセッション鍵を使用します。公開鍵暗号化は常に別のセッション鍵を使用します。このオプションは対称鍵暗号化のためのもので、デフォルトではS2K鍵を直接使用します。</target>
        </trans-unit>
        <trans-unit id="93c526253accc03345c125a338a69425d93d7a5c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt; statement to drop views.</source>
          <target state="translated">&lt;a href=&quot;sql-dropview&quot;&gt;DROP VIEW&lt;/a&gt;ステートメントを使用してビューを削除します。</target>
        </trans-unit>
        <trans-unit id="0d8fcf6d0e2c0c387fa9db23f6382b953340061f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションを使用します。詳細については、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3b4b457d273cfa55849542aa4f8ee8d5c092684f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option. See &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;, where all the caveats of this option are explained in detail.</source>
          <target state="translated">&lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションを使用します。このオプションのすべての警告が詳細に説明されている&lt;a href=&quot;sql-reindex&quot;&gt;REINDEXを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="49e85f329c30105292985206289324c8f90af224" translate="yes" xml:space="preserve">
          <source>Use the alternative column-list syntax to do the same update:</source>
          <target state="translated">代替カラムリスト構文を使用して、同じ更新を行います。</target>
        </trans-unit>
        <trans-unit id="c367993bbb1f90b5675f542abe2a7cf24ff8d497" translate="yes" xml:space="preserve">
          <source>Use the manifest file at the specified path, rather than one located in the root of the backup directory.</source>
          <target state="translated">バックアップ ディレクトリのルートにあるマニフェスト ファイルではなく、指定されたパスにあるマニフェスト ファイルを使用します。</target>
        </trans-unit>
        <trans-unit id="9ae2307b8f401e6a987e3d05544bf2939cd859f9" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_COLLATE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; ロケールカテゴリには、指定されたオペレーティングシステムロケールを使用します。</target>
        </trans-unit>
        <trans-unit id="55a394e7b9e61f2a206b4b6967eab6c67d2c7b7c" translate="yes" xml:space="preserve">
          <source>Use the specified operating system locale for the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale category.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; ロケールカテゴリには、指定されたオペレーティングシステムロケールを使用します。</target>
        </trans-unit>
        <trans-unit id="b2aa6b91b4c4ba84fa390b2a6da37aa75a60894a" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.87&lt;/a&gt; for more details).</source>
          <target state="translated">データベースのダンプを作成するときに、指定された同期スナップショットを使用します（詳細については、&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;表9.87&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="f01c307a5f93cc4ea8d811925d49d9a9c26369ed" translate="yes" xml:space="preserve">
          <source>Use the specified synchronized snapshot when making a dump of the database (see &lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;Table 9.88&lt;/a&gt; for more details).</source>
          <target state="translated">データベースのダンプを作成するときは、指定された同期スナップショットを使用します（詳細については、&lt;a href=&quot;functions-admin#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE&quot;&gt;表9.88&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="ee78ab2ce0e01deb66fa480713a33b2c2b35d2ab" translate="yes" xml:space="preserve">
          <source>Use the specified value of &lt;code&gt;extra_float_digits&lt;/code&gt; when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">使用可能な最大精度の代わりに、浮動小数点データをダンプするときに、 &lt;code&gt;extra_float_digits&lt;/code&gt; の指定された値を使用します。バックアップ目的で作成されたルーチンダンプでは、このオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="af4516f566a55d94c31709c01f556432e3bd7291" translate="yes" xml:space="preserve">
          <source>Use the specified value of extra_float_digits when dumping floating-point data, instead of the maximum available precision. Routine dumps made for backup purposes should not use this option.</source>
          <target state="translated">浮動小数点データをダンプする際には、利用可能な最大精度ではなく、指定された extra_float_digits の値を使用します。バックアップを目的とした定期的なダンプでは、このオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="6f31da9aa85cb07454372ac17645a52a84247324" translate="yes" xml:space="preserve">
          <source>Use this sequence in an &lt;code&gt;INSERT&lt;/code&gt; command:</source>
          <target state="translated">このシーケンスを &lt;code&gt;INSERT&lt;/code&gt; コマンドで使用します。</target>
        </trans-unit>
        <trans-unit id="29370364d5a3aa7edfb47c0679c084d535a999d7" translate="yes" xml:space="preserve">
          <source>Used to allow inference of partial unique indexes. Any indexes that satisfy the predicate (which need not actually be partial indexes) can be inferred. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format. &lt;code&gt;SELECT&lt;/code&gt; privilege on any column appearing within &lt;code&gt;index_predicate&lt;/code&gt; is required.</source>
          <target state="translated">部分的にユニークなインデックスの推論を可能にするために使用されます。述部を満たすインデックス（実際には部分インデックスである必要はありません）を推測できます。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。 &lt;code&gt;index_predicate&lt;/code&gt; 内に表示される列に対する &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="60a26aae579e4125ce2ef1b4188cb642a6c52362" translate="yes" xml:space="preserve">
          <source>Used to compute the maximum amount of memory that hash-based operations can use. The final limit is determined by multiplying &lt;code&gt;work_mem&lt;/code&gt; by &lt;code&gt;hash_mem_multiplier&lt;/code&gt;. The default value is 1.0, which makes hash-based operations subject to the same simple &lt;code&gt;work_mem&lt;/code&gt; maximum as sort-based operations.</source>
          <target state="translated">ハッシュベースの操作で使用できるメモリの最大量を計算するために使用されます。最終的な制限は、 &lt;code&gt;work_mem&lt;/code&gt; に &lt;code&gt;hash_mem_multiplier&lt;/code&gt; を掛けることによって決定されます。デフォルト値は1.0です。これにより、ハッシュベースの操作は、ソートベースの操作と同じ単純な &lt;code&gt;work_mem&lt;/code&gt; の最大値の対象になります。</target>
        </trans-unit>
        <trans-unit id="1bfbb286795d184b793a60a1094e6c47b8ed4218" translate="yes" xml:space="preserve">
          <source>Useful values for production work probably range from a small number of hours to a few days. Small values (such as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;) are only allowed because they may sometimes be useful for testing. While a setting as high as &lt;code&gt;60d&lt;/code&gt; is allowed, please note that in many workloads extreme bloat or transaction ID wraparound may occur in much shorter time frames.</source>
          <target state="translated">本番作業に役立つ値は、おそらく数時間から数日までの範囲です。小さな値（ &lt;code&gt;0&lt;/code&gt; や &lt;code&gt;1min&lt;/code&gt; など）は、テストに役立つ場合があるため、許可されています。 &lt;code&gt;60d&lt;/code&gt; までの設定が許可されていますが、多くのワークロードでは、極端な膨張またはトランザクションIDの折り返しがはるかに短い時間枠で発生する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="0aa9c997122e493dfcfb31ff0542b184a558e6ef" translate="yes" xml:space="preserve">
          <source>User Name Maps</source>
          <target state="translated">ユーザー名マップ</target>
        </trans-unit>
        <trans-unit id="657c8b98d31db02ca6e2f49846863d392059fe65" translate="yes" xml:space="preserve">
          <source>User bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">ユーザーはすべての行レベルのセキュリティポリシーをバイパスします。詳細については、&lt;a href=&quot;ddl-rowsecurity&quot;&gt;セクション5.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="17a367250b51dc731bdf8cbd166e2c6618238172" translate="yes" xml:space="preserve">
          <source>User can create databases</source>
          <target state="translated">ユーザーはデータベースを作成することができます。</target>
        </trans-unit>
        <trans-unit id="0cd638046cbfe5c1f3e3cd84a3d83b310d114f21" translate="yes" xml:space="preserve">
          <source>User can initiate streaming replication and put the system in and out of backup mode.</source>
          <target state="translated">ユーザーはストリーミングレプリケーションを開始し、システムをバックアップモードに入れたり外したりすることができます。</target>
        </trans-unit>
        <trans-unit id="62ff3be7aa18f82b61ae56cce7156698ab778283" translate="yes" xml:space="preserve">
          <source>User is a superuser</source>
          <target state="translated">ユーザーはスーパーユーザー</target>
        </trans-unit>
        <trans-unit id="4aef5e6fb407d9fa24def89a2aaec4ed9412ef6a" translate="yes" xml:space="preserve">
          <source>User mapping</source>
          <target state="translated">ユーザーマッピング</target>
        </trans-unit>
        <trans-unit id="0381065a82fe9d6c10d8cd3e9089f5c14f9312b8" translate="yes" xml:space="preserve">
          <source>User mapping specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としてのユーザーマッピング固有のオプション</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">ユーザー名</target>
        </trans-unit>
        <trans-unit id="0966c5e99e856745941e09bf863b1894eaa04766" translate="yes" xml:space="preserve">
          <source>User name for the user to run the service as. For domain users, use the format &lt;code&gt;DOMAIN\username&lt;/code&gt;.</source>
          <target state="translated">サービスを実行するユーザーのユーザー名。ドメインユーザーの場合は、 &lt;code&gt;DOMAIN\username&lt;/code&gt; という形式を使用します。</target>
        </trans-unit>
        <trans-unit id="ae03b2f53e94d67697836cc9ddba3d24303f1bd3" translate="yes" xml:space="preserve">
          <source>User name maps are defined in the ident map file, which by default is named &lt;code&gt;pg_ident.conf&lt;/code&gt; and is stored in the cluster's data directory. (It is possible to place the map file elsewhere, however; see the &lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;ident_file&lt;/a&gt; configuration parameter.) The ident map file contains lines of the general form:</source>
          <target state="translated">ユーザー名マップは、デフォルトで &lt;code&gt;pg_ident.conf&lt;/code&gt; という名前のidentマップファイルで定義され、クラスターのデータディレクトリに保存されます。（ただし、マップファイルを別の場所に配置することもできます&lt;a href=&quot;runtime-config-file-locations#GUC-IDENT-FILE&quot;&gt;。ident_file&lt;/a&gt;構成パラメーターを参照してください。）identマップファイルには、一般的な形式の行が含まれています。</target>
        </trans-unit>
        <trans-unit id="26c83bd5ba1faee58ca4dfcad77ca8603bcdb897" translate="yes" xml:space="preserve">
          <source>User name of the mapping. &lt;code&gt;CURRENT_USER&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; match the name of the current user. &lt;code&gt;PUBLIC&lt;/code&gt; is used to match all present and future user names in the system.</source>
          <target state="translated">マッピングのユーザー名。 &lt;code&gt;CURRENT_USER&lt;/code&gt; および &lt;code&gt;USER&lt;/code&gt; は、現在のユーザーの名前と一致します。 &lt;code&gt;PUBLIC&lt;/code&gt; は、システム内の現在および将来のすべてのユーザー名を照合するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5f782be03fcdc443b383e428fe084103c7519032" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to create).</source>
          <target state="translated">接続するユーザー名(作成するユーザー名ではありません)。</target>
        </trans-unit>
        <trans-unit id="58a48e5ec3f1ddd8734180ce7a8bcf7ce3e61813" translate="yes" xml:space="preserve">
          <source>User name to connect as (not the user name to drop).</source>
          <target state="translated">接続するユーザー名(ドロップするユーザー名ではありません)。</target>
        </trans-unit>
        <trans-unit id="6c7c5d855fc83ff64eb10669f8523b7d11212f01" translate="yes" xml:space="preserve">
          <source>User name to connect as.</source>
          <target state="translated">接続するユーザー名。</target>
        </trans-unit>
        <trans-unit id="104f2eb40da0056ec5533c282848e3fce154c0c2" translate="yes" xml:space="preserve">
          <source>User name to connect as. Defaults to current operating system user name.</source>
          <target state="translated">接続するユーザー名。デフォルトは、現在のオペレーティングシステムのユーザー名です。</target>
        </trans-unit>
        <trans-unit id="d47cce93b040f97f45693a064d2ec0fe0d47cbfa" translate="yes" xml:space="preserve">
          <source>User-defined constraint triggers (created with &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt;) also give rise to an entry in this table.</source>
          <target state="translated">ユーザー定義の制約トリガー（ &lt;code&gt;CREATE CONSTRAINT TRIGGER&lt;/code&gt; で作成されたもの）も、このテーブルのエントリを生成します。</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">ユーザー定義タイプ</target>
        </trans-unit>
        <trans-unit id="08a19bf7678e0c925ef7e00adabbc0a5965212bf" translate="yes" xml:space="preserve">
          <source>Users (roles) that are to be added to or removed from the group. The users must already exist; &lt;code&gt;ALTER GROUP&lt;/code&gt; does not create or drop users.</source>
          <target state="translated">グループに追加またはグループから削除されるユーザー（ロール）。ユーザーはすでに存在している必要があります。 &lt;code&gt;ALTER GROUP&lt;/code&gt; はユーザーを作成または削除しません。</target>
        </trans-unit>
        <trans-unit id="c368e154de403e348ebf85b5c480f63c95e940b6" translate="yes" xml:space="preserve">
          <source>Users accustomed to working with other SQL database management systems might be disappointed by the performance of the &lt;code&gt;count&lt;/code&gt; aggregate when it is applied to the entire table. A query like:</source>
          <target state="translated">他のSQLデータベース管理システムでの作業に慣れているユーザーは、 &lt;code&gt;count&lt;/code&gt; 集計がテーブル全体に適用されるときのパフォーマンスに失望する可能性があります。次のようなクエリ：</target>
        </trans-unit>
        <trans-unit id="ec14cfda8b568c538e7a2b35ec4764216fe766a6" translate="yes" xml:space="preserve">
          <source>Users can define their own range types. The most common reason to do this is to use ranges over subtypes not provided among the built-in range types. For example, to define a new range type of subtype &lt;code&gt;float8&lt;/code&gt;:</source>
          <target state="translated">ユーザーは独自の範囲タイプを定義できます。これを行う最も一般的な理由は、組み込みの範囲型の中で提供されていないサブタイプの範囲を使用するためです。たとえば、サブタイプ &lt;code&gt;float8&lt;/code&gt; の新しい範囲タイプを定義するには：</target>
        </trans-unit>
        <trans-unit id="9a9efc48c7a0e88a7803961454d90d55b5ba0528" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of role names means that there cannot be different roles named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">クラスタのユーザーは、必ずしもクラスタ内のすべてのデータベースにアクセスする権限を持っているとは限りません。ロール名の共有は、同じクラスター内の2つのデータベースに &lt;code&gt;joe&lt;/code&gt; という名前の異なるロールが存在できないことを意味します。ただし、システムは、 &lt;code&gt;joe&lt;/code&gt; が一部のデータベースにのみアクセスできるように構成できます。</target>
        </trans-unit>
        <trans-unit id="4944fa9df06f02dea3273ddeb97bb2eab5830741" translate="yes" xml:space="preserve">
          <source>Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, &lt;code&gt;joe&lt;/code&gt; in two databases in the same cluster; but the system can be configured to allow &lt;code&gt;joe&lt;/code&gt; access to only some of the databases.</source>
          <target state="translated">クラスタのユーザーは、必ずしもクラスタ内のすべてのデータベースにアクセスする特権を持っているとは限りません。ユーザー名を共有するということは、同じクラスター内の2つのデータベースに &lt;code&gt;joe&lt;/code&gt; という名前の異なるユーザーが存在することはできないということです。ただし、 &lt;code&gt;joe&lt;/code&gt; 一部のデータベースにのみアクセスできるようにシステムを構成できます。</target>
        </trans-unit>
        <trans-unit id="655defefcbd5cf77a94fb403c6b891d5f809540a" translate="yes" xml:space="preserve">
          <source>Users should be clear that tables that are regularly and heavily updated on the primary server will quickly cause cancellation of longer running queries on the standby. In such cases the setting of a finite value for &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; can be considered similar to setting &lt;code&gt;statement_timeout&lt;/code&gt;.</source>
          <target state="translated">プライマリサーバーで定期的かつ頻繁に更新されるテーブルは、スタンバイで長時間実行されているクエリをすぐにキャンセルすることをユーザーは明確にすべきです。このような場合、 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; または &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; の有限値の設定は、 &lt;code&gt;statement_timeout&lt;/code&gt; の設定と同様に考えることができます。</target>
        </trans-unit>
        <trans-unit id="dc34515c6a1d7984b3e11718da650ce1ef5ed348" translate="yes" xml:space="preserve">
          <source>Users sometimes try to declare operators applying just to a domain type. This is possible but is not nearly as useful as it might seem, because the operator resolution rules are designed to select operators applying to the domain's base type. As an example consider</source>
          <target state="translated">ユーザーは時々、ドメインの型だけに適用される演算子を宣言しようとすることがあります。これは可能ですが、見かけほど有用ではありません。なぜなら、演算子解決ルールはドメインのベースタイプに適用される演算子を選択するように設計されているからです。例として以下を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1772f82727e2e70cce145a14908f76eba9dee789" translate="yes" xml:space="preserve">
          <source>Users sometimes wonder why host names are handled in this seemingly complicated way, with two name resolutions including a reverse lookup of the client's IP address. This complicates use of the feature in case the client's reverse DNS entry is not set up or yields some undesirable host name. It is done primarily for efficiency: this way, a connection attempt requires at most two resolver lookups, one reverse and one forward. If there is a resolver problem with some address, it becomes only that client's problem. A hypothetical alternative implementation that only did forward lookups would have to resolve every host name mentioned in &lt;code&gt;pg_hba.conf&lt;/code&gt; during every connection attempt. That could be quite slow if many names are listed. And if there is a resolver problem with one of the host names, it becomes everyone's problem.</source>
          <target state="translated">ユーザーは、ホスト名がこの一見複雑に見える方法で処理される理由を不思議に思うことがあります。クライアントのIPアドレスの逆引きを含む2つの名前解決があります。これにより、クライアントの逆引きDNSエントリが設定されていない場合や、望ましくないホスト名が生成された場合に、機能の使用が複雑になります。これは主に効率化のために行われます。この方法では、接続の試行には最大で2つのリゾルバルックアップが必要です。一部のアドレスにリゾルバーの問題がある場合、それはそのクライアントの問題のみになります。前方参照のみを行った架空の代替実装では、 &lt;code&gt;pg_hba.conf&lt;/code&gt; に記載されているすべてのホスト名を解決する必要がありますすべての接続試行中。多くの名前がリストされている場合、それはかなり遅くなる可能性があります。また、ホスト名の1つにリゾルバーの問題がある場合、それは全員の問題になります。</target>
        </trans-unit>
        <trans-unit id="4adcca052990f33f0c6c8200c5c596110e4cd88f" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">ユーザーは、 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; を発行することにより、セッションが読み取り専用かどうかを確認できます。さらに、一連の関数（&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85&lt;/a&gt;）により、ユーザーはスタンバイサーバーに関する情報にアクセスできます。これらにより、データベースの現在の状態を認識するプログラムを作成できます。これらを使用して、回復の進行状況を監視したり、データベースを特定の状態に復元する複雑なプログラムを作成したりできます。</target>
        </trans-unit>
        <trans-unit id="83c06bb19535af77b0a89cf5ee576459c7758e4d" translate="yes" xml:space="preserve">
          <source>Users will be able to tell whether their session is read-only by issuing &lt;code&gt;SHOW transaction_read_only&lt;/code&gt;. In addition, a set of functions (&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt;) allow users to access information about the standby server. These allow you to write programs that are aware of the current state of the database. These can be used to monitor the progress of recovery, or to allow you to write complex programs that restore the database to particular states.</source>
          <target state="translated">ユーザーは、 &lt;code&gt;SHOW transaction_read_only&lt;/code&gt; を発行することにより、セッションが読み取り専用かどうかを確認できます。さらに、一連の機能（&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.86&lt;/a&gt;）を使用すると、ユーザーはスタンバイサーバーに関する情報にアクセスできます。これらを使用すると、データベースの現在の状態を認識するプログラムを作成できます。これらを使用して、リカバリの進行状況を監視したり、データベースを特定の状態に復元する複雑なプログラムを作成したりできます。</target>
        </trans-unit>
        <trans-unit id="28e2bf0df748000aab563d6b102d035c272f7dd2" translate="yes" xml:space="preserve">
          <source>Users will stop waiting if a fast shutdown is requested. However, as when using asynchronous replication, the server will not fully shutdown until all outstanding WAL records are transferred to the currently connected standby servers.</source>
          <target state="translated">高速シャットダウンが要求された場合、ユーザーは待機を停止します。しかし、非同期レプリケーションを使用している場合と同様に、現在接続されているスタンバイサーバーにすべての未処理のWALレコードが転送されるまで、サーバーは完全にシャットダウンしません。</target>
        </trans-unit>
        <trans-unit id="00379b69f39e7e2d3d7c05f05b12ede542302d0d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt; on an object additionally requires &lt;code&gt;relabelfrom&lt;/code&gt; permission for the object in conjunction with its old security label and &lt;code&gt;relabelto&lt;/code&gt; permission for the object in conjunction with its new security label. (In cases where multiple label providers are installed and the user tries to set a security label, but it is not managed by SELinux, only &lt;code&gt;setattr&lt;/code&gt; should be checked here. This is currently not done due to implementation restrictions.)</source>
          <target state="translated">オブジェクトで&lt;a href=&quot;sql-security-label&quot;&gt;SECURITY LABEL&lt;/a&gt;を使用するには、古いセキュリティラベルと &lt;code&gt;relabelto&lt;/code&gt; てオブジェクトのrelabelfrom権限と、新しいセキュリティラベルと組み合わせてオブジェクトの &lt;code&gt;relabelfrom&lt;/code&gt; 権限がさらに必要です。（複数のラベルプロバイダーがインストールされており、ユーザーがセキュリティラベルを設定しようとしたが、SELinuxで管理されていない場合は、 &lt;code&gt;setattr&lt;/code&gt; のみをここで確認する必要があります。これは、実装上の制限により現在行われていません。）</target>
        </trans-unit>
        <trans-unit id="7ba7d6f6db215ecebd0a0dd010a3ef4d72762c57" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; on this view, specifically updating the &lt;code&gt;setting&lt;/code&gt; column, is the equivalent of issuing &lt;code&gt;SET&lt;/code&gt; commands. For example, the equivalent of</source>
          <target state="translated">このビューで&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;を使用すること、特に &lt;code&gt;setting&lt;/code&gt; 列を更新することは、 &lt;code&gt;SET&lt;/code&gt; コマンドを発行することと同じです。たとえば、</target>
        </trans-unit>
        <trans-unit id="9f4a279994eeee7b66ef6f4b6c4072e3efe337a2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ALL&lt;/code&gt; for a policy means that it will apply to all commands, regardless of the type of command. If an &lt;code&gt;ALL&lt;/code&gt; policy exists and more specific policies exist, then both the &lt;code&gt;ALL&lt;/code&gt; policy and the more specific policy (or policies) will be applied. Additionally, &lt;code&gt;ALL&lt;/code&gt; policies will be applied to both the selection side of a query and the modification side, using the &lt;code&gt;USING&lt;/code&gt; expression for both cases if only a &lt;code&gt;USING&lt;/code&gt; expression has been defined.</source>
          <target state="translated">ポリシーに &lt;code&gt;ALL&lt;/code&gt; を使用すると、コマンドのタイプに関係なく、すべてのコマンドに適用されます。場合 &lt;code&gt;ALL&lt;/code&gt; 次に、ポリシーが存在し、より具体的なポリシーが存在し、両方の &lt;code&gt;ALL&lt;/code&gt; のポリシーと、より具体的なポリシー（又はポリシー）が適用されます。また、 &lt;code&gt;ALL&lt;/code&gt; ポリシーが使用して、クエリの選択側と変更側の両方に適用されます &lt;code&gt;USING&lt;/code&gt; 場合にのみ、両方のケースのための式を &lt;code&gt;USING&lt;/code&gt; 式が定義されています。</target>
        </trans-unit>
        <trans-unit id="b1caa6904d1b2e3c70cf23410fccedf2e858e4cc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELETE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;DELETE&lt;/code&gt; commands. Only rows that pass this policy will be seen by a &lt;code&gt;DELETE&lt;/code&gt; command. There can be rows that are visible through a &lt;code&gt;SELECT&lt;/code&gt; that are not available for deletion, if they do not pass the &lt;code&gt;USING&lt;/code&gt; expression for the &lt;code&gt;DELETE&lt;/code&gt; policy.</source>
          <target state="translated">ポリシーに &lt;code&gt;DELETE&lt;/code&gt; を使用すると、 &lt;code&gt;DELETE&lt;/code&gt; コマンドに適用されます。このポリシーに合格した行のみが &lt;code&gt;DELETE&lt;/code&gt; コマンドで表示されます。 &lt;code&gt;DELETE&lt;/code&gt; ポリシーの &lt;code&gt;USING&lt;/code&gt; 式を渡さない場合、 &lt;code&gt;SELECT&lt;/code&gt; を介して表示できるが削除に使用できない行がある可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ba736c87dfcbb2c8e16a4a5fbcf41dc4d34ae6e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;INSERT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;INSERT&lt;/code&gt; commands. Rows being inserted that do not pass this policy will result in a policy violation error, and the entire &lt;code&gt;INSERT&lt;/code&gt; command will be aborted. An &lt;code&gt;INSERT&lt;/code&gt; policy cannot have a &lt;code&gt;USING&lt;/code&gt; expression, as it only applies in cases where records are being added to the relation.</source>
          <target state="translated">ポリシーに &lt;code&gt;INSERT&lt;/code&gt; を使用すると、 &lt;code&gt;INSERT&lt;/code&gt; コマンドに適用されます。このポリシーに合格しない行が挿入されると、ポリシー違反エラーが発生し、 &lt;code&gt;INSERT&lt;/code&gt; コマンド全体が中止されます。 &lt;code&gt;INSERT&lt;/code&gt; のポリシーが持つことはできません &lt;code&gt;USING&lt;/code&gt; 、それはレコードだけが関係に追加されている場合に適用されるように、式を。</target>
        </trans-unit>
        <trans-unit id="4584b8b01123eb82dc7847c4d9677c40b0e5bba4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ONLY&lt;/code&gt; to add or drop a constraint on only the partitioned table is supported as long as there are no partitions. Once partitions exist, using &lt;code&gt;ONLY&lt;/code&gt; will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints on the partitions themselves can be added and (if they are not present in the parent table) dropped.</source>
          <target state="translated">パーティションがない限り、 &lt;code&gt;ONLY&lt;/code&gt; を使用してパーティション分割されたテーブルのみに制約を追加または削除できます。パーティションが存在する場合、 &lt;code&gt;ONLY&lt;/code&gt; を使用するとエラーが発生します。パーティションが存在する場合、パーティションテーブルのみに対する制約の追加または削除はサポートされないためです。代わりに、パーティション自体に対する制約を追加し、（それらが親テーブルに存在しない場合は）削除できます。</target>
        </trans-unit>
        <trans-unit id="9191967f0b2195c21483c93a60dfe19fe3e18ef8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;PGCLIENTENCODING&lt;/code&gt;. If the environment variable &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">&lt;code&gt;PGCLIENTENCODING&lt;/code&gt; の使用。環境変数 &lt;code&gt;PGCLIENTENCODING&lt;/code&gt; がクライアントの環境で定義されている場合、サーバーへの接続が確立されると、そのクライアントエンコーディングが自動的に選択されます。（これはその後、上記の他の方法のいずれかを使用してオーバーライドできます。）</target>
        </trans-unit>
        <trans-unit id="de75f251dab5b0ad3801e8b63609c603b9f339f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SELECT&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;SELECT&lt;/code&gt; queries and whenever &lt;code&gt;SELECT&lt;/code&gt; permissions are required on the relation the policy is defined for. The result is that only those records from the relation that pass the &lt;code&gt;SELECT&lt;/code&gt; policy will be returned during a &lt;code&gt;SELECT&lt;/code&gt; query, and that queries that require &lt;code&gt;SELECT&lt;/code&gt; permissions, such as &lt;code&gt;UPDATE&lt;/code&gt;, will also only see those records that are allowed by the &lt;code&gt;SELECT&lt;/code&gt; policy. A &lt;code&gt;SELECT&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being retrieved from the relation.</source>
          <target state="translated">ポリシーに &lt;code&gt;SELECT&lt;/code&gt; を使用すると、ポリシーが &lt;code&gt;SELECT&lt;/code&gt; クエリに適用され、ポリシーが定義されている関係で &lt;code&gt;SELECT&lt;/code&gt; 権限が必要な場合は常に適用されます。その結果、 &lt;code&gt;SELECT&lt;/code&gt; ポリシーを通過するリレーションのレコードのみが &lt;code&gt;SELECT&lt;/code&gt; クエリ中に返され、 &lt;code&gt;UPDATE&lt;/code&gt; などの &lt;code&gt;SELECT&lt;/code&gt; 権限を必要とするクエリでも、 &lt;code&gt;SELECT&lt;/code&gt; ポリシーで許可されているレコードのみが表示されます。 &lt;code&gt;SELECT&lt;/code&gt; ポリシーが持つことができません &lt;code&gt;WITH CHECK&lt;/code&gt; それはレコードのみが関係から取得されている場合に適用されるように、式を。</target>
        </trans-unit>
        <trans-unit id="8ea11f118aea185625aef767542a580e19f76285" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SET client_encoding TO&lt;/code&gt;. Setting the client encoding can be done with this SQL command:</source>
          <target state="translated">&lt;code&gt;SET client_encoding TO&lt;/code&gt; を使用します。クライアントエンコーディングの設定は、次のSQLコマンドで実行できます。</target>
        </trans-unit>
        <trans-unit id="c3e9a2e659e09abe2efa2c5be22d40b62c3aee16" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Type=notify&lt;/code&gt; requires that the server binary was built with &lt;code&gt;configure --with-systemd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=notify&lt;/code&gt; を使用するには、サーバーバイナリが &lt;code&gt;configure --with-systemd&lt;/code&gt; でビルドされている必要があります。</target>
        </trans-unit>
        <trans-unit id="5f17447546dfac5a3cba43658b86d3ae11e9f49a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;UPDATE&lt;/code&gt; for a policy means that it will apply to &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; commands, as well as auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clauses of &lt;code&gt;INSERT&lt;/code&gt; commands. Since &lt;code&gt;UPDATE&lt;/code&gt; involves pulling an existing record and replacing it with a new modified record, &lt;code&gt;UPDATE&lt;/code&gt; policies accept both a &lt;code&gt;USING&lt;/code&gt; expression and a &lt;code&gt;WITH CHECK&lt;/code&gt; expression. The &lt;code&gt;USING&lt;/code&gt; expression determines which records the &lt;code&gt;UPDATE&lt;/code&gt; command will see to operate against, while the &lt;code&gt;WITH CHECK&lt;/code&gt; expression defines which modified rows are allowed to be stored back into the relation.</source>
          <target state="translated">ポリシーに &lt;code&gt;UPDATE&lt;/code&gt; を使用すると、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 、および &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; コマンドに加えて、 &lt;code&gt;INSERT&lt;/code&gt; コマンドの補助的な &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句にも適用されます。以来 &lt;code&gt;UPDATE&lt;/code&gt; は既存のレコードを引っ張って、新しい変更されたレコードでそれを置き換える必要、 &lt;code&gt;UPDATE&lt;/code&gt; のポリシーは、両方受け入れ &lt;code&gt;USING&lt;/code&gt; 表現と &lt;code&gt;WITH CHECK&lt;/code&gt; 式を。 &lt;code&gt;USING&lt;/code&gt; 記録表現判定する &lt;code&gt;UPDATE&lt;/code&gt; のコマンドは、反対に動作するために表示されますしばらく &lt;code&gt;WITH CHECK&lt;/code&gt; 式は、変更された行をリレーションに戻すことができるように定義します。</target>
        </trans-unit>
        <trans-unit id="4872b905960b3b0bb609a1d1f16d8a8085172d7f" translate="yes" xml:space="preserve">
          <source>Using WAL results in a significantly reduced number of disk writes, because only the log file needs to be flushed to disk to guarantee that a transaction is committed, rather than every data file changed by the transaction. The log file is written sequentially, and so the cost of syncing the log is much less than the cost of flushing the data pages. This is especially true for servers handling many small transactions touching different parts of the data store. Furthermore, when the server is processing many small concurrent transactions, one &lt;code&gt;fsync&lt;/code&gt; of the log file may suffice to commit many transactions.</source>
          <target state="translated">WALを使用すると、トランザクションによって変更されるすべてのデータファイルではなく、トランザクションがコミットされることを保証するためにログファイルのみをディスクにフラッシュする必要があるため、ディスク書き込みの数が大幅に削減されます。ログファイルは順次書き込まれるため、ログを同期するコストは、データページをフラッシュするコストよりもはるかに低くなります。これは、データストアのさまざまな部分にアクセスする多くの小さなトランザクションを処理するサーバーに特に当てはまります。さらに、サーバーが多数の小さな同時トランザクションを処理している場合、ログファイルの1つの &lt;code&gt;fsync&lt;/code&gt; で多くのトランザクションをコミットするのに十分な場合があります。</target>
        </trans-unit>
        <trans-unit id="c4792021563cf0153c3bbaaa6301ad807dbacef8" translate="yes" xml:space="preserve">
          <source>Using a SHA hash function provides a cryptographically secure digest of each file for users who wish to verify that the backup has not been tampered with, while the CRC32C algorithm provides a checksum that is much faster to calculate; it is good at catching errors due to accidental changes but is not resistant to malicious modifications. Note that, to be useful against an adversary who has access to the backup, the backup manifest would need to be stored securely elsewhere or otherwise verified not to have been modified since the backup was taken.</source>
          <target state="translated">SHAハッシュ関数を使用すると、バックアップが改ざんされていないことを確認したいユーザのために、暗号的に安全な各ファイルのダイジェストを提供します。バックアップへのアクセス権を持つ敵対者に対して有用であるためには、バックアップマニフェストを別の場所に安全に保存するか、バックアップを取得してから変更されていないことを検証する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2e62e4e51350449dc0eec4f1e12ec4aa76a1f3f9" translate="yes" xml:space="preserve">
          <source>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as bash or perl.</source>
          <target state="translated">アーカイブ処理で 1 つ以上のコマンドを使用したい場合は、別のスクリプトファイルを使用することをお勧めします。これにより、すべての複雑さをスクリプト内で管理することができ、bash や perl のような一般的なスクリプト言語で書くことができます。</target>
        </trans-unit>
        <trans-unit id="b28cc95da9f9c8ec1f9441e5caff1c654ea239b4" translate="yes" xml:space="preserve">
          <source>Using a simple integer &lt;code&gt;offset&lt;/code&gt; is preferred when defining an abbreviation whose offset from UTC has never changed, as such abbreviations are much cheaper to process than those that require consulting a time zone definition.</source>
          <target state="translated">UTCからのオフセットが変更されていない略語を定義する場合は、単純な整数 &lt;code&gt;offset&lt;/code&gt; を使用することをお勧めします。そのような略語は、タイムゾーン定義の参照が必要な略語よりも処理がはるかに安価です。</target>
        </trans-unit>
        <trans-unit id="d159535298801ecd67e86d11daf24d3f29bae4e5" translate="yes" xml:space="preserve">
          <source>Using a table:</source>
          <target state="translated">テーブルを使って</target>
        </trans-unit>
        <trans-unit id="97a7d609ae1fc837ff854c4a8fe8b3cbd1349e8b" translate="yes" xml:space="preserve">
          <source>Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial.</source>
          <target state="translated">pgAdminのような既存のグラフィカルなフロントエンドツールやODBCやJDBCをサポートするオフィススイートを使用して、データベースを作成したり操作したりします。これらの可能性については、このチュートリアルでは説明しません。</target>
        </trans-unit>
        <trans-unit id="9b0ce3043e87fd971bf85082c10b3ea412051c05" translate="yes" xml:space="preserve">
          <source>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</source>
          <target state="translated">異なる入れ子レベルでフィルタ式を使用することもできます。次の例では、最初にすべてのセグメントを場所別にフィルタリングし、利用可能な場合はこれらのセグメントの心拍数の高い値を返します。</target>
        </trans-unit>
        <trans-unit id="3f87542d489a5d09a003c3d32c1fdd090240fb1a" translate="yes" xml:space="preserve">
          <source>Using huge pages reduces overhead when using large contiguous chunks of memory, as PostgreSQL does, particularly when using large values of &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;. To use this feature in PostgreSQL you need a kernel with &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; and &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt;. You will also have to adjust the kernel setting &lt;code&gt;vm.nr_hugepages&lt;/code&gt;. To estimate the number of huge pages needed, start PostgreSQL without huge pages enabled and check the postmaster's anonymous shared memory segment size, as well as the system's huge page size, using the &lt;code&gt;/proc&lt;/code&gt; file system. This might look like:</source>
          <target state="translated">巨大なページを使用すると、PostgreSQLのように、連続したメモリの大きなチャンクを使用する場合、特に&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffersの&lt;/a&gt;値が大きい場合にオーバーヘッドが減少します。 PostgreSQLでこの機能を使用するには、 &lt;code&gt;CONFIG_HUGETLBFS=y&lt;/code&gt; および &lt;code&gt;CONFIG_HUGETLB_PAGE=y&lt;/code&gt; を指定したカーネルが必要です。また、カーネル設定 &lt;code&gt;vm.nr_hugepages&lt;/code&gt; を調整する必要があります。必要な巨大ページの数を推定するには、巨大ページを有効にせずにPostgreSQLを起動し、 &lt;code&gt;/proc&lt;/code&gt; ファイルシステムを使用して、postmasterの匿名共有メモリセグメントサイズとシステムの巨大ページサイズを確認します。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c0f4579fb33ddb8969cb60774c58272e5c781549" translate="yes" xml:space="preserve">
          <source>Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications.</source>
          <target state="translated">常識的に考えれば、このようなデータは数値のペアではなく、間隔として保存した方が便利なように見えます。実際には、ほとんどのアプリケーションでは、その方が効率的であることがわかります。</target>
        </trans-unit>
        <trans-unit id="a8fc95773ce3956bab8c2e8bf2027d9e849d1b1f" translate="yes" xml:space="preserve">
          <source>Using psql on a recently vacuumed or analyzed database, you can issue queries to see the disk usage of any table:</source>
          <target state="translated">最近バキュームされた、または分析されたデータベース上でpsqlを使用して、任意のテーブルのディスク使用量を確認するためにクエリを発行することができます。</target>
        </trans-unit>
        <trans-unit id="65181e02239e5820a5b7c0dec699536af98e9eef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command recurse to objects owned by other users.</source>
          <target state="translated">&lt;code&gt;CASCADE&lt;/code&gt; オプションを使用すると、コマンドが他のユーザーが所有するオブジェクトに再帰する場合があります。</target>
        </trans-unit>
        <trans-unit id="a3919689ac7e30c1a7b51bdbeb0b298903ed7b06" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;CASCADE&lt;/code&gt; option might make the command remove objects in other schemas besides the one(s) named.</source>
          <target state="translated">&lt;code&gt;CASCADE&lt;/code&gt; オプションを使用すると、指定したスキーマ以外のスキーマにあるオブジェクトがコマンドによって削除される場合があります。</target>
        </trans-unit>
        <trans-unit id="9d956f8965b7e70f75d823768214bbad6a425210" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;\encoding&lt;/code&gt; command in psql. &lt;code&gt;\encoding&lt;/code&gt; allows you to change client encoding on the fly. For example, to change the encoding to &lt;code&gt;SJIS&lt;/code&gt;, type:</source>
          <target state="translated">psqlで &lt;code&gt;\encoding&lt;/code&gt; コマンドを使用します。 &lt;code&gt;\encoding&lt;/code&gt; 使用すると、オンザフライでクライアントのエンコーディングを変更できます。たとえば、エンコーディングを &lt;code&gt;SJIS&lt;/code&gt; に変更するには、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="ce95ab1950e8fbb1a63e8b189b58b6a856d611e2" translate="yes" xml:space="preserve">
          <source>Using the configuration variable &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;. If the &lt;code&gt;client_encoding&lt;/code&gt; variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</source>
          <target state="translated">構成変数&lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;を使用します。場合 &lt;code&gt;client_encoding&lt;/code&gt; 変数が設定されているサーバーへの接続が行われたときに、そのクライアントの符号化方式が自動的に選択されます。（これは、上記の他の方法のいずれかを使用して後でオーバーライドできます。）</target>
        </trans-unit>
        <trans-unit id="7b44d852d97da519564a9d99f8e49c858203cdb6" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;&lt;code&gt;UNION&lt;/code&gt; Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;&lt;code&gt;INTERSECT&lt;/code&gt; Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;&lt;code&gt;EXCEPT&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">演算子 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、および &lt;code&gt;EXCEPT&lt;/code&gt; を使用すると、複数の &lt;code&gt;SELECT&lt;/code&gt; ステートメントの出力を組み合わせて単一の結果セットを形成できます。 &lt;code&gt;UNION&lt;/code&gt; のオペレータは、結果セットの一方または両方にあるすべての行を返します。 &lt;code&gt;INTERSECT&lt;/code&gt; のオペレータは、両方の結果セットに厳密にあるすべての行を返します。 &lt;code&gt;EXCEPT&lt;/code&gt; 演算子は、最初の結果セットではなく、第二にある行を返します。 3つすべてのケースで、 &lt;code&gt;ALL&lt;/code&gt; を指定しない限り、重複する行は削除されます。ノイズワード &lt;code&gt;DISTINCT&lt;/code&gt; を追加して、重複する行の削除を明示的に指定できます。お知らせ &lt;code&gt;DISTINCT&lt;/code&gt; &lt;code&gt;SELECT&lt;/code&gt; 自体のデフォルトは &lt;code&gt;ALL&lt;/code&gt; ですが、ここではデフォルトの動作です。 （下記の&lt;a href=&quot;sql-select#SQL-UNION&quot;&gt; &lt;code&gt;UNION&lt;/code&gt; &lt;/a&gt;節、&lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt; &lt;code&gt;INTERSECT&lt;/code&gt; &lt;/a&gt;節、および&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt; &lt;code&gt;EXCEPT&lt;/code&gt; &lt;/a&gt;節を参照してください。）</target>
        </trans-unit>
        <trans-unit id="60ff87ccea487ea3e7de59df62d12a0091443a0c" translate="yes" xml:space="preserve">
          <source>Using the operators &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, and &lt;code&gt;EXCEPT&lt;/code&gt;, the output of more than one &lt;code&gt;SELECT&lt;/code&gt; statement can be combined to form a single result set. The &lt;code&gt;UNION&lt;/code&gt; operator returns all rows that are in one or both of the result sets. The &lt;code&gt;INTERSECT&lt;/code&gt; operator returns all rows that are strictly in both result sets. The &lt;code&gt;EXCEPT&lt;/code&gt; operator returns the rows that are in the first result set but not in the second. In all three cases, duplicate rows are eliminated unless &lt;code&gt;ALL&lt;/code&gt; is specified. The noise word &lt;code&gt;DISTINCT&lt;/code&gt; can be added to explicitly specify eliminating duplicate rows. Notice that &lt;code&gt;DISTINCT&lt;/code&gt; is the default behavior here, even though &lt;code&gt;ALL&lt;/code&gt; is the default for &lt;code&gt;SELECT&lt;/code&gt; itself. (See &lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION Clause&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT Clause&lt;/a&gt;, and &lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT Clause&lt;/a&gt; below.)</source>
          <target state="translated">演算子 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、および &lt;code&gt;EXCEPT&lt;/code&gt; を使用して、複数の &lt;code&gt;SELECT&lt;/code&gt; ステートメントの出力を組み合わせて単一の結果セットを形成できます。 &lt;code&gt;UNION&lt;/code&gt; のオペレータは、結果セットの一方または両方にあるすべての行を返します。 &lt;code&gt;INTERSECT&lt;/code&gt; のオペレータは、両方の結果セットに厳密にあるすべての行を返します。 &lt;code&gt;EXCEPT&lt;/code&gt; 演算子は、最初の結果セットではなく、第二にある行を返します。 3つのケースすべてで、 &lt;code&gt;ALL&lt;/code&gt; が指定されていない限り、重複する行は削除されます。ノイズワード &lt;code&gt;DISTINCT&lt;/code&gt; を追加して、重複行の削除を明示的に指定できます。 &lt;code&gt;DISTINCT&lt;/code&gt; に注意してくださいここでは、 &lt;code&gt;ALL&lt;/code&gt; が &lt;code&gt;SELECT&lt;/code&gt; 自体のデフォルトですが、はデフォルトの動作です。（以下の&lt;a href=&quot;sql-select#SQL-UNION&quot;&gt;UNION句&lt;/a&gt;、&lt;a href=&quot;sql-select#SQL-INTERSECT&quot;&gt;INTERSECT句&lt;/a&gt;、および&lt;a href=&quot;sql-select#SQL-EXCEPT&quot;&gt;EXCEPT句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="345d4ccffce95dcf05491c18eea8197735fd71fd" translate="yes" xml:space="preserve">
          <source>Using this command, it is possible to either add privileges or restrict one's privileges. If the session user role has the &lt;code&gt;INHERIT&lt;/code&gt; attribute, then it automatically has all the privileges of every role that it could &lt;code&gt;SET ROLE&lt;/code&gt; to; in this case &lt;code&gt;SET ROLE&lt;/code&gt; effectively drops all the privileges assigned directly to the session user and to the other roles it is a member of, leaving only the privileges available to the named role. On the other hand, if the session user role has the &lt;code&gt;NOINHERIT&lt;/code&gt; attribute, &lt;code&gt;SET ROLE&lt;/code&gt; drops the privileges assigned directly to the session user and instead acquires the privileges available to the named role.</source>
          <target state="translated">このコマンドを使用すると、特権を追加したり、特権を制限したりすることができます。セッションユーザーロールに &lt;code&gt;INHERIT&lt;/code&gt; 属性がある場合は、 &lt;code&gt;SET ROLE&lt;/code&gt; を設定できるすべてのロールのすべての権限が自動的に付与されます。この場合、 &lt;code&gt;SET ROLE&lt;/code&gt; は、セッションユーザーとそれがメンバーである他のロールに直接割り当てられたすべての特権を効果的に削除し、指定されたロールが使用できる特権のみを残します。一方、セッションユーザーロールに &lt;code&gt;NOINHERIT&lt;/code&gt; 属性がある場合、 &lt;code&gt;SET ROLE&lt;/code&gt; はセッションユーザーに直接割り当てられた特権を削除し、代わりに指定されたロールで使用可能な特権を取得します。</target>
        </trans-unit>
        <trans-unit id="bf3833196f5808681a4549e6dae3e11c17ff7d14" translate="yes" xml:space="preserve">
          <source>Using this option is subtly different from writing &lt;code&gt;psql &amp;lt; filename&lt;/code&gt;. In general, both will do what you expect, but using &lt;code&gt;-f&lt;/code&gt; enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand.</source>
          <target state="translated">このオプションの使用は、 &lt;code&gt;psql &amp;lt; filename&lt;/code&gt; 書くこととは微妙に異なります。一般に、どちらでも期待どおりの結果が得られますが、 &lt;code&gt;-f&lt;/code&gt; を使用すると、行番号を含むエラーメッセージなどの便利な機能が有効になります。このオプションを使用すると、起動時のオーバーヘッドが減少する可能性もあります。一方、シェルの入力リダイレクトを使用するバリアントは、（理論的には）すべてを手動で入力した場合とまったく同じ出力が得られることが保証されています。</target>
        </trans-unit>
        <trans-unit id="bb94658d71fedbd45e9091422be0f40e3960ad97" translate="yes" xml:space="preserve">
          <source>Usually, a row reflecting an incorrect entry will have values for only the &lt;code&gt;line_number&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; fields.</source>
          <target state="translated">通常、正しくないエントリを反映する行には、 &lt;code&gt;line_number&lt;/code&gt; フィールドと &lt;code&gt;error&lt;/code&gt; フィールドの値しかありません。</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="615ff5ce2e5448f0eae82299f9e03df2b83f7a7d" translate="yes" xml:space="preserve">
          <source>VACUUM &amp;mdash; garbage-collect and optionally analyze a database</source>
          <target state="translated">VACUUM &amp;mdash;ガベージコレクション、およびオプションでデータベースの分析</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="7e2bb4ebd8bb3d86c6acc1d3b34b4607a8278459" translate="yes" xml:space="preserve">
          <source>VALUES &amp;mdash; compute a set of rows</source>
          <target state="translated">VALUES &amp;mdash;行のセットを計算します</target>
        </trans-unit>
        <trans-unit id="df605145d9028810fbbd6bb82ba2cbbdf49fe2f6" translate="yes" xml:space="preserve">
          <source>VALUES Lists</source>
          <target state="translated">VALUESリスト</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="49310dbe4a27690da5f29db4c406ef0b0e02e27a" translate="yes" xml:space="preserve">
          <source>Vacuum all databases.</source>
          <target state="translated">すべてのデータベースにバキュームをかける。</target>
        </trans-unit>
        <trans-unit id="d78bc05489ae0681fdd181a90fe2d3af72c88331" translate="yes" xml:space="preserve">
          <source>Vacuum all four standard tables before running the test. With neither &lt;code&gt;-n&lt;/code&gt; nor &lt;code&gt;-v&lt;/code&gt;, pgbench will vacuum the &lt;code&gt;pgbench_tellers&lt;/code&gt; and &lt;code&gt;pgbench_branches&lt;/code&gt; tables, and will truncate &lt;code&gt;pgbench_history&lt;/code&gt;.</source>
          <target state="translated">テストを実行する前に、4つの標準テーブルをすべて掃除してください。 &lt;code&gt;-n&lt;/code&gt; も &lt;code&gt;-v&lt;/code&gt; も使用しない場合、pgbenchは &lt;code&gt;pgbench_branches&lt;/code&gt; テーブルとpgbench_branchesテーブルをバキュームし、 &lt;code&gt;pgbench_tellers&lt;/code&gt; を切り捨て &lt;code&gt;pgbench_history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="558c7ef6cec7040888bc23237bf5bc10ac6c115d" translate="yes" xml:space="preserve">
          <source>Vacuum also allows removal of old files from the &lt;code&gt;pg_xact&lt;/code&gt; subdirectory, which is why the default is a relatively low 200 million transactions. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;.</source>
          <target state="translated">Vacuumを使用すると、 &lt;code&gt;pg_xact&lt;/code&gt; サブディレクトリから古いファイルを削除することもできます。そのため、デフォルトでは2億トランザクションが比較的低くなっています。このパラメーターはサーバーの起動時にのみ設定できますが、テーブルストレージパラメーターを変更することで、個々のテーブルの設定を減らすことができます。詳細は&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;項24.1.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f4af123f2e65a46f53e9a9ee64ca03a1079be929" translate="yes" xml:space="preserve">
          <source>Vacuum maintains a &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; for each table to keep track of which pages contain only tuples that are known to be visible to all active transactions (and all future transactions, until the page is again modified). This has two purposes. First, vacuum itself can skip such pages on the next run, since there is nothing to clean up.</source>
          <target state="translated">Vacuum は各テーブルの&lt;a href=&quot;storage-vm&quot;&gt;可視性マップ&lt;/a&gt;を維持して、すべてのアクティブなトランザクション（およびページが再度変更されるまで、将来のすべてのトランザクション）から見えることがわかっているタプルのみを含むページを追跡します。これには2つの目的があります。まず、掃除するものが何もないので、vacuum自体は次の実行でそのようなページをスキップできます。</target>
        </trans-unit>
        <trans-unit id="8fb0ba1bca8b404cfdbdb7679f9f4d296fc6f1fa" translate="yes" xml:space="preserve">
          <source>Vacuuming multixacts also allows removal of old files from the &lt;code&gt;pg_multixact/members&lt;/code&gt; and &lt;code&gt;pg_multixact/offsets&lt;/code&gt; subdirectories, which is why the default is a relatively low 400 million multixacts. This parameter can only be set at server start, but the setting can be reduced for individual tables by changing table storage parameters. For more information see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;.</source>
          <target state="translated">multixactをバキュームすると、 &lt;code&gt;pg_multixact/members&lt;/code&gt; および &lt;code&gt;pg_multixact/offsets&lt;/code&gt; サブディレクトリから古いファイルを削除することもできます。これが、デフォルトで4億のmultixactが比較的低い理由です。このパラメーターはサーバーの起動時にのみ設定できますが、テーブルストレージパラメーターを変更することで、個々のテーブルの設定を減らすことができます。詳細は&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;項24.1.5.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac19d033655fd012b97b53639462b257da978e6a" translate="yes" xml:space="preserve">
          <source>Valid Types</source>
          <target state="translated">有効なタイプ</target>
        </trans-unit>
        <trans-unit id="c7e5f1bbc3dc93b5ff6072a3bc81757a3ed075d7" translate="yes" xml:space="preserve">
          <source>Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional &lt;code&gt;AD&lt;/code&gt; or &lt;code&gt;BC&lt;/code&gt;. (Alternatively, &lt;code&gt;AD&lt;/code&gt;/&lt;code&gt;BC&lt;/code&gt; can appear before the time zone, but this is not the preferred ordering.) Thus:</source>
          <target state="translated">タイムスタンプタイプの有効な入力は、日付と時刻の連結、その後に続くオプションのタイムゾーン、それに続くオプションの &lt;code&gt;AD&lt;/code&gt; または &lt;code&gt;BC&lt;/code&gt; で構成されます。 （または、 &lt;code&gt;AD&lt;/code&gt; / &lt;code&gt;BC&lt;/code&gt; はタイムゾーンの前に表示できますが、これは優先順序ではありません。）したがって：</target>
        </trans-unit>
        <trans-unit id="c3fd0054c277594413eaed1c75df986510128d67" translate="yes" xml:space="preserve">
          <source>Valid input for these types consists of a time of day followed by an optional time zone. (See &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;Table 8.11&lt;/a&gt; and &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;Table 8.12&lt;/a&gt;.) If a time zone is specified in the input for &lt;code&gt;time without time zone&lt;/code&gt;, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as &lt;code&gt;America/New_York&lt;/code&gt;. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the &lt;code&gt;time with time zone&lt;/code&gt; value.</source>
          <target state="translated">これらのタイプの有効な入力は、時刻とそれに続くオプションのタイムゾーンで構成されます。 （&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TIME-TABLE&quot;&gt;表8.11&lt;/a&gt;および&lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONE-TABLE&quot;&gt;表8.12を&lt;/a&gt;参照してください。）時間帯 &lt;code&gt;time without time zone&lt;/code&gt; 入力に時間帯が指定されている場合、それは警告なしに無視されます。日付を指定することもできますが、 &lt;code&gt;America/New_York&lt;/code&gt; などの夏時間のルールを含むタイムゾーン名を使用する場合を除いて、日付は無視されます。この場合、標準または夏時間が適用されるかどうかを判断するために日付を指定する必要があります。適切なタイムゾーンオフセットは &lt;code&gt;time with time zone&lt;/code&gt; 値を持つ時間に記録されます。</target>
        </trans-unit>
        <trans-unit id="844edfde8ce5da216439f5cc862b141254fb9d4a" translate="yes" xml:space="preserve">
          <source>Valid memory units are &lt;code&gt;B&lt;/code&gt; (bytes), &lt;code&gt;kB&lt;/code&gt; (kilobytes), &lt;code&gt;MB&lt;/code&gt; (megabytes), &lt;code&gt;GB&lt;/code&gt; (gigabytes), and &lt;code&gt;TB&lt;/code&gt; (terabytes). The multiplier for memory units is 1024, not 1000.</source>
          <target state="translated">有効なメモリ単位は、 &lt;code&gt;B&lt;/code&gt; （バイト）、 &lt;code&gt;kB&lt;/code&gt; （キロバイト）、 &lt;code&gt;MB&lt;/code&gt; （メガバイト）、 &lt;code&gt;GB&lt;/code&gt; （ギガバイト）、および &lt;code&gt;TB&lt;/code&gt; （テラバイト）です。メモリユニットの乗数は1000ではなく1024です。</target>
        </trans-unit>
        <trans-unit id="239bf25206857881980ea876d3982e5ae2994831" translate="yes" xml:space="preserve">
          <source>Valid starting points for standby queries are generated at each checkpoint on the master. If the standby is shut down while the master is in a shutdown state, it might not be possible to re-enter Hot Standby until the primary is started up, so that it generates further starting points in the WAL logs. This situation isn't a problem in the most common situations where it might happen. Generally, if the primary is shut down and not available anymore, that's likely due to a serious failure that requires the standby being converted to operate as the new primary anyway. And in situations where the primary is being intentionally taken down, coordinating to make sure the standby becomes the new primary smoothly is also standard procedure.</source>
          <target state="translated">スタンバイクエリの有効な開始点は、マスタの各チェックポイントで生成されます。マスターがシャットダウン状態にある間にスタンバイがシャットダウンされた場合、プライマリが起動するまでホットスタンバイを再入力することができない可能性があるため、WALログにさらに開始点が生成されます。このような状況が発生する可能性のある最も一般的な状況では問題ではありません。一般的に、プライマリがシャットダウンされて使用できなくなった場合、それは深刻な障害が発生したために、いずれにしても新しいプライマリとして動作するようにスタンバイを変換する必要があることが原因である可能性が高いです。また、意図的にプライマリを停止させている状況では、待機状態がスムーズに新しいプライマリになるように調整することも標準的な手順です。</target>
        </trans-unit>
        <trans-unit id="36d562c59f538b4cf6287a1bc49b7023b220600a" translate="yes" xml:space="preserve">
          <source>Valid time units are &lt;code&gt;us&lt;/code&gt; (microseconds), &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), &lt;code&gt;min&lt;/code&gt; (minutes), &lt;code&gt;h&lt;/code&gt; (hours), and &lt;code&gt;d&lt;/code&gt; (days).</source>
          <target state="translated">有効な時間単位は、 &lt;code&gt;us&lt;/code&gt; （マイクロ秒）、 &lt;code&gt;ms&lt;/code&gt; （ミリ秒）、 &lt;code&gt;s&lt;/code&gt; （秒）、 &lt;code&gt;min&lt;/code&gt; （分）、 &lt;code&gt;h&lt;/code&gt; （時間）、および &lt;code&gt;d&lt;/code&gt; （日）です。</target>
        </trans-unit>
        <trans-unit id="dfda311a4ab9af803299c88d82467b20a4636196" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;field&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 有効な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="10d7649316ac64615f5264b37dbb56375dda92e2" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">有効な変数名には、文字、数字、およびアンダースコアを含めることができます。詳細については、以下の&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数を&lt;/a&gt;参照してください。変数名では大文字と小文字が区別されます。</target>
        </trans-unit>
        <trans-unit id="4e71de8159ccd805dfaf84c4abe0cc37c7fd0bef" translate="yes" xml:space="preserve">
          <source>Valid variable names can contain letters, digits, and underscores. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below for details. Variable names are case-sensitive.</source>
          <target state="translated">有効な変数名には、文字、数字、およびアンダースコアを含めることができます。詳細については、以下の&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数&lt;/a&gt;のセクションを参照してください。変数名では大文字と小文字が区別されます。</target>
        </trans-unit>
        <trans-unit id="6495bdc388499bc5f8ab2cec7e4d413da357e199" translate="yes" xml:space="preserve">
          <source>Validate the catalog entries for the specified operator class, so far as the access method can reasonably do that. For example, this might include testing that all required support functions are provided. The &lt;code&gt;amvalidate&lt;/code&gt; function must return false if the opclass is invalid. Problems should be reported with &lt;code&gt;ereport&lt;/code&gt; messages.</source>
          <target state="translated">アクセスメソッドが合理的に行うことができる限り、指定された演算子クラスのカタログエントリを検証します。たとえば、必要なサポート機能がすべて提供されているかどうかのテストが含まれる場合があります。 &lt;code&gt;amvalidate&lt;/code&gt; OPCLASSが無効である場合、関数はfalseを返す必要があります。問題は &lt;code&gt;ereport&lt;/code&gt; メッセージで報告する必要があります。</target>
        </trans-unit>
        <trans-unit id="89711f6e0ac15ee4534c22e657dbb299816df29f" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag)</source>
          <target state="translated">無効な数値を検証します(無効フラグをクリアします)。</target>
        </trans-unit>
        <trans-unit id="589311b6a2805b6a0281872c806ce0f19f6dd7a2" translate="yes" xml:space="preserve">
          <source>Validates an invalid number (clears the invalid flag).</source>
          <target state="translated">無効な数値を検証します(無効フラグをクリアします)。</target>
        </trans-unit>
        <trans-unit id="a914a2300c495dde9a239ee72a952fef70648b1b" translate="yes" xml:space="preserve">
          <source>Value Example</source>
          <target state="translated">値の例</target>
        </trans-unit>
        <trans-unit id="892634b1322b72a29145754cdb909390816e79df" translate="yes" xml:space="preserve">
          <source>Value Expressions</source>
          <target state="translated">値の表現</target>
        </trans-unit>
        <trans-unit id="b69a17e345014c4860d42b3ea12bfd1d74a98205" translate="yes" xml:space="preserve">
          <source>Value Expressions: Aggregate Expressions</source>
          <target state="translated">値の式。集約式</target>
        </trans-unit>
        <trans-unit id="62258d667ea100846bebdafcf33e6ba0d80bc0cf" translate="yes" xml:space="preserve">
          <source>Value Expressions: Array Constructors</source>
          <target state="translated">値の式。配列コンストラクタ</target>
        </trans-unit>
        <trans-unit id="538d0773b42800a1dced9ebd66981d039270223a" translate="yes" xml:space="preserve">
          <source>Value Expressions: Collation Expressions</source>
          <target state="translated">値の式。照合式</target>
        </trans-unit>
        <trans-unit id="09b3d5a6d9bce4eae0f96433329fd2780b515b1d" translate="yes" xml:space="preserve">
          <source>Value Expressions: Column References</source>
          <target state="translated">値の式。カラム参照</target>
        </trans-unit>
        <trans-unit id="0f5899e3893a9e71da04384ff81d2b0668b66cce" translate="yes" xml:space="preserve">
          <source>Value Expressions: Expression Evaluation Rules</source>
          <target state="translated">値の式。式の評価規則</target>
        </trans-unit>
        <trans-unit id="7a33243a5a764268dbc19c7b5d5ffb815f2b2494" translate="yes" xml:space="preserve">
          <source>Value Expressions: Field Selection</source>
          <target state="translated">値の式。フィールドの選択</target>
        </trans-unit>
        <trans-unit id="fc2734409ea30f439f8007a816c89fd5d4964498" translate="yes" xml:space="preserve">
          <source>Value Expressions: Function Calls</source>
          <target state="translated">値の式。関数呼び出し</target>
        </trans-unit>
        <trans-unit id="06ab5a8d541c803b5a6f5f5baa72444250b7d0c9" translate="yes" xml:space="preserve">
          <source>Value Expressions: Operator Invocations</source>
          <target state="translated">値の式。演算子の呼び出し</target>
        </trans-unit>
        <trans-unit id="e5f7f7098e87803a977afb22b3e716623af90f8e" translate="yes" xml:space="preserve">
          <source>Value Expressions: Positional Parameters</source>
          <target state="translated">値の式。位置パラメータ</target>
        </trans-unit>
        <trans-unit id="c58f459ac2b52cf9d74d05fef53f0cf74dcac929" translate="yes" xml:space="preserve">
          <source>Value Expressions: Row Constructors</source>
          <target state="translated">値の式。行のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="2c538998fa55638c7ded3a8a283b8e9feb0bd885" translate="yes" xml:space="preserve">
          <source>Value Expressions: Scalar Subqueries</source>
          <target state="translated">値の式。スカラー副問い合わせ</target>
        </trans-unit>
        <trans-unit id="1da69c14dd40700afb2c0a8abd86f7b740450e6f" translate="yes" xml:space="preserve">
          <source>Value Expressions: Subscripts</source>
          <target state="translated">値の式。添え字</target>
        </trans-unit>
        <trans-unit id="cccb4f69d3a8cb038ef6a413bb2c663923cd9fc0" translate="yes" xml:space="preserve">
          <source>Value Expressions: Type Casts</source>
          <target state="translated">値の式.タイプキャスト</target>
        </trans-unit>
        <trans-unit id="3715da19fdcfeeba7fe50bb93e020a8b25f6a530" translate="yes" xml:space="preserve">
          <source>Value Expressions: Window Function Calls</source>
          <target state="translated">値の式。ウィンドウ関数呼び出し</target>
        </trans-unit>
        <trans-unit id="bf4f8a0decbb4b4fd4371821f1c74ba9a1594ce9" translate="yes" xml:space="preserve">
          <source>Value Storage</source>
          <target state="translated">価値の貯蔵</target>
        </trans-unit>
        <trans-unit id="2977eb7ab7cb1230619c6002ed4cbbc6cc756fa6" translate="yes" xml:space="preserve">
          <source>Value expressions are used in a variety of contexts, such as in the target list of the &lt;code&gt;SELECT&lt;/code&gt; command, as new column values in &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;, or in search conditions in a number of commands. The result of a value expression is sometimes called a &lt;em&gt;scalar&lt;/em&gt;, to distinguish it from the result of a table expression (which is a table). Value expressions are therefore also called &lt;em&gt;scalar expressions&lt;/em&gt; (or even simply &lt;em&gt;expressions&lt;/em&gt;). The expression syntax allows the calculation of values from primitive parts using arithmetic, logical, set, and other operations.</source>
          <target state="translated">値式は、 &lt;code&gt;SELECT&lt;/code&gt; コマンドのターゲットリストなどのさまざまなコンテキストで、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; の新しい列値として、またはいくつかのコマンドの検索条件で使用されます。値式の結果は、テーブル式（テーブル）の結果と区別するために、&lt;em&gt;スカラー&lt;/em&gt;と呼ばれることがあります。したがって、&lt;em&gt;値式はスカラー式&lt;/em&gt;（または単に&lt;em&gt;式&lt;/em&gt;）とも呼ばれます。式の構文では、算術、論理、セット、およびその他の演算を使用して、プリミティブパーツから値を計算できます。</target>
        </trans-unit>
        <trans-unit id="114f96aeed1ddb1f81a693ccadc122b00691f706" translate="yes" xml:space="preserve">
          <source>Value that &lt;code&gt;RESET&lt;/code&gt; would reset the parameter to in the current session</source>
          <target state="translated">値 &lt;code&gt;RESET&lt;/code&gt; は、現在のセッションでのパラメータをリセットします</target>
        </trans-unit>
        <trans-unit id="28c18b9457473dab8964985ffc208f4a1973292c" translate="yes" xml:space="preserve">
          <source>Value to be assigned to the parameter</source>
          <target state="translated">パラメータに割り当てる値</target>
        </trans-unit>
        <trans-unit id="f84541e98210f793e8890e82c64afbe27a9c9a73" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;false&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;false&lt;/code&gt; リテラルとの比較を実行するために使用される値</target>
        </trans-unit>
        <trans-unit id="f129faa853bacb07b12134ac4fd986301a263b11" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;null&lt;/code&gt; value</source>
          <target state="translated">JSON &lt;code&gt;null&lt;/code&gt; 値との比較を実行するために使用される値</target>
        </trans-unit>
        <trans-unit id="8a792873148b2fe92c538941fe93212a85f960e9" translate="yes" xml:space="preserve">
          <source>Value used to perform comparison with JSON &lt;code&gt;true&lt;/code&gt; literal</source>
          <target state="translated">JSON &lt;code&gt;true&lt;/code&gt; リテラルとの比較を実行するために使用される値</target>
        </trans-unit>
        <trans-unit id="e8086792911df062e24caa3131a5135743c9b16c" translate="yes" xml:space="preserve">
          <source>Value/Predicate</source>
          <target state="translated">Value/Predicate</target>
        </trans-unit>
        <trans-unit id="1f1cb2e6759dab2334119644e8cf129ac32ce11d" translate="yes" xml:space="preserve">
          <source>Values are stored internally as 64-bit floating point numbers. This means that numbers with more than about 16 significant digits will be truncated.</source>
          <target state="translated">値は内部的に64ビット浮動小数点数として格納されます。これは、約 16 桁以上の有効数字は切り捨てられることを意味します。</target>
        </trans-unit>
        <trans-unit id="6d7efb522647e3ca74917dae6abd528277b3ab9e" translate="yes" xml:space="preserve">
          <source>Values needed to run one PostgreSQL instance</source>
          <target state="translated">1つのPostgreSQLインスタンスを実行するために必要な値</target>
        </trans-unit>
        <trans-unit id="8d380e11f26f75eaba033d74818adbe55ddca1de" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; data types can be cast to &lt;code&gt;money&lt;/code&gt;. Conversion from the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; data types can be done by casting to &lt;code&gt;numeric&lt;/code&gt; first, for example:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; データ型の値は &lt;code&gt;money&lt;/code&gt; にキャストできます。 &lt;code&gt;real&lt;/code&gt; および &lt;code&gt;double precision&lt;/code&gt; データ型からの変換は、最初に &lt;code&gt;numeric&lt;/code&gt; キャストすることで実行できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="6a94b34531e2a116d1ab90afc1f71919f7dc0067" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; can be obtained only from the &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; の値は、 &lt;code&gt;pg_statistic_ext_data.stxdmcv&lt;/code&gt; 列からのみ取得できます。</target>
        </trans-unit>
        <trans-unit id="850035024c129e8a798d30d9fc0a41ee9af84afc" translate="yes" xml:space="preserve">
          <source>Values of the &lt;code&gt;pg_mcv_list&lt;/code&gt; type can be obtained only from the &lt;code&gt;pg_statistic_ext_data&lt;/code&gt;.&lt;code&gt;stxdmcv&lt;/code&gt; column.</source>
          <target state="translated">&lt;code&gt;pg_mcv_list&lt;/code&gt; タイプの値は、 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; からのみ取得できます。 &lt;code&gt;stxdmcv&lt;/code&gt; 列。</target>
        </trans-unit>
        <trans-unit id="3b87bdbb02446940728e896c08b8825bde2b21b0" translate="yes" xml:space="preserve">
          <source>Values of this domain are allowed to be null. This is the default.</source>
          <target state="translated">このドメインの値はヌルにすることができます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="d29119abb7de6b63218065ed67e351db8dc51728" translate="yes" xml:space="preserve">
          <source>Values of this domain are prevented from being null (but see notes below).</source>
          <target state="translated">このドメインの値はNULLになることはありません(ただし、以下の注意事項を参照してください)。</target>
        </trans-unit>
        <trans-unit id="0d30cecbfdbc76e7857e49ac92bd25f13ef34d9b" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;character&lt;/code&gt; are physically padded with spaces to the specified width &lt;code&gt;n&lt;/code&gt;, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type &lt;code&gt;character&lt;/code&gt;. In collations where whitespace is significant, this behavior can produce unexpected results; for example &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; returns true, even though &lt;code&gt;C&lt;/code&gt; locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a &lt;code&gt;character&lt;/code&gt; value to one of the other string types. Note that trailing spaces &lt;em&gt;are&lt;/em&gt; semantically significant in &lt;code&gt;character varying&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; values, and when using pattern matching, that is &lt;code&gt;LIKE&lt;/code&gt; and regular expressions.</source>
          <target state="translated">&lt;code&gt;character&lt;/code&gt; 型の値は、指定された幅 &lt;code&gt;n&lt;/code&gt; までスペースで物理的に埋め込まれ、そのように格納および表示されます。ただし、 &lt;code&gt;character&lt;/code&gt; 型の2つの値を比較する場合、末尾のスペースは意味的に重要ではないと見なされ、無視されます。空白が重要な照合では、この動作により予期しない結果が生じる可能性があります。たとえば、 &lt;code&gt;SELECT 'a '::CHAR(2) collate &quot;C&quot; &amp;lt; E'a\n'::CHAR(2)&lt;/code&gt; はtrueを返しますが、 &lt;code&gt;C&lt;/code&gt; ロケールではスペースが改行よりも大きいと見なされます。 &lt;code&gt;character&lt;/code&gt; 値を他の文字列タイプの1つに変換すると、末尾のスペースが削除されます。末尾のスペース&lt;em&gt;は&lt;/em&gt;意味的に重要であることに注意してください &lt;code&gt;character varying&lt;/code&gt; と &lt;code&gt;text&lt;/code&gt; 値、およびパターンマッチングを使用する場合、 &lt;code&gt;LIKE&lt;/code&gt; と正規表現です。</target>
        </trans-unit>
        <trans-unit id="0d0e8ddc497a1b9c951f5949c5d9e1b70b9a22cd" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;path&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">タイプ &lt;code&gt;path&lt;/code&gt; 値は、次の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="d80b51f9c7fc6e7a8b7e3fe299274555e9a2ae02" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;polygon&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">タイプ &lt;code&gt;polygon&lt;/code&gt; の値は、以下の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="e5a16467bfe399e24f49eb7fdb667ccec5d8723e" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER DATABASE&lt;/code&gt; and &lt;code&gt;ALTER ROLE&lt;/code&gt; are applied only when starting a fresh database session. They override values obtained from the configuration files or server command line, and constitute defaults for the rest of the session. Note that some settings cannot be changed after server start, and so cannot be set with these commands (or the ones listed below).</source>
          <target state="translated">&lt;code&gt;ALTER DATABASE&lt;/code&gt; および &lt;code&gt;ALTER ROLE&lt;/code&gt; で設定された値は、新しいデータベースセッションを開始するときにのみ適用されます。これらは、構成ファイルまたはサーバーのコマンドラインから取得した値を上書きし、残りのセッションのデフォルトを構成します。一部の設定はサーバーの起動後に変更できないため、これらのコマンド（または以下のコマンド）では設定できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="818a4a9f523da08f985a8d7bb8387b916781ef1a" translate="yes" xml:space="preserve">
          <source>Values set with &lt;code&gt;ALTER SYSTEM&lt;/code&gt; will be effective after the next server configuration reload, or after the next server restart in the case of parameters that can only be changed at server start. A server configuration reload can be commanded by calling the SQL function &lt;code&gt;pg_reload_conf()&lt;/code&gt;, running &lt;code&gt;pg_ctl reload&lt;/code&gt;, or sending a SIGHUP signal to the main server process.</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; で設定された値は、次のサーバー構成の再ロード後、またはサーバーの起動時にのみ変更できるパラメーターの場合は次のサーバーの再起動後に有効になります。サーバー構成の再読み込みは、SQL関数 &lt;code&gt;pg_reload_conf()&lt;/code&gt; を呼び出すか、 &lt;code&gt;pg_ctl reload&lt;/code&gt; を実行するか、メインサーバープロセスにSIGHUPシグナルを送信することで実行できます。</target>
        </trans-unit>
        <trans-unit id="8e2a94acd55e77d304a8881179a17d08010c723b" translate="yes" xml:space="preserve">
          <source>Values to be inserted into a table are converted to the destination column's data type according to the following steps.</source>
          <target state="translated">テーブルに挿入される値は、以下の手順に従って、挿入先のカラムのデータ型に変換されます。</target>
        </trans-unit>
        <trans-unit id="543a387448ddbbf661178992c3adaa7b069168fb" translate="yes" xml:space="preserve">
          <source>Values: 0 - Without salt. Dangerous! 1 - With salt but with fixed iteration count. 3 - Variable iteration count. Default: 3 Applies to: pgp_sym_encrypt</source>
          <target state="translated">値。0-塩抜き。危ない! 1-塩を使用しますが、反復回数が固定されています。3-反復回数が可変です。デフォルト:3 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e85fa17c91ce0d6924e2ed0119f352ea3f8fb549" translate="yes" xml:space="preserve">
          <source>Values: 0 - no compression 1 - ZIP compression 2 - ZLIB compression (= ZIP plus meta-data and block CRCs) Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値を指定します。0-圧縮なし 1-ZIP圧縮 2-ZLIB圧縮(=ZIPにメタデータとブロックCRCを加えたもの)デフォルト:0 適用対象:pgp_sym_encrypt、pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="52218ba89357173a5dfb8618986a1e8fdfb757a3" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt</source>
          <target state="translated">値を指定します。0,1 デフォルト:0 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="922303e052dbc79ebb5e801b79cffb9186efe35c" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値を指定します。0,1 デフォルト:0 適用対象:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="bbe411494b7a8541ba3eda983d9fa94b6f7dde40" translate="yes" xml:space="preserve">
          <source>Values: 0, 1 Default: 0 Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</source>
          <target state="translated">値を指定します。0,1 デフォルト:0 適用対象:pgp_sym_encrypt,pgp_pub_encrypt,pgp_sym_decrypt,pgp_pub_decrypt</target>
        </trans-unit>
        <trans-unit id="87f52252bc49eca143f466418a46bf231d397765" translate="yes" xml:space="preserve">
          <source>Values: 0, 1-9 Default: 6 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値を指定します。0,1-9 デフォルト:6 適用対象:pgp_sym_encrypt,pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="631bb9d3f376659e6d97cddb0d8676370c2c08b3" translate="yes" xml:space="preserve">
          <source>Values: bf, aes, aes128, aes192, aes256 Default: use cipher-algo Applies to: pgp_sym_encrypt</source>
          <target state="translated">値:bf,aes,aes128,aes192,aes256 デフォルト:use cipher-algo 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="e9d1d35bfb5be3f756eb7a018b33d9e394f847ba" translate="yes" xml:space="preserve">
          <source>Values: bf, aes128, aes192, aes256 (OpenSSL-only: &lt;code&gt;3des&lt;/code&gt;, &lt;code&gt;cast5&lt;/code&gt;) Default: aes128 Applies to: pgp_sym_encrypt, pgp_pub_encrypt</source>
          <target state="translated">値：bf、aes128、aes192、aes256（OpenSSLのみ： &lt;code&gt;3des&lt;/code&gt; 、 &lt;code&gt;cast5&lt;/code&gt; ）デフォルト：aes128適用対象：pgp_sym_encrypt、pgp_pub_encrypt</target>
        </trans-unit>
        <trans-unit id="777af837f1de8927748898b65d1060bc773bad7b" translate="yes" xml:space="preserve">
          <source>Values: md5, sha1 Default: sha1 Applies to: pgp_sym_encrypt</source>
          <target state="translated">値:md5,sha1 デフォルト:sha1 適用対象:pgp_sym_encrypt</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a0b72534c52ce05719721c1bfff6524b4aef3cf8" translate="yes" xml:space="preserve">
          <source>Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as &lt;code&gt;':foo'&lt;/code&gt; doesn't work to produce a quoted literal from a variable's value (and it would be unsafe if it did work, since it wouldn't correctly handle quotes embedded in the value).</source>
          <target state="translated">変数の補間は、引用符で囲まれたSQLリテラルと識別子内では実行されません。したがって、 &lt;code&gt;':foo'&lt;/code&gt; などの構造は、変数の値から引用されたリテラルを生成するように機能しません（そして、値に埋め込まれた引用符を正しく処理しないため、機能した場合は安全ではありません）。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="f20578601408732c8ea02e8d928be3d22ba16637" translate="yes" xml:space="preserve">
          <source>Variables that control psql's behavior generally cannot be unset or set to invalid values. An &lt;code&gt;\unset&lt;/code&gt; command is allowed but is interpreted as setting the variable to its default value. A &lt;code&gt;\set&lt;/code&gt; command without a second argument is interpreted as setting the variable to &lt;code&gt;on&lt;/code&gt;, for control variables that accept that value, and is rejected for others. Also, control variables that accept the values &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; will also accept other common spellings of Boolean values, such as &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">psqlの動作を制御する変数は、通常、設定を解除したり、無効な値に設定したりすることはできません。 &lt;code&gt;\unset&lt;/code&gt; コマンドが許可されますが、デフォルト値に変数を設定すると解釈されます。 &lt;code&gt;\set&lt;/code&gt; 第二引数なしのコマンドは、変数を設定すると解釈される &lt;code&gt;on&lt;/code&gt; 、その値を受け入れる制御変数のために、そして他人のために拒否されます。また、 &lt;code&gt;on&lt;/code&gt; と &lt;code&gt;off&lt;/code&gt; の値を受け入れる制御変数は、 &lt;code&gt;true&lt;/code&gt; や &lt;code&gt;false&lt;/code&gt; など、ブール値の他の一般的なスペルも受け入れます。</target>
        </trans-unit>
        <trans-unit id="71d1d14c3d8bef73e900f87a2c49118ec1795b0b" translate="yes" xml:space="preserve">
          <source>Various other settings related to &amp;ldquo;semaphore undo&amp;rdquo;, such as &lt;code&gt;SEMMNU&lt;/code&gt; and &lt;code&gt;SEMUME&lt;/code&gt;, do not affect PostgreSQL.</source>
          <target state="translated">&lt;code&gt;SEMMNU&lt;/code&gt; や &lt;code&gt;SEMUME&lt;/code&gt; など、「セマフォの取り消し」に関連するその他のさまざまな設定は、PostgreSQLには影響しません。</target>
        </trans-unit>
        <trans-unit id="bd6240cba4fe3aa73d43764309d30fb6d3d037a4" translate="yes" xml:space="preserve">
          <source>Various parameters have been mentioned above in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt; and &lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;Section 26.5.3&lt;/a&gt;.</source>
          <target state="translated">さまざまなパラメータについては、&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;セクション26.5.2&lt;/a&gt;および&lt;a href=&quot;hot-standby#HOT-STANDBY-ADMIN&quot;&gt;セクション26.5.3で説明してい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d5b3325956fac55ce90bb38fba311678783c4a5a" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">検証は、インデックススキャン自体で使用されるものと同じ手順を使用して実行されます。これは、ユーザー定義の演算子クラスコードである場合があります。たとえば、Bツリーインデックスの検証は、1つ以上のBツリーサポート関数1ルーチンで行われた比較に依存しています。参照&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;セクション37.16.3を&lt;/a&gt;演算子クラスのサポート機能の詳細については。</target>
        </trans-unit>
        <trans-unit id="61976158db30bfdbe77805af6f5914f1244b7a45" translate="yes" xml:space="preserve">
          <source>Verification is performed using the same procedures as those used by index scans themselves, which may be user-defined operator class code. For example, B-Tree index verification relies on comparisons made with one or more B-Tree support function 1 routines. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details of operator class support functions.</source>
          <target state="translated">検証は、インデックススキャン自体で使用される手順と同じ手順を使用して実行されます。これは、ユーザー定義の演算子クラスコードである場合があります。たとえば、B-Treeインデックスの検証は、1つ以上のB-Treeサポート関数1ルーチンで行われた比較に依存しています。参照&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;セクション37.16.3を&lt;/a&gt;演算子クラスのサポート機能の詳細については。</target>
        </trans-unit>
        <trans-unit id="875530bb85a9bc9a572c1b81ee549fe16ccb6d4b" translate="yes" xml:space="preserve">
          <source>Version and Platform Compatibility</source>
          <target state="translated">バージョンとプラットフォームの互換性</target>
        </trans-unit>
        <trans-unit id="1d9929f1f28bbd8834745a088bfee2450b12d5d8" translate="yes" xml:space="preserve">
          <source>Version name</source>
          <target state="translated">バージョン名</target>
        </trans-unit>
        <trans-unit id="2597e3332e662024a1086db859f74acc32e53a21" translate="yes" xml:space="preserve">
          <source>Version name for the extension</source>
          <target state="translated">拡張機能のバージョン名</target>
        </trans-unit>
        <trans-unit id="29156f5ef29fca0492cf46682a435025e1953ccd" translate="yes" xml:space="preserve">
          <source>Version number</source>
          <target state="translated">バージョン番号</target>
        </trans-unit>
        <trans-unit id="637ea0ea7f40808c77700c1c4f68ba0087e0490c" translate="yes" xml:space="preserve">
          <source>Version of SSL in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">使用しているSSLのバージョン、またはこの接続でSSLが使用されていない場合はNULL</target>
        </trans-unit>
        <trans-unit id="20a77b4ce23e6a598792ebba9c5fa53b934c43a3" translate="yes" xml:space="preserve">
          <source>Version of the server (optional)</source>
          <target state="translated">サーバーのバージョン(オプション</target>
        </trans-unit>
        <trans-unit id="2002aefc5b11f637b7466ee1a13c20a9e6171391" translate="yes" xml:space="preserve">
          <source>Vertical tab (ASCII 11)</source>
          <target state="translated">縦タブ(ASCII 11</target>
        </trans-unit>
        <trans-unit id="9fe85f9993f6a26e677373400348d89af1072a3c" translate="yes" xml:space="preserve">
          <source>Very long-lived write transactions</source>
          <target state="translated">非常に長持ちする書き込みトランザクション</target>
        </trans-unit>
        <trans-unit id="30f98f07baa783307d6eeb3e956be798331b0ca1" translate="yes" xml:space="preserve">
          <source>Victor Wagner &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Cryptocom LTD</source>
          <target state="translated">ビクターワグナー &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:vitus@cryptocom.ru&quot;&gt;vitus@cryptocom.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、Cryptocom LTD</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="bf0400b0f3aafc0bb49249e45dc8694f8cdb7fdb" translate="yes" xml:space="preserve">
          <source>View Name</source>
          <target state="translated">名前を見る</target>
        </trans-unit>
        <trans-unit id="33ef89bbb476e8982fc98b280a43e4c9b99ae10c" translate="yes" xml:space="preserve">
          <source>View all the locks currently outstanding, all the locks on relations in a particular database, all the locks on a particular relation, or all the locks held by a particular PostgreSQL session.</source>
          <target state="translated">現在未解決のすべてのロック、特定のデータベース内のリレーションに対するすべてのロック、特定のリレーションに対するすべてのロック、または特定のPostgreSQLセッションが保持するすべてのロックを表示します。</target>
        </trans-unit>
        <trans-unit id="cbe38ed5293f170b37453ef21637367ceda0f0b8" translate="yes" xml:space="preserve">
          <source>View definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">ビュー定義（再構築された &lt;code&gt;SELECT&lt;/code&gt; クエリ）</target>
        </trans-unit>
        <trans-unit id="94f66a08ed3a699a66860df21a573d573a238197" translate="yes" xml:space="preserve">
          <source>Viewing Locks</source>
          <target state="translated">ビューイングロック</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c43c0cfc302cb10077693176e5e074e56b5aa3e7" translate="yes" xml:space="preserve">
          <source>Views can be used in almost any place a real table can be used. Building views upon other views is not uncommon.</source>
          <target state="translated">ビューは、ほとんどの場所で実際のテーブルを使用することができます。他のビューの上にビューを構築することは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="8e39d0decda3838416b25ba5106b0efbe06c4023" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction targeted by the lock, or null if the target is not a virtual transaction ID</source>
          <target state="translated">ロックの対象となるトランザクションの仮想 ID、または対象が仮想トランザクション ID でない場合は NULL。</target>
        </trans-unit>
        <trans-unit id="811a0b30888086bd25c748477319220487f25d50" translate="yes" xml:space="preserve">
          <source>Virtual ID of the transaction that is holding or awaiting this lock</source>
          <target state="translated">このロックを保持または待機しているトランザクションの仮想 ID</target>
        </trans-unit>
        <trans-unit id="4e4ba211a7e69b2432d26b396c51c526655c765b" translate="yes" xml:space="preserve">
          <source>Virtual transaction ID (backendID/localXID)</source>
          <target state="translated">仮想トランザクションID (backendID/localXID)</target>
        </trans-unit>
        <trans-unit id="588b3f896da2cfeabe798008bfd5617b36ad005b" translate="yes" xml:space="preserve">
          <source>Visibility map (fork)</source>
          <target state="translated">可視性マップ(フォーク</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="588c142955d93338aefe3c6dd59baf541f7f60c7" translate="yes" xml:space="preserve">
          <source>WAL</source>
          <target state="translated">WAL</target>
        </trans-unit>
        <trans-unit id="1d1c95a48c1cec72e7cde457f1faf1b2311bbdfd" translate="yes" xml:space="preserve">
          <source>WAL Configuration</source>
          <target state="translated">WALの設定</target>
        </trans-unit>
        <trans-unit id="dc7b27e2b628547b61cdbe01ad5b4d44572d2c25" translate="yes" xml:space="preserve">
          <source>WAL Internals</source>
          <target state="translated">WALインターナル</target>
        </trans-unit>
        <trans-unit id="cd824454d5f714596ff079dcd401902ac18dd100" translate="yes" xml:space="preserve">
          <source>WAL also makes it possible to support on-line backup and point-in-time recovery, as described in &lt;a href=&quot;continuous-archiving&quot;&gt;Section 25.3&lt;/a&gt;. By archiving the WAL data we can support reverting to any time instant covered by the available WAL data: we simply install a prior physical backup of the database, and replay the WAL log just as far as the desired time. What's more, the physical backup doesn't have to be an instantaneous snapshot of the database state &amp;mdash; if it is made over some period of time, then replaying the WAL log for that period will fix any internal inconsistencies.</source>
          <target state="translated">&lt;a href=&quot;continuous-archiving&quot;&gt;セクション25.3で&lt;/a&gt;説明されているように、WALはオンラインバックアップとポイントインタイムリカバリのサポートも可能にします。WALデータをアーカイブすることで、利用可能なWALデータでカバーされる任意の時点への復帰をサポートできます。データベースの事前の物理バックアップをインストールし、希望する時間までWALログを再生します。さらに、物理バックアップはデータベースの状態の瞬間的なスナップショットである必要はありません。一定の期間にわたって作成された場合、その期間のWALログを再生すると、内部の不整合が修正されます。</target>
        </trans-unit>
        <trans-unit id="56d9842b4dd6ff8912c8130e9ac002eac147ee40" translate="yes" xml:space="preserve">
          <source>WAL archiver (process)</source>
          <target state="translated">WALアーカイバ</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">WALファイル</target>
        </trans-unit>
        <trans-unit id="e4adb460b94535160dc5514c2f3243fad9448dc8" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g. &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">&lt;code&gt;pg_start_backup&lt;/code&gt; 、 &lt;code&gt;pg_switch_wal&lt;/code&gt; などのWALファイル制御コマンドはリカバリ中に機能しません。</target>
        </trans-unit>
        <trans-unit id="0dc06e1a1b8ef3a3c8739d9743e015585588e2e0" translate="yes" xml:space="preserve">
          <source>WAL file control commands will not work during recovery, e.g., &lt;code&gt;pg_start_backup&lt;/code&gt;, &lt;code&gt;pg_switch_wal&lt;/code&gt; etc.</source>
          <target state="translated">WALファイル制御コマンドは、リカバリ中は機能しません（例： &lt;code&gt;pg_start_backup&lt;/code&gt; 、 &lt;code&gt;pg_switch_wal&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="9b2801865ae804dc7013c1520108c058b7f6c30a" translate="yes" xml:space="preserve">
          <source>WAL is automatically enabled; no action is required from the administrator except ensuring that the disk-space requirements for the WAL logs are met, and that any necessary tuning is done (see &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt;).</source>
          <target state="translated">WALは自動的に有効になります。 WALログのディスク容量要件が満たされていること、および必要な調整が行われていることを確認する以外は、管理者によるアクションは必要ありません（&lt;a href=&quot;wal-configuration&quot;&gt;セクション29.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c356b4888573bfd6af6c126f717a43c96a7d21b4" translate="yes" xml:space="preserve">
          <source>WAL location at which to start reading. The default is to start reading the first valid log record found in the earliest file found.</source>
          <target state="translated">読み込みを開始する WAL の位置。デフォルトでは、最初に見つかったファイルで最初に見つかった有効なログレコードの読み込みを開始します。</target>
        </trans-unit>
        <trans-unit id="4873b80cfe4fe4ff618ed5cd62f9b47043675a98" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000000&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WALログは、データディレクトリの下のディレクトリ &lt;code&gt;pg_wal&lt;/code&gt; に一連のセグメントファイルとして保存されます。通常、サイズはそれぞれ16 MBです（ただし、サイズは &lt;code&gt;--wal-segsize&lt;/code&gt; initdbオプションを変更することで変更できます）。各セグメントは通常8 KBのページに分割されます（このサイズは &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 設定オプションで変更できます）。ログレコードヘッダーは &lt;code&gt;access/xlogrecord.h&lt;/code&gt; に記述されています。レコードの内容は、ログに記録されるイベントのタイプによって異なります。セグメントファイルには、 &lt;code&gt;000000010000000000000000&lt;/code&gt; から始まる名前として、増え続ける番号が付けられます。数値は折り返されませんが、使用可能な数の在庫を使い果たすには非常に長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="fce41bc59a921956886daa163cc3371dfbffcdb7" translate="yes" xml:space="preserve">
          <source>WAL logs are stored in the directory &lt;code&gt;pg_wal&lt;/code&gt; under the data directory, as a set of segment files, normally each 16 MB in size (but the size can be changed by altering the &lt;code&gt;--wal-segsize&lt;/code&gt; initdb option). Each segment is divided into pages, normally 8 kB each (this size can be changed via the &lt;code&gt;--with-wal-blocksize&lt;/code&gt; configure option). The log record headers are described in &lt;code&gt;access/xlogrecord.h&lt;/code&gt;; the record content is dependent on the type of event that is being logged. Segment files are given ever-increasing numbers as names, starting at &lt;code&gt;000000010000000000000001&lt;/code&gt;. The numbers do not wrap, but it will take a very, very long time to exhaust the available stock of numbers.</source>
          <target state="translated">WALログは、データディレクトリの下のディレクトリ &lt;code&gt;pg_wal&lt;/code&gt; に、セグメントファイルのセットとして、通常はそれぞれ16 MBのサイズで保存されます（ただし、サイズは &lt;code&gt;--wal-segsize&lt;/code&gt; initdbオプションを変更することで変更できます）。各セグメントはページに分割され、通常はそれぞれ8 kBです（このサイズは &lt;code&gt;--with-wal-blocksize&lt;/code&gt; 設定オプションで変更できます）。ログレコードヘッダーは、 &lt;code&gt;access/xlogrecord.h&lt;/code&gt; 説明されています。レコードの内容は、ログに記録されているイベントのタイプによって異なります。セグメントファイルには、 &lt;code&gt;000000010000000000000001&lt;/code&gt; から始まる名前として増え続ける番号が付けられます。数字は折り返されませんが、利用可能な数字の在庫を使い果たすには非常に長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="f9cabc60b441504c082bc1d5bf727636abc5fa64" translate="yes" xml:space="preserve">
          <source>WAL record</source>
          <target state="translated">WALレコード</target>
        </trans-unit>
        <trans-unit id="5fa55cdd1f960e02b270cbf81d5d051cfdadab50" translate="yes" xml:space="preserve">
          <source>WAL record construction can be canceled between any of the above steps by calling &lt;code&gt;GenericXLogAbort(state)&lt;/code&gt;. This will discard all changes to the page image copies.</source>
          <target state="translated">&lt;code&gt;GenericXLogAbort(state)&lt;/code&gt; を呼び出すことにより、上記のステップのいずれかの間でWALレコードの構築をキャンセルできます。これにより、ページのイメージコピーに対するすべての変更が破棄されます。</target>
        </trans-unit>
        <trans-unit id="ec0756aa72f12460643a103d61be69d319455e3e" translate="yes" xml:space="preserve">
          <source>WAL records are appended to the WAL logs as each new record is written. The insert position is described by a Log Sequence Number (LSN) that is a byte offset into the logs, increasing monotonically with each new record. LSN values are returned as the datatype &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt;. Values can be compared to calculate the volume of WAL data that separates them, so they are used to measure the progress of replication and recovery.</source>
          <target state="translated">WALレコードは、新しいレコードが書き込まれるたびにWALログに追加されます。挿入位置は、ログへのバイトオフセットであるログシーケンス番号（LSN）によって記述され、新しいレコードごとに単調に増加します。LSN値は、データ型&lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt;として返されます。値を比較して、それらを分離するWALデータの量を計算できます。そのため、これらの値は、レプリケーションとリカバリの進行状況を測定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d60f7a41c7594f9d60365bb80cc500438858f049" translate="yes" xml:space="preserve">
          <source>WAL segment</source>
          <target state="translated">WALセグメント</target>
        </trans-unit>
        <trans-unit id="85207d0ebcdb97d98e8f6e4d0d99438888bd2967" translate="yes" xml:space="preserve">
          <source>WAL segments that cannot be found in the archive will be sought in &lt;code&gt;pg_wal/&lt;/code&gt;; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in &lt;code&gt;pg_wal/&lt;/code&gt;.</source>
          <target state="translated">アーカイブで見つからないWALセグメントは &lt;code&gt;pg_wal/&lt;/code&gt; で検索されます。これにより、最近のアーカイブされていないセグメントを使用できます。ただし、アーカイブから利用可能なセグメントは、 &lt;code&gt;pg_wal/&lt;/code&gt; 内のファイルよりも優先して使用されます。</target>
        </trans-unit>
        <trans-unit id="a848a0c06549fd9cb5d11422d342ef502df6d940" translate="yes" xml:space="preserve">
          <source>WAL writer (process)</source>
          <target state="translated">WALライター(プロセス</target>
        </trans-unit>
        <trans-unit id="670936924f36e223ed7101a5577c1a95fc54d46f" translate="yes" xml:space="preserve">
          <source>WIDE Project</source>
          <target state="translated">WIDEプロジェクト</target>
        </trans-unit>
        <trans-unit id="0c238a027f49a7325c81b6fcad74df656598a8d1" translate="yes" xml:space="preserve">
          <source>WITH Queries</source>
          <target state="translated">WITH クエリ</target>
        </trans-unit>
        <trans-unit id="62c72223105cadaf945f1907d7cca51ac5e11a9a" translate="yes" xml:space="preserve">
          <source>WITH Queries: Data-Modifying Statements in WITH</source>
          <target state="translated">WITH クエリ。WITH でのデータ変更文</target>
        </trans-unit>
        <trans-unit id="81a33ebe9b068dc28117b34d20aebb31ffcc15d4" translate="yes" xml:space="preserve">
          <source>WITH Queries: SELECT in WITH</source>
          <target state="translated">WITH クエリを使用します。でSELECT</target>
        </trans-unit>
        <trans-unit id="b3c1b6ed1901fdc76c7650d703ade5c43c418ba9" translate="yes" xml:space="preserve">
          <source>Wait Event Name</source>
          <target state="translated">待機イベント名</target>
        </trans-unit>
        <trans-unit id="cfecc9a9e7dbc0650b752c6d733646645d5d3acd" translate="yes" xml:space="preserve">
          <source>Wait Event Type</source>
          <target state="translated">待機イベントタイプ</target>
        </trans-unit>
        <trans-unit id="b1541ea954698c8eaec6697e4064951737b7ac58" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt; through &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="translated">バックエンドが現在待機している場合はイベント名を待機し、それ以外の場合はNULL。&lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;表27.5&lt;/a&gt;から&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;表27.13を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7d1dd06a2c6e4048cfa872860c567be1efcd7c2b" translate="yes" xml:space="preserve">
          <source>Wait event name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">バックエンドが現在待機している場合は待機イベント名、それ以外の場合はNULL。詳細は&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;表27.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e0d176395064480d6a06595b0b0b2f5082eb7376" translate="yes" xml:space="preserve">
          <source>Wait event type name if backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">バックエンドが現在待機している場合は待機イベントタイプ名、それ以外の場合はNULL。詳細は&lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;表27.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d814f74425edb745c0f36dde73fdb494bc74e548" translate="yes" xml:space="preserve">
          <source>Wait for the operation to complete. This is supported for the modes &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;restart&lt;/code&gt;, &lt;code&gt;promote&lt;/code&gt;, and &lt;code&gt;register&lt;/code&gt;, and is the default for those modes.</source>
          <target state="translated">操作が完了するまで待ちます。これは、モード &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;stop&lt;/code&gt; 、 &lt;code&gt;restart&lt;/code&gt; 、 &lt;code&gt;promote&lt;/code&gt; 、および &lt;code&gt;register&lt;/code&gt; でサポートされており、これらのモードのデフォルトです。</target>
        </trans-unit>
        <trans-unit id="dd618adedec17e6469d06a5651fc5072c2cb8b33" translate="yes" xml:space="preserve">
          <source>Waiting a new WAL segment created by copying an existing one to reach stable storage.</source>
          <target state="translated">既存のものをコピーして作成した新しいWALセグメントが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="d1f87abf987753c903a49d1bd2c679d42224c9ed" translate="yes" xml:space="preserve">
          <source>Waiting due to a call to &lt;code&gt;pg_sleep&lt;/code&gt; or a sibling function.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; または兄弟関数の呼び出しのために待機しています。</target>
        </trans-unit>
        <trans-unit id="7b263c588c8a9b03696257b8f7a21247383c1982" translate="yes" xml:space="preserve">
          <source>Waiting during base backup when throttling activity.</source>
          <target state="translated">アクティビティをスロットリングしているときにベースバックアップ中に待機しています。</target>
        </trans-unit>
        <trans-unit id="af48f8ee80431258cbd39e7f8a24022d589cd2d4" translate="yes" xml:space="preserve">
          <source>Waiting during recovery when WAL data is not available from any source (&lt;code&gt;pg_wal&lt;/code&gt;, archive or stream).</source>
          <target state="translated">WALデータがどのソース（ &lt;code&gt;pg_wal&lt;/code&gt; 、アーカイブ、またはストリーム）からも利用できない場合、リカバリ中に待機します。</target>
        </trans-unit>
        <trans-unit id="d62ddea7d6b1ce8c2e8479d95982f02c6ba59204" translate="yes" xml:space="preserve">
          <source>Waiting for I/O a subtransaction buffer.</source>
          <target state="translated">サブトランザクションバッファのI/O待ち。</target>
        </trans-unit>
        <trans-unit id="b41198be2ca46788de05f6339f5abc58ad97837a" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU buffer.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; メッセージSLRUバッファーでの入出力を待機しています。</target>
        </trans-unit>
        <trans-unit id="10b267052de8e5af8879f9629c8e82adc667c91f" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a clog (transaction status) buffer.</source>
          <target state="translated">クロッグ(トランザクションステータス)バッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="e58154eef4dbe4cc36348aa199353c80f25bfc90" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a commit timestamp SLRU buffer.</source>
          <target state="translated">コミットタイムスタンプ SLRU バッファで I/O を待っています。</target>
        </trans-unit>
        <trans-unit id="8bbc9325a896b8fd7a70abd45c23e5faa43a813b" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a data page.</source>
          <target state="translated">データページでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="b97519258b555ff83c2d8f7537b4d0c3849dc3b0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact member SLRU buffer.</source>
          <target state="translated">マルチアクトメンバー SLRU バッファの I/O を待っています。</target>
        </trans-unit>
        <trans-unit id="5520e2be332ddadef5e822360efad62eedfb3753" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset SLRU buffer.</source>
          <target state="translated">多重オフセット SLRU バッファで I/O を待っています。</target>
        </trans-unit>
        <trans-unit id="8a704e423e485baf39382a4b61985268bdbe9816" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact offset buffer.</source>
          <target state="translated">マルチクセクト・オフセット・バッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="567d45c24a3c7adfee8a01424ebb678b04e38b31" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a multixact_member buffer.</source>
          <target state="translated">multixact_memberバッファのI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="f5580fedd445b2fc16dfac5701d5e862d784f551" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a replication slot.</source>
          <target state="translated">レプリケーションスロットでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="e6bc836d70082711faa785a87bbd568bb40a26f2" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a serializable transaction conflict SLRU buffer.</source>
          <target state="translated">シリアライズ可能なトランザクションの競合 SLRU バッファで I/O を待っています。</target>
        </trans-unit>
        <trans-unit id="3cf608c43f24f0741708f464c3bfab6ed45555c1" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a sub-transaction SLRU buffer.</source>
          <target state="translated">サブトランザクションSLRUバッファでI/O待ちをしています。</target>
        </trans-unit>
        <trans-unit id="e164de805b3886359f5010f6a7deb581bdf00ae0" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on a transaction status SLRU buffer.</source>
          <target state="translated">トランザクションステータス SLRU バッファで I/O を待っています。</target>
        </trans-unit>
        <trans-unit id="8eda0ee8cd8803033853db58b70b41cefa970a11" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an async (notify) buffer.</source>
          <target state="translated">非同期(通知)バッファでI/O待ちをしています。</target>
        </trans-unit>
        <trans-unit id="abba94e34c19d07b07ce80f08b906e7d03736163" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on an oldserxid buffer.</source>
          <target state="translated">oldserxidバッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="89be09a6258d69b36b9e65eae64f0556be147bdd" translate="yes" xml:space="preserve">
          <source>Waiting for I/O on commit timestamp buffer.</source>
          <target state="translated">コミットタイムスタンプバッファでI/Oを待っています。</target>
        </trans-unit>
        <trans-unit id="785bfc0b8ad80cb03e1bb84a54b286b13aa0651d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage during a checkpoint or database shutdown.</source>
          <target state="translated">チェックポイントまたはデータベースのシャットダウン中に SLRU データが耐久性のあるストレージに到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="003d2dd01b2593677f27df1a51eb75521d66a25d" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach durable storage following a page write.</source>
          <target state="translated">ページ書き込み後、SLRU データが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="da4c5fd8e7b43af2a409040c541ebf56ba090a42" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage during a checkpoint or database shutdown.</source>
          <target state="translated">チェックポイントまたはデータベースのシャットダウン中に SLRU データが安定したストレージに到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="a795b2d3551897df90d4dc06b1de18f13711e4ef" translate="yes" xml:space="preserve">
          <source>Waiting for SLRU data to reach stable storage following a page write.</source>
          <target state="translated">ページ書き込み後、SLRU データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="3f43eca07331b8b4d48d83deb11f1187e3222c57" translate="yes" xml:space="preserve">
          <source>Waiting for SSL while attempting connection.</source>
          <target state="translated">接続を試みている間、SSLを待っています。</target>
        </trans-unit>
        <trans-unit id="cea499b505dfbcd4c53729e4e78e2f60a5e0dfa9" translate="yes" xml:space="preserve">
          <source>Waiting for TBM shared iterator lock.</source>
          <target state="translated">TBM共有イテレータのロックを待っています。</target>
        </trans-unit>
        <trans-unit id="28f5fe1f96a90cf6f89027f31d1f8fff440aadd4" translate="yes" xml:space="preserve">
          <source>Waiting for WAL buffers to be written to disk.</source>
          <target state="translated">WAL バッファがディスクに書き込まれるのを待っています。</target>
        </trans-unit>
        <trans-unit id="984062f9c9b976e8df42046bfd109717db60ade5" translate="yes" xml:space="preserve">
          <source>Waiting for WAL files required for a backup to be successfully archived.</source>
          <target state="translated">バックアップに必要なWALファイルが正常にアーカイブされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="e5f443781f65a70ffb9eadd8d00b62bec73ed570" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from a stream at recovery.</source>
          <target state="translated">回復時のストリームからのWAL待ち。</target>
        </trans-unit>
        <trans-unit id="ce0b3cbfc2a21133aecfeb0025076a64608b1920" translate="yes" xml:space="preserve">
          <source>Waiting for WAL from any kind of source (local, archive or stream) at recovery.</source>
          <target state="translated">リカバリー時に任意の種類のソース(ローカル、アーカイブ、ストリーム)からのWALを待っています。</target>
        </trans-unit>
        <trans-unit id="c3d04b47f170d0a017b5a8840ab7fd732b861077" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to be flushed in WAL sender process.</source>
          <target state="translated">WAL送信者プロセスでWALがフラッシュされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="f4a5e554d691351f284f09d8db7f55190422b270" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach durable storage during bootstrapping.</source>
          <target state="translated">ブートストラップ中にWALが耐久ストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="35934124d45c41b66cac20041da4f7acc6c09234" translate="yes" xml:space="preserve">
          <source>Waiting for WAL to reach stable storage during bootstrapping.</source>
          <target state="translated">ブートストラップ中にWALが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b82237d07a68b8fa940123851d375627fb31efe7" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach durable storage.</source>
          <target state="translated">耐久性のあるストレージに届くWALファイルを待っています。</target>
        </trans-unit>
        <trans-unit id="2347bde945d2a1ac488cc00b97f03eb25edf886c" translate="yes" xml:space="preserve">
          <source>Waiting for a WAL file to reach stable storage.</source>
          <target state="translated">WALファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="52ca09d978f55744184f7d9cdb893379dab55dfe" translate="yes" xml:space="preserve">
          <source>Waiting for a barrier event to be processed by all backends.</source>
          <target state="translated">すべてのバックエンドでバリアイベントが処理されるのを待っています。</target>
        </trans-unit>
        <trans-unit id="b64554949a794fe8845162525251d4f832f615ae" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to complete.</source>
          <target state="translated">チェックポイントの完了を待っています。</target>
        </trans-unit>
        <trans-unit id="fbe85ec49696086b315ad919340a19fe4137e208" translate="yes" xml:space="preserve">
          <source>Waiting for a checkpoint to start.</source>
          <target state="translated">チェックポイントの開始を待っています。</target>
        </trans-unit>
        <trans-unit id="318c8efea6418e0ce484fc89483b1eb1ff78690d" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to change state.</source>
          <target state="translated">論理レプリケーションリモートサーバーの状態変化を待っています。</target>
        </trans-unit>
        <trans-unit id="9be1a8f95aa3da64fa571808ebb5f548539f1390" translate="yes" xml:space="preserve">
          <source>Waiting for a logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">論理レプリケーションのリモートサーバーが初期テーブル同期のためのデータを送信するのを待っています。</target>
        </trans-unit>
        <trans-unit id="d59d3373d5959bbfb7f16fd5cf3905eaaca00840" translate="yes" xml:space="preserve">
          <source>Waiting for a new WAL segment created by copying an existing one to reach durable storage.</source>
          <target state="translated">既存のものをコピーして作成した新しいWALセグメントが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="bdee33be52627bad37addf1e4cb4de672175760f" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach durable storage.</source>
          <target state="translated">新しく作成されたタイムラインの履歴ファイルが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="a86020a20952ecd2adfecfb302ee0a5d59b93de9" translate="yes" xml:space="preserve">
          <source>Waiting for a newly created timeline history file to reach stable storage.</source>
          <target state="translated">新しく作成されたタイムラインの履歴ファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b0cdef84441eaddf22ea692b65eccf4c082d170e" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach durable storage.</source>
          <target state="translated">新たに初期化されたWALファイルが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="6fe40708f510b2425a56df962113c332035d1ebb" translate="yes" xml:space="preserve">
          <source>Waiting for a newly initialized WAL file to reach stable storage.</source>
          <target state="translated">新たに初期化されたWALファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="a99635b6aefa182932d6d8ac35e0fadee6f58362" translate="yes" xml:space="preserve">
          <source>Waiting for a read during a file copy operation.</source>
          <target state="translated">ファイルコピー操作中の読み込み待ち。</target>
        </trans-unit>
        <trans-unit id="1b1c7ee0bc940e8ff954a9dc21e088de25e160e7" translate="yes" xml:space="preserve">
          <source>Waiting for a read during recheck of the data directory lock file.</source>
          <target state="translated">データ・ディレクトリ・ロック・ファイルの再チェック中に読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="9ae33919f01ffd845bcfe367fc1ce42274883982" translate="yes" xml:space="preserve">
          <source>Waiting for a read during reorder buffer management.</source>
          <target state="translated">リオーダバッファ管理中に読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="21b0b22bdd6995f4c8facc815a7958bc78a4df11" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a WAL file.</source>
          <target state="translated">WALファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="7c0a57a09d41e3dd4b6c43069589a550983cdfbc" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a buffered file.</source>
          <target state="translated">バッファリングされたファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="9d7f43727962110ab0f659fc3569b92c09e1e4c3" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a relation data file.</source>
          <target state="translated">リレーションデータファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b5434d2dc36bc6e479cf33762dac4cdbbad013ab" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a replication slot control file.</source>
          <target state="translated">レプリケーションスロット制御ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="d17e29530adb24a2c7484307af3bcddda11a2aae" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during a walsender timeline command.</source>
          <target state="translated">walsender timeline コマンドの実行中にタイムライン履歴ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="0d8e0677108348e6cb25c6439df96979d79370b4" translate="yes" xml:space="preserve">
          <source>Waiting for a read from a timeline history file during walsender timeline command.</source>
          <target state="translated">walsender timeline コマンドの実行中にタイムライン履歴ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b83f25adf4d23330ec82b288f382bbfe80bca47f" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; ファイルからの読み取りを待機しています。</target>
        </trans-unit>
        <trans-unit id="bb87f9075b737550478460fe92ea81d5a8e44f1b" translate="yes" xml:space="preserve">
          <source>Waiting for a read from the control file.</source>
          <target state="translated">制御ファイルからの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b13a29b976f4d9243fad247169f0d2821ffe4aa3" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a logical mapping during reorder buffer management.</source>
          <target state="translated">リオーダバッファ管理中に論理マッピングの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="94303f5f840422428a360dcb8cf874ed8d7188d8" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a serialized historical catalog snapshot.</source>
          <target state="translated">シリアライズされたヒストリカル・カタログ・スナップショットの読み取りを待っています。</target>
        </trans-unit>
        <trans-unit id="2ab04c92d0fda0e18fe65ce97ed4f4a6278c8bda" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a timeline history file.</source>
          <target state="translated">タイムラインの履歴ファイルの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="c0e334fe7275467445ed31f445bb0d89fc42ea11" translate="yes" xml:space="preserve">
          <source>Waiting for a read of a two phase state file.</source>
          <target state="translated">二相状態のファイルの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="24f5541db52af4f2f83a5aff926cb570ad37ea9a" translate="yes" xml:space="preserve">
          <source>Waiting for a read of an SLRU page.</source>
          <target state="translated">SLRUのページの読み込み待ち。</target>
        </trans-unit>
        <trans-unit id="ab3bd50798c846431f5c99cd295ac155af5c3628" translate="yes" xml:space="preserve">
          <source>Waiting for a read of the relation map file.</source>
          <target state="translated">リレーションマップファイルの読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="653fed415a1560b6108907354641e1d02603af7f" translate="yes" xml:space="preserve">
          <source>Waiting for a read when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">既存のWALセグメントをコピーして新規にWALセグメントを作成する際に、読み込みを待っている。</target>
        </trans-unit>
        <trans-unit id="8b50fdc4779713a2250434752ac096729a9b9e3d" translate="yes" xml:space="preserve">
          <source>Waiting for a read while adding a line to the data directory lock file.</source>
          <target state="translated">データ・ディレクトリ・ロック・ファイルに行を追加している間、読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="764d5f916fab0f4117b0be0cbd2e731f54a839fb" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be extended.</source>
          <target state="translated">関係データファイルの拡張を待っています。</target>
        </trans-unit>
        <trans-unit id="2d4550cc931e0694f7888372505856f6d3c09005" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to be truncated.</source>
          <target state="translated">関係データファイルが切り捨てられるのを待っています。</target>
        </trans-unit>
        <trans-unit id="56656077995a3c3ccd9b20b71affc54ffa5f3b73" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach durable storage.</source>
          <target state="translated">関係データファイルが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="196784ad8df1886187ea3f9758445468708682d5" translate="yes" xml:space="preserve">
          <source>Waiting for a relation data file to reach stable storage.</source>
          <target state="translated">関係データファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="e193dd315e3b35e9bfde686ab2df07cc942ef67f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive so it can be dropped.</source>
          <target state="translated">レプリケーションオリジンが非アクティブになるのを待っているので、それを落とすことができます。</target>
        </trans-unit>
        <trans-unit id="2c6dd21f72774436bf4201a14e0bef224865f318" translate="yes" xml:space="preserve">
          <source>Waiting for a replication origin to become inactive to be dropped.</source>
          <target state="translated">レプリケーションオリジンが非アクティブになってドロップされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="a2c385c9c429e881d994641cd053fdd40d599ca4" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage while restoring it to memory.</source>
          <target state="translated">レプリケーションスロット制御ファイルをメモリに復元しながら、耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="933e401eade88c4d239f909f0d7a24552c57d2a6" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach durable storage.</source>
          <target state="translated">レプリケーションスロット制御ファイルが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="51efea4b8a37a030875e22581e67a71b2c0b921b" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage while restoring it to memory.</source>
          <target state="translated">レプリケーションスロット制御ファイルをメモリに復元しながら、安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="3360d7e3a23f4e402f25182926d976cf44db39f3" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot control file to reach stable storage.</source>
          <target state="translated">レプリケーションスロット制御ファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="494ade39222b8fb62d122bed2c1029dcb97e4b7f" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive so it can be dropped.</source>
          <target state="translated">レプリケーションスロットが非アクティブになるのを待っているので、それを落とすことができます。</target>
        </trans-unit>
        <trans-unit id="199501dcba57d5c5271ac74b95e191bf236cb733" translate="yes" xml:space="preserve">
          <source>Waiting for a replication slot to become inactive to be dropped.</source>
          <target state="translated">レプリケーションスロットが非アクティブになってドロップされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="6e324c985d50a900618f8748e92b810be7e79671" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach durable storage.</source>
          <target state="translated">シリアル化された歴史的なカタログスナップショットが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="863f50afd3c1563b85fb65b1a42b5b1ae705dfb7" translate="yes" xml:space="preserve">
          <source>Waiting for a serialized historical catalog snapshot to reach stable storage.</source>
          <target state="translated">シリアライズされたヒストリカルカタログスナップショットが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b66c979e7938ef913ce663fc865d33095c21de87" translate="yes" xml:space="preserve">
          <source>Waiting for a snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">&lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; トランザクションのスナップショットを待機しています。</target>
        </trans-unit>
        <trans-unit id="111cfd0a418a3a5087e98e0082a0895f0e94e2f0" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach durable storage.</source>
          <target state="translated">ストリーミングレプリケーションで受信したタイムラインの履歴ファイルが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="e483dd61b2e17583a1594dcda6e591f3ac3e513f" translate="yes" xml:space="preserve">
          <source>Waiting for a timeline history file received via streaming replication to reach stable storage.</source>
          <target state="translated">ストリーミングレプリケーションで受信したタイムラインの履歴ファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="2853dc0fde120da340c58317ae296218c97a1c94" translate="yes" xml:space="preserve">
          <source>Waiting for a transaction to finish.</source>
          <target state="translated">取引が終わるのを待っています。</target>
        </trans-unit>
        <trans-unit id="e24c900a389bc0f02e97f81a8ce41fbab7e291af" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach durable storage.</source>
          <target state="translated">二相状態のファイルが耐久ストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="157ed476e7697e7a1cadb6976248a98472434e0a" translate="yes" xml:space="preserve">
          <source>Waiting for a two phase state file to reach stable storage.</source>
          <target state="translated">二相状態のファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="85a6ffd0d68eb37b547774e0919378d07b939300" translate="yes" xml:space="preserve">
          <source>Waiting for a write during a file copy operation.</source>
          <target state="translated">ファイルコピー操作中の書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="32492adb76e65f3fe0a6e72f8951521baef55fec" translate="yes" xml:space="preserve">
          <source>Waiting for a write during reorder buffer management.</source>
          <target state="translated">リオーダバッファ管理中の書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="ba450cd205c3dd8e5640b537d57ff27410f1253d" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a WAL page during bootstrapping.</source>
          <target state="translated">ブートストラップ中にWALページの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="8705f070fa23d795eb616cd9e31b50566ca67cc3" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a newly created timeline history file.</source>
          <target state="translated">新規作成したタイムライン履歴ファイルの書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="8d1760404310ebeadc931ff2c4124968d47b107a" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a serialized historical catalog snapshot.</source>
          <target state="translated">シリアライズされたヒストリカル・カタログ・スナップショットの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="b37297f957be6d38118691421e743bea3d403b7c" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a timeline history file received via streaming replication.</source>
          <target state="translated">ストリーミングレプリケーションで受信したタイムラインの履歴ファイルの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="be49d8c0c1b4685519fdd85850348ecd44be9749" translate="yes" xml:space="preserve">
          <source>Waiting for a write of a two phase state file.</source>
          <target state="translated">二相状態のファイルの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="53aeb8cdb283bc1d47f777ad7b24ec161b846ee7" translate="yes" xml:space="preserve">
          <source>Waiting for a write of an SLRU page.</source>
          <target state="translated">SLRUのページの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="1465353979b7faf0b115892be0b212bb41254cd5" translate="yes" xml:space="preserve">
          <source>Waiting for a write of logical rewrite mappings.</source>
          <target state="translated">論理的な書き換えマッピングの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="262bd0eebb54ede821d500429e0af687cc713958" translate="yes" xml:space="preserve">
          <source>Waiting for a write of mapping data during a logical rewrite.</source>
          <target state="translated">論理書き換え中のマッピングデータの書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="3b9bd51d9cae106255dd99b45134793e8fe5ca42" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a WAL file.</source>
          <target state="translated">WALファイルへの書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="251086a074c439cbe743d7c3bb152d463c21bb7b" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a buffered file.</source>
          <target state="translated">バッファリングされたファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="8b47e588513cf133674bba56df9090d2883dd101" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a relation data file.</source>
          <target state="translated">リレーションデータファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="299b50c23e70d2d279fbb4a9694963e890bfee88" translate="yes" xml:space="preserve">
          <source>Waiting for a write to a replication slot control file.</source>
          <target state="translated">レプリケーションスロット制御ファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="c78572013cf870b1d5b2f14bfe069a7a53092ec4" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; ファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="f26411046b5f9c53b1644f439224f22b40020be7" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the control file.</source>
          <target state="translated">制御ファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="f75228f5ef22ab61abd11733484809e768dbf43c" translate="yes" xml:space="preserve">
          <source>Waiting for a write to the relation map file.</source>
          <target state="translated">リレーションマップファイルへの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="49fdc5304647deaf1df0e95e8d9b82ecf63a8d41" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the &lt;code&gt;pg_control&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; ファイルを更新するための書き込みを待機しています。</target>
        </trans-unit>
        <trans-unit id="d4dc5be0a61a88b12bee2628ecf09d1b773c4c35" translate="yes" xml:space="preserve">
          <source>Waiting for a write to update the control file.</source>
          <target state="translated">制御ファイルを更新するための書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="610d140534d98776f4ceaac82401a792839d1b45" translate="yes" xml:space="preserve">
          <source>Waiting for a write when creating a new WAL segment by copying an existing one.</source>
          <target state="translated">既存のWALセグメントをコピーして新規にWALセグメントを作成する際に書き込み待ちになる。</target>
        </trans-unit>
        <trans-unit id="e8e6f804ba2f5656426f9c3ccd5ba5ebd95a87d4" translate="yes" xml:space="preserve">
          <source>Waiting for a write while adding a line to the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルに行を追加している間、書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="0696197c3d3d4067137d8fe428f74da050d0c268" translate="yes" xml:space="preserve">
          <source>Waiting for a write while creating the data directory lock file.</source>
          <target state="translated">データディレクトリロックファイルの作成中に書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="2fa5fc8fd5be1292b1cb40d3c83b93e702c367e3" translate="yes" xml:space="preserve">
          <source>Waiting for a write while initializing a new WAL file.</source>
          <target state="translated">新規WALファイルの初期化中に書き込み待ち。</target>
        </trans-unit>
        <trans-unit id="734b565bcfa5ca2fc97c773bf856a02689576213" translate="yes" xml:space="preserve">
          <source>Waiting for action on logical replication worker to finish.</source>
          <target state="translated">論理レプリケーションワーカーのアクションの終了を待っています。</target>
        </trans-unit>
        <trans-unit id="d26e6e2627cb32e8a27e81f318db98a11e54cd12" translate="yes" xml:space="preserve">
          <source>Waiting for activity from a child process while executing a &lt;code&gt;Gather&lt;/code&gt; plan node.</source>
          <target state="translated">&lt;code&gt;Gather&lt;/code&gt; プランノードの実行中に子プロセスからのアクティビティを待機しています。</target>
        </trans-unit>
        <trans-unit id="a1613179ffe75070217dd36a5f12906b74afc2ab" translate="yes" xml:space="preserve">
          <source>Waiting for activity from child process when executing &lt;code&gt;Gather&lt;/code&gt; node.</source>
          <target state="translated">&lt;code&gt;Gather&lt;/code&gt; ノードの実行時に子プロセスからのアクティビティを待機しています。</target>
        </trans-unit>
        <trans-unit id="6126b8aaccca6a7a91b7220ca50f325ae2373721" translate="yes" xml:space="preserve">
          <source>Waiting for an asynchronous prefetch from a relation data file.</source>
          <target state="translated">リレーションデータファイルからの非同期プリフェッチを待っています。</target>
        </trans-unit>
        <trans-unit id="7ceade57b19a1c5eb1845d4c821b850186cc2839" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">選出されたパラレルハッシュ参加者がハッシュテーブルを割り当てるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7ae35732e2bfced9301c45c422a5bb06a774ed38" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate more batches.</source>
          <target state="translated">選出されたパラレルハッシュ参加者がより多くのバッチを割り当てるのを待っています。</target>
        </trans-unit>
        <trans-unit id="fb366154c77101be0d76ea7c08df266aa7b65be9" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">選出されたパラレルハッシュ参加者が初期ハッシュテーブルを割り当てるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7cf1c258cd35461c3f1727fa0a9eacebdd04769c" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">選出されたパラレルハッシュ参加者が将来のバッチ成長を決定するのを待っています。</target>
        </trans-unit>
        <trans-unit id="07635fd669dda3c946a486e6f1b23b449441353e" translate="yes" xml:space="preserve">
          <source>Waiting for an elected Parallel Hash participant to finish allocating more buckets.</source>
          <target state="translated">選出されたパラレルハッシュ参加者がより多くのバケットの割り当てを終了するのを待っています。</target>
        </trans-unit>
        <trans-unit id="5801375733f68124f62514d2e4570d9207fd757f" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to durable storage.</source>
          <target state="translated">耐久性のあるストレージへの関係データファイルの即時同期を待っています。</target>
        </trans-unit>
        <trans-unit id="4e246fb175c5f149773d0331209040875fd42182" translate="yes" xml:space="preserve">
          <source>Waiting for an immediate synchronization of a relation data file to stable storage.</source>
          <target state="translated">安定したストレージへの関係データファイルの即時同期を待っています。</target>
        </trans-unit>
        <trans-unit id="7259a212cd02dc7285b0b4c7fac8d9b3dccce991" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; ファイルの更新が永続ストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="95d64a2fc217b281e035d77c750609359d54019d" translate="yes" xml:space="preserve">
          <source>Waiting for an update to the control file to reach stable storage.</source>
          <target state="translated">コントロールファイルの更新が安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="77a6d736fc930334f93ec4961120d3fbb33658a7" translate="yes" xml:space="preserve">
          <source>Waiting for another process to be attached to a shared message queue.</source>
          <target state="translated">共有メッセージキューに別のプロセスがアタッチされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="fcf18468a43ecee10b4dea21dad9d1ae0888b697" translate="yes" xml:space="preserve">
          <source>Waiting for any activity when processing replies from WAL receiver in WAL sender process.</source>
          <target state="translated">WAL送信者プロセスでWAL受信者からの返信を処理する際に、何らかのアクティビティを待機している。</target>
        </trans-unit>
        <trans-unit id="27bad1ed6561f03baa1813e29bc1d6a9f97d039b" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to shut down.</source>
          <target state="translated">バックグラウンドワーカーがシャットダウンするのを待っています。</target>
        </trans-unit>
        <trans-unit id="17b78b2404a9c8efe7417660102cb11bcbc99fa4" translate="yes" xml:space="preserve">
          <source>Waiting for background worker to start up.</source>
          <target state="translated">バックグラウンドワーカーの起動を待っています。</target>
        </trans-unit>
        <trans-unit id="1092cdc7eb9ee3391d3a4d79e4f2cbbadb7d2536" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach durable storage.</source>
          <target state="translated">関係データファイルの変更が耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="121ce51ab6e249cf929aa9e0635dd5196c724d55" translate="yes" xml:space="preserve">
          <source>Waiting for changes to a relation data file to reach stable storage.</source>
          <target state="translated">リレーションデータファイルの変更が安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="06baf37c4d00743bd8f1d4776619f21e41c7e849" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from a remote server during synchronous replication.</source>
          <target state="translated">同期レプリケーション中にリモートサーバーからの確認を待っています。</target>
        </trans-unit>
        <trans-unit id="7aedff25c55dbcd34ea828efe5df0cac10c04231" translate="yes" xml:space="preserve">
          <source>Waiting for confirmation from remote server during synchronous replication.</source>
          <target state="translated">同期レプリケーション中にリモートサーバーからの確認を待っています。</target>
        </trans-unit>
        <trans-unit id="06dd73106355257e55c5973700b35599b6ab2aa8" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while adding a line to the data directory lock file.</source>
          <target state="translated">データディレクトリロックファイルに行を追加しながら、データが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="bf1a2cd56f85be8ddf428ad8cd1741cd6c232ca4" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while assigning a new WAL sync method.</source>
          <target state="translated">新しいWAL同期方法を割り当てている間、データが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="7393e0800215c6dc732cf1bd3e9c0f59b66e27cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach durable storage while creating the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルを作成している間、データが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="e096887a303519506fcd67516869ace11ad3e59e" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while adding a line to the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルに行を追加しながら、データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="fe0ab1a16e2329bfa52c27e76aa50ab788d415cf" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while assigning WAL sync method.</source>
          <target state="translated">WAL同期方式を割り当てている間、データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="0a67fcfeb93618a5687879b86795e36261b23961" translate="yes" xml:space="preserve">
          <source>Waiting for data to reach stable storage while creating the data directory lock file.</source>
          <target state="translated">データディレクトリのロックファイルを作成している間、データが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="1f817023f7f1aeed83afe73b277506f04bbf5f51" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to clear transaction id at transaction end.</source>
          <target state="translated">トランザクション終了時にグループリーダーがトランザクションIDをクリアするのを待っています。</target>
        </trans-unit>
        <trans-unit id="9ad12c44c511affe8e5b28dfe797e5442cb69ba2" translate="yes" xml:space="preserve">
          <source>Waiting for group leader to update transaction status at transaction end.</source>
          <target state="translated">トランザクション終了時にグループリーダーがトランザクションのステータスを更新するのを待っています。</target>
        </trans-unit>
        <trans-unit id="6303bec3edc9303d1de1e17ffbef9d10deeb2ec7" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to change state.</source>
          <target state="translated">論理レプリケーションリモートサーバーの状態変更を待っています。</target>
        </trans-unit>
        <trans-unit id="a171ef7b847c02147b5330baa42032a3b728b099" translate="yes" xml:space="preserve">
          <source>Waiting for logical replication remote server to send data for initial table synchronization.</source>
          <target state="translated">論理レプリケーションリモートサーバが初期テーブル同期のためのデータを送信するのを待っています。</target>
        </trans-unit>
        <trans-unit id="f7b87a554b163e3c4b56d071e13d3bb40ae9dcd8" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage during a checkpoint.</source>
          <target state="translated">チェックポイント中に論理的な書き換えマッピングが耐久性のあるストレージに到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="d0128fffe323c5eab36d0b583264686f6fdc14a9" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach durable storage.</source>
          <target state="translated">論理的な書き換えマッピングが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="a1252663514ce3e310a8ccaa53abc308558932c1" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage during a checkpoint.</source>
          <target state="translated">チェックポイント中に論理的な書き換えマッピングが安定したストレージに到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="754897ce0cd2e99fe42e75806589d9d45f48b612" translate="yes" xml:space="preserve">
          <source>Waiting for logical rewrite mappings to reach stable storage.</source>
          <target state="translated">論理的な書き換えマッピングが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="1012667842a00603eeb152c4741dc06b3a218b04" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach durable storage during a logical rewrite.</source>
          <target state="translated">論理的な書き換え中に、マッピングデータが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="ddcc4581e90866cae66b033e94adc36e9d35b43d" translate="yes" xml:space="preserve">
          <source>Waiting for mapping data to reach stable storage during a logical rewrite.</source>
          <target state="translated">論理的な書き換え中に、マッピングデータが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="b8552e94ff493c563b97bc367629ad56d62866bf" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish hashing the inner relation.</source>
          <target state="translated">他のパラレルハッシュ参加者が内部関係のハッシュを終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="e11479178e59844fd7fe15f1ce4eb490d0773d60" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish inserting tuples into new buckets.</source>
          <target state="translated">他のParallel Hash参加者が新しいバケツにタプルを挿入し終わるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7c11b60c1a40d4f8d29e90353a8affe9075ec7f0" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish loading a hash table.</source>
          <target state="translated">他のパラレルハッシュ参加者がハッシュテーブルの読み込みを終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="5413b25ebacbf60f6298ddfd13544237708b4afd" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish partitioning the outer relation.</source>
          <target state="translated">他のParallel Hash参加者が外部関係のパーティショニングを終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="5d8612704b7ac31605b00f1b5ae0376a34a38614" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finish repartitioning.</source>
          <target state="translated">他のParallel Hash参加者が再分割を終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="6ddf8230dce1afc618c7942a19d13a4e06fbab65" translate="yes" xml:space="preserve">
          <source>Waiting for other Parallel Hash participants to finishing repartitioning.</source>
          <target state="translated">他のParallel Hash参加者が再分割を終えるのを待っています。</target>
        </trans-unit>
        <trans-unit id="7ddcd3a1c9792343c59de081cc3c348d37cc1494" translate="yes" xml:space="preserve">
          <source>Waiting for other process to be attached in shared message queue.</source>
          <target state="translated">共有メッセージキューで他のプロセスがアタッチされるのを待っています。</target>
        </trans-unit>
        <trans-unit id="ea1e4d605c6dfe012718f5d6b6342a2c1167a5ba" translate="yes" xml:space="preserve">
          <source>Waiting for parallel &lt;code&gt;CREATE INDEX&lt;/code&gt; workers to finish heap scan.</source>
          <target state="translated">並列 &lt;code&gt;CREATE INDEX&lt;/code&gt; ワーカーがヒープスキャンを完了するのを待機しています。</target>
        </trans-unit>
        <trans-unit id="2c0e5b890525a78c621a8bd9247fc1bb58a1d9d0" translate="yes" xml:space="preserve">
          <source>Waiting for parallel bitmap scan to become initialized.</source>
          <target state="translated">パラレルビットマップスキャンが初期化されるのを待っています。</target>
        </trans-unit>
        <trans-unit id="54d8ebcdd8df7afcbc1ca990a46b504e44b8711d" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation lock.</source>
          <target state="translated">並列クエリ動的共有メモリ割り当てロックを待っています。</target>
        </trans-unit>
        <trans-unit id="1fc906f71278562c97c85008b2e438b9bb00035c" translate="yes" xml:space="preserve">
          <source>Waiting for parallel query dynamic shared memory allocation.</source>
          <target state="translated">並列クエリ動的共有メモリの割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="6b2ad8cbb3533dbd2f7a9b18414fee3c1da25764" translate="yes" xml:space="preserve">
          <source>Waiting for parallel workers to finish computing.</source>
          <target state="translated">並列ワーカーがコンピューティングを終了するのを待っています。</target>
        </trans-unit>
        <trans-unit id="be528b921033388197b955d3bbbb7b2e892893ec" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for a vacuum cleanup.</source>
          <target state="translated">掃除機の回収葛藤解決待ち。</target>
        </trans-unit>
        <trans-unit id="98c345abde177b384e76034b5919030c1a291113" translate="yes" xml:space="preserve">
          <source>Waiting for recovery conflict resolution for dropping a tablespace.</source>
          <target state="translated">テーブルスペースをドロップする際のリカバリーコンフリクトの解決を待っています。</target>
        </trans-unit>
        <trans-unit id="7d3620b94d83d3288e29f36d6b41b0a233781347" translate="yes" xml:space="preserve">
          <source>Waiting for recovery to be resumed.</source>
          <target state="translated">再開に向けて回復を待っています。</target>
        </trans-unit>
        <trans-unit id="d884014cf602749f289dbc7c7fc61acad84fa09d" translate="yes" xml:space="preserve">
          <source>Waiting for standby promotion.</source>
          <target state="translated">待機促進を待っています。</target>
        </trans-unit>
        <trans-unit id="8cb227e761e8b1bc97dcd2f57c98b273168fa6eb" translate="yes" xml:space="preserve">
          <source>Waiting for startup process to send initial data for streaming replication.</source>
          <target state="translated">ストリーミングレプリケーションのための初期データを送信するための起動プロセスを待っています。</target>
        </trans-unit>
        <trans-unit id="575b51c84a8a278b78f70ac32550deee0ade954c" translate="yes" xml:space="preserve">
          <source>Waiting for the &lt;code&gt;pg_control&lt;/code&gt; file to reach durable storage.</source>
          <target state="translated">&lt;code&gt;pg_control&lt;/code&gt; ファイルが永続ストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="4de10813baf47bfe4c27cf4c7969243299b919ed" translate="yes" xml:space="preserve">
          <source>Waiting for the control file to reach stable storage.</source>
          <target state="translated">コントロールファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="7dd0de4ea463c3d55bd0ecf6a2a3ba4fdd4c90a5" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to clear the transaction ID at end of a parallel operation.</source>
          <target state="translated">並列処理の終了時にグループリーダーがトランザクションIDをクリアするのを待っています。</target>
        </trans-unit>
        <trans-unit id="1d874537780129e3ca666a787de17aa9ba412019" translate="yes" xml:space="preserve">
          <source>Waiting for the group leader to update transaction status at end of a parallel operation.</source>
          <target state="translated">並列処理の終了時にグループリーダーがトランザクションステータスを更新するのを待っています。</target>
        </trans-unit>
        <trans-unit id="681bd23f805b6da445bd3d82fc4a46addc600e13" translate="yes" xml:space="preserve">
          <source>Waiting for the page number needed to continue a parallel B-tree scan to become available.</source>
          <target state="translated">並列B-treeスキャンを継続するために必要なページ番号が利用可能になるのを待っています。</target>
        </trans-unit>
        <trans-unit id="19a27081e7292e225f5308f76e3b7bb1b53bae9d" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach durable storage.</source>
          <target state="translated">関係マップファイルが耐久性のあるストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="c939d0ba9c27dac2f7d8824016725fedd49ef586" translate="yes" xml:space="preserve">
          <source>Waiting for the relation map file to reach stable storage.</source>
          <target state="translated">関係マップファイルが安定したストレージに到達するのを待っています。</target>
        </trans-unit>
        <trans-unit id="9e983510c142fcea08d4f84210ccfa6323d4b28e" translate="yes" xml:space="preserve">
          <source>Waiting for truncate of mapping data during a logical rewrite.</source>
          <target state="translated">論理的な書き換え中にマッピングデータの切り捨てを待っています。</target>
        </trans-unit>
        <trans-unit id="c7be20b27094dae3303ee1fadc67011cd3751be8" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to establish connection to remote server.</source>
          <target state="translated">リモートサーバへの接続を確立するためにWAL受信機で待機しています。</target>
        </trans-unit>
        <trans-unit id="8b6df6362589c923614f910bed59cf34ff945324" translate="yes" xml:space="preserve">
          <source>Waiting in WAL receiver to receive data from remote server.</source>
          <target state="translated">WAL受信機でリモートサーバからのデータ受信を待っています。</target>
        </trans-unit>
        <trans-unit id="cb632d8f0ca89d0c5cd00cc7485e8835401d24f7" translate="yes" xml:space="preserve">
          <source>Waiting in a cost-based vacuum delay point.</source>
          <target state="translated">コストベースの真空遅延ポイントで待機。</target>
        </trans-unit>
        <trans-unit id="bb83e82efa5858b6db8ad5949e98eced2a90463a" translate="yes" xml:space="preserve">
          <source>Waiting in an extension.</source>
          <target state="translated">延長で待機中。</target>
        </trans-unit>
        <trans-unit id="feb270e93605e72d07d6bcedd0737f5a39e22df0" translate="yes" xml:space="preserve">
          <source>Waiting in background writer process, hibernating.</source>
          <target state="translated">背景のライタープロセスで待機中、冬眠中。</target>
        </trans-unit>
        <trans-unit id="88eefbfbae399c6feea1548c69357a5e9736f5ab" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL receiver process.</source>
          <target state="translated">WAL受信処理のメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="375265f881add8dd9c33130678344167b52a9588" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL sender process.</source>
          <target state="translated">WAL送信者プロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="f5e173311caac73154fc23d76aed32502c099d08" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of WAL writer process.</source>
          <target state="translated">WALのライター処理のメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="3a633670f0870c8e9a937ee6b4ff3e55e43509be" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of archiver process.</source>
          <target state="translated">アーカイバ処理のメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="7acb76585737d883d007ddb658d4cfd89597eb50" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of autovacuum launcher process.</source>
          <target state="translated">自動バキュームランチャープロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="7e6e41b3df7e89238ff4283ef4198a69ebe76109" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process background worker.</source>
          <target state="translated">背景ライタープロセス背景ワーカーのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="4468be3c04a316f7404c95b5e3ff6208ba74e229" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of background writer process.</source>
          <target state="translated">背景ライター処理のメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="d193be75953171ebbce3b3db2cde50e60c132491" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of checkpointer process.</source>
          <target state="translated">checkpointerプロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="db02418c7eb01a5eb05765091cb30a31f71aa88d" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical apply process.</source>
          <target state="translated">論理適用処理のメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="82a745dd84bf90f7ae367a6c7dc035147ac68293" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical launcher process.</source>
          <target state="translated">論理ランチャープロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="56edcd7dc5636046884520046ede7d834d729f36" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication apply process.</source>
          <target state="translated">論理レプリケーション適用プロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="9560c436af4a42ef660a92403ce9cdd3a8693974" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of logical replication launcher process.</source>
          <target state="translated">論理レプリケーションランチャープロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="1679d413ddb6f0377771d12a5f1423b023c45511" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of startup process for WAL to arrive, during streaming recovery.</source>
          <target state="translated">ストリーミング回復中にWALが到着するまで起動処理のメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="fd3c72bbecc0f184f22e57ca78f3e93236b96e1a" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of statistics collector process.</source>
          <target state="translated">統計情報コレクタプロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="1e0772397293bff630517da7bd7ffb1ab81b17f5" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of syslogger process.</source>
          <target state="translated">sysloggerプロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="54f59b1a36db7407d20232e85176d4c1a23692f4" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the archiver process.</source>
          <target state="translated">アーカイバープロセスのメインループで待機中。</target>
        </trans-unit>
        <trans-unit id="212f0884ddfbc91689a2a97c09aafbcd3f389116" translate="yes" xml:space="preserve">
          <source>Waiting in main loop of the statistics collector process.</source>
          <target state="translated">統計情報コレクタプロセスのメインループで待機しています。</target>
        </trans-unit>
        <trans-unit id="3b4ceca9ff1b34dd3a21d5a1be2bf8a9aa711a70" translate="yes" xml:space="preserve">
          <source>Waiting in process that called &lt;code&gt;pg_sleep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; を呼び出したプロセスで待機しています。</target>
        </trans-unit>
        <trans-unit id="8d789f564ccad610d19b36929dbb0ef518eb37c8" translate="yes" xml:space="preserve">
          <source>Waiting to access a data page in memory.</source>
          <target state="translated">メモリ内のデータページへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="a4ae79783ab5a39da6e76c4478527282bcedbc6a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about composite types.</source>
          <target state="translated">複合型に関する並列クエリの情報へのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="90d1b409aa03dee9b02a04e2a2e3f64452f3400a" translate="yes" xml:space="preserve">
          <source>Waiting to access a parallel query's information about type modifiers that identify anonymous record types.</source>
          <target state="translated">匿名レコード型を識別する型修飾子に関する並列クエリの情報へのアクセスを待機しています。</target>
        </trans-unit>
        <trans-unit id="b1030c503e3237c1219d1eea28582a6ddcbee56c" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared TID bitmap during a parallel bitmap index scan.</source>
          <target state="translated">並列ビットマップインデックススキャン中に共有TIDビットマップへのアクセスを待ちます。</target>
        </trans-unit>
        <trans-unit id="7eba3915c1db0580d2b281d905946603d4982aff" translate="yes" xml:space="preserve">
          <source>Waiting to access a shared tuple store during parallel query.</source>
          <target state="translated">並列クエリ中に共有タプルストアへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="129d2539d77dbbde3d4d4e8ea2141ca238f7d876" translate="yes" xml:space="preserve">
          <source>Waiting to access predicate lock information used by serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションで使用される述語ロック情報へのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="c7319b09761891c0f9227dbd3732f4b9eaeb8739" translate="yes" xml:space="preserve">
          <source>Waiting to access the &lt;code&gt;NOTIFY&lt;/code&gt; message SLRU cache.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; メッセージSLRUキャッシュへのアクセスを待機しています。</target>
        </trans-unit>
        <trans-unit id="af1ca2e2935e52e66c06e90f2e54befc88f72df7" translate="yes" xml:space="preserve">
          <source>Waiting to access the commit timestamp SLRU cache.</source>
          <target state="translated">コミットタイムスタンプ SLRU キャッシュへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="0184a02009f44f4d2a88cbd98d9dfe8231fceb5e" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of finished serializable transactions.</source>
          <target state="translated">終了したシリアライズ可能なトランザクションのリストへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="55fba80517e3090a2255d706ee1972631c869d74" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションが保持する述語ロックのリストへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="f47f83daf5272307314e793a722029f6849c834f" translate="yes" xml:space="preserve">
          <source>Waiting to access the list of predicate locks held by the current serializable transaction during a parallel query.</source>
          <target state="translated">並列クエリ中に現在のシリアライズ可能なトランザクションが保持する述語ロックのリストへのアクセスを待機しています。</target>
        </trans-unit>
        <trans-unit id="0d72c61a42652b27a772dd6eed5858254b3939df" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact member SLRU cache.</source>
          <target state="translated">multixact メンバ SLRU キャッシュへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="c0c797a16c61c341fd52d3f66bf04186016fb3de" translate="yes" xml:space="preserve">
          <source>Waiting to access the multixact offset SLRU cache.</source>
          <target state="translated">マルチクオクトオフセット SLRU キャッシュへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="860e2d04d5faad33e65a1c939bd5f4775f44e584" translate="yes" xml:space="preserve">
          <source>Waiting to access the serializable transaction conflict SLRU cache.</source>
          <target state="translated">シリアライズ可能なトランザクション競合SLRUキャッシュへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="a8c61dc32e3583de9339bc9f5339255eccb847d4" translate="yes" xml:space="preserve">
          <source>Waiting to access the shared per-process data structures (typically, to get a snapshot or report a session's transaction ID).</source>
          <target state="translated">共有されたプロセスごとのデータ構造へのアクセスを待機しています(通常、スナップショットを取得したり、セッションのトランザクションIDを報告したりします)。</target>
        </trans-unit>
        <trans-unit id="6be8feecbd6665e987b15bc5fe4b1aa15dcee557" translate="yes" xml:space="preserve">
          <source>Waiting to access the sub-transaction SLRU cache.</source>
          <target state="translated">サブトランザクションSLRUキャッシュへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="bb9c50c150b703d0eb8293a5862178e36f3db67f" translate="yes" xml:space="preserve">
          <source>Waiting to access the transaction status SLRU cache.</source>
          <target state="translated">トランザクションステータスSLRUキャッシュへのアクセスを待っています。</target>
        </trans-unit>
        <trans-unit id="453521c4c18069faa9fd0afad3d83ca7731d1096" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a non-relation database object.</source>
          <target state="translated">非リレーショナル・データベース・オブジェクトのロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="373b1f9b0bfcc9c3b92c4d65ca011a20f7f7ee7b" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a page of a relation.</source>
          <target state="translated">関係のページでロックを取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="e1e200aae0e4f2353a2c19cd08c7d6ee7ce7f912" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a relation.</source>
          <target state="translated">関係のロックを取得するために待っています。</target>
        </trans-unit>
        <trans-unit id="caf9078aaa0a5a46ce631268ce4c46ea2cb0e198" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on a tuple.</source>
          <target state="translated">タプルのロックを取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="20d61e9ac29e8e57ca0786825f9ae212af87d782" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a lock on page of a relation.</source>
          <target state="translated">関係のページでロックを取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="60529117b6f828f517a439e0152cfca12a03780e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a pin on a buffer.</source>
          <target state="translated">バッファ上でピンの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="9dff15d412549524e8b05e08b4e658a978321307" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a speculative insertion lock.</source>
          <target state="translated">投機的な挿入ロックの獲得を待っています。</target>
        </trans-unit>
        <trans-unit id="6f1d92a10ff6e0f42c232bac9cd39b9515b5e1f1" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a user lock.</source>
          <target state="translated">ユーザーロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="b864edb73d7fdb51b089c159fd2e24aac209fa44" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual transaction ID lock.</source>
          <target state="translated">仮想トランザクションIDロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="feee645b171eddc5255ea3172e0b6eaae2f3531e" translate="yes" xml:space="preserve">
          <source>Waiting to acquire a virtual xid lock.</source>
          <target state="translated">仮想 xid ロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="0cff112c15e1e7f938ee8722e01003e541c3a9b9" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an advisory user lock.</source>
          <target state="translated">勧告ユーザロックの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="fb4afc5fd680e2c4a5249b716bc3eb3612204493" translate="yes" xml:space="preserve">
          <source>Waiting to acquire an exclusive pin on a buffer.</source>
          <target state="translated">バッファ上の専用ピンの取得を待ちます。</target>
        </trans-unit>
        <trans-unit id="f4b782a596b50a85963931c1ce8ff87a36ab9e82" translate="yes" xml:space="preserve">
          <source>Waiting to add a message in shared invalidation queue.</source>
          <target state="translated">共有無効化キューにメッセージを追加するのを待っています。</target>
        </trans-unit>
        <trans-unit id="e0bc3fce7ad76f7cd0de9cfb2f8867086e1cad27" translate="yes" xml:space="preserve">
          <source>Waiting to add a message to the shared catalog invalidation queue.</source>
          <target state="translated">共有カタログ無効キューへのメッセージの追加を待っています。</target>
        </trans-unit>
        <trans-unit id="a30c5b64b9088c9bea1b788c2d9cad490d0feadc" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine locks for backends, or waiting to join or exit a locking group (used by parallel query).</source>
          <target state="translated">バックエンドのロックの追加や検査を待ったり、ロックグループへの参加や終了を待ったりします(並列クエリで使用されます)。</target>
        </trans-unit>
        <trans-unit id="4234f3768471935481a7a5ac70e216c3b3196d0a" translate="yes" xml:space="preserve">
          <source>Waiting to add or examine predicate lock information.</source>
          <target state="translated">述語ロック情報の追加や検査を待っています。</target>
        </trans-unit>
        <trans-unit id="cd6ab73b17fc50224d6ba20de7b66c56a5168edd" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new OID.</source>
          <target state="translated">新しいOIDの割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="c6110497bf2fb4e7dd3e567f14149228534e81be" translate="yes" xml:space="preserve">
          <source>Waiting to allocate a new transaction ID.</source>
          <target state="translated">新しいトランザクションIDの割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="922ece807fb5d0e3eca745374502101b8e2f9883" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign a transaction id.</source>
          <target state="translated">トランザクションIDの割り当てまたは割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="4df1187e247ec9e3885764b731ccac5a81693366" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or assign an OID.</source>
          <target state="translated">OIDの割り当てまたは割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="36e78f99b93b8582ddda9533616d35bad0cb3435" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or exchange a chunk of memory or update counters during Parallel Hash plan execution.</source>
          <target state="translated">パラレルハッシュ計画の実行中に、メモリのチャンクの割り当てや交換、カウンタの更新を待っています。</target>
        </trans-unit>
        <trans-unit id="aea0084a8686cdd126b6dc0b70e3bb510372f940" translate="yes" xml:space="preserve">
          <source>Waiting to allocate or free a replication slot.</source>
          <target state="translated">レプリケーションスロットの割り当てまたは解放を待っています。</target>
        </trans-unit>
        <trans-unit id="392b0fcbf6923b50ad00d9bcdf711922567f010a" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL at recovery because it is delayed.</source>
          <target state="translated">遅れているので回復時のWAL適用待ち。</target>
        </trans-unit>
        <trans-unit id="6a88aa7353a070ee85e5931747ec79047e6808c8" translate="yes" xml:space="preserve">
          <source>Waiting to apply WAL during recovery because of a delay setting.</source>
          <target state="translated">遅延設定のため回復中にWALの適用待ち。</target>
        </trans-unit>
        <trans-unit id="417e2e4d470ba2ea215e899c1f2f47a808b6cd1d" translate="yes" xml:space="preserve">
          <source>Waiting to associate a data block with a buffer in the buffer pool.</source>
          <target state="translated">バッファプール内のバッファとデータブロックの関連付けを待っています。</target>
        </trans-unit>
        <trans-unit id="441c3081779de229e60de2154d2224a6b45068d6" translate="yes" xml:space="preserve">
          <source>Waiting to begin a checkpoint.</source>
          <target state="translated">チェックポイントの開始を待っています。</target>
        </trans-unit>
        <trans-unit id="0b5eba1b1476e67df8c9026fe8a8423164cbbbaf" translate="yes" xml:space="preserve">
          <source>Waiting to choose the next subplan during Parallel Append plan execution.</source>
          <target state="translated">Parallel Appendプラン実行中に次のサブプランを選択するのを待っています。</target>
        </trans-unit>
        <trans-unit id="ef3a63e38286ce146119c1f18cfc00a196004cf5" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop a tablespace.</source>
          <target state="translated">テーブルスペースの作成またはドロップを待っています。</target>
        </trans-unit>
        <trans-unit id="11402cb956b4c4ad7b4f3ee48f5957e1d0e2837b" translate="yes" xml:space="preserve">
          <source>Waiting to create or drop the tablespace.</source>
          <target state="translated">テーブルスペースの作成または削除を待っています。</target>
        </trans-unit>
        <trans-unit id="33c72accbdd4730b372dab88dd65b76db73de627" translate="yes" xml:space="preserve">
          <source>Waiting to create, drop or use a replication origin.</source>
          <target state="translated">レプリケーションオリジンの作成、ドロップ、または使用を待っています。</target>
        </trans-unit>
        <trans-unit id="65bc84d857a25120993bfa2901196e8db0fe8c4c" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate a hash table.</source>
          <target state="translated">ハッシュテーブルを割り当てるパラレルハッシュ参加者の選出を待っています。</target>
        </trans-unit>
        <trans-unit id="f4f746425fc465e7164c9c695db3b4635155f935" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more batches.</source>
          <target state="translated">より多くのバッチを割り当てるためにParallel Hash参加者の選出を待っています。</target>
        </trans-unit>
        <trans-unit id="639eee9765487a635a37650a7d0fb63770b1ca2a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate more buckets.</source>
          <target state="translated">より多くのバケットを割り当てるためにParallel Hash参加者の選出を待っています。</target>
        </trans-unit>
        <trans-unit id="e5677145792ffce4d3d31df1e9a789e136de6ea8" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to allocate the initial hash table.</source>
          <target state="translated">最初のハッシュテーブルを割り当てるParallel Hash参加者の選出を待っています。</target>
        </trans-unit>
        <trans-unit id="065be077f679b5dad73d4b8a473bd2b28958e69a" translate="yes" xml:space="preserve">
          <source>Waiting to elect a Parallel Hash participant to decide on future batch growth.</source>
          <target state="translated">今後のバッチ成長を決定するためのパラレルハッシュ参加者の選出を待っています。</target>
        </trans-unit>
        <trans-unit id="51f5db2c59767bd472dd0b1faf70ac07aafa7a96" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that a table selected for autovacuum still needs vacuuming.</source>
          <target state="translated">自動バキューム用に選択されたテーブルがまだバキュームを必要としていることを確認するのを待っています。</target>
        </trans-unit>
        <trans-unit id="ef13562f4466bb31b5bf871e5d3f767784c48032" translate="yes" xml:space="preserve">
          <source>Waiting to ensure that the table it has selected for a vacuum still needs vacuuming.</source>
          <target state="translated">それが真空のために選択したテーブルがまだ真空を必要としていることを確認するために待っています。</target>
        </trans-unit>
        <trans-unit id="d69f496f29eae75635234b22654119ee74ecb1dc" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;pg_xact_status&lt;/code&gt; or update the oldest transaction ID available to it.</source>
          <target state="translated">Waiting to execute &lt;code&gt;pg_xact_status&lt;/code&gt; or update the oldest transaction ID available to it.</target>
        </trans-unit>
        <trans-unit id="7d2e90490a1d7b7d270317787f40bff2e1d72ee9" translate="yes" xml:space="preserve">
          <source>Waiting to execute &lt;code&gt;txid_status&lt;/code&gt; or update the oldest transaction id available to it.</source>
          <target state="translated">&lt;code&gt;txid_status&lt;/code&gt; の実行、または使用可能な最も古いトランザクションIDの更新を待機しています。</target>
        </trans-unit>
        <trans-unit id="905b59818613073e2e260c6b0fb7d68bf3c39843" translate="yes" xml:space="preserve">
          <source>Waiting to extend a relation.</source>
          <target state="translated">関係の延長を待っています。</target>
        </trans-unit>
        <trans-unit id="d1ff05f0321453c7e170463f2183122fba046afb" translate="yes" xml:space="preserve">
          <source>Waiting to fill a dynamic shared memory backing file with zeroes.</source>
          <target state="translated">動的共有メモリのバッキングファイルをゼロで埋めるのを待っています。</target>
        </trans-unit>
        <trans-unit id="f8b7f54188ceea3dc5def955dc47ae1f28373839" translate="yes" xml:space="preserve">
          <source>Waiting to find or allocate space in shared memory.</source>
          <target state="translated">共有メモリ内のスペースの検索や割り当てを待っています。</target>
        </trans-unit>
        <trans-unit id="fb53c073cc374cfb75fd8b826e6b4d7eb6cc9003" translate="yes" xml:space="preserve">
          <source>Waiting to get a snapshot or clearing a transaction id at transaction end.</source>
          <target state="translated">トランザクション終了時にスナップショットの取得を待っているか、トランザクションIDをクリアしています。</target>
        </trans-unit>
        <trans-unit id="e384d346b49ba85024e06c032fcf3ccf1737b636" translate="yes" xml:space="preserve">
          <source>Waiting to get the start location of a scan on a table for synchronized scans.</source>
          <target state="translated">同期スキャンのテーブル上でスキャンの開始位置を取得するのを待っています。</target>
        </trans-unit>
        <trans-unit id="77a61ca13921177e3120d7941bf5fe7710333ad3" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL data into a memory buffer.</source>
          <target state="translated">メモリバッファへのWALデータの挿入を待っています。</target>
        </trans-unit>
        <trans-unit id="9a6beee315605623099d06c2371ae56da6b46cc7" translate="yes" xml:space="preserve">
          <source>Waiting to insert WAL into a memory buffer.</source>
          <target state="translated">メモリバッファへのWALの挿入を待っています。</target>
        </trans-unit>
        <trans-unit id="cadbcac0880c9c035e541586388a47501c362c88" translate="yes" xml:space="preserve">
          <source>Waiting to manage an extension's space allocation in shared memory.</source>
          <target state="translated">共有メモリ内の拡張子のスペース割り当てを管理するために待機しています。</target>
        </trans-unit>
        <trans-unit id="fe4ce59b2db271f1abfb91f4099370c7dcadc0ae" translate="yes" xml:space="preserve">
          <source>Waiting to manage fsync requests.</source>
          <target state="translated">fsync リクエストの管理を待っています。</target>
        </trans-unit>
        <trans-unit id="e3141c5d05c342451c8644a34df11be83dd434ad" translate="yes" xml:space="preserve">
          <source>Waiting to manage space allocation in shared memory.</source>
          <target state="translated">共有メモリのスペース割り当ての管理を待っています。</target>
        </trans-unit>
        <trans-unit id="fac57a518044fa2f05c64ea1dd8ce9527a59af1f" translate="yes" xml:space="preserve">
          <source>Waiting to obtain a valid snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</source>
          <target state="translated">Waiting to obtain a valid snapshot for a &lt;code&gt;READ ONLY DEFERRABLE&lt;/code&gt; transaction.</target>
        </trans-unit>
        <trans-unit id="b97c8584b996285f48aeab64ef02658839acbba9" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a list of locks held by serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションが保持するロックのリストに対する操作の実行を待機しています。</target>
        </trans-unit>
        <trans-unit id="d8589a1b8c66d6f8e4debafdd099f1a4b71a5b13" translate="yes" xml:space="preserve">
          <source>Waiting to perform an operation on a serializable transaction in a parallel query.</source>
          <target state="translated">並列クエリでシリアライズ可能なトランザクションに対する操作の実行を待っています。</target>
        </trans-unit>
        <trans-unit id="d2ade432e382335fbb1d6fb86bda4500ee8c2cbb" translate="yes" xml:space="preserve">
          <source>Waiting to perform checkpoint.</source>
          <target state="translated">チェックポイントの実行を待っています。</target>
        </trans-unit>
        <trans-unit id="3e379fd689c1e6c70aa9f8b650b7c7fb7692028c" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client while establishing a GSSAPI session.</source>
          <target state="translated">GSSAPIセッションを確立している間、クライアントからのデータ読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="1908bfbabea7a0ab1bbde739ebc0330fc7517b79" translate="yes" xml:space="preserve">
          <source>Waiting to read data from the client.</source>
          <target state="translated">クライアントからのデータ読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="05dd640e8c1d54ebf01054c0befd12ca4f14b63e" translate="yes" xml:space="preserve">
          <source>Waiting to read or record conflicting serializable transactions.</source>
          <target state="translated">競合するシリアライズ可能なトランザクションの読み込みまたは記録を待っています。</target>
        </trans-unit>
        <trans-unit id="0afe38ebe7d995583b3d1a5cd94b6fbc8cf1b845" translate="yes" xml:space="preserve">
          <source>Waiting to read or truncate multixact information.</source>
          <target state="translated">マルチアクト情報の読み込み待ち、または切り捨て待ち。</target>
        </trans-unit>
        <trans-unit id="89e6d605086c4806a8e8361ed20ce472bcc5d0c1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update &lt;code&gt;NOTIFY&lt;/code&gt; messages.</source>
          <target state="translated">Waiting to read or update &lt;code&gt;NOTIFY&lt;/code&gt; messages.</target>
        </trans-unit>
        <trans-unit id="aa2ee7fba8bdd1b9ba46fd013db4148ed8d4f325" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_filenode.map&lt;/code&gt; file (used to track the filenode assignments of certain system catalogs).</source>
          <target state="translated">Waiting to read or update a &lt;code&gt;pg_filenode.map&lt;/code&gt; file (used to track the filenode assignments of certain system catalogs).</target>
        </trans-unit>
        <trans-unit id="f06b28a219ba82487eff75cb07672ef51a1fba36" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a &lt;code&gt;pg_internal.init&lt;/code&gt; relation cache initialization file.</source>
          <target state="translated">Waiting to read or update a &lt;code&gt;pg_internal.init&lt;/code&gt; relation cache initialization file.</target>
        </trans-unit>
        <trans-unit id="29aea2dafdc907848a947f9ada3488409914bca8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update a process' fast-path lock information.</source>
          <target state="translated">プロセスのファストパスロック情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="a018a1a15593b5af23414939d50aec3fcb48c5cb" translate="yes" xml:space="preserve">
          <source>Waiting to read or update background worker state.</source>
          <target state="translated">バックグラウンドワーカーの状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="98f949b18dca9797ce85a82873e92ff14c18778a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory allocation information.</source>
          <target state="translated">動的共有メモリ割り当て情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="cea27617060567594092b7422c38330bfc2e5ee2" translate="yes" xml:space="preserve">
          <source>Waiting to read or update dynamic shared memory state.</source>
          <target state="translated">動的共有メモリの状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="9ba9dcf3b19a57aaa5ade4bb0b3f5c3178217365" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about &amp;ldquo;heavyweight&amp;rdquo; locks.</source>
          <target state="translated">Waiting to read or update information about &amp;ldquo;heavyweight&amp;rdquo; locks.</target>
        </trans-unit>
        <trans-unit id="3aef06dd768e3617fde4dd6b5fb7f38e7fb0ef3c" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションに関する情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="5b94e34a6c9a38b9de8ddbf38266ea41569caa0e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about synchronous replicas.</source>
          <target state="translated">同期レプリカに関する情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="8db953a370c198b1e5b5a6d588d15d8ed6771d32" translate="yes" xml:space="preserve">
          <source>Waiting to read or update information about the state of synchronous replication.</source>
          <target state="translated">同期レプリケーションの状態に関する情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="7be479f3c24eeb847b5e44a9bf4f341c29d1834b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact member mappings.</source>
          <target state="translated">マルチエクストラクト・メンバ・マッピングの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="548a78a89a3c004e9ad475a70fb6f1bb50c1151e" translate="yes" xml:space="preserve">
          <source>Waiting to read or update multixact offset mappings.</source>
          <target state="translated">多軸オフセットマッピングの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="ed18ac469b6f870e80be0efbf5c76a4d5c79b754" translate="yes" xml:space="preserve">
          <source>Waiting to read or update notification messages.</source>
          <target state="translated">通知メッセージの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="76d4dfb568ccc6112df58f601dc5c426ad5d62a8" translate="yes" xml:space="preserve">
          <source>Waiting to read or update old snapshot control information.</source>
          <target state="translated">古いスナップショット制御情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="6ce0cc66a076e07f94b764161b2bddd57ada2509" translate="yes" xml:space="preserve">
          <source>Waiting to read or update replication slot state.</source>
          <target state="translated">レプリケーションスロットの状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="fff67315163276ff44c96c0a78a1830dd666732b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared multixact state.</source>
          <target state="translated">共有マルチアクト状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="b79ef3c6f580409e99c1e495bc8e24c202fbe7ed" translate="yes" xml:space="preserve">
          <source>Waiting to read or update shared notification state.</source>
          <target state="translated">共有通知状態の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="af64ba8ecf87cac9594cd6dc3c61c2e7ddf060d1" translate="yes" xml:space="preserve">
          <source>Waiting to read or update sub-transaction information.</source>
          <target state="translated">サブトランザクション情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="c25e2fc156128ae3093a921e12431593e8862638" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the &lt;code&gt;pg_control&lt;/code&gt; file or create a new WAL file.</source>
          <target state="translated">Waiting to read or update the &lt;code&gt;pg_control&lt;/code&gt; file or create a new WAL file.</target>
        </trans-unit>
        <trans-unit id="bdb0edf32466a645cdde40c21227abb2a0bb1f30" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the control file or creation of a new WAL file.</source>
          <target state="translated">制御ファイルの読み込みや更新、新規WALファイルの作成を待っています。</target>
        </trans-unit>
        <trans-unit id="017527ae52f7de277c3c95bf02bbacf34474f0f5" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the current state of autovacuum workers.</source>
          <target state="translated">自動バキューム作業員の現状を読むか更新するのを待っています。</target>
        </trans-unit>
        <trans-unit id="221da797b029fb896c5fbaed99fd507a4ef2a941" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the fast-path lock information.</source>
          <target state="translated">ファストパスロック情報の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="744cbcf49721354a8aff1c310f4ca421dbb8db3a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for a transaction commit timestamp.</source>
          <target state="translated">トランザクション・コミット・タイムスタンプに設定された最後の値の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="e9baf36ef5d66bb0ea1e99230d14314cf70bc406" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the last value set for the transaction timestamp.</source>
          <target state="translated">トランザクションのタイムスタンプに設定された最後の値の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="e381bb78e4f640c21175ed08f51ed2c3a71544c7" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the progress of one replication origin.</source>
          <target state="translated">1つのレプリケーションオリジンのプログレスの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="15f6ffef563dec9ba786a7f233d5003f5ed45d14" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the replication progress.</source>
          <target state="translated">レプリケーションの進捗状況の読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="9ed2e28217e033a2eda63210c67632651e72f60a" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of logical replication workers.</source>
          <target state="translated">論理レプリケーションワーカーの状態の読み取りまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="defd9a9d465fec9edd19efb8c557ca9acbf7364b" translate="yes" xml:space="preserve">
          <source>Waiting to read or update the state of prepared transactions.</source>
          <target state="translated">準備された取引の状態の読み取りまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="3dc7e6836006d3d5cbb7a9151c1a348063bbcc88" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction commit timestamps.</source>
          <target state="translated">トランザクション・コミットのタイムスタンプの読み込みまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="22fb7890af933754ae7b2b3d81b6bd6e23c2cc52" translate="yes" xml:space="preserve">
          <source>Waiting to read or update transaction status.</source>
          <target state="translated">トランザクションステータスの読み取りまたは更新を待っています。</target>
        </trans-unit>
        <trans-unit id="1691bd5ffa74ce0764d59f613b874fce42907700" translate="yes" xml:space="preserve">
          <source>Waiting to read or update vacuum-related information for a B-tree index.</source>
          <target state="translated">Bツリーインデックスの真空関連情報の閲覧・更新を待っています。</target>
        </trans-unit>
        <trans-unit id="7909f678b84800f1b2a16328d0f20ff93a738a0c" translate="yes" xml:space="preserve">
          <source>Waiting to read or write a data page in memory.</source>
          <target state="translated">メモリ内のデータページの読み書きを待っています。</target>
        </trans-unit>
        <trans-unit id="ba3f3c6d87b25a2add5f41dc054490a6748416d8" translate="yes" xml:space="preserve">
          <source>Waiting to read or write relation cache initialization file.</source>
          <target state="translated">リレーションキャッシュ初期化ファイルの読み込みまたは書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="56e29e2fa37b4e49226f461d31f27cc492afa177" translate="yes" xml:space="preserve">
          <source>Waiting to read while creating the data directory lock file.</source>
          <target state="translated">データディレクトリロックファイルの作成中に読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="22b6a17e9f6b4570d83c86bfc0b1331afbfa69c0" translate="yes" xml:space="preserve">
          <source>Waiting to receive bytes from a shared message queue.</source>
          <target state="translated">共有メッセージキューからのバイトの受信を待っています。</target>
        </trans-unit>
        <trans-unit id="9ce53a35add68653a7082475749be3845de4e91c" translate="yes" xml:space="preserve">
          <source>Waiting to replace a page in WAL buffers.</source>
          <target state="translated">WAL バッファ内のページの入れ替えを待っています。</target>
        </trans-unit>
        <trans-unit id="c84c4a6cb5ccf93e74ddb23312f4a777174ed071" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve messages from the shared catalog invalidation queue.</source>
          <target state="translated">共有カタログ無効キューからのメッセージの取得を待っています。</target>
        </trans-unit>
        <trans-unit id="e3b17dffde0ea5035f1032f34d22df0ea10ab951" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or remove messages from shared invalidation queue.</source>
          <target state="translated">共有された無効化キューからのメッセージの取得または削除を待っています。</target>
        </trans-unit>
        <trans-unit id="4f507f65bfda2fa748e9dfb44f6b949cbab52bf9" translate="yes" xml:space="preserve">
          <source>Waiting to retrieve or store information about serializable transactions.</source>
          <target state="translated">シリアライズ可能なトランザクションに関する情報の取得または保存を待機しています。</target>
        </trans-unit>
        <trans-unit id="eda502d0abfb7f1427a080a8bf7103d25fc2176f" translate="yes" xml:space="preserve">
          <source>Waiting to select the starting location of a synchronized table scan.</source>
          <target state="translated">同期テーブル スキャンの開始位置の選択を待っています。</target>
        </trans-unit>
        <trans-unit id="c9928fb30a8b9bafde30f4c1a7932ab2be3ad802" translate="yes" xml:space="preserve">
          <source>Waiting to send bytes to a shared message queue.</source>
          <target state="translated">共有メッセージキューへのバイト送信を待っています。</target>
        </trans-unit>
        <trans-unit id="352defc191b1b37d8d934ce574b79689999451d7" translate="yes" xml:space="preserve">
          <source>Waiting to setup, drop or use replication origin.</source>
          <target state="translated">セットアップ、ドロップ、またはレプリケーションオリジンの使用を待っています。</target>
        </trans-unit>
        <trans-unit id="25cb6ca2b8d634f565c4d46066dc5f3462003ea1" translate="yes" xml:space="preserve">
          <source>Waiting to synchronize workers during Parallel Hash Join plan execution.</source>
          <target state="translated">Parallel Hash Join計画の実行中にワーカーの同期を待っています。</target>
        </trans-unit>
        <trans-unit id="9266129c75950e38bd53efc5efcc13655677392e" translate="yes" xml:space="preserve">
          <source>Waiting to update &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datfrozenxid&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt;.&lt;code&gt;datminmxid&lt;/code&gt;.</source>
          <target state="translated">Waiting to update &lt;code&gt;pg_database&lt;/code&gt; . &lt;code&gt;datfrozenxid&lt;/code&gt; and &lt;code&gt;pg_database&lt;/code&gt; . &lt;code&gt;datminmxid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb44735a3aba3220d386c9b3faf0ba38310b7b2b" translate="yes" xml:space="preserve">
          <source>Waiting to update limit on &lt;code&gt;NOTIFY&lt;/code&gt; message storage.</source>
          <target state="translated">Waiting to update limit on &lt;code&gt;NOTIFY&lt;/code&gt; message storage.</target>
        </trans-unit>
        <trans-unit id="bedfd2279a25f8b35eba1268870241ba6990c56e" translate="yes" xml:space="preserve">
          <source>Waiting to update limits on transaction id and multixact consumption.</source>
          <target state="translated">トランザクションIDとマルチアクトの消費量の制限の更新を待っています。</target>
        </trans-unit>
        <trans-unit id="99b1822a05f8be538a4edd0d27d811178799d3aa" translate="yes" xml:space="preserve">
          <source>Waiting to update the &lt;code&gt;postgresql.auto.conf&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;postgresql.auto.conf&lt;/code&gt; ファイルの更新を待機しています。</target>
        </trans-unit>
        <trans-unit id="7f7ad4b1674906a82b48581d682f5005d47dd119" translate="yes" xml:space="preserve">
          <source>Waiting to update the relation map file used to store catalog to filenode mapping.</source>
          <target state="translated">カタログからファイルノードへのマッピングを格納するために使用されるリレーションマップファイルの更新を待っています。</target>
        </trans-unit>
        <trans-unit id="8dc204f5803f3077a290dca7bb374395f034529e" translate="yes" xml:space="preserve">
          <source>Waiting to write a protocol message to a shared message queue.</source>
          <target state="translated">共有メッセージキューへのプロトコルメッセージの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="2d0728d153f9f18004a22e4fb271924454b6a556" translate="yes" xml:space="preserve">
          <source>Waiting to write data to the client.</source>
          <target state="translated">クライアントへのデータ書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="65a1974782cb646a2959736cb6599731cefd99f2" translate="yes" xml:space="preserve">
          <source>Waiting to write zero bytes to a dynamic shared memory backing file.</source>
          <target state="translated">動的共有メモリバッキングファイルへのゼロバイトの書き込みを待っています。</target>
        </trans-unit>
        <trans-unit id="0929df55dd9f72fd6c1d910f07bdae3bd6e941bb" translate="yes" xml:space="preserve">
          <source>Warm and hot standby servers can be kept current by reading a stream of write-ahead log (WAL) records. If the main server fails, the standby contains almost all of the data of the main server, and can be quickly made the new master database server. This can be synchronous or asynchronous and can only be done for the entire database server.</source>
          <target state="translated">ウォームスタンバイおよびホットスタンバイサーバは、WAL(write-ahead log)レコードのストリームを読み込むことで、最新の状態に保つことができます。メインサーバに障害が発生した場合、スタンバイサーバにはメインサーバのほぼすべてのデータが含まれており、迅速に新しいマスターデータベースサーバにすることができます。これは同期または非同期のどちらでも可能で、データベースサーバ全体に対してのみ行うことができます。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="a016c375864acf9c142cbb1359e053c54d4d9438" translate="yes" xml:space="preserve">
          <source>We already saw that &lt;code&gt;ORDER BY&lt;/code&gt; can be omitted if the ordering of rows is not important. It is also possible to omit &lt;code&gt;PARTITION BY&lt;/code&gt;, in which case there is a single partition containing all rows.</source>
          <target state="translated">行の順序が重要でない場合は、 &lt;code&gt;ORDER BY&lt;/code&gt; を省略できることはすでに説明しました。 &lt;code&gt;PARTITION BY&lt;/code&gt; を省略することもできます。その場合、すべての行を含む単一のパーティションがあります。</target>
        </trans-unit>
        <trans-unit id="836ee2eeb6e7ae6444006848acb871065ea3b213" translate="yes" xml:space="preserve">
          <source>We already saw the MCV information for &lt;code&gt;stringu1&lt;/code&gt;, and here is its histogram:</source>
          <target state="translated">&lt;code&gt;stringu1&lt;/code&gt; のMCV情報はすでに確認しました。そのヒストグラムを次に示します。</target>
        </trans-unit>
        <trans-unit id="4916a888ae7040005cd716f2c3e28e1930fe1e1c" translate="yes" xml:space="preserve">
          <source>We also want a guarantee that once a transaction is completed and acknowledged by the database system, it has indeed been permanently recorded and won't be lost even if a crash ensues shortly thereafter. For example, if we are recording a cash withdrawal by Bob, we do not want any chance that the debit to his account will disappear in a crash just after he walks out the bank door. A transactional database guarantees that all the updates made by a transaction are logged in permanent storage (i.e., on disk) before the transaction is reported complete.</source>
          <target state="translated">また、一度トランザクションが完了し、データベースシステムによって承認されると、それは本当に永久に記録され、その後すぐにクラッシュが発生しても失われないことを保証したいと思います。例えば、ボブが現金を引き出したことを記録している場合、彼が銀行のドアから出て行った直後のクラッシュで彼の口座への引き落としが消えてしまうようなことは避けたいものです。トランザクションデータベースは、トランザクションが完了したと報告される前に、トランザクションによって行われたすべての更新が永久記憶装置(ディスク上)に記録されることを保証します。</target>
        </trans-unit>
        <trans-unit id="6743dd465747bd2e107f6841f4c88e12a10fdc63" translate="yes" xml:space="preserve">
          <source>We can also access arbitrary rectangular slices of an array, or subarrays. An array slice is denoted by writing &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; for one or more array dimensions. For example, this query retrieves the first item on Bill's schedule for the first two days of the week:</source>
          <target state="translated">また、配列またはサブ配列の任意の長方形スライスにアクセスすることもできます。配列スライスは、1つ以上の配列次元に対して &lt;code&gt;lower-bound:upper-bound&lt;/code&gt; を記述することによって示されます。たとえば、次のクエリは、ビルのスケジュールの最初の2日間の最初のアイテムを取得します。</target>
        </trans-unit>
        <trans-unit id="26d5e00c2932aa021f71e1c7987bbc84382d9b85" translate="yes" xml:space="preserve">
          <source>We can also choose to return &lt;code&gt;NULL&lt;/code&gt;, instead of the lower-cased word, if it is not found in the stop words file. This behavior is selected by setting the dictionary's &lt;code&gt;Accept&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Continuing the example:</source>
          <target state="translated">ストップワードファイルで見つからない場合は、小文字の単語の代わりに &lt;code&gt;NULL&lt;/code&gt; を返すこともできます。この動作は、ディクショナリの &lt;code&gt;Accept&lt;/code&gt; パラメータを &lt;code&gt;false&lt;/code&gt; に設定することによって選択されます。例を続ける：</target>
        </trans-unit>
        <trans-unit id="dfd312f5fc4d67101d851237062bdba159c0ec59" translate="yes" xml:space="preserve">
          <source>We can also join a table against itself. This is called a &lt;em&gt;self join&lt;/em&gt;. As an example, suppose we wish to find all the weather records that are in the temperature range of other weather records. So we need to compare the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of each &lt;code&gt;weather&lt;/code&gt; row to the &lt;code&gt;temp_lo&lt;/code&gt; and &lt;code&gt;temp_hi&lt;/code&gt; columns of all other &lt;code&gt;weather&lt;/code&gt; rows. We can do this with the following query:</source>
          <target state="translated">自分自身に対してテーブルを結合することもできます。これは&lt;em&gt;自己結合&lt;/em&gt;と呼ばれます。例として、他の気象記録の温度範囲にあるすべての気象記録を検索したいとします。比較する必要があり、我々はそう &lt;code&gt;temp_lo&lt;/code&gt; と &lt;code&gt;temp_hi&lt;/code&gt; それぞれの列 &lt;code&gt;weather&lt;/code&gt; に行を &lt;code&gt;temp_lo&lt;/code&gt; と &lt;code&gt;temp_hi&lt;/code&gt; 他のすべての列 &lt;code&gt;weather&lt;/code&gt; 行。これは、次のクエリで実行できます。</target>
        </trans-unit>
        <trans-unit id="4dc6beb3b0e1bef62d183184143ea3d3ef810b4c" translate="yes" xml:space="preserve">
          <source>We can change the rewriting rules just by updating the table:</source>
          <target state="translated">テーブルを更新するだけで書き換えルールを変更することができます。</target>
        </trans-unit>
        <trans-unit id="ee2618785314089b8d336377e9a207db9405d3b4" translate="yes" xml:space="preserve">
          <source>We can create a GIN index (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;) to speed up text searches:</source>
          <target state="translated">GINインデックス（&lt;a href=&quot;textsearch-indexes&quot;&gt;セクション12.9&lt;/a&gt;）を作成して、テキスト検索を高速化できます。</target>
        </trans-unit>
        <trans-unit id="c7821bbb704a2ac952eb9690616bfdd424400d47" translate="yes" xml:space="preserve">
          <source>We can do inheritance:</source>
          <target state="translated">相続はできる。</target>
        </trans-unit>
        <trans-unit id="d91685339d290a8a5e3f0243e992defd515e095f" translate="yes" xml:space="preserve">
          <source>We can then see that an administrator connecting over a network will not see any records, due to the restrictive policy:</source>
          <target state="translated">そして、ネットワーク上に接続している管理者は、制限されたポリシーのために、何の記録も表示されないことがわかります。</target>
        </trans-unit>
        <trans-unit id="9e7ee16addc76bca0dc0a634456700165327da1e" translate="yes" xml:space="preserve">
          <source>We can update an individual subfield of a composite column:</source>
          <target state="translated">複合カラムの個々のサブフィールドを更新することができます。</target>
        </trans-unit>
        <trans-unit id="dbaecdebc4248cd30d99181acc6ee4648ce55281" translate="yes" xml:space="preserve">
          <source>We choose not to index or search some token types that the built-in configuration does handle:</source>
          <target state="translated">組み込みの設定で処理できるいくつかのトークン型をインデックス化したり検索したりしないようにしています。</target>
        </trans-unit>
        <trans-unit id="f68910847b8b293ecced82107bbdb7c9e86be5f0" translate="yes" xml:space="preserve">
          <source>We could also have written:</source>
          <target state="translated">書くこともできました。</target>
        </trans-unit>
        <trans-unit id="1af074a97ee1433a54eef949ce0f504465ee61b0" translate="yes" xml:space="preserve">
          <source>We could simplify this by creating a SQL function that inserts a label at a specified position in a path:</source>
          <target state="translated">パス内の指定した位置にラベルを挿入する SQL 関数を作成することで、これを単純化することができます。</target>
        </trans-unit>
        <trans-unit id="10ed1bedde4f0b0f00a9838d665bf3bd179f0836" translate="yes" xml:space="preserve">
          <source>We define the synonym dictionary like this:</source>
          <target state="translated">類義語辞典をこのように定義しています。</target>
        </trans-unit>
        <trans-unit id="d488cdbcb41070244eeea7399c07a12ab608b66e" translate="yes" xml:space="preserve">
          <source>We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just tar or a similar archiving tool.</source>
          <target state="translated">出発点として完全に一貫したファイルシステムのバックアップは必要ありません。バックアップの内部的な不整合はログ再生によって修正されます(これはクラッシュリカバリー中に起こることと大きな違いはありません)。そのため、ファイルシステムのスナップショット機能は必要ありません。</target>
        </trans-unit>
        <trans-unit id="7d9a8fa7a3f06527b3bcf2908ca8717c376647ee" translate="yes" xml:space="preserve">
          <source>We have already discussed constants in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The following sections discuss the remaining options.</source>
          <target state="translated">定数については、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;セクション4.1.2&lt;/a&gt;ですでに説明しました。以下のセクションでは、残りのオプションについて説明します。</target>
        </trans-unit>
        <trans-unit id="a1ef9ac43045748116a115e49374f363a8ba372f" translate="yes" xml:space="preserve">
          <source>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</source>
          <target state="translated">このテーブルの主な用途は、管理用のオンラインレポートを作成することになるので、ほとんどのクエリは先週、月、四半期のデータだけにアクセスすることがわかっています。保存する必要のある古いデータの量を減らすために、直近の3年分のデータのみを保存することにしました。各月の初めに、古い月のデータを削除します。このような状況では、パーティショニングを使用することで、測定表に対するさまざまな要件をすべて満たすことができます。</target>
        </trans-unit>
        <trans-unit id="8a993aca05617d8df040114000bd6876b7a6bbb8" translate="yes" xml:space="preserve">
          <source>We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options:</source>
          <target state="translated">外部キーは、どの商品にも関連しない注文の作成を禁止していることは知っています。しかし、商品を参照する注文が作成された後に商品が削除された場合はどうでしょうか?SQLでは、そのような場合にも対応することができます。直感的には、いくつかのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="afd1ca25954ba7db5e426cd93dec87fb2f18cad3" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">データが何らかの方法で &lt;code&gt;capitals&lt;/code&gt; テーブルにルーティングされることを期待するかもしれませんが、これは起こりません &lt;code&gt;INSERT&lt;/code&gt; 常に指定されたテーブルに正確に挿入します。場合によっては、ルールを使用して挿入をリダイレクトできます（&lt;a href=&quot;https://www.postgresql.org/docs/12/rules.html&quot;&gt;第40章を&lt;/a&gt;参照）。ただし、 &lt;code&gt;cities&lt;/code&gt; テーブルには列の &lt;code&gt;state&lt;/code&gt; が含まれていないため、上記のケースには役立ちません。そのため、ルールを適用する前にコマンドは拒否されます。</target>
        </trans-unit>
        <trans-unit id="b41ce96b205209d5c52d43184eb3122bcf4d7162" translate="yes" xml:space="preserve">
          <source>We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt;, and so the command will be rejected before the rule can be applied.</source>
          <target state="translated">We might hope that the data would somehow be routed to the &lt;code&gt;capitals&lt;/code&gt; table, but this does not happen: &lt;code&gt;INSERT&lt;/code&gt; always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules.html&quot;&gt;Chapter 40&lt;/a&gt;). However that does not help for the above case because the &lt;code&gt;cities&lt;/code&gt; table does not contain the column &lt;code&gt;state&lt;/code&gt; , and so the command will be rejected before the rule can be applied.</target>
        </trans-unit>
        <trans-unit id="668bafcded25fc8a525c39fc8ba11f8e8e98aa03" translate="yes" xml:space="preserve">
          <source>We might want to insert data and have the server automatically locate the child table into which the row should be added. We could do this with a more complex trigger function, for example:</source>
          <target state="translated">データを挿入して、行を追加すべき子テーブルをサーバが自動的に見つけてくれるようにしたいかもしれません。これは、例えば、より複雑なトリガー関数を使って行うことができます。</target>
        </trans-unit>
        <trans-unit id="1aa4d9dcdf43d5b53cef629cb08b1cf507249faa" translate="yes" xml:space="preserve">
          <source>We must redefine the trigger function each month so that it always points to the current child table. The trigger definition does not need to be updated, however.</source>
          <target state="translated">常に現在の子テーブルを指すように、毎月トリガー関数を再定義する必要があります。しかし、トリガ定義は更新する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1597c32eb07ab6cca066ebab3e65392f57896307" translate="yes" xml:space="preserve">
          <source>We recommend that active production databases be vacuumed frequently (at least nightly), in order to remove dead rows. After adding or deleting a large number of rows, it might be a good idea to issue a &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; command for the affected table. This will update the system catalogs with the results of all recent changes, and allow the PostgreSQL query planner to make better choices in planning queries.</source>
          <target state="translated">デッド行を削除するために、アクティブな本番データベースを頻繁に（少なくとも毎晩）バキュームすることをお勧めします。多数の行を追加または削除した後、影響を受けるテーブルに対して &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; コマンドを発行することをお勧めします。これにより、すべての最近の変更の結果でシステムカタログが更新され、PostgreSQLクエリプランナーがクエリの計画においてより適切な選択を行えるようになります。</target>
        </trans-unit>
        <trans-unit id="4e67abf5ade818ba6d22ea4bc6d74fa648515393" translate="yes" xml:space="preserve">
          <source>We reject the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command across the board, because any module loaded could easily circumvent security policy enforcement.</source>
          <target state="translated">読み込まれたモジュールはセキュリティポリシーの適用を簡単に回避できるため、&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;コマンドは全面的に拒否されます。</target>
        </trans-unit>
        <trans-unit id="977603731abefa85626583cf9841c1f7f86bb5c7" translate="yes" xml:space="preserve">
          <source>We require the index access method to apply these tests itself, which means that it must reach into the heap to check the commit status of any row that is shown to have a duplicate key according to the index contents. This is without a doubt ugly and non-modular, but it saves redundant work: if we did a separate probe then the index lookup for a conflicting row would be essentially repeated while finding the place to insert the new row's index entry. What's more, there is no obvious way to avoid race conditions unless the conflict check is an integral part of insertion of the new index entry.</source>
          <target state="translated">つまり、インデックスの内容に応じてキーが重複していると示された行のコミット状態をチェックするためにヒープに到達しなければならないということです。これは間違いなく醜くて非モダリティですが、冗長な作業を省くことができます。もし別のプローブを行った場合、競合する行のインデックス検索は、新しい行のインデックスエントリを挿入する場所を探しながら本質的に繰り返されることになります。さらに、競合チェックが新しいインデックスエントリの挿入に不可欠な部分でない限り、競合状態を回避する明白な方法はありません。</target>
        </trans-unit>
        <trans-unit id="61809ffaa1e9bec3b74e00f63e536c6b27a9b1ac" translate="yes" xml:space="preserve">
          <source>We say that in this situation the orders table is the &lt;em&gt;referencing&lt;/em&gt; table and the products table is the &lt;em&gt;referenced&lt;/em&gt; table. Similarly, there are referencing and referenced columns.</source>
          <target state="translated">私たちは、この状況での受注テーブルがあると言う&lt;em&gt;参照元の&lt;/em&gt;テーブルと製品テーブルがある&lt;em&gt;参照先&lt;/em&gt;テーブル。同様に、参照列と参照列があります。</target>
        </trans-unit>
        <trans-unit id="926fa8d618ecd63d98d203881339877369fb9e8a" translate="yes" xml:space="preserve">
          <source>We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. (PostgreSQL doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as:</source>
          <target state="translated">最初の2つの制約は列制約であるのに対し、3番目の制約は任意の1つの列の定義とは別に書かれているため、テーブル制約であると言っています。カラム制約はテーブル制約としても書くことができますが、逆は必ずしも可能ではありません。(PostgreSQLはこの規則を強制していませんが、テーブル定義を他のデータベースシステムで動作させたい場合は、この規則に従うべきです)。上の例は次のように書くこともできます。</target>
        </trans-unit>
        <trans-unit id="61ad12c01cac6b9fd7b6ff658816ff5bf8b904a2" translate="yes" xml:space="preserve">
          <source>We store these documents in a table named &lt;code&gt;api&lt;/code&gt;, in a &lt;code&gt;jsonb&lt;/code&gt; column named &lt;code&gt;jdoc&lt;/code&gt;. If a GIN index is created on this column, queries like the following can make use of the index:</source>
          <target state="translated">これらのドキュメントを、 &lt;code&gt;api&lt;/code&gt; という名前のテーブルの &lt;code&gt;jsonb&lt;/code&gt; という名前の &lt;code&gt;jdoc&lt;/code&gt; 列に格納します。この列にGINインデックスが作成されている場合、次のようなクエリでインデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="c00287a4e7374c9957df5b25550d2f8b5bf2d466" translate="yes" xml:space="preserve">
          <source>We use the following terms below: The &lt;em&gt;precision&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The &lt;em&gt;scale&lt;/em&gt; of a &lt;code&gt;numeric&lt;/code&gt; is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.</source>
          <target state="translated">以下の用語を使用します。 &lt;code&gt;numeric&lt;/code&gt; の&lt;em&gt;精度&lt;/em&gt;は、整数の有効桁の総数、つまり、小数点の両側の桁数です。 &lt;code&gt;numeric&lt;/code&gt; の&lt;em&gt;位取り&lt;/em&gt;は、小数点の右側の小数部分の小数点の数です。したがって、数値23.5141の精度は6で、スケールは4です。整数は、スケールがゼロであると見なすことができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c61d0c97e5f7c008c140e2ad3c2ca5a1fbcdb590" translate="yes" xml:space="preserve">
          <source>We use the non-partitioned &lt;code&gt;measurement&lt;/code&gt; table above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">We use the non-partitioned &lt;code&gt;measurement&lt;/code&gt; table above. To implement partitioning using inheritance, use the following steps:</target>
        </trans-unit>
        <trans-unit id="a22e103a166cab5bebeb6c6bf8216ec0f41d1ce6" translate="yes" xml:space="preserve">
          <source>We use the same &lt;code&gt;measurement&lt;/code&gt; table we used above. To implement partitioning using inheritance, use the following steps:</source>
          <target state="translated">上記と同じ &lt;code&gt;measurement&lt;/code&gt; テーブルを使用します。継承を使用してパーティションを実装するには、次の手順を使用します。</target>
        </trans-unit>
        <trans-unit id="87bb5356e299e65f3820ac3133d7b4e088f6bde2" translate="yes" xml:space="preserve">
          <source>We use the word &lt;em&gt;item&lt;/em&gt; to refer to a composite value that is to be indexed, and the word &lt;em&gt;key&lt;/em&gt; to refer to an element value. GIN always stores and searches for keys, not item values per se.</source>
          <target state="translated">索引付けされる複合値を参照するには&lt;em&gt;item&lt;/em&gt;という単語を使用し、要素の値を参照するには&lt;em&gt;key&lt;/em&gt;という単語を使用します。GINは常にアイテムの値自体ではなく、キーを保存して検索します。</target>
        </trans-unit>
        <trans-unit id="aaac10448fb5e7278bf16580755bd9621bfb54f1" translate="yes" xml:space="preserve">
          <source>We want our application to be able to say &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; and have the data be redirected into the appropriate child table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest child, we can use a very simple trigger function:</source>
          <target state="translated">アプリケーションで &lt;code&gt;INSERT INTO measurement ...&lt;/code&gt; を使用して、適切な子テーブルにデータをリダイレクトできるようにしたいと考えています。マスターテーブルに適切なトリガー関数を追加することで、それを調整できます。最新の子にのみデータが追加される場合は、非常に単純なトリガー関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="cdc05935dfdf1c41e4dbff177f8b502be331c045" translate="yes" xml:space="preserve">
          <source>We will use a PostgreSQL-specific synonym list and store it in &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt;. The file contents look like:</source>
          <target state="translated">PostgreSQL固有の同義語リストを使用して、それを &lt;code&gt;$SHAREDIR/tsearch_data/pg_dict.syn&lt;/code&gt; ます。ファイルの内容は次のようになります。</target>
        </trans-unit>
        <trans-unit id="963adbfe40be253cf091e436ca27447ef3a470bc" translate="yes" xml:space="preserve">
          <source>Wed, Weds</source>
          <target state="translated">水、水</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="fdeddc33f6adb1db2fc6d6142f8a57019f70774f" translate="yes" xml:space="preserve">
          <source>Weights are typically used to reflect document structure, for example by marking title words differently from body words. Text search ranking functions can assign different priorities to the different weight markers.</source>
          <target state="translated">重みは一般的に文書構造を反映させるために使用され、例えば、タイトル語と本文語とを区別してマークすることである。テキスト検索ランキング機能は、異なる重みマーカーに異なる優先順位を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="683c9370be61bfcd03e58355d7c86c6e1369d2d9" translate="yes" xml:space="preserve">
          <source>Western European</source>
          <target state="translated">西欧人</target>
        </trans-unit>
        <trans-unit id="e82bc7cf6e54b2e4257e788dff104c1e42da4e0b" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?</source>
          <target state="translated">JITコンパイルとは?</target>
        </trans-unit>
        <trans-unit id="9d446878c466219c122696ab7b32c54ff789d87e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Inlining</source>
          <target state="translated">JITコンパイルとは?インライン化</target>
        </trans-unit>
        <trans-unit id="ca44cc7300ef1dcac2b672637a01e3b0a0da90f7" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: JIT Accelerated Operations</source>
          <target state="translated">JITコンパイルとは?JIT加速化された運用</target>
        </trans-unit>
        <trans-unit id="760d95b57cc4647ff2722b6cf5ee7f34082cc25e" translate="yes" xml:space="preserve">
          <source>What Is JIT compilation?: Optimization</source>
          <target state="translated">JITコンパイルとは?最適化</target>
        </trans-unit>
        <trans-unit id="6026d88e883e805146a8bbfee4583738ccfd77d8" translate="yes" xml:space="preserve">
          <source>What Is the &amp;ldquo;Transaction&amp;rdquo; Actually Performed in pgbench?</source>
          <target state="translated">pgbenchで実際に実行される「トランザクション」とは何ですか？</target>
        </trans-unit>
        <trans-unit id="6c8a97eccbb7e55f60d7659738855ee30c65e97d" translate="yes" xml:space="preserve">
          <source>What has really happened here is that the two unknown literals are resolved to &lt;code&gt;text&lt;/code&gt; by default, allowing the &lt;code&gt;||&lt;/code&gt; operator to be resolved as &lt;code&gt;text&lt;/code&gt; concatenation. Then the &lt;code&gt;text&lt;/code&gt; result of the operator is converted to &lt;code&gt;bpchar&lt;/code&gt; (&amp;ldquo;blank-padded char&amp;rdquo;, the internal name of the &lt;code&gt;character&lt;/code&gt; data type) to match the target column type. (Since the conversion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;bpchar&lt;/code&gt; is binary-coercible, this conversion does not insert any real function call.) Finally, the sizing function &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; is found in the system catalog and applied to the operator's result and the stored column length. This type-specific function performs the required length check and addition of padding spaces.</source>
          <target state="translated">ここで実際に起こったことは、2つの不明なリテラルがデフォルトで &lt;code&gt;text&lt;/code&gt; 解決され、 &lt;code&gt;||&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; 連結として解決される演算子。次に、演算子の &lt;code&gt;text&lt;/code&gt; 結果が &lt;code&gt;bpchar&lt;/code&gt; （「空白で埋め込まれたchar」、 &lt;code&gt;character&lt;/code&gt; データ型の内部名）に変換され、ターゲット列の型と一致します。 （ &lt;code&gt;text&lt;/code&gt; から &lt;code&gt;bpchar&lt;/code&gt; への変換はバイナリ強制可能であるため、この変換では実際の関数呼び出しは挿入されません。）最後に、サイジング関数 &lt;code&gt;bpchar(bpchar, integer, boolean)&lt;/code&gt; システムカタログで見つかり、演算子の結果と格納されている列の長さに適用されます。このタイプ固有の関数は、必要な長さのチェックとパディングスペースの追加を実行します。</target>
        </trans-unit>
        <trans-unit id="dfcede4e6134968fca6be5ab22337a4021df7d2f" translate="yes" xml:space="preserve">
          <source>What is a &amp;ldquo;system user&amp;rdquo; is determined at systemd compile time from the &lt;code&gt;SYS_UID_MAX&lt;/code&gt; setting in &lt;code&gt;/etc/login.defs&lt;/code&gt;.</source>
          <target state="translated">「システムユーザー」とは、systemdのコンパイル時に &lt;code&gt;/etc/login.defs&lt;/code&gt; の &lt;code&gt;SYS_UID_MAX&lt;/code&gt; 設定から決定されます。</target>
        </trans-unit>
        <trans-unit id="c3b062bdc5b358d8bc1d0ea5b87500675ecf488c" translate="yes" xml:space="preserve">
          <source>What is essentially happening here is a join between &lt;code&gt;films&lt;/code&gt; and &lt;code&gt;producers&lt;/code&gt;, with all successfully joined &lt;code&gt;films&lt;/code&gt; rows being marked for deletion. This syntax is not standard. A more standard way to do it is:</source>
          <target state="translated">ここで本質的に起こっていることは、 &lt;code&gt;films&lt;/code&gt; と &lt;code&gt;producers&lt;/code&gt; 間の結合であり、結合に成功したすべての &lt;code&gt;films&lt;/code&gt; 行に削除のマークが付けられます。この構文は標準ではありません。それを行うためのより標準的な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e6eec3dfd99f17e2a6e53d2f854ed352bd2c2826" translate="yes" xml:space="preserve">
          <source>What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command &lt;code&gt;locale -a&lt;/code&gt; will provide a list of available locales. Windows uses more verbose locale names, such as &lt;code&gt;German_Germany&lt;/code&gt; or &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt;, but the principles are the same.</source>
          <target state="translated">システムで使用できるロケールは、オペレーティングシステムベンダーから提供されたものと、インストールされたものによって異なります。ほとんどのUnixシステムでは、コマンド &lt;code&gt;locale -a&lt;/code&gt; を使用すると、使用可能なロケールのリストが表示されます。 Windowsは、 &lt;code&gt;German_Germany&lt;/code&gt; や &lt;code&gt;Swedish_Sweden.1252&lt;/code&gt; などのより詳細なロケール名を使用しますが、原則は同じです。</target>
        </trans-unit>
        <trans-unit id="40680439c20fb6866bd543023ba55a7dbd37c92b" translate="yes" xml:space="preserve">
          <source>What this does is to record the links created by pg_upgrade's link mode that connect files in the old and new clusters on the primary server. It then finds matching files in the standby's old cluster and creates links for them in the standby's new cluster. Files that were not linked on the primary are copied from the primary to the standby. (They are usually small.) This provides rapid standby upgrades. Unfortunately, rsync needlessly copies files associated with temporary and unlogged tables because these files don't normally exist on standby servers.</source>
          <target state="translated">これは、プライマリサーバ上の新旧クラスタ内のファイルを接続するpg_upgradeのリンクモードによって作成されたリンクを記録することです。そして、スタンバイの古いクラスタ内で一致するファイルを見つけ、スタンバイの新しいクラスタ内にそれらのファイルへのリンクを作成します。プライマリ上でリンクされていなかったファイルは、プライマリからスタンバイにコピーされます。(それらは通常小さなものです。)これにより、スタンバイの迅速なアップグレードが可能になります。残念なことに、一時的なテーブルやログされていないテーブルに関連するファイルは通常スタンバイサーバには存在しないので、rsync は不必要にコピーしてしまいます。</target>
        </trans-unit>
        <trans-unit id="a446c8d9e480b9f0f6cbcd76fef7e2bcda6c700b" translate="yes" xml:space="preserve">
          <source>What's more, when you load data into a table with existing foreign key constraints, each new row requires an entry in the server's list of pending trigger events (since it is the firing of a trigger that checks the row's foreign key constraint). Loading many millions of rows can cause the trigger event queue to overflow available memory, leading to intolerable swapping or even outright failure of the command. Therefore it may be &lt;em&gt;necessary&lt;/em&gt;, not just desirable, to drop and re-apply foreign keys when loading large amounts of data. If temporarily removing the constraint isn't acceptable, the only other recourse may be to split up the load operation into smaller transactions.</source>
          <target state="translated">さらに、既存の外部キー制約があるテーブルにデータをロードする場合、新しい行ごとに、サーバーの保留中のトリガーイベントのリストにエントリが必要です（行の外部キー制約をチェックするトリガーの起動であるため）。何百万もの行をロードすると、トリガーイベントキューが使用可能なメモリをオーバーフローし、許容できないスワッピングまたはコマンドの完全な失敗につながる可能性があります。したがって、大量のデータをロードする場合、外部キーを削除して再適用することが望ましいだけでなく、&lt;em&gt;必要&lt;/em&gt;になる場合があります。一時的な制約の削除が受け入れられない場合、他の唯一の手段は、ロード操作をより小さなトランザクションに分割することです。</target>
        </trans-unit>
        <trans-unit id="f0604f8d2119324fb427a16a8668c529701bc1a2" translate="yes" xml:space="preserve">
          <source>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, PostgreSQL will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding &lt;code&gt;CASCADE&lt;/code&gt;:</source>
          <target state="translated">列にあったデータはすべて消えます。列を含むテーブル制約も削除されます。ただし、列が別のテーブルの外部キー制約によって参照されている場合、PostgreSQLはその制約を暗黙的に削除しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加することで、列に依存するすべてのものを削除することを承認できます。</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="a60fe559ad2643627bd47ea3eceb6f63037101eb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt; is set, this parameter also determines the amount of time to wait before a log message is issued about the lock wait. If you are trying to investigate locking delays you might want to set a shorter than normal &lt;code&gt;deadlock_timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-logging#GUC-LOG-LOCK-WAITS&quot;&gt;log_lock_waits&lt;/a&gt;が設定されている場合、このパラメーターは、ロック待機に関するログメッセージが発行されるまでの待機時間も決定します。ロックの遅延を調査する場合は、通常よりも短い &lt;code&gt;deadlock_timeout&lt;/code&gt; を設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="48421d6240bf9ea87a63b5a2373cb0ad9cf5cd58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--include-foreign-data&lt;/code&gt; is specified, pg_dump does not check that the foreign table is writable. Therefore, there is no guarantee that the results of a foreign table dump can be successfully restored.</source>
          <target state="translated">When &lt;code&gt;--include-foreign-data&lt;/code&gt; is specified, pg_dump does not check that the foreign table is writable. Therefore, there is no guarantee that the results of a foreign table dump can be successfully restored.</target>
        </trans-unit>
        <trans-unit id="57e37b6a94a28e9acbd6287be1d60c38f8541fd8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">とき &lt;code&gt;--source-server&lt;/code&gt; オプションが使用されている、pg_rewindもlibpqでサポートされる環境変数を使用しています（参照&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-envars.html&quot;&gt;セクション33.14を&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2797c2b01f0d49dcbbe6a48419d9e0d238c086dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</source>
          <target state="translated">When &lt;code&gt;--source-server&lt;/code&gt; option is used, pg_rewind also uses the environment variables supported by libpq (see &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-envars.html&quot;&gt;Section 33.14&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="1854281aa73e4f5b1f721e95b9f05123b0ade134" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-n&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected schema(s) might depend upon. Therefore, there is no guarantee that the results of a specific-schema dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; が指定されている場合、pg_dumpは、選択されたスキーマが依存している可能性のある他のデータベースオブジェクトをダンプしようとしません。したがって、特定のスキーマのダンプの結果を、それ自体で正常なデータベースに正常に復元できるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="5fef81c501efe3e088f4b73c9a697af2561cb6dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_dump makes no attempt to dump any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that the results of a specific-table dump can be successfully restored by themselves into a clean database.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; が指定されている場合、pg_dumpは、選択されたテーブルが依存する可能性のある他のデータベースオブジェクトをダンプしようとしません。したがって、特定のテーブルのダンプの結果をクリーンなデータベースに正常に復元できるという保証はありません。</target>
        </trans-unit>
        <trans-unit id="8c86589858bd9989813c8435013ddbc1a41c69f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-t&lt;/code&gt; is specified, pg_restore makes no attempt to restore any other database objects that the selected table(s) might depend upon. Therefore, there is no guarantee that a specific-table restore into a clean database will succeed.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; が指定されている場合、pg_restoreは、選択されたテーブルが依存する可能性のある他のデータベースオブジェクトの復元を試みません。したがって、クリーンなデータベースへの特定のテーブルの復元が成功する保証はありません。</target>
        </trans-unit>
        <trans-unit id="6dd3feb588f68391e70d37037327ad64b7721fd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ALTER&lt;/code&gt; command is executed, &lt;code&gt;setattr&lt;/code&gt; will be checked on the object being modified for each object types, except for subsidiary objects such as the indexes or triggers of a table, where permissions are instead checked on the parent object. In some cases, additional permissions are required:</source>
          <target state="translated">場合 &lt;code&gt;ALTER&lt;/code&gt; のコマンドが実行され、 &lt;code&gt;setattr&lt;/code&gt; 子会社は、そのような権限はなく、親オブジェクトでチェックされるテーブルのインデックスまたはトリガなどのオブジェクトを除いて、各オブジェクトタイプに変更されたオブジェクトにチェックされます。場合によっては、追加の権限が必要です。</target>
        </trans-unit>
        <trans-unit id="95ea06756271ccb08739b45bacb4e5cf14e003e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE INDEX&lt;/code&gt; is invoked on a partitioned table, the default behavior is to recurse to all partitions to ensure they all have matching indexes. Each partition is first checked to determine whether an equivalent index already exists, and if so, that index will become attached as a partition index to the index being created, which will become its parent index. If no matching index exists, a new index will be created and automatically attached; the name of the new index in each partition will be determined as if no index name had been specified in the command. If the &lt;code&gt;ONLY&lt;/code&gt; option is specified, no recursion is done, and the index is marked invalid. (&lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; marks the index valid, once all partitions acquire matching indexes.) Note, however, that any partition that is created in the future using &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; will automatically have a matching index, regardless of whether &lt;code&gt;ONLY&lt;/code&gt; is specified.</source>
          <target state="translated">場合は &lt;code&gt;CREATE INDEX&lt;/code&gt; パーティションテーブルの上に呼び出され、デフォルトの動作では、彼らはすべての一致するインデックスを持っていることを確認するために、すべてのパーティションに再帰することです。最初に各パーティションがチェックされ、同等のインデックスが既に存在するかどうかが判断されます。存在する場合、そのインデックスはパーティションインデックスとして作成されるインデックスにアタッチされ、そのインデックスが親インデックスになります。一致するインデックスが存在しない場合、新しいインデックスが作成され、自動的にアタッチされます。各パーティションの新しいインデックスの名前は、コマンドでインデックス名が指定されていないかのように決定されます。 &lt;code&gt;ONLY&lt;/code&gt; オプションが指定されている場合、再帰は行われず、インデックスは無効とマークされます。 （ &lt;code&gt;ALTER INDEX ... ATTACH PARTITION&lt;/code&gt; すべてのパーティションが一致するインデックスを取得すると、インデックスは有効とマークされます。）ただし、 &lt;code&gt;CREATE TABLE ... PARTITION OF&lt;/code&gt; を使用して将来作成されるパーティションは、 &lt;code&gt;ONLY&lt;/code&gt; が指定されているかどうかに関係なく、自動的に一致するインデックスを持ちます。</target>
        </trans-unit>
        <trans-unit id="0c15e2e86d36f47a57239a8f802301f2d222dbb6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; is used to replace an existing function, the ownership and permissions of the function do not change. All other function properties are assigned the values specified or implied in the command. You must own the function to replace it (this includes being a member of the owning role).</source>
          <target state="translated">場合は &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 既存の関数を置き換えるために使用され、機能の所有権とアクセス権は変更されません。他のすべての関数プロパティには、コマンドで指定または暗示されている値が割り当てられます。これを置き換えるには、関数を所有している必要があります（これには、所有ロールのメンバーであることも含まれます）。</target>
        </trans-unit>
        <trans-unit id="db55d63efcb8b5298291fde068a29837b503dfcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; is used to replace an existing procedure, the ownership and permissions of the procedure do not change. All other procedure properties are assigned the values specified or implied in the command. You must own the procedure to replace it (this includes being a member of the owning role).</source>
          <target state="translated">場合は &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; 既存のプロシージャを置き換えるために使用され、手続きの所有権とアクセス権は変更されません。他のすべてのプロシージャプロパティには、コマンドで指定または暗示されている値が割り当てられます。これを置き換えるには、プロシージャを所有している必要があります（これには、所有するロールのメンバーであることも含まれます）。</target>
        </trans-unit>
        <trans-unit id="11b7e02139c0fd56fa0d0c0d7e02cacf1863b7dd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; is used on an existing view, only the view's defining SELECT rule is changed. Other view properties, including ownership, permissions, and non-SELECT rules, remain unchanged. You must own the view to replace it (this includes being a member of the owning role).</source>
          <target state="translated">場合は &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; 既存のビューで使用されている、唯一のビューの定義SELECTルールが変更されます。所有権、権限、非SELECTルールなど、他のビュープロパティは変更されません。ビューを置き換えるには、ビューを所有している必要があります（これには、所有ロールのメンバーであることも含まれます）。</target>
        </trans-unit>
        <trans-unit id="b2b68d33a4076adb362da4bb710ac3317fb09cf8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DROP&lt;/code&gt; command is executed, &lt;code&gt;drop&lt;/code&gt; will be checked on the object being removed. Permissions will be also checked for objects dropped indirectly via &lt;code&gt;CASCADE&lt;/code&gt;. Deletion of objects contained within a particular schema (tables, views, sequences and procedures) additionally requires &lt;code&gt;remove_name&lt;/code&gt; on the schema.</source>
          <target state="translated">ときに &lt;code&gt;DROP&lt;/code&gt; のコマンドが実行され、 &lt;code&gt;drop&lt;/code&gt; 削除されたオブジェクトにチェックされます。 &lt;code&gt;CASCADE&lt;/code&gt; を介して間接的に削除されたオブジェクトのアクセス許可もチェックされます。特定のスキーマ（テーブル、ビュー、シーケンス、およびプロシージャ）に含まれるオブジェクトを削除するには、さらにスキーマに &lt;code&gt;remove_name&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="f47c9d6dc4a8942d1dd522d4978fe59346f8ad48" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GROUP BY&lt;/code&gt; is present, or any aggregate functions are present, it is not valid for the &lt;code&gt;SELECT&lt;/code&gt; list expressions to refer to ungrouped columns except within aggregate functions or when the ungrouped column is functionally dependent on the grouped columns, since there would otherwise be more than one possible value to return for an ungrouped column. A functional dependency exists if the grouped columns (or a subset thereof) are the primary key of the table containing the ungrouped column.</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; が存在する場合、または集約関数が存在する場合、集約関数内、またはグループ化されていない列がグループ化された列に機能的に依存している場合を除いて、 &lt;code&gt;SELECT&lt;/code&gt; リスト式がグループ化されていない列を参照することは無効です。グループ化されていない列に対して返す可能性のある1つの値よりも多くなります。グループ化された列（またはそのサブセット）が、グループ化されていない列を含むテーブルの主キーである場合、機能的な依存関係が存在します。</target>
        </trans-unit>
        <trans-unit id="a61a8feeb668ae119fbcd691b6fc8464f954d0c9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NOTIFY&lt;/code&gt; is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the &lt;code&gt;NOTIFY&lt;/code&gt; in a statement trigger that is triggered by table updates. In this way, notification happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; を使用して特定のテーブルへの変更の発生を通知する場合、有用なプログラミング手法は、テーブルの更新によってトリガーされるステートメントトリガーに &lt;code&gt;NOTIFY&lt;/code&gt; を配置することです。このようにして、テーブルが変更されると通知が自動的に行われ、アプリケーションプログラマが誤ってそれを忘れることはありません。</target>
        </trans-unit>
        <trans-unit id="693b980fbbb477839ff0fa0e6f6f64c259b4b463" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt; ; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</target>
        </trans-unit>
        <trans-unit id="96d946d891d853517e02080ffe41ee5e79e55c40" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;RESTART IDENTITY&lt;/code&gt; is specified, the implied &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; operations are also done transactionally; that is, they will be rolled back if the surrounding transaction does not commit. This is unlike the normal behavior of &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt;. Be aware that if any additional sequence operations are done on the restarted sequences before the transaction rolls back, the effects of these operations on the sequences will be rolled back, but not their effects on &lt;code&gt;currval()&lt;/code&gt;; that is, after the transaction &lt;code&gt;currval()&lt;/code&gt; will continue to reflect the last sequence value obtained inside the failed transaction, even though the sequence itself may no longer be consistent with that. This is similar to the usual behavior of &lt;code&gt;currval()&lt;/code&gt; after a failed transaction.</source>
          <target state="translated">場合 &lt;code&gt;RESTART IDENTITY&lt;/code&gt; が指定され、黙示 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; の動作もトランザクション行われます。つまり、周囲のトランザクションがコミットしない場合は、ロールバックされます。これは、 &lt;code&gt;ALTER SEQUENCE RESTART&lt;/code&gt; の通常の動作とは異なります。トランザクションがロールバックされる前に、再起動されたシーケンスで追加のシーケンス操作が行われた場合、これらの操作のシーケンスへの影響はロールバックされますが、 &lt;code&gt;currval()&lt;/code&gt; への影響はロールバックされません。つまり、トランザクション &lt;code&gt;currval()&lt;/code&gt; の後シーケンス自体がそれと一致しなくなったとしても、失敗したトランザクション内で取得された最後のシーケンス値を反映し続けます。これは、トランザクションが失敗した後の &lt;code&gt;currval()&lt;/code&gt; の通常の動作に似ています。</target>
        </trans-unit>
        <trans-unit id="1dd38b054f6c38892cf4b53376368a92afaa9614" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; changes the mode of a constraint from &lt;code&gt;DEFERRED&lt;/code&gt; to &lt;code&gt;IMMEDIATE&lt;/code&gt;, the new mode takes effect retroactively: any outstanding data modifications that would have been checked at the end of the transaction are instead checked during the execution of the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; command. If any such constraint is violated, the &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; fails (and does not change the constraint mode). Thus, &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; can be used to force checking of constraints to occur at a specific point in a transaction.</source>
          <target state="translated">ときに &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; からの制約のモードを変更 &lt;code&gt;DEFERRED&lt;/code&gt; に &lt;code&gt;IMMEDIATE&lt;/code&gt; 、新しいモードが遡及的に有効になります。トランザクションの終了時にチェックされていた未処理のデータ変更が代わりに実行時にチェックされ &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; コマンド。このような制約に違反すると、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; は失敗します（制約モードは変更されません）。したがって、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; を使用すると、トランザクションの特定のポイントで制約のチェックを強制的に実行できます。</target>
        </trans-unit>
        <trans-unit id="c0b169cb5b7cb17bff71441e629815508752132d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VALUES&lt;/code&gt; is used in &lt;code&gt;INSERT&lt;/code&gt;, the values are all automatically coerced to the data type of the corresponding destination column. When it's used in other contexts, it might be necessary to specify the correct data type. If the entries are all quoted literal constants, coercing the first is sufficient to determine the assumed type for all:</source>
          <target state="translated">ときに &lt;code&gt;VALUES&lt;/code&gt; で使用される &lt;code&gt;INSERT&lt;/code&gt; 、値はすべて自動的に対応する宛先カラムのデータ型に強制されています。他のコンテキストで使用する場合は、正しいデータ型を指定する必要がある場合があります。エントリがすべて引用符で囲まれたリテラル定数の場合、最初のものを強制するだけで、すべての想定される型を特定できます。</target>
        </trans-unit>
        <trans-unit id="45ae9ff8fa95f77c4ea16390adcefafbd4f890d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;ANALYZE&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">場合 &lt;code&gt;VERBOSE&lt;/code&gt; が指定され、 &lt;code&gt;ANALYZE&lt;/code&gt; 発するは、現在処理されているテーブルを示すためのメッセージを進行します。テーブルに関するさまざまな統計も出力されます。</target>
        </trans-unit>
        <trans-unit id="14f1458fcf796362f90bd6b53ff757eaee1e2939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;VERBOSE&lt;/code&gt; is specified, &lt;code&gt;VACUUM&lt;/code&gt; emits progress messages to indicate which table is currently being processed. Various statistics about the tables are printed as well.</source>
          <target state="translated">場合 &lt;code&gt;VERBOSE&lt;/code&gt; が指定されている、 &lt;code&gt;VACUUM&lt;/code&gt; の発するは、現在処理されているテーブルを示すためのメッセージを進行します。テーブルに関するさまざまな統計も出力されます。</target>
        </trans-unit>
        <trans-unit id="f54823d23e5df73c9472414a7a83e6ba082b1ce2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\ef&lt;/code&gt;, or &lt;code&gt;\ev&lt;/code&gt; is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user's editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples:</source>
          <target state="translated">とき &lt;code&gt;\e&lt;/code&gt; 、 &lt;code&gt;\ef&lt;/code&gt; 、または &lt;code&gt;\ev&lt;/code&gt; 行番号の引数とともに使用され、この変数は、コマンドライン引数は、ユーザのエディタに開始行番号を渡すために使用を指定します。 Emacsやviなどのエディターの場合、これはプラス記号です。オプション名と行番号の間にスペースが必要な場合は、変数の値に末尾のスペースを含めます。例：</target>
        </trans-unit>
        <trans-unit id="880bf87755564e46a3f310f5734ab8ac6764465b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;archive_mode&lt;/code&gt; is enabled, completed WAL segments are sent to archive storage by setting &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;archive_command&lt;/a&gt;. In addition to &lt;code&gt;off&lt;/code&gt;, to disable, there are two modes: &lt;code&gt;on&lt;/code&gt;, and &lt;code&gt;always&lt;/code&gt;. During normal operation, there is no difference between the two modes, but when set to &lt;code&gt;always&lt;/code&gt; the WAL archiver is enabled also during archive recovery or standby mode. In &lt;code&gt;always&lt;/code&gt; mode, all files restored from the archive or streamed with streaming replication will be archived (again). See &lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;Section 26.2.9&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;archive_mode&lt;/code&gt; が有効な場合、archive_commandを設定することにより、完了したWALセグメントがアーカイブストレージに送信され&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-COMMAND&quot;&gt;ます&lt;/a&gt;。 &lt;code&gt;off&lt;/code&gt; に加えて、無効にするには、 &lt;code&gt;on&lt;/code&gt; と &lt;code&gt;always&lt;/code&gt; の 2つのモードがあります。通常の操作中、2つのモードの間に違いはありませんが、 &lt;code&gt;always&lt;/code&gt; 設定されている場合、WALアーカイバはアーカイブのリカバリまたはスタンバイモードでも有効になります。で &lt;code&gt;always&lt;/code&gt; モードで、すべてのファイルは、アーカイブから復元または（再）アーカイブされますストリーミングレプリケーションでストリーミング。詳細は&lt;a href=&quot;warm-standby#CONTINUOUS-ARCHIVING-IN-STANDBY&quot;&gt;項26.2.9&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="46cdaf5a9c68bb7dda3e95a7d23c6fce30bcf59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;commit_delay&lt;/code&gt; is set to zero (the default), it is still possible for a form of group commit to occur, but each group will consist only of sessions that reach the point where they need to flush their commit records during the window in which the previous flush operation (if any) is occurring. At higher client counts a &amp;ldquo;gangway effect&amp;rdquo; tends to occur, so that the effects of group commit become significant even when &lt;code&gt;commit_delay&lt;/code&gt; is zero, and thus explicitly setting &lt;code&gt;commit_delay&lt;/code&gt; tends to help less. Setting &lt;code&gt;commit_delay&lt;/code&gt; can only help when (1) there are some concurrently committing transactions, and (2) throughput is limited to some degree by commit rate; but with high rotational latency this setting can be effective in increasing transaction throughput with as few as two clients (that is, a single committing client with one sibling transaction).</source>
          <target state="translated">とき &lt;code&gt;commit_delay&lt;/code&gt; ゼロ（デフォルト）に設定され、グループの形が発生することを約束するために、それはまだ可能ですが、各グループは彼らが窓の間に彼らのコミットレコードをフラッシュする必要がある点に到達するのセッションで構成されます以前のフラッシュ操作（ある場合）が発生しています。クライアント数が多いと「ギャングウェイ効果」が発生する傾向があるため、 &lt;code&gt;commit_delay&lt;/code&gt; がゼロの場合でもグループコミットの効果が大きくなるため、commit_delayを明示的に設定すると &lt;code&gt;commit_delay&lt;/code&gt; が低下する傾向があります。 &lt;code&gt;commit_delay&lt;/code&gt; の設定（1）同時にコミットするトランザクションがいくつかあり、（2）スループットがコミットレートによってある程度制限されている場合にのみ役立ちます。ただし、回転待ち時間が長い場合、この設定は、わずか2つのクライアント（つまり、1つの兄弟トランザクションを持つ単一のコミットクライアント）でトランザクションスループットを向上させるのに効果的です。</target>
        </trans-unit>
        <trans-unit id="639e6544c619e9aa79e7a25d85adc789836438b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;default_tablespace&lt;/code&gt; is set to anything but an empty string, it supplies an implicit &lt;code&gt;TABLESPACE&lt;/code&gt; clause for &lt;code&gt;CREATE TABLE&lt;/code&gt; and &lt;code&gt;CREATE INDEX&lt;/code&gt; commands that do not have an explicit one.</source>
          <target state="translated">とき &lt;code&gt;default_tablespace&lt;/code&gt; 何もなく、空の文字列に設定されている、それは暗黙の供給 &lt;code&gt;TABLESPACE&lt;/code&gt; のための句 &lt;code&gt;CREATE TABLE&lt;/code&gt; と &lt;code&gt;CREATE INDEX&lt;/code&gt; 明示的なものを持っていないコマンドを。</target>
        </trans-unit>
        <trans-unit id="26b9fcc2ea9102afd846d23d5a3d7acf06ea6fcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extractQuery&lt;/code&gt; returns a null key in &lt;code&gt;queryKeys[]&lt;/code&gt;, the corresponding &lt;code&gt;check[]&lt;/code&gt; element is true if the indexed item contains a null key; that is, the semantics of &lt;code&gt;check[]&lt;/code&gt; are like &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt;. The &lt;code&gt;consistent&lt;/code&gt; function can examine the corresponding &lt;code&gt;nullFlags[]&lt;/code&gt; element if it needs to tell the difference between a regular value match and a null match.</source>
          <target state="translated">場合 &lt;code&gt;extractQuery&lt;/code&gt; のがでヌルキー返し &lt;code&gt;queryKeys[]&lt;/code&gt; 、対応する &lt;code&gt;check[]&lt;/code&gt; 要素は、索引項目がヌルキーが含まれている場合も同様です。つまり、 &lt;code&gt;check[]&lt;/code&gt; セマンティクスは &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; のようなものです。 &lt;code&gt;consistent&lt;/code&gt; 機能は、対応する調べることができます &lt;code&gt;nullFlags[]&lt;/code&gt; それは通常の値が一致し、nullマッチの違いを見分ける必要がある場合の要素を。</target>
        </trans-unit>
        <trans-unit id="e521d3acb4576333ab5bee010106dc1a1c2bc018" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">とき &lt;code&gt;geqo_threshold&lt;/code&gt; を超えているで説明したように、考えられて参加シーケンスは、経験則によって決定されている&lt;a href=&quot;https://www.postgresql.org/docs/12/geqo.html&quot;&gt;第59章&lt;/a&gt;。それ以外のプロセスは同じです。</target>
        </trans-unit>
        <trans-unit id="5dc55d7e2d48050cd0f6633337d76448e1d4e69c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</source>
          <target state="translated">When &lt;code&gt;geqo_threshold&lt;/code&gt; is exceeded, the join sequences considered are determined by heuristics, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/geqo.html&quot;&gt;Chapter 59&lt;/a&gt;. Otherwise the process is the same.</target>
        </trans-unit>
        <trans-unit id="d28ef38bf9e5530ece862031c842201d36ddd349" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the directory in which log files will be created. It can be specified as an absolute path, or relative to the cluster data directory. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;log&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは、ログファイルが作成されるディレクトリを決定します。絶対パスまたはクラスターデータディレクトリへの相対パスとして指定できます。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。デフォルトは &lt;code&gt;log&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b3acb8f6d64e7dee8bb588e16430447375cec4a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum amount of time to use an individual log file, after which a new log file will be created. If this value is specified without units, it is taken as minutes. The default is 24 hours. Set to zero to disable time-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは、個々のログファイルを使用する最大時間を決定します。その後、新しいログファイルが作成されます。この値を単位なしで指定した場合、分として扱われます。デフォルトは24時間です。新しいログファイルの時間ベースの作成を無効にするには、ゼロに設定します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="6ba6806c5a61bd0e7df256b20d72936b6dfff344" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter determines the maximum size of an individual log file. After this amount of data has been emitted into a log file, a new log file will be created. If this value is specified without units, it is taken as kilobytes. The default is 10 megabytes. Set to zero to disable size-based creation of new log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは個々のログファイルの最大サイズを決定します。この量のデータがログファイルに出力された後、新しいログファイルが作成されます。この値が単位なしで指定された場合、キロバイトとして扱われます。デフォルトは10メガバイトです。サイズに基づく新しいログファイルの作成を無効にするには、ゼロに設定します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="33d04df6ccc65336486b417a686759bd20169c58" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターは作成されたログファイルのファイル名を設定します。値は &lt;code&gt;strftime&lt;/code&gt; パターンとして扱われるため、 &lt;code&gt;%&lt;/code&gt; - escapesを使用して時変ファイル名を指定できます。 （時間帯に依存する &lt;code&gt;%&lt;/code&gt; -escapesがある場合、計算はlog_timezoneで指定されたゾーンで行われることに&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;注意してください&lt;/a&gt;。）サポートされている &lt;code&gt;%&lt;/code&gt; -escapesは、Open Groupの&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt;仕様にリストされているものと同様です。システムの &lt;code&gt;strftime&lt;/code&gt; は直接使用されないため、プラットフォーム固有（非標準）の拡張は機能しないことに注意してください。デフォルトは &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="de9428c551b8b57c64cfa71598ced7921a3ab10e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt;-escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt;-escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt;-escapes are similar to those listed in the Open Group's &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt;.</source>
          <target state="translated">When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter sets the file names of the created log files. The value is treated as a &lt;code&gt;strftime&lt;/code&gt; pattern, so &lt;code&gt;%&lt;/code&gt; -escapes can be used to specify time-varying file names. (Note that if there are any time-zone-dependent &lt;code&gt;%&lt;/code&gt; -escapes, the computation is done in the zone specified by &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;.) The supported &lt;code&gt;%&lt;/code&gt; -escapes are similar to those listed in the Open Group's &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&quot;&gt;strftime&lt;/a&gt; specification. Note that the system's &lt;code&gt;strftime&lt;/code&gt; is not used directly, so platform-specific (nonstandard) extensions do not work. The default is &lt;code&gt;postgresql-%Y-%m-%d_%H%M%S.log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="912a8bc2db1f94954749b8b7569bc346c69e11ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logging_collector&lt;/code&gt; is enabled, this parameter will cause PostgreSQL to truncate (overwrite), rather than append to, any existing log file of the same name. However, truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation. When off, pre-existing files will be appended to in all cases. For example, using this setting in combination with a &lt;code&gt;log_filename&lt;/code&gt; like &lt;code&gt;postgresql-%H.log&lt;/code&gt; would result in generating twenty-four hourly log files and then cyclically overwriting them. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;code&gt;logging_collector&lt;/code&gt; が有効になっている場合、このパラメーターにより、PostgreSQLは同じ名前の既存のログファイルに追加するのではなく、トランケート（上書き）します。ただし、切り捨ては、サーバーの起動時やサイズベースのローテーションではなく、時間ベースのローテーションによって新しいファイルが開かれているときにのみ発生します。オフにすると、既存のファイルがすべての場合に追加されます。たとえば、この設定を &lt;code&gt;postgresql-%H.log&lt;/code&gt; のような &lt;code&gt;log_filename&lt;/code&gt; と組み合わせて使用​​すると、24時間ごとのログファイルが生成され、それらが循環的に上書きされます。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ac2a30741ea2b8dcb498e785772cf2a514f01258" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;on&lt;/code&gt; (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt; SQL command. When &lt;code&gt;off&lt;/code&gt; or unset, SQL commands are not committed until you explicitly issue &lt;code&gt;COMMIT&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;. The autocommit-off mode works by issuing an implicit &lt;code&gt;BEGIN&lt;/code&gt; for you, just before any command that is not already in a transaction block and is not itself a &lt;code&gt;BEGIN&lt;/code&gt; or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as &lt;code&gt;VACUUM&lt;/code&gt;).</source>
          <target state="translated">とき &lt;code&gt;on&lt;/code&gt; （デフォルト）、各SQLコマンドが自動的に成功した完了時にコミットしています。このモードでコミットを延期するには、 &lt;code&gt;BEGIN&lt;/code&gt; または &lt;code&gt;START TRANSACTION&lt;/code&gt; SQLコマンドを入力する必要があります。 &lt;code&gt;off&lt;/code&gt; または未設定の場合、SQLコマンドは &lt;code&gt;COMMIT&lt;/code&gt; または &lt;code&gt;END&lt;/code&gt; を明示的に発行するまでコミットされません。自動コミットオフモードは、トランザクションブロック内になく、 &lt;code&gt;BEGIN&lt;/code&gt; または他のトランザクション制御コマンドではなく、トランザクションブロック内で実行できないコマンドの直前に暗黙の &lt;code&gt;BEGIN&lt;/code&gt; を発行することで機能します。（ &lt;code&gt;VACUUM&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="c85a8f652ce31ff087a3b7cc628918aedc0afe36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pg_stat_statements&lt;/code&gt; is loaded, it tracks statistics across all databases of the server. To access and manipulate these statistics, the module provides a view, &lt;code&gt;pg_stat_statements&lt;/code&gt;, and the utility functions &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; and &lt;code&gt;pg_stat_statements&lt;/code&gt;. These are not available globally but can be enabled for a specific database with &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;pg_stat_statements&lt;/code&gt; ビューがロードされ、それは、サーバーのすべてのデータベース間での統計情報を追跡します。これらの統計にアクセスして操作するために、モジュールはビュー &lt;code&gt;pg_stat_statements&lt;/code&gt; と、ユーティリティ関数 &lt;code&gt;pg_stat_statements_reset&lt;/code&gt; および &lt;code&gt;pg_stat_statements&lt;/code&gt; を提供します。これらはグローバルには利用できませんが、 &lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt; を使用して特定のデータベースに対して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="5c48693eca5bd4dca7f7f71afdfbb3d41be3ea38" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;postgres_fdw&lt;/code&gt; encounters a join between foreign tables on the same foreign server, it sends the entire join to the foreign server, unless for some reason it believes that it will be more efficient to fetch rows from each table individually, or unless the table references involved are subject to different user mappings. While sending the &lt;code&gt;JOIN&lt;/code&gt; clauses, it takes the same precautions as mentioned above for the &lt;code&gt;WHERE&lt;/code&gt; clauses.</source>
          <target state="translated">とき &lt;code&gt;postgres_fdw&lt;/code&gt; 出会いが同じ外部サーバ上で外国のテーブル間の結合、それはいくつかの理由で、個別に各テーブルから行をフェッチするために、より効率的になると考えていない限り、全体が外部サーバへの参加送信、またはテーブルの参照が関与しない限り、異なるユーザーマッピングが適用されます。 &lt;code&gt;JOIN&lt;/code&gt; 句を送信するときは、 &lt;code&gt;WHERE&lt;/code&gt; 句について前述したのと同じ予防策をとります。</target>
        </trans-unit>
        <trans-unit id="8c8497bbbc5c881081d121fdf01a588723979b05" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;program&lt;/code&gt; is specified, &lt;code&gt;command&lt;/code&gt; is executed by psql and the data passed from or to &lt;code&gt;command&lt;/code&gt; is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">ときに &lt;code&gt;program&lt;/code&gt; 指定され、 &lt;code&gt;command&lt;/code&gt; psqlのことで実行され、またはに渡されたデータ &lt;code&gt;command&lt;/code&gt; サーバとクライアント間でルーティングされます。この場合も、実行権限はサーバーではなくローカルユーザーの権限であり、SQLスーパーユーザー権限は必要ありません。</target>
        </trans-unit>
        <trans-unit id="6840df87dd751c0fab0c6f46649358f6b34c5849" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;slot_name&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, there will be no replication slot associated with the subscription. This can be used if the replication slot will be created later manually. Such subscriptions must also have both &lt;code&gt;enabled&lt;/code&gt; and &lt;code&gt;create_slot&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;slot_name&lt;/code&gt; が &lt;code&gt;NONE&lt;/code&gt; に設定されている場合、サブスクリプションに関連付けられているレプリケーションスロットはありません。これは、後で複製スロットを手動で作成する場合に使用できます。このようなサブスクリプションでは、 &lt;code&gt;enabled&lt;/code&gt; と &lt;code&gt;create_slot&lt;/code&gt; の両方を &lt;code&gt;false&lt;/code&gt; に設定する必要もあります。</target>
        </trans-unit>
        <trans-unit id="d3788a4cfcb030ae27460c4ddd94f0d92885c664" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;temp_tablespaces&lt;/code&gt; is set interactively, specifying a nonexistent tablespace is an error, as is specifying a tablespace for which the user does not have &lt;code&gt;CREATE&lt;/code&gt; privilege. However, when using a previously set value, nonexistent tablespaces are ignored, as are tablespaces for which the user lacks &lt;code&gt;CREATE&lt;/code&gt; privilege. In particular, this rule applies when using a value set in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;temp_tablespaces&lt;/code&gt; がインタラクティブに設定されている場合、存在しないテーブルスペースを指定するとエラーが発生します。ユーザーが &lt;code&gt;CREATE&lt;/code&gt; 権限を持っていないテーブルスペースを指定するとエラーが発生します。ただし、以前に設定された値を使用する場合、存在しないテーブルスペースは無視され、ユーザーが &lt;code&gt;CREATE&lt;/code&gt; 権限を持たないテーブルスペースも無視されます。特に、このルールは &lt;code&gt;postgresql.conf&lt;/code&gt; で設定された値を使用するときに適用されます。</target>
        </trans-unit>
        <trans-unit id="9c068d98cbad8e288e90e4c1dd972e7c59abbaa3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;tgconstraint&lt;/code&gt; is nonzero, &lt;code&gt;tgconstrrelid&lt;/code&gt;, &lt;code&gt;tgconstrindid&lt;/code&gt;, &lt;code&gt;tgdeferrable&lt;/code&gt;, and &lt;code&gt;tginitdeferred&lt;/code&gt; are largely redundant with the referenced &lt;code&gt;pg_constraint&lt;/code&gt; entry. However, it is possible for a non-deferrable trigger to be associated with a deferrable constraint: foreign key constraints can have some deferrable and some non-deferrable triggers.</source>
          <target state="translated">&lt;code&gt;tgconstraint&lt;/code&gt; がゼロ以外の場合、 &lt;code&gt;tgconstrrelid&lt;/code&gt; 、 &lt;code&gt;tgconstrindid&lt;/code&gt; 、 &lt;code&gt;tgdeferrable&lt;/code&gt; 、および &lt;code&gt;tginitdeferred&lt;/code&gt; は、参照される &lt;code&gt;pg_constraint&lt;/code&gt; エントリで大部分は冗長です。ただし、延期できないトリガーを延期可能な制約に関連付けることは可能です。外部キー制約には、一部の延期可能なトリガーと一部の延期不可能なトリガーを含めることができます。</target>
        </trans-unit>
        <trans-unit id="19d575b88117ece85c7a87c6ea7ead5a6532b19a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trust&lt;/code&gt; authentication is specified, PostgreSQL assumes that anyone who can connect to the server is authorized to access the database with whatever database user name they specify (even superuser names). Of course, restrictions made in the &lt;code&gt;database&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt; columns still apply. This method should only be used when there is adequate operating-system-level protection on connections to the server.</source>
          <target state="translated">ときに &lt;code&gt;trust&lt;/code&gt; 認証が指定され、PostgreSQLは、サーバーに接続できる誰もが、彼らが（でもスーパーユーザ名）を指定するどんなデータベースユーザー名でデータベースにアクセスすることを許可されている前提としています。もちろん、 &lt;code&gt;database&lt;/code&gt; と &lt;code&gt;user&lt;/code&gt; 列で行われた制限は引き続き適用されます。この方法は、サーバーへの接続に適切なオペレーティングシステムレベルの保護がある場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="966280f7c40171987c3cbc983291b38e3a71017e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_remote_estimate&lt;/code&gt; is true, &lt;code&gt;postgres_fdw&lt;/code&gt; obtains row count and cost estimates from the remote server and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. When &lt;code&gt;use_remote_estimate&lt;/code&gt; is false, &lt;code&gt;postgres_fdw&lt;/code&gt; performs local row count and cost estimation and then adds &lt;code&gt;fdw_startup_cost&lt;/code&gt; and &lt;code&gt;fdw_tuple_cost&lt;/code&gt; to the cost estimates. This local estimation is unlikely to be very accurate unless local copies of the remote table's statistics are available. Running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the foreign table is the way to update the local statistics; this will perform a scan of the remote table and then calculate and store statistics just as though the table were local. Keeping local statistics can be a useful way to reduce per-query planning overhead for a remote table &amp;mdash; but if the remote table is frequently updated, the local statistics will soon be obsolete.</source>
          <target state="translated">とき &lt;code&gt;use_remote_estimate&lt;/code&gt; は真、ある &lt;code&gt;postgres_fdw&lt;/code&gt; リモートサーバから取得した行数と費用の見積もり、その後追加 &lt;code&gt;fdw_startup_cost&lt;/code&gt; と &lt;code&gt;fdw_tuple_cost&lt;/code&gt; をコストの見積もりに。 &lt;code&gt;use_remote_estimate&lt;/code&gt; がfalseの場合、 &lt;code&gt;postgres_fdw&lt;/code&gt; はローカル行カウントとコスト見積もりを &lt;code&gt;fdw_tuple_cost&lt;/code&gt; から、 &lt;code&gt;fdw_startup_cost&lt;/code&gt; とfdw_tuple_costをコスト見積もりに追加します。このローカル推定は、リモートテーブルの統計のローカルコピーが利用可能でない限り、非常に正確である可能性は低いです。&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEの&lt;/a&gt;実行外部テーブルでローカル統計を更新する方法です。これにより、リモートテーブルのスキャンが実行され、テーブルがローカルであるかのように統計が計算および保存されます。ローカル統計を保持することは、リモートテーブルのクエリごとの計画オーバーヘッドを減らすのに役立つ方法ですが、リモートテーブルが頻繁に更新される場合、ローカル統計はすぐに使用されなくなります。</target>
        </trans-unit>
        <trans-unit id="fb7e09297d71df57df7c85aea76275071123b814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and a transaction commits after creating or rewriting a permanent relation, this setting determines how to persist the new data. If the data is smaller than this setting, write it to the WAL log; otherwise, use an fsync of affected files. Depending on the properties of your storage, raising or lowering this value might help if such commits are slowing concurrent transactions. If this value is specified without units, it is taken as kilobytes. The default is two megabytes (&lt;code&gt;2MB&lt;/code&gt;).</source>
          <target state="translated">When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and a transaction commits after creating or rewriting a permanent relation, this setting determines how to persist the new data. If the data is smaller than this setting, write it to the WAL log; otherwise, use an fsync of affected files. Depending on the properties of your storage, raising or lowering this value might help if such commits are slowing concurrent transactions. If this value is specified without units, it is taken as kilobytes. The default is two megabytes ( &lt;code&gt;2MB&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f04447293cfe5a43fce5bd6f976cc350e753a232" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; some SQL commands are optimized to avoid WAL logging, as described in &lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;Section 14.4.7&lt;/a&gt;. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, &lt;code&gt;wal_level&lt;/code&gt; can only be changed at server start. However, &lt;code&gt;archive_command&lt;/code&gt; can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set &lt;code&gt;archive_command&lt;/code&gt; to the empty string (&lt;code&gt;''&lt;/code&gt;). This will cause WAL files to accumulate in &lt;code&gt;pg_wal/&lt;/code&gt; until a working &lt;code&gt;archive_command&lt;/code&gt; is re-established.</source>
          <target state="translated">&lt;a href=&quot;populate#POPULATE-PITR&quot;&gt;セクション14.4.7で&lt;/a&gt;説明されているように、 &lt;code&gt;wal_level&lt;/code&gt; が &lt;code&gt;minimal&lt;/code&gt; 場合、WALロギングを回避するために一部のSQLコマンドが最適化されます。これらのステートメントのいずれかの実行中にアーカイブまたはストリーミングレプリケーションがオンになっている場合、WALにはアーカイブのリカバリに十分な情報が含まれていません。 （クラッシュリカバリは影響を受けません。）このため、 &lt;code&gt;wal_level&lt;/code&gt; はサーバーの起動時にのみ変更できます。ただし、 &lt;code&gt;archive_command&lt;/code&gt; は、構成ファイルのリロードで変更できます。一時的にアーカイブを停止したい場合、それを行う1つの方法は、 &lt;code&gt;archive_command&lt;/code&gt; を空の文字列（ &lt;code&gt;''&lt;/code&gt; ）に設定することです。これにより、WALファイルが動作するまで &lt;code&gt;pg_wal/&lt;/code&gt; に蓄積されます &lt;code&gt;archive_command&lt;/code&gt; が再確立されます。</target>
        </trans-unit>
        <trans-unit id="bc54463c4a91042c587b320f65f275bd091c2193" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;heapallindexed&lt;/code&gt;&lt;/em&gt; verification is performed, there is generally a greatly increased chance of detecting single-bit errors, since strict binary equality is tested, and the indexed attributes within the heap are tested.</source>
          <target state="translated">場合&lt;em&gt; &lt;code&gt;heapallindexed&lt;/code&gt; &lt;/em&gt;検証が行われ、そこ厳密なバイナリ等式が試験されているので、一般的にシングルビットエラーを検出大幅に増加チャンスであり、ヒープ内のインデックス付き属性がテストされます。</target>
        </trans-unit>
        <trans-unit id="668fe437dfa47692f950b23dc7849bfb4637dcda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;loop_count&lt;/code&gt;&lt;/em&gt; is greater than one, the returned numbers should be averages expected for any one scan of the index.</source>
          <target state="translated">とき&lt;em&gt; &lt;code&gt;loop_count&lt;/code&gt; &lt;/em&gt; 1より大きい場合、返された数字は平均値は、インデックスのいずれかのスキャンのために期待されなければなりません。</target>
        </trans-unit>
        <trans-unit id="36ef5495d24b79877e9b0ce1d70303e79e6501c2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned for &lt;code&gt;NULL&lt;/code&gt; inputs. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">ときに&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;正の場合、ゼロ行が返され&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;より大きくなる&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;。逆に、&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;が負の場合、&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt;が&lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;より小さい場合、ゼロ行が返されます。 &lt;code&gt;NULL&lt;/code&gt; 入力の場合、ゼロ行も返されます。&lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt;がゼロになるのはエラーです。次にいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="80eeda2a3957217fb0ef90a74740dda9cf0f27e8" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is positive, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is greater than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Conversely, when &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; is negative, zero rows are returned if &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; is less than &lt;em&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/em&gt;. Zero rows are also returned if any input is &lt;code&gt;NULL&lt;/code&gt;. It is an error for &lt;em&gt;&lt;code&gt;step&lt;/code&gt;&lt;/em&gt; to be zero. Some examples follow:</source>
          <target state="translated">When &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; is positive, zero rows are returned if &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; is greater than &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;. Conversely, when &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; is negative, zero rows are returned if &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; is less than &lt;em&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/em&gt;. Zero rows are also returned if any input is &lt;code&gt;NULL&lt;/code&gt; . It is an error for &lt;em&gt; &lt;code&gt;step&lt;/code&gt; &lt;/em&gt; to be zero. Some examples follow:</target>
        </trans-unit>
        <trans-unit id="4d1d230678ad6398ea1b726af7844a229cc8f13e" translate="yes" xml:space="preserve">
          <source>When Can Parallel Query Be Used?</source>
          <target state="translated">パラレルクエリはどのような場合に利用できますか?</target>
        </trans-unit>
        <trans-unit id="1ace675b775ff95ec59fcdc66447d15d12e35d34" translate="yes" xml:space="preserve">
          <source>When Color is Used</source>
          <target state="translated">カラーを使用する場合</target>
        </trans-unit>
        <trans-unit id="8c5a55e381f3b4b99fc5f9dc03b78c3fc758ed84" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">GSSAPIがKerberosを使用する場合、 &lt;code&gt;servicename/hostname@realm&lt;/code&gt; という形式の標準プリンシパルを使用します。 PostgreSQLサーバーは、サーバーが使用するキータブに含まれるすべてのプリンシパルを受け入れますが、 &lt;code&gt;krbsrvname&lt;/code&gt; 接続パラメーターを使用してクライアントから接続するときは、正しいプリンシパルの詳細を指定するように注意する必要があります。 （も参照&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;セクション33.1.2を&lt;/a&gt;。）インストール時のデフォルトは、デフォルトから変更することができます &lt;code&gt;postgres&lt;/code&gt; の使用してビルド時 &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; 。ほとんどの環境では、このパラメーターを変更する必要はありません。一部のKerberos実装では、サービス名を大文字にする必要があるMicrosoft Active Directory（ &lt;code&gt;POSTGRES&lt;/code&gt; ）など、別のサービス名が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="d0d3dbcdfb1b49d79ff3ed10298c962dc04c9d92" translate="yes" xml:space="preserve">
          <source>When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt;. The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt;&lt;code&gt;whatever&lt;/code&gt;. In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case (&lt;code&gt;POSTGRES&lt;/code&gt;).</source>
          <target state="translated">When GSSAPI uses Kerberos, it uses a standard principal in the format &lt;code&gt;servicename/hostname@realm&lt;/code&gt; . The PostgreSQL server will accept any principal that is included in the keytab used by the server, but care needs to be taken to specify the correct principal details when making the connection from the client using the &lt;code&gt;krbsrvname&lt;/code&gt; connection parameter. (See also &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;.) The installation default can be changed from the default &lt;code&gt;postgres&lt;/code&gt; at build time using &lt;code&gt;./configure --with-krb-srvnam=&lt;/code&gt; &lt;code&gt;whatever&lt;/code&gt; . In most environments, this parameter never needs to be changed. Some Kerberos implementations might require a different service name, such as Microsoft Active Directory which requires the service name to be in upper case ( &lt;code&gt;POSTGRES&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb176371849755f8e3fddd6c5c7996731ba8719c" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_archive_delay&lt;/code&gt; applies when WAL data is being read from WAL archive (and is therefore not current). If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;セクション26.5.2で&lt;/a&gt;説明されているように、ホットスタンバイがアクティブな場合、このパラメータは、適用されるWALエントリと競合するスタンバイクエリをキャンセルする前にスタンバイサーバーが待機する時間を決定します。 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; は、WALデータがWALアーカイブから読み取られるときに適用されます（したがって、最新ではありません）。この値が単位なしで指定されている場合、ミリ秒と見なされます。デフォルトは30秒です。値が-1の場合、スタンバイは、競合するクエリが完了するまで永久に待機します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="0ec8116773102304d6d7b1390f1e98f30e3bb2ff" translate="yes" xml:space="preserve">
          <source>When Hot Standby is active, this parameter determines how long the standby server should wait before canceling standby queries that conflict with about-to-be-applied WAL entries, as described in &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;Section 26.5.2&lt;/a&gt;. &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; applies when WAL data is being received via streaming replication. If this value is specified without units, it is taken as milliseconds. The default is 30 seconds. A value of -1 allows the standby to wait forever for conflicting queries to complete. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">&lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;セクション26.5.2で&lt;/a&gt;説明されているように、ホットスタンバイがアクティブな場合、このパラメータは、適用されるWALエントリと競合するスタンバイクエリをキャンセルする前にスタンバイサーバーが待機する時間を決定します。 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; は、WALデータがストリーミングレプリケーションを介して受信されている場合に適用されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。デフォルトは30秒です。値が-1の場合、スタンバイは、競合するクエリが完了するまで永久に待機します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="0f0d78fac0ffb73c1a9e09c7cc14d11764cc7556" translate="yes" xml:space="preserve">
          <source>When PostgreSQL maps SQL data values to XML (as in &lt;code&gt;xmlelement&lt;/code&gt;), or XML to SQL (as in the output columns of &lt;code&gt;xmltable&lt;/code&gt;), except for a few cases treated specially, PostgreSQL simply assumes that the XML data type's XPath 1.0 string form will be valid as the text-input form of the SQL datatype, and conversely. This rule has the virtue of simplicity while producing, for many data types, results similar to the mappings specified in the standard.</source>
          <target state="translated">PostgreSQLがSQLデータ値をXMLにマップするとき（ &lt;code&gt;xmlelement&lt;/code&gt; のように）、またはXMLをSQLにマップするとき（xmltableの出力列の &lt;code&gt;xmltable&lt;/code&gt; ）、特別に扱われるいくつかのケースを除いて、PostgreSQLは単にXMLデータ型のXPath 1.0文字列形式がSQLデータ型のテキスト入力形式として有効であり、逆の場合も同様です。このルールには、多くのデータ型について、標準で指定されているマッピングと同様の結果を生成する一方で、単純さという利点があります。</target>
        </trans-unit>
        <trans-unit id="4181958cdfd24c8fd1ab7073c5b2ff83fa0a559f" translate="yes" xml:space="preserve">
          <source>When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name that the client sends in the &lt;code&gt;client-first-message&lt;/code&gt;. The user name that was already sent in the startup message is used instead. PostgreSQL supports multiple character encodings, while SCRAM dictates UTF-8 to be used for the user name, so it might be impossible to represent the PostgreSQL user name in UTF-8.</source>
          <target state="translated">PostgreSQLでSCRAM-SHA-256が使用されている場合、サーバーは、 &lt;code&gt;client-first-message&lt;/code&gt; 送信するユーザー名を無視します。代わりに、起動メッセージですでに送信されたユーザー名が使用されます。 PostgreSQLは複数の文字エンコーディングをサポートしていますが、SCRAMはユーザー名にUTF-8を使用するように指示しているため、PostgreSQLユーザー名をUTF-8で表すことができない場合があります。</target>
        </trans-unit>
        <trans-unit id="b543779d02e501d6f789fd6a94efbe4d169a8312" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_item&lt;/code&gt; list, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_item&lt;/code&gt; list, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</target>
        </trans-unit>
        <trans-unit id="4cd20efcfa95fdaaa37532258734ec47bc3eda12" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; clause is present, what essentially happens is that the target table is joined to the tables mentioned in the &lt;code&gt;from_list&lt;/code&gt;, and each output row of the join represents an update operation for the target table. When using &lt;code&gt;FROM&lt;/code&gt; you should ensure that the join produces at most one output row for each row to be modified. In other words, a target row shouldn't join to more than one row from the other table(s). If it does, then only one of the join rows will be used to update the target row, but which one will be used is not readily predictable.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句が存在する場合、基本的には、ターゲットテーブルが &lt;code&gt;from_list&lt;/code&gt; に記述されているテーブルに結合され、結合の各出力行がターゲットテーブルの更新操作を表します。 &lt;code&gt;FROM&lt;/code&gt; を使用する場合は、結合によって、変更する行ごとに最大1つの出力行が生成されるようにする必要があります。言い換えると、ターゲット行は他のテーブルの複数の行に結合しないでください。その場合、ターゲット行の更新に使用されるのは結合行の1つだけですが、どちらが使用されるかは簡単には予測できません。</target>
        </trans-unit>
        <trans-unit id="0a80d67f6221f67e848e31748e5e7aded5d6746e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;FROM&lt;/code&gt; item contains &lt;code&gt;LATERAL&lt;/code&gt; cross-references, evaluation proceeds as follows: for each row of the &lt;code&gt;FROM&lt;/code&gt; item providing the cross-referenced column(s), or set of rows of multiple &lt;code&gt;FROM&lt;/code&gt; items providing the columns, the &lt;code&gt;LATERAL&lt;/code&gt; item is evaluated using that row or row set's values of the columns. The resulting row(s) are joined as usual with the rows they were computed from. This is repeated for each row or set of rows from the column source table(s).</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; アイテムに &lt;code&gt;LATERAL&lt;/code&gt; 相互参照が含まれている場合、評価は次のように行われます。相互参照される列を提供する &lt;code&gt;FROM&lt;/code&gt; アイテムの各行、または列を提供する複数の &lt;code&gt;FROM&lt;/code&gt; アイテムの行のセットに対して、 &lt;code&gt;LATERAL&lt;/code&gt; アイテムはその行または行セットの列の値。結果の行は、通常どおり、それらが計算された行と結合されます。これは、列ソーステーブルの行または行のセットごとに繰り返されます。</target>
        </trans-unit>
        <trans-unit id="9131be6a2fce2c0e060d15eb98b8c743d3328da0" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint is not deferrable, PostgreSQL checks for uniqueness immediately whenever a row is inserted or modified. The SQL standard says that uniqueness should be enforced only at the end of the statement; this makes a difference when, for example, a single command updates multiple key values. To obtain standard-compliant behavior, declare the constraint as &lt;code&gt;DEFERRABLE&lt;/code&gt; but not deferred (i.e., &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt;). Be aware that this can be significantly slower than immediate uniqueness checking.</source>
          <target state="translated">場合 &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; 行が挿入または変更されるたびに、制約が直ちに、一意性のためのPostgreSQLのチェック遅延可能ではありません。 SQL標準では、一意性はステートメントの最後にのみ適用する必要があるとしています。これにより、たとえば、単一のコマンドが複数のキー値を更新するときに違いが生じます。標準に準拠した動作を実現するには、制約を &lt;code&gt;DEFERRABLE&lt;/code&gt; として宣言しますが、据え置きしません（つまり、 &lt;code&gt;INITIALLY IMMEDIATE&lt;/code&gt; ）。これは、即時の一意性チェックよりも大幅に遅くなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d7633f6759da586e80f43626088973d06a48ea56" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;pg_cast&lt;/code&gt; entry has different source and target types and a function that takes more than one argument, it represents converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">場合 &lt;code&gt;pg_cast&lt;/code&gt; のエントリが異なるソースおよびターゲット・タイプと複数の引数を取る機能を有し、それは、ある型から別の型に変換し、単一のステップで長さの強制を適用表します。そのようなエントリが利用できない場合、型修飾子を使用する型への強制型変換には2つのステップが含まれます。1つはデータ型間の変換、もう1つは修飾子の適用です。</target>
        </trans-unit>
        <trans-unit id="88f0e69da747f3bb16cb53c469a234fbf587434e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;timestamp with time zone&lt;/code&gt; value is output, it is always converted from UTC to the current &lt;code&gt;timezone&lt;/code&gt; zone, and displayed as local time in that zone. To see the time in another time zone, either change &lt;code&gt;timezone&lt;/code&gt; or use the &lt;code&gt;AT TIME ZONE&lt;/code&gt; construct (see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;Section 9.9.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 値付きのタイムスタンプが出力されると、常にUTCから現在の &lt;code&gt;timezone&lt;/code&gt; ゾーンに変換され、そのゾーンの現地時間として表示されます。別のタイムゾーンの時刻を表示するには、 &lt;code&gt;timezone&lt;/code&gt; 変更するか、 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 構文を使用します（&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-ZONECONVERT&quot;&gt;セクション9.9.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="27629e4b11182354bc4cc1d2c2660d2bd8a7f20c" translate="yes" xml:space="preserve">
          <source>When a cast has different source and target types and a function that takes more than one argument, it supports converting from one type to another and applying a length coercion in a single step. When no such entry is available, coercion to a type that uses a type modifier involves two cast steps, one to convert between data types and a second to apply the modifier.</source>
          <target state="translated">キャストが異なるソース型とターゲット型を持ち、複数の引数を取る関数を持つ場合、1つの型から別の型への変換と長さの強制適用を1つのステップでサポートしています。そのようなエントリがない場合、型修飾子を使用する型への強制は、データ型間の変換と修飾子の適用のための2つのキャスト・ステップを必要とします。</target>
        </trans-unit>
        <trans-unit id="49788d41c6b6cbdafb9c157dde66cc21e7ad5c8d" translate="yes" xml:space="preserve">
          <source>When a cast is applied to a value expression of a known type, it represents a run-time type conversion. The cast will succeed only if a suitable type conversion operation has been defined. Notice that this is subtly different from the use of casts with constants, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt;. A cast applied to an unadorned string literal represents the initial assignment of a type to a literal constant value, and so it will succeed for any type (if the contents of the string literal are acceptable input syntax for the data type).</source>
          <target state="translated">キャストが既知の型の値式に適用される場合、それは実行時の型変換を表します。キャストは、適切な型変換操作が定義されている場合にのみ成功します。&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;セクション4.1.2.7に&lt;/a&gt;示すように、これは定数を使用したキャストの使用とは微妙に異なることに注意してください。修飾されていない文字列リテラルに適用されたキャストは、リテラル定数値への型の初期割り当てを表すため、どの型でも成功します（文字列リテラルの内容がデータ型の許容可能な入力構文である場合）。</target>
        </trans-unit>
        <trans-unit id="cf5e183edf65b04ea968b8cbec71c03d82d34814" translate="yes" xml:space="preserve">
          <source>When a character string value is cast to or from type &lt;code&gt;xml&lt;/code&gt; without going through &lt;code&gt;XMLPARSE&lt;/code&gt; or &lt;code&gt;XMLSERIALIZE&lt;/code&gt;, respectively, the choice of &lt;code&gt;DOCUMENT&lt;/code&gt; versus &lt;code&gt;CONTENT&lt;/code&gt; is determined by the &amp;ldquo;XML option&amp;rdquo;  session configuration parameter, which can be set using the standard command:</source>
          <target state="translated">&lt;code&gt;XMLPARSE&lt;/code&gt; または &lt;code&gt;XMLSERIALIZE&lt;/code&gt; を経由せずに文字列値がタイプ &lt;code&gt;xml&lt;/code&gt; との間でそれぞれキャストされる場合、 &lt;code&gt;DOCUMENT&lt;/code&gt; と &lt;code&gt;CONTENT&lt;/code&gt; の選択は、標準コマンドを使用して設定できる「XMLオプション」セッション構成パラメーターによって決定されます。</target>
        </trans-unit>
        <trans-unit id="42fc13aa34e4743bab6d0037fe542f1b13a66649" translate="yes" xml:space="preserve">
          <source>When a column is added with &lt;code&gt;ADD COLUMN&lt;/code&gt; and a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; is specified, the default is evaluated at the time of the statement and the result stored in the table's metadata. That value will be used for the column for all existing rows. If no &lt;code&gt;DEFAULT&lt;/code&gt; is specified, NULL is used. In neither case is a rewrite of the table required.</source>
          <target state="translated">列が &lt;code&gt;ADD COLUMN&lt;/code&gt; で追加され、不揮発性の &lt;code&gt;DEFAULT&lt;/code&gt; が指定されている場合、デフォルトはステートメントの時点で評価され、結果はテーブルのメタデータに格納されます。その値は、既存のすべての行の列に使用されます。 &lt;code&gt;DEFAULT&lt;/code&gt; が指定されていない場合、NULLが使用されます。どちらの場合も、テーブルの書き換えは必要ありません。</target>
        </trans-unit>
        <trans-unit id="4617ca746c05eccbac9e1250d759f5bd44319fcd" translate="yes" xml:space="preserve">
          <source>When a conflicting query is short, it's typically desirable to allow it to complete by delaying WAL application for a little bit; but a long delay in WAL application is usually not desirable. So the cancel mechanism has parameters, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;, that define the maximum allowed delay in WAL application. Conflicting queries will be canceled once it has taken longer than the relevant delay setting to apply any newly-received WAL data. There are two parameters so that different delay values can be specified for the case of reading WAL data from an archive (i.e., initial recovery from a base backup or &amp;ldquo;catching up&amp;rdquo; a standby server that has fallen far behind) versus reading WAL data via streaming replication.</source>
          <target state="translated">競合するクエリが短い場合は、通常、WALアプリケーションを少し遅延させることでクエリを完了できるようにすることが望ましいです。しかし、WALアプリケーションの長い遅延は通常望ましくありません。そのため、キャンセルメカニズムには、WALアプリケーションで許可される最大遅延を定義するパラメーター&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delayが&lt;/a&gt;あります。新しく受信したWALデータを適用するために関連する遅延設定よりも長くかかると、競合するクエリはキャンセルされます。 2つのパラメーターがあるため、アーカイブからWALデータを読み取る場合（つまり、ベースバックアップからの最初のリカバリ、または大幅に遅れているスタンバイサーバーの「キャッチアップ」）と、WALデータを読み取る場合に異なる遅延値を指定できます。ストリーミングレプリケーション。</target>
        </trans-unit>
        <trans-unit id="fe9942af75508e96643f23b2bb2b19c3cb29a5d8" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind anonymously (since &lt;code&gt;ldapbinddn&lt;/code&gt; was not specified) to the LDAP server, perform a search for &lt;code&gt;(uid=someuser)&lt;/code&gt; under the specified base DN. If an entry is found, it will then attempt to bind using that found information and the password supplied by the client. If that second connection succeeds, the database access is granted.</source>
          <target state="translated">データベースユーザー &lt;code&gt;someuser&lt;/code&gt; としてデータベースサーバーへの接続が要求されると、PostgreSQLはLDAPサーバーに（ &lt;code&gt;ldapbinddn&lt;/code&gt; が指定されていないため）匿名でバインドを試み、指定されたベースDNで &lt;code&gt;(uid=someuser)&lt;/code&gt; を検索します。エントリが見つかった場合は、見つかった情報とクライアントから提供されたパスワードを使用してバインドを試みます。2番目の接続が成功すると、データベースアクセスが許可されます。</target>
        </trans-unit>
        <trans-unit id="48781ec5a4acd4a7481b8c8839149e95712b5009" translate="yes" xml:space="preserve">
          <source>When a connection to the database server as database user &lt;code&gt;someuser&lt;/code&gt; is requested, PostgreSQL will attempt to bind to the LDAP server using the DN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; and the password provided by the client. If that connection succeeds, the database access is granted.</source>
          <target state="translated">データベースユーザー &lt;code&gt;someuser&lt;/code&gt; としてデータベースサーバーへの接続が要求されると、PostgreSQLはDN &lt;code&gt;cn=someuser, dc=example, dc=net&lt;/code&gt; およびクライアントから提供されたパスワードを使用してLDAPサーバーにバインドしようとします。その接続が成功すると、データベースアクセスが許可されます。</target>
        </trans-unit>
        <trans-unit id="c225436eedb2c4fcd16a275b1ddffc50962ab028" translate="yes" xml:space="preserve">
          <source>When a constant's value has been ignored for purposes of matching the query to other queries, the constant is replaced by a parameter symbol, such as &lt;code&gt;$1&lt;/code&gt;, in the &lt;code&gt;pg_stat_statements&lt;/code&gt; display. The rest of the query text is that of the first query that had the particular &lt;code&gt;queryid&lt;/code&gt; hash value associated with the &lt;code&gt;pg_stat_statements&lt;/code&gt; entry.</source>
          <target state="translated">クエリを他のクエリと照合する目的で定数の値が無視された場合、 &lt;code&gt;pg_stat_statements&lt;/code&gt; 表示では、定数は &lt;code&gt;$1&lt;/code&gt; などのパラメータシンボルに置き換えられます。クエリテキストの残りの部分は、 &lt;code&gt;pg_stat_statements&lt;/code&gt; エントリに関連付けられた特定のクエリ &lt;code&gt;queryid&lt;/code&gt; ハッシュ値を持つ最初のクエリのテキストです。</target>
        </trans-unit>
        <trans-unit id="ecb409e448668771f827d8fbf0e7974aed415eec" translate="yes" xml:space="preserve">
          <source>When a data-only dump is chosen and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_dump emits commands to disable triggers on user tables before inserting the data, and then commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">データのみのダンプが選択され、オプション &lt;code&gt;--disable-triggers&lt;/code&gt; が使用されている場合、pg_dumpは、データを挿入する前にユーザーテーブルのトリガーを無効にするコマンドを発行し、データが挿入された後にトリガーを再度有効にするコマンドを発行します。復元が途中で停止した場合、システムカタログが誤った状態のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2bb4292f30931b17f0bc254f84df53dc22a84368" translate="yes" xml:space="preserve">
          <source>When a direct database connection is specified using the &lt;code&gt;-d&lt;/code&gt; option, pg_restore internally executes SQL statements. If you have problems running pg_restore, make sure you are able to select information from the database using, for example, &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;. Also, any default connection settings and environment variables used by the libpq front-end library will apply.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; オプションを使用して直接データベース接続が指定されている場合、pg_restoreは内部でSQLステートメントを実行します。pg_restoreの実行に問題がある場合は、たとえば&lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt;を使用してデータベースから情報を選択できることを確認してください。また、libpqフロントエンドライブラリによって使用されるデフォルトの接続設定と環境変数が適用されます。</target>
        </trans-unit>
        <trans-unit id="70b0a551bd1d82e60af1e6e20328604ac27e04a2" translate="yes" xml:space="preserve">
          <source>When a domain has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested in alphabetical order by name. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">ドメインに複数の &lt;code&gt;CHECK&lt;/code&gt; 制約がある場合、それらは名前のアルファベット順にテストされます。（PostgreSQLバージョン9.5より前は、 &lt;code&gt;CHECK&lt;/code&gt; 制約の特定の起動順序を尊重していませんでした。）</target>
        </trans-unit>
        <trans-unit id="d2882ec668c4758898724ea8c42f8d7a46c5af40" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the function's output column(s), which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt; , a &lt;code&gt;bigint&lt;/code&gt; column is appended to the function's output column(s), which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ae6b8670e18414fb24938a0f2cc8a6d1070788" translate="yes" xml:space="preserve">
          <source>When a function in the &lt;code&gt;FROM&lt;/code&gt; clause is suffixed by &lt;code&gt;WITH ORDINALITY&lt;/code&gt;, a &lt;code&gt;bigint&lt;/code&gt; column is appended to the output which starts from 1 and increments by 1 for each row of the function's output. This is most useful in the case of set returning functions such as &lt;code&gt;unnest()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の関数の末尾に &lt;code&gt;WITH ORDINALITY&lt;/code&gt; が付いている場合、 &lt;code&gt;bigint&lt;/code&gt; 列が出力に追加されます。この列は、1から始まり、関数の出力の行ごとに1ずつ増加します。これは、 &lt;code&gt;unnest()&lt;/code&gt; などのセットを返す関数の場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="cc5d8fb3f4d70c3c0f1dea589130a29e4dae23e6" translate="yes" xml:space="preserve">
          <source>When a heap entry is to be deleted (by &lt;code&gt;VACUUM&lt;/code&gt;), all its index entries must be removed first.</source>
          <target state="translated">ヒープエントリを（ &lt;code&gt;VACUUM&lt;/code&gt; によって）削除する場合、そのすべてのインデックスエントリを最初に削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="00af93fe8454ff02af34b94554824196fc81e8fc" translate="yes" xml:space="preserve">
          <source>When a locking clause appears at the top level of a &lt;code&gt;SELECT&lt;/code&gt; query, the rows that are locked are exactly those that are returned by the query; in the case of a join query, the rows locked are those that contribute to returned join rows. In addition, rows that satisfied the query conditions as of the query snapshot will be locked, although they will not be returned if they were updated after the snapshot and no longer satisfy the query conditions. If a &lt;code&gt;LIMIT&lt;/code&gt; is used, locking stops once enough rows have been returned to satisfy the limit (but note that rows skipped over by &lt;code&gt;OFFSET&lt;/code&gt; will get locked). Similarly, if a locking clause is used in a cursor's query, only rows actually fetched or stepped past by the cursor will be locked.</source>
          <target state="translated">ロック句が &lt;code&gt;SELECT&lt;/code&gt; クエリの最上位にある場合、ロックされる行は、クエリによって返される行とまったく同じです。結合クエリの場合、ロックされる行は、返される結合行に寄与する行です。また、スナップショット後に更新され、クエリ条件を満たさなくなった場合は返されませんが、クエリスナップショットの時点でクエリ条件を満たす行はロックされます。場合 &lt;code&gt;LIMIT&lt;/code&gt; が使用されている十分な行が制限を満たすために戻ってきた（しかし、行がでスキップなお、一度、ロックが停止し &lt;code&gt;OFFSET&lt;/code&gt; ロックされます）。同様に、カーソルのクエリでロッキング句を使用すると、カーソルによって実際にフェッチまたはステップオーバーされた行のみがロックされます。</target>
        </trans-unit>
        <trans-unit id="ef95b8a60ebd804a0c28a2e00cab45258a43a0d6" translate="yes" xml:space="preserve">
          <source>When a locking clause appears in a sub-&lt;code&gt;SELECT&lt;/code&gt;, the rows locked are those returned to the outer query by the sub-query. This might involve fewer rows than inspection of the sub-query alone would suggest, since conditions from the outer query might be used to optimize execution of the sub-query. For example,</source>
          <target state="translated">ロッキング句がサブ &lt;code&gt;SELECT&lt;/code&gt; にある場合、ロックされる行は、サブクエリによって外部クエリに返される行です。サブクエリの実行を最適化するために外部クエリの条件が使用される可能性があるため、これには、サブクエリの検査だけが示唆するよりも少ない行が含まれる場合があります。例えば、</target>
        </trans-unit>
        <trans-unit id="bfc7a3d97debfcf5d558fe06d1809283c70c4abd" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;GRANT&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will grant only those privileges for which the user has grant options. The &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">オブジェクト試行の場合は非所有者 &lt;code&gt;GRANT&lt;/code&gt; のオブジェクトに対する権限をユーザーがオブジェクト上の一切の権限を持っていない場合、コマンドは完全に失敗します。いくつかの特権が利用可能である限り、コマンドは続行されますが、ユーザーが付与オプションを持っている特権のみが付与されます。 &lt;code&gt;GRANT ALL PRIVILEGES&lt;/code&gt; なしグラントオプションが開催されていない場合は特に、コマンドで指定された権限のいずれかのためのグラントオプションが開催されていない場合は、他の形態は、警告を発行しますながらフォームは、警告メッセージを発行します。 （原則として、これらのステートメントはオブジェクトの所有者にも適用されますが、所有者は常にすべての付与オプションを保持しているものとして扱われるため、ケースが発生することはありません。）</target>
        </trans-unit>
        <trans-unit id="89d5be09265c0f260930da66e4dbc18e249c5a52" translate="yes" xml:space="preserve">
          <source>When a non-owner of an object attempts to &lt;code&gt;REVOKE&lt;/code&gt; privileges on the object, the command will fail outright if the user has no privileges whatsoever on the object. As long as some privilege is available, the command will proceed, but it will revoke only those privileges for which the user has grant options. The &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; forms will issue a warning message if no grant options are held, while the other forms will issue a warning if grant options for any of the privileges specifically named in the command are not held. (In principle these statements apply to the object owner as well, but since the owner is always treated as holding all grant options, the cases can never occur.)</source>
          <target state="translated">オブジェクトの所有者以外がオブジェクトに対する &lt;code&gt;REVOKE&lt;/code&gt; を取り消そうとすると、ユーザーがオブジェクトに対する権限をまったく持っていない場合、コマンドは完全に失敗します。いくつかの特権が利用可能である限り、コマンドは続行しますが、ユーザーが付与オプションを持っている特権のみを取り消します。 &lt;code&gt;REVOKE ALL PRIVILEGES&lt;/code&gt; なしグラントオプションが開催されていない場合は特に、コマンドで指定された権限のいずれかのためのグラントオプションが開催されていない場合は、他の形態は、警告を発行しますながらフォームは、警告メッセージを発行します。 （原則として、これらのステートメントはオブジェクトの所有者にも適用されますが、所有者は常にすべての付与オプションを保持しているものとして扱われるため、ケースが発生することはありません。）</target>
        </trans-unit>
        <trans-unit id="0029c76ef03f694dc7bb9ed004592d4eb27d7674" translate="yes" xml:space="preserve">
          <source>When a partitioned table is added to a publication, all of its existing and future partitions are implicitly considered to be part of the publication. So, even operations that are performed directly on a partition are also published via publications that its ancestors are part of.</source>
          <target state="translated">パーティショニングされたテーブルがパブリケーションに追加されると、既存のパーティションと将来のパーティションはすべて暗黙のうちにパブリケーションの一部とみなされます。つまり、パーティションに対して直接実行される操作であっても、その祖先がパブリケーションの一部であるパブリケーションを介してパブリッシュされます。</target>
        </trans-unit>
        <trans-unit id="81fc5d42be5663314dba2e99345c9e9036540107" translate="yes" xml:space="preserve">
          <source>When a password is specified in &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; or &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, this parameter determines the algorithm to use to encrypt the password. The default value is &lt;code&gt;md5&lt;/code&gt;, which stores the password as an MD5 hash (&lt;code&gt;on&lt;/code&gt; is also accepted, as alias for &lt;code&gt;md5&lt;/code&gt;). Setting this parameter to &lt;code&gt;scram-sha-256&lt;/code&gt; will encrypt the password with SCRAM-SHA-256.</source>
          <target state="translated">&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;または&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;でパスワードが指定されている場合、このパラメーターは、パスワードの暗号化に使用するアルゴリズムを決定します。デフォルト値は &lt;code&gt;md5&lt;/code&gt; で、MD5ハッシュとしてパスワードを保存します（ &lt;code&gt;md5&lt;/code&gt; のエイリアスとして &lt;code&gt;on&lt;/code&gt; も受け入れられます）。このパラメーターを &lt;code&gt;scram-sha-256&lt;/code&gt; に設定すると、SCRAM-SHA-256でパスワードが暗号化されます。</target>
        </trans-unit>
        <trans-unit id="a045ad36bdf763a5564eafc812cd1f70e538ac02" translate="yes" xml:space="preserve">
          <source>When a query involves multiple window functions, it is possible to write out each one with a separate &lt;code&gt;OVER&lt;/code&gt; clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a &lt;code&gt;WINDOW&lt;/code&gt; clause and then referenced in &lt;code&gt;OVER&lt;/code&gt;. For example:</source>
          <target state="translated">クエリに複数のウィンドウ関数が含まれる場合、それぞれを個別の &lt;code&gt;OVER&lt;/code&gt; 句で書き出すことが可能ですが、これは重複しており、同じウィンドウ処理動作が複数の関数で必要な場合はエラーが発生しやすくなります。代わりに、各ウィンドウ動作を &lt;code&gt;WINDOW&lt;/code&gt; 句で名前を付けてから、 &lt;code&gt;OVER&lt;/code&gt; で参照できます。例えば：</target>
        </trans-unit>
        <trans-unit id="6b051ff28261e8c6e18971fa6cb50736f0add4f7" translate="yes" xml:space="preserve">
          <source>When a query only involves two or three tables, there aren't many join orders to worry about. But the number of possible join orders grows exponentially as the number of tables expands. Beyond ten or so input tables it's no longer practical to do an exhaustive search of all the possibilities, and even for six or seven tables planning might take an annoyingly long time. When there are too many input tables, the PostgreSQL planner will switch from exhaustive search to a &lt;em&gt;genetic&lt;/em&gt; probabilistic search through a limited number of possibilities. (The switch-over threshold is set by the &lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt; run-time parameter.) The genetic search takes less time, but it won't necessarily find the best possible plan.</source>
          <target state="translated">クエリに2つまたは3つのテーブルのみが含まれる場合、心配する必要のある結合順序は多くありません。ただし、テーブルの数が増えると、可能な結合順序の数は指数関数的に増加します。 10個程度の入力テーブルを超えると、すべての可能性を網羅的に検索することは現実的ではなくなり、6個または7個のテーブルであっても、計画には厄介な時間がかかる場合があります。入力テーブルが多すぎる場合、PostgreSQLプランナーは、限られた数の可能性を介して、網羅的検索から&lt;em&gt;遺伝的&lt;/em&gt;確率検索に切り替えます。 （切り替えしきい値は、&lt;a href=&quot;runtime-config-query#GUC-GEQO-THRESHOLD&quot;&gt;geqo_threshold&lt;/a&gt;実行時パラメーターによって設定されます。）遺伝子検索の所要時間は短くなりますが、必ずしも最良の計画が見つかるとは限りません。</target>
        </trans-unit>
        <trans-unit id="52a265f5fc62979fde73128f8ace62054feb152e" translate="yes" xml:space="preserve">
          <source>When a schema-qualified operator name is used in the &lt;code&gt;OPERATOR&lt;/code&gt; syntax, as for example in:</source>
          <target state="translated">以下のように、スキーマ修飾演算子名が &lt;code&gt;OPERATOR&lt;/code&gt; 構文で使用されている場合。</target>
        </trans-unit>
        <trans-unit id="07d688620d10b715a262026cbd31ef1489999e7d" translate="yes" xml:space="preserve">
          <source>When a sequential scan and sort is used, a temporary sort file is also created, so that the peak temporary space requirement is as much as double the table size, plus the index sizes. This method is often faster than the index scan method, but if the disk space requirement is intolerable, you can disable this choice by temporarily setting &lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">順次スキャンおよびソートを使用すると、一時ソートファイルも作成されるため、ピーク一時スペース要件は、テーブルサイズとインデックスサイズの2倍になります。多くの場合、この方法はインデックススキャン方式よりも高速ですが、ディスク容量の要件が許容できない場合は、一時的に&lt;a href=&quot;runtime-config-query#GUC-ENABLE-SORT&quot;&gt;enable_sort&lt;/a&gt;を &lt;code&gt;off&lt;/code&gt; に設定することで、この選択を無効にできます。</target>
        </trans-unit>
        <trans-unit id="f0770f15e6049d266a12140bc7f33a5609b9c35a" translate="yes" xml:space="preserve">
          <source>When a single element is pushed onto either the beginning or end of a one-dimensional array, the result is an array with the same lower bound subscript as the array operand. For example:</source>
          <target state="translated">1つの要素が1次元配列の先頭または末尾のいずれかに押されると、結果は配列オペランドと同じ下界の添え字を持つ配列になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f80cd58c4f6747cdabdfc227aecb194029c6f93d" translate="yes" xml:space="preserve">
          <source>When a standby first attaches to the primary, it will not yet be properly synchronized. This is described as &lt;code&gt;catchup&lt;/code&gt; mode. Once the lag between standby and primary reaches zero for the first time we move to real-time &lt;code&gt;streaming&lt;/code&gt; state. The catch-up duration may be long immediately after the standby has been created. If the standby is shut down, then the catch-up period will increase according to the length of time the standby has been down. The standby is only able to become a synchronous standby once it has reached &lt;code&gt;streaming&lt;/code&gt; state. This state can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">スタンバイが最初にプライマリに接続するとき、まだ適切に同期されていません。これは &lt;code&gt;catchup&lt;/code&gt; モードと呼ばれます。スタンバイとプライマリのラグが初めてゼロに達すると、リアルタイム &lt;code&gt;streaming&lt;/code&gt; 状態に移行します。スタンバイが作成された直後は、キャッチアップ期間が長くなる場合があります。スタンバイがシャットダウンされている場合、キャッチアップ期間は、スタンバイがダウンしていた時間の長さに応じて長くなります。スタンバイは、 &lt;code&gt;streaming&lt;/code&gt; 状態に達した後でのみ同期スタンバイになることができます。この状態は、 &lt;code&gt;pg_stat_replication&lt;/code&gt; ビューを使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="ad5c61ffccbfb5effcfe0a2c8686ec7385263d29" translate="yes" xml:space="preserve">
          <source>When a subscription is dropped and recreated, the synchronization information is lost. This means that the data has to be resynchronized afterwards.</source>
          <target state="translated">サブスクリプションを削除して再作成すると、同期情報が失われます。つまり、後からデータを再同期する必要があります。</target>
        </trans-unit>
        <trans-unit id="b46a9ad23681ef38bc14d25148f1365c37846a4e" translate="yes" xml:space="preserve">
          <source>When a table has a default partition, defining a new partition changes the partition constraint for the default partition. The default partition can't contain any rows that would need to be moved to the new partition, and will be scanned to verify that none are present. This scan, like the scan of the new partition, can be avoided if an appropriate &lt;code&gt;CHECK&lt;/code&gt; constraint is present. Also like the scan of the new partition, it is always skipped when the default partition is a foreign table.</source>
          <target state="translated">テーブルにデフォルトパーティションがある場合、新しいパーティションを定義すると、デフォルトパーティションのパーティション制約が変更されます。デフォルトのパーティションには、新しいパーティションに移動する必要がある行を含めることはできません。行が存在しないことを確認するためにスキャンされます。このスキャンは、新しいパーティションのスキャンと同様に、適切な &lt;code&gt;CHECK&lt;/code&gt; 制約が存在する場合は回避できます。また、新しいパーティションのスキャンと同様に、デフォルトのパーティションが外部テーブルの場合は常にスキップされます。</target>
        </trans-unit>
        <trans-unit id="152306185769e157a52b3f97557867eb083f11a7" translate="yes" xml:space="preserve">
          <source>When a table has an existing &lt;code&gt;DEFAULT&lt;/code&gt; partition and a new partition is added to it, the default partition must be scanned to verify that it does not contain any rows which properly belong in the new partition. If the default partition contains a large number of rows, this may be slow. The scan will be skipped if the default partition is a foreign table or if it has a constraint which proves that it cannot contain rows which should be placed in the new partition.</source>
          <target state="translated">テーブルに既存の &lt;code&gt;DEFAULT&lt;/code&gt; パーティションがあり、新しいパーティションが追加されている場合、デフォルトパーティションをスキャンして、新しいパーティションに適切に属する行が含まれていないことを確認する必要があります。デフォルトのパーティションに多数の行が含まれている場合、これは遅くなる可能性があります。デフォルトのパーティションが外部テーブルである場合、または新しいパーティションに配置する必要のある行を含むことができないことを証明する制約がある場合、スキャンはスキップされます。</target>
        </trans-unit>
        <trans-unit id="43b2ea07826933a7c581c975e04300af317cf31d" translate="yes" xml:space="preserve">
          <source>When a table has multiple &lt;code&gt;CHECK&lt;/code&gt; constraints, they will be tested for each row in alphabetical order by name, after checking &lt;code&gt;NOT NULL&lt;/code&gt; constraints. (PostgreSQL versions before 9.5 did not honor any particular firing order for &lt;code&gt;CHECK&lt;/code&gt; constraints.)</source>
          <target state="translated">テーブルに複数の &lt;code&gt;CHECK&lt;/code&gt; 制約がある場合、 &lt;code&gt;NOT NULL&lt;/code&gt; 制約をチェックした後、名前ごとにアルファベット順に各行についてテストされます。（PostgreSQLバージョン9.5より前は、 &lt;code&gt;CHECK&lt;/code&gt; 制約の特定の起動順序を尊重していませんでした。）</target>
        </trans-unit>
        <trans-unit id="082c9f9ffee26ce9be34e1d589e0da24d6b1e31a" translate="yes" xml:space="preserve">
          <source>When a table is being clustered, an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock is acquired on it. This prevents any other database operations (both reads and writes) from operating on the table until the &lt;code&gt;CLUSTER&lt;/code&gt; is finished.</source>
          <target state="translated">テーブルがクラスター化されている場合、 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックがそのテーブルで取得されます。これにより、 &lt;code&gt;CLUSTER&lt;/code&gt; が完了するまで、他のデータベース操作（読み取りと書き込みの両方）がテーブルで動作するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="7d4eb9118baea2c47a40ccbe4939e2face5ca64c" translate="yes" xml:space="preserve">
          <source>When a table is clustered, PostgreSQL remembers which index it was clustered by. The form &lt;code&gt;CLUSTER table_name&lt;/code&gt; reclusters the table using the same index as before. You can also use the &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; forms of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to set the index to be used for future cluster operations, or to clear any previous setting.</source>
          <target state="translated">テーブルがクラスター化されると、PostgreSQLはクラスター化されたインデックスを記憶します。 &lt;code&gt;CLUSTER table_name&lt;/code&gt; の形式は、以前と同じインデックスを使用してテーブルを再クラスター化します。また、使用することができます &lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;SET WITHOUT CLUSTER&lt;/code&gt; 形&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;将来のクラスター操作に使用する、または任意の以前の設定をクリアするには、インデックスを設定します。</target>
        </trans-unit>
        <trans-unit id="8eb320e131f3533a19b92cb04f708af68aba5d79" translate="yes" xml:space="preserve">
          <source>When a table is clustered, it is physically reordered based on the index information. Clustering is a one-time operation: when the table is subsequently updated, the changes are not clustered. That is, no attempt is made to store new or updated rows according to their index order. (If one wishes, one can periodically recluster by issuing the command again. Also, setting the table's &lt;code&gt;fillfactor&lt;/code&gt; storage parameter to less than 100% can aid in preserving cluster ordering during updates, since updated rows are kept on the same page if enough space is available there.)</source>
          <target state="translated">テーブルがクラスター化されると、インデックス情報に基づいて物理的に並べ替えられます。クラスタリングは1回限りの操作です。テーブルが後で更新されても、変更はクラスタリングされません。つまり、インデックスの順序に従って新しい行または更新された行を格納する試みは行われません。 （必要に応じて、コマンドを再発行して定期的に再クラスター化できます。また、テーブルの &lt;code&gt;fillfactor&lt;/code&gt; storageパラメーターを100％未満に設定すると、十分なスペースがある場合に更新された行が同じページに保持されるため、更新中にクラスターの順序を維持するのに役立ちます。そこで利用できます。）</target>
        </trans-unit>
        <trans-unit id="49a3d5e22ae2844ff5c06f47ba492689eb79f5ba" translate="yes" xml:space="preserve">
          <source>When a table is created, it contains no data. The first thing to do before a database can be of much use is to insert data. Data is conceptually inserted one row at a time. Of course you can also insert more than one row, but there is no way to insert less than one row. Even if you know only some column values, a complete row must be created.</source>
          <target state="translated">テーブルが作成されたとき、そのテーブルには何のデータも含まれていません。データベースが大きく役立つようになる前に最初にやるべきことは、データを挿入することです。データは概念的には1行ずつ挿入されます。もちろん複数の行を挿入することもできますが、1行未満のデータを挿入する方法はありません。一部の列の値だけを知っていても、完全な行を作成しなければなりません。</target>
        </trans-unit>
        <trans-unit id="85bad0d57dfc672246f13e6ad8d8a435cc923083" translate="yes" xml:space="preserve">
          <source>When a table or index exceeds 1 GB, it is divided into gigabyte-sized &lt;em&gt;segments&lt;/em&gt;. The first segment's file name is the same as the filenode; subsequent segments are named filenode.1, filenode.2, etc. This arrangement avoids problems on platforms that have file size limitations. (Actually, 1 GB is just the default segment size. The segment size can be adjusted using the configuration option &lt;code&gt;--with-segsize&lt;/code&gt; when building PostgreSQL.) In principle, free space map and visibility map forks could require multiple segments as well, though this is unlikely to happen in practice.</source>
          <target state="translated">テーブルまたはインデックスが1 GBを超えると、ギガバイトサイズの&lt;em&gt;セグメントに&lt;/em&gt;分割されます。最初のセグメントのファイル名はfilenodeと同じです。後続のセグメントにはfilenode.1、filenode.2などの名前が付けられます。この配置により、ファイルサイズに制限があるプラットフォームでの問題が回避されます。 （実際には、1 GBはデフォルトのセグメントサイズにすぎません。セグメントサイズは、PostgreSQLの &lt;code&gt;--with-segsize&lt;/code&gt; 時に--with-segsize設定オプションを使用して調整できます。）これは実際には起こりそうにありません。</target>
        </trans-unit>
        <trans-unit id="10a45cc60012ed72f0453155b208d80983750321" translate="yes" xml:space="preserve">
          <source>When a table reference names a table that is the parent of a table inheritance hierarchy, the table reference produces rows of not only that table but all of its descendant tables, unless the key word &lt;code&gt;ONLY&lt;/code&gt; precedes the table name. However, the reference produces only the columns that appear in the named table &amp;mdash; any columns added in subtables are ignored.</source>
          <target state="translated">テーブル参照がテーブル継承階層の親であるテーブルを指定する場合、キーワードがテーブル名の前に &lt;code&gt;ONLY&lt;/code&gt; 場合を除き、テーブル参照はそのテーブルだけでなくすべての子孫テーブルの行を生成します。ただし、参照は名前付きテーブルに表示される列のみを生成します。サブテーブルに追加された列は無視されます。</target>
        </trans-unit>
        <trans-unit id="238107619ce9861ed394df0ebec618f90c2d4272" translate="yes" xml:space="preserve">
          <source>When a typed table is created, then the data types of the columns are determined by the underlying composite type and are not specified by the &lt;code&gt;CREATE TABLE&lt;/code&gt; command. But the &lt;code&gt;CREATE TABLE&lt;/code&gt; command can add defaults and constraints to the table and can specify storage parameters.</source>
          <target state="translated">型付き表が作成されると、列のデータ型は基礎となる複合型によって決定され、 &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドでは指定されません。ただし、 &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドは、デフォルトと制約をテーブルに追加し、ストレージパラメータを指定できます。</target>
        </trans-unit>
        <trans-unit id="40ca1a4315d7efd053d1772d2a1868caf568479c" translate="yes" xml:space="preserve">
          <source>When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way:</source>
          <target state="translated">値をSQLリテラルや識別子として使用する場合は、引用符で囲むのが最も安全です。SQLリテラルとして変数の値を引用するには、コロンの後に変数名を一重引用符で囲みます。SQL識別子として値を引用するには、コロンの後に二重引用符で変数名を記述します。これらの構文は、変数値に埋め込まれた引用符やその他の特殊文字を正しく処理します。前の例では、このように書くとより安全です。</target>
        </trans-unit>
        <trans-unit id="55eaed5a13493b2841925c6347f0f009f1c69d52" translate="yes" xml:space="preserve">
          <source>When a view is locked, all relations appearing in the view definition query are also locked recursively with the same lock mode.</source>
          <target state="translated">ビューがロックされている場合、ビュー定義クエリに現れるすべてのリレーションも、同じロックモードで再帰的にロックされます。</target>
        </trans-unit>
        <trans-unit id="0731d9c33a2135d592b4234920022cbe73ac4232" translate="yes" xml:space="preserve">
          <source>When acquiring locks automatically for commands that reference tables, PostgreSQL always uses the least restrictive lock mode possible. &lt;code&gt;LOCK TABLE&lt;/code&gt; provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the &lt;code&gt;READ COMMITTED&lt;/code&gt; isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain &lt;code&gt;SHARE&lt;/code&gt; lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because &lt;code&gt;SHARE&lt;/code&gt; lock mode conflicts with the &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; lock acquired by writers, and your &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; statement will wait until any concurrent holders of &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock.</source>
          <target state="translated">テーブルを参照するコマンドのロックを自動的に取得する場合、PostgreSQLは常に最も制限の少ないロックモードを使用します。 &lt;code&gt;LOCK TABLE&lt;/code&gt; は、より制限的なロックが必要になる場合に備えて提供されます。たとえば、アプリケーションが &lt;code&gt;READ COMMITTED&lt;/code&gt; 分離レベルでトランザクションを実行し、トランザクションの期間中、テーブル内のデータが安定していることを確認する必要があるとします。これを実現するには、クエリを実行する前にテーブルに対して &lt;code&gt;SHARE&lt;/code&gt; ロックモードを取得します。これは、同時データ変更を防止し、それ以降は、コミットされたデータの安定したビューを参照してくださいテーブルの読み込みを保証するため &lt;code&gt;SHARE&lt;/code&gt; を持つロックモードと競合 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; の作家によって取得したロック、そしてあなた &lt;code&gt;LOCK TABLE name IN SHARE MODE&lt;/code&gt; ステートメントは、 &lt;code&gt;ROW EXCLUSIVE&lt;/code&gt; モードロックの同時保持者がコミットまたはロールバックするまで待機します。したがって、ロックを取得すると、コミットされていない未処理の書き込みはありません。さらに、ロックを解除するまで何も開始できません。</target>
        </trans-unit>
        <trans-unit id="b867fce21cdcff5c6925a3d0a1d7eb430184e42c" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days, keeping the time of day the same. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;America/Denver&lt;/code&gt;:</source>
          <target state="translated">When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days, keeping the time of day the same. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt; . For example, with the session time zone set to &lt;code&gt;America/Denver&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="71a870f6af21f8dafd4cc733a991bd99fd9d13ef" translate="yes" xml:space="preserve">
          <source>When adding an &lt;code&gt;interval&lt;/code&gt; value to (or subtracting an &lt;code&gt;interval&lt;/code&gt; value from) a &lt;code&gt;timestamp with time zone&lt;/code&gt; value, the days component advances or decrements the date of the &lt;code&gt;timestamp with time zone&lt;/code&gt; by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means &lt;code&gt;interval '1 day'&lt;/code&gt; does not necessarily equal &lt;code&gt;interval '24 hours'&lt;/code&gt;. For example, with the session time zone set to &lt;code&gt;CST7CDT&lt;/code&gt;, &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; will produce &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt;, while adding &lt;code&gt;interval '24 hours'&lt;/code&gt; to the same initial &lt;code&gt;timestamp with time zone&lt;/code&gt; produces &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt;, as there is a change in daylight saving time at &lt;code&gt;2005-04-03 02:00&lt;/code&gt; in time zone &lt;code&gt;CST7CDT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timestamp with time zone&lt;/code&gt; 値を持つタイムスタンプに &lt;code&gt;interval&lt;/code&gt; 値を追加する（またはタイムスタンプ値から &lt;code&gt;interval&lt;/code&gt; 値を減算する）場合、日コンポーネントは、 &lt;code&gt;timestamp with time zone&lt;/code&gt; の日付を指定された日数だけ進めるか、減らします。夏時間の変更（セッションのタイムゾーンがDSTを認識するタイムゾーンに設定されている場合）全体で、これは、 &lt;code&gt;interval '1 day'&lt;/code&gt; が &lt;code&gt;interval '24 hours'&lt;/code&gt; 必ずしも等しくないことを意味します。たとえば、セッションのタイムゾーンが &lt;code&gt;CST7CDT&lt;/code&gt; に設定されている場合、 &lt;code&gt;timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'&lt;/code&gt; &lt;code&gt;timestamp with time zone '2005-04-03 12:00-06'&lt;/code&gt; 生成します06 '、追加中 &lt;code&gt;interval '24 hours'&lt;/code&gt; &lt;code&gt;timestamp with time zone&lt;/code&gt; 同じ初期タイムスタンプの間隔'24時間 'は、 &lt;code&gt;timestamp with time zone '2005-04-03 13:00-06'&lt;/code&gt; 生成します。これは、 &lt;code&gt;2005-04-03 02:00&lt;/code&gt; の夏時間に変更があるためです。タイムゾーン &lt;code&gt;CST7CDT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1434d3ccf06b603b0c31a66fe4b553e885790f9" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;Append&lt;/code&gt; node is used in a parallel plan, each process will execute the child plans in the order in which they appear, so that all participating processes cooperate to execute the first child plan until it is complete and then move to the second plan at around the same time. When a &lt;code&gt;Parallel Append&lt;/code&gt; is used instead, the executor will instead spread out the participating processes as evenly as possible across its child plans, so that multiple child plans are executed simultaneously. This avoids contention, and also avoids paying the startup cost of a child plan in those processes that never execute it.</source>
          <target state="translated">&lt;code&gt;Append&lt;/code&gt; ノードが並列プランで使用される場合、各プロセスは、出現順に子プランを実行します。そのため、参加しているすべてのプロセスが連携して、最初の子プランが完了するまで実行し、次に2番目のプランに移動します。ほぼ同時に。とき &lt;code&gt;Parallel Append&lt;/code&gt; 代わりに使用され、エグゼキュータは、代わりに複数の子計画が同時に実行されるように、均等にその子計画全体でできるだけ参加のプロセスを広げます。これにより、競合が回避され、子プランを実行しないプロセスで子プランの開始コストを支払う必要もなくなります。</target>
        </trans-unit>
        <trans-unit id="5e4864e701f86b03083b18f6c388ffa7cee629fe" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;INSERT&lt;/code&gt; command has an auxiliary &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause, if the &lt;code&gt;UPDATE&lt;/code&gt; path is taken, the row to be updated is first checked against the &lt;code&gt;USING&lt;/code&gt; expressions of any &lt;code&gt;UPDATE&lt;/code&gt; policies, and then the new updated row is checked against the &lt;code&gt;WITH CHECK&lt;/code&gt; expressions. Note, however, that unlike a standalone &lt;code&gt;UPDATE&lt;/code&gt; command, if the existing row does not pass the &lt;code&gt;USING&lt;/code&gt; expressions, an error will be thrown (the &lt;code&gt;UPDATE&lt;/code&gt; path will &lt;em&gt;never&lt;/em&gt; be silently avoided).</source>
          <target state="translated">場合 &lt;code&gt;INSERT&lt;/code&gt; コマンドは、補助有し &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句場合、 &lt;code&gt;UPDATE&lt;/code&gt; のパスが取られ、更新すべき行が最初に照合され &lt;code&gt;USING&lt;/code&gt; 任意の式 &lt;code&gt;UPDATE&lt;/code&gt; のポリシー、および新しい更新された行が照合され &lt;code&gt;WITH CHECK&lt;/code&gt; 式。ただし、スタンドアロンの &lt;code&gt;UPDATE&lt;/code&gt; コマンドとは異なり、既存の行が &lt;code&gt;USING&lt;/code&gt; 式を渡さない場合は、エラーがスローされます（ &lt;code&gt;UPDATE&lt;/code&gt; パスが暗黙的に回避される&lt;em&gt;こと&lt;/em&gt;はあり&lt;em&gt;ませ&lt;/em&gt;ん）。</target>
        </trans-unit>
        <trans-unit id="f5ddde61a4b6e8647a9abfe81db27fb6ec9b4388" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;N&lt;/code&gt;-dimensional array is pushed onto the beginning or end of an &lt;code&gt;N+1&lt;/code&gt;-dimensional array, the result is analogous to the element-array case above. Each &lt;code&gt;N&lt;/code&gt;-dimensional sub-array is essentially an element of the &lt;code&gt;N+1&lt;/code&gt;-dimensional array's outer dimension. For example:</source>
          <target state="translated">場合 &lt;code&gt;N&lt;/code&gt; 次元アレイはの最初または最後にプッシュされる &lt;code&gt;N+1&lt;/code&gt; 次元アレイ、結果は、上記素子アレイの場合に類似しています。各 &lt;code&gt;N&lt;/code&gt; 次元サブ配列は、基本的に &lt;code&gt;N+1&lt;/code&gt; 次元配列の外側の次元の要素です。例えば：</target>
        </trans-unit>
        <trans-unit id="31260cf4fd42afa924c8ee13fbb974bf90d187b0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; command affects an inheritance hierarchy, the output might look like this:</source>
          <target state="translated">とき &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; コマンドが継承階層に影響を与え、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5c47d72e8415ae2214a0b4c8ffca096b8ee4f7c5" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">集計式がサブクエリにある場合（&lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;セクション4.2.11&lt;/a&gt;および&lt;a href=&quot;functions-subquery&quot;&gt;セクション9.22を&lt;/a&gt;参照）、通常、集計はサブクエリの行に対して評価されます。ただし、集計の引数（および &lt;code&gt;filter_clause&lt;/code&gt; 場合はfilter_clause）に外部レベルの変数のみが含まれている場合は例外が発生します。集計はそのような最も近い外部レベルに属し、そのクエリの行に対して評価されます。集計式は全体として、それが出現するサブクエリの外部参照となり、そのサブクエリの1つの評価に対して定数として機能します。結果リストまたは &lt;code&gt;HAVING&lt;/code&gt; 句のみに表示されることに関する制限は、集計が属するクエリレベルに適用されます。</target>
        </trans-unit>
        <trans-unit id="3611155577957d7d62aaa216921a5999dd2f0cc2" translate="yes" xml:space="preserve">
          <source>When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</source>
          <target state="translated">When an aggregate expression appears in a subquery (see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-SCALAR-SUBQUERIES&quot;&gt;Section 4.2.11&lt;/a&gt; and &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt;), the aggregate is normally evaluated over the rows of the subquery. But an exception occurs if the aggregate's arguments (and &lt;code&gt;filter_clause&lt;/code&gt; if any) contain only outer-level variables: the aggregate then belongs to the nearest such outer level, and is evaluated over the rows of that query. The aggregate expression as a whole is then an outer reference for the subquery it appears in, and acts as a constant over any one evaluation of that subquery. The restriction about appearing only in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause applies with respect to the query level that the aggregate belongs to.</target>
        </trans-unit>
        <trans-unit id="34d2b87c80e1af3054e4c9d4d3c71d80a5607eb6" translate="yes" xml:space="preserve">
          <source>When an aggregate function is used as a window function, it aggregates over the rows within the current row's window frame. An aggregate used with &lt;code&gt;ORDER BY&lt;/code&gt; and the default window frame definition produces a &amp;ldquo;running sum&amp;rdquo; type of behavior, which may or may not be what's wanted. To obtain aggregation over the whole partition, omit &lt;code&gt;ORDER BY&lt;/code&gt; or use &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt;. Other frame specifications can be used to obtain other effects.</source>
          <target state="translated">集計関数をウィンドウ関数として使用すると、現在の行のウィンドウフレーム内の行全体で集計されます。 &lt;code&gt;ORDER BY&lt;/code&gt; とデフォルトのウィンドウフレーム定義で使用される集約は、「実行合計」タイプの動作を生成します。パーティション全体の集計を取得するには、 &lt;code&gt;ORDER BY&lt;/code&gt; を省略するか、 &lt;code&gt;ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING&lt;/code&gt; を使用します。他のフレーム仕様を使用して、他の効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="64b60eb6cf1570c88f1c1631b3c6e4c5824a2f8b" translate="yes" xml:space="preserve">
          <source>When an alias is applied to the output of a &lt;code&gt;JOIN&lt;/code&gt; clause, the alias hides the original name(s) within the &lt;code&gt;JOIN&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;JOIN&lt;/code&gt; 句の出力にエイリアスが適用されると、エイリアスは &lt;code&gt;JOIN&lt;/code&gt; 内の元の名前を隠します。例えば：</target>
        </trans-unit>
        <trans-unit id="0151521ad4c1bed3dd275586a7870760908f04a0" translate="yes" xml:space="preserve">
          <source>When an application receives this error message, it should abort the current transaction and retry the whole transaction from the beginning. The second time through, the transaction will see the previously-committed change as part of its initial view of the database, so there is no logical conflict in using the new version of the row as the starting point for the new transaction's update.</source>
          <target state="translated">アプリケーションがこのエラーメッセージを受け取った場合、アプリケーションは現在のトランザクションを中止して、トランザクション全体を最初から再試行すべきである。2回目の実行では、トランザクションは以前にコミットされた変更をデータベースの最初のビューの一部として見ることになるので、新しいトランザクションの更新の開始点として行の新しいバージョンを使用することに論理的な衝突はありません。</target>
        </trans-unit>
        <trans-unit id="4ee9b3bf4967c5d2fb0d054d753f418145337cf0" translate="yes" xml:space="preserve">
          <source>When an enum type is created, its members are assigned sort-order positions 1..&lt;code&gt;n&lt;/code&gt;. But members added later might be given negative or fractional values of &lt;code&gt;enumsortorder&lt;/code&gt;. The only requirement on these values is that they be correctly ordered and unique within each enum type.</source>
          <target state="translated">列挙型が作成されると、そのメンバーにはソート順の位置1 .. &lt;code&gt;n&lt;/code&gt; が割り当てられます。ただし、後で追加されるメンバーには、 &lt;code&gt;enumsortorder&lt;/code&gt; の負の値または小数値が与えられる場合があります。これらの値の唯一の要件は、それらが正しく列挙され、各列挙型内で一意であることです。</target>
        </trans-unit>
        <trans-unit id="0950043f7233c157a718d379ee2b34585d4ee731" translate="yes" xml:space="preserve">
          <source>When an index is declared unique, multiple table rows with equal indexed values are not allowed. Null values are not considered equal. A multicolumn unique index will only reject cases where all indexed columns are equal in multiple rows.</source>
          <target state="translated">インデックスが一意であると宣言されている場合、等しいインデックス値を持つ複数のテーブル行は許可されません。ヌル値は等しいとはみなされません。複数列の一意インデックスは、複数の行ですべてのインデックス列が等しい場合にのみ拒否されます。</target>
        </trans-unit>
        <trans-unit id="4aa9424b6df0026312433f3f9260dd9161451961" translate="yes" xml:space="preserve">
          <source>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</source>
          <target state="translated">インデックスページの分割が必要な場合、この関数は、ページ上のどのエントリを古いページに残し、どのエントリを新しいページに移動するかを決定します。</target>
        </trans-unit>
        <trans-unit id="d0d21498c252827ceaa7947111042a06bc38a5a5" translate="yes" xml:space="preserve">
          <source>When an index scan is used, a temporary copy of the table is created that contains the table data in the index order. Temporary copies of each index on the table are created as well. Therefore, you need free space on disk at least equal to the sum of the table size and the index sizes.</source>
          <target state="translated">インデックス スキャンを使用すると、インデックス順にテーブル データを含むテーブルの一時コピーが作成されます。テーブル上の各インデックスの一時コピーも同様に作成されます。したがって、少なくともテーブルのサイズとインデックスのサイズの合計に等しいディスク上の空き容量が必要です。</target>
        </trans-unit>
        <trans-unit id="dad624a33f1e64269d27c153de83dc5212addec4" translate="yes" xml:space="preserve">
          <source>When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, &lt;em&gt;privileges&lt;/em&gt; must be granted.</source>
          <target state="translated">オブジェクトが作成されると、所有者が割り当てられます。所有者は通常、作成ステートメントを実行したロールです。ほとんどの種類のオブジェクトでは、初期状態では、所有者（またはスーパーユーザー）だけがオブジェクトを操作できます。他のロールで使用できるようにするには、&lt;em&gt;権限を付与する&lt;/em&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="016db50c093e11f2c3975978fc13dbb74ccca023" translate="yes" xml:space="preserve">
          <source>When an operator or function of the underlying type is applied to a domain value, the domain is automatically down-cast to the underlying type. Thus, for example, the result of &lt;code&gt;mytable.id - 1&lt;/code&gt; is considered to be of type &lt;code&gt;integer&lt;/code&gt; not &lt;code&gt;posint&lt;/code&gt;. We could write &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; to cast the result back to &lt;code&gt;posint&lt;/code&gt;, causing the domain's constraints to be rechecked. In this case, that would result in an error if the expression had been applied to an &lt;code&gt;id&lt;/code&gt; value of 1. Assigning a value of the underlying type to a field or variable of the domain type is allowed without writing an explicit cast, but the domain's constraints will be checked.</source>
          <target state="translated">基になる型の演算子または関数がドメイン値に適用されると、ドメインは基になる型に自動的にダウンキャストされます。したがって、例えば、結果 &lt;code&gt;mytable.id - 1&lt;/code&gt; 型であると考えられている &lt;code&gt;integer&lt;/code&gt; ない &lt;code&gt;posint&lt;/code&gt; 。私たちは書くことができます &lt;code&gt;(mytable.id - 1)::posint&lt;/code&gt; にキャストする結果バック &lt;code&gt;posint&lt;/code&gt; ドメインの制約を再チェックすることが原因。この場合、式が1の &lt;code&gt;id&lt;/code&gt; 値に適用されているとエラーになります。基になる型の値をドメイン型のフィールドまたは変数に割り当てることは、明示的なキャストを記述せずに許可されますが、ドメインの制約がチェックされます。</target>
        </trans-unit>
        <trans-unit id="9d220c80b589197cba0d859444da322b0880222c" translate="yes" xml:space="preserve">
          <source>When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of &amp;ldquo;saving the data somewhere&amp;rdquo;: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, PostgreSQL tries not to make any assumptions about how the archiving will be done. Instead, PostgreSQL lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a &lt;code&gt;cp&lt;/code&gt;, or it could invoke a complex shell script &amp;mdash; it's all up to you.</source>
          <target state="translated">WALデータをアーカイブする場合は、各セグメントファイルがいっぱいになったらその内容をキャプチャし、セグメントファイルを再利用する前にそのデータをどこかに保存する必要があります。アプリケーションと使用可能なハードウェアに応じて、「データをどこかに保存する」さまざまな方法があります。セグメントファイルを別のマシンのNFSマウントディレクトリにコピーし、テープドライブに書き込みます（確実に各ファイルの元の名前を識別する方法）、またはそれらを一緒にバッチ処理してCDに書き込むなど、完全に別の方法です。データベース管理者に柔軟性を提供するために、PostgreSQLはアーカイブがどのように行われるかについて何も想定しないようにしています。代わりに、PostgreSQLでは、管理者が実行するシェルコマンドを指定して、完了したセグメントファイルを必要な場所にコピーできます。コマンドは、 &lt;code&gt;cp&lt;/code&gt; 、またはそれは複雑なシェルスクリプトを呼び出すことができます&amp;mdash;それはすべてあなた次第です。</target>
        </trans-unit>
        <trans-unit id="c3d93c6ecb33c6eb94db27d2fba2d265ff994790" translate="yes" xml:space="preserve">
          <source>When autosummarization is enabled, each time a page range is filled a request is sent to autovacuum for it to execute a targeted summarization for that range, to be fulfilled at the end of the next worker run on the same database. If the request queue is full, the request is not recorded and a message is sent to the server log:</source>
          <target state="translated">autosummarizationが有効になっている場合、ページ範囲が満たされるたびに、その範囲を対象とした要約を実行するためのリクエストがautovacuumに送信され、同じデータベース上で次のワーカーの実行の最後に実行されます。リクエストキューが一杯になると、リクエストは記録されず、サーバログにメッセージが送られます。</target>
        </trans-unit>
        <trans-unit id="f660851bc52c800a20554ffeb6a7df92726f03b4" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are given, the behavior is to output large objects, when data is being dumped, see the &lt;code&gt;-b&lt;/code&gt; documentation.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; と &lt;code&gt;-B&lt;/code&gt; の両方が指定されている場合、動作はラージオブジェクトを出力することです。データがダンプされている場合は、 &lt;code&gt;-b&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ad45f5349fac03bd7966e305b187db06383f5ed7" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given for the same schema name, the &lt;code&gt;-N&lt;/code&gt; switch wins and the schema is excluded.</source>
          <target state="translated">同じスキーマ名に &lt;code&gt;-n&lt;/code&gt; と &lt;code&gt;-N&lt;/code&gt; の両方が指定されている場合、 &lt;code&gt;-N&lt;/code&gt; スイッチが優先され、スキーマは除外されます。</target>
        </trans-unit>
        <trans-unit id="ede3b8af7caafd954943fe5f04f3a1cc429ba018" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-N&lt;/code&gt; are given, the behavior is to dump just the schemas that match at least one &lt;code&gt;-n&lt;/code&gt; switch but no &lt;code&gt;-N&lt;/code&gt; switches. If &lt;code&gt;-N&lt;/code&gt; appears without &lt;code&gt;-n&lt;/code&gt;, then schemas matching &lt;code&gt;-N&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; と &lt;code&gt;-N&lt;/code&gt; の両方が指定されている場合、動作は、少なくとも1つの &lt;code&gt;-n&lt;/code&gt; スイッチに一致し、 &lt;code&gt;-N&lt;/code&gt; スイッチには一致しないスキーマのみをダンプすることです。場合は &lt;code&gt;-N&lt;/code&gt; はせずに表示されます &lt;code&gt;-n&lt;/code&gt; 、その後、一致するスキーマ &lt;code&gt;-N&lt;/code&gt; は、そうでない場合は、通常のダンプが何であるかを対象から除外されています。</target>
        </trans-unit>
        <trans-unit id="031547c5dfb59556734ca49134f210c68e4c5520" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are given, the behavior is to dump just the tables that match at least one &lt;code&gt;-t&lt;/code&gt; switch but no &lt;code&gt;-T&lt;/code&gt; switches. If &lt;code&gt;-T&lt;/code&gt; appears without &lt;code&gt;-t&lt;/code&gt;, then tables matching &lt;code&gt;-T&lt;/code&gt; are excluded from what is otherwise a normal dump.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; と &lt;code&gt;-T&lt;/code&gt; の両方が指定されている場合、動作は、少なくとも1つの &lt;code&gt;-t&lt;/code&gt; スイッチに一致するが、 &lt;code&gt;-T&lt;/code&gt; スイッチには一致しないテーブルのみをダンプすることです。場合は &lt;code&gt;-T&lt;/code&gt; をせずに表示されます &lt;code&gt;-t&lt;/code&gt; 、その後、マッチングテーブル &lt;code&gt;-T&lt;/code&gt; は、そうでない場合は、通常のダンプが何であるかを対象から除外されています。</target>
        </trans-unit>
        <trans-unit id="6e63ae1dfc17974e0be483ba0ff638bbea32a3b3" translate="yes" xml:space="preserve">
          <source>When casting from &lt;code&gt;EAN13&lt;/code&gt; to another type, there is a run-time check that the value is within the domain of the other type, and an error is thrown if not. The other casts are simply relabelings that will always succeed.</source>
          <target state="translated">&lt;code&gt;EAN13&lt;/code&gt; から別のタイプにキャストする場合、値が他のタイプのドメイン内にあることをランタイムチェックし、そうでない場合はエラーがスローされます。他のキャストは、常に成功する単純なラベル付けです。</target>
        </trans-unit>
        <trans-unit id="9b112e4a8b6a5ae3071dcef7339526c0bc3d3e45" translate="yes" xml:space="preserve">
          <source>When changing this value, consider also adjusting &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;, and &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;.</source>
          <target state="translated">この値を変更するときは、&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;、&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt;、および&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-PER-GATHER&quot;&gt;max_parallel_workers_per_gather&lt;/a&gt;も調整することを検討してください。</target>
        </trans-unit>
        <trans-unit id="db437265a89a8152322953823332b5732e1c0d00" translate="yes" xml:space="preserve">
          <source>When choosing OIDs for a patch that is not expected to be committed immediately, best practice is to use a group of more-or-less consecutive OIDs starting with some random choice in the range 8000&amp;mdash;9999. This minimizes the risk of OID collisions with other patches being developed concurrently. To keep the 8000&amp;mdash;9999 range free for development purposes, after a patch has been committed to the master git repository its OIDs should be renumbered into available space below that range. Typically, this will be done near the end of each development cycle, moving all OIDs consumed by patches committed in that cycle at the same time. The script &lt;code&gt;renumber_oids.pl&lt;/code&gt; can be used for this purpose. If an uncommitted patch is found to have OID conflicts with some recently-committed patch, &lt;code&gt;renumber_oids.pl&lt;/code&gt; may also be useful for recovering from that situation.</source>
          <target state="translated">すぐにコミットされるとは予想されないパッチのOIDを選択する場合、ベストプラクティスは、8000〜9999の範囲のランダムな選択で始まる、多少とも連続するOIDのグループを使用することです。これにより、同時に開発されている他のパッチとのOID衝突のリスクが最小限に抑えられます。開発目的で8000〜9999の範囲を空けておくには、パッチがマスターgitリポジトリにコミットされた後、そのOIDをその範囲より下の使用可能なスペースに再番号付けする必要があります。通常、これは各開発サイクルの終わり近くに行われ、そのサイクルでコミットされたパッチによって同時に消費されたすべてのOIDが移動されます。スクリプト &lt;code&gt;renumber_oids.pl&lt;/code&gt; はこの目的で使用できます。コミットされていないパッチが、最近コミットされたいくつかのパッチとOIDが競合していることが判明した場合は、 &lt;code&gt;renumber_oids.pl&lt;/code&gt; その状況からの回復にも役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="9881b7b2a51c119b916b26c12b2f50a595bc868b" translate="yes" xml:space="preserve">
          <source>When compiled with OpenSSL, there will be more algorithms available. Also public-key encryption functions will be faster as OpenSSL has more optimized BIGNUM functions.</source>
          <target state="translated">OpenSSLでコンパイルすると、より多くのアルゴリズムが利用できるようになります。また、公開鍵暗号化関数は、OpenSSLがより最適化されたBIGNUM関数を持っているため、より高速になります。</target>
        </trans-unit>
        <trans-unit id="5f2a4f35ae5e876b04f4e8702b5ef942899c0855" translate="yes" xml:space="preserve">
          <source>When compiled with zlib, PGP encryption functions are able to compress data before encrypting.</source>
          <target state="translated">zlibでコンパイルした場合、PGP暗号化機能は暗号化する前にデータを圧縮することができます。</target>
        </trans-unit>
        <trans-unit id="4526356cc9d2b5524d1c0613a2cac8e5545975fc" translate="yes" xml:space="preserve">
          <source>When compiling the preprocessed C code files, the compiler needs to be able to find the ECPG header files in the PostgreSQL include directory. Therefore, you might have to use the &lt;code&gt;-I&lt;/code&gt; option when invoking the compiler (e.g., &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt;).</source>
          <target state="translated">前処理されたCコードファイルをコンパイルする場合、コンパイラは、PostgreSQLインクルードディレクトリでECPGヘッダーファイルを見つけることができる必要があります。したがって、コンパイラーを呼び出すときに &lt;code&gt;-I&lt;/code&gt; オプションを使用する必要がある場合があります（例： &lt;code&gt;-I/usr/local/pgsql/include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f6cfdda77ce1539f64bc346b96c3160b7466725a" translate="yes" xml:space="preserve">
          <source>When computing the selectivity for a query involving functionally dependent columns, the planner adjusts the per-condition selectivity estimates using the dependency coefficients so as not to produce an underestimate.</source>
          <target state="translated">関数的に依存する列を含む問い合わせの選択性を計算する際,プランナは,過小評価にならないように依存性係数を用いて条件ごとの選択性の推定値を調整します.</target>
        </trans-unit>
        <trans-unit id="29ea042e28fa2362fa9c26ca7e49e9bd0ec5e906" translate="yes" xml:space="preserve">
          <source>When connecting to the database make sure you have a ticket for a principal matching the requested database user name. For example, for database user name &lt;code&gt;fred&lt;/code&gt;, principal &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; would be able to connect. To also allow principal &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt;, use a user name map, as described in &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt;.</source>
          <target state="translated">データベースに接続するときは、要求されたデータベースユーザー名と一致するプリンシパルのチケットがあることを確認してください。たとえば、データベースユーザー名が &lt;code&gt;fred&lt;/code&gt; の場合、プリンシパル &lt;code&gt;fred@EXAMPLE.COM&lt;/code&gt; は接続できます。プリンシパル &lt;code&gt;fred/users.example.com@EXAMPLE.COM&lt;/code&gt; も許可するには、&lt;a href=&quot;auth-username-maps&quot;&gt;セクション20.2で&lt;/a&gt;説明されているように、ユーザー名マップを使用します。</target>
        </trans-unit>
        <trans-unit id="7fb2d529ca9e4c06995d0fca116b867907b7f0d6" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify in its connection request the name of the database it wants to connect to. It is not possible to access more than one database per connection. However, an application is not restricted in the number of connections it opens to the same or other databases. Databases are physically separated and access control is managed at the connection level. If one PostgreSQL server instance is to house projects or users that should be separate and for the most part unaware of each other, it is therefore recommended to put them into separate databases. If the projects or users are interrelated and should be able to use each other's resources, they should be put in the same database but possibly into separate schemas. Schemas are a purely logical structure and who can access what is managed by the privilege system. More information about managing schemas is in &lt;a href=&quot;ddl-schemas&quot;&gt;Section 5.9&lt;/a&gt;.</source>
          <target state="translated">データベースサーバーに接続するとき、クライアントは接続要求で、接続するデータベースの名前を指定する必要があります。接続ごとに複数のデータベースにアクセスすることはできません。ただし、アプリケーションは、同じデータベースまたは他のデータベースに対して開く接続の数に制限はありません。データベースは物理的に分離され、アクセス制御は接続レベルで管理されます。 1つのPostgreSQLサーバーインスタンスが、分離されるべきプロジェクトやユーザーを収容するためのものであり、ほとんどの場合互いに気付かない場合は、それらを別々のデータベースに配置することをお勧めします。プロジェクトまたはユーザーが相互に関連していて、互いのリソースを使用できる必要がある場合、それらは同じデータベースに配置する必要がありますが、場合によっては別々のスキーマに配置する必要があります。スキーマは純粋に論理的な構造であり、誰が特権システムによって管理されているものにアクセスできます。スキーマの管理の詳細については、&lt;a href=&quot;ddl-schemas&quot;&gt;セクション5.9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8b02ea043cf0c79a30fc9e7d7d2f7eb7a91ce38" translate="yes" xml:space="preserve">
          <source>When connecting to the database server, a client must specify the database name in its connection request. It is not possible to access more than one database per connection. However, clients can open multiple connections to the same database, or different databases. Database-level security has two components: access control (see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;), managed at the connection level, and authorization control (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;), managed via the grant system. Foreign data wrappers (see &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt;) allow for objects within one database to act as proxies for objects in other database or clusters. The older dblink module (see &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt;) provides a similar capability. By default, all users can connect to all databases using all connection methods.</source>
          <target state="translated">When connecting to the database server, a client must specify the database name in its connection request. It is not possible to access more than one database per connection. However, clients can open multiple connections to the same database, or different databases. Database-level security has two components: access control (see &lt;a href=&quot;auth-pg-hba-conf&quot;&gt;Section 20.1&lt;/a&gt;), managed at the connection level, and authorization control (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;), managed via the grant system. Foreign data wrappers (see &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt;) allow for objects within one database to act as proxies for objects in other database or clusters. The older dblink module (see &lt;a href=&quot;https://www.postgresql.org/docs/13/dblink.html&quot;&gt;dblink&lt;/a&gt;) provides a similar capability. By default, all users can connect to all databases using all connection methods.</target>
        </trans-unit>
        <trans-unit id="12d0d4ecddcc515b05d012f2d76c53d27fb85b80" translate="yes" xml:space="preserve">
          <source>When continuous WAL archiving is used in a standby, there are two different scenarios: the WAL archive can be shared between the primary and the standby, or the standby can have its own WAL archive. When the standby has its own WAL archive, set &lt;code&gt;archive_mode&lt;/code&gt; to &lt;code&gt;always&lt;/code&gt;, and the standby will call the archive command for every WAL segment it receives, whether it's by restoring from the archive or by streaming replication. The shared archive can be handled similarly, but the &lt;code&gt;archive_command&lt;/code&gt; must test if the file being archived exists already, and if the existing file has identical contents. This requires more care in the &lt;code&gt;archive_command&lt;/code&gt;, as it must be careful to not overwrite an existing file with different contents, but return success if the exactly same file is archived twice. And all that must be done free of race conditions, if two servers attempt to archive the same file at the same time.</source>
          <target state="translated">スタンバイで継続的なWALアーカイブを使用する場合、2つの異なるシナリオがあります。WALアーカイブをプライマリとスタンバイ間で共有することも、スタンバイが独自のWALアーカイブを持つこともできます。スタンバイに独自のWALアーカイブがある場合は、 &lt;code&gt;archive_mode&lt;/code&gt; を &lt;code&gt;always&lt;/code&gt; に設定します。スタンバイは、アーカイブからの復元またはストリーミングレプリケーションのいずれの場合でも、受信するすべてのWALセグメントに対してアーカイブコマンドを呼び出します。共有アーカイブは同様に処理できますが、 &lt;code&gt;archive_command&lt;/code&gt; は、アーカイブされるファイルがすでに存在するかどうか、および既存のファイルの内容が同じかどうかをテストする必要があります。これには、 &lt;code&gt;archive_command&lt;/code&gt; でさらに注意が必要です。、異なる内容で既存のファイルを上書きしないように注意する必要がありますが、まったく同じファイルが2回アーカイブされた場合は成功を返します。また、2つのサーバーが同じファイルを同時にアーカイブしようとする場合は、すべて競合状態から解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="206b825e98c6a586acace075380fd147e6696a55" translate="yes" xml:space="preserve">
          <source>When converting textual JSON input into &lt;code&gt;jsonb&lt;/code&gt;, the primitive types described by RFC 7159 are effectively mapped onto native PostgreSQL types, as shown in &lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;Table 8.23&lt;/a&gt;. Therefore, there are some minor additional constraints on what constitutes valid &lt;code&gt;jsonb&lt;/code&gt; data that do not apply to the &lt;code&gt;json&lt;/code&gt; type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, &lt;code&gt;jsonb&lt;/code&gt; will reject numbers that are outside the range of the PostgreSQL &lt;code&gt;numeric&lt;/code&gt; data type, while &lt;code&gt;json&lt;/code&gt; will not. Such implementation-defined restrictions are permitted by RFC 7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's &lt;code&gt;number&lt;/code&gt; primitive type as IEEE 754 double precision floating point (which RFC 7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by PostgreSQL should be considered.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#JSON-TYPE-MAPPING-TABLE&quot;&gt;表8.23に&lt;/a&gt;示すように、テキストのJSON入力を &lt;code&gt;jsonb&lt;/code&gt; に変換すると、RFC 7159で説明されているプリミティブ型がネイティブのPostgreSQL型に効果的にマッピングされます。したがって、基礎となるデータ型で表現できるものの制限に対応して、 &lt;code&gt;json&lt;/code&gt; 型または抽象のJSONに適用されない有効な &lt;code&gt;jsonb&lt;/code&gt; データを構成するものには、いくつかの小さな追加の制約があります。特に、 &lt;code&gt;jsonb&lt;/code&gt; はPostgreSQLの &lt;code&gt;numeric&lt;/code&gt; データ型の範囲外の数値を拒否しますが、 &lt;code&gt;json&lt;/code&gt; しない。このような実装定義の制限は、RFC 7159で許可されています。ただし、実際には、JSONの &lt;code&gt;number&lt;/code&gt; プリミティブ型をIEEE 754倍精度浮動小数点（RFC 7159で明示的に予測される）として表すことが一般的であるため、このような問題は他の実装で発生する可能性がはるかに高くなります。そして可能にする）。このようなシステムで交換形式としてJSONを使用する場合、PostgreSQLによって最初に保存されたデータと比較して数値の精度が失われる危険性を考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="e063ec55d6b5085c54d075810d580142922489d3" translate="yes" xml:space="preserve">
          <source>When creating a comment on a constraint, a trigger, a rule or a policy these parameters specify the name of the table or domain on which that object is defined.</source>
          <target state="translated">制約、トリガー、ルール、ポリシーのコメントを作成する場合、これらのパラメータは、そのオブジェクトが定義されているテーブルまたはドメインの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="696e17ed5a7d60938c1cece83fb1d6b1c0903390" translate="yes" xml:space="preserve">
          <source>When creating a hash partition, a modulus and remainder must be specified. The modulus must be a positive integer, and the remainder must be a non-negative integer less than the modulus. Typically, when initially setting up a hash-partitioned table, you should choose a modulus equal to the number of partitions and assign every table the same modulus and a different remainder (see examples, below). However, it is not required that every partition have the same modulus, only that every modulus which occurs among the partitions of a hash-partitioned table is a factor of the next larger modulus. This allows the number of partitions to be increased incrementally without needing to move all the data at once. For example, suppose you have a hash-partitioned table with 8 partitions, each of which has modulus 8, but find it necessary to increase the number of partitions to 16. You can detach one of the modulus-8 partitions, create two new modulus-16 partitions covering the same portion of the key space (one with a remainder equal to the remainder of the detached partition, and the other with a remainder equal to that value plus 8), and repopulate them with data. You can then repeat this -- perhaps at a later time -- for each modulus-8 partition until none remain. While this may still involve a large amount of data movement at each step, it is still better than having to create a whole new table and move all the data at once.</source>
          <target state="translated">ハッシュパーティションを作成する際には、モジュラスと余りを指定しなければなりません。係数は正の整数でなければならず、残りは係数以下の非負の整数でなければなりません。一般的に、ハッシュパーティションのテーブルを最初にセットアップするときは、パーティションの数と同じモジュラスを選択し、すべてのテーブルに同じモジュラスと異なる余白を割り当てるべきです (後述の例を参照してください)。しかし、すべてのパーティションが同じモジュラスを持つ必要はなく、ハッシュ分割されたテーブルのパーティション間で発生するすべてのモジュラスが、次のより大きなモジュラスの係数であることだけです。これにより、すべてのデータを一度に移動させることなく、パーティションの数を段階的に増やすことができます。例えば、8つのパーティションを持つハッシュ分割テーブルを持っていて、それぞれのパーティションはモジュラス8ですが、パーティションの数を16に増やす必要があることがわかったとします。モジュラス8のパーティションの1つを切り離し、キー空間の同じ部分をカバーする2つの新しいモジュラス16のパーティションを作成し(1つは切り離したパーティションの残りの値と同じ余剰を持ち、もう1つはその値に8を足した値と同じ余剰を持つ)、データを再配置することができます。そして、これを、おそらく後で、modulus-8 パーティションが一つも残らなくなるまで繰り返すことができます。各ステップで大量のデータ移動が必要になるかもしれませんが、新しいテーブルを作成して一度にすべてのデータを移動するよりは良いでしょう。</target>
        </trans-unit>
        <trans-unit id="dc592c55de3b2852cc094ece1e21e03a790645cd" translate="yes" xml:space="preserve">
          <source>When creating a list partition, &lt;code&gt;NULL&lt;/code&gt; can be specified to signify that the partition allows the partition key column to be null. However, there cannot be more than one such list partition for a given parent table. &lt;code&gt;NULL&lt;/code&gt; cannot be specified for range partitions.</source>
          <target state="translated">リストパーティションを作成する場合、 &lt;code&gt;NULL&lt;/code&gt; を指定して、パーティションでパーティションキー列をnullにすることができます。ただし、特定の親テーブルには、このようなリストパーティションを複数作成することはできません。範囲パーティションには &lt;code&gt;NULL&lt;/code&gt; を指定できません。</target>
        </trans-unit>
        <trans-unit id="959c4be92ae7a89cd93733c9fb53bfb204d0cf54" translate="yes" xml:space="preserve">
          <source>When creating a range partition involving more than one column, it can also make sense to use &lt;code&gt;MAXVALUE&lt;/code&gt; as part of the lower bound, and &lt;code&gt;MINVALUE&lt;/code&gt; as part of the upper bound. For example, a partition defined using &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; allows any rows where the first partition key column is greater than 0 and less than or equal to 10. Similarly, a partition defined using &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; allows any rows where the first partition key column starts with &quot;a&quot;.</source>
          <target state="translated">複数の列を含む範囲パーティションを作成する場合、下限の一部として &lt;code&gt;MAXVALUE&lt;/code&gt; を使用し、上限の一部として &lt;code&gt;MINVALUE&lt;/code&gt; を使用することも意味があります。たとえば、 &lt;code&gt;FROM (0, MAXVALUE) TO (10, MAXVALUE)&lt;/code&gt; を使用して定義されたパーティションは、最初のパーティションキー列が0より大きく10以下の行を許可します。同様に、 &lt;code&gt;FROM ('a', MINVALUE) TO ('b', MINVALUE)&lt;/code&gt; は、最初のパーティションキー列が「a」で始まるすべての行を許可します。</target>
        </trans-unit>
        <trans-unit id="57bc08d42f10eaae11d2af1199ad3605b863277f" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">範囲パーティションを作成する場合、 &lt;code&gt;FROM&lt;/code&gt; で指定された下限は包含的境界ですが、 &lt;code&gt;TO&lt;/code&gt; で指定された上限は排他的境界です。つまり、 &lt;code&gt;FROM&lt;/code&gt; リストで指定された値は、このパーティションの対応するパーティションキー列の有効な値ですが、 &lt;code&gt;TO&lt;/code&gt; リストの値はそうではありません。このステートメントは、行ごとの比較のルール（&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;9.23.5項&lt;/a&gt;）に従って理解する必要があることに注意してください。たとえば、 &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; が指定されている場合、 &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; バインドされたパーティションは、 &lt;code&gt;x=1&lt;/code&gt; で任意の &lt;code&gt;y&amp;gt;=2&lt;/code&gt; 、 &lt;code&gt;x=2&lt;/code&gt; で任意の非null &lt;code&gt;y&lt;/code&gt; を許可します、 &lt;code&gt;x=3&lt;/code&gt; 、 &lt;code&gt;y&amp;lt;4&lt;/code&gt; いずれか。</target>
        </trans-unit>
        <trans-unit id="e7765f2e543f0af71f77765315c7b66c2db81da2" translate="yes" xml:space="preserve">
          <source>When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt;, a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt;, &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt;.</source>
          <target state="translated">When creating a range partition, the lower bound specified with &lt;code&gt;FROM&lt;/code&gt; is an inclusive bound, whereas the upper bound specified with &lt;code&gt;TO&lt;/code&gt; is an exclusive bound. That is, the values specified in the &lt;code&gt;FROM&lt;/code&gt; list are valid values of the corresponding partition key columns for this partition, whereas those in the &lt;code&gt;TO&lt;/code&gt; list are not. Note that this statement must be understood according to the rules of row-wise comparison (&lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt;). For example, given &lt;code&gt;PARTITION BY RANGE (x,y)&lt;/code&gt; , a partition bound &lt;code&gt;FROM (1, 2) TO (3, 4)&lt;/code&gt; allows &lt;code&gt;x=1&lt;/code&gt; with any &lt;code&gt;y&amp;gt;=2&lt;/code&gt; , &lt;code&gt;x=2&lt;/code&gt; with any non-null &lt;code&gt;y&lt;/code&gt; , and &lt;code&gt;x=3&lt;/code&gt; with any &lt;code&gt;y&amp;lt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="812122c3d99be13340fb205c1949bf12eabae44b" translate="yes" xml:space="preserve">
          <source>When creating a replication slot (the default behavior), &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">レプリケーションスロットを作成する場合（デフォルトの動作）、 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; はトランザクションブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="de7cd6bf9e49c5d84cc8863ddd6e1c17c3e9e579" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">スロットを作成するときは、指定された論理デコード出力プラグインを使用します。&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章を&lt;/a&gt;参照してください。スロットがすでに存在する場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="1423e49aad04fb2810f02511e3e72b04f513e2b2" translate="yes" xml:space="preserve">
          <source>When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</source>
          <target state="translated">When creating a slot, use the specified logical decoding output plugin. See &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;. This option has no effect if the slot already exists.</target>
        </trans-unit>
        <trans-unit id="005a2c498e4cc6e0542ca9414edc2d0ef17812bb" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the remote host is not reachable or in an unclear state. In that case, the subscription can be created using the &lt;code&gt;connect = false&lt;/code&gt; option. The remote host will then not be contacted at all. This is what pg_dump uses. The remote replication slot will then have to be created manually before the subscription can be activated.</source>
          <target state="translated">サブスクリプションを作成するときに、リモートホストに到達できないか、不明な状態です。その場合、サブスクリプションは、 &lt;code&gt;connect = false&lt;/code&gt; オプションを使用して作成できます。その場合、リモートホストにはまったく接続されません。これはpg_dumpが使用するものです。その後、サブスクリプションをアクティブ化する前に、リモート複製スロットを手動で作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="34ca2fb6b711dd16e241f960cfce7ef591df396f" translate="yes" xml:space="preserve">
          <source>When creating a subscription, the replication slot already exists. In that case, the subscription can be created using the &lt;code&gt;create_slot = false&lt;/code&gt; option to associate with the existing slot.</source>
          <target state="translated">サブスクリプションを作成するとき、レプリケーションスロットはすでに存在しています。その場合、 &lt;code&gt;create_slot = false&lt;/code&gt; オプションを使用してサブスクリプションを作成し、既存のスロットに関連付けることができます。</target>
        </trans-unit>
        <trans-unit id="16abed6745cbdfc58355b822cc58590cd4574664" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the number of partitions on which the index has been completed.</source>
          <target state="translated">パーティショニングされたテーブルにインデックスを作成する場合、この列にはインデックスが完成したパーティショニングの数が設定されます。</target>
        </trans-unit>
        <trans-unit id="0cf84112606c62d754e9e14623f4cabe94d1c440" translate="yes" xml:space="preserve">
          <source>When creating an index on a partitioned table, this column is set to the total number of partitions on which the index is to be created.</source>
          <target state="translated">パーティショニングされたテーブルにインデックスを作成する場合、この列にはインデックスを作成するパーティションの総数が設定されます。</target>
        </trans-unit>
        <trans-unit id="0f225feca5ba0ff2fa1c5fa9fb76ca1ce05ad30d" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, a &lt;code&gt;choose&lt;/code&gt; result of &lt;code&gt;spgMatchNode&lt;/code&gt; is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied &lt;code&gt;nodeN&lt;/code&gt; value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for &lt;code&gt;choose&lt;/code&gt; to return &lt;code&gt;spgAddNode&lt;/code&gt;, since that would make the nodes not all equivalent; the &lt;code&gt;spgSplitTuple&lt;/code&gt; action must be used if the value to be inserted doesn't match the existing nodes.</source>
          <target state="translated">扱う場合 &lt;code&gt;allTheSame&lt;/code&gt; のタプル、 &lt;code&gt;choose&lt;/code&gt; の結果 &lt;code&gt;spgMatchNode&lt;/code&gt; は、新しい値が同等のノードのいずれかに割り当てることができることを意味すると解釈されます。コアコードは、指定された &lt;code&gt;nodeN&lt;/code&gt; 値を無視し、ランダムにノードの1つに降ります（ツリーのバランスを保つため）。 &lt;code&gt;spgAddNode&lt;/code&gt; を返す &lt;code&gt;choose&lt;/code&gt; すると、ノードがすべて等価になるわけではないため、エラーになります。挿入する値が既存のノードと一致しない場合は、 &lt;code&gt;spgSplitTuple&lt;/code&gt; アクションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc81dfaf2529806492d6926ee92f707f3d6c4c1b" translate="yes" xml:space="preserve">
          <source>When dealing with an &lt;code&gt;allTheSame&lt;/code&gt; tuple, the &lt;code&gt;inner_consistent&lt;/code&gt; function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the &lt;code&gt;inner_consistent&lt;/code&gt; function normally assumes about the meaning of the nodes.</source>
          <target state="translated">&lt;code&gt;allTheSame&lt;/code&gt; タプルを処理する場合、 &lt;code&gt;inner_consistent&lt;/code&gt; 関数は、すべて同等であるため、インデックス検索を続行するためのターゲットとして、すべてのノードを返すか、ノードを返さないかを指定する必要があります。これは、 &lt;code&gt;inner_consistent&lt;/code&gt; 関数がノードの意味について通常想定する量に応じて、特別な場合のコードを必要とする場合と必要としない場合があります。</target>
        </trans-unit>
        <trans-unit id="b32b90019e8bbf81fee22cbcc2778aa7cfddfd6c" translate="yes" xml:space="preserve">
          <source>When dealing with multiple-argument aggregate functions, note that the &lt;code&gt;ORDER BY&lt;/code&gt; clause goes after all the aggregate arguments. For example, write this:</source>
          <target state="translated">複数引数の集約関数を処理する場合、 &lt;code&gt;ORDER BY&lt;/code&gt; 句はすべての集約引数の後にあることに注意してください。たとえば、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="ec8f5c244f8f3ee5e69ba2a3cc1d82f9a3714553" translate="yes" xml:space="preserve">
          <source>When dealing with outer joins, you might see join plan nodes with both &amp;ldquo;Join Filter&amp;rdquo; and plain &amp;ldquo;Filter&amp;rdquo; conditions attached. Join Filter conditions come from the outer join's &lt;code&gt;ON&lt;/code&gt; clause, so a row that fails the Join Filter condition could still get emitted as a null-extended row. But a plain Filter condition is applied after the outer-join rules and so acts to remove rows unconditionally. In an inner join there is no semantic difference between these types of filters.</source>
          <target state="translated">外部結合を処理するとき、「結合フィルター」条件と単純な「フィルター」条件の両方が付加された結合計画ノードが表示される場合があります。結合フィルター条件は、外部結合の &lt;code&gt;ON&lt;/code&gt; 句から取得されるため、結合フィルター条件に失敗した行は、null拡張行として発行される可能性があります。ただし、単純なフィルター条件は外部結合ルールの後に適用されるため、無条件に行を削除するように機能します。内部結合では、これらのタイプのフィルターの間に意味上の違いはありません。</target>
        </trans-unit>
        <trans-unit id="8a4bff252219a510e2ce0b73debb16a2f8ba45f1" translate="yes" xml:space="preserve">
          <source>When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: &lt;code&gt;bb*&lt;/code&gt; matches the three middle characters of &lt;code&gt;abbbc&lt;/code&gt;; &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; matches all ten characters of &lt;code&gt;weeknights&lt;/code&gt;; when &lt;code&gt;(.*).*&lt;/code&gt; is matched against &lt;code&gt;abc&lt;/code&gt; the parenthesized subexpression matches all three characters; and when &lt;code&gt;(a*)*&lt;/code&gt; is matched against &lt;code&gt;bc&lt;/code&gt; both the whole RE and the parenthesized subexpression match an empty string.</source>
          <target state="translated">一致の長さを決定するとき、一致の長さは照合要素ではなく文字で測定されます。空の文字列は、一致しないよりも長いと見なされます。例： &lt;code&gt;bb*&lt;/code&gt; は、 &lt;code&gt;abbbc&lt;/code&gt; の中間の3文字に一致します。 &lt;code&gt;(week|wee)(night|knights)&lt;/code&gt; は、 &lt;code&gt;weeknights&lt;/code&gt; 10文字すべてに一致します。とき &lt;code&gt;(.*).*&lt;/code&gt; 照合され &lt;code&gt;abc&lt;/code&gt; 、括弧内の部分式は、3つのすべての文字にマッチします。 &lt;code&gt;(a*)*&lt;/code&gt; が &lt;code&gt;bc&lt;/code&gt; と一致する場合、RE全体と括弧で囲まれた部分式の両方が空の文字列と一致します。</target>
        </trans-unit>
        <trans-unit id="158e24683a0dfaf92eb2d2d99535563f16d12035" translate="yes" xml:space="preserve">
          <source>When defining a path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similarly to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">When defining a path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similarly to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</target>
        </trans-unit>
        <trans-unit id="f51f30bba3581f1e69eb69eac04311486d90890a" translate="yes" xml:space="preserve">
          <source>When defining the path, you can also use one or more &lt;em&gt;filter expressions&lt;/em&gt; that work similar to the &lt;code&gt;WHERE&lt;/code&gt; clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</source>
          <target state="translated">パスを定義するときに、SQLの &lt;code&gt;WHERE&lt;/code&gt; 句と同様に機能する1つ以上の&lt;em&gt;フィルター式&lt;/em&gt;を使用することもできます。フィルター式は疑問符で始まり、括弧内に条件を提供します：</target>
        </trans-unit>
        <trans-unit id="359ea83f4fdb1b7fa655731f901be35273bbf743" translate="yes" xml:space="preserve">
          <source>When dropping a subscription that is associated with a replication slot on the remote host (the normal state), &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will connect to the remote host and try to drop the replication slot as part of its operation. This is necessary so that the resources allocated for the subscription on the remote host are released. If this fails, either because the remote host is not reachable or because the remote replication slot cannot be dropped or does not exist or never existed, the &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; command will fail. To proceed in this situation, disassociate the subscription from the replication slot by executing &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt;. After that, &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; will no longer attempt any actions on a remote host. Note that if the remote replication slot still exists, it should then be dropped manually; otherwise it will continue to reserve WAL and might eventually cause the disk to fill up. See also &lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;Section 30.2.1&lt;/a&gt;.</source>
          <target state="translated">リモートホストのレプリケーションスロットに関連付けられているサブスクリプションを削除する場合（通常の状態）、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; はリモートホストに接続し、その操作の一部としてレプリケーションスロットを削除しようとします。これは、リモートホストのサブスクリプションに割り当てられたリソースを解放するために必要です。これが失敗した場合、リモートホストに到達できないか、リモートレプリケーションスロットを削除できないか、存在しないか存在しなかったため、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; コマンドは失敗します。この状況で続行するには、 &lt;code&gt;ALTER SUBSCRIPTION ... SET (slot_name = NONE)&lt;/code&gt; 実行して、サブスクリプションとレプリケーションスロットの関連付けを解除します。その後、 &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; リモートホストでのアクションは試行されなくなります。リモート複製スロットがまだ存在する場合は、手動で削除する必要があることに注意してください。そうしないと、WALが予約され続け、最終的にディスクがいっぱいになる可能性があります。&lt;a href=&quot;logical-replication-subscription#LOGICAL-REPLICATION-SUBSCRIPTION-SLOT&quot;&gt;セクション30.2.1&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="16b8b09fc04797b1f4bd77cb938d65220f3c98d4" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the remote host is not reachable. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription. If the remote database instance no longer exists, no further action is then necessary. If, however, the remote database instance is just unreachable, the replication slot should then be dropped manually; otherwise it would continue to reserve WAL and might eventually cause the disk to fill up. Such cases should be carefully investigated.</source>
          <target state="translated">サブスクリプションを削除すると、リモートホストに到達できなくなります。その場合は、サブスクリプションを削除する前に、 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; を使用してスロットとサブスクリプションの関連付けを解除してください。リモートデータベースインスタンスが存在しない場合、それ以上のアクションは必要ありません。ただし、リモートデータベースインスタンスに到達できない場合は、レプリケーションスロットを手動で削除する必要があります。そうしないと、WALが予約され続け、最終的にディスクがいっぱいになる可能性があります。そのような場合は注意深く調査する必要があります。</target>
        </trans-unit>
        <trans-unit id="aef261ef51923658a5c92b355545488277ab638d" translate="yes" xml:space="preserve">
          <source>When dropping a subscription, the replication slot should be kept. This could be useful when the subscriber database is being moved to a different host and will be activated from there. In that case, disassociate the slot from the subscription using &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; before attempting to drop the subscription.</source>
          <target state="translated">サブスクリプションを削除するときは、レプリケーションスロットを保持する必要があります。これは、サブスクライバーデータベースが別のホストに移動され、そこからアクティブ化される場合に役立ちます。その場合は、サブスクリプションを削除する前に、 &lt;code&gt;ALTER SUBSCRIPTION&lt;/code&gt; を使用してスロットとサブスクリプションの関連付けを解除してください。</target>
        </trans-unit>
        <trans-unit id="7012bb7adb09426a92f880209bcb563fe9379138" translate="yes" xml:space="preserve">
          <source>When dumping data for a table partition, make the &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; statements target the root of the partitioning hierarchy that contains it, rather than the partition itself. This causes the appropriate partition to be re-determined for each row when the data is loaded. This may be useful when reloading data on a server where rows do not always fall into the same partitions as they did on the original server. That could happen, for example, if the partitioning column is of type text and the two systems have different definitions of the collation used to sort the partitioning column.</source>
          <target state="translated">テーブルパーティションのデータをダンプするときは、 &lt;code&gt;COPY&lt;/code&gt; ステートメントまたは &lt;code&gt;INSERT&lt;/code&gt; ステートメントが、パーティション自体ではなく、それを含むパーティション階層のルートを対象とするようにします。これにより、データが読み込まれるときに、行ごとに適切なパーティションが再決定されます。これは、行が必ずしも元のサーバーと同じパーティションに分類されるとは限らないサーバーでデータを再ロードする場合に役立ちます。たとえば、パーティション列がテキストタイプであり、2つのシステムでパーティション列の並べ替えに使用される照合の定義が異なる場合に、これが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b3c4665e18254fa2583d0b9a6ca4200ef73e4faf" translate="yes" xml:space="preserve">
          <source>When dumping logical replication subscriptions, pg_dump will generate &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; commands that use the &lt;code&gt;connect = false&lt;/code&gt; option, so that restoring the subscription does not make remote connections for creating a replication slot or for initial table copy. That way, the dump can be restored without requiring network access to the remote servers. It is then up to the user to reactivate the subscriptions in a suitable way. If the involved hosts have changed, the connection information might have to be changed. It might also be appropriate to truncate the target tables before initiating a new full table copy.</source>
          <target state="translated">論理レプリケーションサブスクリプションをダンプするとき、pg_dumpは、 &lt;code&gt;connect = false&lt;/code&gt; オプションを使用する &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; コマンドを生成します。そのため、サブスクリプションを復元しても、レプリケーションスロットの作成や初期テーブルコピーのためのリモート接続は行われません。このようにして、リモートサーバーへのネットワークアクセスを必要とせずにダンプを復元できます。その後、適切な方法でサブスクリプションを再アクティブ化するのはユーザー次第です。関連するホストが変更された場合、接続情報を変更する必要がある場合があります。新しい全表コピーを開始する前に、ターゲット表を切り捨てることも適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="edeac7aa265daa84ac15a79b57465693d865b8ff" translate="yes" xml:space="preserve">
          <source>When either stderr or csvlog are included, the file &lt;code&gt;current_logfiles&lt;/code&gt; is created to record the location of the log file(s) currently in use by the logging collector and the associated logging destination. This provides a convenient way to find the logs currently in use by the instance. Here is an example of this file's content:</source>
          <target state="translated">stderrまたはcsvlogのいずれかが含まれる場合、ファイル &lt;code&gt;current_logfiles&lt;/code&gt; が作成され、ロギングコレクターと関連するロギング先で現在使用されているログファイルの場所が記録されます。これにより、インスタンスで現在使用されているログを簡単に見つけることができます。このファイルの内容の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="0bf7e84c79ef7d8674ff36f5bd69afa904df5b94" translate="yes" xml:space="preserve">
          <source>When encrypting with a public key:</source>
          <target state="translated">公開鍵で暗号化する場合</target>
        </trans-unit>
        <trans-unit id="d8c4c4accb682e67b5f8b1813c77704fe93cbcb0" translate="yes" xml:space="preserve">
          <source>When encrypting with a symmetric key (i.e., a password):</source>
          <target state="translated">対称鍵(つまりパスワード)で暗号化する場合。</target>
        </trans-unit>
        <trans-unit id="db0cd6f3816a8188a89deee57f710a1baaa98cf3" translate="yes" xml:space="preserve">
          <source>When entering &lt;code&gt;bytea&lt;/code&gt; values in escape format, octets of certain values &lt;em&gt;must&lt;/em&gt; be escaped, while all octet values &lt;em&gt;can&lt;/em&gt; be escaped. In general, to escape an octet, convert it into its three-digit octal value and precede it by a backslash. Backslash itself (octet decimal value 92) can alternatively be represented by double backslashes. &lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;Table 8.7&lt;/a&gt; shows the characters that must be escaped, and gives the alternative escape sequences where applicable.</source>
          <target state="translated">エスケープ形式で &lt;code&gt;bytea&lt;/code&gt; 値を入力する場合、特定の値のオクテットはエスケープする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ますが、すべてのオクテット値&lt;em&gt;は&lt;/em&gt;エスケープ&lt;em&gt;でき&lt;/em&gt;ます。一般に、オクテットをエスケープするには、それを3桁の8進数値に変換し、その前にバックスラッシュを付けます。バックスラッシュ自体（10進数のオクテット値92）は、ダブルバックスラッシュで表すこともできます。&lt;a href=&quot;datatype-binary#DATATYPE-BINARY-SQLESC&quot;&gt;表8.7&lt;/a&gt;は、エスケープする必要がある文字を示し、該当する場合は代替のエスケープシーケンスを示します。</target>
        </trans-unit>
        <trans-unit id="0b723af7e86ecb6fa9f1f4fcf436b5692ddd09fd" translate="yes" xml:space="preserve">
          <source>When establishing a unique constraint for a multi-level partition hierarchy, all the columns in the partition key of the target partitioned table, as well as those of all its descendant partitioned tables, must be included in the constraint definition.</source>
          <target state="translated">複数レベルのパーティション階層に一意の制約を設定する場合、ターゲット・パーティション・テーブルのパーティション・キー内のすべての列と、その子孫のすべてのパーティション・テーブルの列を制約の定義に含めなければなりません。</target>
        </trans-unit>
        <trans-unit id="5828ba22818bd784c0d1de682badc9fdcf5283f1" translate="yes" xml:space="preserve">
          <source>When estimating the selectivity, the planner applies all the conditions on items in the MCV list, and then sums the frequencies of the matching ones. See &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; in &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; for details.</source>
          <target state="translated">選択性を推定するとき、プランナーはMCVリストのアイテムにすべての条件を適用し、一致するものの頻度を合計します。詳細 &lt;code&gt;mcv_clauselist_selectivity&lt;/code&gt; は、 &lt;code&gt;src/backend/statistics/mcv.c&lt;/code&gt; のmcv_clauselist_selectivityを参照してください。</target>
        </trans-unit>
        <trans-unit id="716da7567a674fa423040a77262890c91b3b1491" translate="yes" xml:space="preserve">
          <source>When estimating with functional dependencies, the planner assumes that conditions on the involved columns are compatible and hence redundant. If they are incompatible, the correct estimate would be zero rows, but that possibility is not considered. For example, given a query like</source>
          <target state="translated">関数依存関係を使用して推定する場合、プランナーは、関係する列の条件が互換性があり、したがって冗長であることを前提としている。両者が互換性がない場合、正しい推定値は0行になりますが、その可能性は考慮されません。例えば、以下のようなクエリがあるとします。</target>
        </trans-unit>
        <trans-unit id="064d226f0b61cda9a60ca08881b4d97cee01ca7a" translate="yes" xml:space="preserve">
          <source>When executed on a primary, the function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. The return value is the backup's ending write-ahead log location (which again can be ignored). After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">この機能を1次サーバーで実行すると、先行書き込みログのアーカイブ領域にバックアップ履歴ファイルも作成されます。履歴ファイルには、 &lt;code&gt;pg_start_backup&lt;/code&gt; に与えられたラベル、バックアップの開始と終了の先行書き込みログの場所、およびバックアップの開始と終了時間が含まれます。戻り値は、バックアップの最後の先行書き込みログの場所です（これも無視できます）。終了場所を記録した後、現在の先行ログ挿入ポイントは自動的に次の先行ログファイルに進み、終了先行ログファイルをすぐにアーカイブしてバックアップを完了することができます。</target>
        </trans-unit>
        <trans-unit id="f889c44a7c84c84f84b08b78362ee8d2fe32a7ef" translate="yes" xml:space="preserve">
          <source>When executed on a primary, this function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt;, the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</source>
          <target state="translated">When executed on a primary, this function also creates a backup history file in the write-ahead log archive area. The history file includes the label given to &lt;code&gt;pg_start_backup&lt;/code&gt; , the starting and ending write-ahead log locations for the backup, and the starting and ending times of the backup. After recording the ending location, the current write-ahead log insertion point is automatically advanced to the next write-ahead log file, so that the ending write-ahead log file can be archived immediately to complete the backup.</target>
        </trans-unit>
        <trans-unit id="b575c812fb039c331ed73bad6b9599e79ed09b9b" translate="yes" xml:space="preserve">
          <source>When executed, the example D script gives output such as:</source>
          <target state="translated">D スクリプトの例を実行すると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="9b9cbbd3bd8e290879a575143872c711e1071acb" translate="yes" xml:space="preserve">
          <source>When executing a parallel plan, you can use &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; to display per-worker statistics for each plan node. This may be useful in determining whether the work is being evenly distributed between all plan nodes and more generally in understanding the performance characteristics of the plan.</source>
          <target state="translated">並列プランを実行する場合、 &lt;code&gt;EXPLAIN (ANALYZE, VERBOSE)&lt;/code&gt; を使用して、各プランノードのワーカーごとの統計を表示できます。これは、作業がすべての計画ノード間で均等に分散されているかどうかを判別する場合、およびより一般的には計画のパフォーマンス特性を理解する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f5c9db9afb12cc927dcae6f85bc0fefc8f88ecba" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion so as its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">最近昇格したソースとしてオンラインクラスターを使用してpg_rewindを実行する場合は、昇格後に &lt;code&gt;CHECKPOINT&lt;/code&gt; を実行する必要があります。これにより、制御ファイルは最新のタイムライン情報を反映します。これにより、pg_rewindは、ターゲットクラスターができるかどうかを確認します。指定されたソースクラスタを使用して巻き戻します。</target>
        </trans-unit>
        <trans-unit id="bc2e3d886cd659c186dac8f9dc7a3737bab777bf" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion such that its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</source>
          <target state="translated">When executing pg_rewind using an online cluster as source which has been recently promoted, it is necessary to execute a &lt;code&gt;CHECKPOINT&lt;/code&gt; after promotion such that its control file reflects up-to-date timeline information, which is used by pg_rewind to check if the target cluster can be rewound using the designated source cluster.</target>
        </trans-unit>
        <trans-unit id="45578e8de56cf79c1bab7717b9b7f3794e4ce080" translate="yes" xml:space="preserve">
          <source>When executing pg_rewind using an online cluster as source, a role having sufficient permissions to execute the functions used by pg_rewind on the source cluster can be used instead of a superuser. Here is how to create such a role, named &lt;code&gt;rewind_user&lt;/code&gt; here:</source>
          <target state="translated">オンラインクラスターをソースとして使用してpg_rewindを実行する場合、スーパーユーザーの代わりに、ソースクラスターでpg_rewindによって使用される関数を実行するための十分な権限を持つロールを使用できます。ここでは、 &lt;code&gt;rewind_user&lt;/code&gt; という名前のこのようなロールを作成する方法を示します。</target>
        </trans-unit>
        <trans-unit id="9d8da664aa55aa1d9ba572665740c9977324d898" translate="yes" xml:space="preserve">
          <source>When false, the command will not try to refresh table information. &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; should then be executed separately. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">falseの場合、コマンドはテーブル情報を更新しようとしません。次に、 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; を個別に実行する必要があります。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d12b7ebd6720c102addd509acf7a1b3a9bca1905" translate="yes" xml:space="preserve">
          <source>When host names are specified in &lt;code&gt;pg_hba.conf&lt;/code&gt;, you should make sure that name resolution is reasonably fast. It can be of advantage to set up a local name resolution cache such as &lt;code&gt;nscd&lt;/code&gt;. Also, you may wish to enable the configuration parameter &lt;code&gt;log_hostname&lt;/code&gt; to see the client's host name instead of the IP address in the log.</source>
          <target state="translated">ホスト名が &lt;code&gt;pg_hba.conf&lt;/code&gt; で指定されている場合、名前解決がかなり高速であることを確認する必要があります。 &lt;code&gt;nscd&lt;/code&gt; などのローカルの名前解決キャッシュを設定すると便利です。また、構成パラメーター &lt;code&gt;log_hostname&lt;/code&gt; を有効にして、ログでIPアドレスの代わりにクライアントのホスト名を表示することもできます。</target>
        </trans-unit>
        <trans-unit id="72b7c985f760c5c9e2832f32ef829164b2539557" translate="yes" xml:space="preserve">
          <source>When ident is specified for a local (non-TCP/IP) connection, peer authentication (see &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt;) will be used instead.</source>
          <target state="translated">ローカル（TCP / IP以外）接続にidentが指定されている場合、代わりにピア認証（&lt;a href=&quot;auth-peer&quot;&gt;セクション20.9を&lt;/a&gt;参照）が使用されます。</target>
        </trans-unit>
        <trans-unit id="81c1aa17a38d25550246efe2b31fe8f5cb3b0dba" translate="yes" xml:space="preserve">
          <source>When indexes are not used, it can be useful for testing to force their use. There are run-time parameters that can turn off various plan types (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;). For instance, turning off sequential scans (&lt;code&gt;enable_seqscan&lt;/code&gt;) and nested-loop joins (&lt;code&gt;enable_nestloop&lt;/code&gt;), which are the most basic plans, will force the system to use a different plan. If the system still chooses a sequential scan or nested-loop join then there is probably a more fundamental reason why the index is not being used; for example, the query condition does not match the index. (What kind of query can use what kind of index is explained in the previous sections.)</source>
          <target state="translated">インデックスが使用されていない場合、テストでそれらを強制的に使用するのに役立ちます。さまざまな種類のプランをオフにできるランタイムパラメータがあります（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;セクション19.7.1を&lt;/a&gt;参照）。たとえば、最も基本的なプランである順次スキャン（ &lt;code&gt;enable_seqscan&lt;/code&gt; ）とネストループ結合（ &lt;code&gt;enable_nestloop&lt;/code&gt; ）をオフにすると、システムは強制的に別のプランを使用します。それでもシステムが順次スキャンまたはネストループ結合を選択する場合は、おそらくインデックスが使用されていないより根本的な理由があります。たとえば、クエリ条件がインデックスと一致しません。 （前のセクションで説明した種類のインデックスを使用できるクエリの種類。）</target>
        </trans-unit>
        <trans-unit id="9e50d0004d8680329345366b2774f5ebb4ad654f" translate="yes" xml:space="preserve">
          <source>When inserting a lot of data at the same time, consider using the &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. It is not as flexible as the &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; command, but is more efficient. Refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt; for more information on improving bulk loading performance.</source>
          <target state="translated">大量のデータを同時に挿入する場合は、&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;コマンドの使用を検討してください。&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;コマンドほど柔軟ではありませんが、より効率的です。バルクロードのパフォーマンスを向上させる方法の詳細については、&lt;a href=&quot;populate&quot;&gt;セクション14.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dfb95bd9b76a1aa6b1bb1f21c135d8d5ba87cb03" translate="yes" xml:space="preserve">
          <source>When issuing queries in a database where some users mistrust other users, observe security precautions from &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt; when writing function calls.</source>
          <target state="translated">一部のユーザーが他のユーザーを信頼していないデータベースでクエリを発行する場合は、関数呼び出しを作成するときに、&lt;a href=&quot;typeconv-func&quot;&gt;10.3項の&lt;/a&gt;セキュリティ対策を守ってください。</target>
        </trans-unit>
        <trans-unit id="4ed9176dec0c08e99a6d40ec733c0b7bac5bbcf2" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.17&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">評価順序を強制する必要がある場合は、 &lt;code&gt;CASE&lt;/code&gt; 構文（&lt;a href=&quot;functions-conditional&quot;&gt;セクション9.17を&lt;/a&gt;参照）を使用できます。たとえば、これは &lt;code&gt;WHERE&lt;/code&gt; 句でゼロによる除算を回避しようとする信頼できない方法です。</target>
        </trans-unit>
        <trans-unit id="f8882a94a7fafb56987fef2a0a2e2d4eb96df827" translate="yes" xml:space="preserve">
          <source>When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.18&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">When it is essential to force evaluation order, a &lt;code&gt;CASE&lt;/code&gt; construct (see &lt;a href=&quot;functions-conditional&quot;&gt;Section 9.18&lt;/a&gt;) can be used. For example, this is an untrustworthy way of trying to avoid division by zero in a &lt;code&gt;WHERE&lt;/code&gt; clause:</target>
        </trans-unit>
        <trans-unit id="d43ae9852bbd4e7fca0407119c0359f8ae17da03" translate="yes" xml:space="preserve">
          <source>When loading large amounts of data into an installation that uses WAL archiving or streaming replication, it might be faster to take a new base backup after the load has completed than to process a large amount of incremental WAL data. To prevent incremental WAL logging while loading, disable archiving and streaming replication, by setting &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; to &lt;code&gt;minimal&lt;/code&gt;, &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt; to &lt;code&gt;off&lt;/code&gt;, and &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; to zero. But note that changing these settings requires a server restart.</source>
          <target state="translated">WALアーカイブまたはストリーミングレプリケーションを使用するインストールに大量のデータをロードする場合、大量の増分WALデータを処理するよりも、ロードの完了後に新しい基本バックアップを作成する方が速い場合があります。ロード中の増分WALロギングを防ぐには、&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt;を &lt;code&gt;minimal&lt;/code&gt; に、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-MODE&quot;&gt;archive_mode&lt;/a&gt;を &lt;code&gt;off&lt;/code&gt; に、&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt;をゼロに設定して、アーカイブおよびストリーミングレプリケーションを無効にします。ただし、これらの設定を変更すると、サーバーを再起動する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a320947bd6f8b1714ed336d766e812f876be824d" translate="yes" xml:space="preserve">
          <source>When logging to event log is enabled, this parameter determines the program name used to identify PostgreSQL messages in the log. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">イベントログへのロギングが有効な場合、このパラメーターは、ログ内のPostgreSQLメッセージを識別するために使用されるプログラム名を決定します。デフォルトは &lt;code&gt;PostgreSQL&lt;/code&gt; です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="688b202e83ca61ee5187e2a33b6d2092af8c2739" translate="yes" xml:space="preserve">
          <source>When logging to syslog and this is on (the default), then each message will be prefixed by an increasing sequence number (such as &lt;code&gt;[2]&lt;/code&gt;). This circumvents the &amp;ldquo;--- last message repeated N times ---&amp;rdquo; suppression that many syslog implementations perform by default. In more modern syslog implementations, repeated message suppression can be configured (for example, &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; in rsyslog), so this might not be necessary. Also, you could turn this off if you actually want to suppress repeated messages.</source>
          <target state="translated">syslogにログを記録し、これがオン（デフォルト）になっている場合、各メッセージには、増加するシーケンス番号（ &lt;code&gt;[2]&lt;/code&gt; など）がプレフィックスとして付加されます。これにより、多くのsyslog実装がデフォルトで実行する「---最後のメッセージがN回繰り返された---」の抑制が回避されます。最新のsyslog実装では、繰り返しメッセージ抑制を構成できるため（たとえば、rsyslogの &lt;code&gt;$RepeatedMsgReduction&lt;/code&gt; ）、これは必要ない場合があります。また、実際に繰り返されるメッセージを抑制したい場合は、これをオフにすることができます。</target>
        </trans-unit>
        <trans-unit id="ba8a396481d44a42fb2aa24b4ad06150638300e9" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines how messages are delivered to syslog. When on (the default), messages are split by lines, and long lines are split so that they will fit into 1024 bytes, which is a typical size limit for traditional syslog implementations. When off, PostgreSQL server log messages are delivered to the syslog service as is, and it is up to the syslog service to cope with the potentially bulky messages.</source>
          <target state="translated">syslogへのロギングが有効な場合、このパラメータはsyslogへのメッセージの配信方法を決定します。オン(デフォルト)の場合、メッセージは行ごとに分割され、長い行は1024バイトに収まるように分割されます。オフの場合、PostgreSQLサーバのログメッセージはそのままsyslogサービスに配信されます。</target>
        </trans-unit>
        <trans-unit id="80ff0840aef3199452ea4eb2990b10a8d1c55939" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the program name used to identify PostgreSQL messages in syslog logs. The default is &lt;code&gt;postgres&lt;/code&gt;. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslogへのロギングが有効になっている場合、このパラメーターは、syslogログでPostgreSQLメッセージを識別するために使用されるプログラム名を決定します。デフォルトは &lt;code&gt;postgres&lt;/code&gt; です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="985b03993881f4457d8f0c3b34d9b7b01342f4d8" translate="yes" xml:space="preserve">
          <source>When logging to syslog is enabled, this parameter determines the syslog &amp;ldquo;facility&amp;rdquo; to be used. You can choose from &lt;code&gt;LOCAL0&lt;/code&gt;, &lt;code&gt;LOCAL1&lt;/code&gt;, &lt;code&gt;LOCAL2&lt;/code&gt;, &lt;code&gt;LOCAL3&lt;/code&gt;, &lt;code&gt;LOCAL4&lt;/code&gt;, &lt;code&gt;LOCAL5&lt;/code&gt;, &lt;code&gt;LOCAL6&lt;/code&gt;, &lt;code&gt;LOCAL7&lt;/code&gt;; the default is &lt;code&gt;LOCAL0&lt;/code&gt;. See also the documentation of your system's syslog daemon. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">syslogへのロギングが有効になっている場合、このパラメーターは、使用するsyslog「ファシリティ」を決定します。 &lt;code&gt;LOCAL0&lt;/code&gt; 、 &lt;code&gt;LOCAL1&lt;/code&gt; 、 &lt;code&gt;LOCAL2&lt;/code&gt; 、 &lt;code&gt;LOCAL3&lt;/code&gt; 、 &lt;code&gt;LOCAL4&lt;/code&gt; 、 &lt;code&gt;LOCAL5&lt;/code&gt; 、 &lt;code&gt;LOCAL6&lt;/code&gt; 、 &lt;code&gt;LOCAL7&lt;/code&gt; から選択できます。デフォルトは &lt;code&gt;LOCAL0&lt;/code&gt; です。システムのsyslogデーモンのドキュメントも参照してください。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="6d9a3edba4451cb3d18020f74c5a06ee8a7a52bd" translate="yes" xml:space="preserve">
          <source>When managing the server directly, you can control the type of shutdown by sending different signals to the &lt;code&gt;postgres&lt;/code&gt; process:</source>
          <target state="translated">When managing the server directly, you can control the type of shutdown by sending different signals to the &lt;code&gt;postgres&lt;/code&gt; process:</target>
        </trans-unit>
        <trans-unit id="b30985843aab3e94f2bd3bce331e8a5523cabcbb" translate="yes" xml:space="preserve">
          <source>When more than one expression is specified, the later values are used to sort rows that are equal according to the earlier values. Each expression can be followed by an optional &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; keyword to set the sort direction to ascending or descending. &lt;code&gt;ASC&lt;/code&gt; order is the default. Ascending order puts smaller values first, where &amp;ldquo;smaller&amp;rdquo; is defined in terms of the &lt;code&gt;&amp;lt;&lt;/code&gt; operator. Similarly, descending order is determined with the &lt;code&gt;&amp;gt;&lt;/code&gt; operator. &lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">複数の式を指定すると、後の値を使用して、前の値に従って等しい行をソートします。各式の後にオプションの &lt;code&gt;ASC&lt;/code&gt; または &lt;code&gt;DESC&lt;/code&gt; キーワードを続けて、ソート方向を昇順または降順に設定できます。 &lt;code&gt;ASC&lt;/code&gt; オーダーがデフォルトです。昇順では小さい値が最初に配置され、「より小さい」は &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子で定義されます。同様に、降順は &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子で決定されます。&lt;a href=&quot;#ftn.id-1.5.6.9.5.10&quot;&gt;&lt;sup id=&quot;id-1.5.6.9.5.10&quot;&gt;[5]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11912d8e839cffb71f2e5fc45344859e046a9cbc" translate="yes" xml:space="preserve">
          <source>When more than one row is specified, all the rows must have the same number of elements. The data types of the resulting table's columns are determined by combining the explicit or inferred types of the expressions appearing in that column, using the same rules as for &lt;code&gt;UNION&lt;/code&gt; (see &lt;a href=&quot;typeconv-union-case&quot;&gt;Section 10.5&lt;/a&gt;).</source>
          <target state="translated">複数の行を指定する場合、すべての行の要素数は同じでなければなりません。結果のテーブルの列のデータ型は、 &lt;code&gt;UNION&lt;/code&gt; と同じルールを使用して、その列に現れる式の明示的な型または推論された型を組み合わせることによって決定されます（&lt;a href=&quot;typeconv-union-case&quot;&gt;セクション10.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="dcff81a7a0194a63301c74dc5ce189cffc265222" translate="yes" xml:space="preserve">
          <source>When multiple policies apply to a given query, they are combined using either &lt;code&gt;OR&lt;/code&gt; (for permissive policies, which are the default) or using &lt;code&gt;AND&lt;/code&gt; (for restrictive policies). This is similar to the rule that a given role has the privileges of all roles that they are a member of. Permissive vs. restrictive policies are discussed further below.</source>
          <target state="translated">特定のクエリに複数のポリシーが適用される場合、それらは &lt;code&gt;OR&lt;/code&gt; （デフォルトの許可的なポリシーの場合）または &lt;code&gt;AND&lt;/code&gt; （制限的なポリシーの場合）を使用して結合されます。これは、特定のロールがメンバーであるすべてのロールの特権を持っているというルールに似ています。許容ポリシーと制限ポリシーについては、以下で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="269b9ef4adee76f3240604e5767201bc6ee01e71" translate="yes" xml:space="preserve">
          <source>When multiple policies of different command types apply to the same command (for example, &lt;code&gt;SELECT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; policies applied to an &lt;code&gt;UPDATE&lt;/code&gt; command), then the user must have both types of permissions (for example, permission to select rows from the relation as well as permission to update them). Thus the expressions for one type of policy are combined with the expressions for the other type of policy using the &lt;code&gt;AND&lt;/code&gt; operator.</source>
          <target state="translated">異なるコマンドタイプの複数のポリシーが同じコマンドに適用される場合（たとえば、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドに適用される &lt;code&gt;SELECT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; ポリシー）、ユーザーは両方のタイプの権限（たとえば、リレーションから行を選択する権限と、それらを更新する権限）。したがって、あるタイプのポリシーの式は、 &lt;code&gt;AND&lt;/code&gt; 演算子を使用して、他のタイプのポリシーの式と組み合わされます。</target>
        </trans-unit>
        <trans-unit id="556057cb09a8742cb36bd19c1657e03ac61a815b" translate="yes" xml:space="preserve">
          <source>When multiple policies of the same command type apply to the same command, then there must be at least one &lt;code&gt;PERMISSIVE&lt;/code&gt; policy granting access to the relation, and all of the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policies must pass. Thus all the &lt;code&gt;PERMISSIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;OR&lt;/code&gt;, all the &lt;code&gt;RESTRICTIVE&lt;/code&gt; policy expressions are combined using &lt;code&gt;AND&lt;/code&gt;, and the results are combined using &lt;code&gt;AND&lt;/code&gt;. If there are no &lt;code&gt;PERMISSIVE&lt;/code&gt; policies, then access is denied.</source>
          <target state="translated">同じコマンドタイプの複数のポリシーが同じコマンドに適用される場合、関係へのアクセスを許可する少なくとも1つの &lt;code&gt;PERMISSIVE&lt;/code&gt; ポリシーが必要であり、すべての &lt;code&gt;RESTRICTIVE&lt;/code&gt; ポリシーがパスする必要があります。したがって、すべての &lt;code&gt;PERMISSIVE&lt;/code&gt; ポリシー式は &lt;code&gt;OR&lt;/code&gt; を使用して結合され、すべての &lt;code&gt;RESTRICTIVE&lt;/code&gt; ポリシー式は &lt;code&gt;AND&lt;/code&gt; を使用して結合され、結果は &lt;code&gt;AND&lt;/code&gt; を使用して結合されます。 &lt;code&gt;PERMISSIVE&lt;/code&gt; ポリシーがない場合、アクセスは拒否されます。</target>
        </trans-unit>
        <trans-unit id="5d6d15be5ddf45a51b853b506d5d1a1d2068106c" translate="yes" xml:space="preserve">
          <source>When multiple window functions are used, all the window functions having syntactically equivalent &lt;code&gt;PARTITION BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt; clauses in their window definitions are guaranteed to be evaluated in a single pass over the data. Therefore they will see the same sort ordering, even if the &lt;code&gt;ORDER BY&lt;/code&gt; does not uniquely determine an ordering. However, no guarantees are made about the evaluation of functions having different &lt;code&gt;PARTITION BY&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; specifications. (In such cases a sort step is typically required between the passes of window function evaluations, and the sort is not guaranteed to preserve ordering of rows that its &lt;code&gt;ORDER BY&lt;/code&gt; sees as equivalent.)</source>
          <target state="translated">複数のウィンドウ関数を使用する場合、構文的に同等の &lt;code&gt;PARTITION BY&lt;/code&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句とORDER BY句をウィンドウ定義に持つすべてのウィンドウ関数は、データに対する単一のパスで評価されることが保証されます。したがって、 &lt;code&gt;ORDER BY&lt;/code&gt; が順序を一意に決定しない場合でも、同じソート順序が表示されます。ただし、 &lt;code&gt;PARTITION BY&lt;/code&gt; または &lt;code&gt;ORDER BY&lt;/code&gt; の仕様が異なる関数の評価については保証されません。 （このような場合、通常、ウィンドウ関数の評価のパス間で並べ替え手順が必要であり、その並べ替えは、その &lt;code&gt;ORDER BY&lt;/code&gt; が同等と見なす行の順序を保持することが保証されていません。）</target>
        </trans-unit>
        <trans-unit id="34f31d5224ac605a926f4e92907e12ec5add9474" translate="yes" xml:space="preserve">
          <source>When multiple workers are running, the autovacuum cost delay parameters (see &lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;Section 19.4.4&lt;/a&gt;) are &amp;ldquo;balanced&amp;rdquo; among all the running workers, so that the total I/O impact on the system is the same regardless of the number of workers actually running. However, any workers processing tables whose per-table &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; or &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; storage parameters have been set are not considered in the balancing algorithm.</source>
          <target state="translated">複数のワーカーが実行中の場合、自動バキュームコスト遅延パラメーター（&lt;a href=&quot;runtime-config-resource#RUNTIME-CONFIG-RESOURCE-VACUUM-COST&quot;&gt;セクション19.4.4を&lt;/a&gt;参照）は実行中のすべてのワーカー間で「バランスがとれ」ているため、実際に実行中のワーカーの数に関係なく、システムへのI / Oの影響の合計は同じです。ただし、テーブルごとに &lt;code&gt;autovacuum_vacuum_cost_delay&lt;/code&gt; または &lt;code&gt;autovacuum_vacuum_cost_limit&lt;/code&gt; ストレージパラメータが設定されているテーブルを処理するワーカーは、バランシングアルゴリズムでは考慮されません。</target>
        </trans-unit>
        <trans-unit id="84f11ff5e7225ec364ea450b05da5b31bd525923" translate="yes" xml:space="preserve">
          <source>When no final &lt;code&gt;ELSE&lt;/code&gt; clause is provided to a &lt;code&gt;CASE&lt;/code&gt;, the default value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; に最後の &lt;code&gt;ELSE&lt;/code&gt; 句が指定されていない場合、デフォルト値は &lt;code&gt;NULL&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cb2d002b299026c6a8e3abc29ae594e572a6b112" translate="yes" xml:space="preserve">
          <source>When non-serializable writes are possible, to ensure the current validity of a row and protect it against concurrent updates one must use &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or an appropriate &lt;code&gt;LOCK TABLE&lt;/code&gt; statement. (&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; lock just the returned rows against concurrent updates, while &lt;code&gt;LOCK TABLE&lt;/code&gt; locks the whole table.) This should be taken into account when porting applications to PostgreSQL from other environments.</source>
          <target state="translated">シリアライズ不可能な書き込みが可能な場合、行の現在の有効性を保証し、同時更新から保護するには、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 、または適切な &lt;code&gt;LOCK TABLE&lt;/code&gt; ステートメントを使用する必要があります。 （ &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; および &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; は、同時更新に対して返された行のみをロックしますが、 &lt;code&gt;LOCK TABLE&lt;/code&gt; はテーブル全体をロックします。）アプリケーションを他の環境からPostgreSQLに移植する場合は、これを考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="8d5d4ed5a8f5b52f15315d7a651b9128c1d498f8" translate="yes" xml:space="preserve">
          <source>When not all owned objects are to be transferred to the same successor owner, it's best to handle the exceptions manually and then perform the above steps to mop up.</source>
          <target state="translated">所有しているすべてのオブジェクトを同じ後継者に譲渡しない場合は、例外を手動で処理してから上記の手順を実行してモップアップするのがベストです。</target>
        </trans-unit>
        <trans-unit id="ed8afcb65f27d90b88c36a924e96931352e55b61" translate="yes" xml:space="preserve">
          <source>When not using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, the &lt;code&gt;column_definition&lt;/code&gt; list replaces the column alias list that could otherwise be attached to the &lt;code&gt;FROM&lt;/code&gt; item; the names in the column definitions serve as column aliases. When using the &lt;code&gt;ROWS FROM()&lt;/code&gt; syntax, a &lt;code&gt;column_definition&lt;/code&gt; list can be attached to each member function separately; or if there is only one member function and no &lt;code&gt;WITH ORDINALITY&lt;/code&gt; clause, a &lt;code&gt;column_definition&lt;/code&gt; list can be written in place of a column alias list following &lt;code&gt;ROWS FROM()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ROWS FROM()&lt;/code&gt; 構文を使用しない場合、 &lt;code&gt;column_definition&lt;/code&gt; リストは、 &lt;code&gt;FROM&lt;/code&gt; アイテムにアタッチできる列のエイリアスリストを置き換えます。列定義の名前は列のエイリアスとして機能します。 &lt;code&gt;ROWS FROM()&lt;/code&gt; 構文を使用する場合、 &lt;code&gt;column_definition&lt;/code&gt; リストを各メンバー関数に個別にアタッチできます。または、メンバー関数が1つだけあり、 &lt;code&gt;WITH ORDINALITY&lt;/code&gt; 句がない場合は、 &lt;code&gt;ROWS FROM()&lt;/code&gt; の後に列エイリアスリストの代わりに &lt;code&gt;column_definition&lt;/code&gt; リストを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="89c266fb8eeefdc22c382f51ddfa36d2cdf3fd08" translate="yes" xml:space="preserve">
          <source>When objects are created without specifying a particular target schema, they will be placed in the first valid schema named in &lt;code&gt;search_path&lt;/code&gt;. An error is reported if the search path is empty.</source>
          <target state="translated">特定のターゲットスキーマを指定せずにオブジェクトを作成すると、オブジェクトは &lt;code&gt;search_path&lt;/code&gt; で指定された最初の有効なスキーマに配置されます。検索パスが空の場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="99ff2ff0bf302907b157207503609b9e0138a5a9" translate="yes" xml:space="preserve">
          <source>When on, a warning is issued if a backslash (&lt;code&gt;\&lt;/code&gt;) appears in an ordinary string literal (&lt;code&gt;'...'&lt;/code&gt; syntax) and &lt;code&gt;standard_conforming_strings&lt;/code&gt; is off. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">オンの場合、通常の文字列リテラル（ &lt;code&gt;'...'&lt;/code&gt; 構文）にバックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）があり、 &lt;code&gt;standard_conforming_strings&lt;/code&gt; がオフの場合、警告が発行されます。デフォルトは &lt;code&gt;on&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a39a26ef7d5c306f15cfec242fa1908a71ae3775" translate="yes" xml:space="preserve">
          <source>When on, expressions of the form &lt;code&gt;expr = NULL&lt;/code&gt; (or &lt;code&gt;NULL = expr&lt;/code&gt;) are treated as &lt;code&gt;expr IS NULL&lt;/code&gt;, that is, they return true if &lt;code&gt;expr&lt;/code&gt; evaluates to the null value, and false otherwise. The correct SQL-spec-compliant behavior of &lt;code&gt;expr = NULL&lt;/code&gt; is to always return null (unknown). Therefore this parameter defaults to &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">オンの場合、 &lt;code&gt;expr = NULL&lt;/code&gt; （または &lt;code&gt;NULL = expr&lt;/code&gt; ）の形式の式は &lt;code&gt;expr IS NULL&lt;/code&gt; として扱われます。つまり、 &lt;code&gt;expr&lt;/code&gt; がnull値に評価される場合はtrueを返し、それ以外の場合はfalse を返します。 &lt;code&gt;expr = NULL&lt;/code&gt; の正しいSQL仕様準拠の動作は、常にnull（不明）を返すことです。したがって、このパラメーターのデフォルトは &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bd83814e734e8771d44c1de9842876866f19a1c6" translate="yes" xml:space="preserve">
          <source>When on, the parser will emit a warning for any construct that might have changed meanings since PostgreSQL 9.4 as a result of changes in operator precedence. This is useful for auditing applications to see if precedence changes have broken anything; but it is not meant to be kept turned on in production, since it will warn about some perfectly valid, standard-compliant SQL code. The default is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">オンの場合、パーサーは、演算子の優先順位の変更の結果としてPostgreSQL 9.4以降に意味が変更された可能性のある構成要素に対して警告を発行します。これは、優先順位の変更によって何かが壊れていないかアプリケーションを監査するのに役立ちます。ただし、完全に有効な標準に準拠したSQLコードについて警告するため、本番環境で有効にしておくことは意図されていません。デフォルトは &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f61f3e69afe30c64a291d60390d7c29326445c47" translate="yes" xml:space="preserve">
          <source>When operators and support functions are added to a family with &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt;, they are not part of any specific operator class within the family, but are just &amp;ldquo;loose&amp;rdquo; within the family. This indicates that these operators and functions are compatible with the family's semantics, but are not required for correct functioning of any specific index. (Operators and functions that are so required should be declared as part of an operator class, instead; see &lt;a href=&quot;sql-createopclass&quot;&gt;CREATE OPERATOR CLASS&lt;/a&gt;.) PostgreSQL will allow loose members of a family to be dropped from the family at any time, but members of an operator class cannot be dropped without dropping the whole class and any indexes that depend on it. Typically, single-data-type operators and functions are part of operator classes because they are needed to support an index on that specific data type, while cross-data-type operators and functions are made loose members of the family.</source>
          <target state="translated">オペレーターとサポート関数が &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; を使用してファミリーに追加された場合、それらはファミリー内の特定のオペレータークラスの一部ではなく、ファミリー内で「ルーズ」になっています。これは、これらの演算子と関数がファミリのセマンティクスと互換性があることを示していますが、特定のインデックスを正しく機能させるためには必要ありません。 （必要な演算子と関数は、代わりに演算子クラスの一部として宣言する必要があります&lt;a href=&quot;sql-createopclass&quot;&gt;。CREATEOPERATOR CLASSを&lt;/a&gt;参照してください。。）PostgreSQLでは、ファミリーの緩いメンバーをいつでもファミリーから削除できますが、演算子クラスのメンバーは、クラス全体とそれに依存するインデックスを削除しないと削除できません。通常、単一のデータ型の演算子と関数は、特定のデータ型のインデックスをサポートする必要があるため、演算子クラスの一部ですが、クロスデータ型の演算子と関数は、ファミリーの緩いメンバーになります。</target>
        </trans-unit>
        <trans-unit id="0f2ad4b5a54137b2f0c70ae82420f67c0b1b6ea3" translate="yes" xml:space="preserve">
          <source>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</source>
          <target state="translated">クエリや更新が単一パーティションの大きな割合でアクセスする場合、インデックスやテーブル全体に散在するランダムアクセスリードを使用する代わりに、そのパーティションのシーケンシャルスキャンを利用することで、パフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="2540d43e50d1abeb1a847d9db340690266815c23" translate="yes" xml:space="preserve">
          <source>When relying on Serializable transactions to prevent anomalies, it is important that any data read from a permanent user table not be considered valid until the transaction which read it has successfully committed. This is true even for read-only transactions, except that data read within a &lt;em&gt;deferrable&lt;/em&gt; read-only transaction is known to be valid as soon as it is read, because such a transaction waits until it can acquire a snapshot guaranteed to be free from such problems before starting to read any data. In all other cases applications must not depend on results read during a transaction that later aborted; instead, they should retry the transaction until it succeeds.</source>
          <target state="translated">異常を防止するためにシリアライズ可能なトランザクションに依存する場合、永続的なユーザーテーブルから読み取られたデータは、それを読み取ったトランザクションが正常にコミットするまで有効と見なされないことが重要です。これは、読み取り専用トランザクションにも当てはまります。ただし、&lt;em&gt;遅延可能な&lt;/em&gt;読み取り専用トランザクション内で読み取られたデータは、読み取られるとすぐに有効になることがわかっています。データの読み取りを開始する前の問題。他のすべてのケースでは、アプリケーションは、後で中止されたトランザクション中に読み取られた結果に依存してはなりません。代わりに、成功するまでトランザクションを再試行する必要があります。</target>
        </trans-unit>
        <trans-unit id="0f545c1f8d440a6a74e5e5cae7b49a8321ce778e" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE FUNCTION&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">繰り返し &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 呼び出しが同じオブジェクトファイルを参照する場合、ファイルはセッションごとに1回だけロードされます。（おそらく開発中に）ファイルをアンロードして再ロードするには、新しいセッションを開始します。</target>
        </trans-unit>
        <trans-unit id="63cb3d013e86db6ef5ef57500326cdf863814f3a" translate="yes" xml:space="preserve">
          <source>When repeated &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; calls refer to the same object file, the file is only loaded once per session. To unload and reload the file (perhaps during development), start a new session.</source>
          <target state="translated">繰り返される &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 呼び出しが同じオブジェクトファイルを参照する場合、ファイルはセッションごとに1回だけロードされます。（おそらく開発中に）ファイルをアンロードして再ロードするには、新しいセッションを開始します。</target>
        </trans-unit>
        <trans-unit id="b358e9fc6a1b297fd0b37a45eac263be99236636" translate="yes" xml:space="preserve">
          <source>When replacing an existing definition, the argument types, result type, and number of direct arguments may not be changed. Also, the new definition must be of the same kind (ordinary aggregate, ordered-set aggregate, or hypothetical-set aggregate) as the old one.</source>
          <target state="translated">既存の定義を置き換える場合、引数の型、結果の型、直接引数の数は変更できません。また、新しい定義は、古い定義と同じ種類のもの(通常の集合体、順序付き集合体、または仮説集合体)でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf16a952f545e26cfee0e603603bfd07e12cf881" translate="yes" xml:space="preserve">
          <source>When replacing an existing function with &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt;, there are restrictions on changing parameter names. You cannot change the name already assigned to any input parameter (although you can add names to parameters that had none before). If there is more than one output parameter, you cannot change the names of the output parameters, because that would change the column names of the anonymous composite type that describes the function's result. These restrictions are made to ensure that existing calls of the function do not stop working when it is replaced.</source>
          <target state="translated">既存の関数を &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; で置き換える場合、パラメーター名の変更には制限があります。入力パラメーターに既に割り当てられている名前を変更することはできません（以前に名前がなかったパラメーターに名前を追加することはできます）。複数の出力パラメーターがある場合、出力パラメーターの名前を変更することはできません。これにより、関数の結果を説明する匿名の複合型の列名が変更されるためです。これらの制限は、関数の既存の呼び出しが置き換えられたときに機能を停止しないようにするために行われます。</target>
        </trans-unit>
        <trans-unit id="c4f24499d5667a6f6b8b67600774aa56a3d4c33d" translate="yes" xml:space="preserve">
          <source>When replicating between partitioned tables, the actual replication originates, by default, from the leaf partitions on the publisher, so partitions on the publisher must also exist on the subscriber as valid target tables. (They could either be leaf partitions themselves, or they could be further subpartitioned, or they could even be independent tables.) Publications can also specify that changes are to be replicated using the identity and schema of the partitioned root table instead of that of the individual leaf partitions in which the changes actually originate (see &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;).</source>
          <target state="translated">When replicating between partitioned tables, the actual replication originates, by default, from the leaf partitions on the publisher, so partitions on the publisher must also exist on the subscriber as valid target tables. (They could either be leaf partitions themselves, or they could be further subpartitioned, or they could even be independent tables.) Publications can also specify that changes are to be replicated using the identity and schema of the partitioned root table instead of that of the individual leaf partitions in which the changes actually originate (see &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="80773f67cc3b08f5dcb6c36638c7da08b5a16582" translate="yes" xml:space="preserve">
          <source>When requesting synchronous replication, each commit of a write transaction will wait until confirmation is received that the commit has been written to the write-ahead log on disk of both the primary and standby server. The only possibility that data can be lost is if both the primary and the standby suffer crashes at the same time. This can provide a much higher level of durability, though only if the sysadmin is cautious about the placement and management of the two servers. Waiting for confirmation increases the user's confidence that the changes will not be lost in the event of server crashes but it also necessarily increases the response time for the requesting transaction. The minimum wait time is the round-trip time between primary to standby.</source>
          <target state="translated">同期レプリケーションを要求する場合、書き込みトランザクションの各コミットは、プライマリサーバとスタンバイサーバの両方のディスク上の書き込み先ログにコミットが書き込まれたことが確認されるまで待機します。データが失われる可能性があるのは、プライマリサーバとスタンバイサーバの両方が同時にクラッシュした場合だけです。これは、システム管理者が2つのサーバの配置と管理に慎重である場合に限りますが、より高いレベルの耐久性を提供することができます。確認を待つことで、サーバがクラッシュしても変更が失われないというユーザの信頼感が高まりますが、要求したトランザクションの応答時間も必然的に長くなります。最小の待ち時間は、プライマリからスタンバイまでの往復時間である。</target>
        </trans-unit>
        <trans-unit id="7cbfd2d18fb6178afa3088b0725b2bc3fcdf04fe" translate="yes" xml:space="preserve">
          <source>When restoring data to a pre-existing table and the option &lt;code&gt;--disable-triggers&lt;/code&gt; is used, pg_restore emits commands to disable triggers on user tables before inserting the data, then emits commands to re-enable them after the data has been inserted. If the restore is stopped in the middle, the system catalogs might be left in the wrong state.</source>
          <target state="translated">既存のテーブルにデータを復元し、オプション &lt;code&gt;--disable-triggers&lt;/code&gt; を使用する場合、pg_restoreは、データを挿入する前にユーザーテーブルのトリガーを無効にするコマンドを発行し、データが挿入された後で再度有効にするコマンドを発行します。復元が途中で停止した場合、システムカタログが誤った状態のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ade7c8c975218ba23dcef154671330d11fa5728d" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt;.</source>
          <target state="translated">ロールのメンバーシップを取り消す場合、 &lt;code&gt;GRANT OPTION&lt;/code&gt; は代わりに &lt;code&gt;ADMIN OPTION&lt;/code&gt; と呼ばれますが、動作は似ています。この形式のコマンドでは、ノイズワード &lt;code&gt;GROUP&lt;/code&gt; が許可されないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="2378e777cb7029b72a32e416964ca17fb134eb03" translate="yes" xml:space="preserve">
          <source>When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt;, but the behavior is similar. This form of the command also allows a &lt;code&gt;GRANTED BY&lt;/code&gt; option, but that option is currently ignored (except for checking the existence of the named role). Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt;.</source>
          <target state="translated">When revoking membership in a role, &lt;code&gt;GRANT OPTION&lt;/code&gt; is instead called &lt;code&gt;ADMIN OPTION&lt;/code&gt; , but the behavior is similar. This form of the command also allows a &lt;code&gt;GRANTED BY&lt;/code&gt; option, but that option is currently ignored (except for checking the existence of the named role). Note also that this form of the command does not allow the noise word &lt;code&gt;GROUP&lt;/code&gt; in &lt;code&gt;role_specification&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68adac31376cf57c26d631be30fdfc9650022d2" translate="yes" xml:space="preserve">
          <source>When revoking privileges on a table, the corresponding column privileges (if any) are automatically revoked on each column of the table, as well. On the other hand, if a role has been granted privileges on a table, then revoking the same privileges from individual columns will have no effect.</source>
          <target state="translated">テーブル上の特権を取り消す場合、対応するカラムの特権(もしあれば)は、テーブルの各カラムも同様に自動的に取り消されます。一方、あるロールがテーブル上で特権を付与されている場合、個々の列から同じ特権を取り消すことは何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="300dad807edac8d993f28c0997a914c75b99f4bc" translate="yes" xml:space="preserve">
          <source>When rounding values, the &lt;code&gt;numeric&lt;/code&gt; type rounds ties away from zero, while (on most machines) the &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;double precision&lt;/code&gt; types round ties to the nearest even number. For example:</source>
          <target state="translated">値を丸める場合、 &lt;code&gt;numeric&lt;/code&gt; 型はゼロから離れて丸められますが、（ほとんどのマシンでは） &lt;code&gt;real&lt;/code&gt; および &lt;code&gt;double precision&lt;/code&gt; 型は、最も近い偶数に丸められます。例えば：</target>
        </trans-unit>
        <trans-unit id="5f76f7c7b77ca49ded558a0639a8d27cc09a3811" translate="yes" xml:space="preserve">
          <source>When row security is enabled on a table (with &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITY&lt;/a&gt;), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as &lt;code&gt;TRUNCATE&lt;/code&gt; and &lt;code&gt;REFERENCES&lt;/code&gt;, are not subject to row security.</source>
          <target state="translated">テーブルで行セキュリティが有効になっている場合（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE ... ENABLE ROW LEVEL SECURITYを使用&lt;/a&gt;）、行を選択または変更するためのテーブルへの通常のアクセスはすべて、行セキュリティポリシーによって許可される必要があります。（ただし、テーブルの所有者は通常、行のセキュリティポリシーの対象ではありません。）テーブルにポリシーが存在しない場合、default-denyポリシーが使用されます。これは、行が表示されない、または変更できないことを意味します。 &lt;code&gt;TRUNCATE&lt;/code&gt; や &lt;code&gt;REFERENCES&lt;/code&gt; など、テーブル全体に適用される操作は、行セキュリティの対象ではありません。</target>
        </trans-unit>
        <trans-unit id="226f5e12ea7fb1c629a76bb1b3cc1943cd4502fc" translate="yes" xml:space="preserve">
          <source>When running a long test on hardware that can handle a lot of transactions, the log files can become very large. The &lt;code&gt;--sampling-rate&lt;/code&gt; option can be used to log only a random sample of transactions.</source>
          <target state="translated">多くのトランザクションを処理できるハードウェアで長いテストを実行すると、ログファイルが非常に大きくなる可能性があります。 &lt;code&gt;--sampling-rate&lt;/code&gt; オプションは、トランザクションの唯一のランダムなサンプルを記録するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4051fc47591e058546d74bee2aa79ca3ea360af8" translate="yes" xml:space="preserve">
          <source>When running a standby server, you must set this parameter to the same or higher value than on the master server. Otherwise, queries will not be allowed in the standby server.</source>
          <target state="translated">待機サーバーを実行する場合は、このパラメータをマスターサーバーと同じかそれ以上の値に設定する必要があります。そうしないと、待機サーバでのクエリは許可されません。</target>
        </trans-unit>
        <trans-unit id="0becdbc99cfe7674fb7d475f00ec87ca3a5a28cc" translate="yes" xml:space="preserve">
          <source>When running at the &lt;code&gt;serializable&lt;/code&gt; isolation level, a deferrable read-only SQL transaction may be delayed before it is allowed to proceed. However, once it begins executing it does not incur any of the overhead required to ensure serializability; so serialization code will have no reason to force it to abort because of concurrent updates, making this option suitable for long-running read-only transactions.</source>
          <target state="translated">&lt;code&gt;serializable&lt;/code&gt; 可能な分離レベルで実行している場合、遅延可能な読み取り専用SQLトランザクションは、続行する前に遅延する可能性があります。ただし、実行が開始されると、シリアライザビリティを確保するために必要なオーバーヘッドは発生しません。そのため、同時更新のためにシリアライゼーションコードに強制的に強制終了させる理由はなく、このオプションは長時間実行される読み取り専用トランザクションに適しています。</target>
        </trans-unit>
        <trans-unit id="d1a67057ea54f0f16f47cefbf38d78344e7ecca6" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;on&lt;/code&gt;, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to &lt;code&gt;interactive&lt;/code&gt;, such errors are only ignored in interactive sessions, and not when reading script files. When set to &lt;code&gt;off&lt;/code&gt; (the default), a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit &lt;code&gt;SAVEPOINT&lt;/code&gt; for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; に設定すると、トランザクションブロックのステートメントがエラーを生成した場合、エラーは無視され、トランザクションが続行されます。 &lt;code&gt;interactive&lt;/code&gt; に設定すると、そのようなエラーはインタラクティブセッションでのみ無視され、スクリプトファイルの読み取り時には無視されません。設定すると &lt;code&gt;off&lt;/code&gt; （デフォルト）、エラーが発生したトランザクションブロック内の文は、トランザクション全体を中止します。エラーロールバックモードは、トランザクションブロック内の各コマンドの直前に暗黙の &lt;code&gt;SAVEPOINT&lt;/code&gt; を発行し、コマンドが失敗した場合にセーブポイントにロールバックすることで機能します。</target>
        </trans-unit>
        <trans-unit id="549604915bc0a6d5cfb5cf7a10c720e97be80363" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;remote_apply&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s), and also written to durable storage on the standbys. This will cause much larger commit delays than previous settings since it waits for WAL replay. When set to &lt;code&gt;on&lt;/code&gt;, commits wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to durable storage. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_write&lt;/code&gt;, commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it to their file systems. This setting ensures data preservation if a standby instance of PostgreSQL crashes, but not if the standby suffers an operating-system-level crash because the data has not necessarily reached durable storage on the standby. The setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is usually not desirable when synchronous replication is in use, but is provided for completeness.</source>
          <target state="translated">When set to &lt;code&gt;remote_apply&lt;/code&gt; , commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and applied it, so that it has become visible to queries on the standby(s), and also written to durable storage on the standbys. This will cause much larger commit delays than previous settings since it waits for WAL replay. When set to &lt;code&gt;on&lt;/code&gt; , commits wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and flushed it to durable storage. This ensures the transaction will not be lost unless both the primary and all synchronous standbys suffer corruption of their database storage. When set to &lt;code&gt;remote_write&lt;/code&gt; , commits will wait until replies from the current synchronous standby(s) indicate they have received the commit record of the transaction and written it to their file systems. This setting ensures data preservation if a standby instance of PostgreSQL crashes, but not if the standby suffers an operating-system-level crash because the data has not necessarily reached durable storage on the standby. The setting &lt;code&gt;local&lt;/code&gt; causes commits to wait for local flush to disk, but not for replication. This is usually not desirable when synchronous replication is in use, but is provided for completeness.</target>
        </trans-unit>
        <trans-unit id="43e9cba78fc8dadeb25eba89d19fc5d8c6ee61b8" translate="yes" xml:space="preserve">
          <source>When set to off, which is the default, PostgreSQL will raise a PANIC-level error on failure to flush modified data files to the file system. This causes the database server to crash. This parameter can only be set at server start.</source>
          <target state="translated">デフォルトのoffに設定されている場合、PostgreSQLは変更されたデータファイルをファイルシステムにフラッシュできなかった場合にPANICレベルのエラーを発生させます。これにより、データベースサーバがクラッシュします。このパラメータはサーバ起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="6cbaca794cc78ed3c2b124781f712501c0ff4934" translate="yes" xml:space="preserve">
          <source>When set to on, which is the default, PostgreSQL will automatically reinitialize after a backend crash. Leaving this value set to on is normally the best way to maximize the availability of the database. However, in some circumstances, such as when PostgreSQL is being invoked by clusterware, it may be useful to disable the restart so that the clusterware can gain control and take any actions it deems appropriate.</source>
          <target state="translated">デフォルトのonに設定されている場合、PostgreSQLはバックエンドがクラッシュした後に自動的に再初期化します。通常、この値をonに設定したままにしておくことが、データベースの可用性を最大化する最良の方法です。しかし、クラスタウェアによってPostgreSQLが起動されているような状況では、クラスタウェアが制御して適切と思われるアクションを取ることができるように、再起動を無効にすることが有用な場合があります。</target>
        </trans-unit>
        <trans-unit id="a7b55871d6d7b3f171d441751dee834b0868dec6" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;debug_pretty_print&lt;/code&gt; indents the messages produced by &lt;code&gt;debug_print_parse&lt;/code&gt;, &lt;code&gt;debug_print_rewritten&lt;/code&gt;, or &lt;code&gt;debug_print_plan&lt;/code&gt;. This results in more readable but much longer output than the &amp;ldquo;compact&amp;rdquo; format used when it is off. It is on by default.</source>
          <target state="translated">設定すると、 &lt;code&gt;debug_pretty_print&lt;/code&gt; は、 &lt;code&gt;debug_print_parse&lt;/code&gt; 、 &lt;code&gt;debug_print_rewritten&lt;/code&gt; 、または &lt;code&gt;debug_print_plan&lt;/code&gt; によって生成されたメッセージをインデントします。これにより、オフのときに使用される「コンパクト」形式よりも読みやすくなりますが、出力ははるかに長くなります。デフォルトではオンになっています。</target>
        </trans-unit>
        <trans-unit id="9655c6cce4ab0fb89202aa42165255e7c2310c07" translate="yes" xml:space="preserve">
          <source>When setting any of these parameters, a relative path will be interpreted with respect to the directory in which &lt;code&gt;postgres&lt;/code&gt; is started.</source>
          <target state="translated">これらのパラメーターのいずれかを設定すると、 &lt;code&gt;postgres&lt;/code&gt; が起動されたディレクトリを基準にして相対パスが解釈されます。</target>
        </trans-unit>
        <trans-unit id="f5cba5ccebd44827dbe97e5c58205ecd19cd5549" translate="yes" xml:space="preserve">
          <source>When several data types share near-identical sorting semantics, their operator classes can be grouped into an operator family. Doing so is advantageous because it allows the planner to make deductions about cross-type comparisons. Each operator class within the family should contain the single-type operators (and associated support functions) for its input data type, while cross-type comparison operators and support functions are &amp;ldquo;loose&amp;rdquo; in the family. It is recommendable that a complete set of cross-type operators be included in the family, thus ensuring that the planner can represent any comparison conditions that it deduces from transitivity.</source>
          <target state="translated">複数のデータ型がほぼ同一のソートセマンティクスを共有する場合、それらの演算子クラスを演算子ファミリーにグループ化できます。そうすることは、プランナがクロスタイプ比較について推論を行うことを可能にするので有利です。ファミリー内の各演算子クラスには、入力データ型の単一タイプの演算子（および関連するサポート関数）が含まれている必要がありますが、クロスタイプ比較演算子とサポート関数は、ファミリーでは「ルーズ」です。クロスタイプ演算子の完全なセットをファミリに含めることをお勧めします。これにより、プランナが推移性から推定する比較条件を確実に表すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="cb221d1e490779006a131832600e7b4ca11a22c2" translate="yes" xml:space="preserve">
          <source>When showing progress (option &lt;code&gt;-P&lt;/code&gt;), use a timestamp (Unix epoch) instead of the number of seconds since the beginning of the run. The unit is in seconds, with millisecond precision after the dot. This helps compare logs generated by various tools.</source>
          <target state="translated">進行状況を表示する場合（オプション &lt;code&gt;-P&lt;/code&gt; ）、実行開始からの秒数の代わりにタイムスタンプ（Unixエポック）を使用します。単位は秒で、ドットの後にミリ秒の精度があります。これは、さまざまなツールによって生成されたログを比較するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cc026cecf0c9d705d368f497265f6e7182739df8" translate="yes" xml:space="preserve">
          <source>When sorting &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; data types, IPv4 addresses will always sort before IPv6 addresses, including IPv4 addresses encapsulated or mapped to IPv6 addresses, such as ::10.2.3.4 or ::ffff:10.4.3.2.</source>
          <target state="translated">&lt;code&gt;inet&lt;/code&gt; または &lt;code&gt;cidr&lt;/code&gt; データ型をソートする場合、IPv4アドレスは、IPv6アドレスの前に常にソートされます。これには、カプセル化またはIPv6アドレスにマップされたIPv4アドレスが含まれます（:: 10.2.3.4や:: ffff：10.4.3.2など）。</target>
        </trans-unit>
        <trans-unit id="00112c1a0dfb2756ee57aac0f953ab1b28e8aa6b" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use a particular collation in order to be matched during inference. Typically this is omitted, as collations usually do not affect whether or not a constraint violation occurs. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">指定した場合、対応する &lt;code&gt;index_column_name&lt;/code&gt; または &lt;code&gt;index_expression&lt;/code&gt; が特定の照合を使用して推論中に照合されるように強制します。通常、照合は制約違反が発生するかどうかに影響しないため、これは省略されます。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。</target>
        </trans-unit>
        <trans-unit id="49ab9aed56a17743958b35c4487c001e52ad9448" translate="yes" xml:space="preserve">
          <source>When specified, mandates that corresponding &lt;code&gt;index_column_name&lt;/code&gt; or &lt;code&gt;index_expression&lt;/code&gt; use particular operator class in order to be matched during inference. Typically this is omitted, as the &lt;em&gt;equality&lt;/em&gt; semantics are often equivalent across a type's operator classes anyway, or because it's sufficient to trust that the defined unique indexes have the pertinent definition of equality. Follows &lt;code&gt;CREATE INDEX&lt;/code&gt; format.</source>
          <target state="translated">指定した場合、対応する &lt;code&gt;index_column_name&lt;/code&gt; または &lt;code&gt;index_expression&lt;/code&gt; が特定の演算子クラスを使用して推論中に照合されるように強制します。通常、これは省略されます。これは、&lt;em&gt;等価の&lt;/em&gt;セマンティクスが多くの場合、型の演算子クラス全体で同等であるため、または定義された一意のインデックスに等価の適切な定義があることを信頼するのに十分であるためです。 &lt;code&gt;CREATE INDEX&lt;/code&gt; 形式に従います。</target>
        </trans-unit>
        <trans-unit id="cb6cddffb6a42656d1b6071c587cfd75339041b2" translate="yes" xml:space="preserve">
          <source>When specifying a function by name rather than by OID, the allowed input is the same as for the &lt;code&gt;regprocedure&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). An example is:</source>
          <target state="translated">When specifying a function by name rather than by OID, the allowed input is the same as for the &lt;code&gt;regprocedure&lt;/code&gt; data type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;). An example is:</target>
        </trans-unit>
        <trans-unit id="f47b14844e6f65e1969fe664f76645a83ada8978" translate="yes" xml:space="preserve">
          <source>When specifying the &lt;code&gt;program&lt;/code&gt; option, keep in mind that the option string is executed by the shell. If you need to pass any arguments to the command that come from an untrusted source, you must be careful to strip or escape any characters that might have special meaning to the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; オプションを指定するときは、オプション文字列がシェルによって実行されることに注意してください。信頼できないソースからの引数をコマンドに渡す必要がある場合は、シェルにとって特別な意味を持つ可能性のある文字を削除またはエスケープするように注意する必要があります。セキュリティ上の理由から、固定のコマンド文字列を使用するか、少なくともユーザー入力を渡さないようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a86f4916e3e42d9bf0f446f6ed8f6c9365f0b9b8" translate="yes" xml:space="preserve">
          <source>When starting a client session via libpq, parameter settings can be specified using the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable. Settings established in this way constitute defaults for the life of the session, but do not affect other sessions. For historical reasons, the format of &lt;code&gt;PGOPTIONS&lt;/code&gt; is similar to that used when launching the &lt;code&gt;postgres&lt;/code&gt; command; specifically, the &lt;code&gt;-c&lt;/code&gt; flag must be specified. For example,</source>
          <target state="translated">libpqを介してクライアントセッションを開始するとき、パラメーター設定は &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を使用して指定できます。この方法で確立された設定は、セッションの存続期間のデフォルトになりますが、他のセッションには影響しません。歴史的な理由から、 &lt;code&gt;PGOPTIONS&lt;/code&gt; の形式は &lt;code&gt;postgres&lt;/code&gt; コマンドを起動するときに使用される形式と似ています。具体的には、 &lt;code&gt;-c&lt;/code&gt; フラグを指定する必要があります。例えば、</target>
        </trans-unit>
        <trans-unit id="8b3e57832327b1f4cd35e9869284543eb2583802" translate="yes" xml:space="preserve">
          <source>When starting the target, PostgreSQL replays all the required WAL, resulting in a data directory in a consistent state.</source>
          <target state="translated">ターゲットを起動すると、PostgreSQLは必要なWALをすべて再生し、結果として一貫した状態のデータディレクトリを生成します。</target>
        </trans-unit>
        <trans-unit id="80810b3a36d5394cd36078211fe98f572205f903" translate="yes" xml:space="preserve">
          <source>When suitable, query results can be shown in a crosstab representation with the &lt;code&gt;\crosstabview&lt;/code&gt; command:</source>
          <target state="translated">必要に応じて、 &lt;code&gt;\crosstabview&lt;/code&gt; コマンドを使用して、クエリ結果をクロス集計表現で表示できます。</target>
        </trans-unit>
        <trans-unit id="4333b702c3660525cc0e63ef6d85c05931c74735" translate="yes" xml:space="preserve">
          <source>When tar format is used, it is the user's responsibility to unpack each tar file before starting a PostgreSQL server that uses the data. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">When tar format is used, it is the user's responsibility to unpack each tar file before starting a PostgreSQL server that uses the data. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</target>
        </trans-unit>
        <trans-unit id="a4ddbde0da0e9c11c9f3ba6aaa05f9fc0b15fe03" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">When tar format is used, the write-ahead log files will be included in the &lt;code&gt;base.tar&lt;/code&gt; file.</target>
        </trans-unit>
        <trans-unit id="7e8dcb5224676a60278f816ad09b8db2eb2d49b5" translate="yes" xml:space="preserve">
          <source>When tar format is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">When tar format is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a46f34ffb8c110010cfd3fe050b49b5689c1e534" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, it is the user's responsibility to unpack each tar file before starting the PostgreSQL server. If there are additional tablespaces, the tar files for them need to be unpacked in the correct locations. In this case the symbolic links for those tablespaces will be created by the server according to the contents of the &lt;code&gt;tablespace_map&lt;/code&gt; file that is included in the &lt;code&gt;base.tar&lt;/code&gt; file.</source>
          <target state="translated">tar形式モードを使用する場合、PostgreSQLサーバーを起動する前に各tarファイルを解凍するのはユーザーの責任です。追加のテーブルスペースがある場合は、それらのtarファイルを正しい場所に解凍する必要があります。この場合、これらのテーブルスペースのシンボリックリンクは、 &lt;code&gt;base.tar&lt;/code&gt; ファイルに含まれている &lt;code&gt;tablespace_map&lt;/code&gt; ファイルの内容に従ってサーバーによって作成されます。</target>
        </trans-unit>
        <trans-unit id="34c7d99e4e21933c48e46c135fcf1d89d1aca09e" translate="yes" xml:space="preserve">
          <source>When tar format mode is used, the write-ahead log files will be written to a separate file named &lt;code&gt;pg_wal.tar&lt;/code&gt; (if the server is a version earlier than 10, the file will be named &lt;code&gt;pg_xlog.tar&lt;/code&gt;).</source>
          <target state="translated">tar形式モードを使用する場合は、先行書き込みログファイルの名前の別のファイルに書き込まれます &lt;code&gt;pg_wal.tar&lt;/code&gt; （サーバは前のバージョン10以上であれば、ファイルが名前になります &lt;code&gt;pg_xlog.tar&lt;/code&gt; ）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
