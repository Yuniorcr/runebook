<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d835303635997cc515233b553b202dd2ca61cd9f" translate="yes" xml:space="preserve">
          <source>More generically, a relation is a set of tuples; for example, the result of a query is also a relation.</source>
          <target state="translated">より一般的には、関係はタプルの集合です。例えば、クエリの結果も関係です。</target>
        </trans-unit>
        <trans-unit id="e5ff6c49fed97ba21bc443a8e95921cd7fef478d" translate="yes" xml:space="preserve">
          <source>More generically, the term &lt;em&gt;schema&lt;/em&gt; is used to mean all data descriptions (&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; definitions, &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraints&lt;/a&gt;, comments, etc) for a given &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; or subset thereof.</source>
          <target state="translated">より一般的には、&lt;em&gt;スキーマ&lt;/em&gt;という用語は、特定の&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;またはそのサブセットのすべてのデータ記述（&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;定義、&lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;制約&lt;/a&gt;、コメントなど）を意味するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c771e450e93955920d70db2f3a188ef32edea882" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">部分インデックスの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;、&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc9aa3892ba23ddac98c416e33335aa51d42e075" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">部分インデックスの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;、&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;、および&lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SESHADRI95&quot;&gt;[seshadri95]を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f9300c1996c675687b056f93327336beacca1fbf" translate="yes" xml:space="preserve">
          <source>More information about the lock modes and locking strategies can be found in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">ロックモードとロック方法の詳細については、&lt;a href=&quot;explicit-locking&quot;&gt;セクション13.3を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef70336c8dc9c2d758937dd2be0326ac89265cd4" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">データの更新と削除の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6章を&lt;/a&gt;参照してください。&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEの&lt;/a&gt;リファレンスドキュメントの外部キー制約構文の説明もご覧ください。</target>
        </trans-unit>
        <trans-unit id="cadcf76a3de36d133ed36e25753f765d08135f4c" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">データの更新と削除の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;第6章を&lt;/a&gt;参照してください。&lt;a href=&quot;sql-createtable&quot;&gt;CREATETABLEの&lt;/a&gt;リファレンスドキュメントの外部キー制約構文の説明も参照してください。</target>
        </trans-unit>
        <trans-unit id="e689fb0c34bef953cc6f900b699843e5aff59cf5" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">ウィンドウ関数の詳細については、&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.21&lt;/a&gt;、および&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;セクション7.2.5を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="910afb407202e4aaa34247efa3cbb1ddac8f9709" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">ウィンドウ関数の詳細については、&lt;a href=&quot;tutorial-window&quot;&gt;セクション3.5&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.22&lt;/a&gt;、および&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;セクション7.2.5を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b29b35804e6bc278cd58dd861059bfbd8e576bad" translate="yes" xml:space="preserve">
          <source>More specifically, setting this value to &lt;code&gt;on&lt;/code&gt; will add a &lt;code&gt;Gather&lt;/code&gt; node to the top of any query plan for which this appears to be safe, so that the query runs inside of a parallel worker. Even when a parallel worker is not available or cannot be used, operations such as starting a subtransaction that would be prohibited in a parallel query context will be prohibited unless the planner believes that this will cause the query to fail. If failures or unexpected results occur when this option is set, some functions used by the query may need to be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (or, possibly, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;).</source>
          <target state="translated">具体的には、この値を &lt;code&gt;on&lt;/code&gt; に設定すると、 &lt;code&gt;Gather&lt;/code&gt; ノードが安全であると思われるクエリプランの先頭に追加され、クエリが並列ワーカー内で実行されます。並列ワーカーが利用できない場合や使用できない場合でも、並列クエリコンテキストで禁止されるサブトランザクションの開始などの操作は、プランナーがクエリの失敗の原因になると考えない限り禁止されます。このオプションが設定されているときに障害または予期しない結果が発生した場合、クエリで使用される一部の関数を &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; （または、場合によっては &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ）とマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="bf1a578b87b8dcebec736c6d3df5e511c59a7712" translate="yes" xml:space="preserve">
          <source>More usually, &lt;code&gt;VALUES&lt;/code&gt; is used within a larger SQL command. The most common use is in &lt;code&gt;INSERT&lt;/code&gt;:</source>
          <target state="translated">通常、 &lt;code&gt;VALUES&lt;/code&gt; はより大きなSQLコマンド内で使用されます。最も一般的な使用法は &lt;code&gt;INSERT&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f34f1661d8425a72a96b8b7cb49353a492e8fe95" translate="yes" xml:space="preserve">
          <source>Moreover, if we have a function that accepts a single argument of a composite type, we can call it with either notation. These queries are all equivalent:</source>
          <target state="translated">さらに、複合型の単一の引数を受け入れる関数があれば、どちらの表記法でも呼び出すことができます。これらのクエリはすべて等価です。</target>
        </trans-unit>
        <trans-unit id="b6b5cd5fdbfc629a7d3f75be5167b4b144a3f86d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;pg_ctl&lt;/code&gt; modes require knowing the data directory location; therefore, the &lt;code&gt;-D&lt;/code&gt; option is required unless &lt;code&gt;PGDATA&lt;/code&gt; is set.</source>
          <target state="translated">ほとんどの &lt;code&gt;pg_ctl&lt;/code&gt; モードでは、データディレクトリの場所を知っている必要があります。したがって、 &lt;code&gt;PGDATA&lt;/code&gt; が設定されていない限り、 &lt;code&gt;-D&lt;/code&gt; オプションが必要です。</target>
        </trans-unit>
        <trans-unit id="69cf03cafc4ea41c94813d7e422965750bb31a86" translate="yes" xml:space="preserve">
          <source>Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates.</source>
          <target state="translated">ほとんどの集約関数はNULL入力を無視するので、1つ以上の式がNULLをもたらす行は破棄されます。これは、特に指定がない限り、すべての組み込み集約関数において真であると仮定できます。</target>
        </trans-unit>
        <trans-unit id="7ba0155b71f54b39b68d7c23be1cc2e11116377b" translate="yes" xml:space="preserve">
          <source>Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway).</source>
          <target state="translated">ほとんどのアトム、そしてすべての制約は、欲張り属性を持っていません(いずれにしても可変量のテキストをマッチさせることができないため)。</target>
        </trans-unit>
        <trans-unit id="7f53fad77c0918001bf87e5c2287a1e18f906e5e" translate="yes" xml:space="preserve">
          <source>Most common implementations</source>
          <target state="translated">最も一般的な実装</target>
        </trans-unit>
        <trans-unit id="750c1315d8a2e4c64b7b2cf3fe9029ccf298aef6" translate="yes" xml:space="preserve">
          <source>Most kinds of catalog objects are simply referenced by their names. Note that type names must exactly match the referenced &lt;code&gt;pg_type&lt;/code&gt; entry's &lt;code&gt;typname&lt;/code&gt;; you do not get to use any aliases such as &lt;code&gt;integer&lt;/code&gt; for &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">ほとんどの種類のカタログオブジェクトは、単に名前で参照されます。 &lt;code&gt;pg_type&lt;/code&gt; は、参照されるpg_typeエントリの &lt;code&gt;typname&lt;/code&gt; と正確に一致する必要があることに注意してください。次のような任意のエイリアスを使用して取得しない &lt;code&gt;integer&lt;/code&gt; のため &lt;code&gt;int4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ca0f34a89e8d302478dfd8fb8ad2a79bdc73278" translate="yes" xml:space="preserve">
          <source>Most local objects belong to a specific &lt;a href=&quot;glossary#GLOSSARY-SCHEMA&quot;&gt;schema&lt;/a&gt; in their containing database, such as &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; (all types), &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;routines&lt;/a&gt; (all types), data types, etc. The names of such objects of the same type in the same schema are enforced to be unique.</source>
          <target state="translated">ほとんどのローカルオブジェクトは、&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;リレーション&lt;/a&gt;（すべてのタイプ）、&lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;ルーチン&lt;/a&gt;（すべてのタイプ）、データタイプなど、データベースを含む特定の&lt;a href=&quot;glossary#GLOSSARY-SCHEMA&quot;&gt;スキーマ&lt;/a&gt;に属しています。同じスキーマ内の同じタイプのオブジェクトの名前は、一意になるように強制されます。 。</target>
        </trans-unit>
        <trans-unit id="4dbe371d76c6dc7cba4d9098c63670e12f1237d3" translate="yes" xml:space="preserve">
          <source>Most of the functions that reconstruct (decompile) database objects have an optional &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; flag, which if &lt;code&gt;true&lt;/code&gt; causes the result to be &amp;ldquo;pretty-printed&amp;rdquo;. Pretty-printing suppresses unnecessary parentheses and adds whitespace for legibility. The pretty-printed format is more readable, but the default format is more likely to be interpreted the same way by future versions of PostgreSQL; so avoid using pretty-printed output for dump purposes. Passing &lt;code&gt;false&lt;/code&gt; for the &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; parameter yields the same result as omitting the parameter.</source>
          <target state="translated">データベースオブジェクトを再構築（逆コンパイル）するほとんどの関数には、オプションの&lt;em&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/em&gt;フラグがあります。これが &lt;code&gt;true&lt;/code&gt; の場合、結果は「プリティプリント」されます。プリティプリントは、不要な括弧を抑制し、読みやすくするために空白を追加します。きれいに印刷された形式の方が読みやすくなりますが、デフォルトの形式は、PostgreSQLの将来のバージョンでも同じように解釈される可能性が高くなります。したがって、ダンプの目的できれいに印刷された出力を使用することは避けてください。&lt;em&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/em&gt;パラメータに &lt;code&gt;false&lt;/code&gt; を渡すと、パラメータを省略した場合と同じ結果になります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a098765cd76a02dd3c28ed1a2d6ced931f0a323" translate="yes" xml:space="preserve">
          <source>Most queries retrieve only a fraction of the rows in a table, due to &lt;code&gt;WHERE&lt;/code&gt; clauses that restrict the rows to be examined. The planner thus needs to make an estimate of the &lt;em&gt;selectivity&lt;/em&gt; of &lt;code&gt;WHERE&lt;/code&gt; clauses, that is, the fraction of rows that match each condition in the &lt;code&gt;WHERE&lt;/code&gt; clause. The information used for this task is stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; system catalog. Entries in &lt;code&gt;pg_statistic&lt;/code&gt; are updated by the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; commands, and are always approximate even when freshly updated.</source>
          <target state="translated">検査する行を制限する &lt;code&gt;WHERE&lt;/code&gt; 句のため、ほとんどのクエリはテーブルの行の一部のみを取得します。プランナは、このように推定する必要がある&lt;em&gt;選択&lt;/em&gt;の &lt;code&gt;WHERE&lt;/code&gt; で句を、各条件に一致する行の割合 &lt;code&gt;WHERE&lt;/code&gt; 句。このタスクに使用される情報は、&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;システムカタログに格納されます。 &lt;code&gt;pg_statistic&lt;/code&gt; のエントリは &lt;code&gt;ANALYZE&lt;/code&gt; および &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; コマンドによって更新され、新しく更新された場合でも常に概算です。</target>
        </trans-unit>
        <trans-unit id="6eb034f582f8c2b79ea5f1d4aeb8e1cc749b45b2" translate="yes" xml:space="preserve">
          <source>Most scalar data types should have a corresponding array type (that is, a standard varlena array type whose element type is the scalar type, and which is referenced by the &lt;code&gt;typarray&lt;/code&gt; field of the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry). &lt;code&gt;genbki.pl&lt;/code&gt; is able to generate the &lt;code&gt;pg_type&lt;/code&gt; entry for the array type automatically in most cases.</source>
          <target state="translated">ほとんどのスカラーデータ型は、対応する配列型を有するべきである（すなわち、その要素タイプスカラ型であり、かつによって参照される標準varlenaアレイ型 &lt;code&gt;typarray&lt;/code&gt; のスカラー型の分野 &lt;code&gt;pg_type&lt;/code&gt; システムカタログのエントリ）。 &lt;code&gt;genbki.pl&lt;/code&gt; は、ほとんどの場合、配列タイプの &lt;code&gt;pg_type&lt;/code&gt; エントリを自動的に生成できます。</target>
        </trans-unit>
        <trans-unit id="8934cf5770ff56a86643f007085fd816b1b58dfa" translate="yes" xml:space="preserve">
          <source>Most system catalogs are copied from the template database during database creation and are thereafter database-specific. A few catalogs are physically shared across all databases in a cluster; these are noted in the descriptions of the individual catalogs.</source>
          <target state="translated">ほとんどのシステム・カタログは、データベース作成時にテンプレート・データベースからコピーされ、その後はデータベース固有のものになります。いくつかのカタログは、クラスタ内のすべてのデータベースで物理的に共有されています。</target>
        </trans-unit>
        <trans-unit id="a7bd8e4c0ba4c5fef185f840f580e4a5b9a25b96" translate="yes" xml:space="preserve">
          <source>Most types of dictionaries rely on configuration files, such as files of stop words. These files &lt;em&gt;must&lt;/em&gt; be stored in UTF-8 encoding. They will be translated to the actual database encoding, if that is different, when they are read into the server.</source>
          <target state="translated">ほとんどのタイプの辞書は、ストップワードのファイルなどの構成ファイルに依存しています。これらのファイルはUTF-8エンコーディングで保存する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。それらがサーバーに読み込まれたときに、実際のデータベースエンコーディングが異なる場合は、それらに変換されます。</target>
        </trans-unit>
        <trans-unit id="4deea28851a7ae4ce56d6b6d82c468bb35f41bb4" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below.</source>
          <target state="translated">psqlの動作を制御するほとんどの変数は設定を解除できません。代わりに、 &lt;code&gt;\unset&lt;/code&gt; コマンドはそれらをデフォルト値に設定するものとして解釈されます。以下の&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="473029ab69353e53921e8ecd7440a49c9a86be94" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">psqlの動作を制御するほとんどの変数は設定解除できません。代わりに、 &lt;code&gt;\unset&lt;/code&gt; コマンドは、それらをデフォルト値に設定すると解釈されます。以下の&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7293739c8cef6860367bef80e497db37fda337b4" translate="yes" xml:space="preserve">
          <source>Moving an object to a new schema additionally requires &lt;code&gt;remove_name&lt;/code&gt; permission on the old schema and &lt;code&gt;add_name&lt;/code&gt; permission on the new one.</source>
          <target state="translated">新しいスキーマにオブジェクトを移動すると、さらに必要と &lt;code&gt;remove_name&lt;/code&gt; 古いスキーマと上の許可 &lt;code&gt;add_name&lt;/code&gt; 新しいものに許可を。</target>
        </trans-unit>
        <trans-unit id="9a676159878bdf52262c05ecb519fb1a7d01d39b" translate="yes" xml:space="preserve">
          <source>Much of the PostgreSQL type system is built around a rich set of functions. Functions can have one or more arguments. Since PostgreSQL permits function overloading, the function name alone does not uniquely identify the function to be called; the parser must select the right function based on the data types of the supplied arguments.</source>
          <target state="translated">PostgreSQLの型システムの多くは、豊富な関数群を中心に構築されています。関数は1つまたは複数の引数を持つことができます。PostgreSQLは関数のオーバーロードを許可しているので、関数名だけでは呼び出される関数を一意に特定することはできません。</target>
        </trans-unit>
        <trans-unit id="2740f0c680a6e63e450d5b3c062a5229834ae2d2" translate="yes" xml:space="preserve">
          <source>Mule internal code</source>
          <target state="translated">ラバの内部コード</target>
        </trans-unit>
        <trans-unit id="344fa8c431ce29a1cdabfe9e517c51ceaef15678" translate="yes" xml:space="preserve">
          <source>Multi-Version Concurrency Control</source>
          <target state="translated">マルチバージョン同時実行制御</target>
        </trans-unit>
        <trans-unit id="99e2646c11c9e1032892edf955d9bbabc4a055aa" translate="yes" xml:space="preserve">
          <source>Multi-version concurrency control (MVCC)</source>
          <target state="translated">マルチバージョン同時実行制御 (MVCC)</target>
        </trans-unit>
        <trans-unit id="384caf1b9fc6ff1244af37a2f4eefa0674d24a27" translate="yes" xml:space="preserve">
          <source>Multicolumn GIN indexes are implemented by building a single B-tree over composite values (column number, key value). The key values for different columns can be of different types.</source>
          <target state="translated">マルチカラムGINインデックスは、複合値(カラム番号、キー値)の上に単一のBツリーを構築することで実装されます。異なるカラムのキー値は、異なるタイプのものにすることができます。</target>
        </trans-unit>
        <trans-unit id="2c159674cdc49534760eb0265af934a2b89d41fe" translate="yes" xml:space="preserve">
          <source>Multicolumn Indexes</source>
          <target state="translated">マルチカラムインデックス</target>
        </trans-unit>
        <trans-unit id="2d93cd8bc72bc57af1ba376ce47d069b6c4a937d" translate="yes" xml:space="preserve">
          <source>Multicolumn indexes should be used sparingly. In most situations, an index on a single column is sufficient and saves space and time. Indexes with more than three columns are unlikely to be helpful unless the usage of the table is extremely stylized. See also &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt; and &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt; for some discussion of the merits of different index configurations.</source>
          <target state="translated">複数列のインデックスは慎重に使用する必要があります。ほとんどの場合、単一の列のインデックスで十分であり、スペースと時間を節約できます。3列を超えるインデックスは、テーブルの使用法が極端に定型化されていない限り、役立つとは考えられません。さまざまなインデックス設定のメリットについては、&lt;a href=&quot;indexes-bitmap-scans&quot;&gt;セクション11.5&lt;/a&gt;および&lt;a href=&quot;indexes-index-only-scans&quot;&gt;セクション11.9&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="b99aa634fe16bee7bdf05b0cf7793d76fb5f12b3" translate="yes" xml:space="preserve">
          <source>Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-&lt;code&gt;ARRAY&lt;/code&gt; construct. For example:</source>
          <target state="translated">多次元配列コンストラクター要素は、サブ &lt;code&gt;ARRAY&lt;/code&gt; 構成要素だけでなく、適切な種類の配列を生成するものであれば何でもかまいません。例えば：</target>
        </trans-unit>
        <trans-unit id="5dca66d7f2aee43ef1797a393d0e215db306ea18" translate="yes" xml:space="preserve">
          <source>Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word &lt;code&gt;ARRAY&lt;/code&gt; can be omitted. For example, these produce the same result:</source>
          <target state="translated">多次元配列値は、配列コンストラクターをネストすることによって構築できます。内部コンストラクタでは、キーワード &lt;code&gt;ARRAY&lt;/code&gt; を省略できます。たとえば、これらは同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="b8d7e3b8a7276708d01165024b6293de444e2c11" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays must have matching extents for each dimension. A mismatch causes an error, for example:</source>
          <target state="translated">多次元配列は、各次元のエクステントが一致していなければなりません。一致しないと、例えば、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="b92978283c35094160cf22fc851c3df5bcf7effd" translate="yes" xml:space="preserve">
          <source>Multilingual Emacs</source>
          <target state="translated">多言語Emacs</target>
        </trans-unit>
        <trans-unit id="da392350dc33944a643a54bf379fde9199e79c15" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;EXCEPT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;EXCEPT&lt;/code&gt; binds at the same level as &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">同じ &lt;code&gt;SELECT&lt;/code&gt; ステートメント内の複数の &lt;code&gt;EXCEPT&lt;/code&gt; 演算子は、括弧で特に指示されていない限り、左から右に評価されます。 &lt;code&gt;EXCEPT&lt;/code&gt; は &lt;code&gt;UNION&lt;/code&gt; と同じレベルでバインドします。</target>
        </trans-unit>
        <trans-unit id="545da6f8ee31d7740c9c3d5dad863f020a69eb93" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;INTERSECT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;INTERSECT&lt;/code&gt; binds more tightly than &lt;code&gt;UNION&lt;/code&gt;. That is, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; will be read as &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt;.</source>
          <target state="translated">同じ &lt;code&gt;SELECT&lt;/code&gt; ステートメント内の複数の &lt;code&gt;INTERSECT&lt;/code&gt; 演算子は、括弧で特に指示されていない限り、左から右に評価されます。 &lt;code&gt;INTERSECT&lt;/code&gt; は &lt;code&gt;UNION&lt;/code&gt; よりも強く結合します。つまり、 &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; は &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt; として読み取られます。</target>
        </trans-unit>
        <trans-unit id="44cc99500b8c6afffdf8915313cbba82fb39e906" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;UNION&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless otherwise indicated by parentheses.</source>
          <target state="translated">同じ &lt;code&gt;SELECT&lt;/code&gt; ステートメント内の複数の &lt;code&gt;UNION&lt;/code&gt; 演算子は、括弧で示されていない限り、左から右に評価されます。</target>
        </trans-unit>
        <trans-unit id="09ad30df55e0ee1fdeb0db77709134b50e5f6d5c" translate="yes" xml:space="preserve">
          <source>Multiple Identity Columns</source>
          <target state="translated">複数のアイデンティティカラム</target>
        </trans-unit>
        <trans-unit id="e2933c3051980c1e2e6ec097345b6b77b93e0721" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, put the names within quotes and separate the server names with a comma. If multiple servers are specified, all other RADIUS options can also be given as a comma separate list, to apply individual values to each server. They can also be specified as a single value, in which case this value will apply to all servers.</source>
          <target state="translated">複数のRADIUSサーバを指定することができ、その場合は順次試行されます。サーバから否定的な応答を受信した場合、認証は失敗します。応答がない場合は、リストの次のサーバが試行されます。複数のサーバを指定する場合は、サーバ名を引用符で囲み、カンマで区切ってください。複数のサーバーを指定した場合、他のすべてのRADIUSオプションもカンマ区切りのリストとして与え、各サーバーに個別の値を適用することができます。また、単一の値として指定することもできます。</target>
        </trans-unit>
        <trans-unit id="52ee8ebc172afa9611da532af89c4c55f27f12a0" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, separate the server names with commas and surround the list with double quotes. If multiple servers are specified, the other RADIUS options can also be given as comma-separated lists, to provide individual values for each server. They can also be specified as a single value, in which case that value will apply to all servers.</source>
          <target state="translated">複数のRADIUSサーバを指定することができ、その場合は順次試行されます。サーバから否定的な応答を受信した場合、認証は失敗します。応答がない場合は、リストの次のサーバが試行されます。複数のサーバを指定するには、サーバ名をカンマで区切り、リストを二重引用符で囲みます。複数のサーバを指定した場合、他の RADIUS オプションもカンマで区切ったリストで指定して、各サーバの値を個別に指定することができます。また、1 つの値として指定することもでき、その場合はその値がすべてのサーバに適用されます。</target>
        </trans-unit>
        <trans-unit id="47cf9ecc42c00f97b187ac65e4ad87ed8ddddec7" translate="yes" xml:space="preserve">
          <source>Multiple function calls can be combined into a single &lt;code&gt;FROM&lt;/code&gt;-clause item by surrounding them with &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.</source>
          <target state="translated">複数の関数呼び出しを &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 囲むことにより、単一の &lt;code&gt;FROM&lt;/code&gt; 句項目に組み合わせることができます。このようなアイテムの出力は、各関数の最初の行、次に各関数の2番目の行の連結などです。一部の関数が他の行よりも少ない行を生成する場合、null値が欠落データに置き換えられるため、返される行の総数は常に、最も多くの行を生成した関数の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="cb041e89d71104ed194545d06d97265abcc8ac5c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance via the &lt;code&gt;INHERITS&lt;/code&gt; clause is a PostgreSQL language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL.</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; 句による多重継承は、PostgreSQLの言語拡張です。SQL：1999以降では、異なる構文とセマンティクスを使用して単一継承を定義しています。SQL：1999スタイルの継承は、PostgreSQLではまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="dfc4b99f808466861398cb5089390dbcf8288968" translate="yes" xml:space="preserve">
          <source>Multiple initial administrators, and all the other options of &lt;code&gt;CREATE ROLE&lt;/code&gt;, are PostgreSQL extensions.</source>
          <target state="translated">複数の初期管理者、および &lt;code&gt;CREATE ROLE&lt;/code&gt; の他のすべてのオプションは、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="7023aa5fc8e888d453cd39667bc365999be7e91b" translate="yes" xml:space="preserve">
          <source>Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as &lt;code&gt;NOWAIT&lt;/code&gt; if that is specified in any of the clauses affecting it. Otherwise, it is processed as &lt;code&gt;SKIP LOCKED&lt;/code&gt; if that is specified in any of the clauses affecting it.</source>
          <target state="translated">異なるテーブルに異なるロック動作を指定する必要がある場合は、複数のロック句を記述できます。同じテーブルが複数のロック句によって言及されている（または暗黙的に影響を受けている）場合、最強のテーブルによってのみ指定されたかのように処理されます。同様に、テーブルは、それに影響を与えるいずれかの句で指定されている場合、 &lt;code&gt;NOWAIT&lt;/code&gt; として処理されます。それ以外の場合は、影響する句のいずれかで指定されている場合、 &lt;code&gt;SKIP LOCKED&lt;/code&gt; として処理されます。</target>
        </trans-unit>
        <trans-unit id="9ff93077b96a2599909c71e452a52b617dcb75f7" translate="yes" xml:space="preserve">
          <source>Multiple-Server Parallel Query Execution</source>
          <target state="translated">マルチサーバ並列クエリ実行</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="83d4c1590260d359ecbe9f085d559899657ac6eb" translate="yes" xml:space="preserve">
          <source>Multiplies each point of the first argument by the second &lt;code&gt;point&lt;/code&gt; (treating a point as being a complex number represented by real and imaginary parts, and performing standard complex multiplication). If one interprets the second &lt;code&gt;point&lt;/code&gt; as a vector, this is equivalent to scaling the object's size and distance from the origin by the length of the vector, and rotating it counterclockwise around the origin by the vector's angle from the &lt;code&gt;x&lt;/code&gt; axis. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;,&lt;a href=&quot;#ftn.FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;&lt;sup id=&quot;FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;&lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">最初の引数の各ポイントに2番目の &lt;code&gt;point&lt;/code&gt; 乗算します（ポイントを実数部と虚数部で表される複素数として扱い、標準の複素数乗算を実行します）。 2番目の &lt;code&gt;point&lt;/code&gt; をベクトルとして解釈する場合、これは、オブジェクトのサイズと原点からの距離をベクトルの長さでスケーリングし、 &lt;code&gt;x&lt;/code&gt; 軸からのベクトルの角度で原点を中心に反時計回りに回転させることと同じです。以下のための利用可能な &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、&lt;a href=&quot;#ftn.FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;&lt;sup id=&quot;FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;[A]&lt;/sup&gt;&lt;/a&gt; &lt;code&gt;path&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f690d76a3a6b4f3cf2f400b6a49ebe14dc72a219" translate="yes" xml:space="preserve">
          <source>Multiply an interval by a scalar</source>
          <target state="translated">区間をスカラーで乗算する</target>
        </trans-unit>
        <trans-unit id="2c0c5f6099e92ebebc75583d550cc71584a93e4c" translate="yes" xml:space="preserve">
          <source>Multiply the number of rows generated by the scale factor. For example, &lt;code&gt;-s 100&lt;/code&gt; will create 10,000,000 rows in the &lt;code&gt;pgbench_accounts&lt;/code&gt; table. Default is 1. When the scale is 20,000 or larger, the columns used to hold account identifiers (&lt;code&gt;aid&lt;/code&gt; columns) will switch to using larger integers (&lt;code&gt;bigint&lt;/code&gt;), in order to be big enough to hold the range of account identifiers.</source>
          <target state="translated">スケールファクターによって生成された行数を乗算します。たとえば、 &lt;code&gt;-s 100&lt;/code&gt; は &lt;code&gt;pgbench_accounts&lt;/code&gt; テーブルに10,000,000行を作成します。デフォルトは1です。スケールが20,000以上の場合、アカウント識別子を保持するために使用される列（ &lt;code&gt;aid&lt;/code&gt; 列）は、アカウント識別子の範囲を保持するのに十分な大きさになるように、より大きい整数（ &lt;code&gt;bigint&lt;/code&gt; ）を使用するように切り替わります。</target>
        </trans-unit>
        <trans-unit id="0b63b41e9535d1638fe83e7fb152d39f9e2c71b6" translate="yes" xml:space="preserve">
          <source>Multivariate Statistics Examples</source>
          <target state="translated">多変量統計の例</target>
        </trans-unit>
        <trans-unit id="67f1e276e130e436d878dd37efbefd858f1a15f3" translate="yes" xml:space="preserve">
          <source>Multivariate correlation can be demonstrated with a very simple data set &amp;mdash; a table with two columns, both containing the same values:</source>
          <target state="translated">多変量相関は、非常に単純なデータセット（2つの列があり、どちらも同じ値を含むテーブル）で実証できます。</target>
        </trans-unit>
        <trans-unit id="68e9ef2c165e4fa8adf23b844de4bcd199158fae" translate="yes" xml:space="preserve">
          <source>MurmurHash2 hash</source>
          <target state="translated">MurmururHash2 ハッシュ</target>
        </trans-unit>
        <trans-unit id="1d1a603b8a91745540a0eb62aecc8635b092e498" translate="yes" xml:space="preserve">
          <source>Mutation as genetic operator is deprecated so that no repair mechanisms are needed to generate legal TSP tours.</source>
          <target state="translated">遺伝子操作者としての突然変異は、合法的なTSPツアーを生成するために修復メカニズムを必要としないように、非推奨とされています。</target>
        </trans-unit>
        <trans-unit id="411d403f2e3b649eb2f47189fa6c058b68a3959d" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST（&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;）の要点を解明してくれたJoe Hellerstein教授（&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;）と彼の主に感謝します。Illustraのために書かれた彼の例のための元学生アンディ・ドン。また、現在と過去のすべてのPostgres開発者に、自分自身の世界を作成し、そこに邪魔されずに生活できるように感謝しています。そして、私は、私のデータベース研究に対する長年の忠実な支援に対して、アルゴンヌ研究所と米国エネルギー省に感謝したいと思います。</target>
        </trans-unit>
        <trans-unit id="63806797acec7e92b9e9bba40d5e19f39040d989" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST（&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;）の要点を解明してくれたJoe Hellerstein教授（&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;）に主に感謝します。また、現在と過去のすべてのPostgres開発者に、自分自身の世界を作成し、そこに邪魔されずに生活できるように感謝しています。そして、私のデータベース研究に対する長年にわたる誠実なサポートに感謝し、アルゴンヌ研究所と米国エネルギー省に感謝します。</target>
        </trans-unit>
        <trans-unit id="6b165eae6146362f8f4218790f243080eeac62ec" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST（&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;）の要点を解明してくれたJoe Hellerstein教授（&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;）と彼の元学生に主に感謝します。Illustraのために書かれた彼の例のためのAndyDong。また、現在および過去のすべてのPostgres開発者に、自分自身の世界を作成し、邪魔されずに生きることができるようにしてくれたことに感謝しています。また、データベース研究を長年忠実にサポートしてくださったアルゴンヌ国立研究所と米国エネルギー省に感謝の意を表します。</target>
        </trans-unit>
        <trans-unit id="6c665518a6c8a774be8b227ccf9e0e2930a0b4db" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST（&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;）の要点を解明してくれたJoe Hellerstein教授（&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;）に主に感謝します。また、現在および過去のすべてのPostgres開発者に、自分自身の世界を作成し、邪魔されずに生きることができるようにしてくれたことに感謝しています。また、データベース研究を長年忠実にサポートしてくださったアルゴンヌ国立研究所と米国エネルギー省に感謝の意を表します。</target>
        </trans-unit>
        <trans-unit id="990ae3b2652542659607c20d6be633d0e3b25e79" translate="yes" xml:space="preserve">
          <source>MySpell does not support compound words. Hunspell has sophisticated support for compound words. At present, PostgreSQL implements only the basic compound word operations of Hunspell.</source>
          <target state="translated">MySpellは複合語をサポートしていません。Hunspellは複合語を高度にサポートしています。現在のところ、PostgreSQLはHunspellの基本的な複合語操作のみを実装しています。</target>
        </trans-unit>
        <trans-unit id="5e441f15c5e733792befe0ffc73906895c439622" translate="yes" xml:space="preserve">
          <source>MySpell format is a subset of Hunspell. The &lt;code&gt;.affix&lt;/code&gt; file of Hunspell has the following structure:</source>
          <target state="translated">MySpell形式は、Hunspellのサブセットです。 &lt;code&gt;.affix&lt;/code&gt; ののhunspellのファイルは、以下の構造を有します：</target>
        </trans-unit>
        <trans-unit id="488df82bbfc103d0d771499379d0ae7070c9580f" translate="yes" xml:space="preserve">
          <source>N-distinct counts for combinations of column values. If greater than zero, the estimated number of distinct values in the combination. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique combination of columns in which the number of distinct combinations is the same as the number of rows.</source>
          <target state="translated">列値の組み合わせのN個別カウント。ゼロより大きい場合は、組み合わせの個別値の推定数。ゼロ未満の場合、個別の値の数を行数で割った負数。（ &lt;code&gt;ANALYZE&lt;/code&gt; がテーブルの増加に伴って異なる値の数が増える可能性が高いとANALYZEが判断した場合、否定形式が使用されます。列が可能な値の固定数を持っていると思われる場合、正形式が使用されます。）たとえば、-1は異なる組み合わせの数が行の数と同じである列の一意の組み合わせ。</target>
        </trans-unit>
        <trans-unit id="b9f3788bf337d1fbd1e44a8ca35f9f8dc00922f3" translate="yes" xml:space="preserve">
          <source>N-distinct counts, serialized as &lt;code&gt;pg_ndistinct&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;pg_ndistinct&lt;/code&gt; 型としてシリアル化されたN-distinctカウント</target>
        </trans-unit>
        <trans-unit id="df7b392c5a7d73b13e58918e0a512d5732187d0d" translate="yes" xml:space="preserve">
          <source>N.1. When Color is Used</source>
          <target state="translated">N.1.色を使用する場合</target>
        </trans-unit>
        <trans-unit id="82b9c07010036ea2172a9c209c09188b295a72b2" translate="yes" xml:space="preserve">
          <source>N.2. Configuring the Colors</source>
          <target state="translated">N.2.色の設定</target>
        </trans-unit>
        <trans-unit id="e75dedcc315971ca035b9f33d5ff4a268f0acad9" translate="yes" xml:space="preserve">
          <source>NAS</source>
          <target state="translated">NAS</target>
        </trans-unit>
        <trans-unit id="05c70c4a8ccede51b0f764a8b31b48ffad7c77b1" translate="yes" xml:space="preserve">
          <source>NLS</source>
          <target state="translated">NLS</target>
        </trans-unit>
        <trans-unit id="578dc1c57657369feb194b2bc15910a2480a2342" translate="yes" xml:space="preserve">
          <source>NOT &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">しません &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efde75752ab811815325697b4ba90b5afbe2e2a6" translate="yes" xml:space="preserve">
          <source>NOTIFY</source>
          <target state="translated">NOTIFY</target>
        </trans-unit>
        <trans-unit id="3e7d70b52328177b60019485c8ea011b37cce023" translate="yes" xml:space="preserve">
          <source>NOTIFY &amp;mdash; generate a notification</source>
          <target state="translated">NOTIFY &amp;mdash;通知を生成する</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="385a7cff63d2b3c51a6859910c942e284cc2cff9" translate="yes" xml:space="preserve">
          <source>Name of SSL cipher in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">使用しているSSL暗号の名前、またはこの接続でSSLが使用されていない場合はNULL</target>
        </trans-unit>
        <trans-unit id="5eaeda54ec9eb68b2072fa5d1feb6c035f44d644" translate="yes" xml:space="preserve">
          <source>Name of a language</source>
          <target state="translated">言語名</target>
        </trans-unit>
        <trans-unit id="0178948b94c691d929c18fcd5464bd15baa26a58" translate="yes" xml:space="preserve">
          <source>Name of a new or existing column.</source>
          <target state="translated">新規または既存のカラムの名前。</target>
        </trans-unit>
        <trans-unit id="560c42c98008ce51d03f9d6187d29c37c7009544" translate="yes" xml:space="preserve">
          <source>Name of a new or existing constraint.</source>
          <target state="translated">新規または既存の制約の名前。</target>
        </trans-unit>
        <trans-unit id="35dcedcca97d439e09701340473e9f3ca046b02c" translate="yes" xml:space="preserve">
          <source>Name of a notification channel (any identifier).</source>
          <target state="translated">通知チャネルの名前(任意の識別子)。</target>
        </trans-unit>
        <trans-unit id="ce514f0b60e997e86128266bb519efbba0a6ff6b" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">設定可能な構成パラメータの名前。利用可能なパラメータは&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="f56681bfb8a12163f30d0b4fed0f1fd757c8babb" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">設定可能な構成パラメーターの名前。使用可能なパラメータは&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;第19章に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="954ee074d5be1c36459da8f7253027e56d893199" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">設定可能な実行時パラメータの名前。利用可能なパラメータは、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;以下に記載されています。</target>
        </trans-unit>
        <trans-unit id="9a0e3cf73c45665ec4941eb25f3329677ad2c627" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">設定可能な実行時パラメータの名前。使用可能なパラメーターは、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;と&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;リファレンスページに記載されています。</target>
        </trans-unit>
        <trans-unit id="f5a2c1ef6c12c7af08e5bbbc68b4033b620233cc" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">設定可能なランタイムパラメータの名前。使用可能なパラメータは、&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;第19章&lt;/a&gt;以下に記載されています。</target>
        </trans-unit>
        <trans-unit id="aafb6ab430fc1bf75e0c604287df03b8d7d814d7" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">設定可能なランタイムパラメータの名前。使用可能なパラメータは、&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;第19章&lt;/a&gt;および&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;リファレンスページに記載されています。</target>
        </trans-unit>
        <trans-unit id="2c2301404426d669bb911593cec730650e2bdbfe" translate="yes" xml:space="preserve">
          <source>Name of a single trigger to disable or enable.</source>
          <target state="translated">無効化または有効化する単一のトリガーの名前。</target>
        </trans-unit>
        <trans-unit id="c0e033b344c49040ea83d0610c59dfd1b03a919f" translate="yes" xml:space="preserve">
          <source>Name of an existing column.</source>
          <target state="translated">既存のカラムの名前。</target>
        </trans-unit>
        <trans-unit id="231d1ed2d468b8d6e17991509cbba8cadc17e1e5" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop or rename.</source>
          <target state="translated">削除または名前を変更する既存の制約の名前。</target>
        </trans-unit>
        <trans-unit id="22745c3446c7c4d17ba8fa32b15b8f7c06992bdd" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop.</source>
          <target state="translated">ドロップする既存の制約の名前。</target>
        </trans-unit>
        <trans-unit id="b073ede31105aa5c1b6f36a11370455d96d537b0" translate="yes" xml:space="preserve">
          <source>Name of an existing table. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is affected. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are affected. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">既存のテーブルの名前。場合 &lt;code&gt;ONLY&lt;/code&gt; テーブル名の前に指定され、そのテーブルのみが影響を受けています。 &lt;code&gt;ONLY&lt;/code&gt; が指定されていない場合、テーブルとそのすべての子孫テーブル（存在する場合）が影響を受けます。オプションで、 &lt;code&gt;*&lt;/code&gt; をテーブル名の後に指定して、子孫テーブルが含まれることを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="694de0e59c53dd44f4f4691acabc413768ef9d9a" translate="yes" xml:space="preserve">
          <source>Name of anonymous-block handler function, or null if none</source>
          <target state="translated">匿名ブロックハンドラ関数の名前。</target>
        </trans-unit>
        <trans-unit id="5915762ae281a23f2bd1848ce737f5d865ae38a8" translate="yes" xml:space="preserve">
          <source>Name of call handler function</source>
          <target state="translated">呼び出しハンドラ関数名</target>
        </trans-unit>
        <trans-unit id="206dec00fa32e6c205384b3df437c35f69e88392" translate="yes" xml:space="preserve">
          <source>Name of default version, or &lt;code&gt;NULL&lt;/code&gt; if none is specified</source>
          <target state="translated">デフォルトバージョンの名前、または何も指定されていない場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee034d5b0508537af88d7be3d4206b7d9a6f7ace" translate="yes" xml:space="preserve">
          <source>Name of extended statistics</source>
          <target state="translated">拡張統計の名称</target>
        </trans-unit>
        <trans-unit id="987fff60ced95bb42507af7d6f424dce288531b4" translate="yes" xml:space="preserve">
          <source>Name of index</source>
          <target state="translated">インデックス名</target>
        </trans-unit>
        <trans-unit id="b76e90e08249294dc6388d288e0a0ff43959a02e" translate="yes" xml:space="preserve">
          <source>Name of materialized view</source>
          <target state="translated">マテリアライズされたビューの名前</target>
        </trans-unit>
        <trans-unit id="6501e212c15d2fb75aeb9acf75320931a339d605" translate="yes" xml:space="preserve">
          <source>Name of materialized view's owner</source>
          <target state="translated">マテリアライズされたビューの所有者の名前</target>
        </trans-unit>
        <trans-unit id="e6cf10a0a70ad19c5b7371da58941b6c0037ae86" translate="yes" xml:space="preserve">
          <source>Name of policy</source>
          <target state="translated">政策名</target>
        </trans-unit>
        <trans-unit id="a146b1bd6e895582068f638a02a8412aaeadca11" translate="yes" xml:space="preserve">
          <source>Name of publication</source>
          <target state="translated">出版物名</target>
        </trans-unit>
        <trans-unit id="611f97b7cc9cb3302c011583c51a64d361fde262" translate="yes" xml:space="preserve">
          <source>Name of rule</source>
          <target state="translated">ルール名</target>
        </trans-unit>
        <trans-unit id="916daa93b2ab22b09d0d27a6fc75daa92e090cbf" translate="yes" xml:space="preserve">
          <source>Name of schema containing extended statistic</source>
          <target state="translated">拡張統計量を含むスキーマ名</target>
        </trans-unit>
        <trans-unit id="b8e23c7699d61150cab192ab08cb0a8c8eff18ba" translate="yes" xml:space="preserve">
          <source>Name of schema containing materialized view</source>
          <target state="translated">マテリアライズされたビューを含むスキーマ名</target>
        </trans-unit>
        <trans-unit id="8a4b8a6f4e6c77468796e3b2343ea829020a1a97" translate="yes" xml:space="preserve">
          <source>Name of schema containing sequence</source>
          <target state="translated">シーケンスを含むスキーマ名</target>
        </trans-unit>
        <trans-unit id="9330f5310d2e7af8a885aaca54f40c7a5b2e64d8" translate="yes" xml:space="preserve">
          <source>Name of schema containing table</source>
          <target state="translated">テーブルを含むスキーマ名</target>
        </trans-unit>
        <trans-unit id="dd40e81316e76702c45608033ccb5e0f85f3dfea" translate="yes" xml:space="preserve">
          <source>Name of schema containing table and index</source>
          <target state="translated">テーブルとインデックスを含むスキーマ名</target>
        </trans-unit>
        <trans-unit id="b025c1d95310dde444c37ad986883a8dee5bb9d3" translate="yes" xml:space="preserve">
          <source>Name of schema containing table policy is on</source>
          <target state="translated">テーブルポリシーを含むスキーマ名がオンになっている</target>
        </trans-unit>
        <trans-unit id="651e03eac67fc05e08a5fc3c4b0db8b8a5ca2d70" translate="yes" xml:space="preserve">
          <source>Name of schema containing view</source>
          <target state="translated">ビューを含むスキーマ名</target>
        </trans-unit>
        <trans-unit id="fd465cc8a117f3266eab848066483930a22454ae" translate="yes" xml:space="preserve">
          <source>Name of sequence</source>
          <target state="translated">シーケンス名</target>
        </trans-unit>
        <trans-unit id="f8e19bb0d7e02e23ea651a2fbd412be10bd907ea" translate="yes" xml:space="preserve">
          <source>Name of sequence's owner</source>
          <target state="translated">シーケンスの所有者の名前</target>
        </trans-unit>
        <trans-unit id="2c617ffcb7fc75270eec292d65c4160eff374b06" translate="yes" xml:space="preserve">
          <source>Name of table</source>
          <target state="translated">テーブル名</target>
        </trans-unit>
        <trans-unit id="f10df6f392a1568c4d43e34377ec16b2f3a7fa44" translate="yes" xml:space="preserve">
          <source>Name of table policy is on</source>
          <target state="translated">テーブルポリシーの名前がついている</target>
        </trans-unit>
        <trans-unit id="c0513b8ba01d1af1c795daf01358ee55cf3296c9" translate="yes" xml:space="preserve">
          <source>Name of table the index is for</source>
          <target state="translated">インデックスの対象となるテーブル名</target>
        </trans-unit>
        <trans-unit id="d795c0056cb1fd8b2838b400cf90a77a5b34f1c7" translate="yes" xml:space="preserve">
          <source>Name of table the rule is for</source>
          <target state="translated">ルールが適用されるテーブル名</target>
        </trans-unit>
        <trans-unit id="6f44460598242d440e308c5206bbdd4ee6c15df5" translate="yes" xml:space="preserve">
          <source>Name of table's owner</source>
          <target state="translated">テーブルの所有者名</target>
        </trans-unit>
        <trans-unit id="cc73fa216f99d868d036ec5fa8be32ea593b2352" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing index (null if default for database)</source>
          <target state="translated">インデックスを含むテーブル空間の名前(データベースのデフォルトの場合はnull)</target>
        </trans-unit>
        <trans-unit id="13a740701fe416ff32d444b4b9dea241f97f8406" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing materialized view (null if default for database)</source>
          <target state="translated">マテリアライズされたビューを含むテーブルスペースの名前(データベースのデフォルトの場合はnull)</target>
        </trans-unit>
        <trans-unit id="e235059f85c95c9cf0964b16c38689bf7ab5f960" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing table (null if default for database)</source>
          <target state="translated">テーブルを含むテーブル空間の名前(データベースのデフォルトの場合はnull)</target>
        </trans-unit>
        <trans-unit id="38df58659a85a8c6be97b9180f6ba3a3db8fd801" translate="yes" xml:space="preserve">
          <source>Name of the SLRU</source>
          <target state="translated">SLRUの名称</target>
        </trans-unit>
        <trans-unit id="b950b20317e5d48a4d7180b3b67b23925387d954" translate="yes" xml:space="preserve">
          <source>Name of the WAL file of the last failed archival operation</source>
          <target state="translated">最後に失敗したアーカイブ操作のWALファイル名</target>
        </trans-unit>
        <trans-unit id="50c7ff72173e6a33ac0f4b45d6945424b157e3f8" translate="yes" xml:space="preserve">
          <source>Name of the access method</source>
          <target state="translated">アクセス方法の名前</target>
        </trans-unit>
        <trans-unit id="42336fd50699db80c8e30a44b238f551cdfe5e05" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this WAL sender</source>
          <target state="translated">このWAL送信元に接続されているアプリケーション名</target>
        </trans-unit>
        <trans-unit id="73eb48e900d4da8e91ccec691048b06a84e20927" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this backend</source>
          <target state="translated">このバックエンドに接続されているアプリケーションの名前</target>
        </trans-unit>
        <trans-unit id="e5622c8d744e74d58e5852a23ea1813374720ca0" translate="yes" xml:space="preserve">
          <source>Name of the column described by this row</source>
          <target state="translated">この行で記述されている列の名前</target>
        </trans-unit>
        <trans-unit id="05582534113d6fd58f1c91cf719019de03349552" translate="yes" xml:space="preserve">
          <source>Name of the database in which the transaction was executed</source>
          <target state="translated">トランザクションが実行されたデータベースの名前</target>
        </trans-unit>
        <trans-unit id="3c046694c5a00d97ff6a1379659314bd6a78ef25" translate="yes" xml:space="preserve">
          <source>Name of the database this backend is connected to</source>
          <target state="translated">このバックエンドが接続しているデータベースの名前</target>
        </trans-unit>
        <trans-unit id="21b466dc28882ad5e606c7e29b3635f8046375c5" translate="yes" xml:space="preserve">
          <source>Name of the database to which this backend is connected.</source>
          <target state="translated">このバックエンドが接続されているデータベースの名前。</target>
        </trans-unit>
        <trans-unit id="a4b1ce5ff884a2efdb43d43a59c57f0b4fa4d401" translate="yes" xml:space="preserve">
          <source>Name of the event source for pg_ctl to use for logging to the event log when running as a Windows service. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. Note that this only controls messages sent from pg_ctl itself; once started, the server will use the event source specified by its &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; parameter. Should the server fail very early in startup, before that parameter has been set, it might also log using the default event source name &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">Windowsサービスとして実行しているときにpg_ctlがイベントログへのロギングに使用するイベントソースの名前。デフォルトは &lt;code&gt;PostgreSQL&lt;/code&gt; です。これはpg_ctl自体から送信されたメッセージのみを制御することに注意してください。起動すると、サーバーは、&lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt;パラメータで指定されたイベントソースを使用します。サーバーが起動の非常に早い段階で失敗した場合、そのパラメーターが設定される前に、デフォルトのイベントソース名 &lt;code&gt;PostgreSQL&lt;/code&gt; を使用してログに記録することもあります。</target>
        </trans-unit>
        <trans-unit id="db2a8ab1c7a6e8e7352acea353746079da1e0da5" translate="yes" xml:space="preserve">
          <source>Name of the extension</source>
          <target state="translated">拡張子の名前</target>
        </trans-unit>
        <trans-unit id="b32842559bebdaa75c2073237260c49768556ba4" translate="yes" xml:space="preserve">
          <source>Name of the field to order siblings by (optional)</source>
          <target state="translated">兄弟を順番に並べるフィールドの名前(オプション</target>
        </trans-unit>
        <trans-unit id="d305530c62c0c372c9b705ff8915012e6f1258b2" translate="yes" xml:space="preserve">
          <source>Name of the foreign server</source>
          <target state="translated">海外サーバーの名前</target>
        </trans-unit>
        <trans-unit id="59348747feca44834dd28cf94d333b16c8cfbbf0" translate="yes" xml:space="preserve">
          <source>Name of the foreign-data wrapper</source>
          <target state="translated">外部データラッパーの名前</target>
        </trans-unit>
        <trans-unit id="9e20c57335eda37ac38552a55cb17fe874d8fb6b" translate="yes" xml:space="preserve">
          <source>Name of the function</source>
          <target state="translated">機能名</target>
        </trans-unit>
        <trans-unit id="eee39eba3634db32e7cb3a66942216268c13c704" translate="yes" xml:space="preserve">
          <source>Name of the group</source>
          <target state="translated">グループ名</target>
        </trans-unit>
        <trans-unit id="e6e050c906fd9fbc0c7b4d3a235e25d068290256" translate="yes" xml:space="preserve">
          <source>Name of the key field</source>
          <target state="translated">キーフィールドの名前</target>
        </trans-unit>
        <trans-unit id="b217fce5b600ff5e59a7bde206ff84c6743ebd06" translate="yes" xml:space="preserve">
          <source>Name of the language</source>
          <target state="translated">言語名</target>
        </trans-unit>
        <trans-unit id="999d13acc30868afb96a2061f85f8cfbf835af9a" translate="yes" xml:space="preserve">
          <source>Name of the language this template is for</source>
          <target state="translated">このテンプレートが対象とする言語名</target>
        </trans-unit>
        <trans-unit id="c0904d4653e24f5cf40ca0e66167033212dff01e" translate="yes" xml:space="preserve">
          <source>Name of the last WAL file successfully archived</source>
          <target state="translated">最後にアーカイブに成功したWALファイルの名前</target>
        </trans-unit>
        <trans-unit id="632030382b37c4353da7f8cfd3fb10f03fb4878e" translate="yes" xml:space="preserve">
          <source>Name of the local user to be mapped</source>
          <target state="translated">マップされるローカルユーザーの名前</target>
        </trans-unit>
        <trans-unit id="3283788f7750678653d33179d0a9b570a3fb07a0" translate="yes" xml:space="preserve">
          <source>Name of the lock mode held or desired by this process (see &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;Section 13.3.1&lt;/a&gt; and &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;)</source>
          <target state="translated">このプロセスが保持または希望するロックモードの名前（&lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;セクション13.3.1&lt;/a&gt;および&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;セクション13.2.3を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="bca4b201210cb86555d12a73e7fa1d0df2b4ce1d" translate="yes" xml:space="preserve">
          <source>Name of the namespace</source>
          <target state="translated">名前空間の名前</target>
        </trans-unit>
        <trans-unit id="116ede6679101b358b013bfe3778515f6a6eb59a" translate="yes" xml:space="preserve">
          <source>Name of the notification channel to be signaled (any identifier).</source>
          <target state="translated">シグナルする通知チャネルの名前(任意の識別子)。</target>
        </trans-unit>
        <trans-unit id="b1846b8dfbb275c5d01dbe581ad89ecd8bd17f99" translate="yes" xml:space="preserve">
          <source>Name of the on-disk file of this relation; zero means this is a &amp;ldquo;mapped&amp;rdquo; relation whose disk file name is determined by low-level state</source>
          <target state="translated">この関係のディスク上のファイルの名前。ゼロは、これが「マップされた」リレーションであることを意味し、そのディスクファイル名は低レベルの状態によって決定されます</target>
        </trans-unit>
        <trans-unit id="ffd1b3d5baf3902d7d64e922601a9c11dc846fd8" translate="yes" xml:space="preserve">
          <source>Name of the operator</source>
          <target state="translated">オペレータ名</target>
        </trans-unit>
        <trans-unit id="f362cae832a0a92cf6859f4e3035227030a3fa7e" translate="yes" xml:space="preserve">
          <source>Name of the parent-key field</source>
          <target state="translated">親キーフィールドの名前</target>
        </trans-unit>
        <trans-unit id="914386f36015301aa42cdc85d2971f37bbd3f6e1" translate="yes" xml:space="preserve">
          <source>Name of the publication</source>
          <target state="translated">出版物名</target>
        </trans-unit>
        <trans-unit id="f8ba7366e5638b5adb85cf058a4f60fc77a1437d" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database (also used for the local replication origin name); null represents &lt;code&gt;NONE&lt;/code&gt;</source>
          <target state="translated">アップストリームデータベースのレプリケーションスロットの名前（ローカルレプリケーションの起点名にも使用されます）。nullは &lt;code&gt;NONE&lt;/code&gt; を表します</target>
        </trans-unit>
        <trans-unit id="95141217167b4e44530e9c633ef9691ad9e4c7d5" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database. Also used for local replication origin name.</source>
          <target state="translated">上流データベースのレプリケーションスロットの名前。ローカルレプリケーションのオリジン名にも使用されます。</target>
        </trans-unit>
        <trans-unit id="48b6dcd7b3f9b0cceabe3c942a0ff0d053cf3051" translate="yes" xml:space="preserve">
          <source>Name of the replication slot to use. The default behavior is to use the name of the subscription for the slot name.</source>
          <target state="translated">使用するレプリケーション スロットの名前。デフォルトの動作は、スロット名にサブスクリプションの名前を使用することです。</target>
        </trans-unit>
        <trans-unit id="0c22c3cdbc7df0d29a30ef0e5d20c6d53a22aba3" translate="yes" xml:space="preserve">
          <source>Name of the schema that the extension must be installed into, or &lt;code&gt;NULL&lt;/code&gt; if partially or fully relocatable</source>
          <target state="translated">拡張機能をインストールする必要があるスキーマの名前、または部分的または完全に再配置可能な場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46b2c8652132c7dc1c02610fe232f22c32a70e49" translate="yes" xml:space="preserve">
          <source>Name of the schema that this table is in</source>
          <target state="translated">このテーブルが存在するスキーマ名</target>
        </trans-unit>
        <trans-unit id="aeed8d4431144cabd5a1127005bce646d16cab11" translate="yes" xml:space="preserve">
          <source>Name of the schema this function is in</source>
          <target state="translated">この関数が存在するスキーマの名前</target>
        </trans-unit>
        <trans-unit id="b11dd1fd926881e2c689b2ce026036d1c6bf66aa" translate="yes" xml:space="preserve">
          <source>Name of the schema this index is in</source>
          <target state="translated">このインデックスが存在するスキーマの名前</target>
        </trans-unit>
        <trans-unit id="55e1e35ee330306af1edafba8c0ccceb0641d202" translate="yes" xml:space="preserve">
          <source>Name of the schema this sequence is in</source>
          <target state="translated">このシーケンスが存在するスキーマの名前</target>
        </trans-unit>
        <trans-unit id="d75b4d0b583232f5341524b6ac4e00946212dc64" translate="yes" xml:space="preserve">
          <source>Name of the source relation</source>
          <target state="translated">ソース関係の名前</target>
        </trans-unit>
        <trans-unit id="02fe646b94a9a3942519f9c9b3db9e92f9c9c3fd" translate="yes" xml:space="preserve">
          <source>Name of the statistics object</source>
          <target state="translated">統計オブジェクトの名前</target>
        </trans-unit>
        <trans-unit id="33574f9c61c2e627eb0d3d0f3da70a170678a9ff" translate="yes" xml:space="preserve">
          <source>Name of the subscription</source>
          <target state="translated">購読名</target>
        </trans-unit>
        <trans-unit id="90ae080c0a5fc808f5e0a7e8b8cae579504b16d5" translate="yes" xml:space="preserve">
          <source>Name of the system service to register. This name will be used as both the service name and the display name. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">登録するシステムサービスの名前。この名前は、サービス名と表示名の両方として使用されます。デフォルトは &lt;code&gt;PostgreSQL&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f5e271781547e2a1e2376a48974f2d9fab48cde2" translate="yes" xml:space="preserve">
          <source>Name of the table for this index</source>
          <target state="translated">このインデックスのテーブル名</target>
        </trans-unit>
        <trans-unit id="0200e1f7b3df494bd305d84c497873916f941937" translate="yes" xml:space="preserve">
          <source>Name of the table, index, view, etc.</source>
          <target state="translated">テーブル、インデックス、ビューなどの名前</target>
        </trans-unit>
        <trans-unit id="a1f59b4d65687dc8fe0a85f1b74351b10bfba7a6" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this WAL sender process</source>
          <target state="translated">このWAL送信者プロセスにログインしているユーザー名</target>
        </trans-unit>
        <trans-unit id="3fe80a85bf2161f51d9c08098d7bfcdedce6c9ee" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this backend</source>
          <target state="translated">このバックエンドにログインしているユーザーの名前</target>
        </trans-unit>
        <trans-unit id="04f7b7b315d382679587d80fba309d2bb70b1345" translate="yes" xml:space="preserve">
          <source>Name of the user that executed the transaction</source>
          <target state="translated">トランザクションを実行したユーザー名</target>
        </trans-unit>
        <trans-unit id="c24f99aa0c8caf23a96b75cece5098629fd6a94e" translate="yes" xml:space="preserve">
          <source>Name of this database</source>
          <target state="translated">このデータベースの名前</target>
        </trans-unit>
        <trans-unit id="2086d14cece3b039e0a515f48cc92518784c4d7a" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects.</source>
          <target state="translated">このデータベースの名前、または共有オブジェクトの場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73d6411e8bd4b74b577e7365540cb543464ed926" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects.</source>
          <target state="translated">このデータベースの名前、または共有オブジェクトの場合は &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09edc4fe28078a94e956caa9447364b4707b6491" translate="yes" xml:space="preserve">
          <source>Name of this function</source>
          <target state="translated">この関数の名前</target>
        </trans-unit>
        <trans-unit id="a2e0e5204a994c27fb6b9e0e825c613dd1c4755e" translate="yes" xml:space="preserve">
          <source>Name of this index</source>
          <target state="translated">このインデックスの名前</target>
        </trans-unit>
        <trans-unit id="52256e99af10a92f8d2567b55a83d56fe82e813a" translate="yes" xml:space="preserve">
          <source>Name of this operator class</source>
          <target state="translated">この演算子クラスの名前</target>
        </trans-unit>
        <trans-unit id="8660634803fb7c50b11c80dde370467806dff8e0" translate="yes" xml:space="preserve">
          <source>Name of this operator family</source>
          <target state="translated">このオペレータのファミリー名</target>
        </trans-unit>
        <trans-unit id="67e86bea4f13cfb5fdec580a24af26d2de2fdc44" translate="yes" xml:space="preserve">
          <source>Name of this sequence</source>
          <target state="translated">このシーケンスの名前</target>
        </trans-unit>
        <trans-unit id="b490c1221b4b64551bfddc6b8b9c77d0ea3870a9" translate="yes" xml:space="preserve">
          <source>Name of this table</source>
          <target state="translated">このテーブルの名前</target>
        </trans-unit>
        <trans-unit id="79333580b15aa0175b731014d71be95e862ff44a" translate="yes" xml:space="preserve">
          <source>Name of validator function, or null if none</source>
          <target state="translated">バリデータ関数の名前。</target>
        </trans-unit>
        <trans-unit id="d340979d7f1712dd54645083825a2794537380b7" translate="yes" xml:space="preserve">
          <source>Name of view</source>
          <target state="translated">ビューの名前</target>
        </trans-unit>
        <trans-unit id="ca9987204d1e0d3bf0d8020ca5eccf2de116a77a" translate="yes" xml:space="preserve">
          <source>Name of view's owner</source>
          <target state="translated">ビューの所有者名</target>
        </trans-unit>
        <trans-unit id="715cd77a48eca5f7bbf90153374438716221cbe4" translate="yes" xml:space="preserve">
          <source>Named and mixed call notations currently cannot be used when calling an aggregate function (but they do work when an aggregate function is used as a window function).</source>
          <target state="translated">現在、集約関数を呼び出す際には、名前付きおよび混合呼び出し表記は使用できません(ただし、集約関数がウィンドウ関数として使用されている場合は機能します)。</target>
        </trans-unit>
        <trans-unit id="febb13b6b6bedee695a2cdffc8584795987df071" translate="yes" xml:space="preserve">
          <source>Named run-time parameters can be set in either of these styles:</source>
          <target state="translated">指定されたランタイムパラメータは、これらのスタイルのいずれかで設定することができます。</target>
        </trans-unit>
        <trans-unit id="b335beb0e29ec02f76a030301ce30aec55d10a00" translate="yes" xml:space="preserve">
          <source>Names can be assigned to table constraints in the same way as column constraints:</source>
          <target state="translated">名前は、列制約と同じようにテーブル制約に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="90e76064cba28bce291e20a00492ac8908ed2815" translate="yes" xml:space="preserve">
          <source>Names of prerequisite extensions, or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">前提条件の拡張の名前。ない場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="879c37a97f04ee34ad69a53c4aa464879102ff50" translate="yes" xml:space="preserve">
          <source>Names of the columns the extended statistics is defined on</source>
          <target state="translated">拡張統計情報が定義されている列の名前</target>
        </trans-unit>
        <trans-unit id="774a71278e16cec9ccf959b5bab94713611e399e" translate="yes" xml:space="preserve">
          <source>Names of the publications on the publisher to subscribe to.</source>
          <target state="translated">購読する出版社に掲載されている出版物の名前</target>
        </trans-unit>
        <trans-unit id="ef2014703004a1217b3fec5210db4117b70e51de" translate="yes" xml:space="preserve">
          <source>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</source>
          <target state="translated">接続先のLDAPサーバーの名前またはIPアドレス。スペースで区切って複数のサーバーを指定することができます。</target>
        </trans-unit>
        <trans-unit id="3f95be766c8568501a000e46e6894d04ef9f8877" translate="yes" xml:space="preserve">
          <source>Namespace Available to &lt;code&gt;GROUP BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; および &lt;code&gt;ORDER BY&lt;/code&gt; で使用可能な名前空間</target>
        </trans-unit>
        <trans-unit id="47230dc537dc21987e746d4c719b4cc41ae69b6a" translate="yes" xml:space="preserve">
          <source>Namespace of this operator class</source>
          <target state="translated">この演算子クラスの名前空間</target>
        </trans-unit>
        <trans-unit id="a230663970531d46658f671326f61bad6755f192" translate="yes" xml:space="preserve">
          <source>Namespace of this operator family</source>
          <target state="translated">この演算子ファミリの名前空間</target>
        </trans-unit>
        <trans-unit id="a1c428db5a690b5f5a2a8bbbdfae45bd49175ad0" translate="yes" xml:space="preserve">
          <source>National Language Support</source>
          <target state="translated">ナショナルランゲージサポート</target>
        </trans-unit>
        <trans-unit id="725efb9e43acf1bf580c09d2cb1b0cf911451468" translate="yes" xml:space="preserve">
          <source>National Standard</source>
          <target state="translated">ナショナルスタンダード</target>
        </trans-unit>
        <trans-unit id="9d1f7ad08bfbe66715ad20935eced5ce9dc0eb67" translate="yes" xml:space="preserve">
          <source>Natural logarithm</source>
          <target state="translated">自然対数</target>
        </trans-unit>
        <trans-unit id="a9c36a47f8e482a64ff81cd9e84619cb8413e09b" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument</source>
          <target state="translated">引数以上の最も近い整数</target>
        </trans-unit>
        <trans-unit id="68c2729e4aa8267e02a5e14878260b805c76e4f0" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument (same as &lt;code&gt;ceil&lt;/code&gt;)</source>
          <target state="translated">引数以上の最も近い整数（ &lt;code&gt;ceil&lt;/code&gt; と同じ）</target>
        </trans-unit>
        <trans-unit id="333e55744c1836d8e2f747a46f8a58bd387549f7" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the SQL/JSON number</source>
          <target state="translated">SQL/JSON 数以上の最も近い整数</target>
        </trans-unit>
        <trans-unit id="3089188f4ef21fadc5a7ae8a8917660ce59f776c" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the given number</source>
          <target state="translated">指定された数以上の最も近い整数</target>
        </trans-unit>
        <trans-unit id="ebc0f09f7738d16783cda39dfae33946b8073a87" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to argument</source>
          <target state="translated">引数以下の最も近い整数</target>
        </trans-unit>
        <trans-unit id="bee672459bc21a36f5d885e59227b9978e9d1866" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the SQL/JSON number</source>
          <target state="translated">SQL/JSON 数以下の最も近い整数</target>
        </trans-unit>
        <trans-unit id="6a166687429ef42663b71e2fae4f0d6dcf7415c3" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the given number</source>
          <target state="translated">与えられた数以下の最も近い整数</target>
        </trans-unit>
        <trans-unit id="8e224c76bc25e4149e084462adee5b7564caac26" translate="yes" xml:space="preserve">
          <source>Needless to say, processing XML data with PostgreSQL will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Since XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.</source>
          <target state="translated">言うまでもなく、PostgreSQLでXMLデータを処理する場合、XMLデータの符号化方式、クライアント符号化方式、サーバ符号化方式が同じであれば、エラーが発生しにくく効率的です。XMLデータは内部的にUTF-8で処理されますので、サーバのエンコーディングもUTF-8にした方が最も効率的な計算ができます。</target>
        </trans-unit>
        <trans-unit id="dfc508fa9ddaeb33e233aa812ebad0ab8c049dd2" translate="yes" xml:space="preserve">
          <source>Negate an interval</source>
          <target state="translated">区間を否定する</target>
        </trans-unit>
        <trans-unit id="1b33f9b7a0a4606b4bd747722b21501d99fa70ad" translate="yes" xml:space="preserve">
          <source>Negates a &lt;code&gt;tsquery&lt;/code&gt;, producing a query that matches documents that do not match the input query.</source>
          <target state="translated">否定 &lt;code&gt;tsquery&lt;/code&gt; 一致文書が入力されたクエリと一致しないというクエリを生成します、。</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="192f6939bf2bfe49ee33bf49687c9297f6c0972d" translate="yes" xml:space="preserve">
          <source>Negation; unlike subtraction, this can iterate over multiple values</source>
          <target state="translated">否定;減算とは異なり、複数の値を反復して処理することができます。</target>
        </trans-unit>
        <trans-unit id="27cadf6ca95971ac3dd5c11e621924026c16209f" translate="yes" xml:space="preserve">
          <source>Negator of this operator, if any</source>
          <target state="translated">もしあれば、この演算子の負子</target>
        </trans-unit>
        <trans-unit id="cdedd7a3e12a28ecdae254105845f04dc8b7e221" translate="yes" xml:space="preserve">
          <source>Neither sequential scans nor nested-loop joins can be disabled completely; the &lt;code&gt;-fs&lt;/code&gt; and &lt;code&gt;-fn&lt;/code&gt; options simply discourage the optimizer from using those plan types if it has any other alternative.</source>
          <target state="translated">順次スキャンもネストループ結合も完全に無効にすることはできません。 &lt;code&gt;-fs&lt;/code&gt; と &lt;code&gt;-fn&lt;/code&gt; オプションは、単にそれは、他の選択肢を持っている場合、これらの計画型を使用してから、オプティマイザを阻止します。</target>
        </trans-unit>
        <trans-unit id="999497fbc59b4c8badf88b3dddf684b5320af0cd" translate="yes" xml:space="preserve">
          <source>Neither the source nor the destination encoding can be &lt;code&gt;SQL_ASCII&lt;/code&gt;, as the server's behavior for cases involving the &lt;code&gt;SQL_ASCII&lt;/code&gt;&amp;ldquo;encoding&amp;rdquo; is hard-wired.</source>
          <target state="translated">&lt;code&gt;SQL_ASCII&lt;/code&gt; の「エンコーディング」が関係する場合のサーバーの動作はハードワイヤードであるため、ソースエンコーディングもデスティネーションエンコーディングも &lt;code&gt;SQL_ASCII&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="dc249089e46e70234a72d288cf1c8de145f74bd2" translate="yes" xml:space="preserve">
          <source>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained from configuration files stored under &lt;code&gt;.../share/timezone/&lt;/code&gt; and &lt;code&gt;.../share/timezonesets/&lt;/code&gt; of the installation directory (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;).</source>
          <target state="translated">タイムゾーン名も省略形もサーバーに組み込まれていません。これらは、インストールディレクトリの &lt;code&gt;.../share/timezone/&lt;/code&gt; および &lt;code&gt;.../share/timezonesets/&lt;/code&gt; に保存されている構成ファイルから取得されます（&lt;a href=&quot;datetime-config-files&quot;&gt;セクションB.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="8d546e29b4f4fdcb009106a5c128188e2431946d" translate="yes" xml:space="preserve">
          <source>NetBSD versions before 5.0 work like old OpenBSD (see below), except that kernel parameters should be set with the keyword &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt;.</source>
          <target state="translated">5.0より前のバージョンのNetBSDは古いOpenBSD（下記を参照）と同様に機能しますが、カーネルパラメーターは &lt;code&gt;options&lt;/code&gt; ではなくキーワードoptionsで設定する必要があり &lt;code&gt;option&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4970c28f364d041c28f5d5ff2bc88daf1a13ad01" translate="yes" xml:space="preserve">
          <source>Network Address Types</source>
          <target state="translated">ネットワークアドレスの種類</target>
        </trans-unit>
        <trans-unit id="1aab162fb1d4be431f43c575684b7d8c545c8302" translate="yes" xml:space="preserve">
          <source>Network Address Types: cidr</source>
          <target state="translated">ネットワークアドレスの種類:cidr</target>
        </trans-unit>
        <trans-unit id="a0a4631210875f94aba2f16fc813f4614e393764" translate="yes" xml:space="preserve">
          <source>Network Address Types: inet</source>
          <target state="translated">ネットワークアドレスの種類:inet</target>
        </trans-unit>
        <trans-unit id="341da3e8cf1498f3f62648168d4190e67f278782" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr</source>
          <target state="translated">ネットワークアドレスの種類:macaddr</target>
        </trans-unit>
        <trans-unit id="81bbd3c87492587fd7ddfed55118e840abffce9f" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr8</source>
          <target state="translated">ネットワークアドレスの種類:macaddr8</target>
        </trans-unit>
        <trans-unit id="c5f17a43f889ac0d89795d00fba1671fe47f62f0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;</source>
          <target state="translated">ネットワークアドレス： ＆</target>
        </trans-unit>
        <trans-unit id="3182c01748d8a83efe78a3f4ab6c4e990eacea0c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;&amp;amp;</source>
          <target state="translated">ネットワークアドレス： ＆＆</target>
        </trans-unit>
        <trans-unit id="c32091a6107e7e44a68fb436fb33982336ccc452" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;</source>
          <target state="translated">ネットワークアドレス：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="86a00c20e3381c9260f079dcb6e41c4262f1ea3a" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;</source>
          <target state="translated">ネットワークアドレス：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3736d0bb3a030e00d7114ef9030a0916af6881f" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;=</source>
          <target state="translated">ネットワークアドレス：&amp;gt;&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="b6a612c0f5ca1e234f11a6f50c9a9f41342ace58" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;=</source>
          <target state="translated">ネットワークアドレス：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="0cab881598e19094a73fe2cb680ef2e7600ff52c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;</source>
          <target state="translated">ネットワークアドレス：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a2a64bdcd407fdda5883dcb3954eb4988b1bf440" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;gt;</source>
          <target state="translated">ネットワークアドレス：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e00740580248e58ab92c3eb2672f19b765c748b0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;</source>
          <target state="translated">ネットワークアドレス：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1ff901142c2068fe8cf464afe26c9042106af748" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;=</source>
          <target state="translated">ネットワークアドレス：&amp;lt;&amp;lt; =</target>
        </trans-unit>
        <trans-unit id="68fb0bbbf4bee491f6e6bbc78cee804b2462e684" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;=</source>
          <target state="translated">ネットワークアドレス：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="6b9e98c353b63977350c4597ab783ed68802ee56" translate="yes" xml:space="preserve">
          <source>Network Address: +</source>
          <target state="translated">ネットワークアドレス +</target>
        </trans-unit>
        <trans-unit id="39dd97c5cafd7589b71c3638f6bb1482a7b84d8f" translate="yes" xml:space="preserve">
          <source>Network Address: -</source>
          <target state="translated">ネットワークアドレス -</target>
        </trans-unit>
        <trans-unit id="777f2ecef47fe73d67412a0b49eb5b48a584a4d2" translate="yes" xml:space="preserve">
          <source>Network Address: 200 + inet &amp;#x27;::ffff:fff0:1&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：200 + inet ':: ffff：fff0：1'</target>
        </trans-unit>
        <trans-unit id="4b124004ce04609acad1c95336f7a76fcba56d8c" translate="yes" xml:space="preserve">
          <source>Network Address: 4</source>
          <target state="translated">ネットワークアドレス。4</target>
        </trans-unit>
        <trans-unit id="b43debcb1e648bae4f59d9ad9d57421aa61da314" translate="yes" xml:space="preserve">
          <source>Network Address: =</source>
          <target state="translated">ネットワークアドレス</target>
        </trans-unit>
        <trans-unit id="f6da4644273b4e1c84158d7bdc34944932533ec4" translate="yes" xml:space="preserve">
          <source>Network Address: abbrev</source>
          <target state="translated">ネットワークアドレス:略</target>
        </trans-unit>
        <trans-unit id="c0aa9d1b8f2a11dc8e2d5492bfd563df5e51a186" translate="yes" xml:space="preserve">
          <source>Network Address: broadcast</source>
          <target state="translated">ネットワークアドレス:ブロードキャスト</target>
        </trans-unit>
        <trans-unit id="22c496032e898e93c86c9e0b2d1794774c6cc3b0" translate="yes" xml:space="preserve">
          <source>Network Address: family</source>
          <target state="translated">ネットワークアドレス:家族</target>
        </trans-unit>
        <trans-unit id="6144652f94deb193ec23e96153e939af827c258d" translate="yes" xml:space="preserve">
          <source>Network Address: host</source>
          <target state="translated">ネットワークアドレス:ホスト</target>
        </trans-unit>
        <trans-unit id="60b63d4c005ed64503064242e41d8bfa685a802b" translate="yes" xml:space="preserve">
          <source>Network Address: hostmask</source>
          <target state="translated">ネットワークアドレス:hostmask</target>
        </trans-unit>
        <trans-unit id="ed88700d6440e7a05db8038b5e1ae51130f83f6c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.0.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.0.5' &amp;lt;&amp;lt; inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="0f03ec2774c64bbb3436fa6566e034e58c68aaf6" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - 36</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1.43'-36</target>
        </trans-unit>
        <trans-unit id="6cd543dd857eb909c7c1f144d1c68cc26ed17c84" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - inet &amp;#x27;192.168.1.19&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1.43'-inet' 192.168.1.19 '</target>
        </trans-unit>
        <trans-unit id="cba4aae2f54763673ad24c08605a0dc7418f7e69" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1.5' &amp;lt;&amp;lt; inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="bf25351bf5e670090a9a613676ffca0130707992" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; &amp;amp; inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1.6'＆inet '0.0.0.255'</target>
        </trans-unit>
        <trans-unit id="bb861d30d1aca8b8d63e37fc34ab35aac460d1f8" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; + 25</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1.6' + 25</target>
        </trans-unit>
        <trans-unit id="47709a664ccb6f4f20ab0bedea8e5350679a1107" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; | inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1.6' | inet '0.0.0.255'</target>
        </trans-unit>
        <trans-unit id="538a8494f874e1b3946b7a79168cf4b1aa49a99c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.1.80/28&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1 / 24' &amp;amp;&amp;amp; inet '192.168.1.80 / 28'</target>
        </trans-unit>
        <trans-unit id="b08083b1369b886565f8ea80c8058e2d3af87577" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.2.0/28&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1 / 24' &amp;amp;&amp;amp; inet '192.168.2.0/28'</target>
        </trans-unit>
        <trans-unit id="3b9c76f3500e47f384b3cac60e30dacdb3c47029" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt; inet &amp;#x27;192.168.1.5&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1 / 24' &amp;gt;&amp;gt; inet '192.168.1.5'</target>
        </trans-unit>
        <trans-unit id="c5a7912881770eacd62ec019a35b786530ba8e82" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1 / 24' &amp;gt;&amp;gt; = inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="c3f515856eebe2d81a6af46f2f540cf2ea72af80" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1 / 24' &amp;lt;&amp;lt; inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="f49b063066e4c4fbd3500c30f240ef74c750c98e" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet '192.168.1 / 24' &amp;lt;&amp;lt; = inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="2e5e1d3f81690c06565afe5ca9d8a5a94ccf4f70" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;::1&amp;#x27; - inet &amp;#x27;::ffff:1&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：inet ':: 1'-inet' :: ffff：1 '</target>
        </trans-unit>
        <trans-unit id="d7c102cda170efbd5c926c080194943072fd0080" translate="yes" xml:space="preserve">
          <source>Network Address: inet_merge</source>
          <target state="translated">ネットワークアドレス:inet_merge</target>
        </trans-unit>
        <trans-unit id="026b427d2abc32061f460f5004b1e92329b176c3" translate="yes" xml:space="preserve">
          <source>Network Address: inet_same_family</source>
          <target state="translated">ネットワークアドレス:inet_same_family</target>
        </trans-unit>
        <trans-unit id="78246e2d890ea6d8b5a4e72ded75baf6bfea7473" translate="yes" xml:space="preserve">
          <source>Network Address: macaddr8_set7bit</source>
          <target state="translated">ネットワークアドレス:macaddr8_set7bit</target>
        </trans-unit>
        <trans-unit id="1c089819bd8607b5f9a99695372b4e5df1ae11f3" translate="yes" xml:space="preserve">
          <source>Network Address: masklen</source>
          <target state="translated">ネットワークアドレス:マスクレン</target>
        </trans-unit>
        <trans-unit id="e38c25828a5f421b05060a2505734c3b8ed3c4ff" translate="yes" xml:space="preserve">
          <source>Network Address: netmask</source>
          <target state="translated">ネットワークアドレス:ネットマスク</target>
        </trans-unit>
        <trans-unit id="9e08bb5a4ba97edb3516d3ee46ca743eed995918" translate="yes" xml:space="preserve">
          <source>Network Address: network</source>
          <target state="translated">ネットワークアドレス:ネットワーク</target>
        </trans-unit>
        <trans-unit id="e7c94e499362212c6e5807040cfed09039e1ec82" translate="yes" xml:space="preserve">
          <source>Network Address: set_masklen</source>
          <target state="translated">ネットワークアドレス:set_masklen</target>
        </trans-unit>
        <trans-unit id="0ec1baf847c109f5d8cc27de72a96ec587a99682" translate="yes" xml:space="preserve">
          <source>Network Address: text</source>
          <target state="translated">ネットワークアドレス:テキスト</target>
        </trans-unit>
        <trans-unit id="221efaf6a0e58b3e7e632e503daaffa7a1a069d7" translate="yes" xml:space="preserve">
          <source>Network Address: trunc</source>
          <target state="translated">ネットワークアドレス:切り捨て</target>
        </trans-unit>
        <trans-unit id="ab7cd2917681a96bc47067425beee2467a73704d" translate="yes" xml:space="preserve">
          <source>Network Address: |</source>
          <target state="translated">ネットワークアドレス |</target>
        </trans-unit>
        <trans-unit id="83814dd86a48a4c95e9a2274b66946fe0603b1c9" translate="yes" xml:space="preserve">
          <source>Network Address: ~</source>
          <target state="translated">ネットワークアドレス。~</target>
        </trans-unit>
        <trans-unit id="103c5dac467afa451157b604c5b1cc764cc21efb" translate="yes" xml:space="preserve">
          <source>Network Address: ~ inet &amp;#x27;192.168.1.6&amp;#x27;</source>
          <target state="translated">ネットワークアドレス：〜inet '192.168.1.6'</target>
        </trans-unit>
        <trans-unit id="0a2ec6319838e0ec218c4906d73f925465627945" translate="yes" xml:space="preserve">
          <source>Network address types</source>
          <target state="translated">ネットワークアドレスの種類</target>
        </trans-unit>
        <trans-unit id="424a86543035666947635d11018cbc54c86cb289" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">パスワードプロンプトを発行しないでください。サーバーがパスワード認証を必要とし、 &lt;code&gt;.pgpass&lt;/code&gt; ファイルなどの他の方法でパスワードを使用できない場合、接続の試行は失敗します。このオプションは、パスワードを入力するユーザーがいないバッチジョブやスクリプトで役立ちます。</target>
        </trans-unit>
        <trans-unit id="9093e824038ec1b001eb89049bd2ea01904578a0" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">パスワードプロンプトを発行しないでください。サーバーがパスワード認証を必要とし、パスワードが &lt;code&gt;.pgpass&lt;/code&gt; ファイルなどの他のソースから入手できない場合、接続の試行は失敗します。このオプションは、パスワードを入力するユーザーがいないバッチジョブやスクリプトで役立ちます。</target>
        </trans-unit>
        <trans-unit id="d783af92d40765554d538ccb5cb29b09817e84f6" translate="yes" xml:space="preserve">
          <source>New OIDs cannot be assigned, though some UUID generators may still work as long as they do not rely on writing new status to the database.</source>
          <target state="translated">新しいOIDを割り当てることはできませんが、いくつかのUUID生成器は、データベースへの新しいステータスの書き込みに依存しない限り、まだ動作する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1599ff1bdbcb64919583d13e639c6bfaf051dfca" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">新しい集約関数は&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;コマンドで登録されます。集約関数の記述および遷移関数の意味などの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;セクション37.12&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5691f2234d0749ef354ef0f06ef7f16ccef71ffc" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">新しい集計関数は、&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATEAGGREGATE&lt;/a&gt;コマンドで登録されます。集計関数の記述や遷移関数の意味などの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;セクション37.12&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e31c4f5893b955e11ebf06d3912e5da97f70565f" translate="yes" xml:space="preserve">
          <source>New array values can also be constructed using the concatenation operator, &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">新しい配列値は、連結演算子 &lt;code&gt;||&lt;/code&gt; を使用して構築することもできます。：</target>
        </trans-unit>
        <trans-unit id="98e5f0d308c976c18e3e4b7efffa4995977e2612" translate="yes" xml:space="preserve">
          <source>New domain constraint for the domain.</source>
          <target state="translated">新しいドメインの制約</target>
        </trans-unit>
        <trans-unit id="796d9d5ad0384fcde7a5cdd2291232f588f72876" translate="yes" xml:space="preserve">
          <source>New leaf pages are added to a B-Tree index when an existing leaf page cannot fit an incoming tuple. A &lt;em&gt;page split&lt;/em&gt; operation makes room for items that originally belonged on the overflowing page by moving a portion of the items to a new page. Page splits must also insert a new &lt;em&gt;downlink&lt;/em&gt; to the new page in the parent page, which may cause the parent to split in turn. Page splits &amp;ldquo;cascade upwards&amp;rdquo; in a recursive fashion. When the root page finally cannot fit a new downlink, a &lt;em&gt;root page split&lt;/em&gt; operation takes place. This adds a new level to the tree structure by creating a new root page that is one level above the original root page.</source>
          <target state="translated">既存のリーフページが着信タプルに適合できない場合、新しいリーフページがBツリーインデックスに追加されます。&lt;em&gt;ページ分割&lt;/em&gt;操作は、もともと新しいページにアイテムの一部を移動することで溢れページに属していた項目のための部屋を作ります。ページ分割では、親ページの新しいページへの新しい&lt;em&gt;ダウンリンク&lt;/em&gt;も挿入する必要があります。これにより、親が順番に分割される可能性があります。ページは再帰的に「カスケード上向き」に分割されます。ルートページが最終的に新しいダウンリンクに適合できなくなると、&lt;em&gt;ルートページの分割&lt;/em&gt;操作が実行されます。これにより、元のルートページの1レベル上の新しいルートページが作成され、ツリー構造に新しいレベルが追加されます。</target>
        </trans-unit>
        <trans-unit id="a12c3795c3d4f4819f76dadf3e557565c057892c" translate="yes" xml:space="preserve">
          <source>New libc collations can be created like this:</source>
          <target state="translated">新しい libc の照合順序は、このように作成することができます。</target>
        </trans-unit>
        <trans-unit id="650ded8d5d402f503baa0bc831171b9d8bc4272d" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">また、新しいメジャーバージョンには通常、ユーザーに表示される非互換性があるため、アプリケーションプログラミングの変更が必要になる場合があります。ユーザーに表示されるすべての変更は、リリースノート（&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;付録E&lt;/a&gt;）に記載されています。「移行」というセクションに特に注意してください。複数のメジャーバージョン間でアップグレードする場合は、介在する各バージョンのリリースノートを必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="48e034a875ce9ccd77246027f6e0993adbe610b3" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/13/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">新しいメジャーバージョンでは、通常、ユーザーに表示される非互換性がいくつか導入されるため、アプリケーションプログラミングの変更が必要になる場合があります。ユーザーに表示されるすべての変更は、リリースノート（&lt;a href=&quot;https://www.postgresql.org/docs/13/release.html&quot;&gt;付録E&lt;/a&gt;）に記載されています。 「移行」というラベルの付いたセクションに特に注意してください。複数のメジャーバージョン間でアップグレードする場合は、介在する各バージョンのリリースノートを必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="a56ea799e1817e77cfb14f705f9837d87da3531d" translate="yes" xml:space="preserve">
          <source>New name for an existing column.</source>
          <target state="translated">既存のカラムの新しい名前。</target>
        </trans-unit>
        <trans-unit id="b258c013a0b2baff94eb0ca18fab582791cfc317" translate="yes" xml:space="preserve">
          <source>New name for the table.</source>
          <target state="translated">テーブルの新しい名前。</target>
        </trans-unit>
        <trans-unit id="e2584f9de9d6b68e373738ded405b0367bf25369" translate="yes" xml:space="preserve">
          <source>New probes can be defined within the code wherever the developer desires, though this will require a recompilation. Below are the steps for inserting new probes:</source>
          <target state="translated">新しいプローブは、開発者が希望するコード内で定義することができますが、これには再コンパイルが必要です。以下に、新しいプローブを挿入する手順を示します。</target>
        </trans-unit>
        <trans-unit id="9bb5261862459d4fc2f236436c680944b53b22bf" translate="yes" xml:space="preserve">
          <source>New row</source>
          <target state="translated">新しい行</target>
        </trans-unit>
        <trans-unit id="b1955e711ad4344c38fc8ef166f89eecc1ca6dce" translate="yes" xml:space="preserve">
          <source>New row &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">新しい行&lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45bbeac915cddbd627fa355d4df5b9dbbc9336c8" translate="yes" xml:space="preserve">
          <source>New rows are checked against the conditions of the view and all underlying base views. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is specified, and neither &lt;code&gt;LOCAL&lt;/code&gt; nor &lt;code&gt;CASCADED&lt;/code&gt; is specified, then &lt;code&gt;CASCADED&lt;/code&gt; is assumed.</source>
          <target state="translated">新しい行は、ビューとすべての基礎となるベースビューの条件に対してチェックされます。 &lt;code&gt;CHECK OPTION&lt;/code&gt; が指定されており、 &lt;code&gt;LOCAL&lt;/code&gt; も &lt;code&gt;CASCADED&lt;/code&gt; も指定されていない場合は、 &lt;code&gt;CASCADED&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="08a4db17fa684c55666b397d42c621a7aaca8bcb" translate="yes" xml:space="preserve">
          <source>New rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify the &lt;code&gt;CHECK OPTION&lt;/code&gt;).</source>
          <target state="translated">新しい行は、ビュー自体で直接定義された条件に対してのみチェックされます。基になるベースビューで定義された条件はチェックされません（条件が &lt;code&gt;CHECK OPTION&lt;/code&gt; も指定している場合を除く）。</target>
        </trans-unit>
        <trans-unit id="0fffd55cc966a5c918570729a73087e9799e7b21" translate="yes" xml:space="preserve">
          <source>New server version.</source>
          <target state="translated">サーバーのバージョンを変更しました。</target>
        </trans-unit>
        <trans-unit id="326bf78cdc5261237c497696e2f88d3bf937ac51" translate="yes" xml:space="preserve">
          <source>New table constraint for the foreign table.</source>
          <target state="translated">外部テーブルの新しいテーブル制約。</target>
        </trans-unit>
        <trans-unit id="c7fc18feb54e6ecc777a74b8dce9c763304724d3" translate="yes" xml:space="preserve">
          <source>New table constraint for the table.</source>
          <target state="translated">テーブルの新しいテーブル制約。</target>
        </trans-unit>
        <trans-unit id="0ef8f5b2618f8741358d2dc6f311e26c77d17c09" translate="yes" xml:space="preserve">
          <source>New value of parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify resetting the parameter to its default value (that is, whatever value it would have had if no &lt;code&gt;SET&lt;/code&gt; had been executed in the current session).</source>
          <target state="translated">パラメータの新しい値。値は、特定のパラメータに応じて、文字列定数、識別子、数値、またはこれらのカンマ区切りリストとして指定できます。パラメータをデフォルト値（つまり、現在のセッションで &lt;code&gt;SET&lt;/code&gt; が実行されていなかった場合の値）にリセットすることを指定するように、 &lt;code&gt;DEFAULT&lt;/code&gt; を書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="74ad18207dee0729707d6021134389a09abbbcf4" translate="yes" xml:space="preserve">
          <source>New value of the parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify removing the parameter and its value from &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">パラメータの新しい値。値は、特定のパラメータに応じて、文字列定数、識別子、数値、またはこれらのカンマ区切りリストとして指定できます。 &lt;code&gt;DEFAULT&lt;/code&gt; は、パラメーターとその値を &lt;code&gt;postgresql.auto.conf&lt;/code&gt; から削除することを指定するように記述できます。</target>
        </trans-unit>
        <trans-unit id="3f73bcda4d00edad798e144ba44c98c20a80aa1b" translate="yes" xml:space="preserve">
          <source>Newer operating systems may check for the known TSC problems and switch to a slower, more stable clock source when they are seen. If your system supports TSC time but doesn't default to that, it may be disabled for a good reason. And some operating systems may not detect all the possible problems correctly, or will allow using TSC even in situations where it's known to be inaccurate.</source>
          <target state="translated">新しいオペレーティングシステムは、既知のTSCの問題をチェックして、問題が見つかった場合には、より遅く、より安定したクロックソースに切り替えることができます。お使いのシステムが TSC 時刻をサポートしているにもかかわらず、それにデフォルトで対応していない場合は、それなりの理由で無効化されている可能性があります。また、一部のオペレーティングシステムでは、考えられるすべての問題を正しく検出しない場合や、不正確であることが知られている状況でもTSCの使用を許可してしまう場合があります。</target>
        </trans-unit>
        <trans-unit id="91613c0496c344d2d60b757f74e45fc5cc402ce3" translate="yes" xml:space="preserve">
          <source>Newline (ASCII 10)</source>
          <target state="translated">改行 (ASCII 10)</target>
        </trans-unit>
        <trans-unit id="abcfe34ad9620d6f4bc03407b5ef1c1c15fc3d23" translate="yes" xml:space="preserve">
          <source>Newlines are inserted between fields as needed to limit line length to 80 characters, if possible. A newline is also inserted between the metadata fields and the regular fields.</source>
          <target state="translated">改行は、行の長さを可能な限り80文字に制限するために、必要に応じてフィールド間に挿入されます。また、メタデータフィールドと通常のフィールドの間にも改行が挿入されます。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="668d132684646785e22fe1441b80ce3d2edabbcd" translate="yes" xml:space="preserve">
          <source>Next field is Julian Date</source>
          <target state="translated">次のフィールドは、ジュリアンの日付です。</target>
        </trans-unit>
        <trans-unit id="b894f41f03f11b1ed4f8f278b45d31b30d6d7e9d" translate="yes" xml:space="preserve">
          <source>Next field is time</source>
          <target state="translated">次のフィールドは時間</target>
        </trans-unit>
        <trans-unit id="8bbd06fda45074a003115cb92bcdeae70e3776f1" translate="yes" xml:space="preserve">
          <source>Next let's consider an example with an equality condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">次に、 &lt;code&gt;WHERE&lt;/code&gt; 句に等価条件を含む例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0accafa67ae47755f44a4c829c06920cf375701d" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993&amp;ndash;1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">次に、「&amp;lt;1000」が占めるヒストグラムの割合が計算されます。これが選択性です。ヒストグラムは範囲を等しい頻度のバケットに分割するため、値が含まれているバケットを見つけて、その&lt;em&gt;一部&lt;/em&gt;と以前の&lt;em&gt;すべて&lt;/em&gt;のバケットをカウントするだけです。値1000は明らかに2番目のバケット（993&amp;ndash;1997）にあります。各バケット内の値の線形分布を想定すると、選択性は次のように計算できます。</target>
        </trans-unit>
        <trans-unit id="5ed06150c503b0381101da4c9e29738d8aede6e0" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993-1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">次に、「&amp;lt;1000」が占めるヒストグラムの割合が算出されます。これが選択性です。ヒストグラムは範囲を等しい頻度のバケットに分割するため、必要なのは、値が含まれているバケットを見つけて、その&lt;em&gt;一部&lt;/em&gt;とそれ以前の&lt;em&gt;すべて&lt;/em&gt;のバケットを数えることだけです。値1000は、明らかに2番目のバケット（993-1997）にあります。各バケット内の値の線形分布を仮定すると、次のように選択性を計算できます。</target>
        </trans-unit>
        <trans-unit id="5e15fe544e0817c8abcd5bf63590f065c8fda5e8" translate="yes" xml:space="preserve">
          <source>Next we register the Ispell dictionary &lt;code&gt;english_ispell&lt;/code&gt;, which has its own configuration files:</source>
          <target state="translated">次に、独自の構成ファイルを持つIspell辞書 &lt;code&gt;english_ispell&lt;/code&gt; を登録します。</target>
        </trans-unit>
        <trans-unit id="5d2e580901bf6290e8151d5811cdef90838e8edb" translate="yes" xml:space="preserve">
          <source>Next, &lt;code&gt;pg_verifybackup&lt;/code&gt; will checksum all the files, compare the checksums against the values in the manifest, and emit errors for any files for which the computed checksum does not match the checksum stored in the manifest. This step is not performed for any files which produced errors in the previous step, since they are already known to have problems. Files which were ignored in the previous step are also ignored in this step.</source>
          <target state="translated">次に、 &lt;code&gt;pg_verifybackup&lt;/code&gt; はすべてのファイルをチェックサムし、チェックサムをマニフェストの値と比較し、計算されたチェックサムがマニフェストに格納されているチェックサムと一致しないファイルに対してエラーを発行します。この手順は、前の手順でエラーが発生したファイルには問題があることがすでにわかっているため、実行されません。前の手順で無視されたファイルも、この手順では無視されます。</target>
        </trans-unit>
        <trans-unit id="bdb6f7d3081e6797875cb41a13e6c45a3f761bbf" translate="yes" xml:space="preserve">
          <source>Next, create a trigram index on the word column:</source>
          <target state="translated">次に、単語欄にトリグラムインデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="d9e892095e44895492c517f24015243e155c5a35" translate="yes" xml:space="preserve">
          <source>Next, there might be a cache in the disk drive controller; this is particularly common on RAID controller cards. Some of these caches are &lt;em&gt;write-through&lt;/em&gt;, meaning writes are sent to the drive as soon as they arrive. Others are &lt;em&gt;write-back&lt;/em&gt;, meaning data is sent to the drive at some later time. Such caches can be a reliability hazard because the memory in the disk controller cache is volatile, and will lose its contents in a power failure. Better controller cards have &lt;em&gt;battery-backup units&lt;/em&gt; (BBUs), meaning the card has a battery that maintains power to the cache in case of system power loss. After power is restored the data will be written to the disk drives.</source>
          <target state="translated">次に、ディスクドライブコントローラーにキャッシュがある可能性があります。これは特にRAIDコントローラカードで一般的です。これらのキャッシュの一部は&lt;em&gt;ライトスルーです&lt;/em&gt;。つまり、書き込みは到着するとすぐにドライブに送信されます。その他は&lt;em&gt;ライトバックです&lt;/em&gt;。つまり、データは後でドライブに送信されます。このようなキャッシュは、ディスクコントローラーキャッシュ内のメモリが揮発性であり、電源障害が発生するとその内容を失うため、信頼性の問題となる可能性があります。より優れたコントローラカードには、&lt;em&gt;バッテリバックアップユニット&lt;/em&gt;（BBU）があります。つまり、カードには、システムの電力が失われた場合にキャッシュへの電力を維持するバッテリが搭載されています。電源が回復すると、データはディスクドライブに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="ab63ab43b9cd6b9423e3548d5b6495e55251533e" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">バックグラウンドワーカーの合計数が&lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processesを&lt;/a&gt;超えることはできないという制限のため、バックグラウンドワーカーは取得できません。</target>
        </trans-unit>
        <trans-unit id="1db509e223519bbbe9c20165e8b19fc16220b41f" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers launched for purposes of parallel query cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;.</source>
          <target state="translated">並列クエリの目的で起動されたバックグラウンドワーカーの合計数が&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workersを&lt;/a&gt;超えることはできないため、バックグラウンドワーカーは取得できません。</target>
        </trans-unit>
        <trans-unit id="737fbf99fcaacc1c750aa9911a89ba763b4fb6c2" translate="yes" xml:space="preserve">
          <source>No conflict resolution necessary</source>
          <target state="translated">紛争解決の必要なし</target>
        </trans-unit>
        <trans-unit id="c4ae42341e7948bd6be9068db7f6b708eab0516f" translate="yes" xml:space="preserve">
          <source>No direct modifications of buffers are allowed! All modifications must be done in copies acquired from &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt;. In other words, code that makes generic WAL records should never call &lt;code&gt;BufferGetPage()&lt;/code&gt; for itself. However, it remains the caller's responsibility to pin/unpin and lock/unlock the buffers at appropriate times. Exclusive lock must be held on each target buffer from before &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; until after &lt;code&gt;GenericXLogFinish()&lt;/code&gt;.</source>
          <target state="translated">バッファを直接変更することはできません！すべての変更は、 &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; から取得したコピーで行う必要があります。言い換えると、一般的なWALレコードを作成するコードは、 &lt;code&gt;BufferGetPage()&lt;/code&gt; を呼び出さないでください。ただし、適切なタイミングでバッファを固定/固定解除およびロック/ロック解除するのは呼び出し側の責任です。排他ロックが前から各ターゲットバッファに保持されなければならない &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 後まで &lt;code&gt;GenericXLogFinish()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59fe225d3b68631dd2336d2bf5588427b3b21997" translate="yes" xml:space="preserve">
          <source>No error concerning corruption raised by &lt;code&gt;amcheck&lt;/code&gt; should ever be a false positive. &lt;code&gt;amcheck&lt;/code&gt; raises errors in the event of conditions that, by definition, should never happen, and so careful analysis of &lt;code&gt;amcheck&lt;/code&gt; errors is often required.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; によって引き起こされた破損に関するエラーが誤検知であってはなりません。 &lt;code&gt;amcheck&lt;/code&gt; は、定義上、決して発生してはならない条件のイベントでエラーを発生させるため、 &lt;code&gt;amcheck&lt;/code&gt; エラーの慎重な分析が必要になることがよくあります。</target>
        </trans-unit>
        <trans-unit id="3b39fb69a71692aa8fa18d1717c1f94f66adfcdf" translate="yes" xml:space="preserve">
          <source>No master server overhead</source>
          <target state="translated">マスターサーバーのオーバーヘッドがない</target>
        </trans-unit>
        <trans-unit id="69d7c6fd29e6141d46559276ef0d0824b8ca6117" translate="yes" xml:space="preserve">
          <source>No more than 256 positions per lexeme</source>
          <target state="translated">1つの語彙につき、256以上のポジションはありません。</target>
        </trans-unit>
        <trans-unit id="d6105567c57e07dede5d4075af64116a14eb0b4d" translate="yes" xml:space="preserve">
          <source>No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs.</source>
          <target state="translated">この実装では、RE の長さに特に制限はありません。しかし、高度な移植性を意図したプログラムでは、POSIXに準拠した実装ではそのようなREの受け入れを拒否することができるため、256バイトより長いREを採用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="b403c7e51ec107180064180093a27a248cb9fcae" translate="yes" xml:space="preserve">
          <source>No special action is taken at the ends of transactions. This is the default behavior.</source>
          <target state="translated">トランザクションの終了時には特別な動作は行われません。これがデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="61fdd0ee1a0e012e017d3d0ae54de832b57200e8" translate="yes" xml:space="preserve">
          <source>No special hardware required</source>
          <target state="translated">特別なハードウェアは必要ありません</target>
        </trans-unit>
        <trans-unit id="ae79014d45aed5cbc3110d3674ce8fdfb2183d69" translate="yes" xml:space="preserve">
          <source>No support for encryption key as master key. As such practice is generally discouraged, this should not be a problem.</source>
          <target state="translated">暗号化キーをマスターキーとしてサポートしていません。このような慣習は一般的には推奨されていませんが、これは問題ではないはずです。</target>
        </trans-unit>
        <trans-unit id="8c30a7a5188f10c0ac8624ba81f5e723c5467bcf" translate="yes" xml:space="preserve">
          <source>No support for several subkeys. This may seem like a problem, as this is common practice. On the other hand, you should not use your regular GPG/PGP keys with &lt;code&gt;pgcrypto&lt;/code&gt;, but create new ones, as the usage scenario is rather different.</source>
          <target state="translated">複数のサブキーはサポートされていません。これは一般的な方法であるため、問題のように思えるかもしれません。一方、使用シナリオがかなり異なるため、通常のGPG / PGPキーを &lt;code&gt;pgcrypto&lt;/code&gt; で使用するのではなく、新しいキーを作成してください。</target>
        </trans-unit>
        <trans-unit id="c9435d4dd42a8ebc8de1b106f0a226340aa75454" translate="yes" xml:space="preserve">
          <source>No support for signing. That also means that it is not checked whether the encryption subkey belongs to the master key.</source>
          <target state="translated">署名には対応していません。これは、暗号化サブキーがマスターキーに属するかどうかをチェックしないということでもあります。</target>
        </trans-unit>
        <trans-unit id="c0ba19704438347e67d6c41db6384452ae2aa5a4" translate="yes" xml:space="preserve">
          <source>No waiting for multiple servers</source>
          <target state="translated">複数のサーバーを待つことなく</target>
        </trans-unit>
        <trans-unit id="4b6d8042bc7e3d0b0614251a34971ce673127f09" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;C&lt;/code&gt; and non-&lt;code&gt;POSIX&lt;/code&gt; locales rely on the operating system's collation library for character set ordering. This controls the ordering of keys stored in indexes. For this reason, a cluster cannot switch to an incompatible collation library version, either through snapshot restore, binary streaming replication, a different operating system, or an operating system upgrade.</source>
          <target state="translated">非 &lt;code&gt;C&lt;/code&gt; および非 &lt;code&gt;POSIX&lt;/code&gt; ロケールは、文字セットの順序付けについて、オペレーティングシステムの照合ライブラリに依存しています。これは、インデックスに格納されるキーの順序を制御します。このため、スナップショットリストア、バイナリストリーミングレプリケーション、別のオペレーティングシステム、またはオペレーティングシステムのアップグレードによって、クラスターは互換性のない照合ライブラリバージョンに切り替えることができません。</target>
        </trans-unit>
        <trans-unit id="b791053ba5b378d8e57979f3c97566be063ef0d0" translate="yes" xml:space="preserve">
          <source>Non-Deferred Uniqueness Constraints</source>
          <target state="translated">非遅延一意性制約</target>
        </trans-unit>
        <trans-unit id="2edd532d90e9a265b3d587446d10683f0ddb82ba" translate="yes" xml:space="preserve">
          <source>Non-Durable Settings</source>
          <target state="translated">耐久性のない設定</target>
        </trans-unit>
        <trans-unit id="1606d825faba4ca859c553032bca97393df353c3" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e. numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">絶対でないディレクトリ名は、参照する構成ファイルを含むディレクトリからの相対パスと見なされます。指定されたディレクトリ内には、名前の末尾が &lt;code&gt;.conf&lt;/code&gt; で終わる非ディレクトリファイルのみが含まれます。で始まるファイル名 &lt;code&gt;.&lt;/code&gt; このようなファイルは一部のプラットフォームでは非表示になっているため、間違いを防ぐために文字も無視されます。インクルードディレクトリ内の複数のファイルは、ファイル名の順序で処理されます（Cロケールの規則に従って、つまり、文字の前に数字、小文字の前に大文字）。</target>
        </trans-unit>
        <trans-unit id="375e6f9829aa08a22fb91bd89b1b288cc7a6547e" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e., numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">非絶対ディレクトリ名は、参照する構成ファイルを含むディレクトリを基準にしたものと見なされます。指定されたディレクトリ内には、名前がサフィックス &lt;code&gt;.conf&lt;/code&gt; で終わるディレクトリ以外のファイルのみが含まれます。で始まるファイル名 &lt;code&gt;.&lt;/code&gt; 一部のプラットフォームではそのようなファイルが非表示になっているため、間違いを防ぐために文字も無視されます。インクルードディレクトリ内の複数のファイルは、ファイル名の順序で処理されます（つまり、Cロケールの規則に従って、文字の前に数字、小文字の前に大文字があります）。</target>
        </trans-unit>
        <trans-unit id="b0daa9d12e18919b30fa114566dbfc8fde09c52f" translate="yes" xml:space="preserve">
          <source>Non-equality comparison</source>
          <target state="translated">非等価比較</target>
        </trans-unit>
        <trans-unit id="005bf64a001e88d6c5954633016b2d70a8916d20" translate="yes" xml:space="preserve">
          <source>Non-equality operator</source>
          <target state="translated">非等式演算子</target>
        </trans-unit>
        <trans-unit id="5d6b03babc67eb26f4a561798892e8e1d042f8b8" translate="yes" xml:space="preserve">
          <source>Non-equality operator (same as &lt;code&gt;!=&lt;/code&gt;)</source>
          <target state="translated">非等値演算子（ &lt;code&gt;!=&lt;/code&gt; と同じ）</target>
        </trans-unit>
        <trans-unit id="20c0da4f56e91a8e794e8ad5b40aa2db7a25e473" translate="yes" xml:space="preserve">
          <source>Non-schema objects such as blobs are not dumped when &lt;code&gt;-n&lt;/code&gt; is specified. You can add blobs back to the dump with the &lt;code&gt;--blobs&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; が指定されている場合、blobなどの非スキーマオブジェクトはダンプされません。 &lt;code&gt;--blobs&lt;/code&gt; スイッチを使用して、BLOBをダンプに戻すことができます。</target>
        </trans-unit>
        <trans-unit id="9caf6bd6e45fde8300143ee2bd8d45d380012859" translate="yes" xml:space="preserve">
          <source>Non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trim()&lt;/code&gt; の非標準構文</target>
        </trans-unit>
        <trans-unit id="1b82aac77684b2e34b968be8bab3328cdefd6c87" translate="yes" xml:space="preserve">
          <source>Non-superusers can only apply &lt;code&gt;LOAD&lt;/code&gt; to library files located in &lt;code&gt;$libdir/plugins/&lt;/code&gt; &amp;mdash; the specified &lt;code&gt;filename&lt;/code&gt; must begin with exactly that string. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.)</source>
          <target state="translated">スーパーユーザー以外は、 &lt;code&gt;LOAD&lt;/code&gt; を &lt;code&gt;$libdir/plugins/&lt;/code&gt; あるライブラリファイルにのみ適用できます&amp;mdash;指定された &lt;code&gt;filename&lt;/code&gt; は、その文字列で始まる必要があります。（「安全な」ライブラリのみがインストールされるようにするのは、データベース管理者の責任です。）</target>
        </trans-unit>
        <trans-unit id="33362508c287b322946b88bcd446c4aed0b4f943" translate="yes" xml:space="preserve">
          <source>Non-zero values of this setting add overhead, as PostgreSQL will need to store textual representations of parameter values in memory at the start of each statement, whether or not an error eventually occurs. The overhead is greater when bind parameters are sent in binary form than when they are sent as text, since the former case requires data conversion while the latter only requires copying the string.</source>
          <target state="translated">PostgreSQLは、各文の開始時にパラメータ値のテキスト表現をメモリに格納する必要があるため、この設定の0以外の値はオーバーヘッドを増加させます。バインドパラメータがバイナリ形式で送信される場合、テキスト形式で送信される場合よりもオーバーヘッドが大きくなります。</target>
        </trans-unit>
        <trans-unit id="cdcf35d8373c6ae03dbb38620bdfe970a151c4ed" translate="yes" xml:space="preserve">
          <source>Nondeterministic collations are only supported with the ICU provider.</source>
          <target state="translated">非決定論的照合は、ICUのプロバイダでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="592caa46c1febc51d4ba97d3f0cb331e0f251855" translate="yes" xml:space="preserve">
          <source>Nonrepeatable Read</source>
          <target state="translated">非繰り返し読み取り</target>
        </trans-unit>
        <trans-unit id="4cd9a0397eea6fedc043bb59b16fdf2f16c3bc14" translate="yes" xml:space="preserve">
          <source>Nonstandard Clauses</source>
          <target state="translated">標準外条項</target>
        </trans-unit>
        <trans-unit id="d10c40965cecc5427a7ccc11e532baca90682092" translate="yes" xml:space="preserve">
          <source>Nordic</source>
          <target state="translated">Nordic</target>
        </trans-unit>
        <trans-unit id="5d192ac91d079d3947c34df6ca0da6af270cb95a" translate="yes" xml:space="preserve">
          <source>Normal cursors return data in text format, the same as a &lt;code&gt;SELECT&lt;/code&gt; would produce. The &lt;code&gt;BINARY&lt;/code&gt; option specifies that the cursor should return data in binary format. This reduces conversion effort for both the server and client, at the cost of more programmer effort to deal with platform-dependent binary data formats. As an example, if a query returns a value of one from an integer column, you would get a string of &lt;code&gt;1&lt;/code&gt; with a default cursor, whereas with a binary cursor you would get a 4-byte field containing the internal representation of the value (in big-endian byte order).</source>
          <target state="translated">通常のカーソルは、 &lt;code&gt;SELECT&lt;/code&gt; が生成するのと同じように、テキスト形式でデータを返します。 &lt;code&gt;BINARY&lt;/code&gt; オプションの指定は、カーソルがバイナリ形式でデータを返す必要があること。これにより、プラットフォームに依存するバイナリデータ形式を処理するプログラマの労力を犠牲にして、サーバーとクライアントの両方の変換作業が削減されます。例として、クエリが整数列から値1を返す場合、デフォルトのカーソルでは &lt;code&gt;1&lt;/code&gt; の文字列が返されますが、バイナリカーソルでは、値の内部表現を含む4バイトのフィールドが返されます（ビッグエンディアンのバイト順）。</target>
        </trans-unit>
        <trans-unit id="e719f066c8f80c3d098dc0de105e52604edf52bd" translate="yes" xml:space="preserve">
          <source>Normally a copy of &lt;code&gt;pg_type.typstorage&lt;/code&gt; of this column's type. For TOAST-able data types, this can be altered after column creation to control storage policy.</source>
          <target state="translated">通常、この列のタイプの &lt;code&gt;pg_type.typstorage&lt;/code&gt; のコピー。TOAST対応のデータ型の場合、列の作成後にこれを変更して、ストレージポリシーを制御できます。</target>
        </trans-unit>
        <trans-unit id="dfefa02592536f045045c313a59b93cf3ea4a182" translate="yes" xml:space="preserve">
          <source>Normally it is better to start &lt;code&gt;postgres&lt;/code&gt; in the background. For this, use the usual Unix shell syntax:</source>
          <target state="translated">通常は、 &lt;code&gt;postgres&lt;/code&gt; をバックグラウンドで開始することをお勧めします。これには、通常のUnixシェル構文を使用します。</target>
        </trans-unit>
        <trans-unit id="eb15db27354b906033434be491a2ae185754105d" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">通常、テーブルを最初に定義したときに確立されたパーティションのセットは、静的なままであることを意図していません。データの古いパーティションを削除し、新しいデータのために定期的に新しいパーティションを追加したいと考えるのが一般的です。パーティショニングの最も重要な利点の一つは、物理的に大量のデータを移動させるのではなく、パーティション構造を操作することで、このような面倒な作業をほぼ瞬時に実行できることです。</target>
        </trans-unit>
        <trans-unit id="fe2f8f91b212090479c992426f90bbd96089fce0" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table is not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">通常、テーブルを最初に定義したときに確立されたパーティションのセットは、静的なままであることを意図していません。データの古いパーティションを削除し、新しいデータのために定期的に新しいパーティションを追加したいと考えるのが一般的です。パーティショニングの最も重要な利点の一つは、物理的に大量のデータを移動させるのではなく、パーティション構造を操作することで、このような面倒な作業をほぼ瞬時に実行できることです。</target>
        </trans-unit>
        <trans-unit id="85e1a3935578c6fbceb8f9dfc1ec7edf36d93788" translate="yes" xml:space="preserve">
          <source>Normally there is one entry, with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;, for each table column that has been analyzed. If the table has inheritance children, a second entry with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; is also created. This row represents the column's statistics over the inheritance tree, i.e., statistics for the data you'd see with &lt;code&gt;SELECT column FROM table*&lt;/code&gt;, whereas the &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; row represents the results of &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt;.</source>
          <target state="translated">通常、分析されたテーブルの列ごとに &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; のエントリが1つあります。テーブルに継承の子がある場合、 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; の 2番目のエントリも作成されます。この行は、継承ツリーに関する列の統計情報、つまり、 &lt;code&gt;SELECT column FROM table*&lt;/code&gt; で表示されるデータの統計情報を表し &lt;code&gt;false&lt;/code&gt; が、 &lt;code&gt;stainherit&lt;/code&gt; = false行は、 &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt; の結果を表します。</target>
        </trans-unit>
        <trans-unit id="ef0a797677cd4cd7010abb5ff69a6286820deaa9" translate="yes" xml:space="preserve">
          <source>Normally these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt; so that they apply to all server processes, but it is possible to turn them on or off in individual sessions using the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command. (To prevent ordinary users from hiding their activity from the administrator, only superusers are allowed to change these parameters with &lt;code&gt;SET&lt;/code&gt;.)</source>
          <target state="translated">通常、これらのパラメーターはすべてのサーバープロセスに適用されるように &lt;code&gt;postgresql.conf&lt;/code&gt; で設定されますが、&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;コマンドを使用して個々のセッションでオンまたはオフにすることができます。 （通常のユーザーが管理者からアクティビティを隠すことを防ぐために、これらのパラメーターを &lt;code&gt;SET&lt;/code&gt; で変更できるのはスーパーユーザーだけです。）</target>
        </trans-unit>
        <trans-unit id="defa435e9220700a95afbba17bf09c1d280dc0dd" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;EXPLAIN&lt;/code&gt; will display every plan node created by the planner. However, there are cases where the executor can determine that certain nodes need not be executed because they cannot produce any rows, based on parameter values that were not available at planning time. (Currently this can only happen for child nodes of an Append or MergeAppend node that is scanning a partitioned table.) When this happens, those plan nodes are omitted from the &lt;code&gt;EXPLAIN&lt;/code&gt; output and a &lt;code&gt;Subplans Removed: N&lt;/code&gt; annotation appears instead.</source>
          <target state="translated">通常、 &lt;code&gt;EXPLAIN&lt;/code&gt; は、プランナーによって作成されたすべてのプランノードを表示します。ただし、エグゼキュータは、計画時に使用できなかったパラメータ値に基づいて、行を生成できないために特定のノードを実行する必要がないと判断できる場合があります。 （現在、これは、パーティション表をスキャンしているAppendまたはMergeAppendノードの子ノードでのみ発生します。）これが発生すると、これらのプランノードは &lt;code&gt;EXPLAIN&lt;/code&gt; 出力から省略され、代わりに &lt;code&gt;Subplans Removed: N&lt;/code&gt; アノテーションが表示されます。</target>
        </trans-unit>
        <trans-unit id="059b752177da2be76f272de074908dfea33c9049" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;VACUUM&lt;/code&gt; will skip pages based on the &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;visibility map&lt;/a&gt;. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them. This option disables all page-skipping behavior, and is intended to be used only when the contents of the visibility map are suspect, which should happen only if there is a hardware or software issue causing database corruption.</source>
          <target state="translated">通常、 &lt;code&gt;VACUUM&lt;/code&gt; は&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;可視性マップに&lt;/a&gt;基づいてページをスキップします。すべてのタプルが凍結されていることがわかっているページは常にスキップできます。また、積極的なバキュームを実行する場合を除いて、すべてのタプルがすべてのトランザクションから見えることがわかっているページはスキップできます。さらに、積極的なバキュームを実行する場合を除いて、他のセッションがページの使用を完了するのを待たないように、一部のページがスキップされる場合があります。このオプションはすべてのページスキップ動作を無効にし、可視性マップのコンテンツが疑わしい場合にのみ使用することを目的としています。これは、データベースの破損を引き起こすハードウェアまたはソフトウェアの問題がある場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="5a28b92dedca807b45d1375cda7834475db13842" translate="yes" xml:space="preserve">
          <source>Normally, a database session will read a dictionary configuration file only once, when it is first used within the session. If you modify a configuration file and want to force existing sessions to pick up the new contents, issue an &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; command on the dictionary. This can be a &amp;ldquo;dummy&amp;rdquo; update that doesn't actually change any parameter values.</source>
          <target state="translated">通常、データベースセッションは、セッション内で最初に使用されるときに、辞書構成ファイルを1回だけ読み取ります。構成ファイルを変更し、既存のセッションで新しいコンテンツを強制的に &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; する場合は、ディクショナリでALTER TEXT SEARCH DICTIONARYコマンドを発行します。これは、実際にはパラメーター値を変更しない「ダミー」の更新である可能性があります。</target>
        </trans-unit>
        <trans-unit id="8bffa790046f833c87fae190fc13aecca45c4acb" translate="yes" xml:space="preserve">
          <source>Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If &lt;code&gt;MATCH FULL&lt;/code&gt; is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a &lt;code&gt;MATCH FULL&lt;/code&gt; constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">通常、その参照列のいずれかがnullの場合、参照行は外部キー制約を満たす必要はありません。場合 &lt;code&gt;MATCH FULL&lt;/code&gt; は、外部キー宣言に追加され、参照する行が（ヌルおよび非ヌル値の組み合わせが失敗することが保証されているように、すべての参照列がヌルである場合にのみ、制約を満たすエスケープ &lt;code&gt;MATCH FULL&lt;/code&gt; の制約）。参照する行が外部キー制約を満たさないようにしたくない場合は、参照する列を &lt;code&gt;NOT NULL&lt;/code&gt; として宣言します。</target>
        </trans-unit>
        <trans-unit id="a73d6e4c0676c9748a26df54015a17cf72960f1a" translate="yes" xml:space="preserve">
          <source>Normally, psql will dispatch a SQL command to the server as soon as it reaches the command-ending semicolon, even if more input remains on the current line. Thus for example entering</source>
          <target state="translated">通常、psqlは、たとえ現在の行にさらに多くの入力が残っていたとしても、コマンド終了のセミコロンに到達するとすぐにSQLコマンドをサーバに送信します。例えば、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="c995fea5a35dfbddf38f7ea21e264f8ae6030a27" translate="yes" xml:space="preserve">
          <source>Normally, recovery will proceed through all available WAL segments, thereby restoring the database to the current point in time (or as close as possible given the available WAL segments). Therefore, a normal recovery will end with a &amp;ldquo;file not found&amp;rdquo; message, the exact text of the error message depending upon your choice of &lt;code&gt;restore_command&lt;/code&gt;. You may also see an error message at the start of recovery for a file named something like &lt;code&gt;00000001.history&lt;/code&gt;. This is also normal and does not indicate a problem in simple recovery situations; see &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">通常、回復はすべての利用可能なWALセグメントを介して行われ、それによってデータベースが現在の時点（または利用可能なWALセグメントが与えられている限り可能な限り近く）に復元されます。したがって、通常のリカバリは「ファイルが見つかりません」というメッセージで終了します。エラーメッセージの正確なテキストは、選択した &lt;code&gt;restore_command&lt;/code&gt; によって異なります。 &lt;code&gt;00000001.history&lt;/code&gt; のような名前のファイルのリカバリの開始時にエラーメッセージが表示される場合もあります。これも正常であり、単純な回復状況での問題を示すものではありません。議論については&lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;項25.3.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="991460ee5abf98bebd31fd08e1871d36222f94b0" translate="yes" xml:space="preserve">
          <source>Normally, the database user who executes this command becomes the owner of the new database. However, a different owner can be specified via the &lt;code&gt;-O&lt;/code&gt; option, if the executing user has appropriate privileges.</source>
          <target state="translated">通常、このコマンドを実行するデータベースユーザーが新しいデータベースの所有者になります。ただし、実行ユーザーが適切な特権を持っている場合は、 &lt;code&gt;-O&lt;/code&gt; オプションを使用して別の所有者を指定できます。</target>
        </trans-unit>
        <trans-unit id="cce3fdca736676d73614d21a0ddda63501859fa9" translate="yes" xml:space="preserve">
          <source>Normally, the single-user mode server treats newline as the command entry terminator; there is no intelligence about semicolons, as there is in psql. To continue a command across multiple lines, you must type backslash just before each newline except the last one. The backslash and adjacent newline are both dropped from the input command. Note that this will happen even when within a string literal or comment.</source>
          <target state="translated">通常、シングルユーザモードのサーバは改行をコマンド入力の終端として扱います。複数の行にまたがってコマンドを続けるには、最後の行を除いて各改行の直前にバックスラッシュを入力しなければなりません。バックスラッシュと隣接する改行の両方が入力コマンドから削除されます。これは文字列リテラルやコメントの中にある場合でも発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ab9de63486b486ed7137fde8276d785f144a066" translate="yes" xml:space="preserve">
          <source>Normally, there is a single apply process running for an enabled subscription. A disabled subscription or a crashed subscription will have zero rows in this view. If the initial data synchronization of any table is in progress, there will be additional workers for the tables being synchronized.</source>
          <target state="translated">通常、有効なサブスクリプションに対しては、1 つの適用プロセスが実行されます。無効なサブスクリプションまたはクラッシュしたサブスクリプションは、このビューにゼロ行が表示されます。いずれかのテーブルの初期データ同期が進行中の場合、同期されているテーブルのための追加のワーカーが存在します。</target>
        </trans-unit>
        <trans-unit id="67e110cfa914197db96be5bd8ad2cb0e12d33a41" translate="yes" xml:space="preserve">
          <source>Normally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if the &lt;code&gt;NOT VALID&lt;/code&gt; option is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; option. See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more information about using the &lt;code&gt;NOT VALID&lt;/code&gt; option.</source>
          <target state="translated">通常、このフォームでは、テーブルをスキャンして、テーブル内のすべての既存の行が新しい制約を満たすことを確認します。ただし、 &lt;code&gt;NOT VALID&lt;/code&gt; オプションを使用すると、この潜在的に時間がかかるスキャンはスキップされます。制約は引き続き後続の挿入または更新に対して適用されます（つまり、外部キーの場合、参照されるテーブルに一致する行がない限り失敗します。または、新しい行が指定されたチェックと一致しない限り失敗します。状態）。ただし、データベースは、 &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; オプションを使用して検証されるまで、制約がテーブル内のすべての行に対して保持されるとは想定しません。 &lt;code&gt;NOT VALID&lt;/code&gt; オプションの使用について詳しくは、以下の&lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;注を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="01a8f59aaf55d8442cfcf99c35955b402850a73f" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">通常、コンピューターの起動時にデータベースサーバーを起動します。自動起動スクリプトはオペレーティングシステム固有です。 &lt;code&gt;contrib/start-scripts&lt;/code&gt; ディレクトリには、PostgreSQLとともにいくつかが配布されています。インストールするには、root権限が必要です。</target>
        </trans-unit>
        <trans-unit id="6c89afe408dffc3292c4743bcc6ff18a8191e1d0" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few example scripts distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">通常、コンピュータの起動時にデータベースサーバーを起動する必要があります。自動起動スクリプトはオペレーティングシステム固有です。 &lt;code&gt;contrib/start-scripts&lt;/code&gt; ディレクトリには、PostgreSQLとともに配布されているスクリプトの例がいくつかあります。インストールにはroot権限が必要です。</target>
        </trans-unit>
        <trans-unit id="99872ab32108649405bf8805c9de4baeb85fb7ad" translate="yes" xml:space="preserve">
          <source>North European</source>
          <target state="translated">北欧</target>
        </trans-unit>
        <trans-unit id="f79ff66cfb084d1746f64ba03a393ded056f91f0" translate="yes" xml:space="preserve">
          <source>Not all client APIs support all the listed character sets. For example, the PostgreSQL JDBC driver does not support &lt;code&gt;MULE_INTERNAL&lt;/code&gt;, &lt;code&gt;LATIN6&lt;/code&gt;, &lt;code&gt;LATIN8&lt;/code&gt;, and &lt;code&gt;LATIN10&lt;/code&gt;.</source>
          <target state="translated">すべてのクライアントAPIが、リストされているすべての文字セットをサポートしているわけではありません。たとえば、PostgreSQL JDBCドライバーは &lt;code&gt;MULE_INTERNAL&lt;/code&gt; 、 &lt;code&gt;LATIN6&lt;/code&gt; 、 &lt;code&gt;LATIN8&lt;/code&gt; 、および &lt;code&gt;LATIN10&lt;/code&gt; をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="9bacd7c0a9a33892b688e78e77b6ecea0ecffd5d" translate="yes" xml:space="preserve">
          <source>Not all of the requested files will be WAL segment files; you should also expect requests for files with a suffix of &lt;code&gt;.history&lt;/code&gt;. Also be aware that the base name of the &lt;code&gt;%p&lt;/code&gt; path will be different from &lt;code&gt;%f&lt;/code&gt;; do not expect them to be interchangeable.</source>
          <target state="translated">要求されたすべてのファイルがWALセグメントファイルになるわけではありません。また、拡張子が &lt;code&gt;.history&lt;/code&gt; のファイルのリクエストも想定されます。また、 &lt;code&gt;%p&lt;/code&gt; パスのベース名は &lt;code&gt;%f&lt;/code&gt; とは異なることに注意してください。それらが交換可能であるとは期待しないでください。</target>
        </trans-unit>
        <trans-unit id="91e930192ef14cc5c350419a549c884c45961c36" translate="yes" xml:space="preserve">
          <source>Not between (the negation of &lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt;).</source>
          <target state="translated">間ではありません（ &lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt; の否定）。</target>
        </trans-unit>
        <trans-unit id="d5510ea0072017c65967037de500e9abf1a00ab2" translate="yes" xml:space="preserve">
          <source>Not between, after sorting the two endpoint values.</source>
          <target state="translated">2つのエンドポイントの値をソートした後、間ではありません。</target>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">等しくない</target>
        </trans-unit>
        <trans-unit id="feb1931a7fb65e60520184c9226b83ff8b5335ec" translate="yes" xml:space="preserve">
          <source>Not equal, treating null as a comparable value.</source>
          <target state="translated">等しくない、ヌルを同等の値として扱う。</target>
        </trans-unit>
        <trans-unit id="6f925a3c210bc672e17b8d68ff775e287c505fff" translate="yes" xml:space="preserve">
          <source>Not every user has authorization to create new databases. If PostgreSQL refuses to create databases for you then the site administrator needs to grant you permission to create databases. Consult your site administrator if this occurs. If you installed PostgreSQL yourself then you should log in for the purposes of this tutorial under the user account that you started the server as. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">すべてのユーザーが新しいデータベースを作成する権限を持っているわけではありません。PostgreSQLがデータベースの作成を拒否した場合、サイト管理者がデータベースを作成する権限を付与する必要があります。これが発生した場合は、サイト管理者に相談してください。PostgreSQLを自分でインストールした場合は、このチュートリアルの目的のために、サーバーを起動したときのユーザーアカウントでログインする必要があります。&lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7dd5e10546306e9d83ef043283f9c8c8719bbf88" translate="yes" xml:space="preserve">
          <source>Not possible</source>
          <target state="translated">不可</target>
        </trans-unit>
        <trans-unit id="14141efdb351648cd5997a4ec11511c9b9025f02" translate="yes" xml:space="preserve">
          <source>Not the password (always reads as &lt;code&gt;********&lt;/code&gt;)</source>
          <target state="translated">パスワードではない（常に &lt;code&gt;********&lt;/code&gt; と読みます）</target>
        </trans-unit>
        <trans-unit id="5b3582a3ba934510ccb693b77b7924863143d181" translate="yes" xml:space="preserve">
          <source>Notable differences between the existing POSIX-based regular-expression feature and XQuery regular expressions include:</source>
          <target state="translated">既存の POSIX ベースの正規表現機能と XQuery の正規表現との顕著な違いは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="9b3331f6b2637140f06fa920c5a275390198583a" translate="yes" xml:space="preserve">
          <source>Note also that if one is relying on explicit locking to prevent concurrent changes, one should either use Read Committed mode, or in Repeatable Read mode be careful to obtain locks before performing queries. A lock obtained by a repeatable read transaction guarantees that no other transactions modifying the table are still running, but if the snapshot seen by the transaction predates obtaining the lock, it might predate some now-committed changes in the table. A repeatable read transaction's snapshot is actually frozen at the start of its first query or data-modification command (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;), so it is possible to obtain locks explicitly before the snapshot is frozen.</source>
          <target state="translated">同時変更を防ぐために明示的なロックに依存している場合は、読み取りコミットモードを使用するか、反復可能読み取りモードではクエリを実行する前にロックを取得するように注意してください。反復可能な読み取りトランザクションによって取得されたロックは、テーブルを変更する他のトランザクションがまだ実行されていないことを保証しますが、トランザクションによって表示されるスナップショットがロックの取得よりも前にある場合、現在コミットされているテーブルの変更の一部よりも前に実行される可能性があります。反復可能な読み取りトランザクションのスナップショットは、最初のクエリまたはデータ変更コマンド（ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; ）の開始時に実際に凍結されるため、スナップショットが凍結される前に明示的にロックを取得することが可能です。</target>
        </trans-unit>
        <trans-unit id="7593ffc9010adfe129fd98d3fee440d02e9a7b83" translate="yes" xml:space="preserve">
          <source>Note however that if multiple standby servers are restoring from the same archive directory, you will need to ensure that you do not delete WAL files until they are no longer needed by any of the servers. &lt;code&gt;archive_cleanup_command&lt;/code&gt; would typically be used in a warm-standby configuration (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command.</source>
          <target state="translated">ただし、複数のスタンバイサーバーが同じアーカイブディレクトリから復元する場合は、どのサーバーでも不要になるまでWALファイルを削除しないようにする必要があります。通常、 &lt;code&gt;archive_cleanup_command&lt;/code&gt; はウォームスタンバイ構成で使用されます（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2を&lt;/a&gt;参照）。書き込みは &lt;code&gt;%%&lt;/code&gt; に実際埋め込む &lt;code&gt;%&lt;/code&gt; のコマンドの文字を。</target>
        </trans-unit>
        <trans-unit id="a9a98603977441f8554a2833afe694dbcfe6aeee" translate="yes" xml:space="preserve">
          <source>Note however that simple names are matched to column names before table names, so this example works only because there is no column named &lt;code&gt;c&lt;/code&gt; in the query's tables.</source>
          <target state="translated">ただし、単純名はテーブル名の前に列名と一致するため、この例は、クエリのテーブルに &lt;code&gt;c&lt;/code&gt; という名前の列がないためにのみ機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="90893364f9fe7dce948b26423ee4ecd2e88b2f16" translate="yes" xml:space="preserve">
          <source>Note however that you &lt;em&gt;cannot&lt;/em&gt; accomplish that effect with a command limited to a single schema. This command has no effect, unless it is undoing a matching &lt;code&gt;GRANT&lt;/code&gt;:</source>
          <target state="translated">ただし、単一のスキーマに限定されたコマンドではその効果を達成&lt;em&gt;できない&lt;/em&gt;ことに注意してください。このコマンドは、一致する &lt;code&gt;GRANT&lt;/code&gt; を元に戻さない限り、効果がありません。</target>
        </trans-unit>
        <trans-unit id="0aef3a8d9770be0e69a039281f14778156239350" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;try all combinations&amp;rdquo; is not a realistic exercise. Usually password cracking is done with the help of dictionaries, which contain both regular words and various mutations of them. So, even somewhat word-like passwords could be cracked much faster than the above numbers suggest, while a 6-character non-word-like password may escape cracking. Or not.</source>
          <target state="translated">「すべての組み合わせを試す」は現実的な演習ではないことに注意してください。通常、パスワードの解読は、通常の単語とそれらのさまざまな変化の両方を含む辞書の助けを借りて行われます。したがって、多少単語のようなパスワードでも、上記の数値が示すよりもはるかに速くクラックされる可能性がありますが、6文字の非単語のようなパスワードはクラックを免れる可能性があります。か否か。</target>
        </trans-unit>
        <trans-unit id="00e6a4c57a18e5fbbf85ff612c2a3727ded13249" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;/etc/rc&lt;/code&gt; is usually overwritten by macOS system updates, so you should expect to have to redo these edits after each update.</source>
          <target state="translated">なお、 &lt;code&gt;/etc/rc&lt;/code&gt; あなたがそれぞれの更新後にこれらの編集をやり直す持つことを期待する必要がありますので、通常は、MacOSのシステムの更新によって上書きされます。</target>
        </trans-unit>
        <trans-unit id="27a1cfa3bf0ee9c52c7a87330ba166c5fa86db79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; are not in the SQL standard, but are a common extension. Some other databases make them return NULL if any argument is NULL, rather than only when all are NULL.</source>
          <target state="translated">ことを注意 &lt;code&gt;GREATEST&lt;/code&gt; と &lt;code&gt;LEAST&lt;/code&gt; は SQL標準ではありませんが、一般的な拡張機能です。他の一部のデータベースでは、すべてがNULLのときだけでなく、いずれかの引数がNULLの場合にNULLが返されます。</target>
        </trans-unit>
        <trans-unit id="d1e87e3a532a3c85a5fb7cefcf86b5bd58f7519a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;INSERT&lt;/code&gt; with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; checks &lt;code&gt;INSERT&lt;/code&gt; policies' &lt;code&gt;WITH CHECK&lt;/code&gt; expressions only for rows appended to the relation by the &lt;code&gt;INSERT&lt;/code&gt; path.</source>
          <target state="translated">なお、 &lt;code&gt;INSERT&lt;/code&gt; と &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; のチェック &lt;code&gt;INSERT&lt;/code&gt; のポリシー &lt;code&gt;WITH CHECK&lt;/code&gt; のみによって関係に追加の行の式 &lt;code&gt;INSERT&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="c319652e77f1cdd2df39e790f0f919f2b95a2486" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;amcheck&lt;/code&gt; examines a page as represented in some shared memory buffer at the time of verification if there is only a shared buffer hit when accessing the block. Consequently, &lt;code&gt;amcheck&lt;/code&gt; does not necessarily examine data read from the file system at the time of verification. Note that when checksums are enabled, &lt;code&gt;amcheck&lt;/code&gt; may raise an error due to a checksum failure when a corrupt block is read into a buffer.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; は、ブロックへのアクセス時に共有バッファーヒットのみがある場合、検証時に一部の共有メモリーバッファーに表されているページを検査することに注意してください。したがって、 &lt;code&gt;amcheck&lt;/code&gt; は、検証時にファイルシステムから読み込まれたデータを必ずしも検査するわけではありません。チェックサムが有効な場合、破損したブロックがバッファーに読み込まれると、 &lt;code&gt;amcheck&lt;/code&gt; はチェックサムエラーのためにエラーを発生させることがあります。</target>
        </trans-unit>
        <trans-unit id="ef24e95dba1150cbef958d74c2f80a5630d7740c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;extract&lt;/code&gt;'s day of the week numbering differs from that of the &lt;code&gt;to_char(..., 'D')&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; の曜日の番号付けは、 &lt;code&gt;to_char(..., 'D')&lt;/code&gt; 関数のものとは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="993b93174865d889f669c89fbc134d310b24fd79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt; consider only the rows within the &amp;ldquo;window frame&amp;rdquo;, which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for &lt;code&gt;last_value&lt;/code&gt; and sometimes also &lt;code&gt;nth_value&lt;/code&gt;. You can redefine the frame by adding a suitable frame specification (&lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt;) to the &lt;code&gt;OVER&lt;/code&gt; clause. See &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt; for more information about frame specifications.</source>
          <target state="translated">&lt;code&gt;first_value&lt;/code&gt; 、 &lt;code&gt;last_value&lt;/code&gt; 、および &lt;code&gt;nth_value&lt;/code&gt; は、「ウィンドウフレーム」内の行のみを考慮することに注意してください。これには、デフォルトで、パーティションの開始から現在の行の最後のピアまでの行が含まれます。これは、 &lt;code&gt;last_value&lt;/code&gt; とnth_valueの役に立たない結果をもたらす可能性があり &lt;code&gt;nth_value&lt;/code&gt; 。適切なフレーム仕様（ &lt;code&gt;RANGE&lt;/code&gt; 、 &lt;code&gt;ROWS&lt;/code&gt; または &lt;code&gt;GROUPS&lt;/code&gt; ）を &lt;code&gt;OVER&lt;/code&gt; 句に追加することにより、フレームを再定義できます。フレーム仕様の詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e089463c04f2f8771502e8d62b431f3c71d88b7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m&lt;/code&gt; columns can also be moved out to secondary storage, but only as a last resort (&lt;code&gt;e&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; columns are moved first).</source>
          <target state="translated">そのノート &lt;code&gt;m&lt;/code&gt; 個の列は、二次記憶装置へのムーブアウトすることができるが、最後の手段としてのみ（ &lt;code&gt;e&lt;/code&gt; および &lt;code&gt;x&lt;/code&gt; 列が最初に移動されます）。</target>
        </trans-unit>
        <trans-unit id="40331004e0ffed62ad250a770b0b797c5ac46ee7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_archive_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</source>
          <target state="translated">&lt;code&gt;max_standby_archive_delay&lt;/code&gt; は、キャンセル前にクエリを実行できる最大時間とは異なることに注意してください。むしろ、それは任意の1つのWALセグメントのデータを適用するために許可される最大合計時間です。したがって、1つのクエリの結果、WALセグメントの早い段階で大幅な遅延が発生した場合、後続の競合するクエリの猶予時間ははるかに短くなります。</target>
        </trans-unit>
        <trans-unit id="d4ea769871b3208ec9bdd68befff4d7903f7eff9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply WAL data once it has been received from the primary server. Thus, if one query has resulted in significant delay, subsequent conflicting queries will have much less grace time until the standby server has caught up again.</source>
          <target state="translated">&lt;code&gt;max_standby_streaming_delay&lt;/code&gt; は、キャンセル前にクエリを実行できる最大時間と同じではないことに注意してください。むしろ、プライマリサーバーから受信したWALデータを適用できる最大合計時間です。したがって、1つのクエリの結果として大幅な遅延が発生した場合、スタンバイサーバーが再び追いつくまで、後続の競合するクエリの猶予時間ははるかに短くなります。</target>
        </trans-unit>
        <trans-unit id="d6596a8da6c53c8c974c373f17703e4e032c6d9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;plainto_tsquery&lt;/code&gt; will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">&lt;code&gt;plainto_tsquery&lt;/code&gt; は、その入力の &lt;code&gt;tsquery&lt;/code&gt; 演算子、重みラベル、またはプレフィックス一致ラベルを認識しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="531e2b77490742cd189acb5bc5e4276f0143a9de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;postgres_fdw&lt;/code&gt; currently lacks support for &lt;code&gt;INSERT&lt;/code&gt; statements with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause. However, the &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; clause is supported, provided a unique index inference specification is omitted. Note also that &lt;code&gt;postgres_fdw&lt;/code&gt; supports row movement invoked by &lt;code&gt;UPDATE&lt;/code&gt; statements executed on partitioned tables, but it currently does not handle the case where a remote partition chosen to insert a moved row into is also an &lt;code&gt;UPDATE&lt;/code&gt; target partition that will be updated later.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; は現在、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句を含む &lt;code&gt;INSERT&lt;/code&gt; ステートメントのサポートを欠いていることに注意してください。ただし、一意のインデックス推論の指定が省略されている場合、 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 句がサポートされます。また、 &lt;code&gt;postgres_fdw&lt;/code&gt; は、パーティション分割されたテーブルで実行される &lt;code&gt;UPDATE&lt;/code&gt; ステートメントによって呼び出される行の移動をサポートしますが、現在、移動された行を挿入するために選択されたリモートパーティションが、後で更新される &lt;code&gt;UPDATE&lt;/code&gt; ターゲットパーティションである場合も処理しません。</target>
        </trans-unit>
        <trans-unit id="9d0c357cbd644595d94bcf660fedeb383e698ab1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;to_tsquery&lt;/code&gt; will process prefixes in the same way as other words, which means this comparison returns true:</source>
          <target state="translated">&lt;code&gt;to_tsquery&lt;/code&gt; は他の言葉と同じ方法で接頭辞を処理することに注意してください。つまり、この比較はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="547e51942705ea4910d562213bfd3cab3c67874d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wal_receiver_timeout&lt;/code&gt;, &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; and &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; configuration parameters affect the logical replication workers as well.</source>
          <target state="translated">&lt;code&gt;wal_receiver_timeout&lt;/code&gt; 、 &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; および &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; 構成パラメーターは、論理レプリケーションワーカーにも影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e5c3c7860afae265b42af4a1e6e8bf5af951d1e2" translate="yes" xml:space="preserve">
          <source>Note that GIN index build time can often be improved by increasing &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;, while GiST index build time is not sensitive to that parameter.</source>
          <target state="translated">多くの場合、GINインデックスの構築時間は&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;を増やすことで改善できますが、GiSTインデックスの構築時間はそのパラメーターの影響を受けません。</target>
        </trans-unit>
        <trans-unit id="4b8a5f57b365044d35823a4b451d18873918bc73" translate="yes" xml:space="preserve">
          <source>Note that XML forests are not valid XML documents if they consist of more than one element, so it might be useful to wrap &lt;code&gt;xmlforest&lt;/code&gt; expressions in &lt;code&gt;xmlelement&lt;/code&gt;.</source>
          <target state="translated">XMLフォレストが複数の要素で構成されている場合、XMLフォレストは有効なXMLドキュメントではないので、 &lt;code&gt;xmlforest&lt;/code&gt; 式を &lt;code&gt;xmlelement&lt;/code&gt; でラップすると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="41bc51ade685b6e9a9074785e60b9928bfbc83ce" translate="yes" xml:space="preserve">
          <source>Note that a file system backup will typically be larger than an SQL dump. (pg_dump does not need to dump the contents of indexes for example, just the commands to recreate them.) However, taking a file system backup might be faster.</source>
          <target state="translated">ファイルシステムのバックアップは通常SQLダンプよりも大きくなることに注意してください。(pg_dumpは例えばインデックスの内容をダンプする必要はありません。)しかし、ファイルシステムのバックアップを取った方が速いかもしれません。</target>
        </trans-unit>
        <trans-unit id="4c32d659dad68b2cd17eab976deb46f2e6ed59ea" translate="yes" xml:space="preserve">
          <source>Note that a foreign table can be declared with fewer columns, or with a different column order, than its underlying remote table has. Matching of columns to the remote table is by name, not position.</source>
          <target state="translated">外部テーブルは、その下にあるリモートテーブルが持つカラム数よりも少ないカラム数で宣言されたり、異なるカラム順で宣言されたりすることがあることに注意してください。リモートテーブルへのカラムのマッチングは、位置ではなく名前で行われます。</target>
        </trans-unit>
        <trans-unit id="c47a3a43d56fab6f7325c7aa20434bcba1bc9c0b" translate="yes" xml:space="preserve">
          <source>Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes (&lt;code&gt;'&lt;/code&gt;), as in the example. The &lt;code&gt;date&lt;/code&gt; type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here.</source>
          <target state="translated">すべてのデータ型がかなり明白な入力フォーマットを使用していることに注意してください。単純な数値ではない定数は、例のように、通常、単一引用符（ &lt;code&gt;'&lt;/code&gt; ）で囲む必要があります。 &lt;code&gt;date&lt;/code&gt; タイプで受け付けられるものは実際はかなり柔軟ですが、このチュートリアルのために、私たちはここに示す明確な形式に固執します。</target>
        </trans-unit>
        <trans-unit id="25d42cd6ceef922ecf25e7b24fce40695e12cb56" translate="yes" xml:space="preserve">
          <source>Note that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users specifying should be aware of the potential problems this might cause.</source>
          <target state="translated">データが正常にロードされると、他のすべてのセッションはすぐにデータを見ることができるようになります。これは MVCC の通常の可視性のルールに違反していますので、指定したユーザーはこれが引き起こす可能性のある問題に注意してください。</target>
        </trans-unit>
        <trans-unit id="df99d378fb51575b390c0b84d9d7987211c8c70b" translate="yes" xml:space="preserve">
          <source>Note that all the solutions described above take care of starting new log files at configurable intervals, but they do not handle deletion of old, no-longer-useful log files. You will probably want to set up a batch job to periodically delete old log files. Another possibility is to configure the rotation program so that old log files are overwritten cyclically.</source>
          <target state="translated">上記で説明したすべてのソリューションは、設定可能な間隔で新しいログファイルを起動するように注意していますが、古いログファイルの削除や不要になったログファイルの削除には対応していないことに注意してください。おそらく、古いログファイルを定期的に削除するためにバッチジョブを設定することになるでしょう。もう一つの可能性としては、古いログファイルが周期的に上書きされるようにローテーションプログラムを設定することです。</target>
        </trans-unit>
        <trans-unit id="2c87d02f3e8f6257698af02e373aea3121b7dc2e" translate="yes" xml:space="preserve">
          <source>Note that although WAL archiving will allow you to restore any modifications made to the data in your PostgreSQL database, it will not restore changes made to configuration files (that is, &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt; and &lt;code&gt;pg_ident.conf&lt;/code&gt;), since those are edited manually rather than through SQL operations. You might wish to keep the configuration files in a location that will be backed up by your regular file system backup procedures. See &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt; for how to relocate the configuration files.</source>
          <target state="translated">WALアーカイブでは、PostgreSQLデータベースのデータに加えられた変更を復元できますが、構成ファイル（つまり、 &lt;code&gt;postgresql.conf&lt;/code&gt; 、 &lt;code&gt;pg_hba.conf&lt;/code&gt; 、 &lt;code&gt;pg_ident.conf&lt;/code&gt; ）に加えられた変更は復元されないことに注意してください。SQL操作ではなく手動で編集します。通常のファイルシステムのバックアップ手順でバックアップされる場所に構成ファイルを保持したい場合があります。構成ファイルを再配置する方法については、&lt;a href=&quot;runtime-config-file-locations&quot;&gt;セクション19.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d53090021f825a89df9ea9e9d71eae604c7c4a95" translate="yes" xml:space="preserve">
          <source>Note that an &lt;code&gt;AS&lt;/code&gt; clause is required when &lt;code&gt;VALUES&lt;/code&gt; is used in a &lt;code&gt;FROM&lt;/code&gt; clause, just as is true for &lt;code&gt;SELECT&lt;/code&gt;. It is not required that the &lt;code&gt;AS&lt;/code&gt; clause specify names for all the columns, but it's good practice to do so. (The default column names for &lt;code&gt;VALUES&lt;/code&gt; are &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc in PostgreSQL, but these names might be different in other database systems.)</source>
          <target state="translated">注意 &lt;code&gt;AS&lt;/code&gt; のとき句が必要な &lt;code&gt;VALUES&lt;/code&gt; で使用されている &lt;code&gt;FROM&lt;/code&gt; 句に真であるのと同様に、 &lt;code&gt;SELECT&lt;/code&gt; 。 &lt;code&gt;AS&lt;/code&gt; 句ですべての列の名前を指定する必要はありませんが、そうすることをお勧めします。 （PostgreSQLの &lt;code&gt;VALUES&lt;/code&gt; のデフォルトの列名は &lt;code&gt;column1&lt;/code&gt; 、 &lt;code&gt;column2&lt;/code&gt; などですが、これらの名前は他のデータベースシステムでは異なる場合があります。）</target>
        </trans-unit>
        <trans-unit id="2b4af4e58c7c07f18643d7fac4e1368ce1d5e583" translate="yes" xml:space="preserve">
          <source>Note that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Thus, for example, revoking &lt;code&gt;SELECT&lt;/code&gt; privilege from &lt;code&gt;PUBLIC&lt;/code&gt; does not necessarily mean that all roles have lost &lt;code&gt;SELECT&lt;/code&gt; privilege on the object: those who have it granted directly or via another role will still have it. Similarly, revoking &lt;code&gt;SELECT&lt;/code&gt; from a user might not prevent that user from using &lt;code&gt;SELECT&lt;/code&gt; if &lt;code&gt;PUBLIC&lt;/code&gt; or another membership role still has &lt;code&gt;SELECT&lt;/code&gt; rights.</source>
          <target state="translated">特定のロールには、直接付与された特権、現在メンバーとなっているロールに付与された特権、および &lt;code&gt;PUBLIC&lt;/code&gt; に付与された特権の合計が含まれることに注意してください。したがって、たとえば、 &lt;code&gt;PUBLIC&lt;/code&gt; から &lt;code&gt;SELECT&lt;/code&gt; 権限を取り消しても、必ずしもすべてのロールがオブジェクトに対する &lt;code&gt;SELECT&lt;/code&gt; 権限を失ったことを意味するわけではありません。直接または別のロールを介して付与されたユーザーには引き続きその権限が与えられます。同様に、取り消し &lt;code&gt;SELECT&lt;/code&gt; を利用者からすると、使用してから、そのユーザーを防ぐいない可能性があります &lt;code&gt;SELECT&lt;/code&gt; を場合 &lt;code&gt;PUBLIC&lt;/code&gt; または別のメンバーシップの役割はまだ持っている &lt;code&gt;SELECT&lt;/code&gt; 権を。</target>
        </trans-unit>
        <trans-unit id="2fd76787f2a53ba7fb758f8a964cdd22772c1d78" translate="yes" xml:space="preserve">
          <source>Note that because &lt;code&gt;recovery.signal&lt;/code&gt; will not be removed when &lt;code&gt;recovery_target_action&lt;/code&gt; is set to &lt;code&gt;shutdown&lt;/code&gt;, any subsequent start will end with immediate shutdown unless the configuration is changed or the &lt;code&gt;recovery.signal&lt;/code&gt; file is removed manually.</source>
          <target state="translated">そのため音符 &lt;code&gt;recovery.signal&lt;/code&gt; のときに削除されない &lt;code&gt;recovery_target_action&lt;/code&gt; がに設定されている &lt;code&gt;shutdown&lt;/code&gt; 設定が変更されたりしない限り、任意の後続のスタートは即時停止して終了する &lt;code&gt;recovery.signal&lt;/code&gt; ファイルを手動で削除されます。</target>
        </trans-unit>
        <trans-unit id="9c33fcc287f27c5bc2a2b32d53b1b513b1091d88" translate="yes" xml:space="preserve">
          <source>Note that casting to just &amp;ldquo;bit&amp;rdquo; means casting to &lt;code&gt;bit(1)&lt;/code&gt;, and so will deliver only the least significant bit of the integer.</source>
          <target state="translated">「ビット」だけにキャストすると、 &lt;code&gt;bit(1)&lt;/code&gt; キャストすることになるため、整数の最下位ビットのみが配信されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fd0a0fb6f9e97d5efee795fd874b77207c725a32" translate="yes" xml:space="preserve">
          <source>Note that collecting the additional timing information needed for per-statement latency computation adds some overhead. This will slow average execution speed and lower the computed TPS. The amount of slowdown varies significantly depending on platform and hardware. Comparing average TPS values with and without latency reporting enabled is a good way to measure if the timing overhead is significant.</source>
          <target state="translated">ステートメントごとのレイテンシ計算に必要な追加のタイミング情報を収集すると、いくつかのオーバーヘッドが追加されることに注意してください。これにより、平均実行速度が遅くなり、計算されたTPSが低下します。低速化の程度は、プラットフォームとハードウェアによって大きく異なります。遅延レポートを有効にした場合としない場合の平均TPS値を比較することは、タイミングオーバーヘッドが大きいかどうかを測定する良い方法です。</target>
        </trans-unit>
        <trans-unit id="46048f7966588bd79b584545411fe217e62e0e87" translate="yes" xml:space="preserve">
          <source>Note that constraints other than &lt;code&gt;NOT NULL&lt;/code&gt; will never be imported from the remote tables. Although PostgreSQL does support &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, there is no provision for importing them automatically, because of the risk that a constraint expression could evaluate differently on the local and remote servers. Any such inconsistency in the behavior of a &lt;code&gt;CHECK&lt;/code&gt; constraint could lead to hard-to-detect errors in query optimization. So if you wish to import &lt;code&gt;CHECK&lt;/code&gt; constraints, you must do so manually, and you should verify the semantics of each one carefully. For more detail about the treatment of &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; 以外の制約がリモートテーブルからインポートされることはありません。 PostgreSQLは外部テーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約をサポートしていますが、制約式がローカルサーバーとリモートサーバーで異なる方法で評価されるリスクがあるため、それらを自動的にインポートするための規定はありません。 &lt;code&gt;CHECK&lt;/code&gt; 制約の動作にこのような不整合があると、クエリの最適化で検出が難しいエラーが発生する可能性があります。したがって、 &lt;code&gt;CHECK&lt;/code&gt; 制約をインポートする場合は、手動で行う必要があり、それぞれのセマンティクスを慎重に確認する必要があります。外部テーブルに対する &lt;code&gt;CHECK&lt;/code&gt; 制約の扱いの詳細については、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLEを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="699164176c152ba6b84d675ad75f5ace743cae19" translate="yes" xml:space="preserve">
          <source>Note that cost estimate functions must be written in C, not in SQL or any available procedural language, because they must access internal data structures of the planner/optimizer.</source>
          <target state="translated">コスト見積もり関数は、プランナー/オプティマイザーの内部データ構造にアクセスしなければならないため、SQLや利用可能な手続き言語ではなく、C言語で書かれなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="06d4a3361a37979804bf5a58a39eb486b3f91ba2" translate="yes" xml:space="preserve">
          <source>Note that deadlocks can also occur as the result of row-level locks (and thus, they can occur even if explicit locking is not used). Consider the case in which two concurrent transactions modify a table. The first transaction executes:</source>
          <target state="translated">デッドロックは行レベルのロックの結果としても発生する可能性があることに注意してください(したがって、明示的なロックが使用されていなくても発生する可能性があります)。2つのトランザクションが同時にテーブルを変更する場合を考えてみましょう。最初のトランザクションが実行されます。</target>
        </trans-unit>
        <trans-unit id="6082e5afeea05f3f2e208c50995f15f349743dca" translate="yes" xml:space="preserve">
          <source>Note that deduplication is deemed unsafe and cannot be used in the following cases involving semantically significant differences among equal datums:</source>
          <target state="translated">重複排除は安全ではないとみなされ、同じデータ間で意味的に有意な差がある以下のケースでは使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8001d46d3d20b93246bb06a2398e61902d0e24f2" translate="yes" xml:space="preserve">
          <source>Note that different keys may have the same ID. This is rare but a normal event. The client application should then try to decrypt with each one, to see which fits &amp;mdash; like handling &lt;code&gt;ANYKEY&lt;/code&gt;.</source>
          <target state="translated">異なるキーが同じIDを持つ場合があることに注意してください。これはまれですが、通常のイベントです。次に、クライアントアプリケーションは、 &lt;code&gt;ANYKEY&lt;/code&gt; の処理のように、それぞれで復号化を試みて、どちらが適合するかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="8d9652ff899a1fe6db38db0e7bf8d1018609b472" translate="yes" xml:space="preserve">
          <source>Note that different units are used for the per loop time than the histogram. The loop can have resolution within a few nanoseconds (ns), while the individual timing calls can only resolve down to one microsecond (us).</source>
          <target state="translated">ヒストグラムとは異なる単位がループごとの時間に使用されていることに注意してください。ループは数ナノ秒(ns)以内の分解能を持つことができますが、個々のタイミングコールは1マイクロ秒(us)までしか分解能を持つことができません。</target>
        </trans-unit>
        <trans-unit id="8463fb9b10613a7f093421dc720a6dd930e1df32" translate="yes" xml:space="preserve">
          <source>Note that enabling or disabling group access on an existing cluster requires the cluster to be shut down and the appropriate mode to be set on all directories and files before restarting PostgreSQL. Otherwise, a mix of modes might exist in the data directory. For clusters that allow access only by the owner, the appropriate modes are &lt;code&gt;0700&lt;/code&gt; for directories and &lt;code&gt;0600&lt;/code&gt; for files. For clusters that also allow reads by the group, the appropriate modes are &lt;code&gt;0750&lt;/code&gt; for directories and &lt;code&gt;0640&lt;/code&gt; for files.</source>
          <target state="translated">既存のクラスターでグループアクセスを有効または無効にするには、クラスターをシャットダウンし、PostgreSQLを再起動する前にすべてのディレクトリとファイルで適切なモードを設定する必要があることに注意してください。そうしないと、データディレクトリに複数のモードが混在する可能性があります。所有者のみがアクセスを許可するクラスターの場合、適切なモードは、ディレクトリの場合は &lt;code&gt;0700&lt;/code&gt; 、ファイルの場合は &lt;code&gt;0600&lt;/code&gt; です。グループによる読み取りも許可するクラスターの場合、適切なモードは、ディレクトリの場合は &lt;code&gt;0750&lt;/code&gt; 、ファイルの場合は &lt;code&gt;0640&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="836bf1d98935001a9e7ffe81c54955b795aef94c" translate="yes" xml:space="preserve">
          <source>Note that even when this parameter is disabled, the system will launch autovacuum processes if necessary to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more information.</source>
          <target state="translated">このパラメーターが無効になっている場合でも、トランザクションIDの折り返しを防ぐために、必要に応じてシステムが自動バキュームプロセスを起動することに注意してください。詳細は&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;項24.1.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7f1ea5bec1703e5249cd8348fa7e3e07222422cf" translate="yes" xml:space="preserve">
          <source>Note that exclusion constraints are not supported as arbiters with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;. In all cases, only &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; constraints and unique indexes are supported as arbiters.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; のアービターとして除外制約はサポートされていないことに注意してください。すべての場合において、 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; としてサポートされるのはNOT DEFERRABLE制約と一意のインデックスのみです。</target>
        </trans-unit>
        <trans-unit id="8de881cb4486af9a5996e8f814cf056ae7026e35" translate="yes" xml:space="preserve">
          <source>Note that for constraint triggers, evaluation of the &lt;code&gt;WHEN&lt;/code&gt; condition is not deferred, but occurs immediately after the row update operation is performed. If the condition does not evaluate to true then the trigger is not queued for deferred execution.</source>
          <target state="translated">制約トリガーの場合、 &lt;code&gt;WHEN&lt;/code&gt; 条件の評価は据え置かれませんが、行の更新操作が実行された直後に発生します。条件がtrueと評価されない場合、トリガーは遅延実行のキューに入れられません。</target>
        </trans-unit>
        <trans-unit id="0be6e3fd01fb4ed50e92212c3560099998e4c687" translate="yes" xml:space="preserve">
          <source>Note that for historic reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; to convert between the two, for example &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation.</source>
          <target state="translated">歴史的な理由により、関数 &lt;code&gt;md5&lt;/code&gt; は &lt;code&gt;text&lt;/code&gt; タイプの16進数でエンコードされた値を返しますが、SHA-2関数はタイプ &lt;code&gt;bytea&lt;/code&gt; を返します。関数 &lt;code&gt;encode&lt;/code&gt; と &lt;code&gt;decode&lt;/code&gt; を使用して2つの間で変換します。たとえば、 &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; を使用して、16進エンコードされたテキスト表現を取得します。</target>
        </trans-unit>
        <trans-unit id="cfe04c8846d33d71c984b2b6f7148e6d08053137" translate="yes" xml:space="preserve">
          <source>Note that foreign tables that use a foreign-data wrapper with no handler cannot be accessed.</source>
          <target state="translated">ハンドラのない外部データラッパーを使用する外部テーブルにはアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="02035a3862ae6605e031adf46021fcd89539c880" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server that the database server process can read; these functions bypass all in-database privilege checks. This means that, for example, a user with such access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is stored, as well as read any table data in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">&lt;code&gt;pg_read_file()&lt;/code&gt; または関連する関数に対するEXECUTE特権をユーザーに付与すると、データベースサーバープロセスが読み取ることができるサーバー上の任意のファイルを読み取ることができることに注意してください。これらの関数は、すべてのデータベース内特権チェックをバイパスします。これは、たとえば、そのようなアクセス権を持つユーザーが、認証情報が格納されている &lt;code&gt;pg_authid&lt;/code&gt; テーブルの内容を読み取ることができ、データベース内の任意のテーブルデータを読み取ることができることを意味します。したがって、これらの機能へのアクセスを許可することは慎重に検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="5453a69c6ad7e7ddfed4130bdc5747df6c5fd62b" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server which the database can read and that those reads bypass all in-database privilege checks. This means that, among other things, a user with this access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is contained, as well as read any file in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">&lt;code&gt;pg_read_file()&lt;/code&gt; または関連する関数に対するEXECUTE特権をユーザーに付与すると、データベースが読み取ることができるサーバー上の任意のファイルを読み取ることができ、それらの読み取りはすべてのデータベース内の特権チェックをバイパスすることに注意してください。これは、特に、このアクセス権を持つユーザーは、認証情報が含まれている &lt;code&gt;pg_authid&lt;/code&gt; テーブルの内容を読み取るだけでなく、データベース内の任意のファイルを読み取ることができることを意味します。したがって、これらの機能へのアクセスを許可することは慎重に検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="fd90b8fb5e3c2266322a8f9361a13beecb2d12fc" translate="yes" xml:space="preserve">
          <source>Note that here the &lt;code&gt;field&lt;/code&gt; parameter needs to be a string value, not a name. The valid field names for &lt;code&gt;date_part&lt;/code&gt; are the same as for &lt;code&gt;extract&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;field&lt;/code&gt; パラメータは名前ではなく文字列値である必要があることに注意してください。 &lt;code&gt;date_part&lt;/code&gt; の有効なフィールド名は、 &lt;code&gt;extract&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="13c19c7fbcb3e2d4787b53bfa2ce9ac2e3e6f680" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;MINVALUE&lt;/code&gt; or &lt;code&gt;MAXVALUE&lt;/code&gt; is used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; is not a valid bound; you should write &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt;.</source>
          <target state="translated">パーティション化境界の1つの列に &lt;code&gt;MINVALUE&lt;/code&gt; または &lt;code&gt;MAXVALUE&lt;/code&gt; を使用する場合は、後続のすべての列に同じ値を使用する必要があることに注意してください。たとえば、 &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; は有効な境界ではありません。 &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt; 書く必要があります。</target>
        </trans-unit>
        <trans-unit id="ba56c2e43467332103da0c13e1894f6a417084e8" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;code&gt;FROM&lt;/code&gt; clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:</source>
          <target state="translated">場合があります &lt;code&gt;FROM&lt;/code&gt; 句が指定されていない、クエリは任意のデータベーステーブルを参照することはできません。たとえば、次のクエリは無効です。</target>
        </trans-unit>
        <trans-unit id="90a3cd6b9233790897980d2c49eb8226596f6f8e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are specified, the &lt;code&gt;fields&lt;/code&gt; must include &lt;code&gt;SECOND&lt;/code&gt;, since the precision applies only to the seconds.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; と &lt;code&gt;p&lt;/code&gt; の両方を指定する場合、精度は秒にのみ適用されるため、 &lt;code&gt;fields&lt;/code&gt; は &lt;code&gt;SECOND&lt;/code&gt; を含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ee74a393ded0f5a9715105cabc63616fc14f639" translate="yes" xml:space="preserve">
          <source>Note that if extra WAL files which are not required to recover the backup are present, they will not be checked by this tool, although a separate invocation of &lt;code&gt;pg_waldump&lt;/code&gt; could be used for that purpose. Also note that WAL verification is version-specific: you must use the version of &lt;code&gt;pg_verifybackup&lt;/code&gt;, and thus of &lt;code&gt;pg_waldump&lt;/code&gt;, which pertains to the backup being checked. In contrast, the data file integrity checks should work with any version of the server that generates a &lt;code&gt;backup_manifest&lt;/code&gt; file.</source>
          <target state="translated">バックアップの回復に必要のない追加のWALファイルが存在する場合、 &lt;code&gt;pg_waldump&lt;/code&gt; の個別の呼び出しをその目的で使用できますが、これらはこのツールではチェックされないことに注意してください。また、WAL検証はバージョン固有であることに注意してください &lt;code&gt;pg_verifybackup&lt;/code&gt; のバージョンを使用する必要があります。したがって、チェック対象のバックアップに関連する &lt;code&gt;pg_waldump&lt;/code&gt; のバージョンを使用する必要があります。対照的に、データファイルの整合性チェックは、 &lt;code&gt;backup_manifest&lt;/code&gt; ファイルを生成するサーバーのすべてのバージョンで機能する必要があります。</target>
        </trans-unit>
        <trans-unit id="a560da48a0c3eebe2ee9e445e8f80b7a7c072449" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">左側の式がnullを生成する場合、または等しい右側の値がなく、少なくとも1つの右側の式がnullを生成する場合、 &lt;code&gt;IN&lt;/code&gt; 構文の結果はfalseではなくnullになることに注意してください。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="0c5f4c3fbdd65353e1a71d55f99ee8748d4b0fa1" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true as one might naively expect. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">左側の式がnullを生成する場合、または等しい右側の値がなく、少なくとも1つの右側の式がnullを生成する場合、 &lt;code&gt;NOT IN&lt;/code&gt; 構文の結果はnullになることに注意してください。 。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="3770b570045d24672e81b92be3b78c98e0908b47" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">左側の式がnullを生成する場合、または等しい右側の値がなく、少なくとも1つの右側の行がnullを生成する場合、 &lt;code&gt;IN&lt;/code&gt; 構文の結果はfalseではなくnullになることに注意してください。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="95d9a10f36eb36219f7c3566abef0868c3a7a8f8" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">左側の式がnullを生成する場合、または等しい右側の値がなく、少なくとも1つの右側の行がnullを生成する場合、 &lt;code&gt;NOT IN&lt;/code&gt; 構文の結果はnullであり、真ではないことに注意してください。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="b5695d0e24822e1a46463dd2f7c72886d58ca728" translate="yes" xml:space="preserve">
          <source>Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the &lt;code&gt;ANY&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">成功がなく、少なくとも1つの右側の行で演算子の結果がnullになる場合、 &lt;code&gt;ANY&lt;/code&gt; 構文の結果はfalseではなくnullになることに注意してください。これは、NULL値のブール値の組み合わせに関するSQLの通常の規則に従っています。</target>
        </trans-unit>
        <trans-unit id="f74d4f9409b75f18ec02eb7363768188eed257dd" translate="yes" xml:space="preserve">
          <source>Note that if you use this option currently, you probably also want the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as the &lt;code&gt;COPY FROM&lt;/code&gt; during restore does not support row security.</source>
          <target state="translated">現在このオプションを使用している場合、リストア中の &lt;code&gt;COPY FROM&lt;/code&gt; は行セキュリティをサポートしていないため、おそらくダンプも &lt;code&gt;INSERT&lt;/code&gt; 形式にする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76b5be5ae69de8a00f81a37774ba0bddbcd592c1" translate="yes" xml:space="preserve">
          <source>Note that in a standard-conforming string literal, &lt;code&gt;\&lt;/code&gt; just means &lt;code&gt;\&lt;/code&gt; anyway. This parameter only affects the handling of non-standard-conforming literals, including escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;).</source>
          <target state="translated">なお、標準準拠の文字列リテラルでは、 &lt;code&gt;\&lt;/code&gt; ちょうど手段 &lt;code&gt;\&lt;/code&gt; とにかく。このパラメーターは、エスケープ文字列構文（ &lt;code&gt;E'...'&lt;/code&gt; ）を含む、標準に準拠していないリテラルの処理にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="23bc72830133f60c02bed8bfbe946fd178dc8663" translate="yes" xml:space="preserve">
          <source>Note that in some macOS versions, &lt;em&gt;all five&lt;/em&gt; shared-memory parameters must be set in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, else the values will be ignored.</source>
          <target state="translated">一部のmacOSバージョンでは、&lt;em&gt;5つすべての&lt;/em&gt;共有メモリパラメータを &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; に設定する必要があります。それ以外の場合、値は無視されます。</target>
        </trans-unit>
        <trans-unit id="7d63d2dbef5cb198e7018e15f160e61a7a98bae4" translate="yes" xml:space="preserve">
          <source>Note that in the latter case the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit &lt;code&gt;COLLATE&lt;/code&gt; clause will override the collations of all other arguments. (Attaching non-matching &lt;code&gt;COLLATE&lt;/code&gt; clauses to more than one argument, however, is an error. For more details see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.) Thus, this gives the same result as the previous example:</source>
          <target state="translated">後者の場合、 &lt;code&gt;COLLATE&lt;/code&gt; 句は、影響を与えたい演算子の入力引数に付加されることに注意してください。演算子または関数によって適用される照合はすべての引数を考慮して導出され、明示的な &lt;code&gt;COLLATE&lt;/code&gt; 句は他のすべての照合をオーバーライドするため、演算子または関数呼び出しのどの引数が &lt;code&gt;COLLATE&lt;/code&gt; 句に関連付けられているかは関係ありません。引数。 （ただし、一致し &lt;code&gt;COLLATE&lt;/code&gt; 句を複数の引数にアタッチするとエラーになります。詳細については、&lt;a href=&quot;collation&quot;&gt;セクション23.2を&lt;/a&gt;参照してください。）したがって、これは前の例と同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="a84d7bddb80d9016bd6c4bee8fb7ca51415943a4" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">このモードでは、サーバーは一度に1ファイルずつWALを適用するため、クエリにスタンバイサーバーを使用する場合（ホットスタンバイを参照）、マスターのアクションとアクションがWALファイルがいっぱいになるまでの時間に対応するスタンバイ。 &lt;code&gt;archive_timeout&lt;/code&gt; を使用して、その遅延を短くすることができます。また、ストリーミングレプリケーションをこの方法と組み合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="8a1638c843cb47802240a66e163419411cf8f8a8" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding to the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">このモードでは、サーバーは一度に1つのファイルをWALに適用するため、クエリにスタンバイサーバーを使用する場合（ホットスタンバイを参照）、マスターでのアクションとアクションがで表示されるまでに遅延が発生することに注意してください。スタンバイ。WALファイルを埋めるのにかかる時間に対応します。 &lt;code&gt;archive_timeout&lt;/code&gt; を使用して、その遅延を短くすることができます。また、ストリーミングレプリケーションをこの方法と組み合わせることはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d4405d800f3ae0d5fa272786ae62fc932fc40328" translate="yes" xml:space="preserve">
          <source>Note that in this syntax, &lt;code&gt;BINARY&lt;/code&gt; and &lt;code&gt;CSV&lt;/code&gt; are treated as independent keywords, not as arguments of a &lt;code&gt;FORMAT&lt;/code&gt; option.</source>
          <target state="translated">この構文では、 &lt;code&gt;BINARY&lt;/code&gt; と &lt;code&gt;CSV&lt;/code&gt; は、 &lt;code&gt;FORMAT&lt;/code&gt; オプションの引数としてではなく、独立したキーワードとして扱われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a52e8eceb78cffa4749cb6c0e0ac81c842683dee" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported by &lt;code&gt;postgres_fdw&lt;/code&gt; to prepare the remote transaction for two-phase commit.</source>
          <target state="translated">現在、2フェーズコミット用のリモートトランザクションを準備することは、 &lt;code&gt;postgres_fdw&lt;/code&gt; ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5bf276b552e113c8aa30767266df52ef9cf60275" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported for the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause of an &lt;code&gt;INSERT&lt;/code&gt; applied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.</source>
          <target state="translated">現在、パーティション化されたテーブルに適用される &lt;code&gt;INSERT&lt;/code&gt; の &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 句では、競合する行のパーティションキーを更新して、行を新しいパーティションに移動する必要があるため、サポートされていません。</target>
        </trans-unit>
        <trans-unit id="1def70c0867779a85dc5cf9834ec9df5745ab872" translate="yes" xml:space="preserve">
          <source>Note that it is entirely up to the access method to ensure that it correctly finds all and only the entries passing all the given scan keys. Also, the core system will simply hand off all the &lt;code&gt;WHERE&lt;/code&gt; clauses that match the index keys and operator families, without any semantic analysis to determine whether they are redundant or contradictory. As an example, given &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a b-tree indexed column, it is left to the b-tree &lt;code&gt;amrescan&lt;/code&gt; function to realize that the first scan key is redundant and can be discarded. The extent of preprocessing needed during &lt;code&gt;amrescan&lt;/code&gt; will depend on the extent to which the index access method needs to reduce the scan keys to a &amp;ldquo;normalized&amp;rdquo; form.</source>
          <target state="translated">与えられたすべてのスキャンキーを渡すすべてのエントリのみを正しく検出することを保証するのは、アクセス方法次第であることに注意してください。また、コアシステムは、インデックスキーと演算子族に一致するすべての &lt;code&gt;WHERE&lt;/code&gt; 句を渡すだけで、冗長であるか矛盾しているかを判断するセマンティック分析を行いません。例として、 &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; はbツリーのインデックス付き列）の場合、最初のスキャンキーは冗長であり、破棄できることをb-tree &lt;code&gt;amrescan&lt;/code&gt; 関数に任せます。 &lt;code&gt;amrescan&lt;/code&gt; 中に必要な前処理の程度は、インデックスアクセスメソッドがスキャンキーを「正規化された」形式に削減する必要がある程度によって異なります。</target>
        </trans-unit>
        <trans-unit id="873ebf4f2aa65167f1962a321c4caa0aa6923fed" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for an access method to implement only &lt;code&gt;amgetbitmap&lt;/code&gt; and not &lt;code&gt;amgettuple&lt;/code&gt;, or vice versa, if its internal implementation is unsuited to one API or the other.</source>
          <target state="translated">内部の実装がいずれかのAPIに適さない場合、アクセスメソッドが &lt;code&gt;amgetbitmap&lt;/code&gt; のみを実装して &lt;code&gt;amgettuple&lt;/code&gt; を実装しないこと、またはその逆が許可されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0eac953a1d1c9a171b24393d7da1daab96fde8aa" translate="yes" xml:space="preserve">
          <source>Note that it is possible that pre-existing options of the foreign-data wrapper, or of dependent servers, user mappings, or foreign tables, are invalid according to the new validator. PostgreSQL does not check for this. It is up to the user to make sure that these options are correct before using the modified foreign-data wrapper. However, any options specified in this &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; command will be checked using the new validator.</source>
          <target state="translated">新しいバリデーターによると、foreign-data wrapper、または従属サーバー、ユーザーマッピング、または外部テーブルの既存のオプションが無効である可能性があることに注意してください。PostgreSQLはこれをチェックしません。変更された外部データラッパーを使用する前に、これらのオプションが正しいことを確認するのはユーザーの責任です。ただし、この &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; コマンドで指定されたオプションは、新しいバリデーターを使用してチェックされます。</target>
        </trans-unit>
        <trans-unit id="54f1f1ea0bfe92e9a92461b1d9eddd8c8bc5388c" translate="yes" xml:space="preserve">
          <source>Note that it is possible to create array values containing null values even when this variable is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">この変数が &lt;code&gt;off&lt;/code&gt; 場合でも、null値を含む配列値を作成できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e482ec43ca141e91073df95564c36e7944046093" translate="yes" xml:space="preserve">
          <source>Note that it would not make much sense to test a non-schema-qualified type name in this way &amp;mdash; if the name can be recognized at all, it must be visible.</source>
          <target state="translated">この方法でスキーマ修飾されていない型名をテストすることはあまり意味がないことに注意してください。名前がまったく認識できる場合は、可視でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1aef4a22f764ee40b1bcb8140980923ce0f949fc" translate="yes" xml:space="preserve">
          <source>Note that it's quite possible for two objects to be linked by more than one &lt;code&gt;pg_depend&lt;/code&gt; entry. For example, a child partitioned index would have both a partition-type dependency on its associated partition table, and an auto dependency on each column of that table that it indexes. This sort of situation expresses the union of multiple dependency semantics. A dependent object can be dropped without &lt;code&gt;CASCADE&lt;/code&gt; if any of its dependencies satisfies its condition for automatic dropping. Conversely, all the dependencies' restrictions about which objects must be dropped together must be satisfied.</source>
          <target state="translated">2つのオブジェクトが複数の &lt;code&gt;pg_depend&lt;/code&gt; エントリによってリンクされる可能性があることに注意してください。たとえば、子パーティションインデックスには、関連付けられているパーティションテーブルに対するパーティションタイプの依存関係と、インデックスが作成されるテーブルの各列に対する自動依存関係の両方があります。このような状況は、複数の依存関係のセマンティクスの結合を表しています。依存関係のいずれかが自動削除の条件を満たす場合、依存オブジェクトは &lt;code&gt;CASCADE&lt;/code&gt; なしで削除できます。逆に、どのオブジェクトを一緒にドロップする必要があるかについてのすべての依存関係の制限を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="7a633bec827cd5945acb13add9ef3e8ab355704d" translate="yes" xml:space="preserve">
          <source>Note that late binding was the only behavior supported in PostgreSQL releases before 8.1, so you might need to do this to preserve the semantics of old applications.</source>
          <target state="translated">8.1以前のPostgreSQLリリースでは、遅いバインディングが唯一の動作としてサポートされていましたので、古いアプリケーションのセマンティクスを保持するためにこれを行う必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f498abb4a796a1a75315ef84efac83b6642a42d1" translate="yes" xml:space="preserve">
          <source>Note that libpq uses the SAM-compatible name if no explicit user name is specified. If you use libpq or a driver based on it, you should leave this option disabled or explicitly specify user name in the connection string.</source>
          <target state="translated">明示的なユーザ名が指定されていない場合、libpqはSAM互換の名前を使用することに注意してください。libpqやそれをベースにしたドライバを使用している場合は、このオプションを無効にしておくか、接続文字列に明示的にユーザ名を指定してください。</target>
        </trans-unit>
        <trans-unit id="743714bf2d851c6ffde333b305cc76acb3b1f4e3" translate="yes" xml:space="preserve">
          <source>Note that loading a large number of rows using &lt;code&gt;COPY&lt;/code&gt; is almost always faster than using &lt;code&gt;INSERT&lt;/code&gt;, even if &lt;code&gt;PREPARE&lt;/code&gt; is used and multiple insertions are batched into a single transaction.</source>
          <target state="translated">&lt;code&gt;PREPARE&lt;/code&gt; が使用され、複数の挿入が単一のトランザクションにバッチ処理される場合でも、 &lt;code&gt;COPY&lt;/code&gt; を使用して多数の行をロードする方が、ほとんど常に &lt;code&gt;INSERT&lt;/code&gt; を使用するよりも高速であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="42e8e431b9942cab90fba21d1a0369e9ad613d53" translate="yes" xml:space="preserve">
          <source>Note that locale names are specific to the operating system, so that the above commands might not work in the same way everywhere.</source>
          <target state="translated">ロケール名はオペレーティングシステムに依存しているので、上記のコマンドはどこでも同じようには動作しない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a9b85d99902345f4af7308b01a61dc7702db748b" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">すべてのSQLコマンドが継承階層で機能できるわけではないことに注意してください。データのクエリ、データの変更、またはスキーマの変更に使用されるコマンド（たとえば、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;ALTER TABLE&lt;/code&gt; のほとんどのバリアントですが、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; ）は通常、デフォルトで子テーブルを含み、 &lt;code&gt;ONLY&lt;/code&gt; のみをサポートしますそれらを除外する表記。データベースのメンテナンスとチューニングを行うコマンド（例： &lt;code&gt;REINDEX&lt;/code&gt; 、 &lt;code&gt;VACUUM&lt;/code&gt; )）通常、個々の物理テーブルでのみ機能し、継承階層の再帰はサポートしていません。個々のコマンドのそれぞれの動作は、そのリファレンスページ（&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQLコマンド&lt;/a&gt;）に記載されています。</target>
        </trans-unit>
        <trans-unit id="327ef47ac3644ee0b774c6ef4fdf9e2c60c4fad3" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/13/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">すべてのSQLコマンドが継承階層で機能できるわけではないことに注意してください。データクエリ、データ変更、またはスキーマ変更に使用されるコマンド（ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;ALTER TABLE&lt;/code&gt; のほとんどのバリアント、ただし &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; は除く）は通常、デフォルトで子テーブルを含み、 &lt;code&gt;ONLY&lt;/code&gt; をサポートします。それらを除外する表記。データベースの保守と調整を行うコマンド（例： &lt;code&gt;REINDEX&lt;/code&gt; 、 &lt;code&gt;VACUUM&lt;/code&gt; ）通常、個々の物理テーブルでのみ機能し、継承階層の繰り返しはサポートしません。個々のコマンドのそれぞれの動作は、そのリファレンスページ（&lt;a href=&quot;https://www.postgresql.org/docs/13/sql-commands.html&quot;&gt;SQLコマンド&lt;/a&gt;）に記載されています。</target>
        </trans-unit>
        <trans-unit id="5a5e9d67d623aca716181f6ec9cb80abc27268bb" translate="yes" xml:space="preserve">
          <source>Note that object keys are compared in their storage order; in particular, since shorter keys are stored before longer keys, this can lead to results that might be unintuitive, such as:</source>
          <target state="translated">オブジェクトのキーは保存順に比較されることに注意してください。特に、短いキーは長いキーよりも前に保存されるため、以下のような直感的でない結果になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c0b32073b6d3e410922a70ee12709380a01c6753" translate="yes" xml:space="preserve">
          <source>Note that older clients might lack support for the SCRAM authentication mechanism, and hence not work with passwords encrypted with SCRAM-SHA-256. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for more details.</source>
          <target state="translated">古いクライアントはSCRAM認証メカニズムをサポートしていない可能性があるため、SCRAM-SHA-256で暗号化されたパスワードでは機能しないことに注意してください。詳細は&lt;a href=&quot;auth-password&quot;&gt;項20.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a9b3d09d3d6340576d5c998f6421491652b39ecd" translate="yes" xml:space="preserve">
          <source>Note that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.</source>
          <target state="translated">更新トランザクションのみを再試行する必要があるかもしれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2954af76eca7ba35f68a0a8d801d4249462c8089" translate="yes" xml:space="preserve">
          <source>Note that ordering options apply only to the expression they follow; for example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; does not mean the same thing as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">順序付けオプションは、それらが続く式にのみ適用されることに注意してください。たとえば、 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; は、 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; と同じ意味ではありません。</target>
        </trans-unit>
        <trans-unit id="b1c2c8127025345a934a6314a2f889673aacbd3b" translate="yes" xml:space="preserve">
          <source>Note that parallel queries may consume very substantially more resources than non-parallel queries, because each worker process is a completely separate process which has roughly the same impact on the system as an additional user session. This should be taken into account when choosing a value for this setting, as well as when configuring other settings that control resource utilization, such as &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;. Resource limits such as &lt;code&gt;work_mem&lt;/code&gt; are applied individually to each worker, which means the total utilization may be much higher across all processes than it would normally be for any single process. For example, a parallel query using 4 workers may use up to 5 times as much CPU time, memory, I/O bandwidth, and so forth as a query which uses no workers at all.</source>
          <target state="translated">各ワーカープロセスは完全に独立したプロセスであり、システムに追加のユーザーセッションとほぼ同じ影響を与えるため、並列クエリは非並列クエリよりもかなり多くのリソースを消費する可能性があることに注意してください。この設定の値を選択するとき、および&lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;などのリソース使用率を制御する他の設定を構成するときは、これを考慮する必要があります。 &lt;code&gt;work_mem&lt;/code&gt; などのリソース制限は各ワーカーに個別に適用されます。つまり、すべてのプロセスでの合計使用率は、通常の単一プロセスの場合よりもはるかに高くなる可能性があります。たとえば、4つのワーカーを使用する並列クエリは、ワーカーをまったく使用しないクエリとして、最大5倍のCPU時間、メモリ、I / O帯域幅などを使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="03d17cb56c53d9a14510ff412e2277014674b9c7" translate="yes" xml:space="preserve">
          <source>Note that parallel utility commands should not consume substantially more memory than equivalent non-parallel operations. This strategy differs from that of parallel query, where resource limits generally apply per worker process. Parallel utility commands treat the resource limit &lt;code&gt;maintenance_work_mem&lt;/code&gt; as a limit to be applied to the entire utility command, regardless of the number of parallel worker processes. However, parallel utility commands may still consume substantially more CPU resources and I/O bandwidth.</source>
          <target state="translated">パラレルユーティリティコマンドは、同等の非パラレル操作よりも大幅に多くのメモリを消費しないことに注意してください。この戦略は、リソースの制限が一般にワーカープロセスごとに適用される並列クエリの戦略とは異なります。並列ユーティリティコマンドは、リソース制限 &lt;code&gt;maintenance_work_mem&lt;/code&gt; を、並列ワーカープロセスの数に関係なく、ユーティリティコマンド全体に適用される制限として扱います。ただし、並列ユーティリティコマンドは、依然としてかなり多くのCPUリソースとI / O帯域幅を消費します。</target>
        </trans-unit>
        <trans-unit id="1c3896a4097aefd43e61d30f8ed6fc4608d53683" translate="yes" xml:space="preserve">
          <source>Note that partition pruning is driven only by the constraints defined implicitly by the partition keys, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former.</source>
          <target state="translated">パーティションの剪定は、パーティションキーによって暗黙的に定義された制約によってのみ実行され、インデックスの存在によっては実行されないことに注意してください。したがって、キーカラムにインデックスを定義する必要はありません。あるパーティションに対してインデックスを作成する必要があるかどうかは、そのパーティションをスキャンするクエリが、一般的にはパーティションの大部分をスキャンするのか、それとも小さな部分だけをスキャンするのかに依存します。インデックスは後者の場合に役立ちますが、前者の場合には役立ちません。</target>
        </trans-unit>
        <trans-unit id="c526234778414186549c3a732294e28ea6360814" translate="yes" xml:space="preserve">
          <source>Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. However, superusers and the owner of the table being dumped always bypass RLS.</source>
          <target state="translated">pg_dumpは、テーブルのすべての内容が確実にダンプされるように、デフォルトで &lt;code&gt;row_security&lt;/code&gt; を &lt;code&gt;OFF&lt;/code&gt; に設定することに注意してください。pg_dumpを実行しているユーザーに適切な権限がない場合、エラーが返されます。ただし、スーパーユーザーとダンプされるテーブルの所有者は常にRLSをバイパスします。</target>
        </trans-unit>
        <trans-unit id="8457004be1bd2121d647641e3e2f206401f9ee82" translate="yes" xml:space="preserve">
          <source>Note that revoking this privilege will not alter the existence or location of existing objects.</source>
          <target state="translated">この特権を取り消しても、既存のオブジェクトの存在や場所は変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="aed232352821561d7f4d97b0cbed4bb08fe3a2ef" translate="yes" xml:space="preserve">
          <source>Note that roles are defined at the database cluster level, and so are valid in all databases in the cluster.</source>
          <target state="translated">ロールはデータベースクラスタレベルで定義され、クラスタ内のすべてのデータベースで有効であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="746fd0d5f2f710a9b186a9ef98779e17d15fa9db" translate="yes" xml:space="preserve">
          <source>Note that tablespace directories are not cleaned up either way.</source>
          <target state="translated">テーブルスペースディレクトリはどちらの方法でもクリーンアップされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d1d5538437b8defc93f56eee03304e310c0c5042" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;actual time&amp;rdquo; values are in milliseconds of real time, whereas the &lt;code&gt;cost&lt;/code&gt; estimates are expressed in arbitrary units; so they are unlikely to match up. The thing that's usually most important to look for is whether the estimated row counts are reasonably close to reality. In this example the estimates were all dead-on, but that's quite unusual in practice.</source>
          <target state="translated">「実際の時間」の値はリアルタイムのミリ秒単位ですが、 &lt;code&gt;cost&lt;/code&gt; 見積もりは任意の単位で表されます。したがって、一致する可能性は低いです。通常、最も重要なことは、推定行数が現実にかなり近いかどうかです。この例では、見積もりはすべて完全に当てはまりましたが、実際には非常に珍しいものです。</target>
        </trans-unit>
        <trans-unit id="9e220f4fc878ea43d3bad6e0a739b4b79c17d896" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;best match&amp;rdquo; rules are identical for operator and function type resolution. Some examples follow.</source>
          <target state="translated">「ベストマッチ」ルールは、演算子と関数のタイプ解決で同じであることに注意してください。次にいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="ef1701ee0df5df14d039148f316d2e4d2b8aa8fd" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of the geometric types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on), where available for these types, likewise compare areas.</source>
          <target state="translated">「sameas」演算子 &lt;code&gt;~=&lt;/code&gt; は、 &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、および &lt;code&gt;circle&lt;/code&gt; タイプの通常の等式の概念を表すことに注意してください。幾何学的なタイプのいくつかは持って &lt;code&gt;=&lt;/code&gt; 演算子が、 &lt;code&gt;=&lt;/code&gt; は等しいための比較&lt;em&gt;領域&lt;/em&gt;のみ。他のスカラー比較演算子（ &lt;code&gt;&amp;lt;=&lt;/code&gt; など）は、これらのタイプで使用できる場合、同様に領域を比較します。</target>
        </trans-unit>
        <trans-unit id="68a397047ec4388fcee29b79f7e608c05447ff76" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of these types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on) likewise compare areas for these types.</source>
          <target state="translated">「同じ」演算子 &lt;code&gt;~=&lt;/code&gt; は、 &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、および &lt;code&gt;circle&lt;/code&gt; タイプの通常の等式の概念を表すことに注意してください。これらのタイプのいくつかはまた、持っている &lt;code&gt;=&lt;/code&gt; 演算子を、しかし &lt;code&gt;=&lt;/code&gt; は等しいために比較し&lt;em&gt;た領域&lt;/em&gt;のみ。他のスカラー比較演算子（ &lt;code&gt;&amp;lt;=&lt;/code&gt; など）も同様に、これらのタイプの面積を比較します。</target>
        </trans-unit>
        <trans-unit id="3f9568498993be48d548609f8f99b58407bdc0b5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CHECK OPTION&lt;/code&gt; is only supported on views that are automatically updatable, and do not have &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers or &lt;code&gt;INSTEAD&lt;/code&gt; rules. If an automatically updatable view is defined on top of a base view that has &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers, then the &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; may be used to check the conditions on the automatically updatable view, but the conditions on the base view with &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has an &lt;code&gt;INSTEAD&lt;/code&gt; rule that causes the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with the &lt;code&gt;INSTEAD&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;CHECK OPTION&lt;/code&gt; は、自動的に更新可能なビューでのみサポートされ、 &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガーまたは &lt;code&gt;INSTEAD&lt;/code&gt; ルールがないことに注意してください。自動更新可能なビューが &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガーのあるベースビューの上に定義されている場合、 &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; を使用して自動更新可能なビューの条件をチェックできますが、 &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガーのあるベースビューの条件はチェックされている（カスケードされたチェックオプションはトリガー更新可能なビューにカスケードされません。トリガー更新可能なビューで直接定義されたチェックオプションは無視されます）。ビューまたはその基本関係のいずれかに &lt;code&gt;INSTEAD&lt;/code&gt; ルールがあり、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; コマンドが書き換えられると、 &lt;code&gt;INSTEAD&lt;/code&gt; ルールとの関係に基づいて定義された自動更新可能なビューからのチェックも含め、書き換えられたクエリではすべてのチェックオプションが無視されます。</target>
        </trans-unit>
        <trans-unit id="048b814d4fde306f95eb514ec96249604d0f3baf" translate="yes" xml:space="preserve">
          <source>Note that the checksum depends on the block number, so matching block numbers should be passed (except when doing esoteric debugging).</source>
          <target state="translated">チェックサムはブロック番号に依存するので、一致するブロック番号を渡すべきであることに注意してください (秘境的なデバッグを行う場合を除く)。</target>
        </trans-unit>
        <trans-unit id="8c92d729af687d63d61faa7693bb18cfc4db6007" translate="yes" xml:space="preserve">
          <source>Note that the command is invoked by the shell, so if you need to pass any arguments to shell command that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">コマンドはシェルによって起動されるので、信頼できないソースからの引数をシェルコマンドに渡す必要がある場合は、シェルにとって特別な意味を持つ可能性のある特別な文字を取り除くか、エスケープするように注意しなければなりません。セキュリティ上の理由から、固定のコマンド文字列を使用するか、少なくともユーザの入力を渡さないようにするのがベストです。</target>
        </trans-unit>
        <trans-unit id="95e2592cd121958603de591b16676dfd151d7385" translate="yes" xml:space="preserve">
          <source>Note that the effects of all per-row &lt;code&gt;BEFORE INSERT&lt;/code&gt; triggers are reflected in &lt;code&gt;excluded&lt;/code&gt; values, since those effects may have contributed to the row being excluded from insertion.</source>
          <target state="translated">行ごとのすべての &lt;code&gt;BEFORE INSERT&lt;/code&gt; トリガーの影響は &lt;code&gt;excluded&lt;/code&gt; 値に反映されることに注意してください。これらの影響は、挿入から除外される行に影響を与えた可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="5d831510235276a5c3036f14f7c31dd0c8581fc2" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field does not point to another block. Also, on internal pages, the first real data item (the first item that is not a high key) reliably has every column truncated away, leaving no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">右端以外のページ（ &lt;code&gt;btpo_next&lt;/code&gt; フィールドの値がゼロ以外のページ）の最初の項目はページの「上位キー」であり、その &lt;code&gt;data&lt;/code&gt; はページに表示されるすべての項目の上限として機能することに注意してください。その &lt;code&gt;ctid&lt;/code&gt; フィールドは別のブロックを指していません。また、内部ページでは、最初の実際のデータ項目（上位キーではない最初の項目）では、すべての列が確実に切り捨てられ、 &lt;code&gt;data&lt;/code&gt; フィールドに実際の値が残されません。ただし、このようなアイテムの &lt;code&gt;ctid&lt;/code&gt; フィールドには有効なダウンリンクがあります。</target>
        </trans-unit>
        <trans-unit id="e212873009117f62fcd9c668559d87771494a3ea" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field is meaningless. Also, on non-leaf pages, the first real data item (the first item that is not a high key) is a &amp;ldquo;minus infinity&amp;rdquo; item, with no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">右端以外のページ（ &lt;code&gt;btpo_next&lt;/code&gt; フィールドにゼロ以外の値を持つページ）の最初のアイテムは、ページの「ハイキー」であることに注意してください。つまり、その &lt;code&gt;data&lt;/code&gt; は、ページに表示されるすべてのアイテムの上限として機能します。その &lt;code&gt;ctid&lt;/code&gt; フィールドは無意味です。また、非リーフページでは、最初の実際のデータアイテム（ハイキーではない最初のアイテム）は「マイナス無限」のアイテムであり、 &lt;code&gt;data&lt;/code&gt; フィールドに実際の値はありません。ただし、そのようなアイテムの &lt;code&gt;ctid&lt;/code&gt; フィールドには有効なダウンリンクがあります。</target>
        </trans-unit>
        <trans-unit id="535954ca2908fbda93be1ed4d604a5a38ff7249d" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">次のセクションでは、組み込みの &lt;code&gt;heap&lt;/code&gt; &lt;a href=&quot;tableam&quot;&gt;テーブルアクセスメソッド&lt;/a&gt;と組み込みの&lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;インデックスアクセスメソッド&lt;/a&gt;の動作について説明します。PostgreSQLの拡張可能な性質により、他のアクセス方法は異なる動作をする場合があります。</target>
        </trans-unit>
        <trans-unit id="b97c4406cd03632c5651253443e7276d76c22605" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">次のセクションでは、組み込み &lt;code&gt;heap&lt;/code&gt; &lt;a href=&quot;tableam&quot;&gt;テーブルアクセスメソッド&lt;/a&gt;と組み込み&lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;インデックスアクセスメソッド&lt;/a&gt;の動作について説明していることに注意してください。PostgreSQLの拡張可能な性質により、他のアクセス方法は異なる動作をする可能性があります。</target>
        </trans-unit>
        <trans-unit id="5ff99b02bab93b2bce6ccdae00e15d7def0f0061" translate="yes" xml:space="preserve">
          <source>Note that the locale behavior of the server is determined by the environment variables seen by the server, not by the environment of any client. Therefore, be careful to configure the correct locale settings before starting the server. A consequence of this is that if client and server are set up in different locales, messages might appear in different languages depending on where they originated.</source>
          <target state="translated">サーバのロケールの動作は、クライアントの環境ではなく、サーバが見る環境変数によって決まることに注意してください。したがって、サーバを起動する前に正しいロケール設定を行うように注意してください。その結果、クライアントとサーバが異なるロケールで設定されている場合、メッセージがどこから来たかによって、異なる言語で表示される可能性があります。</target>
        </trans-unit>
        <trans-unit id="07d471153d0c31d19d3a687501b18f85b42ddbd4" translate="yes" xml:space="preserve">
          <source>Note that the only supported &lt;a href=&quot;auth-methods&quot;&gt;authentication methods&lt;/a&gt; for use with GSSAPI encryption are &lt;code&gt;gss&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, and &lt;code&gt;trust&lt;/code&gt;.</source>
          <target state="translated">GSSAPI暗号化での使用がサポートされている&lt;a href=&quot;auth-methods&quot;&gt;認証方法&lt;/a&gt;は、 &lt;code&gt;gss&lt;/code&gt; 、 &lt;code&gt;reject&lt;/code&gt; 、および &lt;code&gt;trust&lt;/code&gt; のみであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c1ad926ce9c3e21892b3792f7b8c1dbecab3b69d" translate="yes" xml:space="preserve">
          <source>Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a &amp;ldquo;+&amp;rdquo; operator for some custom data type it will have the same precedence as the built-in &amp;ldquo;+&amp;rdquo; operator, no matter what yours does.</source>
          <target state="translated">演算子の優先規則は、上記の組み込み演算子と同じ名前を持つユーザー定義の演算子にも適用されることに注意してください。たとえば、一部のカスタムデータタイプに「+」演算子を定義すると、組み込みの「+」演算子と同じ優先順位が、何を実行するかに関係なく生成されます。</target>
        </trans-unit>
        <trans-unit id="c8f86dee03c6b505a272324fb9a4a25b4a43909d" translate="yes" xml:space="preserve">
          <source>Note that the ordering options are considered independently for each sort column. For example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; means &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;, which is not the same as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">並べ替えオプションは、並べ替え列ごとに個別に考慮されることに注意してください。たとえば、 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; は、 &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; 、y DESCを意味します。これは、 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e2d7f74d4ba0ae61a9bd9e94f45d68a74a955765" translate="yes" xml:space="preserve">
          <source>Note that the parser automatically understands that &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are of type &lt;code&gt;boolean&lt;/code&gt;, but this is not so for &lt;code&gt;NULL&lt;/code&gt; because that can have any type. So in some contexts you might have to cast &lt;code&gt;NULL&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt; explicitly, for example &lt;code&gt;NULL::boolean&lt;/code&gt;. Conversely, the cast can be omitted from a string-literal Boolean value in contexts where the parser can deduce that the literal must be of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">パーサーは &lt;code&gt;TRUE&lt;/code&gt; と &lt;code&gt;FALSE&lt;/code&gt; が &lt;code&gt;boolean&lt;/code&gt; 型であることを自動的に理解することに注意してください。ただし、これは &lt;code&gt;NULL&lt;/code&gt; の場合はそうではありません。したがって、コンテキストによっては、 &lt;code&gt;NULL::boolean&lt;/code&gt; など、明示的に &lt;code&gt;NULL&lt;/code&gt; を &lt;code&gt;boolean&lt;/code&gt; にキャストする必要がある場合があります。逆に、パーサーがリテラルが &lt;code&gt;boolean&lt;/code&gt; 型である必要があると推測できるコンテキストでは、文字列リテラルのブール値からキャストを省略できます。</target>
        </trans-unit>
        <trans-unit id="6830af538ea3d4def0017ebca2cb9eb811ef481a" translate="yes" xml:space="preserve">
          <source>Note that the password prompt will occur again for each database to be dumped. Usually, it's better to set up a &lt;code&gt;~/.pgpass&lt;/code&gt; file than to rely on manual password entry.</source>
          <target state="translated">ダンプするデータベースごとにパスワードプロンプトが再度表示されることに注意してください。通常、手動のパスワード入力に依存するよりも &lt;code&gt;~/.pgpass&lt;/code&gt; ファイルを設定する方が適切です。</target>
        </trans-unit>
        <trans-unit id="42ada1c8e6a6026750e361cb5d7ba311ef045adc" translate="yes" xml:space="preserve">
          <source>Note that the query planner does not consider deferring the evaluation of parallel-restricted functions or aggregates involved in the query in order to obtain a superior plan. So, for example, if a &lt;code&gt;WHERE&lt;/code&gt; clause applied to a particular table is parallel restricted, the query planner will not consider performing a scan of that table in the parallel portion of a plan. In some cases, it would be possible (and perhaps even efficient) to include the scan of that table in the parallel portion of the query and defer the evaluation of the &lt;code&gt;WHERE&lt;/code&gt; clause so that it happens above the &lt;code&gt;Gather&lt;/code&gt; node. However, the planner does not do this.</source>
          <target state="translated">クエリプランナーは、上位プランを取得するために、クエリに含まれる並列制限された関数または集計の評価を延期することを考慮していないことに注意してください。したがって、たとえば、特定のテーブルに適用される &lt;code&gt;WHERE&lt;/code&gt; 句が並列制限されている場合、クエリプランナーはプランの並列部分でそのテーブルのスキャンを実行することを考慮しません。場合によっては、クエリの並列部分にそのテーブルのスキャンを含めて、 &lt;code&gt;WHERE&lt;/code&gt; 句の評価を延期し、 &lt;code&gt;Gather&lt;/code&gt; ノードの上で実行することが可能です（おそらく効率的です）。ただし、計画担当者はこれを行いません。</target>
        </trans-unit>
        <trans-unit id="5f4f575c0dfc110a613df4c8c43c09b6bc17afc4" translate="yes" xml:space="preserve">
          <source>Note that the single-user mode server does not provide sophisticated line-editing features (no command history, for example). Single-user mode also does not do any background processing, such as automatic checkpoints or replication.</source>
          <target state="translated">シングルユーザモードのサーバは、洗練されたライン編集機能を提供しないことに注意してください(例えば、コマンド履歴はありません)。また、シングルユーザーモードでは、自動チェックポイントやレプリケーションなどのバックグラウンド処理も行いません。</target>
        </trans-unit>
        <trans-unit id="542b405bccbd1dfc2248044e2da7018d901a07e8" translate="yes" xml:space="preserve">
          <source>Note that the unique key on this catalog is (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collencoding&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;) not just (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;). PostgreSQL generally ignores all collations that do not have &lt;code&gt;collencoding&lt;/code&gt; equal to either the current database's encoding or -1, and creation of new entries with the same name as an entry with &lt;code&gt;collencoding&lt;/code&gt; = -1 is forbidden. Therefore it is sufficient to use a qualified SQL name (&lt;code&gt;schema&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt;) to identify a collation, even though this is not unique according to the catalog definition. The reason for defining the catalog this way is that initdb fills it in at cluster initialization time with entries for all locales available on the system, so it must be able to hold entries for all encodings that might ever be used in the cluster.</source>
          <target state="translated">（注）このカタログの一意のキーが（あると &lt;code&gt;collname&lt;/code&gt; 、 &lt;code&gt;collencoding&lt;/code&gt; 、 &lt;code&gt;collnamespace&lt;/code&gt; ）だけではなく（ &lt;code&gt;collname&lt;/code&gt; 、 &lt;code&gt;collnamespace&lt;/code&gt; ）。 PostgreSQLは一般に、現在のデータベースのエンコーディングまたは-1と等しい &lt;code&gt;collencoding&lt;/code&gt; を持たないすべての照合を無視し、 &lt;code&gt;collencoding&lt;/code&gt; = -1のエントリと同じ名前の新しいエントリの作成は禁止されています。したがって、それが修飾SQL名を使用することで十分である（ &lt;code&gt;schema&lt;/code&gt; 。 &lt;code&gt;name&lt;/code&gt; ）これはカタログ定義によれば一意ではありませんが、照合を識別するためです。このようにカタログを定義する理由は、initdbがクラスターの初期化時に、システムで使用可能なすべてのロケールのエントリーでカタログを埋めるため、クラスターで使用される可能性のあるすべてのエンコーディングのエントリーを保持できる必要があるためです。</target>
        </trans-unit>
        <trans-unit id="57816233be3efc2c0b4b0cdc3b84a0dda807639d" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">ビューで挿入、更新、または削除を実行するユーザーは、ビューで対応する挿入、更新、または削除の特権を持っている必要があることに注意してください。さらに、ビューの所有者は、基礎となる基本リレーションに対する関連する権限を持っている必要がありますが、更新を実行するユーザーには、基礎となる基本リレーションに対する権限は必要ありません（&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;セクション40.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="52e6a2ffb8f6a4ee70000d58285441af2239687a" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">ビューで挿入、更新、または削除を実行するユーザーは、ビューで対応する挿入、更新、または削除の権限を持っている必要があることに注意してください。さらに、ビューの所有者は、基礎となる基本関係に対する関連する特権を持っている必要がありますが、更新を実行するユーザーは、基礎となる基本関係に対する権限を必要としません（&lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;セクション40.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7f758ecc8993acb3505a10e1f0f3118a15da20e0" translate="yes" xml:space="preserve">
          <source>Note that the white space on each line is actually a tab character.</source>
          <target state="translated">各行の空白は、実際にはタブ文字であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f2961d22f06a0ed36b2caf77fbad086d6c0a84ff" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in an online backup from the standby:</source>
          <target state="translated">待機中からのオンラインバックアップには制限があるので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="4d288b29e3c118d6d8c73403f59b3896205eea76" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in taking a backup from a standby:</source>
          <target state="translated">待機状態からバックアップを取るには、いくつかの制限があるので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="ad0151522b3b77d6456a32b223d7660f4475e688" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;CREATE ROUTINE&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;CREATE ROUTINE&lt;/code&gt; コマンドがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a1d66a79704a8f138a556c34b5e710e75580d121" translate="yes" xml:space="preserve">
          <source>Note that there needs to be at least one permissive policy to grant access to records before restrictive policies can be usefully used to reduce that access. If only restrictive policies exist, then no records will be accessible. When a mix of permissive and restrictive policies are present, a record is only accessible if at least one of the permissive policies passes, in addition to all the restrictive policies.</source>
          <target state="translated">制限的なポリシーをそのアクセスを減らすために有効に使用する前に、レコードへのアクセスを許可するために、少なくとも1つの寛容なポリシーが必要であることに注意してください。制限的なポリシーのみが存在する場合、レコードにはアクセスできません。許可ポリシーと制限ポリシーが混在している場合、すべての制限ポリシーに加えて、少なくとも1つの許可ポリシーが通過した場合にのみ、レコードはアクセス可能となります。</target>
        </trans-unit>
        <trans-unit id="95b9e36ae86d5f4054bebe05afb0d0ec344eb9ad" translate="yes" xml:space="preserve">
          <source>Note that these potentially produce a lot of data, which needs to be built up in memory. When requesting content mappings of large schemas or databases, it might be worthwhile to consider mapping the tables separately instead, possibly even through a cursor.</source>
          <target state="translated">これらは潜在的に多くのデータを生成し、メモリに構築する必要があることに注意してください。大規模なスキーマやデータベースのコンテンツマッピングを要求する場合は、テーブルを個別にマッピングすることを検討する価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b8effb15698d614b121eab24d0dff7bc4e7c22a6" translate="yes" xml:space="preserve">
          <source>Note that this actually means &amp;ldquo;revoke all privileges that I granted&amp;rdquo;.</source>
          <target state="translated">これは実際には「許可したすべての権限を取り消す」ことを意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a377102624b4be7d75b74040aea8858a414e0fc7" translate="yes" xml:space="preserve">
          <source>Note that this behavior is consistent with other popular implementations of host name-based access control, such as the Apache HTTP Server and TCP Wrappers.</source>
          <target state="translated">この動作は、Apache HTTPサーバやTCPラッパーのような、ホスト名ベースのアクセス制御の他の一般的な実装と一致していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="765730fc2ec6d6848cd71e4c2044c699075b50df" translate="yes" xml:space="preserve">
          <source>Note that this command is subtly different from the server-side &lt;code&gt;lo_import&lt;/code&gt; because it acts as the local user on the local file system, rather than the server's user and file system.</source>
          <target state="translated">このコマンドは、サーバーのユーザーとファイルシステムではなく、ローカルファイルシステムのローカルユーザーとして機能するため、サーバー側の &lt;code&gt;lo_import&lt;/code&gt; とは微妙に異なります。</target>
        </trans-unit>
        <trans-unit id="0f8fb90970b8968e4f7127f317566345b970df55" translate="yes" xml:space="preserve">
          <source>Note that this doesn't affect any existing rows in the table, it just changes the default for future &lt;code&gt;INSERT&lt;/code&gt; commands.</source>
          <target state="translated">これはテーブル内の既存の行には影響せず、将来の &lt;code&gt;INSERT&lt;/code&gt; コマンドのデフォルトを変更するだけであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="56e3b32d061c366fed83bd98f4d4590767c40034" translate="yes" xml:space="preserve">
          <source>Note that this is different from</source>
          <target state="translated">とは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9e5d1d4e065e9c7dc21ef91bf768d68d3c9d8a1d" translate="yes" xml:space="preserve">
          <source>Note that this is not the same as the left-to-right &amp;ldquo;short-circuiting&amp;rdquo; of Boolean operators that is found in some programming languages.</source>
          <target state="translated">これは、一部のプログラミング言語で見られるブール演算子の左から右への「短絡」と同じではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ca51a28e46507688c57df1dccd9f468de8996aae" translate="yes" xml:space="preserve">
          <source>Note that this option currently also requires the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as &lt;code&gt;COPY FROM&lt;/code&gt; does not support row security.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; は行のセキュリティをサポートしていないため、現在このオプションでは、ダンプが &lt;code&gt;INSERT&lt;/code&gt; 形式である必要もあります。</target>
        </trans-unit>
        <trans-unit id="9da43a46207df32c5bc41dc69140b018443cc610" translate="yes" xml:space="preserve">
          <source>Note that this option is incompatible with the &lt;code&gt;--index&lt;/code&gt; and &lt;code&gt;--system&lt;/code&gt; options.</source>
          <target state="translated">このオプションは、 &lt;code&gt;--index&lt;/code&gt; および &lt;code&gt;--system&lt;/code&gt; オプションと互換性がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ddb5224f9cf66b54a71c646c3cd12c1c98805d5f" translate="yes" xml:space="preserve">
          <source>Note that this option only affects the exact form &lt;code&gt;= NULL&lt;/code&gt;, not other comparison operators or other expressions that are computationally equivalent to some expression involving the equals operator (such as &lt;code&gt;IN&lt;/code&gt;). Thus, this option is not a general fix for bad programming.</source>
          <target state="translated">このオプションは、正確な形式 &lt;code&gt;= NULL&lt;/code&gt; にのみ影響し、他の比較演算子や、等号演算子を含む一部の式（ &lt;code&gt;IN&lt;/code&gt; など）と計算上同等の式には影響しないことに注意してください。したがって、このオプションは悪いプログラミングに対する一般的な修正ではありません。</target>
        </trans-unit>
        <trans-unit id="e47f160f4c862fafa44c7f19b4f7d0d78fd15669" translate="yes" xml:space="preserve">
          <source>Note that this option will remain set for the entire session, and so it affects uses of the meta-command &lt;code&gt;\connect&lt;/code&gt; as well as the initial connection attempt.</source>
          <target state="translated">このオプションはセッション全体で設定されたままになるため、メタコマンド &lt;code&gt;\connect&lt;/code&gt; と最初の接続試行に影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="9cb49d36842c28bbc6961c206fc6fb511f408fc8" translate="yes" xml:space="preserve">
          <source>Note that this query cannot use this index:</source>
          <target state="translated">このクエリはこのインデックスを使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="eeb09f3d3f513d7242e768b40d1a3d7a48755d6c" translate="yes" xml:space="preserve">
          <source>Note that this setting only affects the main shared memory area. Operating systems such as Linux, FreeBSD, and Illumos can also use huge pages (also known as &amp;ldquo;super&amp;rdquo; pages or &amp;ldquo;large&amp;rdquo; pages) automatically for normal memory allocation, without an explicit request from PostgreSQL. On Linux, this is called &amp;ldquo;transparent huge pages&amp;rdquo; (THP). That feature has been known to cause performance degradation with PostgreSQL for some users on some Linux versions, so its use is currently discouraged (unlike explicit use of &lt;code&gt;huge_pages&lt;/code&gt;).</source>
          <target state="translated">この設定はメインの共有メモリ領域にのみ影響することに注意してください。 Linux、FreeBSD、およびIllumosなどのオペレーティングシステムは、PostgreSQLからの明示的な要求なしに、通常のメモリ割り当てに巨大ページ（「スーパー」ページまたは「ラージ」ページとも呼ばれる）を自動的に使用することもできます。 Linuxでは、これは「トランスペアレントヒュージページ」（THP）と呼ばれます。この機能は、一部のLinuxバージョンの一部のユーザーに対してPostgreSQLのパフォーマンス低下を引き起こすことが知られているため、（ &lt;code&gt;huge_pages&lt;/code&gt; の明示的な使用とは異なり）現在、その使用は推奨されていません。</target>
        </trans-unit>
        <trans-unit id="601d111715a6b1b59291397e0542ab5aa27f6545" translate="yes" xml:space="preserve">
          <source>Note that this view does not include memory allocated using the dynamic shared memory infrastructure.</source>
          <target state="translated">このビューには、動的共有メモリ・インフラストラクチャを使用して割り当てられたメモリは含まれていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="906c24642d7c9d1ccf94ab876f98cee1fa64d503" translate="yes" xml:space="preserve">
          <source>Note that this way the connection from &lt;code&gt;shell.foo.com&lt;/code&gt; to &lt;code&gt;db.foo.com&lt;/code&gt; will not be encrypted by the SSH tunnel. SSH offers quite a few configuration possibilities when the network is restricted in various ways. Please refer to the SSH documentation for details.</source>
          <target state="translated">この方法でから接続することを注意 &lt;code&gt;shell.foo.com&lt;/code&gt; に &lt;code&gt;db.foo.com&lt;/code&gt; は、 SSHトンネルによって暗号化されません。SSHは、ネットワークがさまざまな方法で制限されている場合に、いくつかの構成の可能性を提供します。詳細については、SSHのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="aed9a462aeaf6aae78a53a2e55aac5e3c16613ab" translate="yes" xml:space="preserve">
          <source>Note that this will result in locking all rows of &lt;code&gt;mytable&lt;/code&gt;, whereas &lt;code&gt;FOR UPDATE&lt;/code&gt; at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the &lt;code&gt;ORDER BY&lt;/code&gt; is combined with &lt;code&gt;LIMIT&lt;/code&gt; or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.</source>
          <target state="translated">これは、すべての行ロックとなることに注意して下さい &lt;code&gt;mytable&lt;/code&gt; はのに対し、 &lt;code&gt;FOR UPDATE&lt;/code&gt; トップレベルでは唯一、実際に返された行をロックします。これにより、特に &lt;code&gt;ORDER BY&lt;/code&gt; が &lt;code&gt;LIMIT&lt;/code&gt; またはその他の制限と組み合わされている場合、パフォーマンスに大きな違いが生じる可能性があります。したがって、この手法は、順序付け列の同時更新が予想され、厳密にソートされた結果が必要な場合にのみお勧めします。</target>
        </trans-unit>
        <trans-unit id="59d9533d6b1ff70587da7945ccc9db2ea583f449" translate="yes" xml:space="preserve">
          <source>Note that two rows are displayed for the same column, one corresponding to the complete inheritance hierarchy starting at the &lt;code&gt;road&lt;/code&gt; table (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;t&lt;/code&gt;), and another one including only the &lt;code&gt;road&lt;/code&gt; table itself (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;f&lt;/code&gt;).</source>
          <target state="translated">同じ列に2つの行が表示されていることに注意してください。1つは &lt;code&gt;road&lt;/code&gt; テーブルから始まる完全な継承階層に対応し（ &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;t&lt;/code&gt; ）、もう1つは &lt;code&gt;road&lt;/code&gt; テーブル自体のみを含む（ &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="10e9b0e25eb4f44f89bb51356ad1df0c93761c8b" translate="yes" xml:space="preserve">
          <source>Note that unlike most catalogs with a &amp;ldquo;namespace&amp;rdquo; column, &lt;code&gt;extnamespace&lt;/code&gt; is not meant to imply that the extension belongs to that schema. Extension names are never schema-qualified. Rather, &lt;code&gt;extnamespace&lt;/code&gt; indicates the schema that contains most or all of the extension's objects. If &lt;code&gt;extrelocatable&lt;/code&gt; is true, then this schema must in fact contain all schema-qualifiable objects belonging to the extension.</source>
          <target state="translated">「namespace」列を持つほとんどのカタログとは異なり、 &lt;code&gt;extnamespace&lt;/code&gt; は、拡張機能がそのスキーマに属していることを意味するものではないことに注意してください。拡張名はスキーマで修飾されません。むしろ、 &lt;code&gt;extnamespace&lt;/code&gt; は、拡張のオブジェクトのほとんどまたはすべてを含むスキーマを示します。場合 &lt;code&gt;extrelocatable&lt;/code&gt; が真で、その後、実際には、このスキーマ必見拡張に属するすべてのスキーマqualifiableオブジェクトを含みます。</target>
        </trans-unit>
        <trans-unit id="95d30679c93680a49476e594a17f9119213eea89" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;code&gt;cube&lt;/code&gt;-based part of the module, units are hardwired here: changing the &lt;code&gt;earth()&lt;/code&gt; function will not affect the results of this operator.</source>
          <target state="translated">モジュールの &lt;code&gt;cube&lt;/code&gt; ベースの部分とは異なり、ユニットはここに組み込まれていることに注意してください。earth &lt;code&gt;earth()&lt;/code&gt; 関数を変更しても、この演算子の結果には影響しません。</target>
        </trans-unit>
        <trans-unit id="aec424e8783da60644af6ec05ea73b5e181a5ff9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;ldapscheme&lt;/code&gt; or &lt;code&gt;ldaptls&lt;/code&gt; only encrypts the traffic between the PostgreSQL server and the LDAP server. The connection between the PostgreSQL server and the PostgreSQL client will still be unencrypted unless SSL is used there as well.</source>
          <target state="translated">&lt;code&gt;ldapscheme&lt;/code&gt; または &lt;code&gt;ldaptls&lt;/code&gt; を使用すると、PostgreSQLサーバーとLDAPサーバー間のトラフィックのみが暗号化されることに注意してください。PostgreSQLサーバーとPostgreSQLクライアント間の接続は、SSLが使用されていない限り、暗号化されません。</target>
        </trans-unit>
        <trans-unit id="f4e11f3a6327ed7b6ce66ef2d86de4e055bd13dd" translate="yes" xml:space="preserve">
          <source>Note that using this mode together with the &lt;code&gt;-f&lt;/code&gt; (&lt;code&gt;FULL&lt;/code&gt;) option might cause deadlock failures if certain system catalogs are processed in parallel.</source>
          <target state="translated">このモードを &lt;code&gt;-f&lt;/code&gt; （ &lt;code&gt;FULL&lt;/code&gt; ）オプションと一緒に使用すると、特定のシステムカタログが並行して処理される場合にデッドロック障害が発生する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f608b76c0c846a43652d18d27b367a743ac19721" translate="yes" xml:space="preserve">
          <source>Note that weight labels apply to &lt;em&gt;positions&lt;/em&gt;, not &lt;em&gt;lexemes&lt;/em&gt;. If the input vector has been stripped of positions then &lt;code&gt;setweight&lt;/code&gt; does nothing.</source>
          <target state="translated">重量ラベルは&lt;em&gt;語彙素&lt;/em&gt;ではなく&lt;em&gt;位置&lt;/em&gt;に適用されることに注意してください。入力ベクトルの位置が取り除かれている場合、 &lt;code&gt;setweight&lt;/code&gt; は何もしません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a501f50ad867471d366c858d1e68c08c9bf71a3b" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;ANALYZE&lt;/code&gt; is run on a partitioned table, all of its partitions are also recursively analyzed as also mentioned in &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;. In that case, &lt;code&gt;ANALYZE&lt;/code&gt; progress is reported first for the parent table, whereby its inheritance statistics are collected, followed by that for each partition.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; がパーティションテーブルで実行されると、&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;でも説明されているように、そのすべてのパーティションも再帰的に分析されることに注意してください。その場合、 &lt;code&gt;ANALYZE&lt;/code&gt; の進行状況が最初に親テーブルについて報告され、それによってその継承統計が収集され、次に各パーティションの統計が収集されます。</target>
        </trans-unit>
        <trans-unit id="1fb0133d2b01bcc98921dcbe4b4f3b20ca215976" translate="yes" xml:space="preserve">
          <source>Note that when an ACL entry in another catalog is null, it is taken to represent the hard-wired default privileges for its object, &lt;em&gt;not&lt;/em&gt; whatever might be in &lt;code&gt;pg_default_acl&lt;/code&gt; at the moment. &lt;code&gt;pg_default_acl&lt;/code&gt; is only consulted during object creation.</source>
          <target state="translated">別のカタログのACLエントリがnullの場合、そのオブジェクトのハードワイヤードデフォルト特権を表すと &lt;code&gt;pg_default_acl&lt;/code&gt; れ、現時点でpg_default_aclにあるもの&lt;em&gt;は&lt;/em&gt;何もないことに注意してください。 &lt;code&gt;pg_default_acl&lt;/code&gt; は、オブジェクトの作成時にのみ参照されます。</target>
        </trans-unit>
        <trans-unit id="2e6cf1460524f06f7b596e4f9001c12f09f21277" translate="yes" xml:space="preserve">
          <source>Note that when autovacuum runs, up to &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; times this memory may be allocated, so be careful not to set the default value too high. It may be useful to control for this by separately setting &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt;.</source>
          <target state="translated">autovacuumの実行時に、&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt;倍までこのメモリが割り当てられる可能性があるため、デフォルト値を高く設定しすぎないように注意してください。&lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_memを&lt;/a&gt;個別に設定することで、これを制御すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="b298d8fd9d5a27445f1547b4987f220ddf522324" translate="yes" xml:space="preserve">
          <source>Note that when multiple rewrite rules are applied in this way, the order of application can be important; so in practice you will want the source query to &lt;code&gt;ORDER BY&lt;/code&gt; some ordering key.</source>
          <target state="translated">この方法で複数の書き換えルールを適用する場合、適用の順序が重要になる可能性があることに注意してください。そのため、実際には、ソースクエリをいくつかの順序付けキーで &lt;code&gt;ORDER BY&lt;/code&gt; する必要があります。</target>
        </trans-unit>
        <trans-unit id="15b117a19d6af07c7a1d926814d3fa7ed429f962" translate="yes" xml:space="preserve">
          <source>Note that when using nondefault WAL segment sizes, the numbers in the WAL file names are different from the LSNs that are reported by system functions and system views. This option takes a WAL file name, not an LSN.</source>
          <target state="translated">デフォルトではないWALセグメントサイズを使用している場合、WALファイル名の数値は、システム機能やシステムビューで報告されるLSNとは異なることに注意してください。このオプションは、LSNではなくWALファイル名を使用します。</target>
        </trans-unit>
        <trans-unit id="5091d99db40796ae0ac6a127a75124d1c7974a77" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;COPY&lt;/code&gt; allows options such as &lt;code&gt;HEADER&lt;/code&gt; to be specified without a corresponding value, the foreign table option syntax requires a value to be present in all cases. To activate &lt;code&gt;COPY&lt;/code&gt; options typically written without a value, you can pass the value TRUE, since all such options are Booleans.</source>
          <target state="translated">ながらそのノート &lt;code&gt;COPY&lt;/code&gt; が可能などのオプション &lt;code&gt;HEADER&lt;/code&gt; 、対応する値なしで指定されるが、外部テーブルのオプション構文は、すべての場合に存在する値を必要とします。値なしで通常書き込まれる &lt;code&gt;COPY&lt;/code&gt; オプションをアクティブにするには、そのようなオプションはすべてブール値であるため、値TRUEを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="20e2ed64775c1454506227ebe10642431813ecd2" translate="yes" xml:space="preserve">
          <source>Note that while a table's filenode often matches its OID, this is &lt;em&gt;not&lt;/em&gt; necessarily the case; some operations, like &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;, can change the filenode while preserving the OID. Avoid assuming that filenode and table OID are the same. Also, for certain system catalogs including &lt;code&gt;pg_class&lt;/code&gt; itself, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt; contains zero. The actual filenode number of these catalogs is stored in a lower-level data structure, and can be obtained using the &lt;code&gt;pg_relation_filenode()&lt;/code&gt; function.</source>
          <target state="translated">テーブルのファイルノードはしばしばOIDと一致しますが、これは必ずしもそうでは&lt;em&gt;ない&lt;/em&gt;ことに注意してください。 &lt;code&gt;TRUNCATE&lt;/code&gt; 、 &lt;code&gt;REINDEX&lt;/code&gt; 、 &lt;code&gt;CLUSTER&lt;/code&gt; および一部の形式の &lt;code&gt;ALTER TABLE&lt;/code&gt; などの一部の操作では、OIDを保持しながらファイルノードを変更できます。 filenodeとテーブルOIDが同じであると想定しないでください。また、 &lt;code&gt;pg_class&lt;/code&gt; 自体を含む特定のシステムカタログでは、 &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;relfilenode&lt;/code&gt; にはゼロが含まれています。これらのカタログの実際のファイルノード番号は、下位レベルのデータ構造に格納され、 &lt;code&gt;pg_relation_filenode()&lt;/code&gt; 関数を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="acd42ff3a7dd119700e6cb55e96c90dc5e6fd840" translate="yes" xml:space="preserve">
          <source>Note that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">ローカルパーティションから外部テーブルパーティションに行を移動させることができますが(外部データラッパーがタプルルーティングをサポートしている場合)、外部テーブルパーティションから別のパーティションには移動できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2d8be16bebefaea4da0b18cb12ca9511981a5205" translate="yes" xml:space="preserve">
          <source>Note that while the above will indeed grant all privileges if executed by a superuser or the owner of &lt;code&gt;kinds&lt;/code&gt;, when executed by someone else it will only grant those permissions for which the someone else has grant options.</source>
          <target state="translated">上記はスーパーユーザーまたは &lt;code&gt;kinds&lt;/code&gt; の所有者によって実行された場合、実際にすべての特権を付与しますが、他の誰かによって実行された場合、他のユーザーが付与オプションを持っている権限のみを付与することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ec3a83831ac9036a3595c6ce5f5e7350a4e67363" translate="yes" xml:space="preserve">
          <source>Note that while this system allows creating collations that &amp;ldquo;ignore case&amp;rdquo; or &amp;ldquo;ignore accents&amp;rdquo; or similar (using the &lt;code&gt;ks&lt;/code&gt; key), in order for such collations to act in a truly case- or accent-insensitive manner, they also need to be declared as not &lt;em&gt;deterministic&lt;/em&gt; in &lt;code&gt;CREATE COLLATION&lt;/code&gt;; see &lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;Section 23.2.2.4&lt;/a&gt;. Otherwise, any strings that compare equal according to the collation but are not byte-wise equal will be sorted according to their byte values.</source>
          <target state="translated">このシステムでは、「大文字と小文字を無視する」または「アクセントを無視する」などの照合を作成できますが（ &lt;code&gt;ks&lt;/code&gt; キーを使用）、このような照合が大文字と小文字またはアクセントを区別しない方法で機能するためには、 &lt;code&gt;CREATE COLLATION&lt;/code&gt; で&lt;em&gt;確定的&lt;/em&gt;でないと宣言されています。&lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;セクション23.2.2.4を&lt;/a&gt;参照してください。それ以外の場合、照合に従って等しいと比較されてもバイト単位で等しくない文字列は、そのバイト値に従ってソートされます。</target>
        </trans-unit>
        <trans-unit id="84595e2b092724cd7800c2af7679de35fbd01caf" translate="yes" xml:space="preserve">
          <source>Note that with any of these methods, attempting to prewarm more blocks than can be cached &amp;mdash; by the OS when using &lt;code&gt;prefetch&lt;/code&gt; or &lt;code&gt;read&lt;/code&gt;, or by PostgreSQL when using &lt;code&gt;buffer&lt;/code&gt; &amp;mdash; will likely result in lower-numbered blocks being evicted as higher numbered blocks are read in. Prewarmed data also enjoys no special protection from cache evictions, so it is possible that other system activity may evict the newly prewarmed blocks shortly after they are read; conversely, prewarming may also evict other data from cache. For these reasons, prewarming is typically most useful at startup, when caches are largely empty.</source>
          <target state="translated">これらの方法のいずれかで、キャッシュできるよりも多くのブロックをプリウォームしようとすると（OSが &lt;code&gt;prefetch&lt;/code&gt; または &lt;code&gt;read&lt;/code&gt; を使用 &lt;code&gt;buffer&lt;/code&gt; 場合、またはPostgreSQLがバッファーを使用する場合）、番号の大きいブロックが読み取られると、番号の小さいブロックが排除される可能性があります。事前にウォームアップされたデータは、キャッシュの排除から特別な保護を受けることもないため、他のシステムアクティビティが、新しくウォームアップされたブロックが読み取られた直後に排除する可能性があります。逆に、予熱によって、他のデータがキャッシュから追い出される場合もあります。これらの理由により、事前ウォーミングは通常、キャッシュがほとんど空である起動時に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="e25d9c4fc7da6af49acba3a1d74aecf78d61de9d" translate="yes" xml:space="preserve">
          <source>Note that you can name the collation objects in the SQL environment anything you want. In this example, we follow the naming style that the predefined collations use, which in turn also follow BCP 47, but that is not required for user-defined collations.</source>
          <target state="translated">SQL環境の照合順序オブジェクトには、任意の名前を付けることができます。この例では、定義済み照合順序が使用する命名スタイルに従っていますが、BCP 47にも従っています。</target>
        </trans-unit>
        <trans-unit id="d9f6471c0f24b8d6760419402c171355a4484c03" translate="yes" xml:space="preserve">
          <source>Note that you must execute this command while logged into the PostgreSQL user account, which is described in the previous section.</source>
          <target state="translated">前のセクションで説明したように、PostgreSQLのユーザアカウントにログインした状態でこのコマンドを実行する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bb0a6a455313edbad71a60b25303151964bacc15" translate="yes" xml:space="preserve">
          <source>Note that you should also create an index with the default operator class if you want queries involving ordinary &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt; comparisons to use an index. Such queries cannot use the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes. (Ordinary equality comparisons can use these operator classes, however.) It is possible to create multiple indexes on the same column with different operator classes. If you do use the C locale, you do not need the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes, because an index with the default operator class is usable for pattern-matching queries in the C locale.</source>
          <target state="translated">通常の &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、または &lt;code&gt;&amp;gt;=&lt;/code&gt; の比較を含むクエリでインデックスを使用する場合は、デフォルトの演算子クラスでインデックスを作成する必要があることに注意してください。このようなクエリでは、 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 演算子クラスを使用できません。 （ただし、通常の等価比較ではこれらの演算子クラスを使用できます。）異なる演算子クラスを使用して、同じ列に複数のインデックスを作成することができます。 Cロケールを使用する場合は、 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 演算子クラスは必要ありません。これは、デフォルトの演算子クラスのインデックスがCロケールでのパターンマッチングクエリに使用できるためです。</target>
        </trans-unit>
        <trans-unit id="a9ac1561fc3ccdadc787e0b99a4aeb85f57a226f" translate="yes" xml:space="preserve">
          <source>Note that, for the purposes of combining multiple policies, &lt;code&gt;ALL&lt;/code&gt; policies are treated as having the same type as whichever other type of policy is being applied.</source>
          <target state="translated">複数のポリシーを組み合わせるために、 &lt;code&gt;ALL&lt;/code&gt; のポリシーは、適用されている他のタイプのポリシーと同じタイプを持つものとして扱われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0ce85a00735b68da34a1fd226cafeaa370c6ae8f" translate="yes" xml:space="preserve">
          <source>Note the relatively large number of false positives: 2439 rows were selected to be visited in the heap, but none actually matched the query. We could reduce that by specifying a larger signature length. In this example, creating the index with &lt;code&gt;length=200&lt;/code&gt; reduced the number of false positives to 55; but it doubled the index size (to 306 MB) and ended up being slower for this query (125 ms overall).</source>
          <target state="translated">偽陽性の数が比較的多いことに注意してください。ヒープ内を訪問するために2439行が選択されましたが、実際にはクエリに一致するものはありません。より長い署名長を指定することで、これを減らすことができます。この例では、 &lt;code&gt;length=200&lt;/code&gt; でインデックスを作成すると、誤検知の数が55に減少しました。しかし、インデックスサイズが2倍になり（306 MBになり）、このクエリでは遅くなりました（全体で125ミリ秒）。</target>
        </trans-unit>
        <trans-unit id="ad6486d9d7802af73d40de7a1e56de198a7926a1" translate="yes" xml:space="preserve">
          <source>Note the use of the double underline in the probe name. In a DTrace script using the probe, the double underline needs to be replaced with a hyphen, so &lt;code&gt;transaction-start&lt;/code&gt; is the name to document for users.</source>
          <target state="translated">プローブ名に二重下線が使用されていることに注意してください。プローブを使用するDTraceスクリプトでは、二重下線をハイフンに置き換える必要があるため、 &lt;code&gt;transaction-start&lt;/code&gt; は、ユーザーに文書化する名前です。</target>
        </trans-unit>
        <trans-unit id="6d65457512b308441a74c7c138c05193c57c7bb6" translate="yes" xml:space="preserve">
          <source>Note there can be ambiguity in the &lt;code&gt;months&lt;/code&gt; field returned by &lt;code&gt;age&lt;/code&gt; because different months have different numbers of days. PostgreSQL's approach uses the month from the earlier of the two dates when calculating partial months. For example, &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; uses April to yield &lt;code&gt;1 mon 1 day&lt;/code&gt;, while using May would yield &lt;code&gt;1 mon 2 days&lt;/code&gt; because May has 31 days, while April has only 30.</source>
          <target state="translated">&lt;code&gt;months&lt;/code&gt; によって日数が異なるため、 &lt;code&gt;age&lt;/code&gt; によって返される月フィールドにはあいまいさが存在する可能性があることに注意してください。PostgreSQLのアプローチでは、部分的な月を計算するときに、2つの日付のうち早い方の月を使用します。たとえば、 &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; は、Aprilを使用して &lt;code&gt;1 mon 1 day&lt;/code&gt; 月1日を生成しますが、Mayを使用すると、5月は31日で4月は30 &lt;code&gt;1 mon 2 days&lt;/code&gt; ので、2月1日を生成します。。</target>
        </trans-unit>
        <trans-unit id="1afbaf202c9ac2c26c7604e3bc2b4bbf35293589" translate="yes" xml:space="preserve">
          <source>Note, however, that the SQL/MED functionality as a whole is not yet conforming.</source>
          <target state="translated">ただし、SQL/MEDの機能全体がまだ適合していないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ccd71e26f3c643a05b48c9814bdace2e62bf73fd" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;ltxtquery&lt;/code&gt; allows whitespace between symbols, but &lt;code&gt;ltree&lt;/code&gt; and &lt;code&gt;lquery&lt;/code&gt; do not.</source>
          <target state="translated">注： &lt;code&gt;ltxtquery&lt;/code&gt; はシンボル間の空白を許可しますが、 &lt;code&gt;ltree&lt;/code&gt; と &lt;code&gt;lquery&lt;/code&gt; は許可しません。</target>
        </trans-unit>
        <trans-unit id="b12db1dd6e1d08b3916e0fb99c42096b024c7157" translate="yes" xml:space="preserve">
          <source>Note: This index type is lossy.</source>
          <target state="translated">注:このインデックス型はロッシーです。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Windowsユーザーのためのノート</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="070bd4d20a16681cab0fd80e64bbfd09232b5422" translate="yes" xml:space="preserve">
          <source>Notice here that we don't need to (and indeed cannot) put parentheses around the column name appearing just after &lt;code&gt;SET&lt;/code&gt;, but we do need parentheses when referencing the same column in the expression to the right of the equal sign.</source>
          <target state="translated">ここで、 &lt;code&gt;SET&lt;/code&gt; の直後に表示される列名を括弧で囲む必要はありません（実際に括弧を付けることはできません）が、等号の右側の式で同じ列を参照する場合は括弧が必要です。</target>
        </trans-unit>
        <trans-unit id="4daabf40dd7349fdbfe5f996ee7218e2e875bd85" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;AS&lt;/code&gt; clause is used to relabel the output column. (The &lt;code&gt;AS&lt;/code&gt; clause is optional.)</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 句を使用して出力列のラベルを変更する方法に注意してください。（ &lt;code&gt;AS&lt;/code&gt; 句はオプションです。）</target>
        </trans-unit>
        <trans-unit id="6e1ea47811c08b80c4e6755f65407fcd8d137657" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;BETWEEN SYMMETRIC&lt;/code&gt; is like &lt;code&gt;BETWEEN&lt;/code&gt; except there is no requirement that the argument to the left of &lt;code&gt;AND&lt;/code&gt; be less than or equal to the argument on the right. If it is not, those two arguments are automatically swapped, so that a nonempty range is always implied.</source>
          <target state="translated">&lt;code&gt;BETWEEN&lt;/code&gt; は、エンドポイント値を範囲に含まれるものとして扱うことに注意してください。 &lt;code&gt;BETWEEN SYMMETRIC&lt;/code&gt; は、 &lt;code&gt;AND&lt;/code&gt; の左側の引数が右側の引数以下である必要がないことを除いて、 &lt;code&gt;BETWEEN&lt;/code&gt; に似ています。そうでない場合は、これら2つの引数が自動的に交換されるため、空でない範囲が常に暗示されます。</target>
        </trans-unit>
        <trans-unit id="faa7b0c69e4931a2ff5fa82ad77b7c14b3d74a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;NOT BETWEEN&lt;/code&gt; does the opposite comparison:</source>
          <target state="translated">&lt;code&gt;BETWEEN&lt;/code&gt; は、エンドポイント値を範囲に含まれるものとして扱うことに注意してください。 &lt;code&gt;NOT BETWEEN&lt;/code&gt; は逆の比較を行います：</target>
        </trans-unit>
        <trans-unit id="8240947764f6659f2796d4acf4007ac22ad3a1c1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;supernova star&lt;/code&gt; matches &lt;code&gt;supernovae stars&lt;/code&gt; in &lt;code&gt;thesaurus_astro&lt;/code&gt; because we specified the &lt;code&gt;english_stem&lt;/code&gt; stemmer in the thesaurus definition. The stemmer removed the &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">ことに注意してください &lt;code&gt;supernova star&lt;/code&gt; 試合は &lt;code&gt;supernovae stars&lt;/code&gt; に &lt;code&gt;thesaurus_astro&lt;/code&gt; 我々が指定したため &lt;code&gt;english_stem&lt;/code&gt; のシソーラス定義でステマーを。ステマーは &lt;code&gt;e&lt;/code&gt; と &lt;code&gt;s&lt;/code&gt; を削除しました。</target>
        </trans-unit>
        <trans-unit id="89eb1ae6972d1166d8e27e8ffc5a4983fca12820" translate="yes" xml:space="preserve">
          <source>Notice that although the recursive view's name is schema-qualified in this &lt;code&gt;CREATE&lt;/code&gt;, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.</source>
          <target state="translated">この &lt;code&gt;CREATE&lt;/code&gt; では、再帰的ビューの名前はスキーマ修飾されていますが、その内部自己参照はスキーマ修飾されていないことに注意してください。これは、暗黙的に作成されたCTEの名前をスキーマで修飾できないためです。</target>
        </trans-unit>
        <trans-unit id="c36fb1e9faaa2ef2c027bbd666eb850c4abbeb31" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as suggested by the examples.</source>
          <target state="translated">&lt;code&gt;enum_range&lt;/code&gt; の 2つの引数の形式を除いて、これらの関数は渡された特定の値を無視することに注意してください。宣言されたデータ型のみを考慮します。 nullまたは型の特定の値を渡すことができ、同じ結果が得られます。例に示されているように、これらの関数をハードワイヤードの型名よりもテーブルの列または関数の引数に適用する方が一般的です。</target>
        </trans-unit>
        <trans-unit id="fb75cf9e722bdf4111edc3be58d21f8a3427f3ff" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as used in the examples.</source>
          <target state="translated">&lt;code&gt;enum_range&lt;/code&gt; の2つの引数形式を除いて、これらの関数は渡された特定の値を無視することに注意してください。宣言されたデータ型のみを考慮します。nullまたはその型の特定の値のいずれかを渡すことができ、同じ結果が得られます。これらの関数は、例で使用されているハードワイヤード型名よりも、テーブルの列または関数の引数に適用する方が一般的です。</target>
        </trans-unit>
        <trans-unit id="3f7db9efeeec80f82f8d01c7d6c915db40d7ca58" translate="yes" xml:space="preserve">
          <source>Notice that here the planner has chosen to &amp;ldquo;materialize&amp;rdquo; the inner relation of the join, by putting a Materialize plan node atop it. This means that the &lt;code&gt;t2&lt;/code&gt; index scan will be done just once, even though the nested-loop join node needs to read that data ten times, once for each row from the outer relation. The Materialize node saves the data in memory as it's read, and then returns the data from memory on each subsequent pass.</source>
          <target state="translated">ここで、プランナは、マテリアライズ計画ノードをその上に置くことにより、結合の内部関係を「マテリアライズ」することを選択したことに注意してください。つまり、入れ子ループ結合ノードがそのデータを外部リレーションからの各行に対して1回ずつ10回読み取る必要がある場合でも、 &lt;code&gt;t2&lt;/code&gt; インデックススキャンは1回だけ実行されます。Materializeノードは、データを読み取ったときにメモリに保存し、その後の各パスでメモリからデータを返します。</target>
        </trans-unit>
        <trans-unit id="4bf689adc2caa48f04b5854bba37632c664406c0" translate="yes" xml:space="preserve">
          <source>Notice that in both &lt;code&gt;ROWS&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; mode, &lt;code&gt;0 PRECEDING&lt;/code&gt; and &lt;code&gt;0 FOLLOWING&lt;/code&gt; are equivalent to &lt;code&gt;CURRENT ROW&lt;/code&gt;. This normally holds in &lt;code&gt;RANGE&lt;/code&gt; mode as well, for an appropriate data-type-specific meaning of &amp;ldquo;zero&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;ROWS&lt;/code&gt; モードと &lt;code&gt;GROUPS&lt;/code&gt; モードの両方で、 &lt;code&gt;0 PRECEDING&lt;/code&gt; および &lt;code&gt;0 FOLLOWING&lt;/code&gt; は &lt;code&gt;CURRENT ROW&lt;/code&gt; と同等であることに注意してください。これは通常、「ゼロ」の適切なデータ型固有の意味のために、 &lt;code&gt;RANGE&lt;/code&gt; モードにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="944ef29330d1f49189c08507e0ff3ef14adbfe93" translate="yes" xml:space="preserve">
          <source>Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag.</source>
          <target state="translated">ドル引用符で囲まれた文字列の中では、単一引用符をエスケープする必要がないことに注意してください。実際、ドル引用符で囲まれた文字列の中にはエスケープされる文字はありません。バックスラッシュは特別なものではありませんし、ドル記号も特別なものではありません。</target>
        </trans-unit>
        <trans-unit id="f68a4013d1520908a834c3452585e4c0680f0866" translate="yes" xml:space="preserve">
          <source>Notice that placing the restriction in the &lt;code&gt;WHERE&lt;/code&gt; clause produces a different result:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句に制限を配置すると、異なる結果が生成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d13f7a26b5cfa0ec363a717ba07bad2b152f0f72" translate="yes" xml:space="preserve">
          <source>Notice that the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; is used. Only text search functions that specify a configuration name can be used in expression indexes (&lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;). This is because the index contents must be unaffected by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;. If they were affected, the index contents might be inconsistent because different entries could contain &lt;code&gt;tsvector&lt;/code&gt;s that were created with different text search configurations, and there would be no way to guess which was which. It would be impossible to dump and restore such an index correctly.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; の 2引数バージョンが使用されていることに注意してください。式インデックスで使用できるのは、構成名を指定するテキスト検索関数のみです（&lt;a href=&quot;indexes-expressional&quot;&gt;セクション11.7&lt;/a&gt;）。これは、インデックスの内容が&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_configの&lt;/a&gt;影響を受けないようにする必要があるためです。影響を受ける場合、異なるテキスト検索構成で作成された &lt;code&gt;tsvector&lt;/code&gt; が異なるエントリに含まれている可能性があり、どれがどれであるかを推測する方法がないため、インデックスの内容に一貫性がない可能性があります。このようなインデックスを正しくダンプして復元することは不可能です。</target>
        </trans-unit>
        <trans-unit id="4b9c07bbe048665c89925c842ae22cd1fc6040f9" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;DROP&lt;/code&gt; syntax only specifies the &amp;ldquo;slot&amp;rdquo; in the operator family, by strategy or support number and input data type(s). The name of the operator or function occupying the slot is not mentioned. Also, for &lt;code&gt;DROP FUNCTION&lt;/code&gt; the type(s) to specify are the input data type(s) the function is intended to support; for GiST, SP-GiST and GIN indexes this might have nothing to do with the actual input argument types of the function.</source>
          <target state="translated">&lt;code&gt;DROP&lt;/code&gt; 構文は、戦略またはサポート番号と入力データ型によって、演算子族の「スロット」のみを指定することに注意してください。スロットを占有しているオペレーターまたは関数の名前は言及されていません。また、 &lt;code&gt;DROP FUNCTION&lt;/code&gt; の場合、指定するタイプは、関数がサポートすることを目的とした入力データタイプです。 GiST、SP-GiST、およびGINインデックスの場合、これは関数の実際の入力引数タイプとは関係がない場合があります。</target>
        </trans-unit>
        <trans-unit id="051e5841933239126fb981b1dfd93c63aee12913" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;EXPLAIN&lt;/code&gt; output shows the &lt;code&gt;WHERE&lt;/code&gt; clause being applied as a &amp;ldquo;filter&amp;rdquo; condition attached to the Seq Scan plan node. This means that the plan node checks the condition for each row it scans, and outputs only the ones that pass the condition. The estimate of output rows has been reduced because of the &lt;code&gt;WHERE&lt;/code&gt; clause. However, the scan will still have to visit all 10000 rows, so the cost hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;, to be exact) to reflect the extra CPU time spent checking the &lt;code&gt;WHERE&lt;/code&gt; condition.</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 出力には、シーケンススキャンプランノードにアタッチされた「フィルター」条件として適用されている &lt;code&gt;WHERE&lt;/code&gt; 句が示されていることに注意してください。これは、計画ノードがスキャンする各行の条件をチェックし、条件に合格したもののみを出力することを意味します。 &lt;code&gt;WHERE&lt;/code&gt; 句のため、出力行の見積もりが削減されました。ただし、スキャンでは依然として10000行すべてにアクセスする必要があるため、コストは減少していません。実際、 &lt;code&gt;WHERE&lt;/code&gt; 条件のチェックに費やされた余分なCPU時間を反映するために、（正確には10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;によって）少し上がりました。</target>
        </trans-unit>
        <trans-unit id="d34da680054f05253f7563479166aab9f149ee00" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;WITH&lt;/code&gt; query was evaluated only once, so that we got two sets of the same three random values.</source>
          <target state="translated">ことに注意してください &lt;code&gt;WITH&lt;/code&gt; のクエリは、我々は同じ3つのランダムな値の二組を得たのでことを、一度だけ評価されました。</target>
        </trans-unit>
        <trans-unit id="51724582644bab73340aa6c622d37155c5257732" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;picksplit&lt;/code&gt; function's result is delivered by modifying the passed-in &lt;code&gt;v&lt;/code&gt; structure. The return value per se is ignored, though it's conventional to pass back the address of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;picksplit&lt;/code&gt; 関数の結果は、渡された &lt;code&gt;v&lt;/code&gt; 構造を変更することによって配信されることに注意してください。戻り値自体は無視されますが、 &lt;code&gt;v&lt;/code&gt; のアドレスを返すのが一般的です。</target>
        </trans-unit>
        <trans-unit id="bf156003e881a5db213ca4ff342d316a104a89cc" translate="yes" xml:space="preserve">
          <source>Notice that the above commands specify copying the &lt;code&gt;template0&lt;/code&gt; database. When copying any other database, the encoding and locale settings cannot be changed from those of the source database, because that might result in corrupt data. For more information see &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">上記のコマンドは、 &lt;code&gt;template0&lt;/code&gt; データベースのコピーを指定していることに注意してください。他のデータベースをコピーする場合、エンコードとロケールの設定をソースデータベースの設定から変更することはできません。データが破損する可能性があるためです。詳細については、&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;セクション22.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a8cdb89e02698866354e5dd11605d6eb9295c222" translate="yes" xml:space="preserve">
          <source>Notice that the array elements are ordinary SQL constants or expressions; for instance, string literals are single quoted, instead of double quoted as they would be in an array literal. The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;Section 4.2.12&lt;/a&gt;.</source>
          <target state="translated">配列要素は通常のSQL定数または式であることに注意してください。たとえば、文字列リテラルは配列リテラルのように二重引用符で囲まれるのではなく、単一引用符で囲まれます。 &lt;code&gt;ARRAY&lt;/code&gt; のコンストラクタの構文はで詳しく説明されている&lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;セクション4.2.12&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="66469b4e59f919ba275ed4a6fda1a4c5c23cd621" translate="yes" xml:space="preserve">
          <source>Notice that the individual subcommands do not end with semicolons.</source>
          <target state="translated">個々のサブコマンドはセミコロンで終わらないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3160def781e659e6cdc752185f9870b36c8a345f" translate="yes" xml:space="preserve">
          <source>Notice that the number of rows estimated to be returned from the bitmap index scan reflects only the condition used with the index; this is important since it affects the cost estimate for the subsequent heap fetches.</source>
          <target state="translated">ビットマップインデックススキャンから返されると推定される行数は、インデックスで使用された条件のみを反映していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="873a445a12a2fae4f43b1f16da917ba94ef395cb" translate="yes" xml:space="preserve">
          <source>Notice that the owner's implicit grant options are not marked in the access privileges display. A &lt;code&gt;*&lt;/code&gt; will appear only when grant options have been explicitly granted to someone.</source>
          <target state="translated">所有者の暗黙の付与オプションは、アクセス特権の表示でマークされていないことに注意してください。 &lt;code&gt;*&lt;/code&gt; は、グラントオプションが明示的に誰かに付与されている場合にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="bf407e6deb6991a0a95054bdc8f3340e9ff64b36" translate="yes" xml:space="preserve">
          <source>Notice that the period (&lt;code&gt;.&lt;/code&gt;) is not a metacharacter for &lt;code&gt;SIMILAR TO&lt;/code&gt;.</source>
          <target state="translated">ピリオド（ &lt;code&gt;.&lt;/code&gt; ）は &lt;code&gt;SIMILAR TO&lt;/code&gt; のメタ文字ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="74768806db56cf6b766037079dc057b3f23de85a" translate="yes" xml:space="preserve">
          <source>Notice that the primary key overlaps with the foreign keys in the last table.</source>
          <target state="translated">主キーが最後のテーブルの外部キーと重なっていることに注目してください。</target>
        </trans-unit>
        <trans-unit id="8e2f5e5785b45b8d6d5aee74a3bd7e8d7b7e0944" translate="yes" xml:space="preserve">
          <source>Notice that this example defines the &lt;code&gt;page_count&lt;/code&gt; result column as an integer. The function deals internally with string representations, so when you say you want an integer in the output, it will take the string representation of the XPath result and use PostgreSQL input functions to transform it into an integer (or whatever type the &lt;code&gt;AS&lt;/code&gt; clause requests). An error will result if it can't do this &amp;mdash; for example if the result is empty &amp;mdash; so you may wish to just stick to &lt;code&gt;text&lt;/code&gt; as the column type if you think your data has any problems.</source>
          <target state="translated">この例では、 &lt;code&gt;page_count&lt;/code&gt; 結果列を整数として定義していることに注意してください。関数は内部的に文字列表現を処理するため、出力に整数が必要な場合、XPath結果の文字列表現を取得し、PostgreSQL入力関数を使用して整数（または &lt;code&gt;AS&lt;/code&gt; 句が要求する任意の型）に変換します。 。これができない場合（結果が空の場合など）は、エラーが発生します。そのため、データに問題があると思われる場合は、列タイプとして &lt;code&gt;text&lt;/code&gt; のみを使用できます。</target>
        </trans-unit>
        <trans-unit id="8b9217ccd836ba1fba783902d277384da15bf50d" translate="yes" xml:space="preserve">
          <source>Notice that we showed &lt;code&gt;inner_cardinality&lt;/code&gt; as 10000, that is, the unmodified size of &lt;code&gt;tenk2&lt;/code&gt;. It might appear from inspection of the &lt;code&gt;EXPLAIN&lt;/code&gt; output that the estimate of join rows comes from 50 * 1, that is, the number of outer rows times the estimated number of rows obtained by each inner index scan on &lt;code&gt;tenk2&lt;/code&gt;. But this is not the case: the join relation size is estimated before any particular join plan has been considered. If everything is working well then the two ways of estimating the join size will produce about the same answer, but due to round-off error and other factors they sometimes diverge significantly.</source>
          <target state="translated">&lt;code&gt;inner_cardinality&lt;/code&gt; を10000、つまり変更されていない &lt;code&gt;tenk2&lt;/code&gt; のサイズとして示したことに注意してください。 &lt;code&gt;EXPLAIN&lt;/code&gt; 出力の検査から、結合行の推定は50 * 1、つまり、 &lt;code&gt;tenk2&lt;/code&gt; での各内部インデックススキャンによって取得された行の推定数に外部行の数を掛けたものであることがわかります。ただし、これは当てはまりません。特定の結合計画が検討される前に、結合関係のサイズが推定されます。すべてが適切に機能している場合、結合サイズを見積もる2つの方法でほぼ同じ答えが得られますが、丸め誤差やその他の要因により、大きく異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="159dfc60dcca0632285615def5fab2a023373a94" translate="yes" xml:space="preserve">
          <source>Notice that while the plain (unaggregated) log file shows which script was used for each transaction, the aggregated log does not. Therefore if you need per-script data, you need to aggregate the data on your own.</source>
          <target state="translated">プレーンな (集計されていない)ログファイルには、各トランザクションでどのスクリプトが使用されたかが示されていますが、集計されたログには示されていないことに注意してください。したがって、スクリプトごとのデータが必要な場合は、自分でデータを集約する必要があります。</target>
        </trans-unit>
        <trans-unit id="99369cd02fa72e17001071790856a797298fed53" translate="yes" xml:space="preserve">
          <source>Notice the typical form of recursive queries: an initial condition, followed by &lt;code&gt;UNION&lt;/code&gt;, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for more examples.)</source>
          <target state="translated">再帰クエリの一般的な形式に注意してください。初期条件の後に &lt;code&gt;UNION&lt;/code&gt; が続き、その後にクエリの再帰部分が続きます。クエリの再帰部分が最終的にタプルを返さないことを確認してください。そうしないと、クエリが無限にループします。（他の例については、&lt;a href=&quot;queries-with&quot;&gt;セクション7.8&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="085506905d3dc520376505271fd3c45af0c829eb" translate="yes" xml:space="preserve">
          <source>Notice we don't use &lt;code&gt;-C&lt;/code&gt;, and instead connect directly to the database to be restored into. Also note that we clone the new database from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, to ensure it is initially empty.</source>
          <target state="translated">&lt;code&gt;-C&lt;/code&gt; を使用しないことに注意してください。代わりに、復元先のデータベースに直接接続します。また、新しいデータベースを &lt;code&gt;template0&lt;/code&gt; ではなく &lt;code&gt;template1&lt;/code&gt; から複製し、データベースが最初は空であることを確認します。</target>
        </trans-unit>
        <trans-unit id="bb9bfefd5391f52be54267e2a938a126661b0ff7" translate="yes" xml:space="preserve">
          <source>Nov</source>
          <target state="translated">Nov</target>
        </trans-unit>
        <trans-unit id="3c5bf776f5efcaa22d6e0fd4839db7d2b83e52be" translate="yes" xml:space="preserve">
          <source>November</source>
          <target state="translated">November</target>
        </trans-unit>
        <trans-unit id="0ffcf97fe0b617e1a1fb0f97e1a88d84bed8f352" translate="yes" xml:space="preserve">
          <source>Now consider the same query, but with a constant that is not in the MCV list:</source>
          <target state="translated">同じクエリを、MCVリストにない定数で考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1101583b5cab5dfe73a02721963b60a84711fcd9" translate="yes" xml:space="preserve">
          <source>Now it is impossible to create orders with non-NULL &lt;code&gt;product_no&lt;/code&gt; entries that do not appear in the products table.</source>
          <target state="translated">現在、productsテーブルに表示されない、NULL以外の &lt;code&gt;product_no&lt;/code&gt; エントリを含む注文を作成することはできません。</target>
        </trans-unit>
        <trans-unit id="05189fbbab4b515fc19f955242b1b42d3dc53c9c" translate="yes" xml:space="preserve">
          <source>Now it is possible to bind the thesaurus dictionary &lt;code&gt;thesaurus_simple&lt;/code&gt; to the desired token types in a configuration, for example:</source>
          <target state="translated">これで、シソーラス・ディクショナリー &lt;code&gt;thesaurus_simple&lt;/code&gt; を構成内の必要なトークン・タイプにバインドできるようになりました。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="14b6efa33e8cde1d203d7549fcab8edf43d173c9" translate="yes" xml:space="preserve">
          <source>Now it is possible to create a foreign table with &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. In this example we wish to access the table named &lt;code&gt;some_schema.some_table&lt;/code&gt; on the remote server. The local name for it will be &lt;code&gt;foreign_table&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;を使用して外部テーブルを作成できるようになりました。この例では、リモートサーバー上の &lt;code&gt;some_schema.some_table&lt;/code&gt; という名前のテーブルにアクセスします。ローカル名は &lt;code&gt;foreign_table&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="dd96a87b36842da43e36de2200fdfc1838f0e684" translate="yes" xml:space="preserve">
          <source>Now let's add another condition to the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">次に、 &lt;code&gt;WHERE&lt;/code&gt; 句に別の条件を追加します。</target>
        </trans-unit>
        <trans-unit id="95432c22f405504df2d81a0fb2d4efc9ca2560c4" translate="yes" xml:space="preserve">
          <source>Now let's consider a case with more than one condition in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">次に、 &lt;code&gt;WHERE&lt;/code&gt; 句に複数の条件があるケースを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="f0a0a72cb219eba72676d0750f57b70ee142cf22" translate="yes" xml:space="preserve">
          <source>Now let's modify the query to add a &lt;code&gt;WHERE&lt;/code&gt; condition:</source>
          <target state="translated">次に、クエリを変更して &lt;code&gt;WHERE&lt;/code&gt; 条件を追加します。</target>
        </trans-unit>
        <trans-unit id="47c1122f650e2dbfda8bc7f189317df3657e8635" translate="yes" xml:space="preserve">
          <source>Now look at the table definition again:</source>
          <target state="translated">では、もう一度テーブルの定義を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d6a6836d17a53567c7bdd65d95a74e120c1311f5" translate="yes" xml:space="preserve">
          <source>Now suppose that &lt;code&gt;alice&lt;/code&gt; wishes to change the &amp;ldquo;slightly secret&amp;rdquo; information, but decides that &lt;code&gt;mallory&lt;/code&gt; should not be trusted with the new content of that row, so she does:</source>
          <target state="translated">ここで、 &lt;code&gt;alice&lt;/code&gt; が「わずかに秘密の」情報を変更したいが、 &lt;code&gt;mallory&lt;/code&gt; がその行の新しいコンテンツで信頼されるべきではないと決定したと仮定します。</target>
        </trans-unit>
        <trans-unit id="9c4ea909bc20a14cf1d5201600f80228a4642b36" translate="yes" xml:space="preserve">
          <source>Now the parenthesized object is correctly interpreted as a reference to the &lt;code&gt;item&lt;/code&gt; column, and then the subfield can be selected from it.</source>
          <target state="translated">これで、括弧で囲まれたオブジェクトが &lt;code&gt;item&lt;/code&gt; 列への参照として正しく解釈され、サブフィールドをそこから選択できるようになりました。</target>
        </trans-unit>
        <trans-unit id="deae757ce21f92bbc32823a914fbc837ca56a164" translate="yes" xml:space="preserve">
          <source>Now this is fine for PostgreSQL-specific applications, but standard code using JDBC or ODBC won't delete the objects, resulting in orphan objects &amp;mdash; objects that are not referenced by anything, and simply occupy disk space.</source>
          <target state="translated">現在、これはPostgreSQL固有のアプリケーションでは問題ありませんが、JDBCまたはODBCを使用する標準コードはオブジェクトを削除しないため、孤立したオブジェクト（何からも参照されていないオブジェクト）になり、ディスク領域を占有するだけです。</target>
        </trans-unit>
        <trans-unit id="084bd00ac798eb5161b956e1962a53497a37531c" translate="yes" xml:space="preserve">
          <source>Now try inserting an invalid record:</source>
          <target state="translated">次に、無効なレコードを挿入してみてください。</target>
        </trans-unit>
        <trans-unit id="5458bef284659cf16721d439d4b767332bf554fc" translate="yes" xml:space="preserve">
          <source>Now we are ready to perform a fast full text search:</source>
          <target state="translated">これで、高速な全文検索を実行する準備が整いました。</target>
        </trans-unit>
        <trans-unit id="a02f5ffaa75cbfc6c6328ab3a75ec757069f839c" translate="yes" xml:space="preserve">
          <source>Now we can see how it works. &lt;code&gt;ts_lexize&lt;/code&gt; is not very useful for testing a thesaurus, because it treats its input as a single token. Instead we can use &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;to_tsvector&lt;/code&gt; which will break their input strings into multiple tokens:</source>
          <target state="translated">これでどのように機能するかがわかります。 &lt;code&gt;ts_lexize&lt;/code&gt; は入力を単一のトークンとして扱うため、シソーラスのテストにはあまり役立ちません。代わりに、 &lt;code&gt;plainto_tsquery&lt;/code&gt; と &lt;code&gt;to_tsvector&lt;/code&gt; を使用して、入力文字列を複数のトークンに分割できます。</target>
        </trans-unit>
        <trans-unit id="18b6223b0641dfa27780508785b1cab41976292c" translate="yes" xml:space="preserve">
          <source>Now we can set up the mappings for words in configuration &lt;code&gt;pg&lt;/code&gt;:</source>
          <target state="translated">これで、構成 &lt;code&gt;pg&lt;/code&gt; で単語のマッピングを設定できます。</target>
        </trans-unit>
        <trans-unit id="b4d3c996fedace29e66a9cecc69860990e5567d4" translate="yes" xml:space="preserve">
          <source>Now we can show some &lt;code&gt;INSERT&lt;/code&gt; statements:</source>
          <target state="translated">これで、いくつかの &lt;code&gt;INSERT&lt;/code&gt; ステートメントを表示できます。</target>
        </trans-unit>
        <trans-unit id="9811d50e24107f487d484ef3d4f8590f2676cba5" translate="yes" xml:space="preserve">
          <source>Now we can test our configuration:</source>
          <target state="translated">これで設定をテストすることができます。</target>
        </trans-unit>
        <trans-unit id="ace10f4ace4cfabef3a16f550a37af5ffc6dcce7" translate="yes" xml:space="preserve">
          <source>Now we can test our dictionary:</source>
          <target state="translated">これで辞書のテストができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f27c4f52d858064037f2d98b4e6143af1fdd5e4c" translate="yes" xml:space="preserve">
          <source>Now we change the prompt to something more interesting:</source>
          <target state="translated">では、プロンプトをもっと面白いものに変えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d4a301c61d4f0a929427d7399e79093ab65b2312" translate="yes" xml:space="preserve">
          <source>Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the &lt;code&gt;weather&lt;/code&gt; table and for each row to find the matching &lt;code&gt;cities&lt;/code&gt; row(s). If no matching row is found we want some &amp;ldquo;empty values&amp;rdquo; to be substituted for the &lt;code&gt;cities&lt;/code&gt; table's columns. This kind of query is called an &lt;em&gt;outer join&lt;/em&gt;. (The joins we have seen so far are inner joins.) The command looks like this:</source>
          <target state="translated">次に、ヘイワードのレコードを取得する方法を理解します。クエリで実行するのは、 &lt;code&gt;weather&lt;/code&gt; 表をスキャンし、各行で一致する &lt;code&gt;cities&lt;/code&gt; 行を見つけることです。一致する行が見つからない場合は、いくつかの「空の値」を &lt;code&gt;cities&lt;/code&gt; テーブルの列の代わりに使用します。この種類のクエリは、&lt;em&gt;外部結合&lt;/em&gt;と呼ばれます。（これまでに見てきた結合は内部結合です。）コマンドは次のようになります。</target>
        </trans-unit>
        <trans-unit id="7ce7fd7c4c102dd293619badd0d980d7f605bb16" translate="yes" xml:space="preserve">
          <source>Now you are ready to create the foreign data table. Using the &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; command, you will need to define the columns for the table, the CSV file name, and its format:</source>
          <target state="translated">これで、外部データテーブルを作成する準備ができました。 &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; コマンドを使用して、テーブルの列、CSVファイル名、およびそのフォーマットを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="64a8dd2545b6bf024381f0d92feccb523f90f566" translate="yes" xml:space="preserve">
          <source>Now you need only &lt;code&gt;SELECT&lt;/code&gt; from a foreign table to access the data stored in its underlying remote table. You can also modify the remote table using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. (Of course, the remote user you have specified in your user mapping must have privileges to do these things.)</source>
          <target state="translated">これで、基になるリモートテーブルに格納されているデータにアクセスするには、外部テーブルから &lt;code&gt;SELECT&lt;/code&gt; するだけで済みます。 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; を使用してリモートテーブルを変更することもできます。（もちろん、ユーザーマッピングで指定したリモートユーザーには、これらのことを実行するための特権が必要です。）</target>
        </trans-unit>
        <trans-unit id="08d3e6ece6ec2bb9a41472c3b51de60739aa48a4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;SELECT&lt;/code&gt; query similar to the previous example can be used to suggest spellings for misspelled words in user search terms. A useful extra test is to require that the selected words are also of similar length to the misspelled word.</source>
          <target state="translated">これで、前の例と同様の &lt;code&gt;SELECT&lt;/code&gt; クエリを使用して、ユーザーの検索語のスペルが間違っている単語のスペルを提案できます。有用な追加のテストは、選択した単語もスペルミスのある単語と同じ長さであることを要求することです。</target>
        </trans-unit>
        <trans-unit id="eb91f362c7c32cf6e84b89572465a581c06ab515" translate="yes" xml:space="preserve">
          <source>Now, let's make the condition more restrictive:</source>
          <target state="translated">では、もっと条件を厳しくしてみましょう。</target>
        </trans-unit>
        <trans-unit id="fb9ab76d936c6c858686ae054f0811c70819eab5" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; will be recognized as an application of the indexable operator &lt;code&gt;?&lt;/code&gt; to the indexed expression &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt;. (More information on expression indexes can be found in &lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;.)</source>
          <target state="translated">さて、 &lt;code&gt;WHERE&lt;/code&gt; 句 &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; は、インデックス付け可能な演算子のアプリケーションとして認識されます &lt;code&gt;?&lt;/code&gt; インデックス付き式 &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt; 。 （式インデックスの詳細については、&lt;a href=&quot;indexes-expressional&quot;&gt;セクション11.7を参照してください&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9343983b435f96d35ab006d0ce2a792fa81e36a3" translate="yes" xml:space="preserve">
          <source>Now, the catalogs also provide a cast from &lt;code&gt;numeric&lt;/code&gt; to &lt;code&gt;integer&lt;/code&gt;. If that cast were marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which it is not &amp;mdash; then the parser would be faced with choosing between the above interpretation and the alternative of casting the &lt;code&gt;numeric&lt;/code&gt; constant to &lt;code&gt;integer&lt;/code&gt; and applying the &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; operator. Lacking any knowledge of which choice to prefer, it would give up and declare the query ambiguous. The fact that only one of the two casts is implicit is the way in which we teach the parser to prefer resolution of a mixed &lt;code&gt;numeric&lt;/code&gt;-and-&lt;code&gt;integer&lt;/code&gt; expression as &lt;code&gt;numeric&lt;/code&gt;; there is no built-in knowledge about that.</source>
          <target state="translated">現在、カタログは &lt;code&gt;numeric&lt;/code&gt; から &lt;code&gt;integer&lt;/code&gt; へのキャストも提供しています。そのキャストが &lt;code&gt;AS IMPLICIT&lt;/code&gt; とマークされている場合（そうでない場合）、パーサーは上記の解釈と、 &lt;code&gt;numeric&lt;/code&gt; 定数を &lt;code&gt;integer&lt;/code&gt; にキャストし、 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; 演算子を適用するという選択肢のどちらかを選択する必要があります。どちらを選択するかについての知識がないと、あきらめ、クエリがあいまいであることを宣言します。2人のキャストの一方のみが暗黙的であるという事実は、我々が混合の解像度好むようにパーサを教えている方法である &lt;code&gt;numeric&lt;/code&gt; -と- &lt;code&gt;integer&lt;/code&gt; として表現 &lt;code&gt;numeric&lt;/code&gt; ; それに関する組み込みの知識はありません。</target>
        </trans-unit>
        <trans-unit id="7e07cf090027f130a2dc1fbc4d060d70553c3b5f" translate="yes" xml:space="preserve">
          <source>Now, the main problem with the btree search is that btree is inefficient when the search conditions do not constrain the leading index column(s). A better strategy for btree is to create a separate index on each column. Then the planner will choose something like this:</source>
          <target state="translated">さて、btree検索の主な問題は、検索条件が先頭のインデックス列に制約を与えない場合、btreeは非効率的であるということです。btreeのより良い戦略は、各列に別のインデックスを作成することです。そうすると、プランナーは以下のようなものを選択します。</target>
        </trans-unit>
        <trans-unit id="8cf5b756d6afa6277b947e17d815b23a45e8f0cf" translate="yes" xml:space="preserve">
          <source>Now, this methodology can be cumbersome with a very large number of entries in the &lt;code&gt;one_to_many&lt;/code&gt; table. Often, a join like this would result in an index scan and a fetch for each right hand entry in the table for a particular left hand entry. If you have a very dynamic system, there is not much you can do. However, if you have some data which is fairly static, you can create a summary table with the aggregator.</source>
          <target state="translated">現在、この方法は、 &lt;code&gt;one_to_many&lt;/code&gt; テーブルに非常に多くのエントリがあるため、扱いにくい場合があります。多くの場合、このような結合では、特定の左側のエントリについて、テーブル内の右側のエントリごとにインデックススキャンとフェッチが行われます。非常に動的なシステムを使用している場合、できることは多くありません。ただし、かなり静的なデータがある場合は、アグリゲーターを使用してサマリー表を作成できます。</target>
        </trans-unit>
        <trans-unit id="333cddf155e5f6b845810ca1b1ec9493a847d199" translate="yes" xml:space="preserve">
          <source>Now, we can run some queries on the table. First, we show how to access a single element of an array. This query retrieves the names of the employees whose pay changed in the second quarter:</source>
          <target state="translated">さて、テーブルに対していくつかのクエリを実行してみましょう。まず、配列の1つの要素にアクセスする方法を示します。このクエリは、第2四半期に給与が変更された従業員の名前を取得します。</target>
        </trans-unit>
        <trans-unit id="e60c418bd02619354d423e5f131c6effce59534d" translate="yes" xml:space="preserve">
          <source>Now, we have a table &lt;code&gt;test&lt;/code&gt; populated with data describing the hierarchy shown below:</source>
          <target state="translated">これで、以下に示す階層を説明するデータが入力されたテーブル &lt;code&gt;test&lt;/code&gt; が作成されました。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="abc801eb7aa113d4d373983685ad8e4b411d4462" translate="yes" xml:space="preserve">
          <source>Null values are represented by &lt;code&gt;_null_&lt;/code&gt;. (Note that there is no way to create a value that is just that string.)</source>
          <target state="translated">null値は &lt;code&gt;_null_&lt;/code&gt; で表されます。（その文字列だけの値を作成する方法はないことに注意してください。）</target>
        </trans-unit>
        <trans-unit id="71197a0f68656e301e5e80254d15a53eb1f65444" translate="yes" xml:space="preserve">
          <source>Nullness tests</source>
          <target state="translated">ヌルテスト</target>
        </trans-unit>
        <trans-unit id="bf00f0e98d92759b2ab900b85062ac054ac00545" translate="yes" xml:space="preserve">
          <source>Number of &amp;ldquo;internal&amp;rdquo; (upper-level) pages</source>
          <target state="translated">「内部」（上位）ページの数</target>
        </trans-unit>
        <trans-unit id="766db6ffc20af3c98e8a0c222cc91dcfc261ce82" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;CHECK&lt;/code&gt; constraints on the table; see &lt;a href=&quot;catalog-pg-constraint&quot;&gt;&lt;code&gt;pg_constraint&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">テーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約の数。&lt;a href=&quot;catalog-pg-constraint&quot;&gt; &lt;code&gt;pg_constraint&lt;/code&gt; &lt;/a&gt;カタログを参照してください</target>
        </trans-unit>
        <trans-unit id="f562c8ed4194c0f5d892247c878f35e3b1adf69e" translate="yes" xml:space="preserve">
          <source>Number of WAL files that have been successfully archived</source>
          <target state="translated">正常にアーカイブされたWALファイルの数</target>
        </trans-unit>
        <trans-unit id="c384981df593e79281c2a20754104f1934f6c9b7" translate="yes" xml:space="preserve">
          <source>Number of argument strings passed to trigger function</source>
          <target state="translated">トリガー関数に渡される引数文字列の数</target>
        </trans-unit>
        <trans-unit id="686b06e76d78fdcab0c83dfec56d5de3d95d6021" translate="yes" xml:space="preserve">
          <source>Number of arguments that have defaults</source>
          <target state="translated">デフォルトを持つ引数の数</target>
        </trans-unit>
        <trans-unit id="ad8f1d6b3919325e33519443b298eab45ab86017" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">このデータベースに現在接続されているバックエンドの数。共有オブジェクトの場合は &lt;code&gt;NULL&lt;/code&gt; 。これは、現在の状態を反映する値を返すこのビューの唯一の列です。他のすべての列は、最後のリセット以降の累積値を返します。</target>
        </trans-unit>
        <trans-unit id="646ba2279db42aaed6dee8b8ba74083e8ded4a4e" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">現在このデータベースに接続されているバックエンドの数、または共有オブジェクトの場合は &lt;code&gt;NULL&lt;/code&gt; 。これは、現在の状態を反映する値を返すこのビューの唯一の列です。他のすべての列は、最後のリセット以降の累積値を返します。</target>
        </trans-unit>
        <trans-unit id="055e292dc7e47521853b27a0e59b3a6f4ac3517d" translate="yes" xml:space="preserve">
          <source>Number of backends pinning this buffer</source>
          <target state="translated">このバッファを固定するバックエンドの数</target>
        </trans-unit>
        <trans-unit id="7fc2a68fbd98db7f2b41bb2e743259772026c43c" translate="yes" xml:space="preserve">
          <source>Number of bitmap pages</source>
          <target state="translated">ビットマップページ数</target>
        </trans-unit>
        <trans-unit id="7826db063f5934f4aaa44397cffd4f35886a95d2" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">各インデックス列に対して生成されたビット数。各パラメーターの名前は、それが制御するインデックス列の番号を参照します。デフォルトは &lt;code&gt;2&lt;/code&gt; ビットで、最大は &lt;code&gt;4095&lt;/code&gt; です。実際に使用されていないインデックス列のパラメーターは無視されます。</target>
        </trans-unit>
        <trans-unit id="33909c2a9901d0948fd89312acfb6d3e292b76cf" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and the maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">各インデックス列に対して生成されたビット数。各パラメーターの名前は、パラメーターが制御する索引列の番号を参照します。デフォルトは &lt;code&gt;2&lt;/code&gt; ビットで、最大は &lt;code&gt;4095&lt;/code&gt; です。実際に使用されていないインデックス列のパラメータは無視されます。</target>
        </trans-unit>
        <trans-unit id="1a6ee47813de9741b16e5983ad54532485c3f7d8" translate="yes" xml:space="preserve">
          <source>Number of bits in string</source>
          <target state="translated">文字列のビット数</target>
        </trans-unit>
        <trans-unit id="1efe22f20b8b3239aa455f2b88a22e48c7032a46" translate="yes" xml:space="preserve">
          <source>Number of bits in the encryption algorithm used, or NULL if SSL is not used on this connection</source>
          <target state="translated">使用される暗号化アルゴリズムのビット数、またはこの接続でSSLが使用されていない場合はNULL</target>
        </trans-unit>
        <trans-unit id="0aaa9d047e0edd588ca0e7b28edd0b562bba9543" translate="yes" xml:space="preserve">
          <source>Number of blocks already processed in the current phase.</source>
          <target state="translated">現在のフェーズですでに処理されているブロックの数。</target>
        </trans-unit>
        <trans-unit id="1c4fa9ae3322de072b98477062cf3a411db62a9c" translate="yes" xml:space="preserve">
          <source>Number of blocks checked for existence for this SLRU</source>
          <target state="translated">この SLRU の存在を確認したブロック数</target>
        </trans-unit>
        <trans-unit id="e601295de63e2a2c268076613ec412bef9974925" translate="yes" xml:space="preserve">
          <source>Number of blocks zeroed during initializations</source>
          <target state="translated">初期化時にゼロになったブロックの数</target>
        </trans-unit>
        <trans-unit id="00533abb6601d842f496de1f71453437a6ebdea3" translate="yes" xml:space="preserve">
          <source>Number of bucket pages</source>
          <target state="translated">バケットページ数</target>
        </trans-unit>
        <trans-unit id="5f0a807486a5a6ed87ce1d425faa9e67bccd0b96" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in all indexes on this table</source>
          <target state="translated">このテーブルの全インデックスのバッファヒット数</target>
        </trans-unit>
        <trans-unit id="e19591b7755dbe90f2648065af697ccee73ba936" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this index</source>
          <target state="translated">このインデックスのバッファヒット数</target>
        </trans-unit>
        <trans-unit id="7bc9f9ddcb6814f42c1dfcc0f6c3a5f06c83a41c" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this sequence</source>
          <target state="translated">このシーケンスのバッファヒット数</target>
        </trans-unit>
        <trans-unit id="1b92c223ff9c814c48eef462cd5d9e3733ab3a60" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table</source>
          <target state="translated">このテーブルのバッファヒット数</target>
        </trans-unit>
        <trans-unit id="fb5ce149dfa5df345dadf32e3e7609e73a91ab4d" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table (if any)</source>
          <target state="translated">このテーブルのTOASTテーブルのバッファヒット数(ある場合)</target>
        </trans-unit>
        <trans-unit id="23b7daeca394ace2c29173c2e4db7f60e4ffa150" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table indexes (if any)</source>
          <target state="translated">このテーブルのTOASTテーブルインデックスのバッファヒット数(ある場合)</target>
        </trans-unit>
        <trans-unit id="820cb42f301c46e1dfd210dd8b99d341db358b4e" translate="yes" xml:space="preserve">
          <source>Number of buffers allocated</source>
          <target state="translated">割り当てられたバッファの数</target>
        </trans-unit>
        <trans-unit id="9d5ff89dcfa3fb4035bf4d286f1b89c75201025e" translate="yes" xml:space="preserve">
          <source>Number of buffers written by the background writer</source>
          <target state="translated">バックグラウンドライターが書き込んだバッファの数</target>
        </trans-unit>
        <trans-unit id="0754f03bfbfe66ccdcb625fa7e3f44aa2c2a10bf" translate="yes" xml:space="preserve">
          <source>Number of buffers written directly by a backend</source>
          <target state="translated">バックエンドから直接書き込まれるバッファの数</target>
        </trans-unit>
        <trans-unit id="5c0d5f7ac01275f2192348fde149f7bc358fa9b2" translate="yes" xml:space="preserve">
          <source>Number of buffers written during checkpoints</source>
          <target state="translated">チェックポイント中に書き込まれたバッファの数</target>
        </trans-unit>
        <trans-unit id="07fff57f12d731d3ce6021e11cbee81eeb3c2283" translate="yes" xml:space="preserve">
          <source>Number of bytes in binary string</source>
          <target state="translated">バイナリ文字列のバイト数</target>
        </trans-unit>
        <trans-unit id="776e4abf0d400377907ab4118caf858bc018038c" translate="yes" xml:space="preserve">
          <source>Number of bytes in string</source>
          <target state="translated">文字列のバイト数</target>
        </trans-unit>
        <trans-unit id="0c72d2a102dbeffb7f10cf64774275780bc212cb" translate="yes" xml:space="preserve">
          <source>Number of bytes used to store a particular value (possibly compressed)</source>
          <target state="translated">特定の値を格納するために使用されるバイト数 (圧縮されている可能性があります)</target>
        </trans-unit>
        <trans-unit id="c08b0fa84d37e1078db655b5ae7decd119da648e" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;の文字数&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd2d8b2ef7ef37c5c432bb5b54f4a96fe58d0820" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; in the given &lt;em&gt;&lt;code&gt;encoding&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; must be valid in this encoding.</source>
          <target state="translated">指定された&lt;em&gt; &lt;code&gt;encoding&lt;/code&gt; &lt;/em&gt;&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;の文字数。&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;このエンコーディングで有効である必要があります。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21fa6ae67d156ef97e3bcf08c970e730cf5312e3" translate="yes" xml:space="preserve">
          <source>Number of characters in string</source>
          <target state="translated">文字列の文字数</target>
        </trans-unit>
        <trans-unit id="757246d7eeb8dba1a7138e1dc8e8018c67750493" translate="yes" xml:space="preserve">
          <source>Number of child tables scanned. This counter only advances when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="translated">スキャンされた子テーブルの数。このカウンターは、フェーズが &lt;code&gt;acquiring inherited sample rows&lt;/code&gt; ときにのみ進みます。</target>
        </trans-unit>
        <trans-unit id="8bd1fcff19995e8c8816753d9ab90a523509512c" translate="yes" xml:space="preserve">
          <source>Number of child tables.</source>
          <target state="translated">子テーブルの数。</target>
        </trans-unit>
        <trans-unit id="b6c03f4ded52583235611efb49840aea96640208" translate="yes" xml:space="preserve">
          <source>Number of clients simulated, that is, number of concurrent database sessions. Default is 1.</source>
          <target state="translated">シミュレートされるクライアントの数、つまり、同時に実行されるデータベースセッションの数。既定値は1です。</target>
        </trans-unit>
        <trans-unit id="85c5091c823d8842dadc7ece08cd606b9ead02d8" translate="yes" xml:space="preserve">
          <source>Number of completed index vacuum cycles.</source>
          <target state="translated">完了したインデックス真空サイクルの数。</target>
        </trans-unit>
        <trans-unit id="07c0251b99d852d386e6230c7bc68b422860b2c8" translate="yes" xml:space="preserve">
          <source>Number of data page checksum failures detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">このデータベース(または共有オブジェクト)で検出されたデータ・ページ・チェックサムの失敗の数、またはデータ・チェックサムが有効になっていない場合はNULL。</target>
        </trans-unit>
        <trans-unit id="fd10e6b6630a5e0b1a1e37d857ce93abbe92b80c" translate="yes" xml:space="preserve">
          <source>Number of dead tuples</source>
          <target state="translated">死んだタプルの数</target>
        </trans-unit>
        <trans-unit id="afdac9c7f2737a1b2507732298381e07eead13a4" translate="yes" xml:space="preserve">
          <source>Number of dead tuples (exact)</source>
          <target state="translated">デッドタプルの数(正確</target>
        </trans-unit>
        <trans-unit id="02be773fcf618322b70d57bc8dd9f3bf3919a6ff" translate="yes" xml:space="preserve">
          <source>Number of dead tuples collected since the last index vacuum cycle.</source>
          <target state="translated">最後のインデックス真空サイクル以降に収集されたデッドタプルの数。</target>
        </trans-unit>
        <trans-unit id="dfb451e3ffa3210bb1e566dd30fd90934219a10e" translate="yes" xml:space="preserve">
          <source>Number of dead tuples that we can store before needing to perform an index vacuum cycle, based on &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;に基づいて、インデックスのバキュームサイクルを実行する必要がある前に保存できるデッドタプルの数。</target>
        </trans-unit>
        <trans-unit id="c4921acfb7b89b906d587e207c982d99387b078d" translate="yes" xml:space="preserve">
          <source>Number of deadlocks detected in this database</source>
          <target state="translated">このデータベースで検出されたデッドロックの数</target>
        </trans-unit>
        <trans-unit id="7cb4a85ff41caf8fe6b956d1175a54bab38b2930" translate="yes" xml:space="preserve">
          <source>Number of deleted pages</source>
          <target state="translated">削除されたページ数</target>
        </trans-unit>
        <trans-unit id="c3223e4de0ae9c43ca827d1664c98d5d300c8a06" translate="yes" xml:space="preserve">
          <source>Number of dimensions, if the column is an array type; otherwise 0. (Presently, the number of dimensions of an array is not enforced, so any nonzero value effectively means &amp;ldquo;it's an array&amp;rdquo;.)</source>
          <target state="translated">列が配列型の場合、次元数。それ以外の場合は0。（現在、配列の次元数は強制されないため、ゼロ以外の値は事実上「配列であること」を意味します。）</target>
        </trans-unit>
        <trans-unit id="2be05a9b990f09033b8618eab5d65ae1aecc4032" translate="yes" xml:space="preserve">
          <source>Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to &lt;code&gt;pronargs&lt;/code&gt;, the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates.</source>
          <target state="translated">順序付き集合または仮説集合の直接（非集合）引数の数。可変個配列を1つの引数として数えます。 &lt;code&gt;pronargs&lt;/code&gt; と等しい場合、集計は可変個でなければならず、可変個配列は集計された引数と最終的な直接引数を記述します。通常の集計では常にゼロです。</target>
        </trans-unit>
        <trans-unit id="7aaf798c193e9c02ed1872cdc3758501e3edd2e9" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read for this SLRU</source>
          <target state="translated">この SLRU で読み込んだディスクブロック数</target>
        </trans-unit>
        <trans-unit id="32e023d3421063e999e37bd8a8607f9d3b37c25b" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from all indexes on this table</source>
          <target state="translated">このテーブルのすべてのインデックスから読み込まれたディスクブロックの数</target>
        </trans-unit>
        <trans-unit id="5d872dc4357e4133d7ccee125da5dd9ed6f1e23f" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this index</source>
          <target state="translated">このインデックスから読み込まれたディスクブロックの数</target>
        </trans-unit>
        <trans-unit id="f152a31061ce6ad3788ac1d44859392030a5e387" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this sequence</source>
          <target state="translated">このシーケンスから読み込まれたディスクブロックの数</target>
        </trans-unit>
        <trans-unit id="5d8a5f136039b36181bc2310abac4c580db63dc6" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table</source>
          <target state="translated">このテーブルから読み込まれたディスクブロックの数</target>
        </trans-unit>
        <trans-unit id="0eec262fa83f105ce7c719197839961c454478bd" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table (if any)</source>
          <target state="translated">このテーブルのTOASTテーブルから読み込まれたディスクブロックの数(ある場合)</target>
        </trans-unit>
        <trans-unit id="c3595c16a4db90858d963b19c02306856a40fc17" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table indexes (if any)</source>
          <target state="translated">このテーブルのTOASTテーブルインデックスから読み込まれたディスクブロックの数(ある場合</target>
        </trans-unit>
        <trans-unit id="afcfec9d8002c45f94146f16eeb8704ff31575b1" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read in this database</source>
          <target state="translated">このデータベースで読み込まれたディスクブロックの数</target>
        </trans-unit>
        <trans-unit id="900fa7cb003c1be6f273043153c16b1f15b30466" translate="yes" xml:space="preserve">
          <source>Number of disk blocks written for this SLRU</source>
          <target state="translated">この SLRU に書き込まれたディスクブロック数</target>
        </trans-unit>
        <trans-unit id="da37950fc1304c1760a3162855b0cc7eba9abaaf" translate="yes" xml:space="preserve">
          <source>Number of empty pages</source>
          <target state="translated">空ページ数</target>
        </trans-unit>
        <trans-unit id="1eef621006cc03444cdc3f17923c510b432b6ba9" translate="yes" xml:space="preserve">
          <source>Number of entries in semaphore map</source>
          <target state="translated">セマフォマップのエントリ数</target>
        </trans-unit>
        <trans-unit id="477ceecd337608949a72430b5748c93213cf67af" translate="yes" xml:space="preserve">
          <source>Number of extended statistics computed. This counter only advances when the phase is &lt;code&gt;computing extended statistics&lt;/code&gt;.</source>
          <target state="translated">計算された拡張統計の数。このカウンターは、フェーズが &lt;code&gt;computing extended statistics&lt;/code&gt; ときにのみ進みます。</target>
        </trans-unit>
        <trans-unit id="50fbf334710b4f84f1b18744b65687758f7ff55b" translate="yes" xml:space="preserve">
          <source>Number of extended statistics.</source>
          <target state="translated">拡張統計の数。</target>
        </trans-unit>
        <trans-unit id="8ad03f1cded443f2951e34811d9b174dcd53e9f1" translate="yes" xml:space="preserve">
          <source>Number of failed attempts for archiving WAL files</source>
          <target state="translated">WAL ファイルのアーカイブに失敗した試行回数</target>
        </trans-unit>
        <trans-unit id="83240d945e31782e131edbfaf89add567bc6e877" translate="yes" xml:space="preserve">
          <source>Number of flushes of dirty data for this SLRU</source>
          <target state="translated">この SLRU のダーティデータのフラッシュ回数</target>
        </trans-unit>
        <trans-unit id="909efe526c9ef59f71379f7b5459201d6e2057fb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned.</source>
          <target state="translated">スキャンしたヒープブロックの数。</target>
        </trans-unit>
        <trans-unit id="db7d7d8e8c6ad921ea1f650987683cdca25be133" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. Because the &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; is used to optimize scans, some blocks will be skipped without inspection; skipped blocks are included in this total, so that this number will eventually become equal to &lt;code&gt;heap_blks_total&lt;/code&gt; when the vacuum is complete. This counter only advances when the phase is &lt;code&gt;scanning heap&lt;/code&gt;.</source>
          <target state="translated">スキャンされたヒープブロックの数。ので、&lt;a href=&quot;storage-vm&quot;&gt;視認性マップが&lt;/a&gt;最適化スキャンに使用される、いくつかのブロックは、検査せずにスキップされます。スキップされたブロックはこの合計に含まれるため、バキュームが完了すると、この数は最終的に &lt;code&gt;heap_blks_total&lt;/code&gt; と等しくなります。このカウンタは、フェーズが &lt;code&gt;scanning heap&lt;/code&gt; ときにのみ進みます。</target>
        </trans-unit>
        <trans-unit id="8abfe62e8394a6c74c6d4a5a932d175e4675308e" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">スキャンされたヒープブロックの数。このカウンタは、フェーズが &lt;code&gt;seq scanning heap&lt;/code&gt; 場合にのみ進みます。</target>
        </trans-unit>
        <trans-unit id="e3cc4495fb3d4a190394bf457f27a153df853feb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks vacuumed. Unless the table has no indexes, this counter only advances when the phase is &lt;code&gt;vacuuming heap&lt;/code&gt;. Blocks that contain no dead tuples are skipped, so the counter may sometimes skip forward in large increments.</source>
          <target state="translated">バキュームされたヒープブロックの数。テーブルにインデックスがない場合を除き、このカウンターは、フェーズが &lt;code&gt;vacuuming heap&lt;/code&gt; ときにのみ進みます。無効なタプルを含まないブロックはスキップされるため、カウンターが大きく増分してスキップする場合があります。</target>
        </trans-unit>
        <trans-unit id="f7065ea221f976c9edbd673b5b220f7e3c796ada" translate="yes" xml:space="preserve">
          <source>Number of heap tuples scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">スキャンされたヒープタプルの数。このカウンタは、フェーズが &lt;code&gt;seq scanning heap&lt;/code&gt; 、 &lt;code&gt;index scanning heap&lt;/code&gt; または &lt;code&gt;writing new heap&lt;/code&gt; 場合にのみ進みます。</target>
        </trans-unit>
        <trans-unit id="1608d82e7902ccc755c873e18179b75db06e972e" translate="yes" xml:space="preserve">
          <source>Number of heap tuples written. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">書き込まれたヒープタプルの数。このカウンタは、フェーズが &lt;code&gt;seq scanning heap&lt;/code&gt; 、 &lt;code&gt;index scanning heap&lt;/code&gt; または &lt;code&gt;writing new heap&lt;/code&gt; 場合にのみ進みます。</target>
        </trans-unit>
        <trans-unit id="b8a4f5e567445d068c8e050292c1c88bc19074f5" translate="yes" xml:space="preserve">
          <source>Number of index entries returned by scans on this index</source>
          <target state="translated">このインデックスのスキャンによって返されたインデックスエントリの数</target>
        </trans-unit>
        <trans-unit id="2e47feab593e8d7f11f91aca87244c1647d56eda" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this index</source>
          <target state="translated">このインデックスで開始されたインデックススキャンの数</target>
        </trans-unit>
        <trans-unit id="9740aebc5f5b78757843f388b08b6acf15d45722" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this table</source>
          <target state="translated">このテーブルで開始されたインデックススキャンの数</target>
        </trans-unit>
        <trans-unit id="2512b3dbef65d5a2946445bd9f10f953be318af1" translate="yes" xml:space="preserve">
          <source>Number of indexes rebuilt. This counter only advances when the phase is &lt;code&gt;rebuilding index&lt;/code&gt;.</source>
          <target state="translated">再構築されたインデックスの数。このカウンタは、フェーズが &lt;code&gt;rebuilding index&lt;/code&gt; ときにのみ進みます。</target>
        </trans-unit>
        <trans-unit id="c472386046a97dee2b6524340bae3b671c82f90b" translate="yes" xml:space="preserve">
          <source>Number of input arguments</source>
          <target state="translated">入力引数の数</target>
        </trans-unit>
        <trans-unit id="2f8814269318ff6e97c5ce39779e7a57b9de7c2a" translate="yes" xml:space="preserve">
          <source>Number of leaf pages</source>
          <target state="translated">葉のページ数</target>
        </trans-unit>
        <trans-unit id="09d24d58ee5f9d720e6e82ed3d6f447d63a9f297" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by index scans</source>
          <target state="translated">インデックススキャンで取得したライブ行の数</target>
        </trans-unit>
        <trans-unit id="7f6337cf0b1025e25455e7f1eb27c447744854cc" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by sequential scans</source>
          <target state="translated">シーケンシャルスキャンで取得したライブ行の数</target>
        </trans-unit>
        <trans-unit id="c7bb465c5d5812b8f1ac688b0973b4608d17fc34" translate="yes" xml:space="preserve">
          <source>Number of live rows in the table. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">テーブル内のライブ行の数。これは、計画担当者が使用する推定にすぎません。これは、 &lt;code&gt;VACUUM&lt;/code&gt; 、 &lt;code&gt;ANALYZE&lt;/code&gt; 、および &lt;code&gt;CREATE INDEX&lt;/code&gt; などのいくつかのDDLコマンドによって更新されます。</target>
        </trans-unit>
        <trans-unit id="6384ca87c928ff5826fd519745a102a2e37dcfdf" translate="yes" xml:space="preserve">
          <source>Number of live table rows fetched by simple index scans using this index</source>
          <target state="translated">このインデックスを使用した単純なインデックススキャンによってフェッチされたライブテーブルの行数</target>
        </trans-unit>
        <trans-unit id="dd029b3676675a63d87f153e3800676e7c7dd2a6" translate="yes" xml:space="preserve">
          <source>Number of live tuples</source>
          <target state="translated">ライブタプルの数</target>
        </trans-unit>
        <trans-unit id="d58d2b3f2cd29b1e4cc2b40b834ed9770119552a" translate="yes" xml:space="preserve">
          <source>Number of live tuples (estimated)</source>
          <target state="translated">ライブタプル数(推定</target>
        </trans-unit>
        <trans-unit id="5571a3a39c2a5eeb8bba94092d426fefd43fd703" translate="yes" xml:space="preserve">
          <source>Number of lockers already waited for.</source>
          <target state="translated">すでに待機しているロッカーの数</target>
        </trans-unit>
        <trans-unit id="11736240ddbd910654d9f20076ce6396954df295" translate="yes" xml:space="preserve">
          <source>Number of overflow pages</source>
          <target state="translated">オーバーフローページ数</target>
        </trans-unit>
        <trans-unit id="2ef8f42ee9f5e2c4b09ad099506a9000c698f3af" translate="yes" xml:space="preserve">
          <source>Number of pages in the pending list</source>
          <target state="translated">保留リストのページ数</target>
        </trans-unit>
        <trans-unit id="daa5300000bb09c7a79335a89c2593536d8853e6" translate="yes" xml:space="preserve">
          <source>Number of pages that are marked all-visible in the table's visibility map. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">テーブルの可視性マップですべて可視とマークされているページの数。これは、計画担当者が使用する推定にすぎません。これは、 &lt;code&gt;VACUUM&lt;/code&gt; 、 &lt;code&gt;ANALYZE&lt;/code&gt; 、および &lt;code&gt;CREATE INDEX&lt;/code&gt; などのいくつかのDDLコマンドによって更新されます。</target>
        </trans-unit>
        <trans-unit id="e3cf04020ae64faac82b051a0ef081a4ffd60a33" translate="yes" xml:space="preserve">
          <source>Number of points in path or polygon</source>
          <target state="translated">パスまたはポリゴン内の点の数</target>
        </trans-unit>
        <trans-unit id="544446e4ab9a886e3d43e3c0ad1665073743283d" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">このデータベースのリカバリとの競合が原因でキャンセルされたクエリの数。（競合はスタンバイサーバーでのみ発生します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt; &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; &lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="59e27e77340db29b89a3fbca8921ff6b082deb57" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.)</source>
          <target state="translated">このデータベースでのリカバリとの競合によりキャンセルされたクエリの数。（競合はスタンバイサーバーでのみ発生します。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="14b49512f9667544c12ae0c4b4cd966d96369baa" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to deadlocks</source>
          <target state="translated">デッドロックによりキャンセルされたデータベース内のクエリの数</target>
        </trans-unit>
        <trans-unit id="2965fecffa2cf1a8144374cd40187c529bd62354" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to dropped tablespaces</source>
          <target state="translated">テーブルスペースが削除されたためにキャンセルされたこのデータベースのクエリの数</target>
        </trans-unit>
        <trans-unit id="285091906a09f767f888d2dff167e4dafef20892" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to lock timeouts</source>
          <target state="translated">ロック・タイムアウトによりキャンセルされたデータベース内のクエリの数</target>
        </trans-unit>
        <trans-unit id="7bd181d498f49b3250f7391fd0a21bf7f1dd7ba8" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to old snapshots</source>
          <target state="translated">古いスナップショットのためにキャンセルされたこのデータベースのクエリの数</target>
        </trans-unit>
        <trans-unit id="a343fc19cbfe51192fb4c899e5aeef503d395f97" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to pinned buffers</source>
          <target state="translated">このデータベースの中で、バッファが固定されているためにキャンセルされたクエリの数。</target>
        </trans-unit>
        <trans-unit id="0ac9bcd7ffe37a50ba3f5b534d815f116bf780f4" translate="yes" xml:space="preserve">
          <source>Number of requested checkpoints that have been performed</source>
          <target state="translated">要求されたチェックポイントを実行した数</target>
        </trans-unit>
        <trans-unit id="ac10ddd98993ae90bf693c73dcdf8ce8ff50a428" translate="yes" xml:space="preserve">
          <source>Number of rows HOT updated (i.e., with no separate index update required)</source>
          <target state="translated">HOT更新された行の数 (すなわち、個別のインデックス更新は必要ありません)</target>
        </trans-unit>
        <trans-unit id="d2766fede1a28c68b26ca72aae563b9c0e3b81e7" translate="yes" xml:space="preserve">
          <source>Number of rows deleted</source>
          <target state="translated">削除された行数</target>
        </trans-unit>
        <trans-unit id="f34b08643d44d2358187f3d93aedd65adc903d85" translate="yes" xml:space="preserve">
          <source>Number of rows deleted by queries in this database</source>
          <target state="translated">このデータベースのクエリによって削除された行の数</target>
        </trans-unit>
        <trans-unit id="a2b82f360651a017d5888c1a773debe321eb0eb6" translate="yes" xml:space="preserve">
          <source>Number of rows fetched by queries in this database</source>
          <target state="translated">このデータベースのクエリによってフェッチされた行の数</target>
        </trans-unit>
        <trans-unit id="f45586cda10d5aa205f934dede2f25a7f45e1dde" translate="yes" xml:space="preserve">
          <source>Number of rows inserted</source>
          <target state="translated">挿入された行数</target>
        </trans-unit>
        <trans-unit id="6a09e7859bb80515b532f0be7e2f1d0e3e69ef9b" translate="yes" xml:space="preserve">
          <source>Number of rows inserted by queries in this database</source>
          <target state="translated">このデータベースのクエリによって挿入された行の数</target>
        </trans-unit>
        <trans-unit id="df7903056ffeb2c4aeb95ecc376e010c64637c6c" translate="yes" xml:space="preserve">
          <source>Number of rows returned by queries in this database</source>
          <target state="translated">このデータベースのクエリによって返された行の数</target>
        </trans-unit>
        <trans-unit id="323338c3c2a474e71a2da0eb4b11693b9c2f500b" translate="yes" xml:space="preserve">
          <source>Number of rows updated (includes HOT updated rows)</source>
          <target state="translated">更新された行数(HOT更新された行を含む</target>
        </trans-unit>
        <trans-unit id="454a23c41b48acf5b2ccd14833f1fbd50495e2fe" translate="yes" xml:space="preserve">
          <source>Number of rows updated by queries in this database</source>
          <target state="translated">このデータベースのクエリによって更新された行の数</target>
        </trans-unit>
        <trans-unit id="2ac84789e08f3d81095c6bdcfce3914d10c756d6" translate="yes" xml:space="preserve">
          <source>Number of scheduled checkpoints that have been performed</source>
          <target state="translated">実施された予定チェックポイント数</target>
        </trans-unit>
        <trans-unit id="70b6c2dc7031b941f16874427081ef44f2d0e18e" translate="yes" xml:space="preserve">
          <source>Number of sequential scans initiated on this table</source>
          <target state="translated">このテーブルで開始された連続スキャンの数</target>
        </trans-unit>
        <trans-unit id="a406439f0d98d84ebcc73a534711b625f34ad9d2" translate="yes" xml:space="preserve">
          <source>Number of tablespaces streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt;.</source>
          <target state="translated">ストリーミングされたテーブルスペースの数。このカウンターは、フェーズが &lt;code&gt;streaming database files&lt;/code&gt; 場合にのみ進みます。</target>
        </trans-unit>
        <trans-unit id="db1eaebd91f46f68739419b406f7116ca7278810" translate="yes" xml:space="preserve">
          <source>Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">このデータベースでクエリによって作成された一時ファイルの数。一時ファイルが作成された理由（並べ替えやハッシュなど）に関係なく、&lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt;設定に関係なく、すべての一時ファイルがカウントされます。</target>
        </trans-unit>
        <trans-unit id="321ef5914a0a09d168438f2273433fc677686e24" translate="yes" xml:space="preserve">
          <source>Number of the log line for each session or process, starting at 1</source>
          <target state="translated">1から始まる各セッションまたはプロセスのログ行の番号</target>
        </trans-unit>
        <trans-unit id="63fe0ed940b40404d3e8a92d939916a5dc589c9e" translate="yes" xml:space="preserve">
          <source>Number of times a backend had to execute its own &lt;code&gt;fsync&lt;/code&gt; call (normally the background writer handles those even when the backend does its own write)</source>
          <target state="translated">バックエンドが独自の &lt;code&gt;fsync&lt;/code&gt; 呼び出しを実行する必要があった回数（通常、バックエンドが独自の書き込みを行う場合でも、バックグラウンドライターがそれらを処理します）</target>
        </trans-unit>
        <trans-unit id="68d8d91d15dbba072e77a826a2320fb4b78552e4" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the SLRU, so that a read was not necessary (this only includes hits in the SLRU, not the operating system's file system cache)</source>
          <target state="translated">ディスクブロックが既に SLRU 内に存在していたため、読み込みが必要なかった回数 (これは SLRU 内でのヒットのみで、OS のファイルシステムキャッシュは含まれません)</target>
        </trans-unit>
        <trans-unit id="a553947fcdc098d224243a39019d65fcd42472fd" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)</source>
          <target state="translated">ディスクブロックがバッファキャッシュ内で既に見つかっており、読み込みが必要なかった回数(これはPostgreSQLのバッファキャッシュ内のヒットのみを含み、オペレーティングシステムのファイルシステムキャッシュは含まれません)。</target>
        </trans-unit>
        <trans-unit id="d7202f6daa9d37d53dc5948cf3ce73b0f377e700" translate="yes" xml:space="preserve">
          <source>Number of times executed</source>
          <target state="translated">実行回数</target>
        </trans-unit>
        <trans-unit id="03d48edf24ffbd37a62d6a4ffcfb82831fa45c63" translate="yes" xml:space="preserve">
          <source>Number of times the background writer stopped a cleaning scan because it had written too many buffers</source>
          <target state="translated">バックグラウンドライターがバッファを書きすぎたためにクリーニングスキャンを停止した回数</target>
        </trans-unit>
        <trans-unit id="4ed26fe5383a5798683e9283907335221973e727" translate="yes" xml:space="preserve">
          <source>Number of times the statement was executed</source>
          <target state="translated">ステートメントの実行回数</target>
        </trans-unit>
        <trans-unit id="20347e7e3ba3b446a92ff9a3bd79c5b1d653f5c0" translate="yes" xml:space="preserve">
          <source>Number of times the statement was planned (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">ステートメントが計画された回数（ &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; が有効になっている場合、それ以外の場合はゼロ）</target>
        </trans-unit>
        <trans-unit id="db4c1e8598791346cf7ab2d43ead7da4a1cb087e" translate="yes" xml:space="preserve">
          <source>Number of times this function has been called</source>
          <target state="translated">この関数が呼び出された回数</target>
        </trans-unit>
        <trans-unit id="981adc683189320f78f847f75dfe9f19ed8a5df7" translate="yes" xml:space="preserve">
          <source>Number of times this table has been analyzed by the autovacuum daemon</source>
          <target state="translated">このテーブルが自動バキュームデーモンによって解析された回数</target>
        </trans-unit>
        <trans-unit id="b87ae2050cfd76f7faad9ed39e95e377b7ba3065" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually analyzed</source>
          <target state="translated">このテーブルが手動で分析された回数</target>
        </trans-unit>
        <trans-unit id="86f3157922ed18f5e1cb8cdea053f28b23ec91b9" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">このテーブルが手動でバキュームされた回数（ &lt;code&gt;VACUUM FULL&lt;/code&gt; は含まれません）</target>
        </trans-unit>
        <trans-unit id="7d451fa30c0c321954c3a675d2c5bb4c2d50a932" translate="yes" xml:space="preserve">
          <source>Number of times this table has been vacuumed by the autovacuum daemon</source>
          <target state="translated">このテーブルが自動バキュームデーモンによってバキュームされた回数</target>
        </trans-unit>
        <trans-unit id="4c54cfa40fa8364c91aff563ca87ddd6edf318b8" translate="yes" xml:space="preserve">
          <source>Number of transactions each client runs. Default is 10.</source>
          <target state="translated">各クライアントが実行するトランザクションの数。デフォルトは10です。</target>
        </trans-unit>
        <trans-unit id="3275a376403dc18fc868eeb773fd1acfe4f18aec" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been committed</source>
          <target state="translated">このデータベースでコミットされたトランザクションの数</target>
        </trans-unit>
        <trans-unit id="5b3dba5ee04dc9d1479c1b216978bf3f1db9f6aa" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been rolled back</source>
          <target state="translated">ロールバックされたこのデータベース内のトランザクション数</target>
        </trans-unit>
        <trans-unit id="ec735d5660ce6c32dd80bd724ca186e1322664ff" translate="yes" xml:space="preserve">
          <source>Number of truncates for this SLRU</source>
          <target state="translated">この SLRU の切り捨て数</target>
        </trans-unit>
        <trans-unit id="249fa0ad004c753cb36af02875bc1dafebf2db43" translate="yes" xml:space="preserve">
          <source>Number of tuples already processed in the current phase.</source>
          <target state="translated">現在のフェーズで既に処理されているタプルの数。</target>
        </trans-unit>
        <trans-unit id="e10a2168070471eb01214b024083f7afd7ad7f4a" translate="yes" xml:space="preserve">
          <source>Number of tuples in the pending list</source>
          <target state="translated">保留リストのタプル数</target>
        </trans-unit>
        <trans-unit id="cf7d86c225385fe6e945a39e465f0448098943a9" translate="yes" xml:space="preserve">
          <source>Number of unused pages</source>
          <target state="translated">未使用ページ数</target>
        </trans-unit>
        <trans-unit id="64210a61d52a14f7a802ee5036f59bb4880be4c1" translate="yes" xml:space="preserve">
          <source>Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in &lt;code&gt;pg_attribute&lt;/code&gt;. See also &lt;code&gt;pg_attribute.attnum&lt;/code&gt;.</source>
          <target state="translated">リレーション内のユーザー列の数（システム列はカウントされません）。 &lt;code&gt;pg_attribute&lt;/code&gt; には、これだけ多くの対応するエントリが必要です。 &lt;code&gt;pg_attribute.attnum&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="f5897414fda7aed8102e3f5d6f9e16ee579dd363" translate="yes" xml:space="preserve">
          <source>Number of worker threads within pgbench. Using more than one thread can be helpful on multi-CPU machines. Clients are distributed as evenly as possible among available threads. Default is 1.</source>
          <target state="translated">pgbench 内のワーカースレッドの数。複数のスレッドを使用することは、マルチ CPU マシンでは便利です。クライアントは利用可能なスレッド間で可能な限り均等に分散されます。デフォルトは1です。</target>
        </trans-unit>
        <trans-unit id="cefa5441373f254fdc1cb9fdbc4d9c0c1aa44ee4" translate="yes" xml:space="preserve">
          <source>Numbers with 7 or fewer significant digits retain their original precision. That is, if your query returns 0.00, you will be sure that the trailing zeroes are not the artifacts of formatting: they reflect the precision of the original data. The number of leading zeroes does not affect precision: the value 0.0067 is considered to have just 2 significant digits.</source>
          <target state="translated">有効数字が7桁以下の数字は、元の精度を保持します。つまり、クエリが0.00を返した場合、末尾のゼロは書式設定によるものではなく、元のデータの精度を反映したものであることを確認できます。先頭のゼロの数は精度に影響しません。値0.0067は、有効数字が2桁しかないとみなされます。</target>
        </trans-unit>
        <trans-unit id="58224773d7dc5786efbb9bfbfa152b78d5c3ced5" translate="yes" xml:space="preserve">
          <source>Numeric Types</source>
          <target state="translated">数値型</target>
        </trans-unit>
        <trans-unit id="f1b55ea9345add00dc53f8d39e821048683ac6ac" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigint</source>
          <target state="translated">数値型:bigint</target>
        </trans-unit>
        <trans-unit id="34ca1938464846ffd7671c72fe6fcf56ce8ed626" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigserial</source>
          <target state="translated">数値型:bigserial</target>
        </trans-unit>
        <trans-unit id="4f4c21c7dbf7d3b0ce15752213f48b0ca85c6be6" translate="yes" xml:space="preserve">
          <source>Numeric Types: decimal</source>
          <target state="translated">数値型:10進数</target>
        </trans-unit>
        <trans-unit id="5f39be2adc33677462c0440cd7f421e180a13185" translate="yes" xml:space="preserve">
          <source>Numeric Types: double precision</source>
          <target state="translated">数値型:倍精度</target>
        </trans-unit>
        <trans-unit id="7d13fe88ea7d98f3a10e5a107a6fb5f2b06420b9" translate="yes" xml:space="preserve">
          <source>Numeric Types: integer</source>
          <target state="translated">数値型:整数</target>
        </trans-unit>
        <trans-unit id="589f0dce7263b0f4a4ffcc692a06b6cca5db39a7" translate="yes" xml:space="preserve">
          <source>Numeric Types: numeric</source>
          <target state="translated">数値型:数値</target>
        </trans-unit>
        <trans-unit id="d049c61cbf5f08cf4a2b6ad03914911c2436a250" translate="yes" xml:space="preserve">
          <source>Numeric Types: real</source>
          <target state="translated">数値型:実数</target>
        </trans-unit>
        <trans-unit id="017b04d1c97e36f0333abaaf314c6a6c6bbedc30" translate="yes" xml:space="preserve">
          <source>Numeric Types: serial</source>
          <target state="translated">数値タイプ:シリアル</target>
        </trans-unit>
        <trans-unit id="9e36bc851d04411f4bd3afa229897af484988fe2" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallint</source>
          <target state="translated">数値型:smallint</target>
        </trans-unit>
        <trans-unit id="3fa9584c0cd0a43cf41d81cfcfb10456d729bae0" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallserial</source>
          <target state="translated">数値型:smallserial</target>
        </trans-unit>
        <trans-unit id="a172b52198f27b4b4b6b86a0f1c9b17a17d9bf18" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0&amp;ndash;127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">ASCII範囲（0〜127）外の値を指定する数字入力エスケープは、データベースのエンコードに依存する意味を持ちます。エンコーディングがUTF-8の場合、エスケープ値はUnicodeコードポイントと同等です。たとえば、 &lt;code&gt;\u1234&lt;/code&gt; は文字 &lt;code&gt;U+1234&lt;/code&gt; を意味します。他のマルチバイトエンコーディングの場合、文字入力エスケープは通常、文字のバイト値の連結を指定するだけです。エスケープ値がデータベースエンコーディングの有効な文字に対応していない場合、エラーは発生しませんが、どのデータとも一致しません。</target>
        </trans-unit>
        <trans-unit id="6907254669bc308bcd96a76901734e20d0b431f6" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">ASCII範囲（0〜127）の範囲外の値を指定する数値文字のエスケープは、データベースのエンコードに応じて意味が異なります。エンコーディングがUTF-8の場合、エスケープ値はUnicodeコードポイントに相当します。たとえば、 &lt;code&gt;\u1234&lt;/code&gt; は文字 &lt;code&gt;U+1234&lt;/code&gt; を意味します。他のマルチバイトエンコーディングの場合、文字入力エスケープは通常、文字のバイト値の連結を指定するだけです。エスケープ値がデータベースエンコーディングの有効な文字に対応していない場合、エラーは発生しませんが、どのデータとも一致しません。</target>
        </trans-unit>
        <trans-unit id="6e2759a88d02cd4c49727936e3e39cfce1c8fe1b" translate="yes" xml:space="preserve">
          <source>Numeric constants are accepted in these general forms:</source>
          <target state="translated">数値定数は、これらの一般的な形式で受け入れられます。</target>
        </trans-unit>
        <trans-unit id="32c0946f98f3a53c7cc5e78bd6ba14716174ad6a" translate="yes" xml:space="preserve">
          <source>Numeric ordering, sorts sequences of digits by their numeric value, for example: &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (also known as natural sort).</source>
          <target state="translated">数値の順序付け。数字のシーケンスを数値でソートします。例： &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; （ナチュラルソートとも呼ばれます）。</target>
        </trans-unit>
        <trans-unit id="8d7bc2659eda5afabdbd8dae30a1b10b69aab0fa" translate="yes" xml:space="preserve">
          <source>Numeric transaction identifier of the prepared transaction</source>
          <target state="translated">準備されたトランザクションの数値トランザクション識別子</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数値型</target>
        </trans-unit>
        <trans-unit id="bbed1ad8168ad945da348f70d8f35c3aaa2d08ae" translate="yes" xml:space="preserve">
          <source>Numeric types consist of two-, four-, and eight-byte integers, four- and eight-byte floating-point numbers, and selectable-precision decimals. &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt; lists the available types.</source>
          <target state="translated">数値タイプは、2、4、および8バイト整数、4および8バイトの浮動小数点数、および選択可能な精度の10進数で構成されます。&lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;表8.2&lt;/a&gt;に、使用可能なタイプを示します。</target>
        </trans-unit>
        <trans-unit id="ae34df1114cf867e5a5e67721782e6b4936cf60a" translate="yes" xml:space="preserve">
          <source>Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the &lt;code&gt;numeric&lt;/code&gt; type is more akin to &lt;code&gt;varchar(n)&lt;/code&gt; than to &lt;code&gt;char(n)&lt;/code&gt;.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.</source>
          <target state="translated">数値は、余分な先頭または末尾のゼロなしで物理的に保存されます。したがって、列の宣言された精度とスケールは最大であり、固定割り当てではありません。（この意味で、 &lt;code&gt;numeric&lt;/code&gt; 型は &lt;code&gt;char(n)&lt;/code&gt; &lt;code&gt;varchar(n)&lt;/code&gt; よりもvarchar（n）に似ています。）実際のストレージ要件は、4桁の10進数のグループごとに2バイトと、3〜8バイトのオーバーヘッドです。</target>
        </trans-unit>
        <trans-unit id="1cd1073fd79a8443ea8d6973895d5ee6ffe7cdf9" translate="yes" xml:space="preserve">
          <source>Numerical statistics of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not involve numerical values</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 番目の「スロット」に適した種類の数値統計、またはスロットの種類に数値が含まれない場合はnull</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="725ff3ec092f4de8d511006eba9dfe844003c6f9" translate="yes" xml:space="preserve">
          <source>OID of a database</source>
          <target state="translated">データベースのOID</target>
        </trans-unit>
        <trans-unit id="f8c02df27c83758b75b440e8700bcc0f8b46a3f0" translate="yes" xml:space="preserve">
          <source>OID of a function</source>
          <target state="translated">関数のOID</target>
        </trans-unit>
        <trans-unit id="faffc6a7f80d0822867cb82f8a02546997b88ef9" translate="yes" xml:space="preserve">
          <source>OID of a handler function that is responsible for supplying information about the access method</source>
          <target state="translated">アクセスメソッドの情報を提供するハンドラ関数のOID</target>
        </trans-unit>
        <trans-unit id="5a4a96aa8d7efd7ac397558d10f843a235a92c88" translate="yes" xml:space="preserve">
          <source>OID of a sequence</source>
          <target state="translated">シーケンスのOID</target>
        </trans-unit>
        <trans-unit id="996a8d685aef72e0b42d14422b03fa62a0285fd1" translate="yes" xml:space="preserve">
          <source>OID of a table</source>
          <target state="translated">テーブルのOID</target>
        </trans-unit>
        <trans-unit id="90f9df50ed473af29d597298ed5c8caeb84243d2" translate="yes" xml:space="preserve">
          <source>OID of database in which the statement was executed</source>
          <target state="translated">ステートメントが実行されたデータベースのOID</target>
        </trans-unit>
        <trans-unit id="080d0fef7c4d986b1330554caa1d1e593f3124b0" translate="yes" xml:space="preserve">
          <source>OID of session's temporary schema, or 0 if none</source>
          <target state="translated">セッションの一時的なスキーマのOID。</target>
        </trans-unit>
        <trans-unit id="346ed8429eddd05e15627f07718d2d6a7f44eddd" translate="yes" xml:space="preserve">
          <source>OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this foreign table</source>
          <target state="translated">この外部テーブルの &lt;code&gt;pg_class&lt;/code&gt; エントリのOID</target>
        </trans-unit>
        <trans-unit id="3bcb74cd3805e6c2a6b21b10048ed96a348a5d71" translate="yes" xml:space="preserve">
          <source>OID of the TOAST table associated with this table, 0 if none. The TOAST table stores large attributes &amp;ldquo;out of line&amp;rdquo; in a secondary table.</source>
          <target state="translated">このテーブルに関連付けられているTOASTテーブルのOID。ない場合は0。TOASTテーブルは、2次テーブルに「行外」の大きな属性を格納します。</target>
        </trans-unit>
        <trans-unit id="0087f0d6da4c99ba53f0596b33bf633085b24106" translate="yes" xml:space="preserve">
          <source>OID of the child table currently being scanned. This field is only valid when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="translated">現在スキャンされている子テーブルのOID。このフィールドは、フェーズが &lt;code&gt;acquiring inherited sample rows&lt;/code&gt; 場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="5cb554635bbb124706c2580bd976000c272a3041" translate="yes" xml:space="preserve">
          <source>OID of the collation used for range comparisons, or 0 if none</source>
          <target state="translated">範囲比較に使用される照合順序のOID、ない場合は0</target>
        </trans-unit>
        <trans-unit id="1af1844b19464c23fc7fd9fcae9a412bfe3133ff" translate="yes" xml:space="preserve">
          <source>OID of the data type this transform is for</source>
          <target state="translated">この変換を行うデータ型の OID</target>
        </trans-unit>
        <trans-unit id="7be8af1517de8b566e91490637cc744e1bfc4538" translate="yes" xml:space="preserve">
          <source>OID of the database in which the lock target exists, or zero if the target is a shared object, or null if the target is a transaction ID</source>
          <target state="translated">ロック・ターゲットが存在するデータベースのOID、ターゲットが共有オブジェクトの場合は0、ターゲットがトランザクションIDの場合はNULL。</target>
        </trans-unit>
        <trans-unit id="d6eff8fed00f101585817bdde7217d409d0452cb" translate="yes" xml:space="preserve">
          <source>OID of the database this backend is connected to</source>
          <target state="translated">このバックエンドが接続しているデータベースの OID</target>
        </trans-unit>
        <trans-unit id="c3f83d507478524c5f0343641eaf036c1dd5f6f4" translate="yes" xml:space="preserve">
          <source>OID of the database to which this backend is connected.</source>
          <target state="translated">このバックエンドが接続されているデータベースのOID。</target>
        </trans-unit>
        <trans-unit id="99d858de93dcac0523dbaa414705f17f8ce20935" translate="yes" xml:space="preserve">
          <source>OID of the database which the subscription resides in</source>
          <target state="translated">サブスクリプションが存在するデータベースのOID</target>
        </trans-unit>
        <trans-unit id="3c094c24ab67863a7765120475d6a2f2e2e272ea" translate="yes" xml:space="preserve">
          <source>OID of the element type (subtype) of this range type</source>
          <target state="translated">この範囲型の要素型(サブタイプ)のOID</target>
        </trans-unit>
        <trans-unit id="91964bc019a248521428ce08554d6e0d30140b28" translate="yes" xml:space="preserve">
          <source>OID of the foreign server for this foreign table</source>
          <target state="translated">この外部テーブルの外部サーバのOID</target>
        </trans-unit>
        <trans-unit id="73727764a13452c62b9dc37a3cc28ff75c10a8fb" translate="yes" xml:space="preserve">
          <source>OID of the foreign-data wrapper of this foreign server</source>
          <target state="translated">この外部サーバの外部データラッパーの OID</target>
        </trans-unit>
        <trans-unit id="bef000be97274c50b609e7040996c7f3a74549e7" translate="yes" xml:space="preserve">
          <source>OID of the function</source>
          <target state="translated">関数のOID</target>
        </trans-unit>
        <trans-unit id="d936ce13d6a2191f0fb1ebd586182169926914bd" translate="yes" xml:space="preserve">
          <source>OID of the function to convert a range value into canonical form, or 0 if none</source>
          <target state="translated">範囲値を正規形に変換する関数のOID、ない場合は0</target>
        </trans-unit>
        <trans-unit id="3de3255d0dade1eabbba67bef7bb7de2117ad3f9" translate="yes" xml:space="preserve">
          <source>OID of the function to return the difference between two element values as &lt;code&gt;double precision&lt;/code&gt;, or 0 if none</source>
          <target state="translated">2つの要素値の差を &lt;code&gt;double precision&lt;/code&gt; として返す関数のOID、ない場合は0</target>
        </trans-unit>
        <trans-unit id="04695e3476f4985e5e3d88253bca9d829918ada5" translate="yes" xml:space="preserve">
          <source>OID of the index being created or reindexed. During a non-concurrent &lt;code&gt;CREATE INDEX&lt;/code&gt;, this is 0.</source>
          <target state="translated">作成または再インデックスされるインデックスのOID。非並行 &lt;code&gt;CREATE INDEX&lt;/code&gt; の実行中、これは0です。</target>
        </trans-unit>
        <trans-unit id="36fd3faf4abf64d7b63021e96a36b08b96b00ad5" translate="yes" xml:space="preserve">
          <source>OID of the language this transform is for</source>
          <target state="translated">この変換の対象となる言語の OID</target>
        </trans-unit>
        <trans-unit id="7e460991382ec78ace08e8b50c8809bb0c2a37f4" translate="yes" xml:space="preserve">
          <source>OID of the large object to be altered</source>
          <target state="translated">変更するラージオブジェクトのOID</target>
        </trans-unit>
        <trans-unit id="1d1d811b028d1d43309ac3a6a9795a5474876c40" translate="yes" xml:space="preserve">
          <source>OID of the local role being mapped, 0 if the user mapping is public</source>
          <target state="translated">マップされるローカルロールのOID、ユーザーマッピングが公開されている場合は0</target>
        </trans-unit>
        <trans-unit id="f6befa197b5efdceb1d6e3e97ba6a7089030d83b" translate="yes" xml:space="preserve">
          <source>OID of the lock target within its system catalog, or null if the target is not a general database object</source>
          <target state="translated">システムカタログ内のロックターゲットのOID、またはターゲットが一般的なデータベースオブジェクトでない場合はNULL。</target>
        </trans-unit>
        <trans-unit id="547ca9a3f91e95b8778cc1a87f9fe368954503d2" translate="yes" xml:space="preserve">
          <source>OID of the operator</source>
          <target state="translated">オペレータのOID</target>
        </trans-unit>
        <trans-unit id="57147e7dec8c6552f43472e577611d734b852d01" translate="yes" xml:space="preserve">
          <source>OID of the parser's headline function</source>
          <target state="translated">パーサの見出し関数の OID</target>
        </trans-unit>
        <trans-unit id="e75052ec080efa2cb48c4eee33c12247804336c7" translate="yes" xml:space="preserve">
          <source>OID of the parser's lextype function</source>
          <target state="translated">パーサの lextype 関数の OID</target>
        </trans-unit>
        <trans-unit id="070d9465021b789c1852df9d85e1dab51aa12f2b" translate="yes" xml:space="preserve">
          <source>OID of the parser's next-token function</source>
          <target state="translated">パーサのネクストトークン関数のOID</target>
        </trans-unit>
        <trans-unit id="28ddd7cda8c6ae7b671231bc8b5771d3c20a5115" translate="yes" xml:space="preserve">
          <source>OID of the parser's shutdown function</source>
          <target state="translated">パーサのシャットダウン関数の OID</target>
        </trans-unit>
        <trans-unit id="3441d838ae5086ffa5ad3452eab23ff3831aa095" translate="yes" xml:space="preserve">
          <source>OID of the parser's startup function</source>
          <target state="translated">パーサの起動関数のOID</target>
        </trans-unit>
        <trans-unit id="cf7d55d689e6813249b16676499a1c0b2b7376b1" translate="yes" xml:space="preserve">
          <source>OID of the range type</source>
          <target state="translated">範囲タイプのOID</target>
        </trans-unit>
        <trans-unit id="00bba16646f2a65970a0b9e99737c24fb8db4ee2" translate="yes" xml:space="preserve">
          <source>OID of the relation targeted by the lock, or null if the target is not a relation or part of a relation</source>
          <target state="translated">ロックの対象となるリレーションのOID、ターゲットがリレーションでない場合やリレーションの一部でない場合はNULL。</target>
        </trans-unit>
        <trans-unit id="10ccac12f9b1c1d8ff7d1e3fe492cab3d5e3c0cd" translate="yes" xml:space="preserve">
          <source>OID of the relation that the worker is synchronizing; null for the main apply worker</source>
          <target state="translated">ワーカーが同期しているリレーションの OID。</target>
        </trans-unit>
        <trans-unit id="64dbbea0aaf12efa0d4ebae8170596e36c349efc" translate="yes" xml:space="preserve">
          <source>OID of the source data type</source>
          <target state="translated">ソースデータ型のOID</target>
        </trans-unit>
        <trans-unit id="4ab6e82967b76a601d959c42c032a9613f62366e" translate="yes" xml:space="preserve">
          <source>OID of the subscription</source>
          <target state="translated">サブスクリプションのOID</target>
        </trans-unit>
        <trans-unit id="529393343c510cc7f43e20828d0d63fb68383a2c" translate="yes" xml:space="preserve">
          <source>OID of the subtype's operator class used for range comparisons</source>
          <target state="translated">範囲比較に使用されるサブタイプの演算子クラスのOID</target>
        </trans-unit>
        <trans-unit id="633257d0b0d38e2fef790525052ae12fd0314ed1" translate="yes" xml:space="preserve">
          <source>OID of the system catalog containing the lock target, or null if the target is not a general database object</source>
          <target state="translated">ロックターゲットを含むシステムカタログのOID、またはターゲットが一般的なデータベースオブジェクトでない場合はNULL。</target>
        </trans-unit>
        <trans-unit id="6ba91c2dce09309f79136d3e66a8e5ae37f1fe91" translate="yes" xml:space="preserve">
          <source>OID of the table being analyzed.</source>
          <target state="translated">解析対象のテーブルのOID。</target>
        </trans-unit>
        <trans-unit id="6da84f1d83f2a7ebd175fcdf78bf746dff039dba" translate="yes" xml:space="preserve">
          <source>OID of the table being clustered.</source>
          <target state="translated">クラスタ化されるテーブルのOID。</target>
        </trans-unit>
        <trans-unit id="0e4debb724827a1126e4f0985aac0c3bd73e2728" translate="yes" xml:space="preserve">
          <source>OID of the table being vacuumed.</source>
          <target state="translated">掃除機をかけているテーブルのOID。</target>
        </trans-unit>
        <trans-unit id="e9109406be796a3753b7f074b353cc534267a046" translate="yes" xml:space="preserve">
          <source>OID of the table for this index</source>
          <target state="translated">このインデックスのテーブルの OID</target>
        </trans-unit>
        <trans-unit id="50e7e1691ddba39a8ac80c840ffce2b6dd3a48c8" translate="yes" xml:space="preserve">
          <source>OID of the table on which the index is being created.</source>
          <target state="translated">インデックスが作成されるテーブルのOID。</target>
        </trans-unit>
        <trans-unit id="090219832be11fe1619b95babe8e9c1e5e92c437" translate="yes" xml:space="preserve">
          <source>OID of the target data type</source>
          <target state="translated">対象データ型のOID</target>
        </trans-unit>
        <trans-unit id="ac66a3e3aabe35420bf2d2c1e94ee59c9c06a065" translate="yes" xml:space="preserve">
          <source>OID of the template's initialization function</source>
          <target state="translated">テンプレートの初期化関数のOID</target>
        </trans-unit>
        <trans-unit id="50c0da2d8b347f30166307b39f81117e5e35c3ea" translate="yes" xml:space="preserve">
          <source>OID of the template's lexize function</source>
          <target state="translated">テンプレートのレキシズ関数のOID</target>
        </trans-unit>
        <trans-unit id="a8374b131925b37be69ac971d0b27d489ca95329" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this WAL sender process</source>
          <target state="translated">このWAL送信者プロセスにログインしているユーザーのOID</target>
        </trans-unit>
        <trans-unit id="5fe5cd795b2ac38b10709cbfaf75428859cfc40c" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this backend</source>
          <target state="translated">このバックエンドにログインしているユーザーの OID</target>
        </trans-unit>
        <trans-unit id="ac6509d860cce791cfecdfeff54c3c371229705b" translate="yes" xml:space="preserve">
          <source>OID of the user mapping</source>
          <target state="translated">ユーザーマッピングのOID</target>
        </trans-unit>
        <trans-unit id="5cb18008fb6941eebe8d741c085bfe9b7fb69a3f" translate="yes" xml:space="preserve">
          <source>OID of this database, or 0 for objects belonging to a shared relation</source>
          <target state="translated">このデータベースのOID、または共有関係に属するオブジェクトの場合は0</target>
        </trans-unit>
        <trans-unit id="a7af712c7c37a60b529576ed90f30e8cf2d7a00c" translate="yes" xml:space="preserve">
          <source>OID of this index</source>
          <target state="translated">このインデックスのOID</target>
        </trans-unit>
        <trans-unit id="d3dd8c985a0eabab21975bbe483a04f61be0cad9" translate="yes" xml:space="preserve">
          <source>OID of user who executed the statement</source>
          <target state="translated">ステートメントを実行したユーザのOID</target>
        </trans-unit>
        <trans-unit id="387852e7a1481866714e0a22f56d3c6e25b3ae5f" translate="yes" xml:space="preserve">
          <source>OIDs assigned during normal database operation are constrained to be 16384 or higher. This ensures that the range 10000&amp;mdash;16383 is free for OIDs assigned automatically by &lt;code&gt;genbki.pl&lt;/code&gt; or during bootstrap. These automatically-assigned OIDs are not considered stable, and may change from one installation to another.</source>
          <target state="translated">通常のデータベース操作中に割り当てられるOIDは、16384以上に制限されています。この性を保証範囲10000から16383は、によって自動的に割り当てられるOIDのために自由であることを &lt;code&gt;genbki.pl&lt;/code&gt; またはブートストラップ時に。これらの自動的に割り当てられるOIDは安定しているとは見なされず、インストールごとに変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a08513f8d6a0456d0e2e3f8053e17f798ea2afa0" translate="yes" xml:space="preserve">
          <source>OLAP</source>
          <target state="translated">OLAP</target>
        </trans-unit>
        <trans-unit id="751cc96735bf8b84aef2fec3e06efb1b1a5b1ccc" translate="yes" xml:space="preserve">
          <source>OLTP</source>
          <target state="translated">OLTP</target>
        </trans-unit>
        <trans-unit id="25e9c7c3a98b268d5dfb9854a9b3f093ee86933f" translate="yes" xml:space="preserve">
          <source>OR &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">OR &lt;code&gt;tsquery&lt;/code&gt; を一緒に</target>
        </trans-unit>
        <trans-unit id="204bd21a2ea07120bf9aa428b287753e7d9939bc" translate="yes" xml:space="preserve">
          <source>ORDBMS</source>
          <target state="translated">ORDBMS</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">並び順</target>
        </trans-unit>
        <trans-unit id="8cd49ef586968599e62519504427958da4d48a39" translate="yes" xml:space="preserve">
          <source>ORs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match either input query.</source>
          <target state="translated">2つの &lt;code&gt;tsquery&lt;/code&gt; をORして、いずれかの入力クエリに一致するドキュメントに一致するクエリを生成します。</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="b77e714dbd01a80315e52e6a9d94c65e9f359c98" translate="yes" xml:space="preserve">
          <source>Object Identifier</source>
          <target state="translated">オブジェクト識別子</target>
        </trans-unit>
        <trans-unit id="2ebed2ba0d6eed2f88e2d3187c0748eee35c9c48" translate="yes" xml:space="preserve">
          <source>Object Identifier Types</source>
          <target state="translated">オブジェクト識別子の種類</target>
        </trans-unit>
        <trans-unit id="690a335354f7107071acc3fa67c016dc6bc384da" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: oid</source>
          <target state="translated">オブジェクト識別子タイプ:oid</target>
        </trans-unit>
        <trans-unit id="0075fd06325f676dff687ca83f8e432afb05cd0a" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regclass</source>
          <target state="translated">オブジェクト識別子の種類:regclass</target>
        </trans-unit>
        <trans-unit id="47d07e7ec3c2bb281acfd4b09b95c7bd692a6146" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regcollation</source>
          <target state="translated">オブジェクト識別子タイプ:regcollation</target>
        </trans-unit>
        <trans-unit id="9ff60426c655614fda7aef019d73fd45fb97d826" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regconfig</source>
          <target state="translated">オブジェクト識別子タイプ:regconfig</target>
        </trans-unit>
        <trans-unit id="dfaba8ba7726385dd9aaa48834af168d2f9ceedf" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regdictionary</source>
          <target state="translated">オブジェクト識別子の種類:regdictionary</target>
        </trans-unit>
        <trans-unit id="cc8674af1caee1212cf1ad2d15d842446e9a98aa" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regnamespace</source>
          <target state="translated">オブジェクト識別子タイプ:regnamespace</target>
        </trans-unit>
        <trans-unit id="c2b56a3df38b329696180cd377e1ed88251bb409" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoper</source>
          <target state="translated">オブジェクト識別子の種類:regoper</target>
        </trans-unit>
        <trans-unit id="30c72913cd86047f07f98633a45661ed568c2533" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoperator</source>
          <target state="translated">オブジェクト識別子タイプ:regoperator</target>
        </trans-unit>
        <trans-unit id="a48a31a0bb9251c420e48d22aa7c1d09ca5723bd" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regproc</source>
          <target state="translated">オブジェクト識別子タイプ:regproc</target>
        </trans-unit>
        <trans-unit id="67cdc0df1aaf8b31658af7a6a45b330191b5746d" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regprocedure</source>
          <target state="translated">オブジェクト識別子タイプ:regprocedure</target>
        </trans-unit>
        <trans-unit id="6c6385e5aae8c21dd4c725971f7b3936a95ef63b" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regrole</source>
          <target state="translated">オブジェクト識別子タイプ:regrole</target>
        </trans-unit>
        <trans-unit id="f7695a1c32f9f4d88fc2778bef31cc0d65aad8a7" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regtype</source>
          <target state="translated">オブジェクト識別子タイプ:regtype</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">オブジェクトタイプ</target>
        </trans-unit>
        <trans-unit id="440eaacb05716029aec3d29f1c4c8f8f3cf112cd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt; named &lt;code&gt;regsomething&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">オブジェクト識別子（OID）は、さまざまなシステムテーブルの主キーとしてPostgreSQLによって内部的に使用されます。タイプ &lt;code&gt;oid&lt;/code&gt; はオブジェクト識別子を表します。 &lt;code&gt;regsomething&lt;/code&gt; という名前の &lt;code&gt;oid&lt;/code&gt; にはいくつかのエイリアスタイプもあります。&lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;表8.26に&lt;/a&gt;概要を示します。</target>
        </trans-unit>
        <trans-unit id="486ece6dd89f3c4ea297334b48675b716e4268bd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt;: &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regrole&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, and &lt;code&gt;regdictionary&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">オブジェクト識別子（OID）は、PostgreSQLによってさまざまなシステムテーブルの主キーとして内部的に使用されます。タイプ &lt;code&gt;oid&lt;/code&gt; はオブジェクト識別子を表します。いくつかのエイリアス用タイプもあります。 &lt;code&gt;oid&lt;/code&gt; ： &lt;code&gt;regproc&lt;/code&gt; 、 &lt;code&gt;regprocedure&lt;/code&gt; 、 &lt;code&gt;regoper&lt;/code&gt; 、 &lt;code&gt;regoperator&lt;/code&gt; を、 &lt;code&gt;regclass&lt;/code&gt; データ、 &lt;code&gt;regtype&lt;/code&gt; 、 &lt;code&gt;regrole&lt;/code&gt; 、 &lt;code&gt;regnamespace&lt;/code&gt; 、 &lt;code&gt;regconfig&lt;/code&gt; 、および &lt;code&gt;regdictionary&lt;/code&gt; は。&lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;表8.26に&lt;/a&gt;概要を示します。</target>
        </trans-unit>
        <trans-unit id="e6ffe45f664bbe6f6262859df4e3695e1d12153a" translate="yes" xml:space="preserve">
          <source>Object-Relational Database Management System</source>
          <target state="translated">オブジェクトリレーショナルデータベース管理システム</target>
        </trans-unit>
        <trans-unit id="ec90b7e160c78de5740196cc2532f466404d90bc" translate="yes" xml:space="preserve">
          <source>Objects can have initial privileges either by having those privileges set when the system is initialized (by initdb) or when the object is created during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; and the extension script sets initial privileges using the &lt;code&gt;GRANT&lt;/code&gt; system. Note that the system will automatically handle recording of the privileges during the extension script and that extension authors need only use the &lt;code&gt;GRANT&lt;/code&gt; and &lt;code&gt;REVOKE&lt;/code&gt; statements in their script to have the privileges recorded. The &lt;code&gt;privtype&lt;/code&gt; column indicates if the initial privilege was set by initdb or during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; command.</source>
          <target state="translated">オブジェクトは、システムが（initdbによって）初期化されるとき、またはオブジェクトが &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 中に作成され、拡張スクリプトが &lt;code&gt;GRANT&lt;/code&gt; システムを使用して初期特権を設定するときに、これらの特権を設定することによって、初期特権を持つことができます。システムは拡張スクリプトの実行中に特権の記録を自動的に処理し、拡張の作成者は特権を記録するためにスクリプトの &lt;code&gt;GRANT&lt;/code&gt; および &lt;code&gt;REVOKE&lt;/code&gt; ステートメントを使用するだけでよいことに注意してください。 &lt;code&gt;privtype&lt;/code&gt; の最初の権限はinitdbでまたは中に設定された場合、列を示し &lt;code&gt;CREATE EXTENSION&lt;/code&gt; コマンド。</target>
        </trans-unit>
        <trans-unit id="8d18be902bfa3d762f98290f3d1e8291c77198c6" translate="yes" xml:space="preserve">
          <source>Objects which have initial privileges set by initdb will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'i'&lt;/code&gt;, while objects which have initial privileges set by &lt;code&gt;CREATE EXTENSION&lt;/code&gt; will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'e'&lt;/code&gt;.</source>
          <target state="translated">initdbによって初期特権が設定されているオブジェクトには、 &lt;code&gt;privtype&lt;/code&gt; が &lt;code&gt;'i'&lt;/code&gt; であるエントリがあり、 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; によって初期特権が設定されているオブジェクトには、 &lt;code&gt;privtype&lt;/code&gt; が &lt;code&gt;'e'&lt;/code&gt; であるエントリがあります。</target>
        </trans-unit>
        <trans-unit id="8f79c201923795ddf3fc3a390dc899926a81383e" translate="yes" xml:space="preserve">
          <source>Objects with equal numbers of pairs are compared in the order:</source>
          <target state="translated">同数のペアを持つオブジェクトを順番に比較します。</target>
        </trans-unit>
        <trans-unit id="40a4edd85bccc1fb19d69c2e2dabe7dd4292f362" translate="yes" xml:space="preserve">
          <source>Observe how in the traditional ICU locale naming system, the root locale is selected by an empty string.</source>
          <target state="translated">伝統的な ICU のロケール命名システムでは、ルートロケールが空文字列で選択されていることに注目してください。</target>
        </trans-unit>
        <trans-unit id="82dae9ce3d89138d44c64eb3de8005375bc20848" translate="yes" xml:space="preserve">
          <source>Observe that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, but this adds maintenance effort.</source>
          <target state="translated">この種の部分インデックスは、共通値があらかじめ決められていることが必要なので、そのような部分インデックスは、変化しないデータ分布に使用するのが最適です。このようなインデックスは、新しいデータ分布を調整するために時々再作成することができますが、これにはメンテナンスの手間がかかります。</target>
        </trans-unit>
        <trans-unit id="d607df7ca6e658558b5841d4666abffe49980352" translate="yes" xml:space="preserve">
          <source>Observe that this match would not succeed if written as</source>
          <target state="translated">このマッチは、次のように書かれている場合は成功しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d177dde8092a5f060f1495243a63f697a9a17705" translate="yes" xml:space="preserve">
          <source>Observe two things about the result set:</source>
          <target state="translated">結果集合について2つのことを観察してください。</target>
        </trans-unit>
        <trans-unit id="4201c9715be128e9359f0f8e049514e18476b73a" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;code&gt;N&lt;/code&gt; is now ignored, since the number of value columns is always determined by the calling query</source>
          <target state="translated">&lt;code&gt;crosstab(text)&lt;/code&gt; の廃止バージョン。値列の数は常に呼び出し元のクエリによって決定されるため、パラメータ &lt;code&gt;N&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="7df429ce2fd206ab797db57eb8b6b362392f7035" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is now ignored, since the number of value columns is always determined by the calling query.</source>
          <target state="translated">&lt;code&gt;crosstab(text)&lt;/code&gt; の廃止バージョン。値の列の数は常に呼び出し元のクエリによって決定されるため、パラメータ&lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt;は無視されるようになりました。</target>
        </trans-unit>
        <trans-unit id="11744d185f0b82d838b338e8988d902a0140f6b7" translate="yes" xml:space="preserve">
          <source>Obtain a &lt;code&gt;SHARE&lt;/code&gt; lock on a primary key table when going to perform inserts into a foreign key table:</source>
          <target state="translated">外部キーテーブルへの挿入を実行するときに、主キーテーブルの &lt;code&gt;SHARE&lt;/code&gt; ロックを取得します。</target>
        </trans-unit>
        <trans-unit id="05c7fc189f9bad2f9b668a2a40c5180d608c005f" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock</source>
          <target state="translated">排他的なセッションレベルのアドバイザリロックを取得</target>
        </trans-unit>
        <trans-unit id="019972b3655998bb11d76b53a542ff72a8b76dca" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock if available</source>
          <target state="translated">排他的なセッションレベルのアドバイザリロックを取得できる場合</target>
        </trans-unit>
        <trans-unit id="cbeca9dbec7784436d93a189577fd29e34a7fe37" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock</source>
          <target state="translated">排他的なトランザクションレベルのアドバイザリーロックを取得</target>
        </trans-unit>
        <trans-unit id="b51bd7cdf3315df0e1b538d8f77d94955e4c6d83" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock if available</source>
          <target state="translated">利用可能な場合は、排他的なトランザクションレベルのアドバイザリロックを取得します。</target>
        </trans-unit>
        <trans-unit id="b1ba75ca9786f988af27bd943f8ef875b87406fc" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock</source>
          <target state="translated">共有セッションレベルのアドバイザリロックを取得</target>
        </trans-unit>
        <trans-unit id="4efab6b4a18b953adcf6fcfd9c4e7e2bbeb2b169" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock if available</source>
          <target state="translated">共有セッションレベルのアドバイザリロックがあれば取得する</target>
        </trans-unit>
        <trans-unit id="9524c0b6999d2af997e67edd5b67a8f0eafef7e0" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock</source>
          <target state="translated">共有トランザクションレベルのアドバイザリロックを取得</target>
        </trans-unit>
        <trans-unit id="36c2761c3324c27688dc73a65bc20a430c91b936" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock if available</source>
          <target state="translated">利用可能な場合は、共有トランザクションレベルのアドバイザリロックを取得する</target>
        </trans-unit>
        <trans-unit id="443dac9c78b1145631de0395325a4f37cac34453" translate="yes" xml:space="preserve">
          <source>Obtain the client's operating system user name from the operating system and check if it matches the requested database user name. This is only available for local connections. See &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt; for details.</source>
          <target state="translated">クライアントのオペレーティングシステムのユーザー名をオペレーティングシステムから取得し、要求されたデータベースユーザー名と一致するかどうかを確認します。これはローカル接続でのみ使用できます。詳細は&lt;a href=&quot;auth-peer&quot;&gt;項20.9&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0e679373412300b3d7cf749daeaf3997d4726aac" translate="yes" xml:space="preserve">
          <source>Obtain the operating system user name of the client by contacting the ident server on the client and check if it matches the requested database user name. Ident authentication can only be used on TCP/IP connections. When specified for local connections, peer authentication will be used instead. See &lt;a href=&quot;auth-ident&quot;&gt;Section 20.8&lt;/a&gt; for details.</source>
          <target state="translated">クライアントのidentサーバーにアクセスしてクライアントのオペレーティングシステムユーザー名を取得し、要求されたデータベースユーザー名と一致するかどうかを確認します。Ident認証は、TCP / IP接続でのみ使用できます。ローカル接続に指定すると、代わりにピア認証が使用されます。詳細については、&lt;a href=&quot;auth-ident&quot;&gt;セクション20.8&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3c565c625c5016da01624ee751e9ac2b988301ee" translate="yes" xml:space="preserve">
          <source>Obtaining the next value is done using the &lt;code&gt;nextval()&lt;/code&gt; function instead of the standard's &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression.</source>
          <target state="translated">次の値の取得は、標準の &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 式の代わりに &lt;code&gt;nextval()&lt;/code&gt; 関数を使用して行われます。</target>
        </trans-unit>
        <trans-unit id="77c27c2e821d493cd41fdb16ddcdf94550584d81" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">可能な場合は、共有セッションレベルのアドバイザリロックを取得します。これにより、ロックをすぐに取得して &lt;code&gt;true&lt;/code&gt; を返すか、ロックをすぐに取得できない場合は待機せずに &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="63cc890455fd4316e991288e66cd3d2f6153525e" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock, waiting if necessary.</source>
          <target state="translated">共有セッションレベルのアドバイザリロックを取得し、必要に応じて待機します。</target>
        </trans-unit>
        <trans-unit id="fbea7407ba6bb6ee25b3386cda5d9955692d4486" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">可能な場合は、共有トランザクションレベルのアドバイザリロックを取得します。これにより、ロックをすぐに取得して &lt;code&gt;true&lt;/code&gt; を返すか、ロックをすぐに取得できない場合は待機せずに &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3514ce32dda0a7ae50b8c2a334a5396bb99040f9" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock, waiting if necessary.</source>
          <target state="translated">共有トランザクションレベルのアドバイザリロックを取得し、必要に応じて待機します。</target>
        </trans-unit>
        <trans-unit id="e623c9bebc77403e0def2b4752f5561440ee38bb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">可能な場合は、排他的なセッションレベルのアドバイザリロックを取得します。これにより、ロックをすぐに取得して &lt;code&gt;true&lt;/code&gt; を返すか、ロックをすぐに取得できない場合は待機せずに &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="34d59e1d231b4e0bffcbfc5dcc9980161d2e4fdb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock, waiting if necessary.</source>
          <target state="translated">排他的なセッションレベルのアドバイザリロックを取得し、必要に応じて待機します。</target>
        </trans-unit>
        <trans-unit id="0bbbb737cb62d654d3a0339b01c5ad954c39d181" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">可能な場合は、排他的なトランザクションレベルのアドバイザリロックを取得します。これにより、ロックをすぐに取得して &lt;code&gt;true&lt;/code&gt; を返すか、ロックをすぐに取得できない場合は待機せずに &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="ffd08a954b4fc7be94a0c48f352d297308ce7dc5" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock, waiting if necessary.</source>
          <target state="translated">排他的なトランザクションレベルのアドバイザリロックを取得し、必要に応じて待機します。</target>
        </trans-unit>
        <trans-unit id="6f2c6c6809790186229da7b012c8919a980f66c8" translate="yes" xml:space="preserve">
          <source>Obviously, indexes with non-default sort orderings are a fairly specialized feature, but sometimes they can produce tremendous speedups for certain queries. Whether it's worth maintaining such an index depends on how often you use queries that require a special sort ordering.</source>
          <target state="translated">もちろん、デフォルトではないソート順を持つインデックスはかなり特殊な機能ですが、特定のクエリでは驚異的なスピードアップを実現できることもあります。そのようなインデックスを維持する価値があるかどうかは、特別なソート順を必要とするクエリをどれくらいの頻度で使用するかによります。</target>
        </trans-unit>
        <trans-unit id="eb1f89e656ff03a0a31a91974becb3d200ff4b46" translate="yes" xml:space="preserve">
          <source>Obviously, no one should be accessing the clusters during the upgrade. pg_upgrade defaults to running servers on port 50432 to avoid unintended client connections. You can use the same port number for both clusters when doing an upgrade because the old and new clusters will not be running at the same time. However, when checking an old running server, the old and new port numbers must be different.</source>
          <target state="translated">明らかに、アップグレード中は誰もクラスタにアクセスしてはいけません。 pg_upgradeのデフォルトでは、意図しないクライアント接続を避けるためにポート50432でサーバを実行します。アップグレードを行う際には、古いクラスタと新しいクラスタが同時に実行されることはないので、両方のクラスタで同じポート番号を使用することができます。ただし、古い稼働中のサーバーをチェックする場合は、新旧のポート番号が異なる必要があります。</target>
        </trans-unit>
        <trans-unit id="91a6106fff0646feab85327987f859dce96328f8" translate="yes" xml:space="preserve">
          <source>Obviously, pg_restore cannot restore information that is not present in the archive file. For instance, if the archive was made using the &amp;ldquo;dump data as &lt;code&gt;INSERT&lt;/code&gt; commands&amp;rdquo; option, pg_restore will not be able to load the data using &lt;code&gt;COPY&lt;/code&gt; statements.</source>
          <target state="translated">もちろん、pg_restoreはアーカイブファイルに存在しない情報を復元できません。たとえば、「dump data as &lt;code&gt;INSERT&lt;/code&gt; コマンド」オプションを使用してアーカイブが作成された場合、pg_restoreは &lt;code&gt;COPY&lt;/code&gt; ステートメントを使用してデータをロードできません。</target>
        </trans-unit>
        <trans-unit id="ea9f0a51f8358360ebe5d226327ee6a6dba47689" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least one column value. Null values are considered equal in this comparison.</source>
          <target state="translated">明らかに、少なくとも1つの列の値が異なる場合、2つの行は異なるとみなされます。この比較では、ヌル値は等しいとみなされます。</target>
        </trans-unit>
        <trans-unit id="0325b2d5f9478c521e0c1edeceeab6be935d2d2e" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to mix rules from several locales, e.g., use English collation rules but Spanish messages. To support that, a set of locale subcategories exist that control only certain aspects of the localization rules:</source>
          <target state="translated">時には、複数のロケールのルールを混在させたい場合もあるでしょう。 例えば、英語の照合ルールを使用しているがスペイン語のメッセージを使用するなどです。これをサポートするために、ロケールのサブカテゴリが存在し、 ローカリゼーションルールの特定の側面のみを制御します。</target>
        </trans-unit>
        <trans-unit id="51327aef9866e85ef5b5b2294a28494d2715ae59" translate="yes" xml:space="preserve">
          <source>Oct</source>
          <target state="translated">Oct</target>
        </trans-unit>
        <trans-unit id="87206ae2363483496c099f8c3aac5b4a8ae2a66a" translate="yes" xml:space="preserve">
          <source>October</source>
          <target state="translated">October</target>
        </trans-unit>
        <trans-unit id="c07f133434909a3b139ea6fd5087f84900fccadf" translate="yes" xml:space="preserve">
          <source>Of course, a column can have more than one constraint. Just write the constraints one after another:</source>
          <target state="translated">もちろん、カラムは複数の制約を持つことができます。制約を順番に書いていけばいいだけです。</target>
        </trans-unit>
        <trans-unit id="15554cdfd90fe94a0c248e4f64467a3a5d448ea0" translate="yes" xml:space="preserve">
          <source>Of course, each column must be used with operators appropriate to the index type; clauses that involve other operators will not be considered.</source>
          <target state="translated">もちろん、各列はインデックスの型に適した演算子で使用されなければなりません。</target>
        </trans-unit>
        <trans-unit id="3cfcf640173f2cee55033307859827db1cc0f9ba" translate="yes" xml:space="preserve">
          <source>Of course, if the remote table is not in fact updatable, an error would occur anyway. Use of this option primarily allows the error to be thrown locally without querying the remote server. Note however that the &lt;code&gt;information_schema&lt;/code&gt; views will report a &lt;code&gt;postgres_fdw&lt;/code&gt; foreign table to be updatable (or not) according to the setting of this option, without any check of the remote server.</source>
          <target state="translated">もちろん、リモートテーブルが実際に更新可能でない場合は、エラーが発生します。このオプションを使用すると、リモートサーバーに照会せずにローカルでエラーをスローできます。ただし、 &lt;code&gt;information_schema&lt;/code&gt; ビューは、このオプションの設定に従って &lt;code&gt;postgres_fdw&lt;/code&gt; 外部テーブルが更新可能（またはそうでない）であることを報告し、リモートサーバーのチェックは行いません。</target>
        </trans-unit>
        <trans-unit id="ac88e35965ca0b1056564e9dfa16bc3a086971ee" translate="yes" xml:space="preserve">
          <source>Of course, some SQL database systems might not implement schemas at all, or provide namespace support by allowing (possibly limited) cross-database access. If you need to work with those systems, then maximum portability would be achieved by not using schemas at all.</source>
          <target state="translated">もちろん、SQLデータベースシステムの中にはスキーマを全く実装していなかったり、データベース間の相互アクセスを許可して名前空間をサポートしていなかったりするものもあります(おそらく限定的なものでしょう)。そのようなシステムで作業する必要がある場合は、スキーマを全く使用しないことで最大の移植性を達成することができます。</target>
        </trans-unit>
        <trans-unit id="b09f440f59472b164c47e7153b71ff603597271c" translate="yes" xml:space="preserve">
          <source>Of course, the &lt;code&gt;SELECT&lt;/code&gt; statement is compatible with the SQL standard. But there are some extensions and some missing features.</source>
          <target state="translated">もちろん、 &lt;code&gt;SELECT&lt;/code&gt; ステートメントはSQL標準と互換性があります。しかし、いくつかの拡張機能といくつかの欠けている機能があります。</target>
        </trans-unit>
        <trans-unit id="b998cb5ccff7c6a6d09f60a802fba18afa38d81f" translate="yes" xml:space="preserve">
          <source>Of course, the argument of a sequence function can be an expression as well as a constant. If it is a text expression then the implicit coercion will result in a run-time lookup.</source>
          <target state="translated">もちろん、シーケンス関数の引数は定数だけでなく式にもなります。もしそれがテキスト式であれば、暗黙の強制は実行時のルックアップの結果になります。</target>
        </trans-unit>
        <trans-unit id="c8ec66919586aa50108f55c55fa32064846f02f9" translate="yes" xml:space="preserve">
          <source>Of course, the number and type of the constrained columns need to match the number and type of the referenced columns.</source>
          <target state="translated">もちろん、制約列の数と種類は、参照される列の数と種類と一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="608089afae6cc6682d178112cb3562d38642d49b" translate="yes" xml:space="preserve">
          <source>Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example:</source>
          <target state="translated">もちろん、先ほどの例は非常に工夫されたものでした。通常は、テーブルやカラムに名前を付けて、どのようなデータを保存しているかを伝えます。そこで、より現実的な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cdf2e77434f0f6336db99d58530ea7e875d07b42" translate="yes" xml:space="preserve">
          <source>Of course, the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary between PostgreSQL releases due to planner improvements. In addition, the &lt;code&gt;ANALYZE&lt;/code&gt; command uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run of &lt;code&gt;ANALYZE&lt;/code&gt;, even if the actual distribution of data in the table has not changed.</source>
          <target state="translated">もちろん、ここに表示される具体的な数値は、関連するテーブルの実際の内容によって異なります。また、プランナーの改善により、PostgreSQLのリリース間で、数値や選択したクエリ戦略が異なる場合があることにも注意してください。さらに、 &lt;code&gt;ANALYZE&lt;/code&gt; コマンドはランダムサンプリングを使用してデータ統計を推定します。したがって、テーブル内のデータの実際の分布が変更されていない場合でも、 &lt;code&gt;ANALYZE&lt;/code&gt; を新たに実行した後にコストの見積もりが変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a685091dfb5c40427eaec8e993f66849819cf14d" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.19&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;表9.19&lt;/a&gt;で説明されている文字入力エスケープのうち、XQueryは &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、および &lt;code&gt;\t&lt;/code&gt; のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="c662143ec7a1becd10a1701782d2d5b95c4d60a8" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;表9.20&lt;/a&gt;で説明されている文字入力エスケープのうち、XQueryは &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、および &lt;code&gt;\t&lt;/code&gt; のみをサポートします。</target>
        </trans-unit>
        <trans-unit id="1a7f91ef8e30ab71323f7f16c956192d29cee4ea" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;jsonb&lt;/code&gt;, &lt;code&gt;jsonb_ops&lt;/code&gt; is the default. &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports fewer operators but offers better performance for those operators. See &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; for details.</source>
          <target state="translated">タイプ &lt;code&gt;jsonb&lt;/code&gt; の 2つの演算子クラスのうち、 &lt;code&gt;jsonb_ops&lt;/code&gt; がデフォルトです。 &lt;code&gt;jsonb_path_ops&lt;/code&gt; は、サポートする演算子の数を減らしますが、それらの演算子のパフォーマンスを向上させます。詳細については、&lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;8.14.4項&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="34c9deaa906dcefa70af958d1df36fd494f6477e" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;quad_point_ops&lt;/code&gt; is the default. &lt;code&gt;kd_point_ops&lt;/code&gt; supports the same operators but uses a different index data structure that may offer better performance in some applications.</source>
          <target state="translated">タイプ &lt;code&gt;point&lt;/code&gt; の 2つの演算子クラスのうち、 &lt;code&gt;quad_point_ops&lt;/code&gt; がデフォルトです。 &lt;code&gt;kd_point_ops&lt;/code&gt; は同じ演算子をサポートしますが、アプリケーションによってはより良いパフォーマンスを提供する可能性のある異なるインデックスデータ構造を使用します。</target>
        </trans-unit>
        <trans-unit id="823b07791eec5c49089c2fa31c806093113182bb" translate="yes" xml:space="preserve">
          <source>Of these extensions, &lt;code&gt;jsonb_plperl&lt;/code&gt; is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. The rest require superuser privilege to install.</source>
          <target state="translated">これらの拡張機能のうち、 &lt;code&gt;jsonb_plperl&lt;/code&gt; は「信頼できる」と見なされます。つまり、現在のデータベースに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を持つ非スーパーユーザーがインストールできます。残りはインストールするためにスーパーユーザー特権を必要とします。</target>
        </trans-unit>
        <trans-unit id="ae7fdb11d6c25f66601f3fb8a8f5b8fcc9b0822b" translate="yes" xml:space="preserve">
          <source>Offset from UTC (positive means east of Greenwich)</source>
          <target state="translated">UTCからのオフセット(グリニッジの東側を正の意味)</target>
        </trans-unit>
        <trans-unit id="1981d8aed8642cc19a01ec017cd302822eb99a80" translate="yes" xml:space="preserve">
          <source>Offset to end of free space</source>
          <target state="translated">フリースペースの端にオフセット</target>
        </trans-unit>
        <trans-unit id="e27e1909bffb440ac18ed4f49dfc030d3bf289b3" translate="yes" xml:space="preserve">
          <source>Offset to start of free space</source>
          <target state="translated">フリースペースの開始位置へのオフセット</target>
        </trans-unit>
        <trans-unit id="96263ee552b7638e48664d80735a522bd69e2d15" translate="yes" xml:space="preserve">
          <source>Offset to start of special space</source>
          <target state="translated">特殊空間の開始位置へのオフセット</target>
        </trans-unit>
        <trans-unit id="7f9b46694e3dc059ec6a436a3380fe755ceb8f95" translate="yes" xml:space="preserve">
          <source>Often you will want to create a schema owned by someone else (since this is one of the ways to restrict the activities of your users to well-defined namespaces). The syntax for that is:</source>
          <target state="translated">多くの場合、他の誰かが所有するスキーマを作成したいと思うでしょう (これはユーザーの活動を定義済みの名前空間に制限する方法の 1 つであるため)。そのための構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="aa524be3205ddb773bfe2be8f0cbe395871121b5" translate="yes" xml:space="preserve">
          <source>Okay, the worst has happened and you need to recover from your backup. Here is the procedure:</source>
          <target state="translated">さて、最悪の事態が発生したので、バックアップから復旧する必要があります。その手順をご紹介します。</target>
        </trans-unit>
        <trans-unit id="16be0330fc822ce35047bcbe410657ce60f50c0e" translate="yes" xml:space="preserve">
          <source>Older Linux kernels do not offer &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt;, but may have a previous version of the same functionality called &lt;code&gt;/proc/self/oom_adj&lt;/code&gt;. This works the same except the disable value is &lt;code&gt;-17&lt;/code&gt; not &lt;code&gt;-1000&lt;/code&gt;.</source>
          <target state="translated">古いLinuxカーネルは &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt; を提供していませんが、 &lt;code&gt;/proc/self/oom_adj&lt;/code&gt; と呼ばれる同じ機能の以前のバージョンを持っている場合があります。disable値が &lt;code&gt;-1000&lt;/code&gt; ではなく &lt;code&gt;-17&lt;/code&gt; であることを除いて、これは同じように機能します。</target>
        </trans-unit>
        <trans-unit id="ced6ddc46443201e8e3d960abac900f5903d1b39" translate="yes" xml:space="preserve">
          <source>Older PostgreSQL versions do not have this setting and always use the client's preferences. This setting is mainly for backward compatibility with those versions. Using the server's preferences is usually better because it is more likely that the server is appropriately configured.</source>
          <target state="translated">古いバージョンのPostgreSQLにはこの設定はなく、常にクライアントの環境設定を使用します。この設定は主にそれらのバージョンとの下位互換性のためのものです。サーバの環境設定を使用する方が、サーバが適切に設定されている可能性が高いため、通常はサーバの環境設定を使用する方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="b76ff612400899f457b05452321eac3486e8a6ab" translate="yes" xml:space="preserve">
          <source>Oldest unpruned XMAX on page, or zero if none</source>
          <target state="translated">ページ上で最も古い、剪定されていないXMAX。</target>
        </trans-unit>
        <trans-unit id="794b92ddcf68cabe2809fe5836f4849010daf46d" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、Postgres Professional、モスクワ、ロシア</target>
        </trans-unit>
        <trans-unit id="21c3dce2dbff52b671e09984835bd018b576e577" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Moscow University, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; 、モスクワ、モスクワ大学、ロシア</target>
        </trans-unit>
        <trans-unit id="c57ccf7fdc0e782593eaa681140c5d9ba28fcdd1" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;ROW()&lt;/code&gt; syntax in the common case where only one field needs to be checked to recognize a cycle. This allows a simple array rather than a composite-type array to be used, gaining efficiency.</source>
          <target state="translated">サイクルを認識するために1つのフィールドのみをチェックする必要があるという一般的なケースでは、 &lt;code&gt;ROW()&lt;/code&gt; 構文を省略します。これにより、複合型配列ではなく単純な配列を使用できるようになり、効率が向上します。</target>
        </trans-unit>
        <trans-unit id="263c5dac706b853afb054876ee3140dcdc435cf6" translate="yes" xml:space="preserve">
          <source>Omitted &lt;code&gt;FROM&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の省略</target>
        </trans-unit>
        <trans-unit id="46b3737570e6db5d4ea7e5047dd8b127387b63f0" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;AS&lt;/code&gt; Key Word</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; キーワードの省略</target>
        </trans-unit>
        <trans-unit id="22a45e27f71c292f06706c737b69fd6802e9347f" translate="yes" xml:space="preserve">
          <source>On FreeBSD, IDE drives can be queried using &lt;code&gt;atacontrol&lt;/code&gt; and write caching turned off using &lt;code&gt;hw.ata.wc=0&lt;/code&gt; in &lt;code&gt;/boot/loader.conf&lt;/code&gt;; SCSI drives can be queried using &lt;code&gt;camcontrol identify&lt;/code&gt;, and the write cache both queried and changed using &lt;code&gt;sdparm&lt;/code&gt; when available.</source>
          <target state="translated">FreeBSDでは、IDEドライブは &lt;code&gt;atacontrol&lt;/code&gt; を使用して照会でき、書き込みは &lt;code&gt;/boot/loader.conf&lt;/code&gt; の &lt;code&gt;hw.ata.wc=0&lt;/code&gt; を使用してオフにできます。SCSIドライブは、 &lt;code&gt;camcontrol identify&lt;/code&gt; を使用して照会でき、書き込みキャッシュは、使用可能な場合は &lt;code&gt;sdparm&lt;/code&gt; を使用して照会および変更できます。</target>
        </trans-unit>
        <trans-unit id="d39ed9f52193cbb9703d5a56c5956b148e841314" translate="yes" xml:space="preserve">
          <source>On Linux 2.6 and later, it is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">Linux 2.6以降では、メモリを「オーバーコミット」しないようにカーネルの動作を変更することができます。この設定によって&lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOMキラー&lt;/a&gt;が完全に呼び出されるのを防ぐことはできませんが、可能性が大幅に低下するため、システムの動作がより堅牢になります。これは、 &lt;code&gt;sysctl&lt;/code&gt; を介して厳密なオーバーコミットモードを選択することによって行われます。</target>
        </trans-unit>
        <trans-unit id="501ddfe2d2530fe9fcac7688b14da5778270cdb1" translate="yes" xml:space="preserve">
          <source>On Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; determines the maximum number of open files that the kernel will support. It can be changed by writing a different number into the file or by adding an assignment in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. The maximum limit of files per process is fixed at the time the kernel is compiled; see &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; for more information.</source>
          <target state="translated">Linuxでは、 &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; は、カーネルがサポートするオープンファイルの最大数を決定します。これは、ファイルに別の番号を書き込むか、/ &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 割り当てを追加することで変更できます。プロセスあたりのファイルの最大数は、カーネルのコンパイル時に固定されています。詳細については、/ &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f009fe3fb04da9e8adcc93565c99cbfd73e2affe" translate="yes" xml:space="preserve">
          <source>On Linux and POSIX platforms &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; allows to force the OS that pages written by the checkpoint should be flushed to disk after a configurable number of bytes. Otherwise, these pages may be kept in the OS's page cache, inducing a stall when &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint. This setting will often help to reduce transaction latency, but it also can have an adverse effect on performance; particularly for workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache.</source>
          <target state="translated">LinuxおよびPOSIXプラットフォームでは、&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_afterを&lt;/a&gt;使用すると、チェックポイントによって書き込まれたページを、構成可能なバイト数の後にディスクにフラッシュすることをOSに強制できます。そうしないと、これらのページがOSのページキャッシュに保持され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたときにストールが発生する可能性があります。この設定は、多くの場合、トランザクションの待ち時間を短縮するのに役立ちますが、パフォーマンスに悪影響を与える可能性もあります。特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;よりも大きいが、OSのページキャッシュよりは小さいワークロードの場合。</target>
        </trans-unit>
        <trans-unit id="c936f58f7f62e48372e8a8076ff322928b68bb04" translate="yes" xml:space="preserve">
          <source>On Linux or Unix systems, you might use:</source>
          <target state="translated">LinuxやUnixシステムでは、使用するかもしれません。</target>
        </trans-unit>
        <trans-unit id="3f7c8c1bd4d71387a1210efd816cb3bef4ae3f74" translate="yes" xml:space="preserve">
          <source>On Linux systems either add</source>
          <target state="translated">Linuxシステムでは</target>
        </trans-unit>
        <trans-unit id="dc805fd8588880f607d3f4520d6ee5e450aee68a" translate="yes" xml:space="preserve">
          <source>On Linux, IDE and SATA drives can be queried using &lt;code&gt;hdparm -I&lt;/code&gt;; write caching is enabled if there is a &lt;code&gt;*&lt;/code&gt; next to &lt;code&gt;Write cache&lt;/code&gt;. &lt;code&gt;hdparm -W 0&lt;/code&gt; can be used to turn off write caching. SCSI drives can be queried using &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;. Use &lt;code&gt;sdparm --get=WCE&lt;/code&gt; to check whether the write cache is enabled and &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; to disable it.</source>
          <target state="translated">Linuxでは、IDEおよびSATAドライブは &lt;code&gt;hdparm -I&lt;/code&gt; を使用して照会できます。ある場合は、書き込みキャッシュが有効になっている &lt;code&gt;*&lt;/code&gt; 次へ &lt;code&gt;Write cache&lt;/code&gt; 。 &lt;code&gt;hdparm -W 0&lt;/code&gt; を使用して、書き込みキャッシュをオフにすることができます。SCSIドライブは&lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;を使用して照会できます。 &lt;code&gt;sdparm --get=WCE&lt;/code&gt; を使用して書き込みキャッシュが有効かどうかを確認し、 &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; を使用して無効にします。</target>
        </trans-unit>
        <trans-unit id="55da6c1d848d4260b86ebf92495a2847786e7138" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, also:</source>
          <target state="translated">Microsoft Windowsでも。</target>
        </trans-unit>
        <trans-unit id="3630213a83c6eeeff64f72e78908e323507bf7bd" translate="yes" xml:space="preserve">
          <source>On NetBSD, use either the FreeBSD or Linux start scripts, depending on preference.</source>
          <target state="translated">NetBSD では、好みに応じて FreeBSD または Linux の起動スクリプトを使用してください。</target>
        </trans-unit>
        <trans-unit id="ba742d094af1abbc78f9a3859fd3be730c7188af" translate="yes" xml:space="preserve">
          <source>On OpenBSD, add the following lines to the file &lt;code&gt;/etc/rc.local&lt;/code&gt;:</source>
          <target state="translated">OpenBSDでは、次の行をファイル &lt;code&gt;/etc/rc.local&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="6c2c1726b1c50e52c768b284b11ed29bfb8afb96" translate="yes" xml:space="preserve">
          <source>On Solaris, create a file called &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; that contains the following line:</source>
          <target state="translated">Solarisでは、次の行を含む &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; というファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="2bb8949d83fc7ef1475b557895bfe563a925aea9" translate="yes" xml:space="preserve">
          <source>On Solaris, the disk write cache is controlled by &lt;code&gt;format -e&lt;/code&gt;. (The Solaris ZFS file system is safe with disk write-cache enabled because it issues its own disk cache flush commands.)</source>
          <target state="translated">Solarisでは、ディスク書き込みキャッシュは &lt;code&gt;format -e&lt;/code&gt; によって制御されます。（Solaris ZFSファイルシステムは、独自のディスクキャッシュフラッシュコマンドを発行するため、ディスク書き込みキャッシュを有効にしても安全です。）</target>
        </trans-unit>
        <trans-unit id="d85af98780490009a295939145f84e031804f11c" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter reports the permissions of the data directory defined by (&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;) at startup. (On Microsoft Windows this parameter will always display &lt;code&gt;0700&lt;/code&gt;). See &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;group access&lt;/a&gt; for more information.</source>
          <target state="translated">Unixシステムでは、このパラメーターは、起動時に（&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;）によって定義されたデータディレクトリの権限を報告します。（Microsoft Windowsでは、このパラメーターは常に &lt;code&gt;0700&lt;/code&gt; を表示します）。詳細については、&lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;グループアクセス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5d93a70eed193dd90ef032ea7d63d19a6516eb0a" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter sets the permissions for log files when &lt;code&gt;logging_collector&lt;/code&gt; is enabled. (On Microsoft Windows this parameter is ignored.) The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="translated">Unixシステムでは、 &lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターはログファイルの権限を設定します。 （Microsoft Windowsでは、このパラメーターは無視されます。）パラメーター値は、 &lt;code&gt;chmod&lt;/code&gt; および &lt;code&gt;umask&lt;/code&gt; システムコールで受け入れられる形式で指定された数値モードであることが期待されています。 （通常の8進形式を使用するには、数値は &lt;code&gt;0&lt;/code&gt; （ゼロ）で始まる必要があります。）</target>
        </trans-unit>
        <trans-unit id="aec768083a143a16efefa19e77bcef93265299f5" translate="yes" xml:space="preserve">
          <source>On Unix systems, the permissions on &lt;code&gt;server.key&lt;/code&gt; must disallow any access to world or group; achieve this by the command &lt;code&gt;chmod 0600 server.key&lt;/code&gt;. Alternatively, the file can be owned by root and have group read access (that is, &lt;code&gt;0640&lt;/code&gt; permissions). That setup is intended for installations where certificate and key files are managed by the operating system. The user under which the PostgreSQL server runs should then be made a member of the group that has access to those certificate and key files.</source>
          <target state="translated">Unixシステムでは、 &lt;code&gt;server.key&lt;/code&gt; の権限は、ワールドまたはグループへのアクセスをすべて許可しない必要があります。コマンド &lt;code&gt;chmod 0600 server.key&lt;/code&gt; でこれを実現します。または、ファイルをrootが所有し、グループに読み取りアクセス権（つまり &lt;code&gt;0640&lt;/code&gt; 権限）を付与することもできます。このセットアップは、証明書とキーファイルがオペレーティングシステムによって管理されるインストールを対象としています。次に、PostgreSQLサーバーを実行するユーザーを、それらの証明書とキーファイルにアクセスできるグループのメンバーにする必要があります。</target>
        </trans-unit>
        <trans-unit id="e0de69e7d7ec6add644868e783650d15d55a6f2e" translate="yes" xml:space="preserve">
          <source>On Windows hosts, preloading a library at server start will not reduce the time required to start each new server process; each server process will re-load all preload libraries. However, &lt;code&gt;shared_preload_libraries&lt;/code&gt; is still useful on Windows hosts for libraries that need to perform operations at postmaster start time.</source>
          <target state="translated">Windowsホストでは、サーバーの起動時にライブラリをプリロードしても、新しい各サーバープロセスの起動に必要な時間は短縮されません。各サーバープロセスは、すべてのプリロードライブラリを再ロードします。ただし、 &lt;code&gt;shared_preload_libraries&lt;/code&gt; 開始時に操作を実行する必要があるライブラリーのWindowsホストでは、shared_preload_librariesが引き続き役立ちます。</target>
        </trans-unit>
        <trans-unit id="08c92789aa023ae69cee69a7db7a2ae77f278c4c" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;wal_sync_method&lt;/code&gt; is &lt;code&gt;open_datasync&lt;/code&gt; (the default), write caching can be disabled by unchecking &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt;. Alternatively, set &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync&lt;/code&gt; or &lt;code&gt;fsync_writethrough&lt;/code&gt;, which prevent write caching.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;wal_sync_method&lt;/code&gt; が &lt;code&gt;open_datasync&lt;/code&gt; （デフォルト）の場合、 &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt; cache on the diskのチェックを外すと、書き込みキャッシュを無効にできます。また、セット &lt;code&gt;wal_sync_method&lt;/code&gt; へ &lt;code&gt;fsync&lt;/code&gt; または &lt;code&gt;fsync_writethrough&lt;/code&gt; で書き込みキャッシュを防ぐため、。</target>
        </trans-unit>
        <trans-unit id="81eec3e42d4f18ead15b1e929550fb213358fb1f" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 1 second, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">Windowsでは、システムのデフォルト値を読み取る方法がないため、値を0に設定すると、このパラメータは1秒に設定されます。</target>
        </trans-unit>
        <trans-unit id="53478c470af75305cb8745b03e7cb49bde700061" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 2 hours, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">Windowsでは、システムのデフォルト値を読み取る方法がないため、値を0に設定すると、このパラメータは2時間に設定されます。</target>
        </trans-unit>
        <trans-unit id="c0312ea0b4215b07b7b0ad5539831203f3c1aa4d" translate="yes" xml:space="preserve">
          <source>On Windows, when you use the &lt;code&gt;eventlog&lt;/code&gt; option for &lt;code&gt;log_destination&lt;/code&gt;, you should register an event source and its library with the operating system so that the Windows Event Viewer can display event log messages cleanly. See &lt;a href=&quot;event-log-registration&quot;&gt;Section 18.12&lt;/a&gt; for details.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;log_destination&lt;/code&gt; に &lt;code&gt;eventlog&lt;/code&gt; オプションを使用する場合、イベントソースとそのライブラリをオペレーティングシステムに登録して、Windowsイベントビューアがイベントログメッセージをきれいに表示できるようにする必要があります。詳細は&lt;a href=&quot;event-log-registration&quot;&gt;項18.12&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fed4544374a90927980cc01194ee5bade4dcaae9" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;flushed_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">ホットスタンバイでは、WALレシーバープロセスのステータスは、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt; &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; &lt;/a&gt;ビューを介して取得できます。 &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; とビューの &lt;code&gt;flushed_lsn&lt;/code&gt; の大きな違いは、WALが再生可能よりも速く受信されていることを示しています。</target>
        </trans-unit>
        <trans-unit id="b5ae51b938e943ee6107b7e5c25bdb8c42c5ee40" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;received_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">ホットスタンバイでは、&lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt;ビューを介してWALレシーバープロセスのステータスを取得できます。 &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; とビューの &lt;code&gt;received_lsn&lt;/code&gt; の大きな違いは、WALが再生よりも速く受信されていることを示しています。</target>
        </trans-unit>
        <trans-unit id="a87ef11e5bf076fa4c6ca218448b2458c3ebe4c9" translate="yes" xml:space="preserve">
          <source>On all currently supported platforms, the &lt;code&gt;real&lt;/code&gt; type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The &lt;code&gt;double precision&lt;/code&gt; type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</source>
          <target state="translated">現在サポートされているすべてのプラットフォームで、 &lt;code&gt;real&lt;/code&gt; 型の範囲は約1E-37から1E + 37で、精度は少なくとも10進数です。 &lt;code&gt;double precision&lt;/code&gt; 型は、少なくとも15桁の精度で1E + 308の周りの1E-307の範囲を有します。値が大きすぎたり小さすぎたりすると、エラーが発生します。入力数値の精度が高すぎる場合、丸めが行われる可能性があります。ゼロとは異なり、表現できないゼロに近すぎる数値は、アンダーフローエラーの原因になります。</target>
        </trans-unit>
        <trans-unit id="fc9f60ea02e43afcbb3f8733c606556d9627a339" translate="yes" xml:space="preserve">
          <source>On all platforms, the collations named &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; are available. Additional collations may be available depending on operating system support. The &lt;code&gt;default&lt;/code&gt; collation selects the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; values specified at database creation time. The &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations both specify &amp;ldquo;traditional C&amp;rdquo; behavior, in which only the ASCII letters &amp;ldquo;&lt;code&gt;A&lt;/code&gt;&amp;rdquo; through &amp;ldquo;&lt;code&gt;Z&lt;/code&gt;&amp;rdquo; are treated as letters, and sorting is done strictly by character code byte values.</source>
          <target state="translated">すべてのプラットフォームで、 &lt;code&gt;default&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、および &lt;code&gt;POSIX&lt;/code&gt; という名前の照合が使用可能です。オペレーティングシステムのサポートによっては、追加の照合が使用できる場合があります。 &lt;code&gt;default&lt;/code&gt; 照合が選択 &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の値は、データベースの作成時に指定しました。 &lt;code&gt;C&lt;/code&gt; と &lt;code&gt;POSIX&lt;/code&gt; 照合のみASCII文字「とは、「伝統的なC」挙動、指定両方 &lt;code&gt;A&lt;/code&gt; 」から「 &lt;code&gt;Z&lt;/code&gt; が」文字として扱われ、ソートは、文字コードのバイト値によって厳密に行われています。</target>
        </trans-unit>
        <trans-unit id="1c0634f5bf5f884787664141e116cb74ad234b48" translate="yes" xml:space="preserve">
          <source>On error, the server can abort the authentication at any stage, and send an ErrorMessage.</source>
          <target state="translated">エラーが発生した場合、サーバは任意の段階で認証を中止し、ErrorMessageを送信することができます。</target>
        </trans-unit>
        <trans-unit id="5350086780663aaf1bd7a44ba47818175298a073" translate="yes" xml:space="preserve">
          <source>On macOS, write caching can be prevented by setting &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync_writethrough&lt;/code&gt;.</source>
          <target state="translated">macOSでは、 &lt;code&gt;wal_sync_method&lt;/code&gt; を &lt;code&gt;fsync_writethrough&lt;/code&gt; に設定することにより、書き込みキャッシュを防止できます。</target>
        </trans-unit>
        <trans-unit id="befd8f0dca607b26fc6d2d970cd74ce25f6b225a" translate="yes" xml:space="preserve">
          <source>On many systems, however, syslog is not very reliable, particularly with large log messages; it might truncate or drop messages just when you need them the most. Also, on Linux, syslog will flush each message to disk, yielding poor performance. (You can use a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; at the start of the file name in the syslog configuration file to disable syncing.)</source>
          <target state="translated">ただし、多くのシステムでは、特に大きなログメッセージの場合、syslogの信頼性はあまり高くありません。最も必要なときにだけメッセージを切り捨てるか、ドロップする可能性があります。また、Linuxでは、syslogが各メッセージをディスクにフラッシュするため、パフォーマンスが低下します。（syslog構成ファイルのファイル名の先頭に「 &lt;code&gt;-&lt;/code&gt; 」を使用して、同期を無効にすることができます。）</target>
        </trans-unit>
        <trans-unit id="cb6093f7e35a1c20e326af32dcefbf608a486601" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, PostgreSQL modifies its command title as reported by &lt;code&gt;ps&lt;/code&gt;, so that individual server processes can readily be identified. A sample display is</source>
          <target state="translated">ほとんどのUnixプラットフォームでは、PostgreSQLは &lt;code&gt;ps&lt;/code&gt; によって報告されたコマンドタイトルを変更するため、個々のサーバープロセスを簡単に識別できます。表示例は</target>
        </trans-unit>
        <trans-unit id="d3b91e78aa6712803e0d5864f8e480013e5bf3c9" translate="yes" xml:space="preserve">
          <source>On most Unix systems, you will need to alter the configuration of your system's syslog daemon in order to make use of the syslog option for &lt;code&gt;log_destination&lt;/code&gt;. PostgreSQL can log to syslog facilities &lt;code&gt;LOCAL0&lt;/code&gt; through &lt;code&gt;LOCAL7&lt;/code&gt; (see &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;), but the default syslog configuration on most platforms will discard all such messages. You will need to add something like:</source>
          <target state="translated">ほとんどのUnixシステムでは、 &lt;code&gt;log_destination&lt;/code&gt; の syslogオプションを利用するために、システムのsyslogデーモンの構成を変更する必要があります。 PostgreSQLはsyslogのファシリティにログインすることができます &lt;code&gt;LOCAL0&lt;/code&gt; を通じて &lt;code&gt;LOCAL7&lt;/code&gt; （参照&lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;SYSLOG_FACILITYを&lt;/a&gt;）が、ほとんどのプラットフォームのデフォルトのsyslog設定では、すべてのそのようなメッセージを破棄します。次のようなものを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="50e3c6b1dcc491688ab2b7696ca3d74d8a9db77d" translate="yes" xml:space="preserve">
          <source>On most modern operating systems, PostgreSQL can determine which character set is implied by the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting.</source>
          <target state="translated">最近のほとんどのオペレーティングシステムでは、PostgreSQLは &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定によってどの文字セットが暗示されるかを判別でき、一致するデータベースエンコーディングのみが使用されるように強制します。古いシステムでは、選択したロケールで想定されているエンコーディングを使用するようにする必要があります。この領域での間違いは、ソートなどのロケールに依存する操作の奇妙な動作につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b2260de2d5df529fa47da0a7e6dd5d8bb23e03ee" translate="yes" xml:space="preserve">
          <source>On most platforms, if PostgreSQL is built with &lt;code&gt;--enable-dtrace&lt;/code&gt;, the arguments to a trace macro will be evaluated whenever control passes through the macro, &lt;em&gt;even if no tracing is being done&lt;/em&gt;. This is usually not worth worrying about if you are just reporting the values of a few local variables. But beware of putting expensive function calls into the arguments. If you need to do that, consider protecting the macro with a check to see if the trace is actually enabled:</source>
          <target state="translated">ほとんどのプラットフォームでは、PostgreSQLが &lt;code&gt;--enable-dtrace&lt;/code&gt; を使用してビルドされ&lt;em&gt;ている場合、トレースが実行されていなくても&lt;/em&gt;、制御がマクロを通過するたびにトレースマクロへの引数が評価&lt;em&gt;され&lt;/em&gt;ます。いくつかのローカル変数の値をレポートするだけの場合、これは通常心配する価値はありません。ただし、引数に高価な関数呼び出しを含めることに注意してください。これを行う必要がある場合は、チェックを使用してマクロを保護し、トレースが実際に有効になっているかどうかを確認することを検討してください。</target>
        </trans-unit>
        <trans-unit id="d1a020e1e97e31739abdd2c2ef2354878b9e297e" translate="yes" xml:space="preserve">
          <source>On one system, an &lt;code&gt;EXPLAIN&lt;/code&gt; showed a query with a cost of 8488 was reduced to a cost of 329. The original query was a join involving the &lt;code&gt;one_to_many&lt;/code&gt; table, which was replaced by:</source>
          <target state="translated">1つのシステムで、 &lt;code&gt;EXPLAIN&lt;/code&gt; は8488のコストのクエリが329のコストに削減されたことを示しました。元のクエリは、 &lt;code&gt;one_to_many&lt;/code&gt; テーブルを含む結合でした。</target>
        </trans-unit>
        <trans-unit id="46913037bc93da8c08a056c91624219985822221" translate="yes" xml:space="preserve">
          <source>On output, double quotes always surround keys and values, even when it's not strictly necessary.</source>
          <target state="translated">出力では、二重引用符は、厳密には必要でない場合でも、常にキーと値を囲みます。</target>
        </trans-unit>
        <trans-unit id="bac2b8b67734755e62d6acef24655269b5ebc6a2" translate="yes" xml:space="preserve">
          <source>On some newer Linux systems, it's possible to change the clock source used to collect timing data at any time. A second example shows the slowdown possible from switching to the slower acpi_pm time source, on the same system used for the fast results above:</source>
          <target state="translated">いくつかの新しい Linux システムでは、タイミングデータの収集に使用するクロックソースをいつでも変更することができます。2 番目の例は、上記の高速な結果に使用したのと同じシステムで、遅い acpi_pm のタイムソースに切り替えた場合のスローダウンを示しています。</target>
        </trans-unit>
        <trans-unit id="9ce5931c68b8a455769ec944aab5c902a50f0a9b" translate="yes" xml:space="preserve">
          <source>On some operating systems, the status of data in the kernel's page cache is unknown after a write-back failure. In some cases it might have been entirely forgotten, making it unsafe to retry; the second attempt may be reported as successful, when in fact the data has been lost. In these circumstances, the only way to avoid data loss is to recover from the WAL after any failure is reported, preferably after investigating the root cause of the failure and replacing any faulty hardware.</source>
          <target state="translated">オペレーティングシステムによっては、書き込みに失敗した後、カーネルのページキャッシュ内のデータの状態が不明な場合があります。場合によっては、データが完全に忘れ去られていて、再試行が安全でないこともあります。このような状況では、データの損失を避ける唯一の方法は、障害が報告された後、障害の根本原因を調査し、障害のあるハードウェアを交換した後に、WALから回復することです。</target>
        </trans-unit>
        <trans-unit id="eee21b404ba214868f7afb4e8cb293a79759405b" translate="yes" xml:space="preserve">
          <source>On some systems, this locale category does not exist. Setting this variable will still work, but there will be no effect. Also, there is a chance that no translated messages for the desired language exist. In that case you will continue to see the English messages.</source>
          <target state="translated">システムによっては、このロケールカテゴリが存在しない場合があります。この変数を設定しても動作しますが、何の効果もありません。また、希望する言語に翻訳されたメッセージが存在しない可能性もあります。その場合、英語のメッセージが表示され続けます。</target>
        </trans-unit>
        <trans-unit id="d8426bc3d71cab36b2e69aeb3bfdd7499b750f4a" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*recheck&lt;/code&gt; should be set to true if the heap tuple needs to be rechecked against the query operator, or false if the index test is exact. That is, a false return value guarantees that the heap tuple does not match the query; a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to false guarantees that the heap tuple does match the query; and a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to true means that the heap tuple might match the query, so it needs to be fetched and rechecked by evaluating the query operator directly against the originally indexed item.</source>
          <target state="translated">成功した場合、ヒープタプルをクエリ演算子に対して再チェックする必要がある場合は &lt;code&gt;*recheck&lt;/code&gt; をtrueに設定し、インデックステストが正確な場合はfalseに設定する必要があります。つまり、falseの戻り値は、ヒープタプルがクエリと一致しないことを保証します。 &lt;code&gt;*recheck&lt;/code&gt; がfalseに設定されたtrueの戻り値は、ヒープタプルがクエリに一致することを保証します。 &lt;code&gt;*recheck&lt;/code&gt; がtrueに設定されたtrueの戻り値は、ヒープタプルがクエリと一致する可能性があることを意味します。そのため、クエリ演算子を最初にインデックス付けされたアイテムに対して直接評価することにより、フェッチして再チェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="471ab7df5323b9c1beeab9b6ad11a4a3d81ba199" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;COPY&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;COPY&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="a330b5f61b3e5eaefa54001cda5edd47cd225306" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;DELETE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;DELETE&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="606df5c042bda87282091ed6e870632af55a409b" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;FETCH&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;FETCH&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="522cefa61331276f75d9354dde07beed068c55b2" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;MOVE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;MOVE&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="10a00a825ef1af18a74c6369608739640c2c6694" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;INSERT&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;INSERT&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="adea3b7cb9bb8d678c08759a0633a3db722c1eb8" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;UPDATE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="17c3054fe4ff4e4031ec1aca452c9f2fbf414b42" translate="yes" xml:space="preserve">
          <source>On systems that have PostgreSQL started at boot time, there is probably a start-up file that will accomplish the same thing. For example, on a Red Hat Linux system one might find that this works:</source>
          <target state="translated">ブート時にPostgreSQLを起動するシステムでは、おそらく同じことを行う起動ファイルがあるでしょう。例えば、Red Hat Linuxシステムでは、これが動作していることがわかるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5c79b94518a5311140dc7e0d3b2812f742d2b393" translate="yes" xml:space="preserve">
          <source>On systems that support the keepalive socket option, setting &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;, &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; helps the primary promptly notice a broken connection.</source>
          <target state="translated">キープアライブソケットオプションをサポートするシステムでは、&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;、&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt;、および&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt;を設定すると、プライマリが接続の切断に迅速に気付くのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1fa1a4c2c8b8530e986a78ada66b4ce0e77848ad" translate="yes" xml:space="preserve">
          <source>On systems with less than 1GB of RAM, a smaller percentage of RAM is appropriate, so as to leave adequate space for the operating system.</source>
          <target state="translated">RAMが1GB未満のシステムでは、オペレーティングシステムのための十分なスペースを残すために、RAMの割合を小さくすることが適切です。</target>
        </trans-unit>
        <trans-unit id="f7c83da74a1e6d13c844e01daa0931d96bf79bb8" translate="yes" xml:space="preserve">
          <source>On that date, there were two possible interpretations of 2:30AM; there was 2:30AM EDT, and then an hour later after the reversion to standard time, there was 2:30AM EST. Again, PostgreSQL interprets the given time as if it were standard time (UTC-5). We can force the matter by specifying daylight-savings time:</source>
          <target state="translated">その日の午前2時30分には2つの解釈が考えられます。午前2時30分EDTと、標準時に戻ってから1時間後に午前2時30分ESTとなりました。ここでもPostgreSQLは、与えられた時間をあたかも標準時(UTC-5)であるかのように解釈します。サマータイムを指定することで、この問題を強制的に解決することができます。</target>
        </trans-unit>
        <trans-unit id="108bc1acbd3eb627957c49ac13cf1805b058d6fd" translate="yes" xml:space="preserve">
          <source>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</source>
          <target state="translated">一方、JSON存在演算子は入れ子になっていないので、JSON値の最上位で指定されたキーや配列要素のみを探します。</target>
        </trans-unit>
        <trans-unit id="0944856f78282776625887773317f5e5a29f6901" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet:</source>
          <target state="translated">一方、以下のクエリは、州都ではなく、標高500フィート以上の場所にあるすべての都市を検索します。</target>
        </trans-unit>
        <trans-unit id="dc15ca0265b44e308c416ac01f3b8fd4dd23be18" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an elevation over 500 feet:</source>
          <target state="translated">一方、以下のクエリは、州都ではなく、標高500フィート以上の場所にあるすべての都市を検索します。</target>
        </trans-unit>
        <trans-unit id="8d66d041f4d766c1f0ee27254b9b736aa4e0885c" translate="yes" xml:space="preserve">
          <source>On the other hand, the prefix operator &lt;code&gt;~&lt;/code&gt; (bitwise negation) is defined only for integer data types, not for &lt;code&gt;float8&lt;/code&gt;. So, if we try a similar case with &lt;code&gt;~&lt;/code&gt;, we get:</source>
          <target state="translated">一方、接頭辞演算子 &lt;code&gt;~&lt;/code&gt; （ビットごとの否定）は、整数データ型に対してのみ定義され、 &lt;code&gt;float8&lt;/code&gt; に対しては定義されません。したがって、 &lt;code&gt;~&lt;/code&gt; で同様のケースを試すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e3fb0b420bf61dd2f01fedc471af93946522a689" translate="yes" xml:space="preserve">
          <source>On the other hand, the structurally similar case</source>
          <target state="translated">一方、構造的に類似している場合</target>
        </trans-unit>
        <trans-unit id="aa512d53935676cc08f57c9480c2f5a40cb3a7f6" translate="yes" xml:space="preserve">
          <source>On the other side of the coin, some systems allow individual processes to open large numbers of files; if more than a few processes do so then the system-wide limit can easily be exceeded. If you find this happening, and you do not want to alter the system-wide limit, you can set PostgreSQL's &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; configuration parameter to limit the consumption of open files.</source>
          <target state="translated">反対に、一部のシステムでは、個々のプロセスが多数のファイルを開くことができます。いくつかのプロセスがそうする場合、システム全体の制限を簡単に超える可能性があります。これが発生していて、システム全体の制限を変更したくない場合は、PostgreSQLの&lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt;構成パラメーターを設定して、開いているファイルの消費を制限できます。</target>
        </trans-unit>
        <trans-unit id="e90706123ac00808e07c484e32d4635f07e67a74" translate="yes" xml:space="preserve">
          <source>On the primary server, these cases simply result in waiting; and the user might choose to cancel either of the conflicting actions. However, on the standby there is no choice: the WAL-logged action already occurred on the primary so the standby must not fail to apply it. Furthermore, allowing WAL application to wait indefinitely may be very undesirable, because the standby's state will become increasingly far behind the primary's. Therefore, a mechanism is provided to forcibly cancel standby queries that conflict with to-be-applied WAL records.</source>
          <target state="translated">プライマリサーバでは、これらのケースは単に待機状態になるだけであり、ユーザは相反するアクションのいずれかをキャンセルすることを選ぶかもしれない。しかし、スタンバイ側では選択の余地はありません。WALがログに記録されたアクションはプライマリ側で既に発生しているので、スタンバイ側ではその適用に失敗してはいけません。さらに、WALの適用を無期限に待機させることは、スタンバイの状態がプライマリの状態よりもずっと遅れてしまうので、非常に望ましくないかもしれません。そこで、適用されるべきWALレコードと競合するスタンバイクエリを強制的にキャンセルする仕組みが提供されています。</target>
        </trans-unit>
        <trans-unit id="12047b5caa5d65a62660b71617de0d4a759ef067" translate="yes" xml:space="preserve">
          <source>On the primary, parameters &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; have no effect if set on the primary.</source>
          <target state="translated">プライマリでは、パラメータ&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;を使用できます。&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;と&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;は、プライマリで設定しても効果がありません。</target>
        </trans-unit>
        <trans-unit id="f4d2789c0f0275ad798be7e6d4e299236ebe91e1" translate="yes" xml:space="preserve">
          <source>On the publisher side, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;max_replication_slots&lt;/code&gt; must be set to at least the number of subscriptions expected to connect, plus some reserve for table synchronization. And &lt;code&gt;max_wal_senders&lt;/code&gt; should be set to at least the same as &lt;code&gt;max_replication_slots&lt;/code&gt; plus the number of physical replicas that are connected at the same time.</source>
          <target state="translated">出版社側では、 &lt;code&gt;wal_level&lt;/code&gt; をに設定する必要があります &lt;code&gt;logical&lt;/code&gt; 、および &lt;code&gt;max_replication_slots&lt;/code&gt; は少なくとも接続することが予想サブスクリプションの数に加え、テーブルの同期のためのいくつかの予備に設定する必要があります。また、 &lt;code&gt;max_wal_senders&lt;/code&gt; は、少なくとも &lt;code&gt;max_replication_slots&lt;/code&gt; と、同時に接続されている物理レプリカの数を足したものと同じに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="35745b04684e80ded8dc5507c072fa2674283617" translate="yes" xml:space="preserve">
          <source>On the standby, parameters &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; has no effect as long as the server remains in standby mode, though it will become relevant if the standby becomes primary.</source>
          <target state="translated">スタンバイでは、パラメータ&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;、&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;を使用できます。&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;は、サーバーがスタンバイモードである限り効果がありませんが、スタンバイがプライマリになると関連性が出てきます。</target>
        </trans-unit>
        <trans-unit id="70715c6fbe3e407765f6386cd308c88b6865cc56" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;UNLISTEN&lt;/code&gt; has been executed, further &lt;code&gt;NOTIFY&lt;/code&gt; messages will be ignored:</source>
          <target state="translated">一度 &lt;code&gt;UNLISTEN&lt;/code&gt; が実行された、更なる &lt;code&gt;NOTIFY&lt;/code&gt; メッセージは無視されます。</target>
        </trans-unit>
        <trans-unit id="ec65ec416b46f0c02b02945a4d9803e7d39332ca" translate="yes" xml:space="preserve">
          <source>Once a client is connected to the database, PostgreSQL provides two additional SQL commands (and equivalent functions) to interact with session-local configuration settings:</source>
          <target state="translated">クライアントがデータベースに接続されると、PostgreSQLはセッションローカルの設定と対話するための2つの追加SQLコマンド(および同等の関数)を提供します。</target>
        </trans-unit>
        <trans-unit id="356c49cf82618dc4e123a48d759d153fd0e38847" translate="yes" xml:space="preserve">
          <source>Once a connection is established the client process can send a query to the &lt;em&gt;backend&lt;/em&gt; (server). The query is transmitted using plain text, i.e., there is no parsing done in the &lt;em&gt;frontend&lt;/em&gt; (client). The server parses the query, creates an &lt;em&gt;execution plan&lt;/em&gt;, executes the plan and returns the retrieved rows to the client by transmitting them over the established connection.</source>
          <target state="translated">接続が確立されると、クライアントプロセスはクエリを&lt;em&gt;バックエンド&lt;/em&gt;（サーバー）に送信できます。クエリはプレーンテキストを使用して送信されます。つまり、&lt;em&gt;フロントエンド&lt;/em&gt;（クライアント）で解析は行われません。サーバーはクエリを解析し、&lt;em&gt;実行プランを&lt;/em&gt;作成し、&lt;em&gt;プラン&lt;/em&gt;を実行し、確立された接続を介してそれらを送信することにより、取得した行をクライアントに返します。</target>
        </trans-unit>
        <trans-unit id="5ad9c4a6213a012c3300efd580e40047d30505b8" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held till end of transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">いったん獲得されると、ロックは通常、トランザクションの終わりまで保持されます。ただし、セーブポイントの確立後にロックが取得された場合、セーブポイントがロールバックされるとすぐにロックが解除されます。これは、セーブポイント以降、 &lt;code&gt;ROLLBACK&lt;/code&gt; がコマンドのすべての効果をキャンセルするという原則と一致しています。 PL / pgSQL例外ブロック内で取得されたロックについても同様です。ブロックからのエラーエスケープは、ブロック内で取得されたロックを解放します。</target>
        </trans-unit>
        <trans-unit id="f6e9243ef6651a8f1bff8b046ab3cebbec0d9033" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held until the end of the transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">取得されると、ロックは通常、トランザクションが終了するまで保持されます。ただし、セーブポイントの確立後にロックが取得された場合、セーブポイントがロールバックされると、ロックはすぐに解放されます。これは、ロールバックがセーブポイント以降のコマンドのすべての効果をキャンセルするという原則と一致してい &lt;code&gt;ROLLBACK&lt;/code&gt; 。PL / pgSQL例外ブロック内で取得されたロックについても同じことが言えます。ブロックからのエラーエスケープにより、ブロック内で取得されたロックが解放されます。</target>
        </trans-unit>
        <trans-unit id="41f916b016e9381b5815b3e4089f244578b1cdbc" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">インデックスが作成されると、それ以上の介入は必要ありません。システムはテーブルが変更されたときにインデックスを更新し、順次テーブルスキャンよりも効率的であると考えられる場合はクエリでインデックスを使用します。ただし、統計を更新してクエリプランナーが適切な判断を下せるようにするには、 &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを定期的に実行する必要がある場合があります。インデックスが使用されているかどうか、およびプランナがインデックスを使用し&lt;em&gt;ない&lt;/em&gt;場合とその理由を確認する方法については、&lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;第14章を&lt;/a&gt;参照してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="642332a00907b7ff64fd98bc7d16bd9934680cd4" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">インデックスが作成されると、それ以上の介入は必要ありません。システムは、テーブルが変更されたときにインデックスを更新し、シーケンシャルテーブルスキャンよりも効率的であると判断した場合にクエリでインデックスを使用します。ただし、 &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを定期的に実行して統計を更新し、クエリプランナーが知識に基づいた決定を行えるようにする必要がある場合があります。参照してください&lt;a href=&quot;https://www.postgresql.org/docs/13/performance-tips.html&quot;&gt;第14章&lt;/a&gt;インデックスが使用されているかどうかを調べる方法の詳細と、なぜプランナーが選択する可能性がある情報のため&lt;em&gt;ではない&lt;/em&gt;インデックスを使用します。</target>
        </trans-unit>
        <trans-unit id="4e5421d611a483b4f3357d11ff23a5acc44acb58" translate="yes" xml:space="preserve">
          <source>Once any valuable objects have been transferred to new owners, any remaining objects owned by the role-to-be-dropped can be dropped with the &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command. Again, this command cannot access objects in other databases, so it is necessary to run it in each database that contains objects owned by the role. Also, &lt;code&gt;DROP OWNED&lt;/code&gt; will not drop entire databases or tablespaces, so it is necessary to do that manually if the role owns any databases or tablespaces that have not been transferred to new owners.</source>
          <target state="translated">貴重なオブジェクトが新しい所有者に転送されると、&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt;コマンドを使用して、削除するロールが所有する残りのオブジェクトを削除できます。繰り返しますが、このコマンドは他のデータベースのオブジェクトにアクセスできないため、ロールが所有するオブジェクトを含む各データベースで実行する必要があります。また、 &lt;code&gt;DROP OWNED&lt;/code&gt; はデータベースまたはテーブルスペース全体を削除しないため、新しい所有者に転送されていないデータベースまたはテーブルスペースをロールが所有している場合は、手動で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="e81389b8f98e0c4fa0978b0ecbccf3ec2c7326c5" translate="yes" xml:space="preserve">
          <source>Once created, a tablespace can be used from any database, provided the requesting user has sufficient privilege. This means that a tablespace cannot be dropped until all objects in all databases using the tablespace have been removed.</source>
          <target state="translated">一度作成された表空間は、要求するユーザーが十分な権限を持っていれば、どのデータベースからでも使用することができます。これは、テーブルスペースを使用しているすべてのデータベースのすべてのオブジェクトが削除されるまで、テーブルスペースを削除できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="73da0c6102d03c025cdbc83b1b38fc971869013e" translate="yes" xml:space="preserve">
          <source>Once created, the enum type can be used in table and function definitions much like any other type:</source>
          <target state="translated">一度作成された enum 型は、他の型と同様にテーブルや関数の定義で使用することができます。</target>
        </trans-unit>
        <trans-unit id="c9f4d5e2b4aa9fc314da7481d260ca60dd53ed46" translate="yes" xml:space="preserve">
          <source>Once failover to the standby occurs, there is only a single server in operation. This is known as a degenerate state. The former standby is now the primary, but the former primary is down and might stay down. To return to normal operation, a standby server must be recreated, either on the former primary system when it comes up, or on a third, possibly new, system. The &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; utility can be used to speed up this process on large clusters. Once complete, the primary and standby can be considered to have switched roles. Some people choose to use a third server to provide backup for the new primary until the new standby server is recreated, though clearly this complicates the system configuration and operational processes.</source>
          <target state="translated">スタンバイへのフェイルオーバーが発生すると、稼働中のサーバーは1つだけになります。これは縮退状態と呼ばれます。以前のスタンバイは現在プライマリですが、以前のプライマリはダウンしており、ダウンしたままになる可能性があります。通常の動作に戻すには、スタンバイサーバーが、元のプライマリシステムが起動したとき、または3番目の、場合によっては新しいシステムで再作成する必要があります。&lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;ユーティリティは、大規模なクラスタ上で、このプロセスをスピードアップするために使用することができます。完了すると、プライマリとスタンバイの役割が切り替わったと見なすことができます。一部の人々は、新しいスタンバイサーバーが再作成されるまで、新しいプライマリのバックアップを提供するために3番目のサーバーを使用することを選択しますが、これは明らかにシステム構成と運用プロセスを複雑にします。</target>
        </trans-unit>
        <trans-unit id="99eb90b007ab371c4c054db1b4a14dc72baaf9ae" translate="yes" xml:space="preserve">
          <source>Once prepared, a transaction can later be committed or rolled back with &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; or &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;, respectively. Those commands can be issued from any session, not only the one that executed the original transaction.</source>
          <target state="translated">準備が完了すると、トランザクションは後でそれぞれ&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;または&lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;を使用してコミットまたはロールバックできます。これらのコマンドは、元のトランザクションを実行したセッションだけでなく、どのセッションからでも発行できます。</target>
        </trans-unit>
        <trans-unit id="a26efc323b5a3b586fc58ac6b6adb6fb3937603a" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each database so the optimizer has useful statistics. You can also run &lt;code&gt;vacuumdb -a -z&lt;/code&gt; to analyze all databases.</source>
          <target state="translated">復元したら、各データベースで &lt;code&gt;ANALYZE&lt;/code&gt; を実行して、オプティマイザが有用な統計を取得できるようにすることをお勧めします。また、 &lt;code&gt;vacuumdb -a -z&lt;/code&gt; を実行して、すべてのデータベースを分析することもできます。</target>
        </trans-unit>
        <trans-unit id="e1c807b866ed2972017d5380e0a876fec0d03a30" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each restored table so the optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">復元されたら、復元された各テーブルで &lt;code&gt;ANALYZE&lt;/code&gt; を実行して、オプティマイザが有用な統計を取得することをお勧めします。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4f22ae97ca76db6661c3c1f5a88b003eb151976f" translate="yes" xml:space="preserve">
          <source>Once started, &lt;code&gt;pg_upgrade&lt;/code&gt; will verify the two clusters are compatible and then do the upgrade. You can use &lt;code&gt;pg_upgrade --check&lt;/code&gt; to perform only the checks, even if the old server is still running. &lt;code&gt;pg_upgrade --check&lt;/code&gt; will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link or clone mode, you should use the option &lt;code&gt;--link&lt;/code&gt; or &lt;code&gt;--clone&lt;/code&gt; with &lt;code&gt;--check&lt;/code&gt; to enable mode-specific checks. &lt;code&gt;pg_upgrade&lt;/code&gt; requires write permission in the current directory.</source>
          <target state="translated">起動すると、 &lt;code&gt;pg_upgrade&lt;/code&gt; は2つのクラスターに互換性があることを確認してからアップグレードを実行します。 &lt;code&gt;pg_upgrade --check&lt;/code&gt; を使用して、古いサーバーがまだ実行されている場合でも、チェックのみを実行できます。 &lt;code&gt;pg_upgrade --check&lt;/code&gt; は、アップグレード後に行う必要がある手動調整の概要も示します。リンクモードまたはクローンモードを使用する場合は、オプション &lt;code&gt;--link&lt;/code&gt; または &lt;code&gt;--clone&lt;/code&gt; を &lt;code&gt;--check&lt;/code&gt; とともに使用して、モード固有のチェックを有効にする必要があります。 &lt;code&gt;pg_upgrade&lt;/code&gt; には、現在のディレクトリでの書き込み権限が必要です。</target>
        </trans-unit>
        <trans-unit id="c713ae812f1782bcff8d86ab36ed9c6d151c330d" translate="yes" xml:space="preserve">
          <source>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; must be set to a non-empty value. &lt;code&gt;synchronous_commit&lt;/code&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but since this is the default value, typically no change is required. (See &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Section 19.5.1&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Section 19.6.2&lt;/a&gt;.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. &lt;code&gt;synchronous_commit&lt;/code&gt; can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</source>
          <target state="translated">ストリーミングレプリケーションが設定された後、同期レプリケーションを設定することは一つだけ追加の設定手順が必要です。&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_namesは&lt;/a&gt;空でない値に設定する必要があります。 &lt;code&gt;synchronous_commit&lt;/code&gt; も &lt;code&gt;on&lt;/code&gt; に設定する必要がありますが、これはデフォルト値であるため、通常は変更する必要はありません。（&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;セクション19.5.1&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;セクション19.6.2を&lt;/a&gt;参照してください。）この構成により、各コミットは、スタンバイがコミットレコードを永続ストレージに書き込んだことの確認を待機します。 &lt;code&gt;synchronous_commit&lt;/code&gt; 個々のユーザーが設定できるため、特定のユーザーまたはデータベースの構成ファイルで構成することも、アプリケーションごとに動的に構成して、トランザクションごとに永続性の保証を制御することもできます。</target>
        </trans-unit>
        <trans-unit id="9871853da7c650c2f0dd2795f59e948ae7531634" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s first return value is the last segment that is required to form a complete set of backup files. On a primary, if &lt;code&gt;archive_mode&lt;/code&gt; is enabled and the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. On a standby, &lt;code&gt;archive_mode&lt;/code&gt; must be &lt;code&gt;always&lt;/code&gt; in order for &lt;code&gt;pg_stop_backup&lt;/code&gt; to wait. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of &lt;code&gt;pg_stop_backup&lt;/code&gt;, set an appropriate &lt;code&gt;statement_timeout&lt;/code&gt; value, but make note that if &lt;code&gt;pg_stop_backup&lt;/code&gt; terminates because of this your backup may not be valid.</source>
          <target state="translated">バックアップ中にアクティブなWALセグメントファイルがアーカイブされると、完了です。 &lt;code&gt;pg_stop_backup&lt;/code&gt; の最初の戻り値で識別されるファイルは、バックアップファイルの完全なセットを形成するために必要な最後のセグメントです。プライマリでは、 &lt;code&gt;archive_mode&lt;/code&gt; が有効で、 &lt;code&gt;wait_for_archive&lt;/code&gt; パラメータが &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; は最後のセグメントがアーカイブされるまで戻りません。スタンバイでは、 &lt;code&gt;pg_stop_backup&lt;/code&gt; が待機するために、 &lt;code&gt;archive_mode&lt;/code&gt; は &lt;code&gt;always&lt;/code&gt; なければなりません。これらのファイルのアーカイブは、 &lt;code&gt;archive_command&lt;/code&gt; がすでに構成されているため、自動的に行われます。。ほとんどの場合、これはすぐに発生しますが、アーカイブシステムを監視して、遅延がないことを確認することをお勧めします。アーカイブコマンドの失敗によりアーカイブプロセスが遅れた場合、アーカイブが成功してバックアップが完了するまで、再試行が続けられます。 &lt;code&gt;pg_stop_backup&lt;/code&gt; の実行に時間制限を設けたい場合は、適切な &lt;code&gt;statement_timeout&lt;/code&gt; 値を設定しますが、これが原因で &lt;code&gt;pg_stop_backup&lt;/code&gt; が終了した場合、バックアップが無効になる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="32e5f3f159f9a76e583d7e4dd4b47490f3262b2b" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s result is the last segment that is required to form a complete set of backup files. If &lt;code&gt;archive_mode&lt;/code&gt; is enabled, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete.</source>
          <target state="translated">バックアップ中にアクティブなWALセグメントファイルがアーカイブされると、完了です。 &lt;code&gt;pg_stop_backup&lt;/code&gt; の結果によって識別されるファイルは、バックアップファイルの完全なセットを形成するために必要な最後のセグメントです。 &lt;code&gt;archive_mode&lt;/code&gt; が有効な場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; は最後のセグメントがアーカイブされるまで戻りません。これらのファイルのアーカイブは、すでに &lt;code&gt;archive_command&lt;/code&gt; を構成しているため、自動的に行われます。ほとんどの場合、これはすぐに発生しますが、アーカイブシステムを監視して、遅延がないことを確認することをお勧めします。アーカイブコマンドの失敗によりアーカイブプロセスが遅れた場合、アーカイブが成功してバックアップが完了するまで、再試行が続けられます。</target>
        </trans-unit>
        <trans-unit id="5f47c9896865faba1d610987fd3b05badac486b3" translate="yes" xml:space="preserve">
          <source>Once the delay specified by &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; has been exceeded, conflicting queries will be canceled. This usually results just in a cancellation error, although in the case of replaying a &lt;code&gt;DROP DATABASE&lt;/code&gt; the entire conflicting session will be terminated. Also, if the conflict is over a lock held by an idle transaction, the conflicting session is terminated (this behavior might change in the future).</source>
          <target state="translated">&lt;code&gt;max_standby_archive_delay&lt;/code&gt; または &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; で指定された遅延を超えると、競合するクエリはキャンセルされます。 &lt;code&gt;DROP DATABASE&lt;/code&gt; を再生する場合、競合するセッション全体が終了しますが、これは通常、キャンセルエラーになります。また、競合がアイドルトランザクションによって保持されているロックを超えている場合、競合するセッションは終了します（この動作は将来変更される可能性があります）。</target>
        </trans-unit>
        <trans-unit id="b8e1074216e0451321cd3f251827b2e9872eaede" translate="yes" xml:space="preserve">
          <source>Once the group role exists, you can add and remove members using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands:</source>
          <target state="translated">グループの役割が存在する場合、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;コマンドを使用してメンバーを追加および削除できます。</target>
        </trans-unit>
        <trans-unit id="69a71607e88d378416ed92ac7ffd6286dc445378" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">アップグレードに満足したら、 &lt;code&gt;pg_upgrade&lt;/code&gt; の完了時に言及されたスクリプトを実行して、古いクラスターのデータディレクトリを削除できます。（古いデータディレクトリ内にユーザー定義のテーブルスペースがある場合、自動削除はできません。）古いインストールディレクトリ（例： &lt;code&gt;bin&lt;/code&gt; 、 &lt;code&gt;share&lt;/code&gt; ）を削除することもできます。</target>
        </trans-unit>
        <trans-unit id="ddbea494f64cf75943b4997efd25a70a79386e0d" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g., &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">アップグレードに問題がなければ、 &lt;code&gt;pg_upgrade&lt;/code&gt; の完了時に説明されているスクリプトを実行して、古いクラスターのデータディレクトリを削除できます。 （古いデータディレクトリ内にユーザー定義のテーブルスペースがある場合、自動削除はできません。）古いインストールディレクトリ（ &lt;code&gt;bin&lt;/code&gt; 、 &lt;code&gt;share&lt;/code&gt; など）を削除することもできます。</target>
        </trans-unit>
        <trans-unit id="d5a7bdde6e82e682c3584d24535e62c92a86edd3" translate="yes" xml:space="preserve">
          <source>Once you have created a database, you can access it by:</source>
          <target state="translated">データベースを作成したら、以下の方法でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a17a3f555279791537a8bafe938cf8c6379fa784" translate="yes" xml:space="preserve">
          <source>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include &lt;code&gt;-i&lt;/code&gt;, that is</source>
          <target state="translated">あなたが必要な設定を行っているしたら、あなたは含まれていないコマンドを使用してベンチマークを実行することができます &lt;code&gt;-i&lt;/code&gt; をつまり、</target>
        </trans-unit>
        <trans-unit id="61eda2a3b905b905ee98026b455b6eb92908a307" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;postgres&lt;/code&gt; instance always manages the data of exactly one database cluster. A database cluster is a collection of databases that is stored at a common file system location (the &amp;ldquo;data area&amp;rdquo;). More than one &lt;code&gt;postgres&lt;/code&gt; instance can run on a system at one time, so long as they use different data areas and different communication ports (see below). When &lt;code&gt;postgres&lt;/code&gt; starts it needs to know the location of the data area. The location must be specified by the &lt;code&gt;-D&lt;/code&gt; option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable; there is no default. Typically, &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt; points directly to the data area directory created by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Other possible file layouts are discussed in &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt;.</source>
          <target state="translated">1つの &lt;code&gt;postgres&lt;/code&gt; インスタンスが常に1つのデータベースクラスタのデータを管理します。データベースクラスターは、一般的なファイルシステムの場所（「データ領域」）に格納されているデータベースの集まりです。異なるデータ領域と異なる通信ポートを使用している限り（以下を参照）、システム上で複数の &lt;code&gt;postgres&lt;/code&gt; インスタンスを同時に実行できます。とき &lt;code&gt;postgres&lt;/code&gt; 起動するには、データ領域の場所を知っている必要があります。場所は、 &lt;code&gt;-D&lt;/code&gt; オプションまたは &lt;code&gt;PGDATA&lt;/code&gt; 環境変数で指定する必要があります。デフォルトはありません。通常、 &lt;code&gt;-D&lt;/code&gt; または &lt;code&gt;PGDATA&lt;/code&gt; は、&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;によって作成されたデータ領域ディレクトリを直接指します。。その他の可能なファイルレイアウトについては、&lt;a href=&quot;runtime-config-file-locations&quot;&gt;セクション19.2で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="8d2b8f4e1b139546c73a22f8f91fadc862c3170c" translate="yes" xml:space="preserve">
          <source>One advantage of GIN is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert. This is much the same advantage as using GiST.</source>
          <target state="translated">GINの利点の一つは、データベースの専門家ではなく、データ型のドメインの専門家によって、適切なアクセス方法でカスタムデータ型を開発できることです。これはGiSTを使用するのとほぼ同じ利点です。</target>
        </trans-unit>
        <trans-unit id="e058cfc0d2adb864aa10f7c9c5f44bcfe8be50f0" translate="yes" xml:space="preserve">
          <source>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiSTの利点の1つは、データベースの専門家ではなく、データ型のドメインに精通した専門家が、適切なアクセス方法でカスタムデータ型を開発できることです。</target>
        </trans-unit>
        <trans-unit id="f48b87ea34b25adefa4f3efa4a97db47fb753d95" translate="yes" xml:space="preserve">
          <source>One advantage of the separate-column approach over an expression index is that it is not necessary to explicitly specify the text search configuration in queries in order to make use of the index. As shown in the example above, the query can depend on &lt;code&gt;default_text_search_config&lt;/code&gt;. Another advantage is that searches will be faster, since it will not be necessary to redo the &lt;code&gt;to_tsvector&lt;/code&gt; calls to verify index matches. (This is more important when using a GiST index than a GIN index; see &lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;.) The expression-index approach is simpler to set up, however, and it requires less disk space since the &lt;code&gt;tsvector&lt;/code&gt; representation is not stored explicitly.</source>
          <target state="translated">式インデックスに対する個別列アプローチの利点の1つは、インデックスを利用するためにクエリでテキスト検索構成を明示的に指定する必要がないことです。上記の例に示すように、クエリは &lt;code&gt;default_text_search_config&lt;/code&gt; に依存する場合があります。もう1つの利点は、インデックスの一致を確認するために &lt;code&gt;to_tsvector&lt;/code&gt; 呼び出しをやり直す必要がないため、検索が高速になることです。（これは、GINインデックスよりもGiSTインデックスを使用する場合により重要です。&lt;a href=&quot;textsearch-indexes&quot;&gt;セクション12.9を&lt;/a&gt;参照してください。）ただし、式-インデックスアプローチは設定が簡単です。また、 &lt;code&gt;tsvector&lt;/code&gt; 表現が明示的に格納されないため、必要なディスク容量が少なくなります。</target>
        </trans-unit>
        <trans-unit id="c591e2a82e983192d18fdc29edda9221e37c6723" translate="yes" xml:space="preserve">
          <source>One advantage of using concatenation in the vector form, rather than concatenating text before applying &lt;code&gt;to_tsvector&lt;/code&gt;, is that you can use different configurations to parse different sections of the document. Also, because the &lt;code&gt;setweight&lt;/code&gt; function marks all lexemes of the given vector the same way, it is necessary to parse the text and do &lt;code&gt;setweight&lt;/code&gt; before concatenating if you want to label different parts of the document with different weights.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; を適用する前にテキストを連結するのではなく、ベクター形式で連結を使用する利点の1つは、さまざまな構成を使用してドキュメントのさまざまなセクションを解析できることです。また、関数 &lt;code&gt;setweight&lt;/code&gt; は指定されたベクトルのすべての語彙素を同じ方法でマークするため、ドキュメントの異なる部分に異なる重みでラベルを付ける場合は、連結する前にテキストを解析して &lt;code&gt;setweight&lt;/code&gt; を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="7aa492c47d8ea5d45e5da9a09ed3c6c96f7a96e5" translate="yes" xml:space="preserve">
          <source>One application of the rewrite system is in the realization of &lt;em&gt;views&lt;/em&gt;. Whenever a query against a view (i.e., a &lt;em&gt;virtual table&lt;/em&gt;) is made, the rewrite system rewrites the user's query to a query that accesses the &lt;em&gt;base tables&lt;/em&gt; given in the &lt;em&gt;view definition&lt;/em&gt; instead.</source>
          <target state="translated">書き換えシステムの1つのアプリケーションは、&lt;em&gt;ビュー&lt;/em&gt;の実現です。ビュー（つまり、&lt;em&gt;仮想テーブル&lt;/em&gt;）に対するクエリが作成されるたびに、書き換えシステムはユーザーのクエリを、&lt;em&gt;ビュー定義で&lt;/em&gt;指定された&lt;em&gt;ベーステーブルに&lt;/em&gt;アクセスするクエリに書き換えます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bee7fd28573b33fce2d46ef1ac5fa8251ec94562" translate="yes" xml:space="preserve">
          <source>One component of the statistics is the total number of entries in each table and index, as well as the number of disk blocks occupied by each table and index. This information is kept in the table &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;, in the columns &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt;. We can look at it with queries similar to this one:</source>
          <target state="translated">統計の1つの要素は、各テーブルとインデックスのエントリの総数、および各テーブルとインデックスが占めるディスクブロックの数です。この情報は、テーブル&lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt;の列 &lt;code&gt;reltuples&lt;/code&gt; および &lt;code&gt;relpages&lt;/code&gt; に保持されます。次のようなクエリで確認できます。</target>
        </trans-unit>
        <trans-unit id="4bd99552b099beafc96cbe7829988f7a06eb967b" translate="yes" xml:space="preserve">
          <source>One convenient way to create a compatible table that will later be made a new child is to use the &lt;code&gt;LIKE&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;. This creates a new table with the same columns as the source table. If there are any &lt;code&gt;CHECK&lt;/code&gt; constraints defined on the source table, the &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; option to &lt;code&gt;LIKE&lt;/code&gt; should be specified, as the new child must have constraints matching the parent to be considered compatible.</source>
          <target state="translated">後で新しい子になる互換性のあるテーブルを作成する便利な方法の1つは、 &lt;code&gt;CREATE TABLE&lt;/code&gt; で &lt;code&gt;LIKE&lt;/code&gt; 句を使用することです。これにより、ソーステーブルと同じ列を持つ新しいテーブルが作成されます。任意の存在する場合 &lt;code&gt;CHECK&lt;/code&gt; ソーステーブルの上に定義された制約は、 &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; のオプション &lt;code&gt;LIKE&lt;/code&gt; は、新しい子が互換性の考慮すべき親のマッチング制約を持たなければならないとして、指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="313d199647b14e908c91b6831b2ac1803fbc36c9" translate="yes" xml:space="preserve">
          <source>One could accomplish the same thing with, say,</source>
          <target state="translated">同じことを成し遂げることができます。</target>
        </trans-unit>
        <trans-unit id="7bcb03e673340a4965d50eadd319bf1730dddebc" translate="yes" xml:space="preserve">
          <source>One disadvantage of decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; is that it might cause &lt;code&gt;VACUUM&lt;/code&gt; to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; を減らすことの1つの欠点は、 &lt;code&gt;VACUUM&lt;/code&gt; が無駄な作業を行う可能性があることです。行バージョンを凍結すると、その行がすぐに変更された場合（新しいXIDを取得するため）、時間の無駄になります。そのため、設定は、行が変更されなくなるまで行が凍結されないように十分な大きさにする必要があります。</target>
        </trans-unit>
        <trans-unit id="d99c8486b08ccc8839ea87cdfcd9e4516a4d63fc" translate="yes" xml:space="preserve">
          <source>One disadvantage of the longitude/latitude representation is that you need to be careful about the edge conditions near the poles and near +/- 180 degrees of longitude. The &lt;code&gt;cube&lt;/code&gt;-based representation avoids these discontinuities.</source>
          <target state="translated">経度/緯度表現の1つの欠点は、極付近および経度の+/- 180度付近のエッジ条件に注意する必要があることです。 &lt;code&gt;cube&lt;/code&gt; ベースの表現は、これらの不連続を回避することができます。</target>
        </trans-unit>
        <trans-unit id="17918ae437c6b6c4eb55d620ac26a6167c3d73b5" translate="yes" xml:space="preserve">
          <source>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</source>
          <target state="translated">このメカニズムの使用例の一つは、ファイルの内容をテーブルのカラムにコピーすることです。最初にファイルを変数にロードし、変数の値を引用符付きの文字列として補間します。</target>
        </trans-unit>
        <trans-unit id="11e396823958b9942ef20dabe2804d32c8c47de7" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g. have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">テーブルアクセスメソッドAPIのかなり大きな制約の1つは、現在、AMが変更やインデックスをサポートする場合、各タプルがブロック番号とアイテム番号で構成されるタプル識別子（TID）を持つ必要があることです。 （&lt;a href=&quot;storage-page-layout&quot;&gt;セクション68.6&lt;/a&gt;も参照）。 TIDのサブパートが、たとえば &lt;code&gt;heap&lt;/code&gt; の場合と同じ意味である必要はありませんが、ビットマップスキャンのサポートが必要な場合（オプション）、ブロック番号はローカリティを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0040d1980e299cbab932d09606b61e2f45cdab4" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g., have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">テーブルアクセスメソッドAPIのかなり大きな制約の1つは、現在、AMが変更やインデックスをサポートする場合、各タプルがブロック番号とアイテム番号で構成されるタプル識別子（TID）を持つ必要があることです。 （&lt;a href=&quot;storage-page-layout&quot;&gt;セクション68.6&lt;/a&gt;も参照）。 TIDのサブパーツが、たとえば &lt;code&gt;heap&lt;/code&gt; 場合と同じ意味を持つ必要は厳密にはありませんが、ビットマップスキャンのサポートが必要な場合（オプション）、ブロック番号は局所性を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea6157e87abd7338811eb2303b2c46792b171e86" translate="yes" xml:space="preserve">
          <source>One major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; shows a possible application of this idea.</source>
          <target state="translated">部分インデックスを使用する主な理由の1つは、一般的な値のインデックス作成を回避することです。共通の値（すべてのテーブル行の数パーセント以上を占めるもの）を検索するクエリはインデックスを使用しないため、これらの行をインデックスに保持しても意味がありません。これにより、インデックスのサイズが小さくなり、インデックスを使用するクエリが高速化されます。また、すべての場合にインデックスを更新する必要がないため、多くのテーブル更新操作が高速化されます。&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;例11.1&lt;/a&gt;は、このアイデアの可能なアプリケーションを示しています。</target>
        </trans-unit>
        <trans-unit id="d407807dcbba44e4e2aa91e451040ac8b91fe898" translate="yes" xml:space="preserve">
          <source>One might need to insert a large amount of data when first populating a database. This section contains some suggestions on how to make this process as efficient as possible.</source>
          <target state="translated">最初にデータベースにデータを挿入するときに、大量のデータを挿入する必要があるかもしれません。このセクションでは、このプロセスを可能な限り効率的にするためのいくつかの提案が含まれています。</target>
        </trans-unit>
        <trans-unit id="af46cf06b4b2b1ea8a95f9146c144e8cb5a4d7fb" translate="yes" xml:space="preserve">
          <source>One must have the PostgreSQL superuser privilege to register a new language or change an existing language's parameters. However, once the language is created it is valid to assign ownership of it to a non-superuser, who may then drop it, change its permissions, rename it, or assign it to a new owner. (Do not, however, assign ownership of the underlying C functions to a non-superuser; that would create a privilege escalation path for that user.)</source>
          <target state="translated">新しい言語を登録したり、既存の言語のパラメータを変更したりするには、PostgreSQLスーパーユーザ権限が必要です。しかし、一度言語が作成されると、その言語の所有権をスーパーユーザ以外の人に割り当てることができます。(ただし、C言語の基礎となる関数の所有権をスーパーユーザではない人に譲渡してはいけません。)</target>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="translated">の一つです。</target>
        </trans-unit>
        <trans-unit id="0e3d57db8bbc433a035cda8e815f996da30de43e" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt;; this specifies the event that will fire the trigger. Multiple events can be specified using &lt;code&gt;OR&lt;/code&gt;, except when transition relations are requested.</source>
          <target state="translated">一つの &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;TRUNCATE&lt;/code&gt; ;これは、トリガーを起動するイベントを指定します。遷移関係が要求されている場合を除き、 &lt;code&gt;OR&lt;/code&gt; を使用して複数のイベントを指定できます。</target>
        </trans-unit>
        <trans-unit id="e5e814c340c50927afd7b76075dffb81341dc8b6" translate="yes" xml:space="preserve">
          <source>One of several disjoint (not overlapping) subsets of a larger set.</source>
          <target state="translated">大きな集合のいくつかの不連続な(重複しない)部分集合のうちの1つ。</target>
        </trans-unit>
        <trans-unit id="1d58cd9872ba6b984b5aaf4db1dd4f254a5318e3" translate="yes" xml:space="preserve">
          <source>One of the most critical design decisions will be the column or columns by which you partition your data. Often the best choice will be to partition by the column or set of columns which most commonly appear in &lt;code&gt;WHERE&lt;/code&gt; clauses of queries being executed on the partitioned table. &lt;code&gt;WHERE&lt;/code&gt; clause items that match and are compatible with the partition key can be used to prune unneeded partitions. However, you may be forced into making other decisions by requirements for the &lt;code&gt;PRIMARY KEY&lt;/code&gt; or a &lt;code&gt;UNIQUE&lt;/code&gt; constraint. Removal of unwanted data is also a factor to consider when planning your partitioning strategy. An entire partition can be detached fairly quickly, so it may be beneficial to design the partition strategy in such a way that all data to be removed at once is located in a single partition.</source>
          <target state="translated">最も重要な設計決定の1つは、データをパーティション化する1つまたは複数の列です。多くの場合、最良の選択は、パーティション化されたテーブルで実行されるクエリの &lt;code&gt;WHERE&lt;/code&gt; 句に最も一般的に現れる列または列のセットでパーティション化することです。パーティションキーと一致し、互換性がある &lt;code&gt;WHERE&lt;/code&gt; 句の項目を使用して、不要なパーティションをプルーニングできます。ただし、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; または &lt;code&gt;UNIQUE&lt;/code&gt; の要件により、他の決定を余儀なくされる場合があります。制約。不要なデータの削除も、パーティション化戦略を計画する際に考慮すべき要素です。パーティション全体をかなり迅速に切り離すことができるので、一度に削除されるすべてのデータが単一のパーティションに配置されるようにパーティション戦略を設計することが有益な場合があります。</target>
        </trans-unit>
        <trans-unit id="511f9e4f8bd3667e3b6d755989f295209cbb7bb6" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;logging to a CSV file,&lt;/a&gt; which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; の明らかな使用法の1つは、PostgreSQLアクティビティログをクエリ用のテーブルとして使用できるようにすることです。これを行うには、最初に&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;CSVファイルにログを記録する&lt;/a&gt;必要があります。ここでは &lt;code&gt;pglog.csv&lt;/code&gt; と呼びます。まず、 &lt;code&gt;file_fdw&lt;/code&gt; を拡張子としてインストールします。</target>
        </trans-unit>
        <trans-unit id="dd64b8780a8987f51d6cf827b3649d1c335b7dcc" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be logging to a CSV file, which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; の明らかな用途の1つは、PostgreSQLアクティビティログをクエリ用のテーブルとして利用できるようにすることです。これを行うには、まずCSVファイルにログを記録する必要があります。ここでは &lt;code&gt;pglog.csv&lt;/code&gt; と呼びます。まず、 &lt;code&gt;file_fdw&lt;/code&gt; としてfile_fdwをインストールします。</target>
        </trans-unit>
        <trans-unit id="01a9a0754bb2d47df04d6f754f8a9d26cef931fd" translate="yes" xml:space="preserve">
          <source>One of the problems with the JDBC driver (and this affects the ODBC driver also), is that the specification assumes that references to BLOBs (Binary Large OBjects) are stored within a table, and if that entry is changed, the associated BLOB is deleted from the database.</source>
          <target state="translated">JDBCドライバの問題の1つは(これはODBCドライバにも影響します)、BLOB(Binary Large OBjects)への参照がテーブル内に格納され、そのエントリが変更された場合、関連するBLOBがデータベースから削除されることを仕様では想定しているということです。</target>
        </trans-unit>
        <trans-unit id="5e5610f45b959ec0066fbadc6e622bf504204314" translate="yes" xml:space="preserve">
          <source>One of the values estimated by &lt;code&gt;ANALYZE&lt;/code&gt; is the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; によって推定される値の1つは、各列に表示される個別の値の数です。行のサブセットのみが検査されるため、可能な限り最大の統計ターゲットであっても、この見積もりは非常に不正確になる場合があります。この不正確さがクエリプランの不良につながる場合、より正確な値を手動で決定し、 &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; インストールできます（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="493483fbe186caeb533f2587ea2f5c9911b94b74" translate="yes" xml:space="preserve">
          <source>One or more server-challenge and client-response message will follow. Each server-challenge is sent in an AuthenticationSASLContinue message, followed by a response from client in an SASLResponse message. The particulars of the messages are mechanism specific.</source>
          <target state="translated">1つ以上のサーバーチャレンジとクライアント応答メッセージが続く。それぞれのサーバーチャレンジは、AuthenticationSASLContinueメッセージで送られ、その後にクライアントからの応答がSASLResponseメッセージで送られます。メッセージの詳細はメカニズム固有のものです。</target>
        </trans-unit>
        <trans-unit id="425be19de627a14da7ab3bb185d550dfbfe3423c" translate="yes" xml:space="preserve">
          <source>One parameter is specified per line. The equal sign between name and value is optional. Whitespace is insignificant (except within a quoted parameter value) and blank lines are ignored. Hash marks (&lt;code&gt;#&lt;/code&gt;) designate the remainder of the line as a comment. Parameter values that are not simple identifiers or numbers must be single-quoted. To embed a single quote in a parameter value, write either two quotes (preferred) or backslash-quote. If the file contains multiple entries for the same parameter, all but the last one are ignored.</source>
          <target state="translated">1行に1つのパラメーターを指定します。名前と値の間の等号はオプションです。空白は重要ではなく（引用符で囲まれたパラメータ値内を除く）、空白行は無視されます。ハッシュマーク（ &lt;code&gt;#&lt;/code&gt; ）は、行の残りをコメントとして指定します。単純な識別子または数値ではないパラメーター値は、単一引用符で囲む必要があります。パラメータ値に単一引用符を埋め込むには、2つの引用符（推奨）またはバックスラッシュ引用符を記述します。ファイルに同じパラメータの複数のエントリが含まれている場合、最後のエントリ以外はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="71b216cd8704d27b44cb581f634267f6e26f6ef5" translate="yes" xml:space="preserve">
          <source>One past the highest completed transaction ID. All transaction IDs greater than or equal to &lt;code&gt;xmax&lt;/code&gt; had not yet completed as of the time of the snapshot, and thus are invisible.</source>
          <target state="translated">完了したトランザクションIDの最高値を1つ過ぎたもの。 &lt;code&gt;xmax&lt;/code&gt; 以上のすべてのトランザクションIDは、スナップショットの時点ではまだ完了していないため、表示されません。</target>
        </trans-unit>
        <trans-unit id="a3fe47df2bc317685fd9b966bcab8a9f820096f2" translate="yes" xml:space="preserve">
          <source>One row for each WAL sender process streaming a base backup, showing current progress. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt;.</source>
          <target state="translated">基本バックアップをストリーミングするWAL送信者プロセスごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;セクション27.4.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="82642c7d45248923778a2209d5f115330d366506" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;ANALYZE&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#ANALYZE-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; を実行しているバックエンド（自動バキュームワーカープロセスを含む）ごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#ANALYZE-PROGRESS-REPORTING&quot;&gt;セクション27.4.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="80b5eb3c3d07dabe60de983aaa0a3518afd885a7" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; を実行しているバックエンド（autovacuumワーカープロセスを含む）ごとに1行、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;セクション27.4.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="effeab1715906cd694d7b1852e9b8750b001e4c5" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; を実行しているバックエンド（自動バキュームワーカープロセスを含む）ごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;セクション27.4.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e814a8df1ec5e7ba9113e201d150026719d20049" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; を実行しているバックエンドごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;セクション27.4.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3fefdce83b8168d66ba70cfd9d6be8231c7483a5" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; 実行しているバックエンドごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;セクション27.4.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="592609ed9243ae5def10fa9f090855998b555b8d" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; または &lt;code&gt;REINDEX&lt;/code&gt; を実行するバックエンドごとに1行。現在の進行状況を示します。&lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;セクション27.4.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7c1c91b429aaf8e67212422dcd282876be59a3b8" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; または &lt;code&gt;REINDEX&lt;/code&gt; を実行しているバックエンドごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;セクション27.4.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e27c3edf1970037c5b38d9980359c2a682d83e63" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのインデックスごとに1行で、その特定のインデックスのI / Oに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-INDEXES-VIEW&quot;&gt; &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="636789b8fa3526dcb7ffa47252873c271555303c" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのインデックスごとに1行。その特定のインデックスのI / Oに関する統計を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="4d77f2cdac8ddfb746a4ceaac2099e52076e9af7" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのインデックスごとに1行で、その特定のインデックスへのアクセスに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-INDEXES-VIEW&quot;&gt; &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c843f1eedf963b1dea0a4c471c30395c4850fb0a" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのインデックスごとに1行。その特定のインデックスへのアクセスに関する統計が表示されます。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="5fdb86eec2a29466a4d1044e6a5602fb45a47381" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_sequences&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのシーケンスごとに1行で、その特定のシーケンスのI / Oに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt; &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c2a19a27308f1c1e0f487d86ec09bd9389b70b95" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのシーケンスごとに1行。その特定のシーケンスのI / Oに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="af3494e4cc13caccb2edb628436f0d6fc2950bc0" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのテーブルごとに1行で、その特定のテーブルのI / Oに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-TABLES-VIEW&quot;&gt; &lt;code&gt;pg_statio_all_tables&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="876cb7f3198f93830f07de3b355cbda033ba5c5c" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのテーブルごとに1行。その特定のテーブルのI / Oに関する統計を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b933ef4e80b93a79e66696a5ea76c78fbf07acf1" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのテーブルごとに1行で、その特定のテーブルへのアクセスに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-TABLES-VIEW&quot;&gt; &lt;code&gt;pg_stat_all_tables&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
