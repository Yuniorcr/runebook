<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d2256e3896ead62f77d423e731b976ceab4c8935" translate="yes" xml:space="preserve">
          <source>Includes the required write-ahead log files (WAL files) in the backup. This will include all write-ahead logs generated during the backup. Unless the method &lt;code&gt;none&lt;/code&gt; is specified, it is possible to start a postmaster directly in the extracted directory without the need to consult the log archive, thus making this a completely standalone backup.</source>
          <target state="translated">必要な先行書き込みログファイル（WALファイル）をバックアップに含めます。これには、バックアップ中に生成されたすべての先行書き込みログが含まれます。メソッド &lt;code&gt;none&lt;/code&gt; が指定されていない限り、ログアーカイブを参照する必要なしに、抽出されたディレクトリでpostmasterを直接起動することができるため、これは完全にスタンドアロンのバックアップになります。</target>
        </trans-unit>
        <trans-unit id="bba52d333ab18b6249842b58dabb5827d455ee93" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), and application name. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; リストに &lt;code&gt;csvlog&lt;/code&gt; を含めると、ログファイルをデータベーステーブルにインポートするのに便利です。このオプションは、コンマ区切り値（CSV）形式でログ行を出力します。これらの列は、ミリ秒のタイムスタンプ、ユーザー名、データベース名、プロセスID、クライアントホスト：ポート番号、セッションID、セッションごとの行番号、コマンドです。タグ、セッション開始時間、仮想トランザクションID、通常のトランザクションID、エラーの重大度、SQLSTATEコード、エラーメッセージ、エラーメッセージの詳細、ヒント、エラーの原因となった内部クエリ（存在する場合）、その中のエラー位置の文字数、エラーコンテキスト、エラーの原因となったユーザークエリ（存在する場合、 &lt;code&gt;log_min_error_statement&lt;/code&gt; によって有効化されます））、その中のエラー位置の文字数、PostgreSQLソースコード内のエラーの場所（ &lt;code&gt;log_error_verbosity&lt;/code&gt; が &lt;code&gt;verbose&lt;/code&gt; に設定されている場合）、およびアプリケーション名。以下は、CSV形式のログ出力を格納するためのサンプルテーブル定義です。</target>
        </trans-unit>
        <trans-unit id="3277b28011c125843d31a46c71b92575dd21118e" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;csvlog&lt;/code&gt; in the &lt;code&gt;log_destination&lt;/code&gt; list provides a convenient way to import log files into a database table. This option emits log lines in comma-separated-values (CSV) format, with these columns: time stamp with milliseconds, user name, database name, process ID, client host:port number, session ID, per-session line number, command tag, session start time, virtual transaction ID, regular transaction ID, error severity, SQLSTATE code, error message, error message detail, hint, internal query that led to the error (if any), character count of the error position therein, error context, user query that led to the error (if any and enabled by &lt;code&gt;log_min_error_statement&lt;/code&gt;), character count of the error position therein, location of the error in the PostgreSQL source code (if &lt;code&gt;log_error_verbosity&lt;/code&gt; is set to &lt;code&gt;verbose&lt;/code&gt;), application name, and backend type. Here is a sample table definition for storing CSV-format log output:</source>
          <target state="translated">&lt;code&gt;log_destination&lt;/code&gt; リストに &lt;code&gt;csvlog&lt;/code&gt; を含めると、ログファイルをデータベーステーブルにインポートする便利な方法が提供されます。このオプションは、次の列を含むコンマ区切り値（CSV）形式のログ行を出力します：ミリ秒のタイムスタンプ、ユーザー名、データベース名、プロセスID、クライアントホスト：ポート番号、セッションID、セッションごとの行番号、コマンドタグ、セッション開始時刻、仮想トランザクションID、通常のトランザクションID、エラーの重大度、SQLSTATEコード、エラーメッセージ、エラーメッセージの詳細、ヒント、エラーの原因となった内部クエリ（存在する場合）、エラー位置の文字数、エラーコンテキスト、エラーの原因となったユーザークエリ（存在する場合、 &lt;code&gt;log_min_error_statement&lt;/code&gt; によって有効化されます））、エラー位置の文字数、PostgreSQLソースコード内のエラーの場所（ &lt;code&gt;log_error_verbosity&lt;/code&gt; が &lt;code&gt;verbose&lt;/code&gt; に設定されている場合）、アプリケーション名、およびバックエンドタイプ。 CSV形式のログ出力を保存するためのサンプルテーブル定義を次に示します。</target>
        </trans-unit>
        <trans-unit id="4c47c86c8d425f70d8b2151c0d809c6c1813e865" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; and &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;; this reduces the frequency of checkpoints, but increases the storage requirements of &lt;code&gt;/pg_wal&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt;と&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeoutを&lt;/a&gt;増やします。これはチェックポイントの頻度を減らしますが、 &lt;code&gt;/pg_wal&lt;/code&gt; のストレージ要件を増やします。</target>
        </trans-unit>
        <trans-unit id="491d088ee8f4f607e5e1e928bb9bf8875f9a361a" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;code&gt;r&lt;/code&gt; in at least &lt;code&gt;n&lt;/code&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;code&gt;r&lt;/code&gt;. Lower-left coordinates are decreased by &lt;code&gt;r&lt;/code&gt; and upper-right coordinates are increased by &lt;code&gt;r&lt;/code&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;code&gt;r&lt;/code&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;code&gt;n&lt;/code&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;code&gt;r&lt;/code&gt; &amp;gt; 0), then extra dimensions are added to make &lt;code&gt;n&lt;/code&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">立方体のサイズを、少なくとも &lt;code&gt;n&lt;/code&gt; 次元で指定された半径 &lt;code&gt;r&lt;/code&gt; だけ増やします。半径が負の場合、立方体は代わりに縮小されます。定義されたすべての寸法は、半径 &lt;code&gt;r&lt;/code&gt; によって変更されます。左下の座標は &lt;code&gt;r&lt;/code&gt; だけ減少し、右上の座標は &lt;code&gt;r&lt;/code&gt; だけ増加します。左下の座標が対応する右上の座標よりも大きくなると（ &lt;code&gt;r&lt;/code&gt; &amp;lt;0の場合にのみ発生します）、両方の座標が平均に設定されます。場合 &lt;code&gt;n&lt;/code&gt; 定義された次元の数よりも大きく、キューブが拡大されている（ &lt;code&gt;r&lt;/code&gt; &amp;gt; 0）、次いで余分寸法が作るために添加される &lt;code&gt;n&lt;/code&gt; 個完全に; 追加座標の初期値として0が使用されます。この関数は、近くのポイントを検索するためにポイントの周囲に境界ボックスを作成するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a6f168056ed493abc9b82ee898684e7de650c44e" translate="yes" xml:space="preserve">
          <source>Increases the size of the cube by the specified radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; in at least &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; dimensions. If the radius is negative the cube is shrunk instead. All defined dimensions are changed by the radius &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. Lower-left coordinates are decreased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; and upper-right coordinates are increased by &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt;. If a lower-left coordinate is increased to more than the corresponding upper-right coordinate (this can only happen when &lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;lt; 0) than both coordinates are set to their average. If &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is greater than the number of defined dimensions and the cube is being enlarged (&lt;em&gt;&lt;code&gt;r&lt;/code&gt;&lt;/em&gt; &amp;gt; 0), then extra dimensions are added to make &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; altogether; 0 is used as the initial value for the extra coordinates. This function is useful for creating bounding boxes around a point for searching for nearby points.</source>
          <target state="translated">少なくとも&lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt;次元で、指定された半径&lt;em&gt; &lt;code&gt;r&lt;/code&gt; だけ&lt;/em&gt;立方体のサイズを大きくします。半径が負の場合、代わりに立方体が縮小されます。定義されたすべての寸法は、半径&lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt;によって変更されます。左下の座標は&lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt;だけ減少し、右上の座標は&lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt;だけ増加します。左下の座標が対応する右上の座標よりも大きくなると（これは&lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt; &amp;lt;0の場合にのみ発生する可能性があります）、両方の座標が平均に設定されます。場合&lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt;定義された次元の数よりも大きく、キューブが拡大されている（&lt;em&gt; &lt;code&gt;r&lt;/code&gt; &lt;/em&gt;&amp;gt; 0）、次いで余分寸法が作るために添加される&lt;em&gt; &lt;code&gt;n&lt;/code&gt; 個&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;完全に; 追加座標の初期値は0です。この関数は、近くのポイントを検索するために、ポイントの周囲に境界ボックスを作成するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="f9c0442f572435bb8c34c7304c10e685fc7ac4b3" translate="yes" xml:space="preserve">
          <source>Increment an integer, making use of an argument name, in PL/pgSQL:</source>
          <target state="translated">PL/pgSQLでは、引数名を利用して整数をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="d5e6a1521753325e1f10aefe90f61ed951c60b45" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, and record the whole updated row along with current time in a log table:</source>
          <target state="translated">株式会社アクメのアカウントを管理する営業担当者の売上数を増加させ、更新された全行を現在時刻とともにログテーブルに記録します。</target>
        </trans-unit>
        <trans-unit id="016cda80a0391be204d7aeb8cae7ec5708da297f" translate="yes" xml:space="preserve">
          <source>Increment the sales count of the salesperson who manages the account for Acme Corporation, using the &lt;code&gt;FROM&lt;/code&gt; clause syntax:</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の構文を使用して、Acme Corporationのアカウントを管理する販売員の販売数を増やします。</target>
        </trans-unit>
        <trans-unit id="9a4352e3ce439f57ce839ae2217c61914bab2036" translate="yes" xml:space="preserve">
          <source>Increment value of the sequence</source>
          <target state="translated">シーケンスのインクリメント値</target>
        </trans-unit>
        <trans-unit id="0baba858aebf401bd8fc5997be9e51de35556b66" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1 most recent WAL files are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;max_wal_size&lt;/code&gt; とは関係なく、&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; + 1最新のWALファイルが常に保持されます。また、WALアーカイブが使用されている場合、古いセグメントはアーカイブされるまで削除またはリサイクルできません。 WALアーカイブがWALが生成されるペースに追いつかない場合、または &lt;code&gt;archive_command&lt;/code&gt; が繰り返し失敗する場合、状況が解決されるまで、古いWALファイルが &lt;code&gt;pg_wal&lt;/code&gt; に蓄積されます。レプリケーションスロットを使用する低速または&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;障害が&lt;/a&gt;発生したスタンバイサーバーでも同じ効果があります（セクション26.2.6を参照）。</target>
        </trans-unit>
        <trans-unit id="ac2969c439badc170cf6b29ba051a5583d528c7a" translate="yes" xml:space="preserve">
          <source>Independently of &lt;code&gt;max_wal_size&lt;/code&gt;, the most recent &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt; megabytes of WAL files plus one additional WAL file are kept at all times. Also, if WAL archiving is used, old segments can not be removed or recycled until they are archived. If WAL archiving cannot keep up with the pace that WAL is generated, or if &lt;code&gt;archive_command&lt;/code&gt; fails repeatedly, old WAL files will accumulate in &lt;code&gt;pg_wal&lt;/code&gt; until the situation is resolved. A slow or failed standby server that uses a replication slot will have the same effect (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;max_wal_size&lt;/code&gt; とは関係なく、最新の&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SIZE&quot;&gt;wal_keep_size&lt;/a&gt;メガバイトのWALファイルと1つの追加のWALファイルが常に保持されます。また、WALアーカイブが使用されている場合、古いセグメントはアーカイブされるまで削除またはリサイクルできません。WALアーカイブがWALの生成ペースに追いつかない場合、または &lt;code&gt;archive_command&lt;/code&gt; が繰り返し失敗した場合、状況が解決されるまで古いWALファイルが &lt;code&gt;pg_wal&lt;/code&gt; に蓄積されます。レプリケーションスロットを使用する低速または&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;障害のある&lt;/a&gt;スタンバイサーバーでも同じ効果があります（セクション26.2.6を参照）。</target>
        </trans-unit>
        <trans-unit id="bbdcb0b3a79497de0963b2de12972bc29faac57b" translate="yes" xml:space="preserve">
          <source>Index (relation)</source>
          <target state="translated">索引(関係)</target>
        </trans-unit>
        <trans-unit id="fc7301cd0f493014b9a0674c1f9a1816640cb05f" translate="yes" xml:space="preserve">
          <source>Index Access Method: Basic API Structure for Indexes</source>
          <target state="translated">インデックスのアクセス方法。インデックスの基本API構造</target>
        </trans-unit>
        <trans-unit id="f78511aae833dc82a57faebbdb5be9d2b811c5ba" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Access Method Functions</source>
          <target state="translated">インデックスアクセス方式 インデックスアクセス方式機能</target>
        </trans-unit>
        <trans-unit id="67844b6b086746a2175da308cd69b3a3322c8f8a" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Cost Estimation Functions</source>
          <target state="translated">インデックスアクセス方式。インデックスコスト推定関数</target>
        </trans-unit>
        <trans-unit id="ed0cf00558f5f3be604eab3a16ea9444c680fa41" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Locking Considerations</source>
          <target state="translated">インデックスアクセス方法。インデックスロックの考慮事項</target>
        </trans-unit>
        <trans-unit id="23bdd1e7799979f5184920ab721afb82ac1bc5bc" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Scanning</source>
          <target state="translated">インデックスアクセス方法 インデックススキャン</target>
        </trans-unit>
        <trans-unit id="1b3aa3923e02606cc47b91d3beb9e0be0fcf698b" translate="yes" xml:space="preserve">
          <source>Index Access Method: Index Uniqueness Checks</source>
          <target state="translated">インデックスのアクセス方法。インデックスの一意性チェック</target>
        </trans-unit>
        <trans-unit id="5ec145b22f866c8350ec8fde02299443b400da81" translate="yes" xml:space="preserve">
          <source>Index Storage Parameters</source>
          <target state="translated">インデックスストレージパラメータ</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">インデックスの種類</target>
        </trans-unit>
        <trans-unit id="f19762ba6cf5f18bb6bfea402f2aaa7605c7a6d9" translate="yes" xml:space="preserve">
          <source>Index access method operator class is for</source>
          <target state="translated">インデックスアクセスメソッド演算子クラスは</target>
        </trans-unit>
        <trans-unit id="aa270689b00c3b50db9d0d870a5d8e7c14e30f9d" translate="yes" xml:space="preserve">
          <source>Index access method operator family is for</source>
          <target state="translated">インデックスアクセスメソッド演算子ファミリは</target>
        </trans-unit>
        <trans-unit id="7f91618c60dc341c28ac1a80ab4b5e00b3b36fa4" translate="yes" xml:space="preserve">
          <source>Index access method specific data. Different methods store different data. Empty in ordinary tables.</source>
          <target state="translated">インデックスアクセス方式の特定のデータ。メソッドによって保存するデータが異なる 通常のテーブルでは空</target>
        </trans-unit>
        <trans-unit id="31a6a8a40d18f374bed6deff03fed3f43968a4d7" translate="yes" xml:space="preserve">
          <source>Index access methods must handle concurrent updates of the index by multiple processes. The core PostgreSQL system obtains &lt;code&gt;AccessShareLock&lt;/code&gt; on the index during an index scan, and &lt;code&gt;RowExclusiveLock&lt;/code&gt; when updating the index (including plain &lt;code&gt;VACUUM&lt;/code&gt;). Since these lock types do not conflict, the access method is responsible for handling any fine-grained locking it might need. An exclusive lock on the index as a whole will be taken only during index creation, destruction, or &lt;code&gt;REINDEX&lt;/code&gt;.</source>
          <target state="translated">インデックスアクセスメソッドは、複数のプロセスによるインデックスの同時更新を処理する必要があります。コアPostgreSQLシステムは、インデックススキャン中にインデックスの &lt;code&gt;AccessShareLock&lt;/code&gt; を取得し、インデックス（プレーンな &lt;code&gt;VACUUM&lt;/code&gt; を含む）を更新するときに &lt;code&gt;RowExclusiveLock&lt;/code&gt; を取得します。これらのロックタイプは競合しないため、アクセス方法は、必要になる可能性のある細かいロックの処理を担当します。インデックス全体の排他ロックは、インデックスの作成、破棄、または &lt;code&gt;REINDEX&lt;/code&gt; 中にのみ取得されます。</target>
        </trans-unit>
        <trans-unit id="411152cefe270170bdbd707fa7bb100f59936ac0" translate="yes" xml:space="preserve">
          <source>Index definition (a reconstructed &lt;code&gt;CREATE INDEX&lt;/code&gt; command)</source>
          <target state="translated">インデックス定義（再構築された &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンド）</target>
        </trans-unit>
        <trans-unit id="fdde6507a698ff6040826cbe9781cf5e41a80789" translate="yes" xml:space="preserve">
          <source>Index expressions are relatively expensive to maintain, because the derived expression(s) must be computed for each row upon insertion and whenever it is updated. However, the index expressions are &lt;em&gt;not&lt;/em&gt; recomputed during an indexed search, since they are already stored in the index. In both examples above, the system sees the query as just &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; and so the speed of the search is equivalent to any other simple index query. Thus, indexes on expressions are useful when retrieval speed is more important than insertion and update speed.</source>
          <target state="translated">インデックス式は、挿入時および更新時に行ごとに派生式を計算する必要があるため、維持するのに比較的コストがかかります。ただし、インデックス式はすでにインデックスに格納されているため、インデックス付き検索中に再計算され&lt;em&gt;ません&lt;/em&gt;。上記の両方の例で、システムはクエリを &lt;code&gt;WHERE indexedcolumn = 'constant'&lt;/code&gt; と見なすため、検索速度は他の単純なインデックスクエリと同等です。したがって、式のインデックスは、挿入と更新の速度よりも検索速度が重要な場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="137221474050ee597f18d1d2a9bf5cc8c57090b0" translate="yes" xml:space="preserve">
          <source>Index-Only Scans and Covering Indexes</source>
          <target state="translated">インデックスのみのスキャンとカバーリングインデックス</target>
        </trans-unit>
        <trans-unit id="fa0d50739fe1e6ebbc17d0c70d81ac62acbaf58d" translate="yes" xml:space="preserve">
          <source>Indexable Operators</source>
          <target state="translated">インデックス可能な演算子</target>
        </trans-unit>
        <trans-unit id="69a6a1b0f4ad606d0ae7c258868e72a29f0777ef" translate="yes" xml:space="preserve">
          <source>Indexed Data Type</source>
          <target state="translated">インデックス化されたデータ型</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="0b07dd7c1e4d64ef5d5ba2561b6e35701b2906b6" translate="yes" xml:space="preserve">
          <source>Indexes and foreign key constraints apply to single tables and not to their inheritance children, hence they have some &lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;caveats&lt;/a&gt; to be aware of.</source>
          <target state="translated">インデックスと外部キー制約は単一のテーブルに適用され、継承の子には適用されないため、&lt;a href=&quot;ddl-inherit#DDL-INHERIT-CAVEATS&quot;&gt;注意&lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="e15643bd769ae7fcf2c35c27f2ab1732e1a9d5c1" translate="yes" xml:space="preserve">
          <source>Indexes can also be used to enforce uniqueness of a column's value, or the uniqueness of the combined values of more than one column.</source>
          <target state="translated">インデックスは、列の値の一意性や、複数の列の組み合わせ値の一意性を強制するために使用することもできます。</target>
        </trans-unit>
        <trans-unit id="94aa2c39061285d86804bbba30d7e52d694f4564" translate="yes" xml:space="preserve">
          <source>Indexes can also benefit &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands with search conditions. Indexes can moreover be used in join searches. Thus, an index defined on a column that is part of a join condition can also significantly speed up queries with joins.</source>
          <target state="translated">インデックスは、検索条件を備えた &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; コマンドにも役立ちます。さらに、インデックスは結合検索で使用できます。したがって、結合条件の一部である列に定義されたインデックスも、結合を使用したクエリを大幅に高速化できます。</target>
        </trans-unit>
        <trans-unit id="68c16c2b91128e4f41955f5ff646c75a169f39bb" translate="yes" xml:space="preserve">
          <source>Indexes can be used by simple index scans, &amp;ldquo;bitmap&amp;rdquo; index scans, and the optimizer. In a bitmap scan the output of several indexes can be combined via AND or OR rules, so it is difficult to associate individual heap row fetches with specific indexes when a bitmap scan is used. Therefore, a bitmap scan increments the &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_read&lt;/code&gt; count(s) for the index(es) it uses, and it increments the &lt;code&gt;pg_stat_all_tables&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt; count for the table, but it does not affect &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;.&lt;code&gt;idx_tup_fetch&lt;/code&gt;. The optimizer also accesses indexes to check for supplied constants whose values are outside the recorded range of the optimizer statistics because the optimizer statistics might be stale.</source>
          <target state="translated">インデックスは、単純なインデックススキャン、「ビットマップ」インデックススキャン、およびオプティマイザで使用できます。ビットマップスキャンでは、複数のインデックスの出力をANDまたはORルールで組み合わせることができるため、ビットマップスキャンを使用する場合、個々のヒープ行フェッチを特定のインデックスに関連付けることは困難です。したがって、ビットマップスキャンは &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; をインクリメントします。使用するインデックスの &lt;code&gt;idx_tup_read&lt;/code&gt; カウント、および &lt;code&gt;pg_stat_all_tables&lt;/code&gt; をインクリメントします。テーブルの &lt;code&gt;idx_tup_fetch&lt;/code&gt; 数。ただし、 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; には影響しません。 &lt;code&gt;idx_tup_fetch&lt;/code&gt; 。オプティマイザ統計は古くなっている可能性があるため、オプティマイザはインデックスにアクセスして、オプティマイザ統計の記録された範囲外の値を持つ指定された定数をチェックします。</target>
        </trans-unit>
        <trans-unit id="fe87987c8ecb565fcb320eb91d374313994665e6" translate="yes" xml:space="preserve">
          <source>Indexes can even concatenate columns:</source>
          <target state="translated">インデックスは列を連結することもできます。</target>
        </trans-unit>
        <trans-unit id="615b513b7bf8866eb4478326c86bda00dbb8833c" translate="yes" xml:space="preserve">
          <source>Indexes can not have multiple inheritance, since they can only inherit when using declarative partitioning.</source>
          <target state="translated">インデックスは宣言的分割を使用する場合にのみ継承できるため、複数の継承を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="8fee069b42975ecfc0bf523b8f7af8b0cf11b9bb" translate="yes" xml:space="preserve">
          <source>Indexes, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, and &lt;code&gt;EXCLUDE&lt;/code&gt; constraints on the original table will be created on the new table. Names for the new indexes and constraints are chosen according to the default rules, regardless of how the originals were named. (This behavior avoids possible duplicate-name failures for the new indexes.)</source>
          <target state="translated">元のテーブルのインデックス、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、 &lt;code&gt;UNIQUE&lt;/code&gt; 、および &lt;code&gt;EXCLUDE&lt;/code&gt; 制約は、新しいテーブルに作成されます。新しいインデックスと制約の名前は、元の名前の付け方に関係なく、デフォルトの規則に従って選択されます。（この動作により、新しいインデックスでの重複した名前の失敗の可能性が回避されます。）</target>
        </trans-unit>
        <trans-unit id="64accc47bb83e575341063f3658e1d1e7d2113e1" translate="yes" xml:space="preserve">
          <source>Indexing for &amp;ldquo;float ranges&amp;rdquo;</source>
          <target state="translated">「フロート範囲」のインデックス作成</target>
        </trans-unit>
        <trans-unit id="d165c70b9c7feb2704f3285d8d27cbb3a58c3a91" translate="yes" xml:space="preserve">
          <source>Indexing for multidimensional cubes</source>
          <target state="translated">多次元キューブのインデックス作成</target>
        </trans-unit>
        <trans-unit id="b91462559e819269659f845aa92e7f5041a36896" translate="yes" xml:space="preserve">
          <source>Indexing for tree-like structures</source>
          <target state="translated">木のような構造のための索引付け</target>
        </trans-unit>
        <trans-unit id="610e7a10148c311249b3bbd57cd9833a58b8714d" translate="yes" xml:space="preserve">
          <source>Indicates how the cast is performed. &lt;code&gt;f&lt;/code&gt; means that the function specified in the &lt;code&gt;castfunc&lt;/code&gt; field is used. &lt;code&gt;i&lt;/code&gt; means that the input/output functions are used. &lt;code&gt;b&lt;/code&gt; means that the types are binary-coercible, thus no conversion is required.</source>
          <target state="translated">キャストの実行方法を示します。 &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;castfunc&lt;/code&gt; フィールドで指定された関数が使用されることを意味します。 &lt;code&gt;i&lt;/code&gt; は、入出力関数が使用されることを意味します。 &lt;code&gt;b&lt;/code&gt; は、型がバイナリ強制型であることを意味するため、変換は必要ありません。</target>
        </trans-unit>
        <trans-unit id="c8e4b2b3e4731dd79133b34f9f993d48a44e51e7" translate="yes" xml:space="preserve">
          <source>Indicates not to recurse creating indexes on partitions, if the table is partitioned. The default is to recurse.</source>
          <target state="translated">テーブルがパーティショニングされている場合、パーティション上にインデックスを作成しないことを示します。デフォルトは再帰することを示します。</target>
        </trans-unit>
        <trans-unit id="c934b82eb6dc908677ffc76af2256f04ecf84094" translate="yes" xml:space="preserve">
          <source>Indicates role to which this role will be added immediately as a new member. Multiple roles to which this role will be added as a member can be specified by writing multiple &lt;code&gt;-g&lt;/code&gt; switches.</source>
          <target state="translated">このロールが新しいメンバーとしてすぐに追加されるロールを示します。このロールをメンバーとして追加する複数のロールは、複数の &lt;code&gt;-g&lt;/code&gt; スイッチを記述することで指定できます。</target>
        </trans-unit>
        <trans-unit id="bba08c6b0be5e0b5de1c5dd077ea609cb92072f0" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意の配列データ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="eeaf761f967f3ec9a6c653153e34b899c18b98b6" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意の配列データ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2af32ec08da7863e95ebf028210e1919471adfda" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意の配列データ型を受け入れ、複数の引数が共通のデータ型に自動的に昇格することを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7a2f7fb68c39785b7c61d53497fe5cf5bd1568bd" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3dcc0fc3f371079dcd8cbcbfff1f3968fc460f48" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5be49c718755809ee9277f9ab09722e8b9a182ec" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が任意のデータ型を受け入れることを示し、複数の引数を共通のデータ型に自動的に昇格させます（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9f46df9b9c0db2bde38cb75f71fb9153783611d4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">関数が任意のenumデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;datatype-enum&quot;&gt;セクション8.7を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="8fccdb3ecc85b5b077cee3a13e6c3bbb009743e7" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any enum data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;).</source>
          <target state="translated">関数が任意の列挙型データ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;datatype-enum&quot;&gt;セクション8.7を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="46bd42bb48f3fa999abde7cc36ebf5b6f5ac5c8d" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any input data type.</source>
          <target state="translated">関数が任意の入力データ型を受け入れることを示します。</target>
        </trans-unit>
        <trans-unit id="4e38b6c5ff227f9cc8a0278ba387f1ee54390caf" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が配列以外のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bd2da16b809ae60477ecb6e3765117401057fff5" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が非配列データ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a67aeb7edc5c822452d3c7740dc6c35d51323bcb" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any non-array data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt;).</source>
          <target state="translated">関数が非配列データ型を受け入れることを示し、複数の引数が共通のデータ型に自動的に昇格されます（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="95d9465560cf78be64ef72d2e6367284edb5463f" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">関数が任意の範囲のデータ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;rangetypes&quot;&gt;セクション8.17を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="035276077ea5e5ea9bea1d81e40e660b2873cd5b" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">関数が任意の範囲データ型を受け入れることを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;rangetypes&quot;&gt;セクション8.17を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4af7c5b9171c91763d28f65430601eb54e6589ed" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts any range data type, with automatic promotion of multiple arguments to a common data type (see &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;Section 37.2.5&lt;/a&gt; and &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;).</source>
          <target state="translated">関数が任意の範囲データ型を受け入れ、複数の引数が共通のデータ型に自動的に昇格することを示します（&lt;a href=&quot;https://www.postgresql.org/docs/13/extend-type-system.html#EXTEND-TYPES-POLYMORPHIC&quot;&gt;セクション37.2.5&lt;/a&gt;および&lt;a href=&quot;rangetypes&quot;&gt;セクション8.17を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="99e158daaace8eac02a3ccf2b3b765596ccc91e4" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a null-terminated C string.</source>
          <target state="translated">関数がヌル文字で終端するC言語の文字列を受け付ける、または返すことを示します。</target>
        </trans-unit>
        <trans-unit id="54761c9282026639ec5c8540cc79ebf4ba11462a" translate="yes" xml:space="preserve">
          <source>Indicates that a function accepts or returns a server-internal data type.</source>
          <target state="translated">関数がサーバー内部のデータ型を受け入れるか、または返すことを示します。</target>
        </trans-unit>
        <trans-unit id="89dc9ca8b4db982fb593e3e44e25350b25d82bea" translate="yes" xml:space="preserve">
          <source>Indicates that a function returns no value.</source>
          <target state="translated">関数が値を返さないことを示します。</target>
        </trans-unit>
        <trans-unit id="7d75608f451e28beb0733c0d6c1c5d589e592ee3" translate="yes" xml:space="preserve">
          <source>Indicates that data retrieved from the cursor should be unaffected by updates to the table(s) underlying the cursor that occur after the cursor is created. In PostgreSQL, this is the default behavior; so this key word has no effect and is only accepted for compatibility with the SQL standard.</source>
          <target state="translated">カーソルから取得されたデータは、カーソルが作成された後に発生するカーソルの下にあるテーブルの更新の影響を受けないことを示します。PostgreSQLでは、これがデフォルトの動作です。したがって、このキーワードは何の効果もなく、SQL標準との互換性のためだけに受け入れられます。</target>
        </trans-unit>
        <trans-unit id="95cdb06015680fe563a8aa9dd541903933a11ad2" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in any context.</source>
          <target state="translated">どのようなコンテキストでも暗黙のうちにキャストを呼び出すことができることを示します。</target>
        </trans-unit>
        <trans-unit id="0390d2ebad5b8b8a226d9901a34d76e7770b71be" translate="yes" xml:space="preserve">
          <source>Indicates that the cast can be invoked implicitly in assignment contexts.</source>
          <target state="translated">代入コンテキストでキャストが暗黙的に呼び出されることを示します。</target>
        </trans-unit>
        <trans-unit id="3840502dacc9907db02fe8896c3bfeafcfa9e633" translate="yes" xml:space="preserve">
          <source>Indicates that the cast is an I/O conversion cast, performed by invoking the output function of the source data type, and passing the resulting string to the input function of the target data type.</source>
          <target state="translated">このキャストは,ソースデータ型の出力関数を呼び出して,結果の文字列をターゲットデータ型の入力関数に渡すことで実行されるI/O変換キャストであることを示します。</target>
        </trans-unit>
        <trans-unit id="01e358ef1ee49de64b80b741226b8d05654b1eb9" translate="yes" xml:space="preserve">
          <source>Indicates that the source type is binary-coercible to the target type, so no function is required to perform the cast.</source>
          <target state="translated">ソース型がターゲット型に対してバイナリ互換性があるため、キャストを実行するための関数が必要ないことを示します。</target>
        </trans-unit>
        <trans-unit id="4f0180a78d5a13ddfb20f673dc1c1a653a0dbf1c" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a hash join.</source>
          <target state="translated">この演算子がハッシュ結合をサポートしていることを示します。</target>
        </trans-unit>
        <trans-unit id="7f8be265aa5381d640f66bb0fbb51979d62652fa" translate="yes" xml:space="preserve">
          <source>Indicates this operator can support a merge join.</source>
          <target state="translated">この演算子がマージ結合をサポートしていることを示します。</target>
        </trans-unit>
        <trans-unit id="88982366e025d973d9fdcbf523cd379f45035c49" translate="yes" xml:space="preserve">
          <source>Indicates what contexts the cast can be invoked in. &lt;code&gt;e&lt;/code&gt; means only as an explicit cast (using &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; syntax). &lt;code&gt;a&lt;/code&gt; means implicitly in assignment to a target column, as well as explicitly. &lt;code&gt;i&lt;/code&gt; means implicitly in expressions, as well as the other cases.</source>
          <target state="translated">キャストを呼び出すことができるコンテキストを示します &lt;code&gt;e&lt;/code&gt; は、明示的なキャストとしてのみ（ &lt;code&gt;CAST&lt;/code&gt; または &lt;code&gt;::&lt;/code&gt; 構文を使用して）意味します。 &lt;code&gt;a&lt;/code&gt; は、ターゲット列への割り当てで暗黙的に、および明示的に意味します。 &lt;code&gt;i&lt;/code&gt; は、他の場合と同様に、式で暗黙的に意味します。</target>
        </trans-unit>
        <trans-unit id="e1335256027d947c4a5d7cbed371240e3fa5176d" translate="yes" xml:space="preserve">
          <source>Indirect TOAST pointers simply point at a non-indirect varlena value stored somewhere in memory. This case was originally created merely as a proof of concept, but it is currently used during logical decoding to avoid possibly having to create physical tuples exceeding 1 GB (as pulling all out-of-line field values into the tuple might do). The case is of limited use since the creator of the pointer datum is entirely responsible that the referenced data survives for as long as the pointer could exist, and there is no infrastructure to help with this.</source>
          <target state="translated">間接 TOAST ポインタは、メモリのどこかに保存されている非間接的な varlena 値を指すだけです。このケースはもともと概念の証明として作成されただけですが、現在は論理デコードの際に使用されており、1GBを超える物理的なタプルを作成しなければならない可能性を避けるために使用されています。ポインタデータムの作成者は、ポインタが存在する限り参照されるデータが存続することに完全に責任があるため、このケースの使用は限定的であり、これを支援するインフラストラクチャはありません。</target>
        </trans-unit>
        <trans-unit id="749d2a57690cd8938d324488d8b64d9826db075f" translate="yes" xml:space="preserve">
          <source>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set &lt;code&gt;longValuesOK&lt;/code&gt; to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</source>
          <target state="translated">個々のリーフタプルと内部タプルは、単一のインデックスページに収まる必要があります（デフォルトでは8kB）。したがって、可変長データ型の値にインデックスを付ける場合、長い値は基数ツリーなどのメソッドでのみサポートできます。この場合、ツリーの各レベルには、ページに収まるほど短いプレフィックスと、最終的なリーフレベルが含まれます。ページに収まるほど短い接尾辞も含まれます。オペレータークラスは、これが発生するように準備する場合にのみ、 &lt;code&gt;longValuesOK&lt;/code&gt; をtrueに設定する必要があります。それ以外の場合、SP-GiSTコアは、インデックスページに収まらないほど大きな値のインデックスを作成する要求を拒否します。</target>
        </trans-unit>
        <trans-unit id="60182f316e9821f12c8e613a5f4a51ed0303f8be" translate="yes" xml:space="preserve">
          <source>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the generic features of inheritance (discussed below) with declaratively partitioned tables or their partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and their partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; with some exceptions, most notably:</source>
          <target state="translated">個々のパーティションは、舞台裏で継承されたパーティションテーブルにリンクされています。ただし、宣言的にパーティション分割されたテーブルまたはそのパーティションでは、継承の一般的な機能の一部（以下で説明）を使用することはできません。たとえば、パーティションはパーティションであるパー​​ティションテーブル以外の親を持つことはできません。また、通常のテーブルはパーティションテーブルから継承して後者を親にすることはできません。つまり、パーティションテーブルとそのパーティションは、通常のテーブルとの継承には参加しません。パーティション化されたテーブルとそのパーティションで構成されるパーティション階層は引き続き継承階層であるため、&lt;a href=&quot;ddl-inherit&quot;&gt;セクション5.10&lt;/a&gt;で説明されているように、いくつかの例外を除いて、すべての通常の継承ルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="e8da164cdd479d1b5a117c145f315adf86e0bbc9" translate="yes" xml:space="preserve">
          <source>Individual state files in &lt;code&gt;pg_twophase&lt;/code&gt; are protected by CRC-32.</source>
          <target state="translated">&lt;code&gt;pg_twophase&lt;/code&gt; の個々の状態ファイルはCRC-32で保護されています。</target>
        </trans-unit>
        <trans-unit id="10dbe9c3ced898e42dd1884b1b4e3f1dc8f408e3" translate="yes" xml:space="preserve">
          <source>Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:</source>
          <target state="translated">不正確とは、いくつかの値が内部フォーマットに正確に変換できず、近似値として保存されていることを意味し、値を保存したり取り出したりすると、わずかな不一致を示す可能性があります。これらの誤差を管理し、それらが計算を通してどのように伝搬するかは、数学とコンピュータサイエンスの一分野の主題であり、以下の点を除いて、ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="4d7d8b040e79c74720337a20e81bb860b0667a32" translate="yes" xml:space="preserve">
          <source>Infinite line</source>
          <target state="translated">無限線</target>
        </trans-unit>
        <trans-unit id="6f943c69647f371e6d494b5d1c35aba8e91e86d6" translate="yes" xml:space="preserve">
          <source>Information about text search configuration objects can be obtained in psql using a set of commands:</source>
          <target state="translated">テキスト検索設定オブジェクトに関する情報は、一連のコマンドを使用してpsqlで取得することができます。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="40def20f80d8ba48037f621df42aa0343e15ee73" translate="yes" xml:space="preserve">
          <source>Inheritance does not automatically propagate data from &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;COPY&lt;/code&gt; commands to other tables in the inheritance hierarchy. In our example, the following &lt;code&gt;INSERT&lt;/code&gt; statement will fail:</source>
          <target state="translated">継承は、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;COPY&lt;/code&gt; コマンドからのデータを継承階層の他のテーブルに自動的に伝播しません。この例では、次の &lt;code&gt;INSERT&lt;/code&gt; ステートメントは失敗します。</target>
        </trans-unit>
        <trans-unit id="48cefe4735516b5da581e0949fa06f740d2b885b" translate="yes" xml:space="preserve">
          <source>Inheritance is a concept from object-oriented databases. It opens up interesting new possibilities of database design.</source>
          <target state="translated">継承はオブジェクト指向データベースからの概念です。それはデータベース設計の興味深い新しい可能性を開きます。</target>
        </trans-unit>
        <trans-unit id="ad5cfb3ab229a84f8bd5bd34780ce3d5e37a4e03" translate="yes" xml:space="preserve">
          <source>Inherited queries perform access permission checks on the parent table only. Thus, for example, granting &lt;code&gt;UPDATE&lt;/code&gt; permission on the &lt;code&gt;cities&lt;/code&gt; table implies permission to update rows in the &lt;code&gt;capitals&lt;/code&gt; table as well, when they are accessed through &lt;code&gt;cities&lt;/code&gt;. This preserves the appearance that the data is (also) in the parent table. But the &lt;code&gt;capitals&lt;/code&gt; table could not be updated directly without an additional grant. In a similar way, the parent table's row security policies (see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;) are applied to rows coming from child tables during an inherited query. A child table's policies, if any, are applied only when it is the table explicitly named in the query; and in that case, any policies attached to its parent(s) are ignored.</source>
          <target state="translated">継承されたクエリは、親テーブルに対してのみアクセス許可チェックを実行します。したがって、例えば、付与 &lt;code&gt;UPDATE&lt;/code&gt; の上の権限 &lt;code&gt;cities&lt;/code&gt; 表は、内の行を更新する権限を意味 &lt;code&gt;capitals&lt;/code&gt; それらを介してアクセスされたときに、同様のテーブルを &lt;code&gt;cities&lt;/code&gt; 。これにより、データが（また）親テーブルにあるように見えます。しかし、 &lt;code&gt;capitals&lt;/code&gt; 表は、追加の補助金なしでは直接更新できませんでした。同様に、親テーブルの行セキュリティポリシー（&lt;a href=&quot;ddl-rowsecurity&quot;&gt;セクション5.8を&lt;/a&gt;参照））は、継承されたクエリ中に子テーブルからの行に適用されます。子テーブルのポリシーがある場合は、それがクエリで明示的に指定されたテーブルである場合にのみ適用されます。その場合、その親に関連付けられているポリシーは無視されます。</target>
        </trans-unit>
        <trans-unit id="1f25aac16509c63c647e201e6dca9b42be580c36" translate="yes" xml:space="preserve">
          <source>Initialization Options</source>
          <target state="translated">初期化オプション</target>
        </trans-unit>
        <trans-unit id="02678e4e52eadddd5b615833652cf8428b2afe6a" translate="yes" xml:space="preserve">
          <source>Initialization option string for the template</source>
          <target state="translated">テンプレートの初期化オプション文字列</target>
        </trans-unit>
        <trans-unit id="6528a9644e65de4c79a52fdab1106b0b771a6d92" translate="yes" xml:space="preserve">
          <source>Initialize the new cluster using &lt;code&gt;initdb&lt;/code&gt;. Again, use compatible &lt;code&gt;initdb&lt;/code&gt; flags that match the old cluster. Many prebuilt installers do this step automatically. There is no need to start the new cluster.</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; を使用して新しいクラスターを初期化します。この場合も、古いクラスターと一致する互換性のある &lt;code&gt;initdb&lt;/code&gt; フラグを使用します。多くのビルド済みインストーラーがこのステップを自動的に実行します。新しいクラスターを起動する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2a5c551f4615e330d270ad5f3b0629fcdfcd3de2" translate="yes" xml:space="preserve">
          <source>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more &lt;em&gt;nodes&lt;/em&gt;, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a &lt;em&gt;label&lt;/em&gt; that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see &lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;Section 65.4.2&lt;/a&gt;.) Optionally, an inner tuple can have a &lt;em&gt;prefix&lt;/em&gt; value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</source>
          <target state="translated">内部タプルは検索ツリーの分岐点であるため、より複雑です。各内部タプルには、類似したリーフ値のグループを表す1つ以上の&lt;em&gt;ノードの&lt;/em&gt;セットが含まれています。ノードには、別の下位レベルの内部タプル、またはすべて同じインデックスページにあるリーフタプルの短いリストにつながるダウンリンクが含まれています。各ノードには通常、それを説明する&lt;em&gt;ラベル&lt;/em&gt;があります。たとえば、基数ツリーでは、ノードラベルを文字列値の次の文字にすることができます。 （または、すべての内部タプルのノードの固定セットで機能する場合、演算子クラスはノードラベルを省略できます。&lt;a href=&quot;spgist-implementation#SPGIST-NULL-LABELS&quot;&gt;セクション65.4.2を&lt;/a&gt;参照してください。）オプションで、内部タプルに&lt;em&gt;プレフィックスを付ける&lt;/em&gt;ことができ&lt;em&gt;ます。&lt;/em&gt;そのすべてのメンバーを説明する値。基数ツリーでは、これは表現された文字列の共通の接頭辞になる可能性があります。接頭辞の値は、必ずしも実際には接頭辞である必要はありませんが、演算子クラスに必要な任意のデータにすることができます。たとえば、四分木では、4つの象限が測定される中心点を保存できます。四分木の内部タプルには、この中心点の周囲の四分円に対応する4つのノードも含まれます。</target>
        </trans-unit>
        <trans-unit id="0029fb34c419096901cb17ee7f69f8d100b925e7" translate="yes" xml:space="preserve">
          <source>Input Ordering</source>
          <target state="translated">ご注文の入力</target>
        </trans-unit>
        <trans-unit id="c651bb8d20d59b648e5817a714d081c24490bd28" translate="yes" xml:space="preserve">
          <source>Input String</source>
          <target state="translated">入力文字列</target>
        </trans-unit>
        <trans-unit id="c42fb65381608e452debc58ec5ce5a7de90ede68" translate="yes" xml:space="preserve">
          <source>Input conversion function (binary format), or 0 if none</source>
          <target state="translated">入力変換機能(バイナリ形式)、ない場合は0</target>
        </trans-unit>
        <trans-unit id="6ede32a74b25d24d933316273b8d1a1c5b311742" translate="yes" xml:space="preserve">
          <source>Input conversion function (text format)</source>
          <target state="translated">入力変換機能(テキスト形式</target>
        </trans-unit>
        <trans-unit id="445431b172a9cb689a043786c27d77bc63ec81f4" translate="yes" xml:space="preserve">
          <source>Input data is interpreted according to &lt;code&gt;ENCODING&lt;/code&gt; option or the current client encoding, and output data is encoded in &lt;code&gt;ENCODING&lt;/code&gt; or the current client encoding, even if the data does not pass through the client but is read from or written to a file directly by the server.</source>
          <target state="translated">入力データは &lt;code&gt;ENCODING&lt;/code&gt; オプションまたは現在のクライアントエンコーディングに従って解釈され、出力データは、データがクライアントを通過せずにサーバーによってファイルから直接読み取られるかファイルに書き込まれる場合でも、 &lt;code&gt;ENCODING&lt;/code&gt; または現在のクライアントエンコーディングでエンコードされます。 。</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="aa563adcb5d00e2fc3a73ea58d9fd1b265968174" translate="yes" xml:space="preserve">
          <source>Insert a distributor, or do nothing for rows proposed for insertion when an existing, excluded row (a row with a matching constrained column or columns after before row insert triggers fire) exists. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column:</source>
          <target state="translated">ディストリビューターを挿入するか、既存の除外された行（行の挿入トリガーが起動する前に一致する制約列または列を持つ行）が存在する場合、挿入が提案された行に対して何もしません。例では、 &lt;code&gt;did&lt;/code&gt; 列に表示される値を制約する一意のインデックスが定義されていると想定しています。</target>
        </trans-unit>
        <trans-unit id="1b0022e72f294401989398fe077aa7293c9d0864" translate="yes" xml:space="preserve">
          <source>Insert a new tuple into an existing index. The &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;isnull&lt;/code&gt; arrays give the key values to be indexed, and &lt;code&gt;heap_tid&lt;/code&gt; is the TID to be indexed. If the access method supports unique indexes (its &lt;code&gt;amcanunique&lt;/code&gt; flag is true) then &lt;code&gt;checkUnique&lt;/code&gt; indicates the type of uniqueness check to perform. This varies depending on whether the unique constraint is deferrable; see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt; for details. Normally the access method only needs the &lt;code&gt;heapRelation&lt;/code&gt; parameter when performing uniqueness checking (since then it will have to look into the heap to verify tuple liveness).</source>
          <target state="translated">新しいタプルを既存のインデックスに挿入します。 &lt;code&gt;values&lt;/code&gt; と &lt;code&gt;isnull&lt;/code&gt; アレイは、インデックス付けされるキー値を与える、と &lt;code&gt;heap_tid&lt;/code&gt; が索引付けされるTIDです。アクセス方法が一意のインデックスをサポートしている場合（その &lt;code&gt;amcanunique&lt;/code&gt; フラグがtrue）、 &lt;code&gt;checkUnique&lt;/code&gt; は実行する一意性チェックのタイプを示します。これは、一意の制約を延期できるかどうかによって異なります。詳細は&lt;a href=&quot;index-unique-checks&quot;&gt;項61.5&lt;/a&gt;を参照してください。通常、アクセス方法は、一意性チェックを実行するときに &lt;code&gt;heapRelation&lt;/code&gt; パラメータのみを必要とします（それ以降は、タプルの活性を確認するためにヒープを調べる必要があるため）。</target>
        </trans-unit>
        <trans-unit id="0f674319e8780ea4807c4a4acfb9e949fb5f9a9e" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;distributors&lt;/code&gt;, returning the sequence number generated by the &lt;code&gt;DEFAULT&lt;/code&gt; clause:</source>
          <target state="translated">単一行をテーブル &lt;code&gt;distributors&lt;/code&gt; に挿入し、 &lt;code&gt;DEFAULT&lt;/code&gt; 句によって生成されたシーケンス番号を返します。</target>
        </trans-unit>
        <trans-unit id="632c13df9b06de5c5de5b6f56617f6d898fc7280" translate="yes" xml:space="preserve">
          <source>Insert a single row into table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">テーブル &lt;code&gt;films&lt;/code&gt; 1行挿入します。</target>
        </trans-unit>
        <trans-unit id="3892df53992670e16381ba584272763bbe059b7e" translate="yes" xml:space="preserve">
          <source>Insert new distributor if possible; otherwise &lt;code&gt;DO NOTHING&lt;/code&gt;. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column on a subset of rows where the &lt;code&gt;is_active&lt;/code&gt; Boolean column evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">可能であれば新しいディストリビューターを挿入します。それ以外の場合は、 &lt;code&gt;DO NOTHING&lt;/code&gt; ないでください。例では、 &lt;code&gt;is_active&lt;/code&gt; ブール列が &lt;code&gt;true&lt;/code&gt; と評価される行のサブセットの &lt;code&gt;did&lt;/code&gt; 列に表示される値を制約する一意のインデックスが定義されていると想定しています。</target>
        </trans-unit>
        <trans-unit id="db80c622e1c5ed5095a7dd936600840392c749b3" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. Note that the special &lt;code&gt;excluded&lt;/code&gt; table is used to reference values originally proposed for insertion:</source>
          <target state="translated">必要に応じて、新しいディストリビューターを挿入または更新します。did 列に表示される値を制約する一意のインデックスが定義されていると仮定 &lt;code&gt;did&lt;/code&gt; ます。特別に &lt;code&gt;excluded&lt;/code&gt; テーブルは、最初に挿入が提案された値を参照するために使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="449538b0ed8e6f507ea1c64d35164fae0d826023" translate="yes" xml:space="preserve">
          <source>Insert or update new distributors as appropriate. Example assumes a unique index has been defined that constrains values appearing in the &lt;code&gt;did&lt;/code&gt; column. &lt;code&gt;WHERE&lt;/code&gt; clause is used to limit the rows actually updated (any existing row not updated will still be locked, though):</source>
          <target state="translated">必要に応じて、新しいディストリビューターを挿入または更新します。例では、 &lt;code&gt;did&lt;/code&gt; 列に表示される値を制約する一意のインデックスが定義されていると想定しています。 &lt;code&gt;WHERE&lt;/code&gt; 句は、実際に更新される行を制限するために使用されます（ただし、更新されていない既存の行はロックされます）。</target>
        </trans-unit>
        <trans-unit id="ae6eaf6a32e43f0bf6ecef28e872215845bae1e6" translate="yes" xml:space="preserve">
          <source>Inserting</source>
          <target state="translated">Inserting</target>
        </trans-unit>
        <trans-unit id="0dd2b481ad724309af4e29174757be7f9ad67dd8" translate="yes" xml:space="preserve">
          <source>Inserting Data</source>
          <target state="translated">データの挿入</target>
        </trans-unit>
        <trans-unit id="a58e264f985643a8003e2d8ae2f19f1f44151747" translate="yes" xml:space="preserve">
          <source>Insertion into a GIN index can be slow due to the likelihood of many keys being inserted for each item. So, for bulk insertions into a table it is advisable to drop the GIN index and recreate it after finishing bulk insertion.</source>
          <target state="translated">GINインデックスへの挿入は、項目ごとに多くのキーが挿入される可能性があるため、挿入に時間がかかることがあります。そのため、テーブルへの一括挿入では、一括挿入を終えた後にGINインデックスを削除して再作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a514639c0e9db066f2ca50c5677c9c0ad2871adb" translate="yes" xml:space="preserve">
          <source>Inside the crosstab grid, for each distinct value &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;colH&lt;/code&gt; and each distinct value &lt;code&gt;y&lt;/code&gt; of &lt;code&gt;colV&lt;/code&gt;, the cell located at the intersection &lt;code&gt;(x,y)&lt;/code&gt; contains the value of the &lt;code&gt;colD&lt;/code&gt; column in the query result row for which the value of &lt;code&gt;colH&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; and the value of &lt;code&gt;colV&lt;/code&gt; is &lt;code&gt;y&lt;/code&gt;. If there is no such row, the cell is empty. If there are multiple such rows, an error is reported.</source>
          <target state="translated">クロス集計グリッドの内側に、それぞれ異なる値のために &lt;code&gt;x&lt;/code&gt; の &lt;code&gt;colH&lt;/code&gt; それぞれ異なる値 &lt;code&gt;y&lt;/code&gt; の &lt;code&gt;colV&lt;/code&gt; 、交差点に位置するセル &lt;code&gt;(x,y)&lt;/code&gt; の値が含まれている &lt;code&gt;colD&lt;/code&gt; の値れるクエリ結果行の列 &lt;code&gt;colH&lt;/code&gt; があるの &lt;code&gt;x&lt;/code&gt; で、 &lt;code&gt;colV&lt;/code&gt; の値は &lt;code&gt;y&lt;/code&gt; です。そのような行がない場合、セルは空です。そのような行が複数ある場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="b00cb7892b66a87132bdd26b6401b8b521c81e40" translate="yes" xml:space="preserve">
          <source>Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring &lt;code&gt;pg_hba.conf&lt;/code&gt; to normal.</source>
          <target state="translated">データベースの内容を調べて、目的の状態に回復したことを確認します。そうでない場合は、手順1に戻ります。問題がなければ、 &lt;code&gt;pg_hba.conf&lt;/code&gt; を通常の状態に戻して、ユーザーが接続できるようにします。</target>
        </trans-unit>
        <trans-unit id="bb93c6938a2011d934988eab5986d385a4c4d0be" translate="yes" xml:space="preserve">
          <source>Inspecting the MCV list is possible using &lt;code&gt;pg_mcv_list_items&lt;/code&gt; set-returning function.</source>
          <target state="translated">MCVリストの検査は、 &lt;code&gt;pg_mcv_list_items&lt;/code&gt; セットを返す関数を使用して可能です。</target>
        </trans-unit>
        <trans-unit id="ff17c423681bf713fcd55cb3b3eb644d120028a0" translate="yes" xml:space="preserve">
          <source>Inspired by the original &lt;code&gt;citext&lt;/code&gt; module by Donald Fraser.</source>
          <target state="translated">Donald Fraserによるオリジナルの &lt;code&gt;citext&lt;/code&gt; モジュールに触発されました。</target>
        </trans-unit>
        <trans-unit id="e2f807d3934f67c59236ce54638758a511971353" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g. &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g. &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">例えば、新しいクラスタに古いクラスタで使用される任意のカスタム共有オブジェクトファイル（またはDLL）をインストールする &lt;code&gt;pgcrypto.so&lt;/code&gt; どこからであるかどうか、 &lt;code&gt;contrib&lt;/code&gt; または他のソース。スキーマ定義、たとえば &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; はインストールしないでください。これらは古いクラスターからアップグレードされるためです。また、カスタムの全文検索ファイル（辞書、同義語、類義語辞典、ストップワード）も新しいクラスターにコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="ad8735c38dbf2201c7954106ea9c90d304db5a72" translate="yes" xml:space="preserve">
          <source>Install any custom shared object files (or DLLs) used by the old cluster into the new cluster, e.g., &lt;code&gt;pgcrypto.so&lt;/code&gt;, whether they are from &lt;code&gt;contrib&lt;/code&gt; or some other source. Do not install the schema definitions, e.g., &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt;, because these will be upgraded from the old cluster. Also, any custom full text search files (dictionary, synonym, thesaurus, stop words) must also be copied to the new cluster.</source>
          <target state="translated">古いクラスターで使用されていたカスタム共有オブジェクトファイル（またはDLL）を、 &lt;code&gt;contrib&lt;/code&gt; からのものか他のソースからのものかに &lt;code&gt;pgcrypto.so&lt;/code&gt; 、新しいクラスター（pgcrypto.soなど）にインストールします。 &lt;code&gt;CREATE EXTENSION pgcrypto&lt;/code&gt; などのスキーマ定義は古いクラスターからアップグレードされるため、インストールしないでください。また、カスタム全文検索ファイル（辞書、類義語、シソーラス、ストップワード）も新しいクラスターにコピーする必要があります。</target>
        </trans-unit>
        <trans-unit id="1a0968ed3e41692f76e13c55e2d74df0fcf64b5b" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database, placing its objects in schema &lt;code&gt;addons&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt;拡張機能を現在のデータベースにインストールし、そのオブジェクトをスキーマ &lt;code&gt;addons&lt;/code&gt; 配置します。</target>
        </trans-unit>
        <trans-unit id="34a5a70619c2c19e2c9702b13c9847e5c653791a" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt; extension into the current database:</source>
          <target state="translated">&lt;a href=&quot;hstore&quot;&gt;hstore&lt;/a&gt;拡張機能を現在のデータベースにインストールします。</target>
        </trans-unit>
        <trans-unit id="04f7a627a6509f6c7b363a56555a0d35366acc62" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;postgres_fdw&lt;/code&gt; extension using &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt;を使用して &lt;code&gt;postgres_fdw&lt;/code&gt; 拡張をインストールします。</target>
        </trans-unit>
        <trans-unit id="9684579d3e7c9b1f5825f61e639d95625abccadc" translate="yes" xml:space="preserve">
          <source>Install the new server's binaries and support files. pg_upgrade is included in a default installation.</source>
          <target state="translated">新しいサーバのバイナリとサポートファイルをインストールします。</target>
        </trans-unit>
        <trans-unit id="cb2992c5a571b6edb98a5bf527c86c020a33e35d" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html&quot;&gt;セクション16.4の&lt;/a&gt;説明に従って、新しいバージョンのPostgreSQLをインストールします。</target>
        </trans-unit>
        <trans-unit id="d7e4ec31b8bf1a9e0464c75a90e53710f79548e0" translate="yes" xml:space="preserve">
          <source>Install the new version of PostgreSQL as outlined in &lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html&quot;&gt;Section 16.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/install-procedure.html&quot;&gt;セクション16.4で&lt;/a&gt;概説されているように、新しいバージョンのPostgreSQLをインストールします。</target>
        </trans-unit>
        <trans-unit id="90075fb521dd4d59c46ee65abf78d28b40851d8c" translate="yes" xml:space="preserve">
          <source>Install the same custom shared object files on the new standbys that you installed in the new primary cluster.</source>
          <target state="translated">新しいプライマリクラスタにインストールしたのと同じカスタム共有オブジェクトファイルを新しいスタンバイにインストールします。</target>
        </trans-unit>
        <trans-unit id="f0738ede58ba3533e9ba6fac10de77528d0eda5f" translate="yes" xml:space="preserve">
          <source>Installing an extension as superuser requires trusting that the extension's author wrote the extension installation script in a secure fashion. It is not terribly difficult for a malicious user to create trojan-horse objects that will compromise later execution of a carelessly-written extension script, allowing that user to acquire superuser privileges. However, trojan-horse objects are only hazardous if they are in the &lt;code&gt;search_path&lt;/code&gt; during script execution, meaning that they are in the extension's installation target schema or in the schema of some extension it depends on. Therefore, a good rule of thumb when dealing with extensions whose scripts have not been carefully vetted is to install them only into schemas for which CREATE privilege has not been and will not be granted to any untrusted users. Likewise for any extensions they depend on.</source>
          <target state="translated">スーパーユーザーとして拡張機能をインストールするには、拡張機能の作成者が拡張機能のインストールスクリプトを安全な方法で作成したことを信頼する必要があります。悪意のあるユーザーがトロイの木馬オブジェクトを作成することはそれほど難しくありません。このオブジェクトは、後で不注意に記述された拡張スクリプトの実行を危険にさらし、そのユーザーがスーパーユーザー特権を取得できるようにします。ただし、トロイの木馬オブジェクトは、 &lt;code&gt;search_path&lt;/code&gt; にある場合にのみ危険です。スクリプトの実行中。つまり、拡張機能のインストールターゲットスキーマまたは依存する拡張機能のスキーマにあります。したがって、スクリプトが慎重に精査されていない拡張機能を扱う場合の経験則は、CREATE特権が付与されておらず、信頼できないユーザーに付与されないスキーマにのみそれらをインストールすることです。同様に、それらが依存する拡張機能についても同様です。</target>
        </trans-unit>
        <trans-unit id="00a4641a5ec01b91ac5755c29e1f7d10ca370b2e" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_int&lt;/code&gt; extension creates a text search template &lt;code&gt;intdict_template&lt;/code&gt; and a dictionary &lt;code&gt;intdict&lt;/code&gt; based on it, with the default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_int&lt;/code&gt; 拡張機能をインストールすると、デフォルトのパラメーターを使用して、テキスト検索テンプレート &lt;code&gt;intdict_template&lt;/code&gt; とそれに基づく辞書 &lt;code&gt;intdict&lt;/code&gt; が作成されます。たとえば、パラメータを変更できます</target>
        </trans-unit>
        <trans-unit id="88a4b249e71fce074c62157e59fbc27119675b0b" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;dict_xsyn&lt;/code&gt; extension creates a text search template &lt;code&gt;xsyn_template&lt;/code&gt; and a dictionary &lt;code&gt;xsyn&lt;/code&gt; based on it, with default parameters. You can alter the parameters, for example</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; 拡張機能をインストールすると、テキスト検索テンプレート &lt;code&gt;xsyn_template&lt;/code&gt; と &lt;code&gt;xsyn&lt;/code&gt; 基づく辞書xsynが作成され、デフォルトのパラメーターが設定されます。たとえば、パラメータを変更できます</target>
        </trans-unit>
        <trans-unit id="cf52efd63633f939852f89750e72d737a7ef8451" translate="yes" xml:space="preserve">
          <source>Installing the &lt;code&gt;unaccent&lt;/code&gt; extension creates a text search template &lt;code&gt;unaccent&lt;/code&gt; and a dictionary &lt;code&gt;unaccent&lt;/code&gt; based on it. The &lt;code&gt;unaccent&lt;/code&gt; dictionary has the default parameter setting &lt;code&gt;RULES='unaccent'&lt;/code&gt;, which makes it immediately usable with the standard &lt;code&gt;unaccent.rules&lt;/code&gt; file. If you wish, you can alter the parameter, for example</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 拡張機能をインストールすると、テキスト検索テンプレート &lt;code&gt;unaccent&lt;/code&gt; とそれに基づいた辞書 &lt;code&gt;unaccent&lt;/code&gt; が作成されます。 &lt;code&gt;unaccent&lt;/code&gt; 辞書は、デフォルトのパラメータ設定がある &lt;code&gt;RULES='unaccent'&lt;/code&gt; 標準で、それはすぐに使用可能になり、 &lt;code&gt;unaccent.rules&lt;/code&gt; ファイルを。必要に応じて、パラメータを変更できます。たとえば、</target>
        </trans-unit>
        <trans-unit id="5f97f8775628e86310829ab9e8c465258ab92a5e" translate="yes" xml:space="preserve">
          <source>Instance</source>
          <target state="translated">Instance</target>
        </trans-unit>
        <trans-unit id="5b4ebcd87748b86d7b51facd78d76e7b88a0adf7" translate="yes" xml:space="preserve">
          <source>Instead of an expression, &lt;code&gt;*&lt;/code&gt; can be written in the output list as a shorthand for all the columns of the selected rows. Also, you can write &lt;code&gt;table_name.*&lt;/code&gt; as a shorthand for the columns coming from just that table. In these cases it is not possible to specify new names with &lt;code&gt;AS&lt;/code&gt;; the output column names will be the same as the table columns' names.</source>
          <target state="translated">式の代わりに、 &lt;code&gt;*&lt;/code&gt; を選択した行のすべての列の省略形として出力リストに書き込むことができます。また、 &lt;code&gt;table_name.*&lt;/code&gt; を、そのテーブルからの列の省略形として書くこともできます。これらの場合、 &lt;code&gt;AS&lt;/code&gt; で新しい名前を指定することはできません。出力列の名前は、テーブルの列の名前と同じになります。</target>
        </trans-unit>
        <trans-unit id="a6521c09d55a0d983da28cb3b1223e411f459cda" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;amgettuple&lt;/code&gt;, an index scan can be done with &lt;code&gt;amgetbitmap&lt;/code&gt; to fetch all tuples in one call. This can be noticeably more efficient than &lt;code&gt;amgettuple&lt;/code&gt; because it allows avoiding lock/unlock cycles within the access method. In principle &lt;code&gt;amgetbitmap&lt;/code&gt; should have the same effects as repeated &lt;code&gt;amgettuple&lt;/code&gt; calls, but we impose several restrictions to simplify matters. First of all, &lt;code&gt;amgetbitmap&lt;/code&gt; returns all tuples at once and marking or restoring scan positions isn't supported. Secondly, the tuples are returned in a bitmap which doesn't have any specific ordering, which is why &lt;code&gt;amgetbitmap&lt;/code&gt; doesn't take a &lt;code&gt;direction&lt;/code&gt; argument. (Ordering operators will never be supplied for such a scan, either.) Also, there is no provision for index-only scans with &lt;code&gt;amgetbitmap&lt;/code&gt;, since there is no way to return the contents of index tuples. Finally, &lt;code&gt;amgetbitmap&lt;/code&gt; does not guarantee any locking of the returned tuples, with implications spelled out in &lt;a href=&quot;index-locking&quot;&gt;Section 61.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amgettuple&lt;/code&gt; を使用する代わりに、 &lt;code&gt;amgetbitmap&lt;/code&gt; を使用してインデックススキャンを実行し、1回の呼び出しですべてのタプルをフェッチできます。これは、アクセス方法内のロック/ロック解除サイクルを回避できるため、 &lt;code&gt;amgettuple&lt;/code&gt; よりも著しく効率的です。原則として &lt;code&gt;amgetbitmap&lt;/code&gt; は &lt;code&gt;amgettuple&lt;/code&gt; を繰り返し呼び出すのと同じ効果がありますが、問題を単純化するためにいくつかの制限を課しています。まず、 &lt;code&gt;amgetbitmap&lt;/code&gt; はすべてのタプルを一度に返します。スキャン位置のマークまたは復元はサポートされていません。次に、タプルは特定の順序付けがないビットマップで返されます。これが、 &lt;code&gt;amgetbitmap&lt;/code&gt; が &lt;code&gt;direction&lt;/code&gt; とらない理由です。引数。（このようなスキャンでも順序付け演算子が提供されることはありません。）また、インデックスタプルの内容を返す方法がないため、 &lt;code&gt;amgetbitmap&lt;/code&gt; を使用したインデックスのみのスキャンには対応していません。最後に、 &lt;code&gt;amgetbitmap&lt;/code&gt; はで綴ら意味合いで、返されるタプルのいずれかのロックを保証するものではありません&lt;a href=&quot;index-locking&quot;&gt;、セクション61.4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d79849f61d583b44d9d0fdc8025d98ffb5bbfd35" translate="yes" xml:space="preserve">
          <source>Instead of writing &lt;code&gt;ONLY&lt;/code&gt; before the table name, you can write &lt;code&gt;*&lt;/code&gt; after the table name to explicitly specify that descendant tables are included. There is no real reason to use this syntax any more, because searching descendant tables is now always the default behavior. However, it is supported for compatibility with older releases.</source>
          <target state="translated">テーブル名の前に &lt;code&gt;ONLY&lt;/code&gt; を記述する代わりに、テーブル名の後に &lt;code&gt;*&lt;/code&gt; を記述して、子孫テーブルが含まれることを明示的に指定できます。子孫テーブルの検索が常にデフォルトの動作になるため、この構文を使用する本当の理由はありません。ただし、以前のリリースとの互換性のためにサポートされています。</target>
        </trans-unit>
        <trans-unit id="4a1635249102b1ddea4769929b8a71df3f648e09" translate="yes" xml:space="preserve">
          <source>Institute of Electrical and Electronics Engineers</source>
          <target state="translated">電気電子学会</target>
        </trans-unit>
        <trans-unit id="e877a09ab092ea6de15878a42ea4226bbdc6693d" translate="yes" xml:space="preserve">
          <source>Integer bit mask indicating which arguments are not being included in the current grouping set</source>
          <target state="translated">現在のグループ化セットに含まれない引数を示す整数ビットマスク</target>
        </trans-unit>
        <trans-unit id="03c1016d0a2fd0151189914ddf3d90f010d5ee41" translate="yes" xml:space="preserve">
          <source>Integer quotient of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; (truncates towards zero)</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; の&lt;/em&gt;整数商（ゼロに向かって切り捨て）</target>
        </trans-unit>
        <trans-unit id="897c83dd3fcb5ef382c1b65917bd9be2f5323fd2" translate="yes" xml:space="preserve">
          <source>Inter-Process Communication</source>
          <target state="translated">プロセス間通信</target>
        </trans-unit>
        <trans-unit id="d85d227df828a06ee1ce26f9f247a35c482de85a" translate="yes" xml:space="preserve">
          <source>Interesting idea for picking passwords.</source>
          <target state="translated">パスワードを選ぶための興味深いアイデア。</target>
        </trans-unit>
        <trans-unit id="457737863c2801b7971002cd15c9223e0c9b404e" translate="yes" xml:space="preserve">
          <source>Interfacing with monitoring software to report errors</source>
          <target state="translated">エラーを報告するための監視ソフトウェアとのインターフェース</target>
        </trans-unit>
        <trans-unit id="bc34e531672634aab3b26d4017b45aa2bbc7b3db" translate="yes" xml:space="preserve">
          <source>Interfacing with other backup and recovery software</source>
          <target state="translated">他のバックアップおよびリカバリソフトウェアとの連携</target>
        </trans-unit>
        <trans-unit id="ec9a27bfbcfba0ca31c61c9c952115c2287d92f0" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set.</source>
          <target state="translated">既存のルート証明書にチェーンする中間証明書は、クライアントに保存しないようにする場合は、&lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt;ファイルにも表示できます（ルート証明書と中間証明書が &lt;code&gt;v3_ca&lt;/code&gt; 拡張子で作成されていると仮定します）。パラメータ&lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt;が設定されている場合、証明書失効リスト（CRL）エントリもチェックされます。</target>
        </trans-unit>
        <trans-unit id="087813fa40caa10b888af01dbc97f7437b81b67d" translate="yes" xml:space="preserve">
          <source>Intermediate certificates that chain up to existing root certificates can also appear in the &lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt; file if you wish to avoid storing them on clients (assuming the root and intermediate certificates were created with &lt;code&gt;v3_ca&lt;/code&gt; extensions). Certificate Revocation List (CRL) entries are also checked if the parameter &lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt; is set. (See &lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt; for diagrams showing SSL certificate usage.)</source>
          <target state="translated">既存のルート証明書にチェーンする中間証明書は、クライアントに保存しないようにしたい場合は、&lt;a href=&quot;runtime-config-connection#GUC-SSL-CA-FILE&quot;&gt;ssl_ca_file&lt;/a&gt;ファイルにも表示できます（ルート証明書と中間証明書が &lt;code&gt;v3_ca&lt;/code&gt; 拡張で作成されたと想定）。証明書失効リスト（CRL）エントリも、パラメータ&lt;a href=&quot;runtime-config-connection#GUC-SSL-CRL-FILE&quot;&gt;ssl_crl_file&lt;/a&gt;が設定されている場合にチェックされます。 （SSL証明書の使用法を示す図については、&lt;a href=&quot;http://h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&quot;&gt;http：//h41379.www4.hpe.com/doc/83final/ba554_90007/ch04s02.html&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="8784a00f8fa083e2a06f38fd51cc35a39bb77fca" translate="yes" xml:space="preserve">
          <source>Internal access to the system catalogs is not done using the isolation level of the current transaction. This means that newly created database objects such as tables are visible to concurrent Repeatable Read and Serializable transactions, even though the rows they contain are not. In contrast, queries that explicitly examine the system catalogs don't see rows representing concurrently created database objects, in the higher isolation levels.</source>
          <target state="translated">システムカタログへの内部アクセスは、現在のトランザクションの分離レベルを使用して行われません。これは、テーブルのような新しく作成されたデータベースオブジェクトは、その中に含まれる行が含まれていなくても、同時並行のリピート可能な読み取りトランザクションやシリアライズ可能なトランザクションには表示されることを意味します。対照的に、システムカタログを明示的に調べるクエリは、より高い分離レベルでは、同時に作成されたデータベースオブジェクトを表す行は表示されません。</target>
        </trans-unit>
        <trans-unit id="a6ed083a1fd80d11b5474ab6a44b299da8513f67" translate="yes" xml:space="preserve">
          <source>Internal data structures such as &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;pg_subtrans&lt;/code&gt;, &lt;code&gt;pg_multixact&lt;/code&gt;, &lt;code&gt;pg_serial&lt;/code&gt;, &lt;code&gt;pg_notify&lt;/code&gt;, &lt;code&gt;pg_stat&lt;/code&gt;, &lt;code&gt;pg_snapshots&lt;/code&gt; are not directly checksummed, nor are pages protected by full page writes. However, where such data structures are persistent, WAL records are written that allow recent changes to be accurately rebuilt at crash recovery and those WAL records are protected as discussed above.</source>
          <target state="translated">&lt;code&gt;pg_xact&lt;/code&gt; 、 &lt;code&gt;pg_subtrans&lt;/code&gt; 、 &lt;code&gt;pg_multixact&lt;/code&gt; 、 &lt;code&gt;pg_serial&lt;/code&gt; 、 &lt;code&gt;pg_notify&lt;/code&gt; 、 &lt;code&gt;pg_stat&lt;/code&gt; 、 &lt;code&gt;pg_snapshots&lt;/code&gt; などの内部データ構造は直接チェックサムされず、ページ全体の書き込みによってページが保護されません。ただし、このようなデータ構造が永続的である場合は、クラッシュリカバリ時に最近の変更を正確に再構築できるWALレコードが書き込まれ、これらのWALレコードは上記のように保護されます。</target>
        </trans-unit>
        <trans-unit id="210293c0eebe094c6cf4191095ebf7c83ba53d58" translate="yes" xml:space="preserve">
          <source>Internal hash code, computed from the statement's parse tree</source>
          <target state="translated">ステートメントの構文解析ツリーから計算される内部ハッシュコード</target>
        </trans-unit>
        <trans-unit id="e2daadb2e211983a80b38897bed9d140e91cd8e5" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;interval&lt;/code&gt; values are stored as months, days, and seconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the seconds field can store fractions. Because intervals are usually created from constant strings or &lt;code&gt;timestamp&lt;/code&gt; subtraction, this storage method works well in most cases, but can cause unexpected results:</source>
          <target state="translated">内部的には、 &lt;code&gt;interval&lt;/code&gt; 値は月、日、秒として格納されます。これは、1か月の日数が異なり、夏時間が調整されている場合は1日が23時間または25時間になる可能性があるためです。月と日のフィールドは整数であり、秒のフィールドは分数を格納できます。間隔は通常、定数の文字列または &lt;code&gt;timestamp&lt;/code&gt; 減算から作成されるため、この格納方法はほとんどの場合うまく機能しますが、予期しない結果を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="95d68b94ef37a16fd1db6257f62457d5c440b435" translate="yes" xml:space="preserve">
          <source>Internally, a GIN index contains a B-tree index constructed over keys, where each key is an element of one or more indexed items (a member of an array, for example) and where each tuple in a leaf page contains either a pointer to a B-tree of heap pointers (a &amp;ldquo;posting tree&amp;rdquo;), or a simple list of heap pointers (a &amp;ldquo;posting list&amp;rdquo;) when the list is small enough to fit into a single index tuple along with the key value. &lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;Figure 66.1&lt;/a&gt; illustrates these components of a GIN index.</source>
          <target state="translated">内部的には、GINインデックスには、キー上に構築されたBツリーインデックスが含まれます。各キーは、1つ以上のインデックス付きアイテムの要素（たとえば、配列のメンバー）であり、リーフページの各タプルには、リストがキー値と共に単一のインデックスタプルに収まるほど小さい場合は、ヒープポインターのBツリー（「投稿ツリー」）、またはヒープポインターの単純なリスト（「投稿リスト」）。&lt;a href=&quot;gin-implementation#GIN-INTERNALS-FIGURE&quot;&gt;図66.1&lt;/a&gt;は、GINインデックスのこれらのコンポーネントを示しています。</target>
        </trans-unit>
        <trans-unit id="7c7cae0387037fdfc011139b31adb37771e499bb" translate="yes" xml:space="preserve">
          <source>Internally, all these types use the same representation (a 64-bit integer), and all are interchangeable. Multiple types are provided to control display formatting and to permit tighter validity checking of input that is supposed to denote one particular type of number.</source>
          <target state="translated">内部的には、これらの型はすべて同じ表現(64ビット整数)を使用し、すべて互換性があります。複数の型が用意されているのは、表示の書式を制御したり、ある特定のタイプの数値を表すことになっている入力の有効性をより厳密にチェックしたりするためです。</target>
        </trans-unit>
        <trans-unit id="801996043d0146904ef0a7b7426c0b0decab6e65" translate="yes" xml:space="preserve">
          <source>Internally, an LSN is a 64-bit integer, representing a byte position in the write-ahead log stream. It is printed as two hexadecimal numbers of up to 8 digits each, separated by a slash; for example, &lt;code&gt;16/B374D848&lt;/code&gt;. The &lt;code&gt;pg_lsn&lt;/code&gt; type supports the standard comparison operators, like &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. Two LSNs can be subtracted using the &lt;code&gt;-&lt;/code&gt; operator; the result is the number of bytes separating those write-ahead log locations.</source>
          <target state="translated">内部的には、LSNは64ビット整数であり、先読みログストリームのバイト位置を表します。スラッシュで区切られた、それぞれ最大8桁の2つの16進数として出力されます。たとえば、 &lt;code&gt;16/B374D848&lt;/code&gt; 。 &lt;code&gt;pg_lsn&lt;/code&gt; のタイプのような、標準的な比較演算子をサポートしています &lt;code&gt;=&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; 。 &lt;code&gt;-&lt;/code&gt; 演算子を使用すると、2つのLSNを減算できます。結果は、これらの先行書き込みログの場所を区切るバイト数です。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="68baab823cf9c4d570311e278e9e088b97918aa9" translate="yes" xml:space="preserve">
          <source>Internals: BRIN Indexes</source>
          <target state="translated">内部の様子。BRINインデックス</target>
        </trans-unit>
        <trans-unit id="30d8bd593f993584038a1e0fe42a81f00b0963a3" translate="yes" xml:space="preserve">
          <source>Internals: Catalogs</source>
          <target state="translated">内部情報。カタログ</target>
        </trans-unit>
        <trans-unit id="3af4bd3be7009ecb5492dd21a7a43e553ce2cd0e" translate="yes" xml:space="preserve">
          <source>Internals: GIN Indexes</source>
          <target state="translated">内部情報 GINインデックス</target>
        </trans-unit>
        <trans-unit id="dc575f859035c87eddb3703eb9f32faa91a064d5" translate="yes" xml:space="preserve">
          <source>Internals: Genetic Query Optimizer</source>
          <target state="translated">内部。遺伝的クエリオプティマイザ</target>
        </trans-unit>
        <trans-unit id="2fdd0d171f1a82304db06140f5b0e0b132641e9d" translate="yes" xml:space="preserve">
          <source>Internals: GiST Indexes</source>
          <target state="translated">内部情報 GiSTインデックス</target>
        </trans-unit>
        <trans-unit id="3353317a88b7d0fe5733c291ee0c6066760bb027" translate="yes" xml:space="preserve">
          <source>Internals: Index Access Method</source>
          <target state="translated">内部的には インデックスアクセス方式</target>
        </trans-unit>
        <trans-unit id="2cfa78663fb409507ad30892f6c62ca88915c849" translate="yes" xml:space="preserve">
          <source>Internals: Physical Storage</source>
          <target state="translated">内部。物理ストレージ</target>
        </trans-unit>
        <trans-unit id="72bd21b653073da0193a18c2b147b4e07c551c2d" translate="yes" xml:space="preserve">
          <source>Internals: SP-GiST Indexes</source>
          <target state="translated">内部情報 SP-GISTインデックス</target>
        </trans-unit>
        <trans-unit id="9a4222dfc9fdc77f19f92dba6e20438075629f39" translate="yes" xml:space="preserve">
          <source>International Electrotechnical Commission</source>
          <target state="translated">国際電気標準会議</target>
        </trans-unit>
        <trans-unit id="efd83bf4b70a77811c228aa3f499876839b1a079" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization</source>
          <target state="translated">国際標準化機構</target>
        </trans-unit>
        <trans-unit id="2bafd8d16b13f2565f9ae12e4063fa2d0cddcfb9" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">国際標準図書番号が新しいEAN13表示形式で表示されるようになりました。</target>
        </trans-unit>
        <trans-unit id="08b688b4eb6cf112f11ba47bac6e099bfb8d453f" translate="yes" xml:space="preserve">
          <source>International Standard Book Numbers to be displayed in the old short display format</source>
          <target state="translated">国際標準図書の番号を旧短表示形式で表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="ebb2e09bb43f37cc7a01fd763ee8d3845536f4c8" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">新表示形式EAN13で表示される国際標準音楽番号</target>
        </trans-unit>
        <trans-unit id="ef34d5e58a9ceadea54e7a66e1ff9112f05b0da0" translate="yes" xml:space="preserve">
          <source>International Standard Music Numbers to be displayed in the old short display format</source>
          <target state="translated">国際標準音楽番号を旧短表示形式で表示するようにした</target>
        </trans-unit>
        <trans-unit id="8dd6340c1b5827c9a707b92916af32dcdcd785bc" translate="yes" xml:space="preserve">
          <source>International Standard Serial Number</source>
          <target state="translated">国際標準シリアル番号</target>
        </trans-unit>
        <trans-unit id="4e1c1c5e087cdba177b1e3d204777d49f8f64412" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the new EAN13 display format</source>
          <target state="translated">新しいEAN13表示形式で表示される国際標準シリアル番号</target>
        </trans-unit>
        <trans-unit id="105b56360755198078a6d52573dd0840458a5750" translate="yes" xml:space="preserve">
          <source>International Standard Serial Numbers to be displayed in the old short display format</source>
          <target state="translated">国際標準シリアル番号を旧ショートディスプレイ形式で表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="8fa33d4271f21b38b9499a714668d1694939db92" translate="yes" xml:space="preserve">
          <source>Interpreting Results</source>
          <target state="translated">結果の解釈</target>
        </trans-unit>
        <trans-unit id="27d548cba7b30ac38c7cf5611fd348dac11ee53d" translate="yes" xml:space="preserve">
          <source>Interpreting the actual data can only be done with information obtained from other tables, mostly &lt;code&gt;pg_attribute&lt;/code&gt;. The key values needed to identify field locations are &lt;code&gt;attlen&lt;/code&gt; and &lt;code&gt;attalign&lt;/code&gt;. There is no way to directly get a particular attribute, except when there are only fixed width fields and no null values. All this trickery is wrapped up in the functions &lt;em&gt;heap_getattr&lt;/em&gt;, &lt;em&gt;fastgetattr&lt;/em&gt; and &lt;em&gt;heap_getsysattr&lt;/em&gt;.</source>
          <target state="translated">実際のデータの解釈は、他のテーブル、主に &lt;code&gt;pg_attribute&lt;/code&gt; から取得した情報でのみ実行できます。フィールドの場所を特定するために必要な主要な値は、 &lt;code&gt;attlen&lt;/code&gt; と &lt;code&gt;attalign&lt;/code&gt; です。固定幅フィールドのみがあり、null値がない場合を除いて、特定の属性を直接取得する方法はありません。このすべてのトリックは、関数&lt;em&gt;heap_getattr&lt;/em&gt;、&lt;em&gt;fastgetattr&lt;/em&gt;、および&lt;em&gt;heap_getsysattrに&lt;/em&gt;ラップされています。</target>
        </trans-unit>
        <trans-unit id="24238f9afeb08c45bbce6cbe5bfc823ad38ca9fd" translate="yes" xml:space="preserve">
          <source>Intersects?</source>
          <target state="translated">Intersects?</target>
        </trans-unit>
        <trans-unit id="4e15cd1f984843596070878cf276c50b3a281208" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</source>
          <target state="translated">間隔から &lt;code&gt;x&lt;/code&gt; - &lt;code&gt;delta&lt;/code&gt; に &lt;code&gt;x&lt;/code&gt; + &lt;code&gt;delta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264b54df84208c3c82823ada24d9901903b36609" translate="yes" xml:space="preserve">
          <source>Interval from &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; から &lt;code&gt;y&lt;/code&gt; までの間隔</target>
        </trans-unit>
        <trans-unit id="d6c942376df50e42c9c8ec0a3deb9eba3459225b" translate="yes" xml:space="preserve">
          <source>Interval values can also be written as ISO 8601 time intervals, using either the &amp;ldquo;format with designators&amp;rdquo; of the standard's section 4.4.3.2 or the &amp;ldquo;alternative format&amp;rdquo; of section 4.4.3.3. The format with designators looks like this:</source>
          <target state="translated">間隔の値は、規格のセクション4.4.3.2の「指定子付きのフォーマット」またはセクション4.4.3.3の「代替フォーマット」を使用して、ISO 8601時間間隔として書き込むこともできます。指定子付きのフォーマットは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e96fd04cfd40c6866ae4fadc2523f325bbca5474" translate="yes" xml:space="preserve">
          <source>Intuitively, the larger the &lt;code&gt;parameter&lt;/code&gt;, the more frequently values close to &lt;code&gt;min&lt;/code&gt; are accessed, and the less frequently values close to &lt;code&gt;max&lt;/code&gt; are accessed. The closer to 0 &lt;code&gt;parameter&lt;/code&gt; is, the flatter (more uniform) the access distribution. A crude approximation of the distribution is that the most frequent 1% values in the range, close to &lt;code&gt;min&lt;/code&gt;, are drawn &lt;code&gt;parameter&lt;/code&gt;% of the time. The &lt;code&gt;parameter&lt;/code&gt; value must be strictly positive.</source>
          <target state="translated">直感的には、 &lt;code&gt;parameter&lt;/code&gt; が大きいほど、 &lt;code&gt;min&lt;/code&gt; に近い値にアクセスする頻度が高くなり、 &lt;code&gt;max&lt;/code&gt; に近い値にアクセスする頻度が少なくなります。 &lt;code&gt;parameter&lt;/code&gt; が0に近いほど、アクセス分布はよりフラット（より均一）になります。分布の大雑把な概算は、 &lt;code&gt;min&lt;/code&gt; に近い範囲で最も頻繁な1％の値が、時間の &lt;code&gt;parameter&lt;/code&gt; として描画されることです。 &lt;code&gt;parameter&lt;/code&gt; 値が厳密に正でなければなりません。</target>
        </trans-unit>
        <trans-unit id="fa5dcf3086d32573b28d785efef236569ee934d3" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in degrees</source>
          <target state="translated">逆コサイン、度数の結果</target>
        </trans-unit>
        <trans-unit id="65156637d01418342819a73cb6f0c84ed3aadd9b" translate="yes" xml:space="preserve">
          <source>Inverse cosine, result in radians</source>
          <target state="translated">逆コサイン、ラジアンでの結果</target>
        </trans-unit>
        <trans-unit id="044acbc59a99d5be1dcd2df39272182f119202c9" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine</source>
          <target state="translated">逆双曲余弦</target>
        </trans-unit>
        <trans-unit id="aa52c84bd7eb12aa1c433c5d2762f1447b2f7569" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine</source>
          <target state="translated">逆双曲正弦</target>
        </trans-unit>
        <trans-unit id="d2adf2990a26a6381a709615ea39f05a1bb69453" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent</source>
          <target state="translated">逆双曲正接</target>
        </trans-unit>
        <trans-unit id="76a2b17d6de61349537c2d6805d0dd47465a55e8" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in degrees</source>
          <target state="translated">逆正弦波、度数での結果</target>
        </trans-unit>
        <trans-unit id="c2443561103c4f30b566171f3e2681acb12058ea" translate="yes" xml:space="preserve">
          <source>Inverse sine, result in radians</source>
          <target state="translated">逆サイン、ラジアンでの結果</target>
        </trans-unit>
        <trans-unit id="0e43d0792058a59dfb9b5584a76b17083ea3f125" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in degrees</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; の&lt;/em&gt;逆正接、結果は度</target>
        </trans-unit>
        <trans-unit id="43cbfde7a6966208306cd1536838dca692e6b35d" translate="yes" xml:space="preserve">
          <source>Inverse tangent of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;, result in radians</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; の&lt;/em&gt;逆正接、結果はラジアン</target>
        </trans-unit>
        <trans-unit id="7c7267a29db6fb274a599fb9151d3055e43e152d" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in degrees</source>
          <target state="translated">逆接、度の結果</target>
        </trans-unit>
        <trans-unit id="d9e9282eef441e5d3e97532b28f7543960a0fda3" translate="yes" xml:space="preserve">
          <source>Inverse tangent, result in radians</source>
          <target state="translated">逆接、ラジアンでの結果</target>
        </trans-unit>
        <trans-unit id="d4c4d2a44d0c1732fb4957da686a2c8c6fd4c621" translate="yes" xml:space="preserve">
          <source>Inverse transition function for moving-aggregate mode (zero if none)</source>
          <target state="translated">移動アグリゲートモードの逆遷移関数(ない場合はゼロ)</target>
        </trans-unit>
        <trans-unit id="28b7eaaae619dbbc89f335962aef4470def2f3e3" translate="yes" xml:space="preserve">
          <source>Invoke &lt;code&gt;VACUUM&lt;/code&gt; on the standard tables.</source>
          <target state="translated">標準テーブルで &lt;code&gt;VACUUM&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3018fd4dab61ebc08a8223638bc64040a2d9e057" translate="yes" xml:space="preserve">
          <source>Is above (allows touching)?</source>
          <target state="translated">上記は(触れることができる)ですか?</target>
        </trans-unit>
        <trans-unit id="da6fc6925748c3c1aaf71338cad9d5f477a2383e" translate="yes" xml:space="preserve">
          <source>Is below (allows touching)?</source>
          <target state="translated">下は(触ることができる)ですか?</target>
        </trans-unit>
        <trans-unit id="4cde919e343d25f19646be89eb578d4418ea8a44" translate="yes" xml:space="preserve">
          <source>Is collation visible in search path?</source>
          <target state="translated">照合は検索パスに表示されますか?</target>
        </trans-unit>
        <trans-unit id="fa29522fdb9c9289837f5d8f7d870cd6a67b34d7" translate="yes" xml:space="preserve">
          <source>Is conversion visible in search path?</source>
          <target state="translated">コンバージョンは検索パスに表示されますか?</target>
        </trans-unit>
        <trans-unit id="94be39b60eecf97da6c05767e63714ce3bb576d4" translate="yes" xml:space="preserve">
          <source>Is first &lt;code&gt;tsquery&lt;/code&gt; contained in the second? (This considers only whether all the lexemes appearing in one query appear in the other, ignoring the combining operators.)</source>
          <target state="translated">最初の &lt;code&gt;tsquery&lt;/code&gt; は2番目に含まれていますか？（これは、結合演算子を無視して、一方のクエリに表示されるすべての語彙素がもう一方のクエリに表示されるかどうかのみを考慮します。）</target>
        </trans-unit>
        <trans-unit id="c1572ea1eb7fef37d46de7513f84f0e67fb37082" translate="yes" xml:space="preserve">
          <source>Is first object above second (allows edges to touch)?</source>
          <target state="translated">第一のオブジェクトは第二のオブジェクトの上にありますか(エッジが触れることができます)?</target>
        </trans-unit>
        <trans-unit id="c505339eacef9319fd285351332723a55918638e" translate="yes" xml:space="preserve">
          <source>Is first object below second (allows edges to touch)?</source>
          <target state="translated">第一のオブジェクトは第二のオブジェクトの下にありますか(エッジが触れることができます)?</target>
        </trans-unit>
        <trans-unit id="e5bac705c5e60b2475e9b17e98087c0990a2c946" translate="yes" xml:space="preserve">
          <source>Is first object contained in or on second? Available for these pairs of types: (&lt;code id=&quot;point&quot;&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;lseg&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;point&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;), (&lt;code&gt;box&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;), (&lt;code&gt;lseg&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;), (&lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;), (&lt;code&gt;circle&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;).</source>
          <target state="translated">最初のオブジェクトは2番目に含まれていますか？これらのタイプのペアで使用可能:( &lt;code id=&quot;point&quot;&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; ）、（ &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;lseg&lt;/code&gt; ）、（ &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;line&lt;/code&gt; ）、（ &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;path&lt;/code&gt; ）、（ &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; ）、（ &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; ）、（ &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; ）、（ &lt;code&gt;lseg&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; ）、（ &lt;code&gt;lseg&lt;/code&gt; 、 &lt;code&gt;line&lt;/code&gt; ）、（ &lt;code&gt;polygon&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; ）、（ &lt;code&gt;circle&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7e54349160763b512bf27d165196d02b1f67231a" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? (This operator is misnamed; it should be &lt;code id=&quot;1246262&quot;&gt;|&amp;gt;&amp;gt;&lt;/code&gt;.)</source>
          <target state="translated">最初のオブジェクトは厳密に2番目より上ですか？（この演算子の名前は間違っています。 &lt;code id=&quot;1246262&quot;&gt;|&amp;gt;&amp;gt;&lt;/code&gt; である必要があります。）</target>
        </trans-unit>
        <trans-unit id="2ba666af39de93d6cf6a684c0aa3dde8c77aa45b" translate="yes" xml:space="preserve">
          <source>Is first object strictly above second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">最初のオブジェクトは厳密に2番目より上ですか？ &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 利用できます。</target>
        </trans-unit>
        <trans-unit id="a74a8665c56409f78bc9b13ad274898bb226d641" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? (This operator is misnamed; it should be &lt;code id=&quot;6060124&quot;&gt;&amp;lt;&amp;lt;|&lt;/code&gt;.)</source>
          <target state="translated">最初のオブジェクトは厳密に2番目より下にありますか？（この演算子の名前は間違っています。 &lt;code id=&quot;6060124&quot;&gt;&amp;lt;&amp;lt;|&lt;/code&gt; である必要があります。）</target>
        </trans-unit>
        <trans-unit id="0bb75e79e36aeff0c7858d8fb478e380c0c08061" translate="yes" xml:space="preserve">
          <source>Is first object strictly below second? Available for &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">最初のオブジェクトは厳密に2番目より下にありますか？ &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 利用できます。</target>
        </trans-unit>
        <trans-unit id="82493964e24c37744bf5de6c7abddd6d617b2dbe" translate="yes" xml:space="preserve">
          <source>Is first object strictly left of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">最初のオブジェクトは厳密に2番目のオブジェクトの左側にありますか？以下のための利用可能な &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceb9750549fc2256498ec80ab691b24c888f4e5c" translate="yes" xml:space="preserve">
          <source>Is first object strictly right of second? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">最初のオブジェクトは厳密に2番目のオブジェクトの権利ですか？以下のための利用可能な &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2352c4320a598b186beeca1fa33e9ebc446c5989" translate="yes" xml:space="preserve">
          <source>Is function visible in search path? (This also works for procedures and aggregates.)</source>
          <target state="translated">関数は検索パスに表示されていますか?(これはプロシージャやアグリゲートに対しても有効です)。</target>
        </trans-unit>
        <trans-unit id="ea56f04ac22e5eca73342cefd404d9c1b002af61" translate="yes" xml:space="preserve">
          <source>Is horizontal?</source>
          <target state="translated">横長なのかな?</target>
        </trans-unit>
        <trans-unit id="1818cd29919e00fd168940f58522c1a837de41d9" translate="yes" xml:space="preserve">
          <source>Is left argument a descendant of right (or equal)?</source>
          <target state="translated">左の議論は右の子孫(もしくはイコール)なのか?</target>
        </trans-unit>
        <trans-unit id="c6269d3f15bfebe74c5b103d510d2f6af4fbb1be" translate="yes" xml:space="preserve">
          <source>Is left argument an ancestor of right (or equal)?</source>
          <target state="translated">左の議論は右の先祖(もしくはイコール)なのか?</target>
        </trans-unit>
        <trans-unit id="0bfb83cf12d958867b468135803b461105b5e313" translate="yes" xml:space="preserve">
          <source>Is left array contained in right array?</source>
          <target state="translated">左の配列は右の配列に含まれていますか?</target>
        </trans-unit>
        <trans-unit id="931e59a6570abe457c179e4beff2927ed26d2296" translate="yes" xml:space="preserve">
          <source>Is left operand contained in right?</source>
          <target state="translated">左のオペランドは右に含まれていますか?</target>
        </trans-unit>
        <trans-unit id="571e67a163dd7cbf36b6a8d1f61104a0a31bbc98" translate="yes" xml:space="preserve">
          <source>Is line horizontal?</source>
          <target state="translated">線は水平なのか?</target>
        </trans-unit>
        <trans-unit id="d1926a606e864164a6ebd58c12b6d35ee6a87c25" translate="yes" xml:space="preserve">
          <source>Is line vertical?</source>
          <target state="translated">線は垂直なのか?</target>
        </trans-unit>
        <trans-unit id="ae143f55d7c085448a695f852ae27520ec5aa08b" translate="yes" xml:space="preserve">
          <source>Is operator class visible in search path?</source>
          <target state="translated">検索パスに演算子クラスが表示されていますか?</target>
        </trans-unit>
        <trans-unit id="a5787d3510293778cafab6156a15c641287921cd" translate="yes" xml:space="preserve">
          <source>Is operator family visible in search path?</source>
          <target state="translated">演算子ファミリーは検索パスに表示されていますか?</target>
        </trans-unit>
        <trans-unit id="2c15be0091b6642fd23724ba17d912f27c02d8aa" translate="yes" xml:space="preserve">
          <source>Is operator visible in search path?</source>
          <target state="translated">検索パスに演算子が表示されていますか?</target>
        </trans-unit>
        <trans-unit id="07ef905d97492d046c005a27265c8219bcc2fb0c" translate="yes" xml:space="preserve">
          <source>Is path closed?</source>
          <target state="translated">パスは閉じられているのか?</target>
        </trans-unit>
        <trans-unit id="692378f0378ddf6c5206700062aa1ea0e029afe6" translate="yes" xml:space="preserve">
          <source>Is path open?</source>
          <target state="translated">道は開いていますか?</target>
        </trans-unit>
        <trans-unit id="c9fe9c5adbc8c22895dcd6a5a3619390deb9964a" translate="yes" xml:space="preserve">
          <source>Is perpendicular?</source>
          <target state="translated">垂直なのか?</target>
        </trans-unit>
        <trans-unit id="aee38f7bf2589d5e14735890024a26f0647e7b2b" translate="yes" xml:space="preserve">
          <source>Is row-level security active for the specified table in the context of the current user and current environment?</source>
          <target state="translated">現在のユーザーと現在の環境のコンテキストで、指定されたテーブルに対して行レベルのセキュリティが有効になっているか?</target>
        </trans-unit>
        <trans-unit id="a3bd90c2bab054cba48ad1eb7ff2752205acec58" translate="yes" xml:space="preserve">
          <source>Is statistics object visible in search path?</source>
          <target state="translated">検索パスに統計オブジェクトが表示されていますか?</target>
        </trans-unit>
        <trans-unit id="fefaf9d6dfa31078880e5655df30026e38004358" translate="yes" xml:space="preserve">
          <source>Is strictly above?</source>
          <target state="translated">厳密には上ですか?</target>
        </trans-unit>
        <trans-unit id="a05cc4a278817fbe41225c1212990f7a42609499" translate="yes" xml:space="preserve">
          <source>Is strictly below?</source>
          <target state="translated">厳密には下なのかな?</target>
        </trans-unit>
        <trans-unit id="b70722f5747da5b37c94b2e21f108653a4a0d9d2" translate="yes" xml:space="preserve">
          <source>Is strictly left of?</source>
          <target state="translated">厳密には左かな?</target>
        </trans-unit>
        <trans-unit id="c41dadb911bf56e59cfeff92444afa779a0c9714" translate="yes" xml:space="preserve">
          <source>Is strictly right of?</source>
          <target state="translated">厳密には正しいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="fd466dacfa71c9a3651034da3efd29046bfe7fec" translate="yes" xml:space="preserve">
          <source>Is subnet contained by or equal to subnet?</source>
          <target state="translated">サブネットは、サブネットによって含まれているか、またはサブネットに等しいか?</target>
        </trans-unit>
        <trans-unit id="608df21f03573c35e537fec94e301c9c05a0ef8c" translate="yes" xml:space="preserve">
          <source>Is subnet strictly contained by subnet? This operator, and the next four, test for subnet inclusion. They consider only the network parts of the two addresses (ignoring any bits to the right of the netmasks) and determine whether one network is identical to or a subnet of the other.</source>
          <target state="translated">サブネットが厳密にサブネットに含まれているか?この演算子と次の4つの演算子は、サブネットが含まれているかどうかをテストします。これらの演算子は、2つのアドレスのネットワーク部分のみを考慮し(ネットマスクの右側のビットは無視)、一方のネットワークが他方のネットワークと同一であるか、他方のサブネットであるかを判断します。</target>
        </trans-unit>
        <trans-unit id="46cc6fe87dd8470a9509c9da1c694aaec675334f" translate="yes" xml:space="preserve">
          <source>Is table visible in search path? (This works for all types of relations, including views, materialized views, indexes, sequences and foreign tables.)</source>
          <target state="translated">テーブルは検索パスに表示されていますか?(これは、ビュー、マテリアライズド・ビュー、インデックス、シーケンス、外部テーブルなど、すべてのタイプのリレーションで動作します)</target>
        </trans-unit>
        <trans-unit id="c16dfcb2d9f33c5ed1d4f60e7e94de5cdb8bb497" translate="yes" xml:space="preserve">
          <source>Is text search configuration visible in search path?</source>
          <target state="translated">テキスト検索の設定は検索パスに表示されますか?</target>
        </trans-unit>
        <trans-unit id="b171387fa6a48bfddce09bcc6374af3cb74ce2b7" translate="yes" xml:space="preserve">
          <source>Is text search dictionary visible in search path?</source>
          <target state="translated">テキスト検索の辞書は検索パスに表示されますか?</target>
        </trans-unit>
        <trans-unit id="cb8ecee88af93cf9199b28e0c89bec38e335e65b" translate="yes" xml:space="preserve">
          <source>Is text search parser visible in search path?</source>
          <target state="translated">テキスト検索パーサは検索パスに表示されますか?</target>
        </trans-unit>
        <trans-unit id="ea7a21a45c17bac5fc36d8a030345a04d716413b" translate="yes" xml:space="preserve">
          <source>Is text search template visible in search path?</source>
          <target state="translated">テキスト検索のテンプレートは検索パスに表示されますか?</target>
        </trans-unit>
        <trans-unit id="0992b021bae889bee0f11abcbb95dee7929e73aa" translate="yes" xml:space="preserve">
          <source>Is the collation deterministic?</source>
          <target state="translated">照合は決定論的なのか?</target>
        </trans-unit>
        <trans-unit id="8a25c1b43d537dd1a7d2ddd1e8080433f5e3eacd" translate="yes" xml:space="preserve">
          <source>Is the constraint deferrable?</source>
          <target state="translated">制約は延期可能ですか?</target>
        </trans-unit>
        <trans-unit id="fef490f8fe9dee88c33c6a89d30667da1bd2fb9a" translate="yes" xml:space="preserve">
          <source>Is the constraint deferred by default?</source>
          <target state="translated">制約はデフォルトで延期されていますか?</target>
        </trans-unit>
        <trans-unit id="f2477e67686fc75771da395271b903b89c805e05" translate="yes" xml:space="preserve">
          <source>Is the element contained in the range?</source>
          <target state="translated">要素が範囲に含まれているか?</target>
        </trans-unit>
        <trans-unit id="48e41905df707985819a963b62a733ad231a70af" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; contained in the second?</source>
          <target state="translated">最初の &lt;code&gt;seg&lt;/code&gt; は2番目のセグメントに含まれていますか？</target>
        </trans-unit>
        <trans-unit id="c56a2a69c3c21bd55c585fa99939bf4f7fc0147c" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the left of the second? [a, b] &amp;lt;&amp;lt; [c, d] is true if b &amp;lt; c.</source>
          <target state="translated">最初の &lt;code&gt;seg&lt;/code&gt; 完全に2番目のセグメントの左側にありますか？[a、b] &amp;lt;&amp;lt; [c、d]は、b &amp;lt;cの場合に真になります。</target>
        </trans-unit>
        <trans-unit id="ee8b00f339a2f532b4e9c2b55069412b977dc8e8" translate="yes" xml:space="preserve">
          <source>Is the first &lt;code&gt;seg&lt;/code&gt; entirely to the right of the second? [a, b] &amp;gt;&amp;gt; [c, d] is true if a &amp;gt; d.</source>
          <target state="translated">最初の &lt;code&gt;seg&lt;/code&gt; 完全に2番目のセグメントの右側にありますか？[a、b] &amp;gt;&amp;gt; [c、d]は、a&amp;gt; dの場合に真になります。</target>
        </trans-unit>
        <trans-unit id="aea89b97de3ee5955142d5113dfb9dcdb02c115c" translate="yes" xml:space="preserve">
          <source>Is the first JSON value contained in the second?</source>
          <target state="translated">1つ目のJSON値は2つ目のJSON値に含まれていますか?</target>
        </trans-unit>
        <trans-unit id="19d335f2a70cca44d7330f0d373f5cb2960385ef" translate="yes" xml:space="preserve">
          <source>Is the first array contained by the second?</source>
          <target state="translated">1番目の配列は2番目の配列に含まれていますか?</target>
        </trans-unit>
        <trans-unit id="07c8facc78abfeb194236811a0926e5445b93180" translate="yes" xml:space="preserve">
          <source>Is the first cube contained in the second?</source>
          <target state="translated">1つ目の立方体は2つ目の立方体に含まれていますか?</target>
        </trans-unit>
        <trans-unit id="e609c817143333de1521a8cf7a158b827be99cd2" translate="yes" xml:space="preserve">
          <source>Is the first range contained by the second?</source>
          <target state="translated">1つ目の範囲は2つ目の範囲に含まれていますか?</target>
        </trans-unit>
        <trans-unit id="68559d84b5ac88d0e9e0f63a5f0039af51bf0f9e" translate="yes" xml:space="preserve">
          <source>Is the first range strictly left of the second?</source>
          <target state="translated">第一レンジは厳密には第二レンジの左なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="bf2611d9965b16ffb44827feb465cfe43a1b6dc3" translate="yes" xml:space="preserve">
          <source>Is the first range strictly right of the second?</source>
          <target state="translated">第一範囲は厳密には第二範囲の右なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="3225d84455e28cf3582ea057725108c97e83f30e" translate="yes" xml:space="preserve">
          <source>Is the given transaction ID &lt;em&gt;visible&lt;/em&gt; according to this snapshot (that is, was it completed before the snapshot was taken)? Note that this function will not give the correct answer for a subtransaction ID.</source>
          <target state="translated">指定されたトランザクションIDは、このスナップショットに従って&lt;em&gt;表示&lt;/em&gt;されますか（つまり、スナップショットが作成される前に完了しましたか）？この関数は、サブトランザクションIDに対して正しい答えを与えないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="db516f5dadc3d5e25dea043648eeea3321f5ccdb" translate="yes" xml:space="preserve">
          <source>Is the page dirty?</source>
          <target state="translated">ページが汚い?</target>
        </trans-unit>
        <trans-unit id="7a5b28f2abec65dff2a005cef1bab93ce79757ac" translate="yes" xml:space="preserve">
          <source>Is the policy permissive or restrictive?</source>
          <target state="translated">ポリシーは寛容なのか、それとも制限的なのか?</target>
        </trans-unit>
        <trans-unit id="1c868da3e376b67ccb29be6664b407ae22b09b84" translate="yes" xml:space="preserve">
          <source>Is the range empty?</source>
          <target state="translated">範囲は空ですか?</target>
        </trans-unit>
        <trans-unit id="ff182ac571c70913b62ea8bad05f34c331a87f89" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound inclusive?</source>
          <target state="translated">範囲の下界は含まれていますか?</target>
        </trans-unit>
        <trans-unit id="ca739e6c1b1df7d98a703e7f4cf56e0c0b73eb1f" translate="yes" xml:space="preserve">
          <source>Is the range's lower bound infinite?</source>
          <target state="translated">範囲の下界は無限大ですか?</target>
        </trans-unit>
        <trans-unit id="d3f822412dc56d423cd1651a21ff0e5c86774082" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound inclusive?</source>
          <target state="translated">範囲の上限が含まれていますか?</target>
        </trans-unit>
        <trans-unit id="6edd78c835bde36ba19726c52d54bb7fc15f1a47" translate="yes" xml:space="preserve">
          <source>Is the range's upper bound infinite?</source>
          <target state="translated">範囲の上限は無限大ですか?</target>
        </trans-unit>
        <trans-unit id="69a6303395c0e1b94086b05146ed59054275f0b9" translate="yes" xml:space="preserve">
          <source>Is type (or domain) visible in search path?</source>
          <target state="translated">検索パスにタイプ(またはドメイン)が表示されていますか?</target>
        </trans-unit>
        <trans-unit id="272dd553360faca6d08c14d4f1b40a013a88fc82" translate="yes" xml:space="preserve">
          <source>Is vertical?</source>
          <target state="translated">垂直なのか?</target>
        </trans-unit>
        <trans-unit id="616318d9db61d03876a33f8c27e6df459bd2eff6" translate="yes" xml:space="preserve">
          <source>Isolation</source>
          <target state="translated">Isolation</target>
        </trans-unit>
        <trans-unit id="04fa9226f0713bae8b60402f090506b8771675ec" translate="yes" xml:space="preserve">
          <source>Isolation Level</source>
          <target state="translated">絶縁レベル</target>
        </trans-unit>
        <trans-unit id="5ef461ce76cd9304ad8686fa89152e4b6011f931" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries support splitting compound words; a useful feature. Notice that the affix file should specify a special flag using the &lt;code&gt;compoundwords controlled&lt;/code&gt; statement that marks dictionary words that can participate in compound formation:</source>
          <target state="translated">Ispell辞書は複合語の分割をサポートしています。便利な機能。接辞ファイルでは、複合語の形成に参加できる辞書の単語をマークする &lt;code&gt;compoundwords controlled&lt;/code&gt; ステートメントを使用して、特別なフラグを指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a44764c80f1ba0b240d3f5d527b95ad90a01a872" translate="yes" xml:space="preserve">
          <source>Ispell dictionaries usually recognize a limited set of words, so they should be followed by another broader dictionary; for example, a Snowball dictionary, which recognizes everything.</source>
          <target state="translated">Ispell辞書は通常、限られた単語のセットを認識するので、それに続いて別のより広い辞書を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d78243d5b6a6182e6f2ddf831b4aabfb7caae3f0" translate="yes" xml:space="preserve">
          <source>Issues a verification prompt before doing anything destructive.</source>
          <target state="translated">破壊的なことをする前に検証プロンプトを発行します。</target>
        </trans-unit>
        <trans-unit id="f4c1344e1b107a94e97cb2d1c0387b09d48b1998" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ABORT&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">トランザクションブロックの外部で &lt;code&gt;ABORT&lt;/code&gt; を発行すると警告が発せられ、それ以外の場合は効果がありません。</target>
        </trans-unit>
        <trans-unit id="51092034eb6099bfab57ce2cf44c57b972ed851c" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;BEGIN&lt;/code&gt; when already inside a transaction block will provoke a warning message. The state of the transaction is not affected. To nest transactions within a transaction block, use savepoints (see &lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;).</source>
          <target state="translated">すでにトランザクションブロック内で &lt;code&gt;BEGIN&lt;/code&gt; を発行すると、警告メッセージが表示されます。トランザクションの状態は影響を受けません。トランザクションをトランザクションブロック内にネストするには、セーブポイントを使用します（&lt;a href=&quot;sql-savepoint&quot;&gt;SAVEPOINTを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1c66e92badb172759ea8ab0365668fbc4bfcd29b" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;COMMIT&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message. &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; when not inside a transaction is an error.</source>
          <target state="translated">トランザクション内にないときに &lt;code&gt;COMMIT&lt;/code&gt; を発行しても害はありませんが、警告メッセージが表示されます。トランザクション内にない場合の &lt;code&gt;COMMIT AND CHAIN&lt;/code&gt; はエラーです。</target>
        </trans-unit>
        <trans-unit id="d8f2914a3de77623d7fcc2d76c1402e19f0682c2" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;END&lt;/code&gt; when not inside a transaction does no harm, but it will provoke a warning message.</source>
          <target state="translated">トランザクション内にないときに &lt;code&gt;END&lt;/code&gt; を発行しても害はありませんが、警告メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="9a3f1f230232d57deb86f9d1d1a7e859eaa17234" translate="yes" xml:space="preserve">
          <source>Issuing &lt;code&gt;ROLLBACK&lt;/code&gt; outside of a transaction block emits a warning and otherwise has no effect. &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; outside of a transaction block is an error.</source>
          <target state="translated">トランザクションブロックの外部で &lt;code&gt;ROLLBACK&lt;/code&gt; を発行すると警告が発行され、それ以外の場合は効果がありません。トランザクションブロック外の &lt;code&gt;ROLLBACK AND CHAIN&lt;/code&gt; はエラーです。</target>
        </trans-unit>
        <trans-unit id="1dd72b5f30a56642ade69ef87bd0dd32591ebc8c" translate="yes" xml:space="preserve">
          <source>It can be used as a top-level command or as a space-saving syntax variant in parts of complex queries. Only the &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, &lt;code&gt;EXCEPT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, &lt;code&gt;OFFSET&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;FOR&lt;/code&gt; locking clauses can be used with &lt;code&gt;TABLE&lt;/code&gt;; the &lt;code&gt;WHERE&lt;/code&gt; clause and any form of aggregation cannot be used.</source>
          <target state="translated">最上位のコマンドとして、または複雑なクエリの一部で省スペースの構文バリアントとして使用できます。 &lt;code&gt;TABLE&lt;/code&gt; で使用できるのは、 &lt;code&gt;WITH&lt;/code&gt; 、 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、 &lt;code&gt;EXCEPT&lt;/code&gt; 、 &lt;code&gt;ORDER BY&lt;/code&gt; 、 &lt;code&gt;LIMIT&lt;/code&gt; 、 &lt;code&gt;OFFSET&lt;/code&gt; 、 &lt;code&gt;FETCH&lt;/code&gt; および &lt;code&gt;FOR&lt;/code&gt; ロック句のみです。 &lt;code&gt;WHERE&lt;/code&gt; 句および凝集の任意の形態を使用することができません。</target>
        </trans-unit>
        <trans-unit id="985845c593d43702ba4580f789c62a95ef3e445a" translate="yes" xml:space="preserve">
          <source>It can return 2 special key IDs:</source>
          <target state="translated">2つの特殊なキーIDを返すことができます。</target>
        </trans-unit>
        <trans-unit id="e06e730d80da388853db0ab9a33a7b2a082e1e65" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">レプリケーションモードの接続を作成するため、&lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;と同じ制約に加えて、論理レプリケーションの制約が適用されます（&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="34093efa4b222287cf39e63aac85890d7758d772" translate="yes" xml:space="preserve">
          <source>It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</source>
          <target state="translated">It creates a replication-mode connection, so it is subject to the same constraints as &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;, plus those for logical replication (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="ee4e1383f1e9f315e70a9d76f0a1946de5a791a1" translate="yes" xml:space="preserve">
          <source>It does not matter which order the opposite corners of a cube are entered in. The &lt;code&gt;cube&lt;/code&gt; functions automatically swap values if needed to create a uniform &amp;ldquo;lower left &amp;mdash; upper right&amp;rdquo; internal representation. When the corners coincide, &lt;code&gt;cube&lt;/code&gt; stores only one corner along with an &amp;ldquo;is point&amp;rdquo; flag to avoid wasting space.</source>
          <target state="translated">立方体の反対側の角が入力される順序は関係ありません。 &lt;code&gt;cube&lt;/code&gt; 関数は、均一な「左下-右上」の内部表現を作成する必要がある場合、値を自動的に入れ替えます。コーナーが一致する場合、 &lt;code&gt;cube&lt;/code&gt; はスペースを無駄にしないように、「is point」フラグとともにコーナーを1つだけ格納します。</target>
        </trans-unit>
        <trans-unit id="aeb260c8d10781feddd45ff6a16008fdceb285b4" translate="yes" xml:space="preserve">
          <source>It does so by first creating all possible &lt;em&gt;paths&lt;/em&gt; leading to the same result. For example if there is an index on a relation to be scanned, there are two paths for the scan. One possibility is a simple sequential scan and the other possibility is to use the index. Next the cost for the execution of each path is estimated and the cheapest path is chosen. The cheapest path is expanded into a complete plan that the executor can use.</source>
          <target state="translated">まず、同じ結果につながるすべての可能な&lt;em&gt;パスを&lt;/em&gt;作成し&lt;em&gt;ます&lt;/em&gt;。たとえば、スキャンするリレーションにインデックスがある場合、スキャンには2つのパスがあります。1つの可能性は単純な順次スキャンであり、もう1つの可能性はインデックスを使用することです。次に、各パスの実行コストが推定され、最も安価なパスが選択されます。最も安いパスは、エグゼキュータが使用できる完全なプランに拡張されます。</target>
        </trans-unit>
        <trans-unit id="22062c54b59724e3ba4ff79971e8d1516ebd1cef" translate="yes" xml:space="preserve">
          <source>It does this by skipping pages that have only visible tuples according to the visibility map (if a page has the corresponding VM bit set, then it is assumed to contain no dead tuples). For such pages, it derives the free space value from the free space map, and assumes that the rest of the space on the page is taken up by live tuples.</source>
          <target state="translated">これは、可視性マップに従って可視タプルのみを持つページをスキップすることによって行われます(ページに対応するVMビットがセットされている場合、デッドタプルは含まれていないと仮定されます)。そのようなページについては、空き領域マップから空き領域の値を導出し、ページ上の残りの領域がライブタプルによって占められていると仮定します。</target>
        </trans-unit>
        <trans-unit id="289bb6de0c119ae341fea7727f0ae465a6ffb7a2" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; recommended that you override this behavior by changing the session-level settings of these parameters; that is likely to cause &lt;code&gt;postgres_fdw&lt;/code&gt; to malfunction.</source>
          <target state="translated">これらのパラメーターのセッションレベルの設定を変更して、この動作を上書きすることはお勧めし&lt;em&gt;ません&lt;/em&gt;。これにより、 &lt;code&gt;postgres_fdw&lt;/code&gt; が誤動作する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1927f65da9f3267669c003e30b5762ebad0dc5a9" translate="yes" xml:space="preserve">
          <source>It is a good idea to save the database server's log output somewhere, rather than just discarding it via &lt;code&gt;/dev/null&lt;/code&gt;. The log output is invaluable when diagnosing problems. However, the log output tends to be voluminous (especially at higher debug levels) so you won't want to save it indefinitely. You need to &lt;em&gt;rotate&lt;/em&gt; the log files so that new log files are started and old ones removed after a reasonable period of time.</source>
          <target state="translated">データベースサーバーのログ出力を &lt;code&gt;/dev/null&lt;/code&gt; 経由で単に破棄するのではなく、どこかに保存することをお勧めします。ログ出力は、問題を診断する際に非常に役立ちます。ただし、ログ出力は（特に、より高いデバッグレベルで）膨大になる傾向があるため、無期限に保存する必要はありません。新しいログファイルが開始され、古いログファイルが妥当な期間後に削除される&lt;em&gt;ように&lt;/em&gt;、ログファイルを&lt;em&gt;ローテーション&lt;/em&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="45d3adbb3df378f5fff436872f95f728d888325a" translate="yes" xml:space="preserve">
          <source>It is advantageous if the log is located on a different disk from the main database files. This can be achieved by moving the &lt;code&gt;pg_wal&lt;/code&gt; directory to another location (while the server is shut down, of course) and creating a symbolic link from the original location in the main data directory to the new location.</source>
          <target state="translated">ログがメインのデータベースファイルとは別のディスクにある場合に有利です。これは、 &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリを別の場所に移動し（サーバーがシャットダウンしている間はもちろん）、メインデータディレクトリの元の場所から新しい場所へのシンボリックリンクを作成することで実現できます。</target>
        </trans-unit>
        <trans-unit id="25c2883a31f29210a79363008b59988d33c5a31b" translate="yes" xml:space="preserve">
          <source>It is advisable to set &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; to a reasonably large value (but not more than the amount of RAM you can dedicate to the &lt;code&gt;CLUSTER&lt;/code&gt; operation) before clustering.</source>
          <target state="translated">クラスタリングを行う前に、&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;を適度に大きな値（ただし、 &lt;code&gt;CLUSTER&lt;/code&gt; 操作専用にできるRAMの容量以下）に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f4c2ed49f12a870b96cb954dbc625ee0c439a239" translate="yes" xml:space="preserve">
          <source>It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, &lt;em&gt;and that it returns nonzero status in this case&lt;/em&gt;. The example command above for Unix ensures this by including a separate &lt;code&gt;test&lt;/code&gt; step. On some Unix platforms, &lt;code&gt;cp&lt;/code&gt; has switches such as &lt;code&gt;-i&lt;/code&gt; that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU &lt;code&gt;cp&lt;/code&gt; will return status zero when &lt;code&gt;-i&lt;/code&gt; is used and the target file already exists, which is &lt;em&gt;not&lt;/em&gt; the desired behavior.)</source>
          <target state="translated">提案されたアーカイブコマンドをテストして、実際に既存のファイルを上書きしない&lt;em&gt;こと&lt;/em&gt;、&lt;em&gt;およびこの場合はゼロ以外のステータスを返す&lt;/em&gt;ことを確認することをお勧めします。上記のUnixのコマンド例では、個別の &lt;code&gt;test&lt;/code&gt; ステップを含めることでこれを保証しています。一部のUnixプラットフォームでは、 &lt;code&gt;cp&lt;/code&gt; には &lt;code&gt;-i&lt;/code&gt; などのスイッチがあり、同じことをより簡潔に行うことができますが、正しい終了ステータスが返されることを確認せずにこれらに依存することはできません。 （特に、GNU &lt;code&gt;cp&lt;/code&gt; は、 &lt;code&gt;-i&lt;/code&gt; が使用され、ターゲットファイルが既に存在する場合、ステータス0を返しますが、これは望ましい動作ではあり&lt;em&gt;ません&lt;/em&gt;。）</target>
        </trans-unit>
        <trans-unit id="5ccc1a490a09faccece314c281e5a4bacdabe99b" translate="yes" xml:space="preserve">
          <source>It is also important to consider the overhead of partitioning during query planning and execution. The query planner is generally able to handle partition hierarchies with up to a few thousand partitions fairly well, provided that typical queries allow the query planner to prune all but a small number of partitions. Planning times become longer and memory consumption becomes higher when more partitions remain after the planner performs partition pruning. This is particularly true for the &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. Another reason to be concerned about having a large number of partitions is that the server's memory consumption may grow significantly over a period of time, especially if many sessions touch large numbers of partitions. That's because each partition requires its metadata to be loaded into the local memory of each session that touches it.</source>
          <target state="translated">クエリの計画と実行中にパーティション分割のオーバーヘッドを考慮することも重要です。一般的なクエリでクエリプランナーが少数のパーティションを除くすべてをプルーニングできる場合、クエリプランナーは通常、最大数千のパーティションを持つパーティション階層を適切に処理できます。プランナーがパーティションプルーニングを実行した後、さらに多くのパーティションが残っていると、計画時間が長くなり、メモリ消費が高くなります。これは特に &lt;code&gt;UPDATE&lt;/code&gt; と &lt;code&gt;DELETE&lt;/code&gt; に当てはまりますコマンド。多数のパーティションがあることを懸念するもう1つの理由は、特に多くのセッションが多数のパーティションにアクセスしている場合、サーバーのメモリ消費量が一定期間にわたって大幅に増加する可能性があることです。これは、各パーティションで、そのパーティションにアクセスする各セッションのローカルメモリにメタデータをロードする必要があるためです。</target>
        </trans-unit>
        <trans-unit id="08e56c7bbb1c5c1ca45ba0adfbd971830db5b40e" translate="yes" xml:space="preserve">
          <source>It is also possible to access the file as a foreign table, using the supplied &lt;a href=&quot;file-fdw&quot;&gt;file_fdw&lt;/a&gt; module.</source>
          <target state="translated">It is also possible to access the file as a foreign table, using the supplied &lt;a href=&quot;file-fdw&quot;&gt;file_fdw&lt;/a&gt; module.</target>
        </trans-unit>
        <trans-unit id="b8a8c0ea8274eada7feb8d1cce002d08a07341cc" translate="yes" xml:space="preserve">
          <source>It is also possible to construct an array from the results of a subquery. In this form, the array constructor is written with the key word &lt;code&gt;ARRAY&lt;/code&gt; followed by a parenthesized (not bracketed) subquery. For example:</source>
          <target state="translated">サブクエリの結果から配列を作成することもできます。この形式では、配列コンストラクターはキーワード &lt;code&gt;ARRAY&lt;/code&gt; に続けて括弧で囲まれた（括弧で囲まれていない）サブクエリで記述されます。例えば：</target>
        </trans-unit>
        <trans-unit id="21db650c844a5c99fb809ce100bf6bab36b3a9c1" translate="yes" xml:space="preserve">
          <source>It is also possible to create a chain of trust that includes intermediate certificates:</source>
          <target state="translated">中間証明書を含む信頼の連鎖を作ることも可能です。</target>
        </trans-unit>
        <trans-unit id="1bbde7dfe5218957bc7115e4bb121f93797376d5" translate="yes" xml:space="preserve">
          <source>It is also possible to implement record-based log shipping using this alternative method, though this requires custom development, and changes will still only become visible to hot standby queries after a full WAL file has been shipped.</source>
          <target state="translated">また、この代替方法を使用して記録ベースのログ出荷を実装することも可能ですが、これにはカスタム開発が必要で、変更は完全なWALファイルが出荷された後にホットスタンバイクエリにのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="a889ddd9646ac2e435b2d44d186929390a588c8e" translate="yes" xml:space="preserve">
          <source>It is also possible to insert the result of a query (which might be no rows, one row, or many rows):</source>
          <target state="translated">また、クエリの結果を挿入することも可能です(行がない、1行、または多くの行があるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="23dc30a3752f1a0512f87d6b42f04212daedc525" translate="yes" xml:space="preserve">
          <source>It is also possible to make a backup while the server is stopped. In this case, you obviously cannot use &lt;code&gt;pg_start_backup&lt;/code&gt; or &lt;code&gt;pg_stop_backup&lt;/code&gt;, and you will therefore be left to your own devices to keep track of which backup is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above.</source>
          <target state="translated">サーバーが停止しているときにバックアップを作成することもできます。この場合、明らかに &lt;code&gt;pg_start_backup&lt;/code&gt; または &lt;code&gt;pg_stop_backup&lt;/code&gt; を使用できないため、どのバックアップがどれで、関連するWALファイルがどこまで遡っているかを追跡するのは、自分のデバイスに任されます。通常は、上記の継続的なアーカイブ手順に従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6383187f9793f49474de63c9c18fca5ed6c8c44d" translate="yes" xml:space="preserve">
          <source>It is also possible to pass a page to &lt;code&gt;bt_page_items&lt;/code&gt; as a &lt;code&gt;bytea&lt;/code&gt; value. A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. So the last example could also be rewritten like this:</source>
          <target state="translated">また、ページを &lt;code&gt;bt_page_items&lt;/code&gt; に &lt;code&gt;bytea&lt;/code&gt; 値として渡すこともできます。 &lt;code&gt;get_raw_page&lt;/code&gt; で取得したページ画像を引数として渡す必要があります。したがって、最後の例は次のように書き換えることもできます。</target>
        </trans-unit>
        <trans-unit id="44f6da252a14d7892790fa503a4f493737f34471" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type cast using a function-like syntax:</source>
          <target state="translated">関数のような構文を使って型キャストを指定することも可能です。</target>
        </trans-unit>
        <trans-unit id="da0d70336d913c862f76912f7ff4b7d2cecbbfee" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a type coercion using a function-like syntax:</source>
          <target state="translated">関数のような構文を使って型強制を指定することも可能です。</target>
        </trans-unit>
        <trans-unit id="6ce33e1d5683bd1e633283bcca0d2a1c2815c050" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific database rather than to a role; see &lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASE&lt;/a&gt;. If there is a conflict, database-role-specific settings override role-specific ones, which in turn override database-specific ones.</source>
          <target state="translated">また、セッションのデフォルトをロールではなく特定のデータベースに関連付けることもできます。&lt;a href=&quot;sql-alterdatabase&quot;&gt;ALTER DATABASEを&lt;/a&gt;参照してください。競合がある場合は、データベースの役割固有の設定が役割固有の設定を上書きし、次にデータベース固有の設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="752073224562183bf86377a6f918beef1da4c653" translate="yes" xml:space="preserve">
          <source>It is also possible to tie a session default to a specific role rather than to a database; see &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;. Role-specific settings override database-specific ones if there is a conflict.</source>
          <target state="translated">セッションのデフォルトをデータベースではなく特定のロールに関連付けることもできます。&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLEを&lt;/a&gt;参照してください。競合がある場合、ロール固有の設定はデータベース固有の設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="c7b08ca18ddba24ea9814754a2d56bec9634faff" translate="yes" xml:space="preserve">
          <source>It is also possible to use arbitrary expressions in the &lt;code&gt;ORDER BY&lt;/code&gt; clause, including columns that do not appear in the &lt;code&gt;SELECT&lt;/code&gt; output list. Thus the following statement is valid:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 出力リストに表示されない列を含む、 &lt;code&gt;ORDER BY&lt;/code&gt; 句で任意の式を使用することもできます。したがって、次のステートメントは有効です。</target>
        </trans-unit>
        <trans-unit id="f4e580c8b0c33e188baa71c64a617a90c70459e7" translate="yes" xml:space="preserve">
          <source>It is also possible to use logical replication methods to create a standby server with the updated version of PostgreSQL. This is possible because logical replication supports replication between different major versions of PostgreSQL. The standby can be on the same computer or a different computer. Once it has synced up with the master server (running the older version of PostgreSQL), you can switch masters and make the standby the master and shut down the older database instance. Such a switch-over results in only several seconds of downtime for an upgrade.</source>
          <target state="translated">また、論理レプリケーションの方法を使用して、更新されたバージョンのPostgreSQLで待機サーバを作成することも可能です。論理レプリケーションはPostgreSQLの異なるメジャーバージョン間のレプリケーションをサポートしているため、これが可能です。待機サーバは同じコンピュータ上にあっても、別のコンピュータ上にあっても構いません。マスタサーバ(古いバージョンのPostgreSQLを実行している)と同期したら、マスタを切り替えてスタンバイをマスタとし、古いデータベースインスタンスをシャットダウンすることができます。このような切り替えにより、アップグレードのためのダウンタイムは数秒で済みます。</target>
        </trans-unit>
        <trans-unit id="2f14f1cce0e64f81899ff66a139003d88acce025" translate="yes" xml:space="preserve">
          <source>It is an error to mix configuration options for simple bind with options for search+bind.</source>
          <target state="translated">シンプルバインドの設定オプションと検索+バインドのオプションが混在しているのはエラーです。</target>
        </trans-unit>
        <trans-unit id="8a93dfee21deef6822077b576885ec96bea313d5" translate="yes" xml:space="preserve">
          <source>It is best not to use SIGKILL to shut down the server. Doing so will prevent the server from releasing shared memory and semaphores. Furthermore, SIGKILL kills the &lt;code&gt;postgres&lt;/code&gt; process without letting it relay the signal to its subprocesses, so it might be necessary to kill the individual subprocesses by hand as well.</source>
          <target state="translated">SIGKILLを使用してサーバーをシャットダウンしないことをお勧めします。これを行うと、サーバーが共有メモリとセマフォを解放できなくなります。さらに、SIGKILLは &lt;code&gt;postgres&lt;/code&gt; プロセスを強制終了しますが、シグナルをサブプロセスに中継させないため、個々のサブプロセスも手動で強制終了する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="03425b40ae836e9eabd64694b0fe5bdd09ab82f4" translate="yes" xml:space="preserve">
          <source>It is best not to use parallelism when restoring from an archive made with this option, because pg_restore will not know exactly which partition(s) a given archive data item will load data into. This could result in inefficiency due to lock conflicts between parallel jobs, or perhaps even reload failures due to foreign key constraints being set up before all the relevant data is loaded.</source>
          <target state="translated">このオプションを使用して作成されたアーカイブからリストアする際には、並列処理を使用しない方が良いでしょう。なぜならば、pg_restoreは与えられたアーカイブデータ項目がどのパーティションにデータをロードするかを正確に把握していないからです。これは、並列ジョブ間でのロックの競合による非効率性や、すべての関連データがロードされる前に外部キー制約が設定されるためにリロードに失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="98e38adf41282f06a6bcba53d9fb2cad2cffe8b4" translate="yes" xml:space="preserve">
          <source>It is common for a client that executes &lt;code&gt;NOTIFY&lt;/code&gt; to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the application logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; を実行するクライアントが同じ通知チャネル自体をリッスンすることは一般的です。その場合、他のすべてのリスニングセッションと同様に、通知イベントが返されます。アプリケーションロジックによっては、データベーステーブルを読み取って、そのセッションが書き込んだのと同じ更新を見つけるなど、無駄な作業が発生する可能性があります。通知セッションのサーバープロセスPID（通知イベントメッセージで提供）が自分のセッションのPID（libpqから入手可能）と同じであるかどうかを通知することで、このような余分な作業を回避できます。それらが同じ場合、通知イベントは自分自身の跳ね返りであり、無視できます。</target>
        </trans-unit>
        <trans-unit id="c9caa8dc8a351442eebfc90a7900dd2df9e2e966" translate="yes" xml:space="preserve">
          <source>It is common to see slow queries running bad execution plans because multiple columns used in the query clauses are correlated. The planner normally assumes that multiple conditions are independent of each other, an assumption that does not hold when column values are correlated. Regular statistics, because of their per-individual-column nature, cannot capture any knowledge about cross-column correlation. However, PostgreSQL has the ability to compute &lt;em&gt;multivariate statistics&lt;/em&gt;, which can capture such information.</source>
          <target state="translated">クエリ句で使用されている複数の列が相互に関連付けられているため、遅いクエリで実行プランが正しく実行されないことがよくあります。通常、プランナは、複数の条件が互いに独立していると想定します。これは、列の値が相関している場合は成立しないという想定です。定期的な統計は、個々の列ごとの性質のため、列間の相関に関する知識をキャプチャできません。ただし、PostgreSQLには&lt;em&gt;多変量統計&lt;/em&gt;を計算する機能があり、そのような情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="716e43860306866d146f9c899994b23176f3323e" translate="yes" xml:space="preserve">
          <source>It is difficult to formulate a general procedure for determining which indexes to create. There are a number of typical cases that have been shown in the examples throughout the previous sections. A good deal of experimentation is often necessary. The rest of this section gives some tips for that:</source>
          <target state="translated">どのインデックスを作成するかを決定するための一般的な手順を策定することは困難である。これまでのセクションを通して例示してきた典型的なケースがいくつかあります。多くの場合、多くの実験が必要となります。このセクションの残りの部分では、そのためのヒントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="8e2e75db678536414073cb564abf9bafb8f65d0c" translate="yes" xml:space="preserve">
          <source>It is easy to find your largest tables and indexes using this information:</source>
          <target state="translated">この情報を利用して、最大のテーブルやインデックスを簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="e1f4af27f8aaeea1d69cd838327e07079c59b331" translate="yes" xml:space="preserve">
          <source>It is encrypted using the public key and put into the session key packet.</source>
          <target state="translated">公開鍵を使って暗号化し、セッションキーパケットに入れます。</target>
        </trans-unit>
        <trans-unit id="c1facaa0d2b2d45958e470a68a811dfa56fbe0cc" translate="yes" xml:space="preserve">
          <source>It is especially fatal to use very small test data sets. While selecting 1000 out of 100000 rows could be a candidate for an index, selecting 1 out of 100 rows will hardly be, because the 100 rows probably fit within a single disk page, and there is no plan that can beat sequentially fetching 1 disk page.</source>
          <target state="translated">特に、非常に小さなテストデータセットを使用するのは致命的です。100000行のうち1000行を選択することはインデックスの候補になるかもしれませんが、100行のうち1行を選択することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="19ad949d23432743231dc352c6a17b2b375d15f1" translate="yes" xml:space="preserve">
          <source>It is essential that the same parameters are passed in order to obtain matching XML data mappings and XML Schema documents.</source>
          <target state="translated">一致するXMLデータマッピングとXML Schemaドキュメントを取得するためには、同じパラメータを渡すことが不可欠です。</target>
        </trans-unit>
        <trans-unit id="3a50daa221b6ada829c86621c1e1031f8d10ee63" translate="yes" xml:space="preserve">
          <source>It is even possible for repeated executions of the same &lt;code&gt;LIMIT&lt;/code&gt; query to return different subsets of the rows of a table, if there is not an &lt;code&gt;ORDER BY&lt;/code&gt; to enforce selection of a deterministic subset. Again, this is not a bug; determinism of the results is simply not guaranteed in such a case.</source>
          <target state="translated">確定的なサブセットの選択を強制する &lt;code&gt;ORDER BY&lt;/code&gt; がない場合、同じ &lt;code&gt;LIMIT&lt;/code&gt; クエリを繰り返し実行して、テーブルの行の異なるサブセットを返すこともできます。繰り返しますが、これはバグではありません。このような場合、結果の確定性は保証されません。</target>
        </trans-unit>
        <trans-unit id="10042e013ab2c07aefb508d6fa86ca0af029f7db" translate="yes" xml:space="preserve">
          <source>It is frequently convenient to group users together to ease management of privileges: that way, privileges can be granted to, or revoked from, a group as a whole. In PostgreSQL this is done by creating a role that represents the group, and then granting &lt;em&gt;membership&lt;/em&gt; in the group role to individual user roles.</source>
          <target state="translated">特権の管理を容易にするためにユーザーをグループ化すると便利なことがよくあります。このようにして、グループ全体に特権を付与したり、グループから取り消したりすることができます。PostgreSQLでは、これはグループを表すロールを作成し、グループロールの&lt;em&gt;メンバーシップ&lt;/em&gt;を個々のユーザーロールに付与することで行われます。</target>
        </trans-unit>
        <trans-unit id="c7233cabce0e70bf9b6042d864213cd71aa539f4" translate="yes" xml:space="preserve">
          <source>It is generally recommended that the columns of a foreign table be declared with exactly the same data types, and collations if applicable, as the referenced columns of the remote table. Although &lt;code&gt;postgres_fdw&lt;/code&gt; is currently rather forgiving about performing data type conversions at need, surprising semantic anomalies may arise when types or collations do not match, due to the remote server interpreting &lt;code&gt;WHERE&lt;/code&gt; clauses slightly differently from the local server.</source>
          <target state="translated">一般に、外部テーブルの列は、リモートテーブルの参照される列とまったく同じデータ型、および該当する場合は照合順序で宣言することをお勧めします。が &lt;code&gt;postgres_fdw&lt;/code&gt; は現在、むしろ必要でデータ型変換を実行について寛容である種類や照合順序は、通訳リモートサーバによる一致しないとき、驚くべきセマンティック異常が発生する可能性のある句若干異なるローカルサーバから。 &lt;code&gt;WHERE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e59537e8306049dacf2891d27c403a8ccf0ae6a3" translate="yes" xml:space="preserve">
          <source>It is generally recommended to use &lt;code&gt;FOR UPDATE&lt;/code&gt; if the cursor is intended to be used with &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; or &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt;. Using &lt;code&gt;FOR UPDATE&lt;/code&gt; prevents other sessions from changing the rows between the time they are fetched and the time they are updated. Without &lt;code&gt;FOR UPDATE&lt;/code&gt;, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; command will have no effect if the row was changed since the cursor was created.</source>
          <target state="translated">カーソルを &lt;code&gt;UPDATE ... WHERE CURRENT OF&lt;/code&gt; または &lt;code&gt;DELETE ... WHERE CURRENT OF&lt;/code&gt; で使用する場合は、一般に &lt;code&gt;FOR UPDATE&lt;/code&gt; を使用することをお勧めします。 &lt;code&gt;FOR UPDATE&lt;/code&gt; を使用すると、他のセッションが行がフェッチされてから更新されるまでの間に行が変更されるのを防ぎます。 &lt;code&gt;FOR UPDATE&lt;/code&gt; がなければ、カーソルが作成されてから行が変更された場合、後続の &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; コマンドは効果がありません。</target>
        </trans-unit>
        <trans-unit id="a83872fa85fd0323d70dd24a91d302ff7029d1c0" translate="yes" xml:space="preserve">
          <source>It is good practice to create a role that has the &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; privileges, but is not a superuser, and then use this role for all routine management of databases and roles. This approach avoids the dangers of operating as a superuser for tasks that do not really require it.</source>
          <target state="translated">&lt;code&gt;CREATEDB&lt;/code&gt; 特権と &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持っているがスーパーユーザーではないロールを作成し、データベースとロールのすべての日常的な管理にこのロールを使用することをお勧めします。このアプローチは、実際には必要としないタスクのスーパーユーザーとして操作する危険を回避します。</target>
        </trans-unit>
        <trans-unit id="de68fd3161d79a0dbb9addbaa913d55e1165d0a6" translate="yes" xml:space="preserve">
          <source>It is important for the command to return a zero exit status only if it succeeds. The command &lt;em&gt;will&lt;/em&gt; be asked for file names that are not present in the archive; it must return nonzero when so asked. Examples:</source>
          <target state="translated">コマンドは、成功した場合にのみゼロの終了ステータスを返すことが重要です。コマンド&lt;em&gt;は&lt;/em&gt;、アーカイブに存在しないファイル名を要求されます。要求された場合はゼロ以外を返す必要があります。例：</target>
        </trans-unit>
        <trans-unit id="cf6c5b8023371ed1577875e84b0b18cba96de2de" translate="yes" xml:space="preserve">
          <source>It is important that the &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; string not appear in any key values, else &lt;code&gt;connectby&lt;/code&gt; may incorrectly report an infinite-recursion error. Note that if &lt;em&gt;&lt;code&gt;branch_delim&lt;/code&gt;&lt;/em&gt; is not provided, a default value of &lt;code&gt;~&lt;/code&gt; is used for recursion detection purposes.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;文字列がどのキー値にも &lt;code&gt;connectby&lt;/code&gt; れていないことが重要です。&lt;em&gt;そうし&lt;/em&gt;ないと、connectbyが誤って無限再帰エラーを報告する可能性があります。&lt;em&gt; &lt;code&gt;branch_delim&lt;/code&gt; &lt;/em&gt;が指定されていない場合、再帰検出の目的でデフォルト値 &lt;code&gt;~&lt;/code&gt; が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b1ae60071a0616a68a075f0ef2a5eb0bf24ed27b" translate="yes" xml:space="preserve">
          <source>It is important that the administrator select appropriate settings for &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;. The best choices vary depending on business priorities. For example if the server is primarily tasked as a High Availability server, then you will want low delay settings, perhaps even zero, though that is a very aggressive setting. If the standby server is tasked as an additional server for decision support queries then it might be acceptable to set the maximum delay values to many hours, or even -1 which means wait forever for queries to complete.</source>
          <target state="translated">管理者が&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delayの&lt;/a&gt;適切な設定を選択することが重要です。最適な選択肢は、ビジネスの優先順位によって異なります。たとえば、サーバーが主に高可用性サーバーとして機能している場合は、非常に積極的な設定ですが、遅延をできるだけ低く設定することをお勧めします。スタンバイサーバーが意思決定支援クエリの追加サーバーとして機能している場合は、最大遅延値を何時間にも設定できます。-1にしても、クエリが完了するまで永久に待機することになります。</target>
        </trans-unit>
        <trans-unit id="261ccf1229f9ce7bf8e5f6c3bd334b4a4c87db09" translate="yes" xml:space="preserve">
          <source>It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, PostgreSQL will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells PostgreSQL that the file was not archived; it will try again periodically until it succeeds.</source>
          <target state="translated">アーカイブコマンドが成功した場合にのみ、終了ステータスを0にすることが重要です。0の結果が得られた場合、PostgreSQLはファイルが正常にアーカイブされたものとみなし、ファイルを削除したりリサイクルしたりします。しかし、0以外の状態はPostgreSQLにファイルがアーカイブされていないことを伝えます。</target>
        </trans-unit>
        <trans-unit id="696e699e4bfd8bcf4f4c70ae89306a775c1076ba" translate="yes" xml:space="preserve">
          <source>It is important that the command return nonzero exit status on failure. The command &lt;em&gt;will&lt;/em&gt; be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">失敗した場合、コマンドがゼロ以外の終了ステータスを返すことが重要です。コマンド&lt;em&gt;は&lt;/em&gt;、アーカイブに存在しないファイルを要求&lt;em&gt;する&lt;/em&gt;ために呼び出されます。要求された場合はゼロ以外を返す必要があります。これはエラー状態ではありません。例外は、コマンドがシグナル（データベースサーバーのシャットダウンの一部として使用されるSIGTERM以外）またはシェルによるエラー（コマンドが見つからないなど）によって終了した場合、リカバリは中止され、サーバーは起動しない。</target>
        </trans-unit>
        <trans-unit id="23edc6be4b94044ef5894353c32ee9e7375bcbf5" translate="yes" xml:space="preserve">
          <source>It is important to note that the ranking functions do not use any global information, so it is impossible to produce a fair normalization to 1% or 100% as sometimes desired. Normalization option 32 (&lt;code&gt;rank/(rank+1)&lt;/code&gt;) can be applied to scale all ranks into the range zero to one, but of course this is just a cosmetic change; it will not affect the ordering of the search results.</source>
          <target state="translated">ランキング関数はグローバル情報を使用しないため、必要に応じて1％または100％に公平に正規化することは不可能です。正規化オプション32（ &lt;code&gt;rank/(rank+1)&lt;/code&gt; ）を適用して、すべてのランクを0〜1の範囲にスケーリングできますが、これは単なる表面的な変更です。検索結果の順序には影響しません。</target>
        </trans-unit>
        <trans-unit id="52fc312b2cbf7e2b75157d95cff3456da87ba73a" translate="yes" xml:space="preserve">
          <source>It is important to note that the validation which is performed by pg_verifybackup does not and can not include every check which will be performed by a running server when attempting to make use of the backup. Even if you use this tool, you should still perform test restores and verify that the resulting databases work as expected and that they appear to contain the correct data. However, pg_verifybackup can detect many problems that commonly occur due to storage problems or user error.</source>
          <target state="translated">pg_verifybackupによって実行される検証は、バックアップを利用しようとしたときに実行中のサーバによって実行されるすべてのチェックを含んでいるわけではなく、また含んでいないことに注意することが重要です。このツールを使用する場合でも、テストリストアを実行し、結果として得られるデータベースが期待通りに動作し、正しいデータが含まれているように見えるかどうかを検証する必要があります。しかし、pg_verifybackupは、ストレージの問題やユーザエラーのために一般的に発生する多くの問題を検出することができます。</target>
        </trans-unit>
        <trans-unit id="9a6953b33213a41a821ecf81913686f5a307e4e2" translate="yes" xml:space="preserve">
          <source>It is important to store the server's stdout and stderr output somewhere, as shown above. It will help for auditing purposes and to diagnose problems. (See &lt;a href=&quot;logfile-maintenance&quot;&gt;Section 24.3&lt;/a&gt; for a more thorough discussion of log file handling.)</source>
          <target state="translated">上記のように、サーバーのstdoutおよびstderr出力をどこかに保存することが重要です。これは、監査の目的と問題の診断に役立ちます。（ログファイルの処理の詳細については、&lt;a href=&quot;logfile-maintenance&quot;&gt;セクション24.3&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="0c277ac6ce904cf376b200217f724f1a32321205" translate="yes" xml:space="preserve">
          <source>It is important to understand before studying &lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;Table C.1&lt;/a&gt; that the fact that a key word is not reserved in PostgreSQL does not mean that the feature related to the word is not implemented. Conversely, the presence of a key word does not indicate the existence of a feature.</source>
          <target state="translated">&lt;a href=&quot;sql-keywords-appendix#KEYWORDS-TABLE&quot;&gt;表C.1&lt;/a&gt;を学習する前に、キーワードがPostgreSQLで予約されていないということは、その単語に関連する機能が実装されていないことを意味しないことを理解することが重要です。逆に、キーワードの存在は機能の存在を示しません。</target>
        </trans-unit>
        <trans-unit id="2afb84d06182545308e408bb344e52041de5bb4d" translate="yes" xml:space="preserve">
          <source>It is important to understand that the &lt;code&gt;tsvector&lt;/code&gt; type itself does not perform any word normalization; it assumes the words it is given are normalized appropriately for the application. For example,</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; タイプ自体は単語の正規化を実行しないことを理解することが重要です。与えられた単語がアプリケーションに対して適切に正規化されていることを前提としています。例えば、</target>
        </trans-unit>
        <trans-unit id="2fc0b9aee575bb88d3b3c3db08a354cd3df94678" translate="yes" xml:space="preserve">
          <source>It is important to understand the interaction between aggregates and SQL's &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses. The fundamental difference between &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; is this: &lt;code&gt;WHERE&lt;/code&gt; selects input rows before groups and aggregates are computed (thus, it controls which rows go into the aggregate computation), whereas &lt;code&gt;HAVING&lt;/code&gt; selects group rows after groups and aggregates are computed. Thus, the &lt;code&gt;WHERE&lt;/code&gt; clause must not contain aggregate functions; it makes no sense to try to use an aggregate to determine which rows will be inputs to the aggregates. On the other hand, the &lt;code&gt;HAVING&lt;/code&gt; clause always contains aggregate functions. (Strictly speaking, you are allowed to write a &lt;code&gt;HAVING&lt;/code&gt; clause that doesn't use aggregates, but it's seldom useful. The same condition could be used more efficiently at the &lt;code&gt;WHERE&lt;/code&gt; stage.)</source>
          <target state="translated">集計とSQLの &lt;code&gt;WHERE&lt;/code&gt; および &lt;code&gt;HAVING&lt;/code&gt; 句の間の相互作用を理解することが重要です。基本的な違い &lt;code&gt;WHERE&lt;/code&gt; と &lt;code&gt;HAVING&lt;/code&gt; ：本で &lt;code&gt;WHERE&lt;/code&gt; 基及び凝集の前に選択入力行は、（行が集約計算に入るこのように、コントロール）を計算しているのに対し、 &lt;code&gt;HAVING&lt;/code&gt; 基及び凝集後の選択グループ行が計算されます。したがって、 &lt;code&gt;WHERE&lt;/code&gt; 句に集計関数を含めることはできません。集計を使用して、どの行が集計への入力になるかを決定しても意味がありません。一方、 &lt;code&gt;HAVING&lt;/code&gt; 句には常に集計関数が含まれます。（厳密に言うと、集計を使用しない &lt;code&gt;HAVING&lt;/code&gt; 句を記述できますが、ほとんど役に立ちません。同じ条件を &lt;code&gt;WHERE&lt;/code&gt; ステージでより効率的に使用できます。）</target>
        </trans-unit>
        <trans-unit id="d6f798bec767ce149f1b4884b54e8874f501f623" translate="yes" xml:space="preserve">
          <source>It is legitimate to create a &lt;code&gt;pg_cast&lt;/code&gt; entry in which the source and target types are the same, if the associated function takes more than one argument. Such entries represent &amp;ldquo;length coercion functions&amp;rdquo; that coerce values of the type to be legal for a particular type modifier value.</source>
          <target state="translated">関連する関数が複数の引数を取る場合、ソースとターゲットのタイプが同じである &lt;code&gt;pg_cast&lt;/code&gt; エントリを作成することは正当です。そのようなエントリは、特定の型修飾子の値に対して正当な型の値を強制する「長さ強制関数」を表します。</target>
        </trans-unit>
        <trans-unit id="dbc1f490f7774fb666f596c4d1e1fe3642c52d33" translate="yes" xml:space="preserve">
          <source>It is likely that &lt;code&gt;pg_pltemplate&lt;/code&gt; will be removed in some future release of PostgreSQL, in favor of keeping this knowledge about procedural languages in their respective extension installation scripts.</source>
          <target state="translated">&lt;code&gt;pg_pltemplate&lt;/code&gt; は、将来のPostgreSQLのリリースで削除される可能性が高く、手続き型言語に関するこの知識をそれぞれの拡張インストールスクリプトで維持することを優先します。</target>
        </trans-unit>
        <trans-unit id="6bb4f0fbbfb491190c393dc7c8ea60757b692676" translate="yes" xml:space="preserve">
          <source>It is normally not necessary to create casts between user-defined types and the standard string types (&lt;code&gt;text&lt;/code&gt;, &lt;code&gt;varchar&lt;/code&gt;, and &lt;code&gt;char(n)&lt;/code&gt;, as well as user-defined types that are defined to be in the string category). PostgreSQL provides automatic I/O conversion casts for that. The automatic casts to string types are treated as assignment casts, while the automatic casts from string types are explicit-only. You can override this behavior by declaring your own cast to replace an automatic cast, but usually the only reason to do so is if you want the conversion to be more easily invokable than the standard assignment-only or explicit-only setting. Another possible reason is that you want the conversion to behave differently from the type's I/O function; but that is sufficiently surprising that you should think twice about whether it's a good idea. (A small number of the built-in types do indeed have different behaviors for conversions, mostly because of requirements of the SQL standard.)</source>
          <target state="translated">通常、ユーザー定義型と標準の文字列型（ &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;varchar&lt;/code&gt; 、および &lt;code&gt;char(n)&lt;/code&gt; の間のキャストを作成する必要はありません。、および文字列カテゴリに含まれるように定義されているユーザー定義型）。 PostgreSQLはそのための自動I / O変換キャストを提供します。文字列型への自動キャストは割り当てキャストとして扱われますが、文字列型からの自動キャストは明示的のみです。独自のキャストを宣言して自動キャストを置き換えることで、この動作をオーバーライドできますが、通常、これを行う唯一の理由は、標準の割り当て専用または明示専用の設定よりも変換を簡単に呼び出すことができるようにする場合です。考えられるもう1つの理由は、変換の動作をタイプのI / O関数とは異なるものにすることです。しかしそれは、それが良い考えかどうかについて二度考えるべきだというのは十分に驚くべきことです。 （実際には、少数の組み込み型では変換の動作が異なりますが、主にSQL標準の要件によるものです。）</target>
        </trans-unit>
        <trans-unit id="f92a52d7559ea7c6c8c28ba12e1fa17dfea96688" translate="yes" xml:space="preserve">
          <source>It is not allowed to combine &lt;code&gt;connect&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;create_slot&lt;/code&gt;, or &lt;code&gt;copy_data&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定して &lt;code&gt;enabled&lt;/code&gt; 、 &lt;code&gt;create_slot&lt;/code&gt; 、または &lt;code&gt;copy_data&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定して組み合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="072c5ad8d293ff2ada18ad71b639cc19ab727e57" translate="yes" xml:space="preserve">
          <source>It is not currently allowed to &lt;code&gt;PREPARE&lt;/code&gt; a transaction that has executed any operations involving temporary tables or the session's temporary namespace, created any cursors &lt;code&gt;WITH HOLD&lt;/code&gt;, or executed &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;UNLISTEN&lt;/code&gt;, or &lt;code&gt;NOTIFY&lt;/code&gt;. Those features are too tightly tied to the current session to be useful in a transaction to be prepared.</source>
          <target state="translated">現在、一時テーブルまたはセッションの一時名前空間に関連する操作を実行したり、 &lt;code&gt;WITH HOLD&lt;/code&gt; カーソルを作成したり、 &lt;code&gt;LISTEN&lt;/code&gt; 、 &lt;code&gt;UNLISTEN&lt;/code&gt; 、または &lt;code&gt;NOTIFY&lt;/code&gt; を実行したトランザクションを &lt;code&gt;PREPARE&lt;/code&gt; することはできません。これらの機能は、現在のセッションに緊密に関連付けられているため、トランザクションを準備するのに役立ちません。</target>
        </trans-unit>
        <trans-unit id="683c463d18b1311e371770a1d3375c3bacddce8d" translate="yes" xml:space="preserve">
          <source>It is not important to which database you connect here since the script file created by pg_dumpall will contain the appropriate commands to create and connect to the saved databases. An exception is that if you specified &lt;code&gt;--clean&lt;/code&gt;, you must connect to the &lt;code&gt;postgres&lt;/code&gt; database initially; the script will attempt to drop other databases immediately, and that will fail for the database you are connected to.</source>
          <target state="translated">pg_dumpallによって作成されたスクリプトファイルには、保存されたデータベースを作成して接続するための適切なコマンドが含まれているため、ここで接続するデータベースは重要ではありません。例外として、-- &lt;code&gt;--clean&lt;/code&gt; を指定した場合、最初に &lt;code&gt;postgres&lt;/code&gt; データベースに接続する必要があります。スクリプトは他のデータベースをすぐに削除しようとし、接続しているデータベースでは失敗します。</target>
        </trans-unit>
        <trans-unit id="1b796566a4506096f72ab10f4b43942e3c90636a" translate="yes" xml:space="preserve">
          <source>It is not necessary to add the root certificate to &lt;code&gt;server.crt&lt;/code&gt;. Instead, clients must have the root certificate of the server's certificate chain.</source>
          <target state="translated">ルート証明書を &lt;code&gt;server.crt&lt;/code&gt; に追加する必要はありません。代わりに、クライアントはサーバーの証明書チェーンのルート証明書を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="c4d12fc72842b14e61904a6ec6e02667bd4e3ff1" translate="yes" xml:space="preserve">
          <source>It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with &lt;code&gt;full_page_writes&lt;/code&gt; disabled, you might notice a drop in performance while the backup runs since &lt;code&gt;full_page_writes&lt;/code&gt; is effectively forced on during backup mode.</source>
          <target state="translated">基本バックアップの作成にかかる時間を気にする必要はありません。ただし、 &lt;code&gt;full_page_writes&lt;/code&gt; を無効にしてサーバーを通常実行すると、バックアップモード中に &lt;code&gt;full_page_writes&lt;/code&gt; が事実上強制されるため、バックアップの実行中にパフォーマンスが低下する場合があります。</target>
        </trans-unit>
        <trans-unit id="aca7caa9402f8a163da6c6daa7fb30a56a74a363" translate="yes" xml:space="preserve">
          <source>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</source>
          <target state="translated">パーティションの境界条件を記述したテーブル制約を作成する必要はありません。その代わりに、パーティション制約は、参照する必要がある場合には、パーティション境界仕様から暗黙的に生成されます。</target>
        </trans-unit>
        <trans-unit id="cf0a2da0ce7b363dca7ad51ebb38c128a6e8bc4b" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or for which the number of additional bytes of storage required is zero.</source>
          <target state="translated">パラレルスキャンをサポートしていないアクセスメソッドや、必要なストレージの追加バイト数がゼロのアクセスメソッドには、この関数を実装する必要はありません。</target>
        </trans-unit>
        <trans-unit id="81e24e9944e94aaaad52d26039e5ac57f4d46637" translate="yes" xml:space="preserve">
          <source>It is not necessary to implement this function for access methods which do not support parallel scans or in cases where the shared memory space required needs no initialization.</source>
          <target state="translated">パラレルスキャンに対応していないアクセスメソッドや、必要な共有メモリ空間の初期化が不要な場合は、この関数を実装する必要はありません。</target>
        </trans-unit>
        <trans-unit id="57e901fbd76f488aaa546e02fcd890de2339da2b" translate="yes" xml:space="preserve">
          <source>It is not necessary to provide both of these functions. If one is not specified, the language-specific default behavior will be used if necessary. (To prevent a transformation in a certain direction from happening at all, you could also write a transform function that always errors out.)</source>
          <target state="translated">これらの機能を両方提供する必要はありません。どちらかが指定されていない場合は、必要に応じて言語固有のデフォルトの動作が使用されます。(特定の方向への変換が全く起こらないようにするには、常にエラーアウトするような変換関数を書くこともできます)。</target>
        </trans-unit>
        <trans-unit id="8c2adbe3f4bf051ef1858dcf0e81ceda3ba80d46" translate="yes" xml:space="preserve">
          <source>It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports &lt;em&gt;point-in-time recovery&lt;/em&gt;: it is possible to restore the database to its state at any time since your base backup was taken.</source>
          <target state="translated">WALエントリを最後まで再生する必要はありません。任意の時点で再生を停止し、その時点でのデータベースの一貫したスナップショットを取得できます。したがって、この手法は&lt;em&gt;ポイントインタイムリカバリを&lt;/em&gt;サポートします。ベースバックアップが作成されてから、いつでもデータベースをその状態に復元することが可能です。</target>
        </trans-unit>
        <trans-unit id="ff889e8c8e60f8ff7137e71a9bfef2608859eeae" translate="yes" xml:space="preserve">
          <source>It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt.</source>
          <target state="translated">サーバーの状態を取得するために、正しいユーザー名、パスワード、データベース名の値を指定する必要はありませんが、間違った値を指定した場合、サーバーは接続の試みに失敗したことを記録します。</target>
        </trans-unit>
        <trans-unit id="594a9711ffec0cdfe29afe713704c6029ca7c0e7" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the &lt;code&gt;sync&lt;/code&gt; mount option. The behavior of the &lt;code&gt;async&lt;/code&gt; option is sufficient, since PostgreSQL issues &lt;code&gt;fsync&lt;/code&gt; calls at appropriate times to flush the write caches. (This is analogous to how it works on a local file system.) However, it is strongly recommended to use the &lt;code&gt;sync&lt;/code&gt; export option on the NFS &lt;em&gt;server&lt;/em&gt; on systems where it exists (mainly Linux). Otherwise, an &lt;code&gt;fsync&lt;/code&gt; or equivalent on the NFS client is not actually guaranteed to reach permanent storage on the server, which could cause corruption similar to running with the parameter &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; off. The defaults of these mount and export options differ between vendors and versions, so it is recommended to check and perhaps specify them explicitly in any case to avoid any ambiguity.</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; マウントオプションを使用する必要はありません。PostgreSQL は書き込みキャッシュをフラッシュするために適切なタイミングで &lt;code&gt;fsync&lt;/code&gt; 呼び出しを発行するため、 &lt;code&gt;async&lt;/code&gt; オプションの動作で十分です。 （これはローカルファイルシステムでの動作に似ています。）ただし、 &lt;code&gt;sync&lt;/code&gt; エクスポートオプションが存在するシステム（主にLinux）のNFS &lt;em&gt;サーバー&lt;/em&gt;で同期エクスポートオプションを使用することを強くお勧めします。それ以外の場合、NFSクライアントの &lt;code&gt;fsync&lt;/code&gt; または同等のものは、サーバーの永続的なストレージに到達することが実際には保証されず、パラメーター&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsyncを&lt;/a&gt;使用した実行と同様の破損を引き起こす可能性があります。&lt;em&gt;&lt;/em&gt;オフ。これらのマウントオプションとエクスポートオプションのデフォルトはベンダーとバージョンによって異なるため、あいまいさを避けるために、これらをチェックして、明示的に指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c52dffeed651be2fa3f87bf20ee3f9a890f9417b" translate="yes" xml:space="preserve">
          <source>It is not possible to release a savepoint when the transaction is in an aborted state.</source>
          <target state="translated">トランザクションが中断された状態にある場合、セーブポイントを解放することはできません。</target>
        </trans-unit>
        <trans-unit id="bfd22308dc33a27874305473df207d131e6a6cc4" translate="yes" xml:space="preserve">
          <source>It is not possible to specify an operator's lexical precedence in &lt;code&gt;CREATE OPERATOR&lt;/code&gt;, because the parser's precedence behavior is hard-wired. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for precedence details.</source>
          <target state="translated">パーサーの優先順位の動作はハードワイヤードであるため、 &lt;code&gt;CREATE OPERATOR&lt;/code&gt; で演算子の字句の優先順位を指定することはできません。参照してください&lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;セクション4.1.6を&lt;/a&gt;優先詳細については。</target>
        </trans-unit>
        <trans-unit id="623a5826c4c93a0ee1b0b35f75bc29bfa6d59c5f" translate="yes" xml:space="preserve">
          <source>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; to learn more about the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; and &lt;code&gt;DETACH PARTITION&lt;/code&gt; sub-commands.</source>
          <target state="translated">通常のテーブルをパーティションテーブルに、またはその逆に変換することはできません。ただし、データを含む通常のテーブルまたはパーティションテーブルをパーティションテーブルのパーティションとして追加したり、パーティションテーブルからパーティションを削除してスタンドアロンテーブルにしたりすることは可能です。 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; および &lt;code&gt;DETACH PARTITION&lt;/code&gt; サブコマンドの詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2662bc57686704e0177490490462c24f0b6b158d" translate="yes" xml:space="preserve">
          <source>It is often a good idea to also omit from the backup the files within the cluster's &lt;code&gt;pg_replslot/&lt;/code&gt; directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line.</source>
          <target state="translated">マスターに存在するレプリケーションスロットがバックアップの一部にならないように、クラスターの &lt;code&gt;pg_replslot/&lt;/code&gt; ディレクトリ内のファイルもバックアップから除外することをお勧めします。そうしないと、その後バックアップを使用してスタンバイを作成すると、スタンバイでWALファイルが無期限に保持され、ホットスタンバイフィードバックが有効になっている場合はマスターで膨らむ可能性があります。これらのレプリケーションスロットを使用しているクライアントが引き続き接続しているためです。スタンバイではなく、マスターのスロットに更新します。バックアップが新しいマスターの作成での使用のみを目的としている場合でも、レプリケーションスロットのコピーは、新しいマスターがオンラインになるまでにそれらのスロットの内容がかなり古くなっている可能性があるため、特に有用であるとは思われません。 。</target>
        </trans-unit>
        <trans-unit id="d49711f89af35705bbf2891f981f944c8b5260d9" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the function definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the function definition must be escaped by doubling them.</source>
          <target state="translated">通常の単一引用符構文ではなく、ドル引用符（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;セクション4.1.2.4を&lt;/a&gt;参照）を使用して関数定義文字列を記述すると役立つことがよくあります。ドル引用符を使用しない場合、関数定義内の単一引用符またはバックスラッシュは、二重にしてエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="070ae03385b0624216e0f28d18b1063fb9896a1e" translate="yes" xml:space="preserve">
          <source>It is often helpful to use dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) to write the procedure definition string, rather than the normal single quote syntax. Without dollar quoting, any single quotes or backslashes in the procedure definition must be escaped by doubling them.</source>
          <target state="translated">通常の単一引用符構文ではなく、ドル引用符（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;セクション4.1.2.4を&lt;/a&gt;参照）を使用してプロシージャ定義文字列を記述すると便利な場合があります。ドル引用符を使用しない場合、プロシージャ定義内の単一引用符またはバックスラッシュは、二重にしてエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="1037cf4994d8c1ebf0e5d5f237e680d00560257d" translate="yes" xml:space="preserve">
          <source>It is often particularly handy to &lt;code&gt;LEFT JOIN&lt;/code&gt; to a &lt;code&gt;LATERAL&lt;/code&gt; subquery, so that source rows will appear in the result even if the &lt;code&gt;LATERAL&lt;/code&gt; subquery produces no rows for them. For example, if &lt;code&gt;get_product_names()&lt;/code&gt; returns the names of products made by a manufacturer, but some manufacturers in our table currently produce no products, we could find out which ones those are like this:</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; サブクエリが行を生成しなくても、ソース行が結果に表示されるように、 &lt;code&gt;LATERAL&lt;/code&gt; サブクエリへの &lt;code&gt;LEFT JOIN&lt;/code&gt; は特に便利です。たとえば、 &lt;code&gt;get_product_names()&lt;/code&gt; が製造元によって製造された製品の名前を返し、テーブル内の一部の製造元が現在製品を製造していない場合、次のような製品を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="25dd81b9b45b03c00d03cc26e891361c1cfb5adf" translate="yes" xml:space="preserve">
          <source>It is often preferable to use unique index inference rather than naming a constraint directly using &lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt;&lt;code&gt;constraint_name&lt;/code&gt;. Inference will continue to work correctly when the underlying index is replaced by another more or less equivalent index in an overlapping way, for example when using &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; before dropping the index being replaced.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT ON CONSTRAINT&lt;/code&gt; &lt;code&gt;constraint_name&lt;/code&gt; を使用して制約に直接名前を付けるよりも、一意のインデックス推論を使用する方が望ましい場合がよくあります。たとえば、置き換えられるインデックスを削除する前に &lt;code&gt;CREATE UNIQUE INDEX ... CONCURRENTLY&lt;/code&gt; を使用する場合など、基礎となるインデックスがほぼ同等の別のインデックスに重複して置き換えられても、推論は引き続き正しく機能します。</target>
        </trans-unit>
        <trans-unit id="f0921a8a84d9d3343d74c19f7c3f5f4b06b1c95a" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;code&gt;SELECT&lt;/code&gt; command running at the &lt;code&gt;READ COMMITTED&lt;/code&gt; transaction isolation level and using &lt;code&gt;ORDER BY&lt;/code&gt; and a locking clause to return rows out of order. This is because &lt;code&gt;ORDER BY&lt;/code&gt; is applied first. The command sorts the result, but might then block trying to obtain a lock on one or more of the rows. Once the &lt;code&gt;SELECT&lt;/code&gt; unblocks, some of the ordering column values might have been modified, leading to those rows appearing to be out of order (though they are in order in terms of the original column values). This can be worked around at need by placing the &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; clause in a sub-query, for example</source>
          <target state="translated">それが可能である &lt;code&gt;SELECT&lt;/code&gt; で動作コマンド &lt;code&gt;READ COMMITTED&lt;/code&gt; トランザクション分離レベルと使用 &lt;code&gt;ORDER BY&lt;/code&gt; 順序の列を返すために、ロック句。これは、 &lt;code&gt;ORDER BY&lt;/code&gt; が最初に適用されるためです。コマンドは結果をソートしますが、1つ以上の行でロックを取得しようとするとブロックされる可能性があります。一度 &lt;code&gt;SELECT&lt;/code&gt; ブロック解除、発注のいくつかの列の値は、順序（彼らは、元の列の値の面で順になっているが）外であるように見えるこれらの行につながる、変更された可能性があります。これは、 &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; 句をサブクエリに配置することで、必要に応じて回避できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="312a8769f42a09f432ff89ed107b0b0a082956d5" translate="yes" xml:space="preserve">
          <source>It is possible for both the client and server to provide SSL certificates to each other. It takes some extra configuration on each side, but this provides stronger verification of identity than the mere use of passwords. It prevents a computer from pretending to be the server just long enough to read the password sent by the client. It also helps prevent &amp;ldquo;man in the middle&amp;rdquo; attacks where a computer between the client and server pretends to be the server and reads and passes all data between the client and server.</source>
          <target state="translated">クライアントとサーバーの両方が相互にSSL証明書を提供することが可能です。両側で追加の構成が必要ですが、これにより、単なるパスワードの使用よりも強力なID検証が提供されます。これは、クライアントが送信したパスワードを読み取るのに十分な長さのサーバーであるかのようにコンピュータが偽ることを防ぎます。また、クライアントとサーバーの間のコンピューターがサーバーになりすまし、クライアントとサーバーの間ですべてのデータを読み取って渡す &quot;中間者&quot;攻撃を防ぐのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="90f59c9a7c7c3d668eb0d91ba42953cad54439f7" translate="yes" xml:space="preserve">
          <source>It is possible for the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; statement) to also contain a &lt;code&gt;WITH&lt;/code&gt; clause. In such a case both sets of &lt;code&gt;with_query&lt;/code&gt; can be referenced within the &lt;code&gt;query&lt;/code&gt;, but the second one takes precedence since it is more closely nested.</source>
          <target state="translated">ことが可能である &lt;code&gt;query&lt;/code&gt; （ &lt;code&gt;SELECT&lt;/code&gt; 文の）も含まれて &lt;code&gt;WITH&lt;/code&gt; の句を。そのような場合、 &lt;code&gt;with_query&lt;/code&gt; の両方のセットを &lt;code&gt;query&lt;/code&gt; 内で参照できますが、2番目のセットはより密接にネストされているため、優先されます。</target>
        </trans-unit>
        <trans-unit id="db7d99e745d7786411f8e352570962f202386c2e" translate="yes" xml:space="preserve">
          <source>It is possible for the parser to produce overlapping tokens from the same piece of text. As an example, a hyphenated word will be reported both as the entire word and as each component:</source>
          <target state="translated">パーサは、同じテキストから重複するトークンを生成することができます。例えば、ハイフネーションされた単語は、単語全体と各構成要素の両方として報告されます。</target>
        </trans-unit>
        <trans-unit id="2357da6f1597b1c38d9b19b97f4eaf9ba4d3b605" translate="yes" xml:space="preserve">
          <source>It is possible that the replication delay between servers exceeds the value of this parameter, in which case no delay is added. Note that the delay is calculated between the WAL time stamp as written on master and the current time on the standby. Delays in transfer because of network lag or cascading replication configurations may reduce the actual wait time significantly. If the system clocks on master and standby are not synchronized, this may lead to recovery applying records earlier than expected; but that is not a major issue because useful settings of this parameter are much larger than typical time deviations between servers.</source>
          <target state="translated">サーバ間のレプリケーション遅延がこのパラメータの値を超える可能性がありますが、その場合は遅延は追加されません。遅延は、マスターに書き込まれたWALタイムスタンプとスタンバイの現在時刻との間で計算されることに注意してください。ネットワークラグやカスケード・レプリケーション構成による転送の遅延は、実際の待ち時間を大幅に短縮する可能性があります。マスタとスタンバイのシステムクロックが同期していない場合、これは予想よりも早くレコードを適用して回復することにつながる可能性がありますが、このパラメータの有用な設定はサーバー間の一般的な時間偏差よりもはるかに大きいため、これは大きな問題ではありません。</target>
        </trans-unit>
        <trans-unit id="f9e86aaa136a99713e8aa37be86f1493657e5f36" translate="yes" xml:space="preserve">
          <source>It is possible to access the two component numbers of a &lt;code&gt;point&lt;/code&gt; as though the point were an array with indexes 0 and 1. For example, if &lt;code&gt;t.p&lt;/code&gt; is a &lt;code&gt;point&lt;/code&gt; column then &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; retrieves the X coordinate and &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; changes the Y coordinate. In the same way, a value of type &lt;code&gt;box&lt;/code&gt; or &lt;code&gt;lseg&lt;/code&gt; can be treated as an array of two &lt;code&gt;point&lt;/code&gt; values.</source>
          <target state="translated">ポイントがインデックス0および1の配列であるかのように、 &lt;code&gt;point&lt;/code&gt; 2つのコンポーネント番号にアクセスすることが可能です。たとえば、 &lt;code&gt;t.p&lt;/code&gt; が &lt;code&gt;point&lt;/code&gt; 列の場合、 &lt;code&gt;SELECT p[0] FROM t&lt;/code&gt; はX座標を取得し、 &lt;code&gt;UPDATE t SET p[1] = ...&lt;/code&gt; 取得します。p [1] = ... Y座標を変更します。同様に、 &lt;code&gt;box&lt;/code&gt; または &lt;code&gt;lseg&lt;/code&gt; 型の値は、2つの &lt;code&gt;point&lt;/code&gt; 値の配列として扱うことができます。</target>
        </trans-unit>
        <trans-unit id="2d05975d6f7f169fef234fa65303a022ea6de537" translate="yes" xml:space="preserve">
          <source>It is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, so that the values will be kept across reboots.</source>
          <target state="translated">It is possible to change all but &lt;code&gt;SHMMNI&lt;/code&gt; on the fly, using sysctl. But it's still best to set up your preferred values via &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; , so that the values will be kept across reboots.</target>
        </trans-unit>
        <trans-unit id="7fd72ecc1dea1c97715f5cc99a51c3564620c9cb" translate="yes" xml:space="preserve">
          <source>It is possible to check the accuracy of the planner's estimates by using &lt;code&gt;EXPLAIN&lt;/code&gt;'s &lt;code&gt;ANALYZE&lt;/code&gt; option. With this option, &lt;code&gt;EXPLAIN&lt;/code&gt; actually executes the query, and then displays the true row counts and true run time accumulated within each plan node, along with the same estimates that a plain &lt;code&gt;EXPLAIN&lt;/code&gt; shows. For example, we might get a result like this:</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; の &lt;code&gt;ANALYZE&lt;/code&gt; オプションを使用して、プランナの推定の精度をチェックすることができます。このオプションを &lt;code&gt;EXPLAIN&lt;/code&gt; すると、EXPLAINは実際にクエリを実行し、各プランノード内で累積された実際の行数と実際の実行時間を、単純な &lt;code&gt;EXPLAIN&lt;/code&gt; が示すのと同じ推定値とともに表示します。たとえば、次のような結果が得られます。</target>
        </trans-unit>
        <trans-unit id="ed45fb50f823ca992b140dff1d81be186a3aef4d" translate="yes" xml:space="preserve">
          <source>It is possible to control the query planner to some extent by using the explicit &lt;code&gt;JOIN&lt;/code&gt; syntax. To see why this matters, we first need some background.</source>
          <target state="translated">明示的な &lt;code&gt;JOIN&lt;/code&gt; 構文を使用すると、クエリプランナーをある程度制御できます。これがなぜ重要かを理解するには、まずいくつかの背景が必要です。</target>
        </trans-unit>
        <trans-unit id="21ffb53e2d68da0c7954b41e98f5975f4ecf8084" translate="yes" xml:space="preserve">
          <source>It is possible to create a foreign-data wrapper with no handler function, but foreign tables using such a wrapper can only be declared, not accessed.</source>
          <target state="translated">ハンドラ関数を持たない外部データラッパーを作成することも可能ですが、そのようなラッパーを使用した外部テーブルは宣言されるだけで、アクセスされることはありません。</target>
        </trans-unit>
        <trans-unit id="d5bd3763bfcd5993518d08a6fc8f19894d8b599a" translate="yes" xml:space="preserve">
          <source>It is possible to create additional template databases, and indeed one can copy any database in a cluster by specifying its name as the template for &lt;code&gt;CREATE DATABASE&lt;/code&gt;. It is important to understand, however, that this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the source database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; during the copy operation, new connections to the source database are prevented.</source>
          <target state="translated">追加のテンプレートデータベースを作成することが可能であり、実際に、その名前を &lt;code&gt;CREATE DATABASE&lt;/code&gt; のテンプレートとして指定することにより、クラスター内の任意のデータベースをコピーできます。ただし、これは（まだ）汎用の「 &lt;code&gt;COPY DATABASE&lt;/code&gt; 」機能としては意図されていないことを理解することが重要です。主な制限は、コピー中は他のセッションをソースデータベースに接続できないことです。開始時に他の接続が存在する場合、 &lt;code&gt;CREATE DATABASE&lt;/code&gt; は失敗します。コピー操作中は、ソースデータベースへの新しい接続が禁止されます。</target>
        </trans-unit>
        <trans-unit id="e68d9c04db6c0169a67f695c187f5caec6e9c6fb" translate="yes" xml:space="preserve">
          <source>It is possible to dispense with &lt;code&gt;SET TRANSACTION&lt;/code&gt; by instead specifying the desired &lt;code&gt;transaction_modes&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;START TRANSACTION&lt;/code&gt;. But that option is not available for &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; または &lt;code&gt;START TRANSACTION&lt;/code&gt; で目的の &lt;code&gt;transaction_modes&lt;/code&gt; を指定することにより、 &lt;code&gt;SET TRANSACTION&lt;/code&gt; を省略できます。ただし、そのオプションは &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; では使用できません。</target>
        </trans-unit>
        <trans-unit id="c6a819090253f862f39b7dcfdb25432b06b91898" translate="yes" xml:space="preserve">
          <source>It is possible to do a full text search without an index. A simple query to print the &lt;code&gt;title&lt;/code&gt; of each row that contains the word &lt;code&gt;friend&lt;/code&gt; in its &lt;code&gt;body&lt;/code&gt; field is:</source>
          <target state="translated">インデックスなしで全文検索を行うことができます。印刷する単純なクエリ &lt;code&gt;title&lt;/code&gt; ワードが含まれ、各行の &lt;code&gt;friend&lt;/code&gt; その中に &lt;code&gt;body&lt;/code&gt; フィールドは以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="6f136c23eebfd4cd415f6012b712c4df1242fdcd" translate="yes" xml:space="preserve">
          <source>It is possible to have authentication without encryption overhead by using &lt;code&gt;NULL-SHA&lt;/code&gt; or &lt;code&gt;NULL-MD5&lt;/code&gt; ciphers. However, a man-in-the-middle could read and pass communications between client and server. Also, encryption overhead is minimal compared to the overhead of authentication. For these reasons NULL ciphers are not recommended.</source>
          <target state="translated">&lt;code&gt;NULL-SHA&lt;/code&gt; または &lt;code&gt;NULL-MD5&lt;/code&gt; 暗号を使用することにより、暗号化オーバーヘッドなしで認証を行うことが可能です。ただし、中間者がクライアントとサーバー間の通信を読み取って渡す可能性があります。また、暗号化のオーバーヘッドは、認証のオーバーヘッドと比較して最小限です。これらの理由により、NULL暗号は推奨されません。</target>
        </trans-unit>
        <trans-unit id="c3a0ba5698f2b4b4f4b4ee88ac329603107cde1d" translate="yes" xml:space="preserve">
          <source>It is possible to log to stderr without using the logging collector; the log messages will just go to wherever the server's stderr is directed. However, that method is only suitable for low log volumes, since it provides no convenient way to rotate log files. Also, on some platforms not using the logging collector can result in lost or garbled log output, because multiple processes writing concurrently to the same log file can overwrite each other's output.</source>
          <target state="translated">ロギングコレクターを使わずに標準エラーにログを記録することは可能です。しかし、この方法はログファイルを回転させる便利な方法を提供しないので、ログボリュームが少ない場合にのみ適しています。また、一部のプラットフォームでは、ロギングコレクターを使用しないと、ログ出力が失われたり、文字化けしたりすることがあります。</target>
        </trans-unit>
        <trans-unit id="3d8f4459b3f7e90845c901d21d257a7423c267d0" translate="yes" xml:space="preserve">
          <source>It is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">It is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36e9a78df914fad0648da0a65b3ec648ec904013" translate="yes" xml:space="preserve">
          <source>It is possible to nest dollar-quoted string constants by choosing different tags at each nesting level. This is most commonly used in writing function definitions. For example:</source>
          <target state="translated">各ネスティングレベルで異なるタグを選択することで、ドル引用符で囲まれた文字列定数をネスティングすることができます。これは、関数の定義を書く際に最もよく使われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a0a345a5b07bad2c1307139346533842f66f7f85" translate="yes" xml:space="preserve">
          <source>It is possible to omit the &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; of a slice specifier; the missing bound is replaced by the lower or upper limit of the array's subscripts. For example:</source>
          <target state="translated">スライス指定子の &lt;code&gt;lower-bound&lt;/code&gt; および/または &lt;code&gt;upper-bound&lt;/code&gt; を省略することができます。欠落している境界は、配列の添え字の下限または上限に置き換えられます。例えば：</target>
        </trans-unit>
        <trans-unit id="0fbcc6e88bd4f468012c5b5e8934f903489fc504" translate="yes" xml:space="preserve">
          <source>It is possible to run &lt;code&gt;ANALYZE&lt;/code&gt; on specific tables and even just specific columns of a table, so the flexibility exists to update some statistics more frequently than others if your application requires it. In practice, however, it is usually best to just analyze the entire database, because it is a fast operation. &lt;code&gt;ANALYZE&lt;/code&gt; uses a statistically random sampling of the rows of a table rather than reading every single row.</source>
          <target state="translated">特定のテーブルおよびテーブルの特定の列でさえ &lt;code&gt;ANALYZE&lt;/code&gt; を実行することが可能であるため、アプリケーションで必要な場合に、一部の統計を他の統計よりも頻繁に更新する柔軟性があります。ただし、実際には高速な操作であるため、通常はデータベース全体を分析するのが最善です。 &lt;code&gt;ANALYZE&lt;/code&gt; は、すべての行を読み取るのではなく、テーブルの行の統計的にランダムなサンプリングを使用します。</target>
        </trans-unit>
        <trans-unit id="56b863d1457c5714b3cbf931bd78aab64ed29d7b" translate="yes" xml:space="preserve">
          <source>It is possible to set up more complex expression indexes wherein the configuration name is specified by another column, e.g.:</source>
          <target state="translated">設定名が別のカラムによって指定されるような、より複雑な式インデックスを設定することが可能である。</target>
        </trans-unit>
        <trans-unit id="ab7995c28ab9203226049f19e6325626835b07f5" translate="yes" xml:space="preserve">
          <source>It is possible to use PostgreSQL's backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than pg_dump dumps. (They are also much larger than pg_dump dumps, so in some cases the speed advantage might be negated.)</source>
          <target state="translated">PostgreSQLのバックアップ機能を使用してスタンドアロンのホットバックアップを作成することができます。これらはポイントインタイムリカバリには使用できないバックアップですが、一般的にはpg_dumpダンプよりもはるかに高速にバックアップとリストアを行うことができます(また、pg_dumpダンプよりもはるかに大きいので、場合によっては速度の優位性が否定されることもあります)。(これらのバックアップはpg_dumpダンプよりもはるかに大きいので、場合によっては速度の優位性が否定されることもあります)。</target>
        </trans-unit>
        <trans-unit id="793bdae387c6386aab767254ea0495efd0a0f102" translate="yes" xml:space="preserve">
          <source>It is possible to use SELinux's dynamic domain transition feature to switch the security label of the client process, the client domain, to a new context, if that is allowed by the security policy. The client domain needs the &lt;code&gt;setcurrent&lt;/code&gt; permission and also &lt;code&gt;dyntransition&lt;/code&gt; from the old to the new domain.</source>
          <target state="translated">セキュリティポリシーで許可されている場合、SELinuxの動的ドメイン移行機能を使用して、クライアントプロセスのセキュリティラベルであるクライアントドメインを新しいコンテキストに切り替えることができます。クライアントドメインには、 &lt;code&gt;setcurrent&lt;/code&gt; 権限と、古いドメインから新しいドメインへの &lt;code&gt;dyntransition&lt;/code&gt; 移行が必要です。</target>
        </trans-unit>
        <trans-unit id="fea64923e6a1c45508b51b78c6ed3fd042a235d3" translate="yes" xml:space="preserve">
          <source>It is possible to use SSH to encrypt the network connection between clients and a PostgreSQL server. Done properly, this provides an adequately secure network connection, even for non-SSL-capable clients.</source>
          <target state="translated">SSHを使用してクライアントとPostgreSQLサーバ間のネットワーク接続を暗号化することができます。これを適切に行うことで、SSL非対応のクライアントであっても、十分に安全なネットワーク接続を提供します。</target>
        </trans-unit>
        <trans-unit id="05887c55098593888d9b6548b102c0d07ee418cb" translate="yes" xml:space="preserve">
          <source>It is possible to use an NFS file system for storing the PostgreSQL data directory. PostgreSQL does nothing special for NFS file systems, meaning it assumes NFS behaves exactly like locally-connected drives. PostgreSQL does not use any functionality that is known to have nonstandard behavior on NFS, such as file locking.</source>
          <target state="translated">PostgreSQLのデータディレクトリを格納するためにNFSファイルシステムを使用することができます。PostgreSQLはNFSファイルシステムに対して特別なことは何もしません。つまり、NFSはローカルに接続されたドライブと全く同じように動作すると仮定しています。PostgreSQLは、ファイルロックなど、NFS上で非標準的な動作をすることが知られている機能を使用していません。</target>
        </trans-unit>
        <trans-unit id="d07d0d357ed59e4c40820ac16ee2111a412a9fe9" translate="yes" xml:space="preserve">
          <source>It is recommended that in a &lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; call, the access method further verify that the target row actually does have an existing entry in the index, and report error if not. This is a good idea because the index tuple values passed to &lt;code&gt;aminsert&lt;/code&gt; will have been recomputed. If the index definition involves functions that are not really immutable, we might be checking the wrong area of the index. Checking that the target row is found in the recheck verifies that we are scanning for the same tuple values as were used in the original insertion.</source>
          <target state="translated">&lt;code&gt;UNIQUE_CHECK_EXISTING&lt;/code&gt; 呼び出しでは、アクセス方法で、ターゲット行が実際にインデックスに既存のエントリを持っていることをさらに確認し、ない場合はエラーを報告することをお勧めします。 &lt;code&gt;aminsert&lt;/code&gt; に渡されたインデックスタプルの値は再計算されるため、これは良い考えです。インデックス定義に実際には不変ではない関数が含まれている場合、インデックスの間違った領域をチェックしている可能性があります。再チェックでターゲット行が見つかったことを確認すると、元の挿入で使用されたのと同じタプル値をスキャンしていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="302398642319ebf3c5925fc78db8e53f6245f737" translate="yes" xml:space="preserve">
          <source>It is recommended that the file name used in &lt;code&gt;COPY&lt;/code&gt; always be specified as an absolute path. This is enforced by the server in the case of &lt;code&gt;COPY TO&lt;/code&gt;, but for &lt;code&gt;COPY FROM&lt;/code&gt; you do have the option of reading from a file specified by a relative path. The path will be interpreted relative to the working directory of the server process (normally the cluster's data directory), not the client's working directory.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; で使用するファイル名は、絶対パスで指定することをお勧めします。これは、 &lt;code&gt;COPY TO&lt;/code&gt; の場合にサーバーによって強制されますが、 &lt;code&gt;COPY FROM&lt;/code&gt; の場合、相対パスで指定されたファイルから読み取るオプションがあります。パスは、クライアントの作業ディレクトリではなく、サーバープロセスの作業ディレクトリ（通常はクラスターのデータディレクトリ）に関連して解釈されます。</target>
        </trans-unit>
        <trans-unit id="fc0e534ffa8e632dc4cfe7cd8ad98fc538520874" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the pg_dump and pg_dumpall programs from the &lt;em&gt;newer&lt;/em&gt; version of PostgreSQL, to take advantage of enhancements that might have been made in these programs. Current releases of the dump programs can read data from any server version back to 7.0.</source>
          <target state="translated">&lt;em&gt;新しい&lt;/em&gt;バージョンのPostgreSQL のpg_dumpおよびpg_dumpallプログラムを使用して、これらのプログラムで行われた可能性のある拡張機能を利用することをお勧めします。ダンププログラムの現在のリリースでは、サーバーバージョン7.0からのデータを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="9c852fda272f66e174a3889edb42521ecc91c452" translate="yes" xml:space="preserve">
          <source>It is redundant to use the &lt;code&gt;clientcert&lt;/code&gt; option with &lt;code&gt;cert&lt;/code&gt; authentication because &lt;code&gt;cert&lt;/code&gt; authentication is effectively &lt;code&gt;trust&lt;/code&gt; authentication with &lt;code&gt;clientcert=verify-full&lt;/code&gt;.</source>
          <target state="translated">It is redundant to use the &lt;code&gt;clientcert&lt;/code&gt; option with &lt;code&gt;cert&lt;/code&gt; authentication because &lt;code&gt;cert&lt;/code&gt; authentication is effectively &lt;code&gt;trust&lt;/code&gt; authentication with &lt;code&gt;clientcert=verify-full&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="580dc3a7b05e5fa4e5a6d4851ec4e93eeb1cdf02" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be resent from the publisher.</source>
          <target state="translated">論理レプリケーションには &lt;code&gt;off&lt;/code&gt; を使用しても安全です。同期が失われているためにサブスクライバーがトランザクションを失うと、データはパブリッシャーから再送信されます。</target>
        </trans-unit>
        <trans-unit id="b5365d46a8cd20c8ffe5a596a1e9394f61f94500" translate="yes" xml:space="preserve">
          <source>It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be sent again from the publisher.</source>
          <target state="translated">It is safe to use &lt;code&gt;off&lt;/code&gt; for logical replication: If the subscriber loses transactions because of missing synchronization, the data will be sent again from the publisher.</target>
        </trans-unit>
        <trans-unit id="29f5d0a01be6a99ad6990afcd555514ae6b7efcb" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that &lt;code&gt;earthdistance&lt;/code&gt; and &lt;code&gt;cube&lt;/code&gt; be installed in the same schema, and that that schema be one for which CREATE privilege has not been and will not be granted to any untrusted users. Otherwise there are installation-time security hazards if &lt;code&gt;earthdistance&lt;/code&gt;'s schema contains objects defined by a hostile user. Furthermore, when using &lt;code&gt;earthdistance&lt;/code&gt;'s functions after installation, the entire search path should contain only trusted schemas.</source>
          <target state="translated">It is strongly recommended that &lt;code&gt;earthdistance&lt;/code&gt; and &lt;code&gt;cube&lt;/code&gt; be installed in the same schema, and that that schema be one for which CREATE privilege has not been and will not be granted to any untrusted users. Otherwise there are installation-time security hazards if &lt;code&gt;earthdistance&lt;/code&gt; 's schema contains objects defined by a hostile user. Furthermore, when using &lt;code&gt;earthdistance&lt;/code&gt; 's functions after installation, the entire search path should contain only trusted schemas.</target>
        </trans-unit>
        <trans-unit id="70a88889b7d21af89f699959f3df667165202cd6" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications generating &lt;code&gt;COPY&lt;/code&gt; data convert data newlines and carriage returns to the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; sequences respectively. At present it is possible to represent a data carriage return by a backslash and carriage return, and to represent a data newline by a backslash and newline. However, these representations might not be accepted in future releases. They are also highly vulnerable to corruption if the &lt;code&gt;COPY&lt;/code&gt; file is transferred across different machines (for example, from Unix to Windows or vice versa).</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; データを生成するアプリケーションでは、データの改行とキャリッジリターンをそれぞれ &lt;code&gt;\n&lt;/code&gt; および &lt;code&gt;\r&lt;/code&gt; シーケンスに変換することを強くお勧めします。現在、データキャリッジリターンをバックスラッシュとキャリッジリターンで表し、データの改行をバックスラッシュと改行で表すことができます。ただし、これらの表現は将来のリリースでは受け入れられなくなる可能性があります。また、 &lt;code&gt;COPY&lt;/code&gt; ファイルが異なるマシン間で転送された場合（たとえば、UnixからWindowsへ、またはその逆）、破損に対して非常に脆弱です。</target>
        </trans-unit>
        <trans-unit id="d870a88dee5f04bff258cb0a3da6e5856609ce9f" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;hstore&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="translated">It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;hstore&lt;/code&gt; . Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</target>
        </trans-unit>
        <trans-unit id="027fad8c14749d5c9a12505629778b95ee9e9e46" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;ltree&lt;/code&gt;. Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</source>
          <target state="translated">It is strongly recommended that the transform extensions be installed in the same schema as &lt;code&gt;ltree&lt;/code&gt; . Otherwise there are installation-time security hazards if a transform extension's schema contains objects defined by a hostile user.</target>
        </trans-unit>
        <trans-unit id="5d757720e64f735dd8e83c5c66b88db49094003f" translate="yes" xml:space="preserve">
          <source>It is typically used like this:</source>
          <target state="translated">一般的にはこのように使用されます。</target>
        </trans-unit>
        <trans-unit id="cb6eae65d1260158a9aaaa3278cf273df69fbee7" translate="yes" xml:space="preserve">
          <source>It is unwise to leave transactions in the prepared state for a long time. This will interfere with the ability of &lt;code&gt;VACUUM&lt;/code&gt; to reclaim storage, and in extreme cases could cause the database to shut down to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;). Keep in mind also that the transaction continues to hold whatever locks it held. The intended usage of the feature is that a prepared transaction will normally be committed or rolled back as soon as an external transaction manager has verified that other databases are also prepared to commit.</source>
          <target state="translated">トランザクションを準備された状態で長時間放置することは賢明ではありません。これは、ストレージを再利用する &lt;code&gt;VACUUM&lt;/code&gt; の機能に干渉し、極端な場合には、トランザクションIDの折り返しを防ぐためにデータベースをシャットダウンする可能性があります（&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;セクション24.1.5を&lt;/a&gt;参照）。また、トランザクションは、保持していたロックを保持し続けることにも注意してください。この機能の使用目的は、通常、準備されたトランザクションは、他のデータベースもコミットする準備ができていることを外部トランザクションマネージャが確認するとすぐにコミットまたはロールバックされることです。</target>
        </trans-unit>
        <trans-unit id="a307e2692a3d4dc03f3b0a5f0050741c926c9763" translate="yes" xml:space="preserve">
          <source>It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, &amp;ldquo;I changed this table, take a look at it to see what's new&amp;rdquo;. But no such association is enforced by the &lt;code&gt;NOTIFY&lt;/code&gt; and &lt;code&gt;LISTEN&lt;/code&gt; commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.</source>
          <target state="translated">特定のデータベースで使用されるチャネル名とそれぞれの意味を定義するのはデータベース設計者の責任です。一般的に、チャネル名はデータベース内のいくつかのテーブルの名前と同じであり、通知イベントは基本的に「このテーブルを変更しました。これを見て、新機能を確認してください」という意味です。しかし、そのような関連付けは &lt;code&gt;NOTIFY&lt;/code&gt; コマンドと &lt;code&gt;LISTEN&lt;/code&gt; コマンドによって強制されません。たとえば、データベース設計者は、いくつかの異なるチャネル名を使用して、1つのテーブルにさまざまな種類の変更を通知できます。あるいは、ペイロード文字列を使用して、さまざまなケースを区別できます。</target>
        </trans-unit>
        <trans-unit id="c8b6810a1ee6954d361d4c3ec546cf2001eccf7f" translate="yes" xml:space="preserve">
          <source>It is up to the specific dictionary how it treats stop words. For example, &lt;code&gt;ispell&lt;/code&gt; dictionaries first normalize words and then look at the list of stop words, while &lt;code&gt;Snowball&lt;/code&gt; stemmers first check the list of stop words. The reason for the different behavior is an attempt to decrease noise.</source>
          <target state="translated">ストップワードの処理方法は、特定の辞書によって異なります。たとえば、 &lt;code&gt;ispell&lt;/code&gt; 辞書は最初に単語を正規化してからストップワードのリストを確認し、 &lt;code&gt;Snowball&lt;/code&gt; ステマーは最初にストップワードのリストを確認します。動作が異なる理由は、ノイズを減らすためです。</target>
        </trans-unit>
        <trans-unit id="ea9210befc0db8269a2ec074f163712e284e5a63" translate="yes" xml:space="preserve">
          <source>It is usually possible to compare values of related data types as well; for example &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;bigint&lt;/code&gt; will work. Some cases of this sort are implemented directly by &amp;ldquo;cross-type&amp;rdquo; comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</source>
          <target state="translated">It is usually possible to compare values of related data types as well; for example &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;bigint&lt;/code&gt; will work. Some cases of this sort are implemented directly by &amp;ldquo;cross-type&amp;rdquo; comparison operators, but if no such operator is available, the parser will coerce the less-general type to the more-general type and apply the latter's comparison operator.</target>
        </trans-unit>
        <trans-unit id="f04c713c711198819201fd61c74a6825a1ba7c14" translate="yes" xml:space="preserve">
          <source>It is usually wise to create the primary and standby servers so that they are as similar as possible, at least from the perspective of the database server. In particular, the path names associated with tablespaces will be passed across unmodified, so both primary and standby servers must have the same mount paths for tablespaces if that feature is used. Keep in mind that if &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt; is executed on the primary, any new mount point needed for it must be created on the primary and all standby servers before the command is executed. Hardware need not be exactly the same, but experience shows that maintaining two identical systems is easier than maintaining two dissimilar ones over the lifetime of the application and system. In any case the hardware architecture must be the same &amp;mdash; shipping from, say, a 32-bit to a 64-bit system will not work.</source>
          <target state="translated">通常、少なくともデータベースサーバーの観点からは、プライマリサーバーとスタンバイサーバーをできるだけ似たものにすることをお勧めします。特に、テーブルスペースに関連付けられたパス名は変更されずに渡されるため、その機能を使用する場合、プライマリサーバーとスタンバイサーバーの両方がテーブルスペースに対して同じマウントパスを持っている必要があります。&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACEの&lt;/a&gt;場合、がプライマリで実行されると、コマンドに必要なすべての新しいマウントポイントが、プライマリサーバーとすべてのスタンバイサーバーで作成される必要があります。ハードウェアは完全に同じである必要はありませんが、経験上、2つの同一のシステムを維持する方が、アプリケーションとシステムの存続期間にわたって2つの異なるシステムを維持するよりも簡単であることがわかっています。いずれの場合も、ハードウェアアーキテクチャは同じである必要があります。たとえば、32ビットシステムから64ビットシステムへの出荷は機能しません。</target>
        </trans-unit>
        <trans-unit id="2ca150da1f7706a6be21716f546b65e3672dbc4a" translate="yes" xml:space="preserve">
          <source>It is very difficult to avoid such problems, because of SQL's general assumption that a null value is a valid value of every data type. Best practice therefore is to design a domain's constraints so that a null value is allowed, and then to apply column &lt;code&gt;NOT NULL&lt;/code&gt; constraints to columns of the domain type as needed, rather than directly to the domain type.</source>
          <target state="translated">SQLでは一般的にnull値はすべてのデータ型の有効な値であると想定されているため、このような問題を回避することは非常に困難です。したがって、ベストプラクティスは、null値が許可されるようにドメインの制約を設計し、次に列の &lt;code&gt;NOT NULL&lt;/code&gt; 制約を、ドメインタイプに直接ではなく必要に応じてドメインタイプの列に適用することです。</target>
        </trans-unit>
        <trans-unit id="7ca67a8bc55b2440ee4642c5a3836e4f1be7ce5b" translate="yes" xml:space="preserve">
          <source>It is very difficult to enforce business rules regarding data integrity using Read Committed transactions because the view of the data is shifting with each statement, and even a single statement may not restrict itself to the statement's snapshot if a write conflict occurs.</source>
          <target state="translated">Read Committedトランザクションを使用してデータの整合性に関するビジネスルールを強制するのは、ステートメントごとにデータのビューがシフトしているため非常に困難であり、単一のステートメントであっても書き込み競合が発生した場合には、ステートメントのスナップショットに自分自身を制限することができない場合があります。</target>
        </trans-unit>
        <trans-unit id="c946419a4ac69d8f0e7011290f8155362fae2bbd" translate="yes" xml:space="preserve">
          <source>It is very easy to use pgbench to produce completely meaningless numbers. Here are some guidelines to help you get useful results.</source>
          <target state="translated">pgbenchを使って全く意味のない数字を出すのは非常に簡単です。ここでは、有用な結果を得るためのガイドラインをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="8a18d874cf4b801c23ef52010af4733b69c843e7" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as a superuser or an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">WALストリームから特権情報を簡単に抽出できるため、WALストリームを信頼できるユーザーだけが読み取ることができるように、複製のアクセス特権を設定することが非常に重要です。スタンバイサーバーは、スーパーユーザーまたは &lt;code&gt;REPLICATION&lt;/code&gt; 特権を持つアカウントとしてプライマリを認証する必要があります。レプリケーションには、 &lt;code&gt;REPLICATION&lt;/code&gt; および &lt;code&gt;LOGIN&lt;/code&gt; 特権を持つ専用ユーザーアカウントを作成することをお勧めします。一方で &lt;code&gt;REPLICATION&lt;/code&gt; 権限が非常に高い権限を与え、それはユーザーがプライマリシステム上のすべてのデータを変更することはできません &lt;code&gt;SUPERUSER&lt;/code&gt; 権限がありません。</target>
        </trans-unit>
        <trans-unit id="fee748fec5cbfe77ff2427ad0976951907c37cc5" translate="yes" xml:space="preserve">
          <source>It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege or a superuser. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</source>
          <target state="translated">It is very important that the access privileges for replication be set up so that only trusted users can read the WAL stream, because it is easy to extract privileged information from it. Standby servers must authenticate to the primary as an account that has the &lt;code&gt;REPLICATION&lt;/code&gt; privilege or a superuser. It is recommended to create a dedicated user account with &lt;code&gt;REPLICATION&lt;/code&gt; and &lt;code&gt;LOGIN&lt;/code&gt; privileges for replication. While &lt;code&gt;REPLICATION&lt;/code&gt; privilege gives very high permissions, it does not allow the user to modify any data on the primary system, which the &lt;code&gt;SUPERUSER&lt;/code&gt; privilege does.</target>
        </trans-unit>
        <trans-unit id="d630958bd06e172aebb494cef807db838ae776b4" translate="yes" xml:space="preserve">
          <source>It is very important to take care to avoid circular rules. For example, though each of the following two rule definitions are accepted by PostgreSQL, the &lt;code&gt;SELECT&lt;/code&gt; command would cause PostgreSQL to report an error because of recursive expansion of a rule:</source>
          <target state="translated">循環ルールを回避するように注意することは非常に重要です。たとえば、次の2つのルール定義はそれぞれPostgreSQLで受け入れられますが、 &lt;code&gt;SELECT&lt;/code&gt; コマンドを使用すると、ルールが再帰的に展開されるため、PostgreSQLでエラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="5a1a313f5514df92e2599108b061f0b4f0a8e02d" translate="yes" xml:space="preserve">
          <source>It is widely considered good style to qualify all column names in a join query, so that the query won't fail if a duplicate column name is later added to one of the tables.</source>
          <target state="translated">結合クエリですべてのカラム名を修飾することは、後にテーブルの1つに重複したカラム名が追加されてもクエリが失敗しないようにするために、広く良いスタイルと考えられています。</target>
        </trans-unit>
        <trans-unit id="906e585ddeae75bc90c0d2a785d10b4e23e5052c" translate="yes" xml:space="preserve">
          <source>It is wise to be conservative about marking casts as implicit. An overabundance of implicit casting paths can cause PostgreSQL to choose surprising interpretations of commands, or to be unable to resolve commands at all because there are multiple possible interpretations. A good rule of thumb is to make a cast implicitly invokable only for information-preserving transformations between types in the same general type category. For example, the cast from &lt;code&gt;int2&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; can reasonably be implicit, but the cast from &lt;code&gt;float8&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt; should probably be assignment-only. Cross-type-category casts, such as &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;int4&lt;/code&gt;, are best made explicit-only.</source>
          <target state="translated">キャストを暗黙的なものとしてマークすることについては慎重に行うことをお勧めします。暗黙のキャストパスが多すぎると、PostgreSQLがコマンドの意外な解釈を選択したり、解釈が複数あるためにコマンドをまったく解決できなかったりする可能性があります。経験則としては、同じ一般的な型カテゴリ内の型間の情報を保持する変換に対してのみ、キャストを暗黙的に呼び出すことができます。例えば、キャストから &lt;code&gt;int2&lt;/code&gt; へ &lt;code&gt;int4&lt;/code&gt; 合理的、暗黙的なことができますが、よりキャスト &lt;code&gt;float8&lt;/code&gt; へ &lt;code&gt;int4&lt;/code&gt; 、おそらく代入のみでなければなりません。 &lt;code&gt;text&lt;/code&gt; から &lt;code&gt;int4&lt;/code&gt; へのようなタイプ間カテゴリのキャストは、明示的にのみ行うのが最適です。</target>
        </trans-unit>
        <trans-unit id="323e3c36d34b28b8ba0133e0d8df50cff77d9ca5" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;; then the server will check that the character conversion is possible.</source>
          <target state="translated">It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. A useful alternative is to use Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;; then the server will check that the character conversion is possible.</target>
        </trans-unit>
        <trans-unit id="7c5b3068c21100601581e786ee86ca3a3f0b7637" translate="yes" xml:space="preserve">
          <source>It is your responsibility that the byte sequences you create, especially when using the octal or hexadecimal escapes, compose valid characters in the server character set encoding. When the server encoding is UTF-8, then the Unicode escapes or the alternative Unicode escape syntax, explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;Section 4.1.2.3&lt;/a&gt;, should be used instead. (The alternative would be doing the UTF-8 encoding by hand and writing out the bytes, which would be very cumbersome.)</source>
          <target state="translated">作成したバイトシーケンス、特に8進数または16進数のエスケープを使用する場合は、サーバーの文字セットエンコーディングで有効な文字を構成する必要があります。サーバーのエンコーディングがUTF-8の場合は、代わりにUnicodeエスケープまたは&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-UESCAPE&quot;&gt;4.1.2.3項&lt;/a&gt;で説明した代替のUnicodeエスケープ構文を使用する必要があります。（別の方法としては、UTF-8エンコードを手動で行い、バイトを書き出す方法があり、非常に煩雑になります。）</target>
        </trans-unit>
        <trans-unit id="570a15e9c9ce6ae9a6fe65bb5309393853fdf2d9" translate="yes" xml:space="preserve">
          <source>It joins two functions into a single &lt;code&gt;FROM&lt;/code&gt; target. &lt;code&gt;json_to_recordset()&lt;/code&gt; is instructed to return two columns, the first &lt;code&gt;integer&lt;/code&gt; and the second &lt;code&gt;text&lt;/code&gt;. The result of &lt;code&gt;generate_series()&lt;/code&gt; is used directly. The &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts the column values as integers.</source>
          <target state="translated">It joins two functions into a single &lt;code&gt;FROM&lt;/code&gt; target. &lt;code&gt;json_to_recordset()&lt;/code&gt; is instructed to return two columns, the first &lt;code&gt;integer&lt;/code&gt; and the second &lt;code&gt;text&lt;/code&gt; . The result of &lt;code&gt;generate_series()&lt;/code&gt; is used directly. The &lt;code&gt;ORDER BY&lt;/code&gt; clause sorts the column values as integers.</target>
        </trans-unit>
        <trans-unit id="7e498293987ea55fea8d5b2403c8c230700d8887" translate="yes" xml:space="preserve">
          <source>It makes your SQL statements verbose, and you always have to remember to use &lt;code&gt;lower&lt;/code&gt; on both the column and the query value.</source>
          <target state="translated">SQLステートメントが冗長になるため、常に列とクエリ値の両方で &lt;code&gt;lower&lt;/code&gt; を使用することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="ef32cc79ad6cb19406da947c5847a9365640d3e1" translate="yes" xml:space="preserve">
          <source>It may also be necessary to give the database server's operating system user permission to use huge pages by setting &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; via sysctl, and/or give permission to lock memory with &lt;code&gt;ulimit -l&lt;/code&gt;.</source>
          <target state="translated">また、sysctlを介して &lt;code&gt;vm.hugetlb_shm_group&lt;/code&gt; を設定することにより、データベースサーバーのオペレーティングシステムユーザーに巨大なページを使用する権限を付与するか、 &lt;code&gt;ulimit -l&lt;/code&gt; でメモリをロックする権限を付与する必要があります。</target>
        </trans-unit>
        <trans-unit id="c230567f694e16c717ab914422a39d27766ee1c7" translate="yes" xml:space="preserve">
          <source>It may be advisable to avoid using type and table names that begin with underscore. While the server will change generated array type names to avoid collisions with user-given names, there is still risk of confusion, particularly with old client software that may assume that type names beginning with underscores always represent arrays.</source>
          <target state="translated">アンダースコアで始まる型名やテーブル名の使用は避けた方が良いでしょう。サーバは、ユーザが指定した名前との衝突を避けるために生成された配列の型名を変更しますが、特に古いクライアントソフトウェアでは、アンダースコアで始まる型名が常に配列を表していると思い込んでいる可能性があり、混乱を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="914462b7eb826c460762b58dc586f5544963cc18" translate="yes" xml:space="preserve">
          <source>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</source>
          <target state="translated">このサイズを調整して、WALログの出荷やアーカイブの粒度を制御すると便利かもしれません。また、WALの量が多いデータベースでは、ディレクトリあたりのWALファイルの数が膨大になると、パフォーマンスや管理上の問題になることがあります。WALファイルのサイズを大きくすることで、WALファイルの数を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="7c0fb5b044b855badd9b796e550a5309d125f9a8" translate="yes" xml:space="preserve">
          <source>It might, however, be necessary to modify the global &lt;code&gt;ulimit&lt;/code&gt; information in &lt;code&gt;/etc/security/limits&lt;/code&gt;, as the default hard limits for file sizes (&lt;code&gt;fsize&lt;/code&gt;) and numbers of files (&lt;code&gt;nofiles&lt;/code&gt;) might be too low.</source>
          <target state="translated">しかし、世界的な修正が必要になる場合があります &lt;code&gt;ulimit&lt;/code&gt; 中の情報 &lt;code&gt;/etc/security/limits&lt;/code&gt; デフォルトとして、ファイルサイズ（ハードリミット &lt;code&gt;fsize&lt;/code&gt; ファイル（の）と数字 &lt;code&gt;nofiles&lt;/code&gt; 低すぎるかもしれません）。</target>
        </trans-unit>
        <trans-unit id="91b31f4b37ed5e598eb7def83710e2ca48bbe707" translate="yes" xml:space="preserve">
          <source>It should also be noted that because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities. These are not discussed here.</source>
          <target state="translated">また、PostgreSQLはオープンソースで拡張が容易なため、多くの企業がPostgreSQLを採用し、独自のフェイルオーバー、レプリケーション、ロードバランシング機能を備えた商用のクローズドソースソリューションを作成していることにも注意が必要です。これらについてはここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="fff2052adc7cc9fd5e18f86ad66dfe1b9dfc242d" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">また、デフォルトのWALフォーマットには多くのディスクページスナップショットが含まれているため、かなりサイズが大きいことにも注意してください。これらのページスナップショットは、部分的に書き込まれたディスクページを修正する必要がある場合があるため、クラッシュリカバリをサポートするように設計されています。システムのハードウェアとソフトウェアによっては、部分的な書き込みのリスクが無視できるほど小さい場合があります。その場合、&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;パラメータを使用してページのスナップショットをオフにすることで、アーカイブログの総量を大幅に減らすことができます。 （その前に、&lt;a href=&quot;https://www.postgresql.org/docs/12/wal.html&quot;&gt;第29章の&lt;/a&gt;注意と警告をお読みください。）ページのスナップショットをオフにしても、PITR操作のログの使用が妨げられることはありません。今後の開発の領域は、 &lt;code&gt;full_page_writes&lt;/code&gt; の場合でも不要なページコピーを削除して、アーカイブされたWALデータを圧縮することですオンです。それまでの間、管理者は、チェックポイント間隔パラメーターを可能な限り大きくして、WALに含まれるページスナップショットの数を減らしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="27800a360494c7320b8e3b3710d75e18bd41894b" translate="yes" xml:space="preserve">
          <source>It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</source>
          <target state="translated">It should also be noted that the default WAL format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. (Read the notes and warnings in &lt;a href=&quot;https://www.postgresql.org/docs/13/wal.html&quot;&gt;Chapter 29&lt;/a&gt; before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when &lt;code&gt;full_page_writes&lt;/code&gt; is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</target>
        </trans-unit>
        <trans-unit id="af922062ac86a130253f6b4fd50587d3a97630cd" translate="yes" xml:space="preserve">
          <source>It should be fairly clear why a btree index requires these laws to hold within a single data type: without them there is no ordering to arrange the keys with. Also, index searches using a comparison key of a different data type require comparisons to behave sanely across two data types. The extensions to three or more data types within a family are not strictly required by the btree index mechanism itself, but the planner relies on them for optimization purposes.</source>
          <target state="translated">btreeインデックスがこれらの法則を単一のデータ型内で保持する必要がある理由は、かなり明確になっているはずです。また、異なるデータ型の比較キーを使用したインデックス検索では、2つのデータ型の間で比較が正しく動作するようにする必要があります。ファミリ内の3つ以上のデータ型への拡張は、btreeインデックス機構自体が厳密に必要とするものではありませんが、プランナーは最適化のためにそれらに依存しています。</target>
        </trans-unit>
        <trans-unit id="e49813f2476bbea73d4ff66119d7d7387c964091" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;code&gt;pg_cast&lt;/code&gt; does not represent every type conversion that the system knows how to perform; only those that cannot be deduced from some generic rule. For example, casting between a domain and its base type is not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;. Another important exception is that &amp;ldquo;automatic I/O conversion casts&amp;rdquo;, those performed using a data type's own I/O functions to convert to or from &lt;code&gt;text&lt;/code&gt; or other string types, are not explicitly represented in &lt;code&gt;pg_cast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_cast&lt;/code&gt; は、システムが実行方法を知っているすべての型変換を表すわけではないことに注意してください。いくつかの一般的なルールから推定できないもののみ。たとえば、ドメインとその基本型の間のキャストは、 &lt;code&gt;pg_cast&lt;/code&gt; では明示的に表現されていません。もう1つの重要な例外は、「自動I / O変換キャスト」、つまりデータタイプ自体のI / O関数を使用して &lt;code&gt;text&lt;/code&gt; または他の文字列タイプとの間で変換を行うものであり、 &lt;code&gt;pg_cast&lt;/code&gt; では明示的に表されません。</target>
        </trans-unit>
        <trans-unit id="3f75a2b78a5f5649b3ab9e555457464dd4adddae" translate="yes" xml:space="preserve">
          <source>It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used.</source>
          <target state="translated">チェック制約は、チェック式が真またはヌル値に評価された場合に満たされることに注意する必要があります。ほとんどの式は、任意のオペランドがNULLであればNULL値に評価されるので、制約のある列にNULL値が含まれないようにすることはできません。列にNULL値が含まれないようにするには、次のセクションで説明する非NULL制約を使用することができます。</target>
        </trans-unit>
        <trans-unit id="02935ea4ceb5538c0d2002f169c21bb8e60788b3" translate="yes" xml:space="preserve">
          <source>It should be noted that database superusers can access all objects regardless of object privilege settings. This is comparable to the rights of &lt;code&gt;root&lt;/code&gt; in a Unix system. As with &lt;code&gt;root&lt;/code&gt;, it's unwise to operate as a superuser except when absolutely necessary.</source>
          <target state="translated">データベースのスーパーユーザーは、オブジェクトの権限設定に関係なく、すべてのオブジェクトにアクセスできることに注意してください。これは、Unixシステムの &lt;code&gt;root&lt;/code&gt; の権限に相当します。 &lt;code&gt;root&lt;/code&gt; と同様に、どうしても必要な場合を除いて、スーパーユーザーとして操作することは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="8c98ab8e1a3d8f36aae75d2304e7a94b266eaa6f" translate="yes" xml:space="preserve">
          <source>It should be noted that except for &lt;code&gt;count&lt;/code&gt;, these functions return a null value when no rows are selected. In particular, &lt;code&gt;sum&lt;/code&gt; of no rows returns null, not zero as one might expect, and &lt;code&gt;array_agg&lt;/code&gt; returns null rather than an empty array when there are no input rows. The &lt;code&gt;coalesce&lt;/code&gt; function can be used to substitute zero or an empty array for null when necessary.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; を除き、行が選択されていない場合、これらの関数はnull値を返すことに注意してください。特に、行がない場合の &lt;code&gt;sum&lt;/code&gt; は期待どおりにゼロではなくnullを返し、入力行がない場合、 &lt;code&gt;array_agg&lt;/code&gt; は空の配列ではなくnullを返します。 &lt;code&gt;coalesce&lt;/code&gt; 機能は代替ゼロまたはヌルのために空の配列に必要に使用することができます。</target>
        </trans-unit>
        <trans-unit id="fcddd727e8976d04c908eb345e29817691fb2925" translate="yes" xml:space="preserve">
          <source>It should be noted that log shipping is asynchronous, i.e., the WAL records are shipped after transaction commit. As a result, there is a window for data loss should the primary server suffer a catastrophic failure; transactions not yet shipped will be lost. The size of the data loss window in file-based log shipping can be limited by use of the &lt;code&gt;archive_timeout&lt;/code&gt; parameter, which can be set as low as a few seconds. However such a low setting will substantially increase the bandwidth required for file shipping. Streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;) allows a much smaller window of data loss.</source>
          <target state="translated">ログ配布は非同期であることに注意してください。つまり、WALレコードはトランザクションのコミット後に配布されます。その結果、プライマリサーバーで壊滅的な障害が発生した場合に、データが失われる可能性があります。まだ出荷されていないトランザクションは失われます。ファイルベースのログ配布でのデータ損失ウィンドウのサイズは、 &lt;code&gt;archive_timeout&lt;/code&gt; パラメータを使用して制限できます。このパラメータは、数秒に設定できます。ただし、このような低い設定では、ファイル配布に必要な帯域幅が大幅に増加します。ストリーミングレプリケーション（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）では、データ損失のウィンドウをはるかに小さくできます。</target>
        </trans-unit>
        <trans-unit id="3fca8a3246e56f8200631a2d48d923a7438a3af3" translate="yes" xml:space="preserve">
          <source>It should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">It should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt; , as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</target>
        </trans-unit>
        <trans-unit id="3defdb9a09006209e803808debdc569c264d27e7" translate="yes" xml:space="preserve">
          <source>It won't use an index, unless you create a functional index using &lt;code&gt;lower&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lower&lt;/code&gt; を使用して関数インデックスを作成しない限り、インデックスは使用されません。</target>
        </trans-unit>
        <trans-unit id="6b722c9c9f3f75689f42f0b53f218a01c48008e8" translate="yes" xml:space="preserve">
          <source>It would be better to instead create child tables as follows:</source>
          <target state="translated">代わりに以下のように子テーブルを作成した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="b3751c875e52c61621661f1961d94164268c168e" translate="yes" xml:space="preserve">
          <source>It's a matter of taste.</source>
          <target state="translated">好みの問題です。</target>
        </trans-unit>
        <trans-unit id="6308fac37b6f916e6aaeedec4f54478b5685b89a" translate="yes" xml:space="preserve">
          <source>It's advisable to create &lt;code&gt;ndistinct&lt;/code&gt; statistics objects only on combinations of columns that are actually used for grouping, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; cycles are just wasted.</source>
          <target state="translated">グループ化に実際に使用されている列の組み合わせでのみ &lt;code&gt;ndistinct&lt;/code&gt; 統計オブジェクトを作成することをお勧めします。そのため、グループ数の誤った推定が悪い計画につながります。そうしないと、 &lt;code&gt;ANALYZE&lt;/code&gt; サイクルが無駄になります。</target>
        </trans-unit>
        <trans-unit id="695d14c6506a71cfb6f8af1b5d18b963ae0d4f6f" translate="yes" xml:space="preserve">
          <source>It's advisable to create MCV statistics objects only on combinations of columns that are actually used in conditions together, and for which misestimation of the number of groups is resulting in bad plans. Otherwise, the &lt;code&gt;ANALYZE&lt;/code&gt; and planning cycles are just wasted.</source>
          <target state="translated">MCV統計オブジェクトは、実際に条件で一緒に使用されている列の組み合わせでのみ作成することをお勧めします。このため、グループ数の誤推定が原因で、計画が悪くなります。そうしないと、 &lt;code&gt;ANALYZE&lt;/code&gt; と計画のサイクルが無駄になります。</target>
        </trans-unit>
        <trans-unit id="26d8635c1af4731c90f7caf11c20fceefa695a0b" translate="yes" xml:space="preserve">
          <source>It's also permissible to attach &lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; to integer columns to reference character set encodings, which are not currently represented as catalog OIDs, but have a set of values known to &lt;code&gt;genbki.pl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BKI_LOOKUP(encoding)&lt;/code&gt; を整数列にアタッチして、現在カタログOIDとして表されていないが、 &lt;code&gt;genbki.pl&lt;/code&gt; に既知の値のセットを持つ文字セットエンコーディングを参照することもできます。</target>
        </trans-unit>
        <trans-unit id="42cd973aeb3dbef0c62ad2e81081d6f4bf4973db" translate="yes" xml:space="preserve">
          <source>It's also possible to select no escape character by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern.</source>
          <target state="translated">&lt;code&gt;ESCAPE ''&lt;/code&gt; と書くことで、エスケープ文字を選択しないこともできます。これにより、エスケープメカニズムが事実上無効になり、パターン内のアンダースコアとパーセント記号の特別な意味をオフにすることができなくなります。</target>
        </trans-unit>
        <trans-unit id="8646be546a98ef8ea063cb9eec163a8d4548ff24" translate="yes" xml:space="preserve">
          <source>It's essential that the data types and other properties of the columns declared in &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; match the actual remote table. Column names must match as well, unless you attach &lt;code&gt;column_name&lt;/code&gt; options to the individual columns to show how they are named in the remote table. In many cases, use of &lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMA&lt;/a&gt; is preferable to constructing foreign table definitions manually.</source>
          <target state="translated">&lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; で宣言された列のデータ型とその他のプロパティが実際のリモートテーブルと一致することが重要です。列名も一致する必要があります。ただし、 &lt;code&gt;column_name&lt;/code&gt; オプションを個々の列にアタッチして、リモートテーブルでの列の名前を示す場合を除きます。多くの場合、外部テーブル定義を手動で作成するよりも、&lt;a href=&quot;sql-importforeignschema&quot;&gt;IMPORT FOREIGN SCHEMAを&lt;/a&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a75f17e623d692c2b958fa72bc491d5871febb40" translate="yes" xml:space="preserve">
          <source>It's important to understand that the cost of an upper-level node includes the cost of all its child nodes. It's also important to realize that the cost only reflects things that the planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client, which could be an important factor in the real elapsed time; but the planner ignores it because it cannot change it by altering the plan. (Every correct plan will output the same row set, we trust.)</source>
          <target state="translated">上位ノードのコストには、その子ノードすべてのコストが含まれていることを理解することが重要です。また、コストはプランナが気にしていることを反映しているだけであることを理解することも重要です。これは実際の経過時間の重要な要素である可能性がありますが,プランナはプランを変更しても変更できないため,これを無視します.しかし,プランナーはプランを変更することで変更できないため,これを無視しています.</target>
        </trans-unit>
        <trans-unit id="7c3ed76ba22932f8e0061fba8fda8ba6c6509eab" translate="yes" xml:space="preserve">
          <source>It's possible to control the statements in a transaction in a more granular fashion through the use of &lt;em&gt;savepoints&lt;/em&gt;. Savepoints allow you to selectively discard parts of the transaction, while committing the rest. After defining a savepoint with &lt;code&gt;SAVEPOINT&lt;/code&gt;, you can if needed roll back to the savepoint with &lt;code&gt;ROLLBACK TO&lt;/code&gt;. All the transaction's database changes between defining the savepoint and rolling back to it are discarded, but changes earlier than the savepoint are kept.</source>
          <target state="translated">&lt;em&gt;セーブポイントを&lt;/em&gt;使用すると、トランザクション内のステートメントをより詳細に制御できます。セーブポイントを使用すると、トランザクションの一部を選択的に破棄し、残りをコミットすることができます。 &lt;code&gt;SAVEPOINT&lt;/code&gt; でセーブポイントを定義した後、必要に応じて &lt;code&gt;ROLLBACK TO&lt;/code&gt; でセーブポイントにロールバックできます。セーブポイントの定義からロールバックまでのトランザクションのデータベース変更はすべて破棄されますが、セーブポイントより前の変更は保持されます。</target>
        </trans-unit>
        <trans-unit id="af6b5757cbe3f9b4c6401b87c759f120734c17d1" translate="yes" xml:space="preserve">
          <source>It's recommended to run &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; before submitting catalog data patches. For convenience, you can simply change to &lt;code&gt;src/include/catalog/&lt;/code&gt; and run &lt;code&gt;make reformat-dat-files&lt;/code&gt;.</source>
          <target state="translated">実行することをお勧めします &lt;code&gt;reformat_dat_file.pl&lt;/code&gt; をカタログデータのパッチを提出する前に。便宜上、単に &lt;code&gt;src/include/catalog/&lt;/code&gt; 変更して &lt;code&gt;make reformat-dat-files&lt;/code&gt; を実行するだけです。</target>
        </trans-unit>
        <trans-unit id="4f13f984e4f7daa459e845c3a4715f4638313970" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches.</source>
          <target state="translated">インデックスにキーではないカラム、特に幅の広いカラムを追加することは慎重に行うのが賢明です。インデックスのタプルがインデックスタイプで許可されている最大サイズを超えると、データの挿入に失敗します。いずれにしても、非キーカラムはインデックスのテーブルからデータを複製し、インデックスのサイズを肥大化させ、検索を遅らせる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e5c646abb35ed677e4428cd5146fe3efa3d6f1d7" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. Furthermore, B-tree deduplication is never used with indexes that have a non-key column.</source>
          <target state="translated">インデックスにキーではないカラム、特に幅の広いカラムを追加することは慎重に行うのが賢明です。インデックスのタプルがインデックスタイプで許可されている最大サイズを超えると、データの挿入に失敗します。いずれにしても、非キーカラムはインデックスのテーブルからデータを複製し、インデックスのサイズを肥大化させ、検索を遅らせる可能性がある。さらに、B-tree重複排除は、非キーカラムを持つインデックスでは決して使用されません。</target>
        </trans-unit>
        <trans-unit id="08237634e67b792c41b6dc72d01cf498506db594" translate="yes" xml:space="preserve">
          <source>It's wise to be conservative about adding non-key payload columns to an index, especially wide columns. If an index tuple exceeds the maximum size allowed for the index type, data insertion will fail. In any case, non-key columns duplicate data from the index's table and bloat the size of the index, thus potentially slowing searches. And remember that there is little point in including payload columns in an index unless the table changes slowly enough that an index-only scan is likely to not need to access the heap. If the heap tuple must be visited anyway, it costs nothing more to get the column's value from there. Other restrictions are that expressions are not currently supported as included columns, and that only B-tree and GiST indexes currently support included columns.</source>
          <target state="translated">インデックスにキー以外のペイロードカラム、特に幅の広いカラムを追加することは慎重に行うのが賢明です。インデックスのタプルがインデックスタイプで許可されている最大サイズを超えると、データの挿入に失敗します。いずれにしても、非キーカラムはインデックスのテーブルからデータを複製し、インデックスのサイズを肥大化させ、検索を遅らせる可能性があります。また、インデックスのみのスキャンでヒープにアクセスする必要がないほどテーブルの変化が遅い場合を除いては、インデックスにペイロードカラムを含めることにはほとんど意味がないことを覚えておいてください。ヒープタプルにアクセスしなければならないのであれば、そこからカラムの値を取得しても、それ以上のコストはかかりません。その他の制限事項としては、式は現在のところインクルードカラムとしてサポートされていないことと、現在のところインクルードカラムをサポートしているのはB-treeとGiSTインデックスのみであることが挙げられます。</target>
        </trans-unit>
        <trans-unit id="9682da0882fceeebec9d99753c1dc0306b85beab" translate="yes" xml:space="preserve">
          <source>It's worth noticing that the AND/OR/NOT operators mean something subtly different when they are within the arguments of a FOLLOWED BY operator than when they are not, because within FOLLOWED BY the exact position of the match is significant. For example, normally &lt;code&gt;!x&lt;/code&gt; matches only documents that do not contain &lt;code&gt;x&lt;/code&gt; anywhere. But &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; matches &lt;code&gt;y&lt;/code&gt; if it is not immediately after an &lt;code&gt;x&lt;/code&gt;; an occurrence of &lt;code&gt;x&lt;/code&gt; elsewhere in the document does not prevent a match. Another example is that &lt;code&gt;x &amp;amp; y&lt;/code&gt; normally only requires that &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; both appear somewhere in the document, but &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; requires &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to match at the same place, immediately before a &lt;code&gt;z&lt;/code&gt;. Thus this query behaves differently from &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt;, which will match a document containing two separate sequences &lt;code&gt;x z&lt;/code&gt; and &lt;code&gt;y z&lt;/code&gt;. (This specific query is useless as written, since &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; could not match at the same place; but with more complex situations such as prefix-match patterns, a query of this form could be useful.)</source>
          <target state="translated">AND / OR / NOT演算子は、FOLLOWED BY演算子の引数内にある場合とそうでない場合とで微妙に異なる意味を持つことに注意してください。FOLLOWEDBY内では、一致の正確な位置が重要であるためです。たとえば、通常、 &lt;code&gt;!x&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; を含まないドキュメントのみに一致します。しかし &lt;code&gt;!x &amp;lt;-&amp;gt; y&lt;/code&gt; 一致する &lt;code&gt;y&lt;/code&gt; は、それがした直後でない場合は &lt;code&gt;x&lt;/code&gt; 、文書内の他の場所で &lt;code&gt;x&lt;/code&gt; が発生しても、一致は妨げられません。別の例として、 &lt;code&gt;x &amp;amp; y&lt;/code&gt; は通常、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方がドキュメントのどこかにあることだけを要求しますが、 &lt;code&gt;(x &amp;amp; y) &amp;lt;-&amp;gt; z&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は、 &lt;code&gt;z&lt;/code&gt; の直前の同じ場所で一致します。したがって、このクエリの動作は &lt;code&gt;x &amp;lt;-&amp;gt; z &amp;amp; y &amp;lt;-&amp;gt; z&lt;/code&gt; とは異なります。これは、2つの別個のシーケンス &lt;code&gt;x z&lt;/code&gt; と &lt;code&gt;y z&lt;/code&gt; を含むドキュメントに一致します。 （この特定のクエリは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が同じ場所で一致することができないため、記述されているようには役に立ちません。ただし、プレフィックス一致パターンなどのより複雑な状況では、この形式のクエリが役立つ場合があります。）</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="036b57986556b399e1579aa78767ca4cf343c8b5" translate="yes" xml:space="preserve">
          <source>ItemIdData</source>
          <target state="translated">ItemIdData</target>
        </trans-unit>
        <trans-unit id="a2965a078eaef7ee13c972baa85b167370cde26a" translate="yes" xml:space="preserve">
          <source>ItemPointerData</source>
          <target state="translated">ItemPointerData</target>
        </trans-unit>
        <trans-unit id="44d25b5d1b6d98c7d090ca3609aca11ae2815fa0" translate="yes" xml:space="preserve">
          <source>Items</source>
          <target state="translated">Items</target>
        </trans-unit>
        <trans-unit id="40f7cf3bbd8b78d82db16eda601698d7597b9ba5" translate="yes" xml:space="preserve">
          <source>J.5. Style Guide</source>
          <target state="translated">J.5.スタイルガイド</target>
        </trans-unit>
        <trans-unit id="7685fa01b8b7b34ce179631444878fcbce78fa81" translate="yes" xml:space="preserve">
          <source>J2451187</source>
          <target state="translated">J2451187</target>
        </trans-unit>
        <trans-unit id="1f1062dcbb83b59e4f6f5cb50ef505afac199e0d" translate="yes" xml:space="preserve">
          <source>JDBC</source>
          <target state="translated">JDBC</target>
        </trans-unit>
        <trans-unit id="eb5d2f4a58038c71155ddcf3cea35dc3c6d34501" translate="yes" xml:space="preserve">
          <source>JIT</source>
          <target state="translated">JIT</target>
        </trans-unit>
        <trans-unit id="6a623f63efe8bb915b0cd81dd3786e0511e1c1a1" translate="yes" xml:space="preserve">
          <source>JIT compilation is beneficial primarily for long-running CPU-bound queries. Frequently these will be analytical queries. For short queries the added overhead of performing JIT compilation will often be higher than the time it can save.</source>
          <target state="translated">JITコンパイルは、主に長期的に実行されるCPUバウンドクエリのために有益です。多くの場合、これらのクエリは分析クエリになります。短いクエリでは、JIT コンパイルの実行によるオーバーヘッドの増加は、多くの場合、時間を節約するよりも高くなります。</target>
        </trans-unit>
        <trans-unit id="6f7646a5ebe2aff38f294e6e525f0ea1b56f8538" translate="yes" xml:space="preserve">
          <source>JOHAB</source>
          <target state="translated">JOHAB</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c731d9e245778a9537fc026bc57fb4f455f28593" translate="yes" xml:space="preserve">
          <source>JSON Functions and Operators</source>
          <target state="translated">JSON関数と演算子</target>
        </trans-unit>
        <trans-unit id="95cc452498b3190abb79d4cdad349208be23c944" translate="yes" xml:space="preserve">
          <source>JSON Types</source>
          <target state="translated">JSONの種類</target>
        </trans-unit>
        <trans-unit id="f9bea7492dcebb5f109566d49e4bca935a7e0ff7" translate="yes" xml:space="preserve">
          <source>JSON Types: boolean</source>
          <target state="translated">JSON型:boolean</target>
        </trans-unit>
        <trans-unit id="22aff2decb9f95af65f4e2a85c938a9901c03229" translate="yes" xml:space="preserve">
          <source>JSON Types: null</source>
          <target state="translated">JSONの種類:null</target>
        </trans-unit>
        <trans-unit id="b89570edbe3781b5bd3ad2ae7d37f0bf110fdf05" translate="yes" xml:space="preserve">
          <source>JSON Types: number</source>
          <target state="translated">JSON型:数値</target>
        </trans-unit>
        <trans-unit id="205b72d84addc780073dacc96aedf0a7c5c2d3cc" translate="yes" xml:space="preserve">
          <source>JSON Types: string</source>
          <target state="translated">JSON型:文字列</target>
        </trans-unit>
        <trans-unit id="6fb42476959dba43e5b647429008c3399be7120f" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">JSON constant &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826d7973fb0fe99520474814c729759899e1f084" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;null&lt;/code&gt; (note that, unlike in SQL, comparison to &lt;code&gt;null&lt;/code&gt; works normally)</source>
          <target state="translated">JSON constant &lt;code&gt;null&lt;/code&gt; (note that, unlike in SQL, comparison to &lt;code&gt;null&lt;/code&gt; works normally)</target>
        </trans-unit>
        <trans-unit id="7b5978544d202bc2b880af72e00c6ff1ea552f31" translate="yes" xml:space="preserve">
          <source>JSON constant &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">JSON constant &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49c22c401963d3661a06e8b5108d657673586e05" translate="yes" xml:space="preserve">
          <source>JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently.</source>
          <target state="translated">JSON データは、テーブルに格納されている場合、他のデータ型と同じ同時実行制御の考慮事項に従います。大きなドキュメントを保存することは可能ですが、更新を行うと行全体の行レベルのロックを取得することに注意しましょう。更新トランザクション間のロックの競合を減らすために、JSON文書を管理可能なサイズに制限することを検討してください。理想的には、JSON文書はそれぞれが、ビジネスルールで規定されているアトミックなデータムを表すべきであり、独立して変更可能な小さなデータムに分割することは合理的に不可能です。</target>
        </trans-unit>
        <trans-unit id="062e2dcdb89d67da750325f5a32e496783b448b0" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">JSONデータ型は、&lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159で&lt;/a&gt;指定されている JSON（JavaScript Object Notation）データを格納するためのものです。このようなデータは &lt;code&gt;text&lt;/code&gt; として保存することもできますが、JSONデータ型には、保存された各値がJSONルールに従って有効であるという利点があります。これらのデータ型に格納されたデータに使用できるJSON固有の関数と演算子も各種あります。&lt;a href=&quot;functions-json&quot;&gt;セクション9.15を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3439d51ccc84271989a1fe8ee4c05702a949e43b" translate="yes" xml:space="preserve">
          <source>JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt;, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC 7159&lt;/a&gt;. Such data can also be stored as &lt;code&gt;text&lt;/code&gt; , but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1b285244e0c7fb77cf325258e945007dbcb0bd79" translate="yes" xml:space="preserve">
          <source>JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly.</source>
          <target state="translated">JSON オブジェクトは配列とは異なり、内部的に検索用に最適化されており、直線的に検索される必要がないため、多くのキーや要素が含まれている場合の格納性や存在性のテストには配列よりも適しています。</target>
        </trans-unit>
        <trans-unit id="ff7a8b7bee4833026249925bb4a7e075a31995d4" translate="yes" xml:space="preserve">
          <source>JSON primitive type</source>
          <target state="translated">JSON基本型</target>
        </trans-unit>
        <trans-unit id="21d0c78d1738d7a3274678ad613fc7038b9e1cd3" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</source>
          <target state="translated">JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</target>
        </trans-unit>
        <trans-unit id="196dea5dbe3d820f7bdbd4775445b07993543c68" translate="yes" xml:space="preserve">
          <source>JSON query functions and operators pass the provided path expression to the &lt;em&gt;path engine&lt;/em&gt; for evaluation. If the expression matches the queried JSON data, the corresponding SQL/JSON item is returned. Path expressions are written in the SQL/JSON path language and can also include arithmetic expressions and functions. Query functions treat the provided expression as a text string, so it must be enclosed in single quotes.</source>
          <target state="translated">JSONクエリ関数と演算子は、提供されたパス式を評価のために&lt;em&gt;パスエンジン&lt;/em&gt;に渡します。式がクエリされたJSONデータと一致する場合、対応するSQL / JSONアイテムが返されます。パス式はSQL / JSONパス言語で記述され、算術式や関数を含めることもできます。クエリ関数は提供された式をテキスト文字列として扱うため、一重引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="7af619b9c5342e6a889b85ca2cae08237b23f616" translate="yes" xml:space="preserve">
          <source>JSON: SQL/JSON Path Language</source>
          <target state="translated">JSON:SQL/JSONパス言語</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="ebeb4b5ab2f3409935c06be07e3191bf0a5dc6cf" translate="yes" xml:space="preserve">
          <source>Jan-08-1999</source>
          <target state="translated">Jan-08-1999</target>
        </trans-unit>
        <trans-unit id="521a936bf91733c55274b55367cc8ed71292693f" translate="yes" xml:space="preserve">
          <source>Jan-08-99</source>
          <target state="translated">Jan-08-99</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="d6e52d181e7ba4487fe8643d957277cd1cbf82c7" translate="yes" xml:space="preserve">
          <source>January 18 in &lt;code&gt;MDY&lt;/code&gt; mode; rejected in other modes</source>
          <target state="translated">1月18日、 &lt;code&gt;MDY&lt;/code&gt; モード。他のモードでは拒否されました</target>
        </trans-unit>
        <trans-unit id="d1fb4cc8c23271615e96e586a4e1801c1ac84f25" translate="yes" xml:space="preserve">
          <source>January 2, 2003 in &lt;code&gt;MDY&lt;/code&gt; mode; February 1, 2003 in &lt;code&gt;DMY&lt;/code&gt; mode; February 3, 2001 in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">2003年1月2日、 &lt;code&gt;MDY&lt;/code&gt; モード。2003年2月1日、 &lt;code&gt;DMY&lt;/code&gt; モード。 &lt;code&gt;YMD&lt;/code&gt; モードの2001年2月3日</target>
        </trans-unit>
        <trans-unit id="397474e233d9068687b354fbdbc0b01176bcc2cc" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;MDY&lt;/code&gt; mode; August 1 in &lt;code&gt;DMY&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;MDY&lt;/code&gt; モードの1月8日。8月1日、 &lt;code&gt;DMY&lt;/code&gt; モード</target>
        </trans-unit>
        <trans-unit id="2391ee88b9183f9c31234260c9722e2d62c959b0" translate="yes" xml:space="preserve">
          <source>January 8 in &lt;code&gt;YMD&lt;/code&gt; mode, else error</source>
          <target state="translated">&lt;code&gt;YMD&lt;/code&gt; モードの1月8日、それ以外のエラー</target>
        </trans-unit>
        <trans-unit id="347ee622c39fd3015013d75c9106e7b8164231b7" translate="yes" xml:space="preserve">
          <source>January 8 in any mode</source>
          <target state="translated">どのモードでも1月8日</target>
        </trans-unit>
        <trans-unit id="682c812bf69e66e4c213bdbcc9a0930f43e82030" translate="yes" xml:space="preserve">
          <source>January 8, 1999</source>
          <target state="translated">1999年1月8日</target>
        </trans-unit>
        <trans-unit id="4444d015dc1b7e202a7ab992a769c820f60f9019" translate="yes" xml:space="preserve">
          <source>January 8, 99 BC</source>
          <target state="translated">紀元前99年1月8日</target>
        </trans-unit>
        <trans-unit id="07425bcd86481aaf19f3e5b4016da2c9f5e1cec4" translate="yes" xml:space="preserve">
          <source>January 8, except error in &lt;code&gt;YMD&lt;/code&gt; mode</source>
          <target state="translated">1月8日、 &lt;code&gt;YMD&lt;/code&gt; モードのエラーを除く</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="21087b70eba36ef97c23b6fae1bc0502a8c7faff" translate="yes" xml:space="preserve">
          <source>Java Database Connectivity</source>
          <target state="translated">ジャワデータベース接続性</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">JavaScript オブジェクト記法</target>
        </trans-unit>
        <trans-unit id="66dc64282e7e424443c0ee036f6560a8429101fe" translate="yes" xml:space="preserve">
          <source>Jean-Luc Cooke Fortuna-based &lt;code&gt;/dev/random&lt;/code&gt; driver for Linux.</source>
          <target state="translated">Linux用のJean-Luc Cooke Fortunaベースの &lt;code&gt;/dev/random&lt;/code&gt; ドライバー。</target>
        </trans-unit>
        <trans-unit id="076e3b3dd165a68d5a1635c764f91d575d41e991" translate="yes" xml:space="preserve">
          <source>Joe Conway</source>
          <target state="translated">ジョー・コンウェイ</target>
        </trans-unit>
        <trans-unit id="36223c3c072f8f4857df7670837893beb8c9ab05" translate="yes" xml:space="preserve">
          <source>John Gray &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ジョングレイ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:jgray@azuli.co.uk&quot;&gt;jgray@azuli.co.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="5253095e71e396147a5bb85865b313a4dfaabec4" translate="yes" xml:space="preserve">
          <source>Join queries of the kind seen thus far can also be written in this alternative form:</source>
          <target state="translated">これまでに見られた種類のジョインクエリは、この代替形式でも書くことができます。</target>
        </trans-unit>
        <trans-unit id="5d51427844afa7a67c043cae62a1e058c08bf8eb" translate="yes" xml:space="preserve">
          <source>Join selectivity estimation function for this operator</source>
          <target state="translated">この演算子の結合選択性推定関数</target>
        </trans-unit>
        <trans-unit id="60bbcdff104b8ef5971151f077f9a3a69bf41608" translate="yes" xml:space="preserve">
          <source>Joins of all types can be chained together, or nested: either or both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; can be joined tables. Parentheses can be used around &lt;code&gt;JOIN&lt;/code&gt; clauses to control the join order. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt; clauses nest left-to-right.</source>
          <target state="translated">すべてのタイプの加入は、一緒に連鎖、または入れ子にすることができる。いずれかまたは両方 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; は、テーブルを接合することができます。 &lt;code&gt;JOIN&lt;/code&gt; 句を括弧で囲んで、結合順序を制御できます。括弧がない場合、 &lt;code&gt;JOIN&lt;/code&gt; 句は左から右にネストします。</target>
        </trans-unit>
        <trans-unit id="b737558468d75ca55b2d9185c0b55eacaea627a0" translate="yes" xml:space="preserve">
          <source>Jul</source>
          <target state="translated">Jul</target>
        </trans-unit>
        <trans-unit id="a78c0406ce3eb63581cbacb7e7085ef4cbc36ad9" translate="yes" xml:space="preserve">
          <source>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</source>
          <target state="translated">ユリウス日</target>
        </trans-unit>
        <trans-unit id="b597ea9fa797a2c2073652808359aeb10b763510" translate="yes" xml:space="preserve">
          <source>Julian date</source>
          <target state="translated">ユリウス日付</target>
        </trans-unit>
        <trans-unit id="df97a42549e5c0e1753b985126565531cc9f3c56" translate="yes" xml:space="preserve">
          <source>July</source>
          <target state="translated">July</target>
        </trans-unit>
        <trans-unit id="6d90df3be4d0d43b08e3fb47f55e09b5b06dae3e" translate="yes" xml:space="preserve">
          <source>Jun</source>
          <target state="translated">Jun</target>
        </trans-unit>
        <trans-unit id="a9db906761699b31567727716eaa6fd19ae5f5d5" translate="yes" xml:space="preserve">
          <source>June</source>
          <target state="translated">June</target>
        </trans-unit>
        <trans-unit id="7b1ddc607d5041d94adba7779845219a639a5e00" translate="yes" xml:space="preserve">
          <source>Just as in a non-parallel plan, the driving table may be joined to one or more other tables using a nested loop, hash join, or merge join. The inner side of the join may be any kind of non-parallel plan that is otherwise supported by the planner provided that it is safe to run within a parallel worker. Depending on the join type, the inner side may also be a parallel plan.</source>
          <target state="translated">非並列計画の場合と同様に、駆動テーブルは、入れ子ループ、ハッシュ結合、マージ結合を使用して、1つ以上の他のテーブルに結合することができます。ジョインの内側は、並列ワーカー内で実行しても安全であれば、プランナがサポートしている非並列プランであってもかまいません。ジョインのタイプによっては、内側が並列プランになることもあります。</target>
        </trans-unit>
        <trans-unit id="dce656c6d5efc6ceb90feb56120166673a499a99" translate="yes" xml:space="preserve">
          <source>Just as in a table, every output column of a &lt;code&gt;SELECT&lt;/code&gt; has a name. In a simple &lt;code&gt;SELECT&lt;/code&gt; this name is just used to label the column for display, but when the &lt;code&gt;SELECT&lt;/code&gt; is a sub-query of a larger query, the name is seen by the larger query as the column name of the virtual table produced by the sub-query. To specify the name to use for an output column, write &lt;code&gt;AS&lt;/code&gt;&lt;code&gt;output_name&lt;/code&gt; after the column's expression. (You can omit &lt;code&gt;AS&lt;/code&gt;, but only if the desired output name does not match any PostgreSQL keyword (see &lt;a href=&quot;sql-keywords-appendix&quot;&gt;Appendix C&lt;/a&gt;). For protection against possible future keyword additions, it is recommended that you always either write &lt;code&gt;AS&lt;/code&gt; or double-quote the output name.) If you do not specify a column name, a name is chosen automatically by PostgreSQL. If the column's expression is a simple column reference then the chosen name is the same as that column's name. In more complex cases a function or type name may be used, or the system may fall back on a generated name such as &lt;code&gt;?column?&lt;/code&gt;.</source>
          <target state="translated">テーブルと同じように、 &lt;code&gt;SELECT&lt;/code&gt; のすべての出力列には名前があります。単純な &lt;code&gt;SELECT&lt;/code&gt; では、この名前は表示用の列にラベルを付けるために使用されますが、 &lt;code&gt;SELECT&lt;/code&gt; がより大きなクエリのサブクエリである場合、その名前は、より大きなクエリによって、サブによって作成された仮想テーブルの列名として表示されます。 -query。出力列に使用する名前を指定するには、列の式の後に &lt;code&gt;AS&lt;/code&gt; &lt;code&gt;output_name&lt;/code&gt; を記述します。 （ &lt;code&gt;AS&lt;/code&gt; は省略できますが、必要な出力名がPostgreSQLキーワードに一致しない場合に限ります（&lt;a href=&quot;sql-keywords-appendix&quot;&gt;付録Cを&lt;/a&gt;参照）。将来のキーワードの追加を防ぐため、常に &lt;code&gt;AS&lt;/code&gt; を記述することをお勧めしますまたは出力名を二重引用符で囲みます。）列名を指定しない場合、名前はPostgreSQLによって自動的に選択されます。列の式が単純な列参照の場合、選択された名前はその列の名前と同じです。より複雑なケースでは、関数または型の名前が使用されるか、システムが &lt;code&gt;?column?&lt;/code&gt; などの生成された名前にフォールバックする場合があります。。</target>
        </trans-unit>
        <trans-unit id="643851cd97b3016db737a7445d565c8fa4d8baef" translate="yes" xml:space="preserve">
          <source>Just as with indexes, a foreign key constraint can be checked &amp;ldquo;in bulk&amp;rdquo; more efficiently than row-by-row. So it might be useful to drop foreign key constraints, load data, and re-create the constraints. Again, there is a trade-off between data load speed and loss of error checking while the constraint is missing.</source>
          <target state="translated">インデックスの場合と同様に、外部キー制約は、行単位よりも「一括」で効率的にチェックできます。したがって、外部キー制約を削除し、データをロードして、制約を再作成すると便利な場合があります。繰り返しになりますが、制約が欠落している間、データのロード速度とエラーチェックの喪失との間にはトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="22069315e577148c2b004f5dd6381d3b0deef8a4" translate="yes" xml:space="preserve">
          <source>Just-in-Time (JIT) compilation is the process of turning some form of interpreted program evaluation into a native program, and doing so at run time. For example, instead of using general-purpose code that can evaluate arbitrary SQL expressions to evaluate a particular SQL predicate like &lt;code&gt;WHERE a.col = 3&lt;/code&gt;, it is possible to generate a function that is specific to that expression and can be natively executed by the CPU, yielding a speedup.</source>
          <target state="translated">ジャストインタイム（JIT）コンパイルは、何らかの形式の解釈済みプログラム評価をネイティブプログラムに変換し、実行時に実行するプロセスです。たとえば、任意のSQL式を評価できる汎用コードを使用して &lt;code&gt;WHERE a.col = 3&lt;/code&gt; ような特定のSQL述語を評価する代わりに、その式に固有で関数によってネイティブに実行できる関数を生成できます。 CPU、スピードアップをもたらします。</target>
        </trans-unit>
        <trans-unit id="7af7e7edb636e51ba6b7f08c539611e4a0057634" translate="yes" xml:space="preserve">
          <source>Just-in-Time Compilation (JIT)</source>
          <target state="translated">ジャストインタイムコンパイル(JIT)</target>
        </trans-unit>
        <trans-unit id="299af5e109b0aae56134447e7dc2dcce5de37f34" translate="yes" xml:space="preserve">
          <source>Just-in-Time compilation</source>
          <target state="translated">ジャストインタイムコンパイル</target>
        </trans-unit>
        <trans-unit id="ffa7300d92e16f73d505ed4698fdd4e962ca51c4" translate="yes" xml:space="preserve">
          <source>KAME kame/sys/crypto</source>
          <target state="translated">KAME kame/sys/crypto</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="8f29952f92109ac24c1d37762ea2beef09083c31" translate="yes" xml:space="preserve">
          <source>KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">KaiGai Kohei &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:kaigai@ak.jp.nec.com&quot;&gt;kaigai@ak.jp.nec.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cd084d348b2278c1d6044754c142d3183367365" translate="yes" xml:space="preserve">
          <source>Keep in mind that all aggregate functions are evaluated before evaluating any &amp;ldquo;scalar&amp;rdquo; expressions in the &lt;code&gt;HAVING&lt;/code&gt; clause or &lt;code&gt;SELECT&lt;/code&gt; list. This means that, for example, a &lt;code&gt;CASE&lt;/code&gt; expression cannot be used to skip evaluation of an aggregate function; see &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HAVING&lt;/code&gt; 句または &lt;code&gt;SELECT&lt;/code&gt; リスト内の「スカラー」式を評価する前に、すべての集約関数が評価されることに注意してください。つまり、たとえば、 &lt;code&gt;CASE&lt;/code&gt; 式を使用して集計関数の評価をスキップすることはできません。&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;セクション4.2.14を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a262b9c7138e1926e93240d562f76b55145fd596" translate="yes" xml:space="preserve">
          <source>Keep in mind that because &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; actually runs the query, any side-effects will happen as usual, even though whatever results the query might output are discarded in favor of printing the &lt;code&gt;EXPLAIN&lt;/code&gt; data. If you want to analyze a data-modifying query without changing your tables, you can roll the command back afterwards, for example:</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; が実際にクエリを実行するため、クエリが出力する可能性のある結果がすべて破棄されて &lt;code&gt;EXPLAIN&lt;/code&gt; データが出力される場合でも、副作用は通常どおり発生します。テーブルを変更せずにデータ変更クエリを分析する場合は、後でコマンドをロールバックできます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="66b96c146884aa3a6a00a301b320c6680d6f4464" translate="yes" xml:space="preserve">
          <source>Keep in mind that by default, a regular expression can match just part of a string. It's usually wise to use &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, as shown in the above example, to force the match to be to the entire system user name.</source>
          <target state="translated">デフォルトでは、正規表現は文字列の一部にのみ一致することに注意してください。上記の例に示すように、通常は &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; を使用して、システムのユーザー名全体との一致を強制するのが賢明です。</target>
        </trans-unit>
        <trans-unit id="c42b9dd519f94f2582e4a71f3f708e12c5a9653d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is important to specify the configuration name explicitly when creating &lt;code&gt;tsvector&lt;/code&gt; values inside triggers, so that the column's contents will not be affected by changes to &lt;code&gt;default_text_search_config&lt;/code&gt;. Failure to do this is likely to lead to problems such as search results changing after a dump and reload.</source>
          <target state="translated">トリガー内に &lt;code&gt;tsvector&lt;/code&gt; 値を作成するときは、構成名を明示的に指定して、列の内容が &lt;code&gt;default_text_search_config&lt;/code&gt; への変更の影響を受けないようにすることが重要です。これを怠ると、ダンプとリロード後に検索結果が変わるなどの問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f3ea22672b214f2b49222df5e8cffc5ea2a095eb" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal.</source>
          <target state="translated">部分的なインデックスを設定するということは、少なくとも問い合わせプランナが知っていることと同じくらいのことを知っていることを意味します。この知識を身につけるには、PostgreSQLのインデックスがどのように動作するかについての経験と理解が必要です。ほとんどの場合、通常のインデックスよりも部分インデックスの方が有利なことはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="3bf0ca5e99386c2632aea1fa222371e26d7ffb9e" translate="yes" xml:space="preserve">
          <source>Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX4&quot;&gt;Example 11.4&lt;/a&gt;.</source>
          <target state="translated">Keep in mind that setting up a partial index indicates that you know at least as much as the query planner knows, in particular you know when an index might be profitable. Forming this knowledge requires experience and understanding of how indexes in PostgreSQL work. In most cases, the advantage of a partial index over a regular index will be minimal. There are cases where they are quite counterproductive, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX4&quot;&gt;Example 11.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ef88fc4a4ab28c6433ccdb43fa109f84e6bdf441" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;hstore&lt;/code&gt; text format, when used for input, applies &lt;em&gt;before&lt;/em&gt; any required quoting or escaping. If you are passing an &lt;code&gt;hstore&lt;/code&gt; literal via a parameter, then no additional processing is needed. But if you're passing it as a quoted literal constant, then any single-quote characters and (depending on the setting of the &lt;code&gt;standard_conforming_strings&lt;/code&gt; configuration parameter) backslash characters need to be escaped correctly. See &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for more on the handling of string constants.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; テキスト形式は、入力に使用さ&lt;em&gt;れる&lt;/em&gt;場合、必要な引用やエスケープの&lt;em&gt;前&lt;/em&gt;に適用されることに注意してください。パラメーターを介して &lt;code&gt;hstore&lt;/code&gt; リテラルを渡す場合、追加の処理は必要ありません。ただし、引用符で囲まれたリテラル定数として渡す場合は、単一引用符文字と（ &lt;code&gt;standard_conforming_strings&lt;/code&gt; 構成パラメーターの設定に応じて）バックスラッシュ文字を正しくエスケープする必要があります。文字列定数の処理の詳細については、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;セクション4.1.2.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3f96958d65d9c021639ce27dbbdb3f614f469552" translate="yes" xml:space="preserve">
          <source>Keep in mind that the delay parameters are compared to the elapsed time since the WAL data was received by the standby server. Thus, the grace period allowed to any one query on the standby is never more than the delay parameter, and could be considerably less if the standby has already fallen behind as a result of waiting for previous queries to complete, or as a result of being unable to keep up with a heavy update load.</source>
          <target state="translated">遅延パラメータは、スタンバイサーバがWALデータを受信してからの経過時間と比較されることに注意してください。したがって、スタンバイ上の1つのクエリに許可される猶予期間は、遅延パラメータを超えることはなく、前のクエリが完了するのを待った結果、スタンバイがすでに遅れている場合や、重い更新負荷に追いつけなくなった結果、大幅に短くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="281e2d1f4654cd490bed6ab58e757285785a6b63" translate="yes" xml:space="preserve">
          <source>Keep in mind that the pattern argument of &lt;code&gt;like_regex&lt;/code&gt; is a JSON path string literal, written according to the rules given in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match strings that contain only digits:</source>
          <target state="translated">&lt;code&gt;like_regex&lt;/code&gt; のパターン引数は、&lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;セクション8.14.6&lt;/a&gt;に記載されているルールに従って記述されたJSONパス文字列リテラルであることを覚えておいてください。これは特に、正規表現で使用したいバックスラッシュは二重にする必要があることを意味します。たとえば、数字のみを含む文字列を照合するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="752b636fa6947f13347177c43e220a338c0e1d06" translate="yes" xml:space="preserve">
          <source>Keep in mind that the statement is actually executed when the &lt;code&gt;ANALYZE&lt;/code&gt; option is used. Although &lt;code&gt;EXPLAIN&lt;/code&gt; will discard any output that a &lt;code&gt;SELECT&lt;/code&gt; would return, other side effects of the statement will happen as usual. If you wish to use &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;EXECUTE&lt;/code&gt; statement without letting the command affect your data, use this approach:</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; オプションを使用すると、ステートメントが実際に実行されることに注意してください。が &lt;code&gt;EXPLAIN&lt;/code&gt; ことを任意の出力破棄します &lt;code&gt;SELECT&lt;/code&gt; が戻ってくると、文の他の副作用は通常通り発生します。コマンドがデータに影響を与えずに、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 、または &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントで &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; を使用する場合は、次のアプローチを使用します。</target>
        </trans-unit>
        <trans-unit id="1a83b7d50233b6c01f2847bb1d523d1444438ed5" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, any user can issue arbitrary queries under the identity of any user not electing to protect itself individually. This pattern is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">デフォルトのままにします。すべてのユーザが暗黙のうちに公開スキーマにアクセスします。これにより、スキーマが全く利用できない状況をシミュレートし、スキーマを認識しない世界からのスムーズな移行を実現します。しかし、任意のユーザーは、自分自身を個別に保護することを選択していないユーザーのアイデンティティの下で、任意のクエリを発行することができます。このパターンは、データベースが単一のユーザまたは数人の相互に信頼できるユーザを持っている場合にのみ許容されます。</target>
        </trans-unit>
        <trans-unit id="7b02debd129668317e39732d6dfb75d3b401f787" translate="yes" xml:space="preserve">
          <source>Keep the default. All users access the public schema implicitly. This simulates the situation where schemas are not available at all, giving a smooth transition from the non-schema-aware world. However, this is never a secure pattern. It is acceptable only when the database has a single user or a few mutually-trusting users.</source>
          <target state="translated">デフォルトのままにします。すべてのユーザが暗黙のうちに公開スキーマにアクセスします。これはスキーマが全く利用できない状況をシミュレートし、スキーマを認識していない世界からのスムーズな移行を可能にします。しかし、これは決して安全なパターンではありません。これは、データベースに単一のユーザがいるか、数人の相互に信頼できるユーザがいる場合にのみ許容されます。</target>
        </trans-unit>
        <trans-unit id="01c357ee3905e2cb6c0488939e3efd4649d18496" translate="yes" xml:space="preserve">
          <source>Keep the partitioning constraints simple, else the planner may not be able to prove that child tables might not need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, because only B-tree-indexable column(s) are allowed in the partition key.</source>
          <target state="translated">パーティショニングの制約を単純にしておかないと、プランナは子テーブルを訪問する必要がないかもしれないことを証明できないかもしれません。リスト・パーティショニングには単純な等質条件を使用し、範囲パーティショニングには単純な範囲テストを使用してください。経験則として、パーティショニング制約は、B-treeインデックス可能な演算子を使用した定数とパーティショニング列の比較のみを含むべきです。</target>
        </trans-unit>
        <trans-unit id="e2032a298b60ea58db844215a572d895ea523039" translate="yes" xml:space="preserve">
          <source>Kernels can also have system-wide limits on some resources.</source>
          <target state="translated">カーネルは、いくつかのリソースに対してシステム全体の制限を設けることもできます。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="59dfe7e6cfc40d95e215dd77804938b17f6c9f40" translate="yes" xml:space="preserve">
          <source>Key Word</source>
          <target state="translated">キーワード</target>
        </trans-unit>
        <trans-unit id="8e27223f630d5f11e0e66ca4d82327af33bd02f7" translate="yes" xml:space="preserve">
          <source>Key value of the row to start at</source>
          <target state="translated">開始する行のキー値</target>
        </trans-unit>
        <trans-unit id="fa701570481252ff476a0ecf4e2d51ece76ebca1" translate="yes" xml:space="preserve">
          <source>Key words and unquoted identifiers are case insensitive. Therefore:</source>
          <target state="translated">キーワードや引用符で囲まれていない識別子は大文字小文字を区別しません。したがって</target>
        </trans-unit>
        <trans-unit id="dec66c5bf0f7fe4cc038ac871def8eb1ac31c146" translate="yes" xml:space="preserve">
          <source>Korean</source>
          <target state="translated">Korean</target>
        </trans-unit>
        <trans-unit id="2ceaa9727ea6aa546bde8ab43842a8c79efd8f8d" translate="yes" xml:space="preserve">
          <source>Korean (Hangul)</source>
          <target state="translated">ハングル</target>
        </trans-unit>
        <trans-unit id="2bfe4366aec039158c13cdff560c53552a6ab2f8" translate="yes" xml:space="preserve">
          <source>LATIN1 with Euro and accents</source>
          <target state="translated">ユーロとアクセントのあるLATIN1</target>
        </trans-unit>
        <trans-unit id="a3f57123a6c2ff10f831d7d1652f96a64aa8ede6" translate="yes" xml:space="preserve">
          <source>LC_COLLATE for this database</source>
          <target state="translated">このデータベースのLC_COLLATE</target>
        </trans-unit>
        <trans-unit id="ccd2341e80cefe881c6b471888b83c35d3eedb65" translate="yes" xml:space="preserve">
          <source>LC_CTYPE for this database</source>
          <target state="translated">このデータベースの LC_CTYPE</target>
        </trans-unit>
        <trans-unit id="d8343c683ae1584c96390fa627005bc1bb0719cd" translate="yes" xml:space="preserve">
          <source>LDAP</source>
          <target state="translated">LDAP</target>
        </trans-unit>
        <trans-unit id="d11fef55a0f4f7f77f5a743808a9e2af4cfab644" translate="yes" xml:space="preserve">
          <source>LDAP Authentication</source>
          <target state="translated">LDAP認証</target>
        </trans-unit>
        <trans-unit id="3af0c4862ddb95641f4519deb20c9bd92b5a696b" translate="yes" xml:space="preserve">
          <source>LDAP URLs are currently only supported with OpenLDAP, not on Windows.</source>
          <target state="translated">LDAP URL は現在のところ OpenLDAP でのみサポートされており、Windows ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="a78f006babbca44fb715e5663d9cdd5f718dd110" translate="yes" xml:space="preserve">
          <source>LDAP authentication can operate in two modes. In the first mode, which we will call the simple bind mode, the server will bind to the distinguished name constructed as &lt;code&gt;prefix&lt;/code&gt;&lt;code&gt;username&lt;/code&gt;&lt;code&gt;suffix&lt;/code&gt;. Typically, the &lt;code&gt;prefix&lt;/code&gt; parameter is used to specify &lt;code&gt;cn=&lt;/code&gt;, or &lt;code&gt;DOMAIN&lt;/code&gt;&lt;code&gt;\&lt;/code&gt; in an Active Directory environment. &lt;code&gt;suffix&lt;/code&gt; is used to specify the remaining part of the DN in a non-Active Directory environment.</source>
          <target state="translated">LDAP認証は2つのモードで動作できます。シンプルバインドモードと呼ばれる最初のモードでは、サーバーは、 &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;username&lt;/code&gt; &lt;code&gt;suffix&lt;/code&gt; として構築された識別名にバインドします。通常、 &lt;code&gt;prefix&lt;/code&gt; パラメータは、Active Directory環境で &lt;code&gt;cn=&lt;/code&gt; または &lt;code&gt;DOMAIN&lt;/code&gt; &lt;code&gt;\&lt;/code&gt; を指定するために使用されます。 &lt;code&gt;suffix&lt;/code&gt; は、非Active Directory環境でDNの残りの部分を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="9bd1b0f9c2859218ce1180337a2bd66b96113b2f" translate="yes" xml:space="preserve">
          <source>LIMIT and OFFSET</source>
          <target state="translated">リミットとオフセット</target>
        </trans-unit>
        <trans-unit id="9c6023564f6507b3ea5cad8e472da23961b9afbb" translate="yes" xml:space="preserve">
          <source>LISTEN</source>
          <target state="translated">LISTEN</target>
        </trans-unit>
        <trans-unit id="9814f182fea16d601141a37a9089918cd74f5452" translate="yes" xml:space="preserve">
          <source>LISTEN &amp;mdash; listen for a notification</source>
          <target state="translated">LISTEN &amp;mdash;通知を聞く</target>
        </trans-unit>
        <trans-unit id="8d0c622ff5ca1933ba98627381a4a7d1db679d31" translate="yes" xml:space="preserve">
          <source>LLVM has support for optimizing generated code. Some of the optimizations are cheap enough to be performed whenever JIT is used, while others are only beneficial for longer-running queries. See &lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https://llvm.org/docs/Passes.html#transform-passes&lt;/a&gt; for more details about optimizations.</source>
          <target state="translated">LLVMは、生成されたコードの最適化をサポートしています。最適化の中には、JITを使用するたびに実行できるほど安価なものもあれば、実行時間の長いクエリにのみ有益なものもあります。最適化の詳細については、&lt;a href=&quot;https://llvm.org/docs/Passes.html#transform-passes&quot;&gt;https：//llvm.org/docs/Passes.html#transform-passes&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="ca2a082afa739ad45f7209a3186244665643f398" translate="yes" xml:space="preserve">
          <source>LOAD &amp;mdash; load a shared library file</source>
          <target state="translated">LOAD &amp;mdash;共有ライブラリファイルをロードする</target>
        </trans-unit>
        <trans-unit id="c37eb4cb935a6017aaaaaab327837c7d9bbbc004" translate="yes" xml:space="preserve">
          <source>LOCK</source>
          <target state="translated">LOCK</target>
        </trans-unit>
        <trans-unit id="92d4fa824b1bf5ae650f5b90867eff13a3a5fe0a" translate="yes" xml:space="preserve">
          <source>LOCK &amp;mdash; lock a table</source>
          <target state="translated">LOCK &amp;mdash;テーブルをロックする</target>
        </trans-unit>
        <trans-unit id="6b4bea52cbee20f8507b76217f199114a117089e" translate="yes" xml:space="preserve">
          <source>LSN</source>
          <target state="translated">LSN</target>
        </trans-unit>
        <trans-unit id="d1fca76fb082d22a2d8e514d1b3ce5e3ce9aa851" translate="yes" xml:space="preserve">
          <source>LSN: next byte after last byte of WAL record for last change to this page</source>
          <target state="translated">LSN:このページへの最後の変更のためのWALレコードの最後のバイトの次のバイト</target>
        </trans-unit>
        <trans-unit id="f7d6ac021994cd293b3c94c2f6248d32ae9579b5" translate="yes" xml:space="preserve">
          <source>Lag times work automatically for physical replication. Logical decoding plugins may optionally emit tracking messages; if they do not, the tracking mechanism will simply display NULL lag.</source>
          <target state="translated">遅延時間は物理的なレプリケーションでは自動的に動作します。論理デコードプラグインはオプションでトラッキングメッセージを出力することができますが、出力しない場合、トラッキングメカニズムは単にNULLラグを表示します。</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="5e9465d239944a0fa40232e75aff84b43ba97385" translate="yes" xml:space="preserve">
          <source>Language of messages</source>
          <target state="translated">メッセージの言語</target>
        </trans-unit>
        <trans-unit id="ce146ba97ccf4a9eb00c4f7b7284970bf1503949" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">ラージオブジェクト（&lt;a href=&quot;https://www.postgresql.org/docs/12/largeobjects.html&quot;&gt;第34章を&lt;/a&gt;参照）は複製されません。通常のテーブルにデータを保存する以外に、その回避策はありません。</target>
        </trans-unit>
        <trans-unit id="f6b0e78c3e5e8149e57bd763e4fa479405b51a85" translate="yes" xml:space="preserve">
          <source>Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/13/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</source>
          <target state="translated">Large objects (see &lt;a href=&quot;https://www.postgresql.org/docs/13/largeobjects.html&quot;&gt;Chapter 34&lt;/a&gt;) are not replicated. There is no workaround for that, other than storing data in normal tables.</target>
        </trans-unit>
        <trans-unit id="a24b3c46d4ed7dfe7397ec67ef490f12c7f2d62a" translate="yes" xml:space="preserve">
          <source>Last system OID in the database; useful particularly to pg_dump</source>
          <target state="translated">データベース内の最後のシステムOID。</target>
        </trans-unit>
        <trans-unit id="d8a8330f47a1d2121f7de4d246b07c539d85b887" translate="yes" xml:space="preserve">
          <source>Last time at which this table was analyzed by the autovacuum daemon</source>
          <target state="translated">このテーブルが自動バキュームデーモンによって解析された最後の時刻</target>
        </trans-unit>
        <trans-unit id="b5daedfbaeb26dce099e49150d7deba8ed7dd63c" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually analyzed</source>
          <target state="translated">このテーブルが手動で分析された最後の時間</target>
        </trans-unit>
        <trans-unit id="d21dc8edf16ccb5721e0bc05e599292ce8cd64c2" translate="yes" xml:space="preserve">
          <source>Last time at which this table was manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">このテーブルが手動でバキュームされた最後の時間（ &lt;code&gt;VACUUM FULL&lt;/code&gt; はカウントされません）</target>
        </trans-unit>
        <trans-unit id="32d602dc6c753beae99504e742b35637bae47172" translate="yes" xml:space="preserve">
          <source>Last time at which this table was vacuumed by the autovacuum daemon</source>
          <target state="translated">このテーブルが自動バキュームデーモンによってバキュームされた最後の時間</target>
        </trans-unit>
        <trans-unit id="a6160372ad225c352ec7ffd4f36cad1f43f752fb" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and flushed to disk, the initial value of this field being the first log location used when WAL receiver is started</source>
          <target state="translated">最後に受信し、ディスクにフラッシュされた書込み先のログの位置で、このフィールドの初期値は WAL 受信機の起動時に最初に使用されるログの位置となる。</target>
        </trans-unit>
        <trans-unit id="1c2624daf23aae1afae71faf67ded93dc5500054" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location already received and written to disk, but not flushed. This should not be used for data integrity checks.</source>
          <target state="translated">最後の書き込み優先ログの場所は、すでに受信してディスクに書き込まれていますが、フラッシュされていません。これはデータの整合性チェックには使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="6dd26aafa1fbdf96a846556c081c9e292557ed50" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location flushed to disk by this standby server</source>
          <target state="translated">このスタンバイ・サーバがディスクにフラッシュした最後の書き込み優先ログの場所</target>
        </trans-unit>
        <trans-unit id="3196ac97aabe6b93efdbd9d951f27185a4510ea9" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location received, the initial value of this field being 0</source>
          <target state="translated">最後に受信した書込み先のログの位置、このフィールドの初期値は0です。</target>
        </trans-unit>
        <trans-unit id="7fce43ad04e1c6ea844b5017a38c520afa802611" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location replayed into the database on this standby server</source>
          <target state="translated">最後に書き込まれたログの場所を、このスタンバイ・サーバのデータベースに再生します。</target>
        </trans-unit>
        <trans-unit id="0d3835b7f40d0e6e66b1e74e7de916b14d4f990d" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location reported to origin WAL sender</source>
          <target state="translated">送信元のWAL送信者に報告された最後の書込み先ログの場所</target>
        </trans-unit>
        <trans-unit id="ac1ae56d16c8b53cb449a2ee572fbfc684cbf5dd" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location sent on this connection</source>
          <target state="translated">この接続で送信された最後の書込み先ログの場所</target>
        </trans-unit>
        <trans-unit id="bafcffd5bbf934c91f7d04975d6317a745ba4820" translate="yes" xml:space="preserve">
          <source>Last write-ahead log location written to disk by this standby server</source>
          <target state="translated">この待機サーバがディスクに書き込んだ最後の書込み先ログの場所</target>
        </trans-unit>
        <trans-unit id="ba538f112903a51c4fdd1a1494e1875649a225bb" translate="yes" xml:space="preserve">
          <source>Latin/Arabic</source>
          <target state="translated">Latin/Arabic</target>
        </trans-unit>
        <trans-unit id="fd84929c694afd8b1b6d7503f4f8e1b23aed9285" translate="yes" xml:space="preserve">
          <source>Latin/Cyrillic</source>
          <target state="translated">Latin/Cyrillic</target>
        </trans-unit>
        <trans-unit id="e688538b3f17f5cc30931971a729f9f8fe4c1bdd" translate="yes" xml:space="preserve">
          <source>Latin/Greek</source>
          <target state="translated">Latin/Greek</target>
        </trans-unit>
        <trans-unit id="daa3f6da7a3a4e4229771dc7d3d5e346a4582850" translate="yes" xml:space="preserve">
          <source>Latin/Hebrew</source>
          <target state="translated">Latin/Hebrew</target>
        </trans-unit>
        <trans-unit id="d494f73e6e88daa7f95e93345a91fc4c8dc4fb69" translate="yes" xml:space="preserve">
          <source>Launch the main autoprewarm worker. This will normally happen automatically, but is useful if automatic prewarm was not configured at server startup time and you wish to start up the worker at a later time.</source>
          <target state="translated">メインのautoprewarmワーカーを起動します。これは通常は自動的に行われますが、サーバー起動時に自動プリウォームが設定されておらず、後でワーカーを起動したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="2c4136854685f9259aab343bbd1cc7a50348e3a5" translate="yes" xml:space="preserve">
          <source>Leaf page fragmentation</source>
          <target state="translated">リーフページの断片化</target>
        </trans-unit>
        <trans-unit id="5f877225069b04b69ebc49ed1c8ffc9db5e722b5" translate="yes" xml:space="preserve">
          <source>Leaf tuples of an SP-GiST tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</source>
          <target state="translated">SP-GISTツリーのリーフタプルには、インデックス化された列と同じデータ型の値が含まれます。ルートレベルのリーフタプルは常に元のインデックス付きデータ値を含みますが、下位レベルのリーフタプルはサフィックスのような圧縮された表現のみを含む場合があります。その場合、演算子クラスのサポート関数は、リーフレベルに到達するために渡される内部タプルから蓄積された情報を使用して元の値を再構築することができなければなりません。</target>
        </trans-unit>
        <trans-unit id="5daa8198764e4eb159c9ea5a3939ed7ca08e926f" translate="yes" xml:space="preserve">
          <source>Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns &lt;code&gt;0&lt;/code&gt; if either input is zero; available for &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">Least common multiple (the smallest strictly positive number that is an integral multiple of both inputs); returns &lt;code&gt;0&lt;/code&gt; if either input is zero; available for &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9299c2aba089dc4590aa8606b111db26dae4554a" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of associated operator</source>
          <target state="translated">関連演算子の左入力データ型</target>
        </trans-unit>
        <trans-unit id="ed906ae901de1e3195028f0570c5ad60b2810880" translate="yes" xml:space="preserve">
          <source>Left-hand input data type of operator</source>
          <target state="translated">演算子の左入力データ型</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="d8b851cee953f8d81c31ec69468e0ec20c2888c1" translate="yes" xml:space="preserve">
          <source>Length of aggregation interval (in seconds). May be used only with &lt;code&gt;-l&lt;/code&gt; option. With this option, the log contains per-interval summary data, as described below.</source>
          <target state="translated">集約間隔の長さ（秒単位）。 &lt;code&gt;-l&lt;/code&gt; オプションとのみ使用できます。このオプションを使用すると、以下に説明するように、ログには間隔ごとの要約データが含まれます。</target>
        </trans-unit>
        <trans-unit id="af6b0587a83fcd51886d616d3a32f3398d01980f" translate="yes" xml:space="preserve">
          <source>Length of binary string</source>
          <target state="translated">2進数文字列の長さ</target>
        </trans-unit>
        <trans-unit id="ccfe4a6f325c29c147887556a7714e5ddcdfe308" translate="yes" xml:space="preserve">
          <source>Length of each signature (index entry) in bits. It is rounded up to the nearest multiple of &lt;code&gt;16&lt;/code&gt;. The default is &lt;code&gt;80&lt;/code&gt; bits and the maximum is &lt;code&gt;4096&lt;/code&gt;.</source>
          <target state="translated">各署名（インデックスエントリ）の長さ（ビット単位）。最も近い &lt;code&gt;16&lt;/code&gt; の倍数に切り上げられます。デフォルトは &lt;code&gt;80&lt;/code&gt; ビットで、最大は &lt;code&gt;4096&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="12d4a8b76c20bac65c1a5a078f5f7a8e333266b4" translate="yes" xml:space="preserve">
          <source>Length or circumference</source>
          <target state="translated">長さまたは周囲</target>
        </trans-unit>
        <trans-unit id="9d6ed670f3c04a36b7689b66ca5b25c4d52af652" translate="yes" xml:space="preserve">
          <source>Less likely to cause problems is the minimum size for shared memory segments (&lt;code&gt;SHMMIN&lt;/code&gt;), which should be at most approximately 32 bytes for PostgreSQL (it is usually just 1). The maximum number of segments system-wide (&lt;code&gt;SHMMNI&lt;/code&gt;) or per-process (&lt;code&gt;SHMSEG&lt;/code&gt;) are unlikely to cause a problem unless your system has them set to zero.</source>
          <target state="translated">問題が発生する可能性が低いのは、共有メモリセグメントの最小サイズ（ &lt;code&gt;SHMMIN&lt;/code&gt; ）です。これは、PostgreSQLの場合は最大で約32バイト（通常は1）です。システム全体でセグメントの最大数（ &lt;code&gt;SHMMNI&lt;/code&gt; ）またはプロセスごと（ &lt;code&gt;SHMSEG&lt;/code&gt; ）の最大数は、システムでゼロに設定されていない限り、問題を引き起こす可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">未満</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">以下</target>
        </trans-unit>
        <trans-unit id="e88e84c79a2349d1ad4055f51a25c693dabaf88a" translate="yes" xml:space="preserve">
          <source>Less-than comparison</source>
          <target state="translated">比較にならない</target>
        </trans-unit>
        <trans-unit id="1f01a7dce204970734b2b2a327ee36987199e47f" translate="yes" xml:space="preserve">
          <source>Less-than operator</source>
          <target state="translated">オペレーター未満</target>
        </trans-unit>
        <trans-unit id="9f4307f8c5a910003114771823ca3aa6f1218371" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to comparison</source>
          <target state="translated">対等かどうかの比較</target>
        </trans-unit>
        <trans-unit id="4576a6bc031e504cf481eb0d13f776e9d54832eb" translate="yes" xml:space="preserve">
          <source>Less-than-or-equal-to operator</source>
          <target state="translated">劣等演算子</target>
        </trans-unit>
        <trans-unit id="0ab7950f1f29b3334f76dd244ef5a7ba783b1b7f" translate="yes" xml:space="preserve">
          <source>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table:</source>
          <target state="translated">また、これらの商品の注文を保存するテーブルがあるとします。注文テーブルには、実際に存在する製品の注文のみが含まれていることを確認したいとします。そこで、商品テーブルを参照する注文テーブルに外部キー制約を定義します。</target>
        </trans-unit>
        <trans-unit id="4bb0a1a761abe6883839cec3e71ca469d8a65b69" translate="yes" xml:space="preserve">
          <source>Let's assume you have filled the table with data and want to take a look at it:</source>
          <target state="translated">テーブルにデータを埋めたと仮定して、それを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6bb447a9045c7cc0d5a93bdb00100d8f10c020e2" translate="yes" xml:space="preserve">
          <source>Let's consider a real-life astronomical example. We'll expand query &lt;code&gt;supernovae&lt;/code&gt; using table-driven rewriting rules:</source>
          <target state="translated">実際の天文学の例を考えてみましょう。テーブル駆動型の書き換えルールを使用して、クエリ &lt;code&gt;supernovae&lt;/code&gt; を拡張します。</target>
        </trans-unit>
        <trans-unit id="3450ae90635f5fd80bf01d11b0586d3e5b336518" translate="yes" xml:space="preserve">
          <source>Let's create two tables: A table &lt;code&gt;cities&lt;/code&gt; and a table &lt;code&gt;capitals&lt;/code&gt;. Naturally, capitals are also cities, so you want some way to show the capitals implicitly when you list all cities. If you're really clever you might invent some scheme like this:</source>
          <target state="translated">2つのテーブルを作成してみましょう。テーブルの &lt;code&gt;cities&lt;/code&gt; とテーブルの &lt;code&gt;capitals&lt;/code&gt; です。当然、首都は都市でもあるため、すべての都市をリストするときに暗黙的に首都を表示する方法が必要です。あなたが本当に賢いなら、あなたはこのようないくつかのスキームを発明するかもしれません：</target>
        </trans-unit>
        <trans-unit id="002106d5520b7ff0cea15ef411a279196063cbfa" translate="yes" xml:space="preserve">
          <source>Let's look at that command in detail. First is the key word &lt;code&gt;UPDATE&lt;/code&gt; followed by the table name. As usual, the table name can be schema-qualified, otherwise it is looked up in the path. Next is the key word &lt;code&gt;SET&lt;/code&gt; followed by the column name, an equal sign, and the new column value. The new column value can be any scalar expression, not just a constant. For example, if you want to raise the price of all products by 10% you could use:</source>
          <target state="translated">そのコマンドを詳しく見てみましょう。最初はキーワード &lt;code&gt;UPDATE&lt;/code&gt; で、その後にテーブル名が続きます。いつものように、テーブル名はスキーマで修飾できますが、そうでない場合はパスで検索されます。次はキーワード &lt;code&gt;SET&lt;/code&gt; で、その後に列名、等号、新しい列値が続きます。新しい列の値には、定数だけでなく、任意のスカラー式を使用できます。たとえば、すべての製品の価格を10％引き上げたい場合は、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="66b99b3611a0c2fdc7f95a1799fb3492cd67f4e6" translate="yes" xml:space="preserve">
          <source>Let's look at the query from &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt; again, but this time with a MCV list created on the same set of columns (be sure to drop the functional dependencies, to make sure the planner uses the newly created statistics).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;セクション70.2.1&lt;/a&gt;のクエリをもう一度見てみましょう。ただし、今回は同じ列のセットに作成されたMCVリストを使用します（機能の依存関係を削除して、プランナが新しく作成された統計を使用していることを確認してください）。</target>
        </trans-unit>
        <trans-unit id="1612ac24f2069dd66f65838fc7336fa0b28c41cb" translate="yes" xml:space="preserve">
          <source>Let's move on to an example with a range condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句に範囲条件を含む例に進みましょう。</target>
        </trans-unit>
        <trans-unit id="e33f516fc6df811ac7dea3c6a71c77e25ecd5519" translate="yes" xml:space="preserve">
          <source>Let's start with a very simple query:</source>
          <target state="translated">まずはとても簡単なクエリから始めてみましょう。</target>
        </trans-unit>
        <trans-unit id="944a02000a7cd912b7786576975c692505293e37" translate="yes" xml:space="preserve">
          <source>Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the &lt;code&gt;capitals&lt;/code&gt; table so that it inherits from &lt;code&gt;cities&lt;/code&gt;:</source>
          <target state="translated">例から始めましょう。都市のデータモデルを構築しようとしていると仮定します。各州には多くの都市がありますが、首都は1つだけです。特定の州の首都をすばやく検索できるようにしたいと考えています。これは、2つのテーブルを作成することで実行できます。1つは州都、もう1つは首都ではない都市用です。しかし、都市であるかどうかに関係なく、都市に関するデータを要求したい場合はどうなりますか？継承機能は、この問題の解決に役立ちます。 &lt;code&gt;cities&lt;/code&gt; から継承するように、 &lt;code&gt;capitals&lt;/code&gt; 表を定義します。</target>
        </trans-unit>
        <trans-unit id="8936905c2cce98cf23701c4834f7f639d90f7b6d" translate="yes" xml:space="preserve">
          <source>Let's try joining two tables, using the columns we have been discussing:</source>
          <target state="translated">これまで説明してきたカラムを使って、2つのテーブルを結合してみましょう。</target>
        </trans-unit>
        <trans-unit id="fc56b91f6d327225a18362ab13575f562f30c691" translate="yes" xml:space="preserve">
          <source>Lexemes that have positions can further be labeled with a &lt;em&gt;weight&lt;/em&gt;, which can be &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, or &lt;code&gt;D&lt;/code&gt;. &lt;code&gt;D&lt;/code&gt; is the default and hence is not shown on output:</source>
          <target state="translated">位置を持つ語彙素は、さらに &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、または &lt;code&gt;D&lt;/code&gt; の&lt;em&gt;重み&lt;/em&gt;でラベル付けできます。 &lt;code&gt;D&lt;/code&gt; がデフォルトであるため、出力には表示されません。</target>
        </trans-unit>
        <trans-unit id="4de4e82a8494674ff2932d2f3ecffa7e7aa91c37" translate="yes" xml:space="preserve">
          <source>Lexical Structure</source>
          <target state="translated">語彙構造</target>
        </trans-unit>
        <trans-unit id="98b17490298c1db6b1bff4b00e76136ec7bbbbbf" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Comments</source>
          <target state="translated">語彙構造。コメント</target>
        </trans-unit>
        <trans-unit id="fba7d54766b9a41f8c00c3be52c20790571085f9" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Constants</source>
          <target state="translated">字句構造。定数</target>
        </trans-unit>
        <trans-unit id="0eb1a63288ed8a4eea2395df1dd364cf859d54a6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Identifiers and Key Words</source>
          <target state="translated">語彙構造。識別子とキーワード</target>
        </trans-unit>
        <trans-unit id="195802f293c2f60e26c9b9d1cca1271d02591bfe" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operator Precedence</source>
          <target state="translated">語彙構造。オペレータの優先順位</target>
        </trans-unit>
        <trans-unit id="f3025dccc066fa7289f006eb8ae5b580e53548c6" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Operators</source>
          <target state="translated">字句構造。オペレータ</target>
        </trans-unit>
        <trans-unit id="820a42a37bd5d5e7546df4a06a9fad64993321ea" translate="yes" xml:space="preserve">
          <source>Lexical Structure: Special Characters</source>
          <target state="translated">語彙構造。特殊文字</target>
        </trans-unit>
        <trans-unit id="aa1c47b9be01b70fcc0a9ce52958782af56ce40a" translate="yes" xml:space="preserve">
          <source>Library API</source>
          <target state="translated">ライブラリAPI</target>
        </trans-unit>
        <trans-unit id="bc61796bcb48c2cc0906e22b19a382e56ac7241c" translate="yes" xml:space="preserve">
          <source>Licensed under the PostgreSQL License.</source>
          <target state="translated">PostgreSQLライセンスでライセンスされています。</target>
        </trans-unit>
        <trans-unit id="70e96422ed9935802e683689abf5ed30f10484c2" translate="yes" xml:space="preserve">
          <source>Lightweight Directory Access Protocol</source>
          <target state="translated">ライトウェイトディレクトリアクセスプロトコル</target>
        </trans-unit>
        <trans-unit id="706c7257274a3b242ba385122feaad6c90232d40" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;%/&lt;/code&gt;, but the output is &lt;code&gt;~&lt;/code&gt; (tilde) if the database is your default database.</source>
          <target state="translated">&lt;code&gt;%/&lt;/code&gt; に似ていますが、データベースがデフォルトデータベースの場合、出力は &lt;code&gt;~&lt;/code&gt; （チルド）です。</target>
        </trans-unit>
        <trans-unit id="01c5b4c11e3825cd811354418a5a2a2256d5f14a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--locale&lt;/code&gt;, but only sets the locale in the specified category.</source>
          <target state="translated">同様 &lt;code&gt;--locale&lt;/code&gt; が、唯一の指定されたカテゴリ内のロケールを設定します。</target>
        </trans-unit>
        <trans-unit id="592d71b5f1a2fc02390509f112e2932ece3b2ce3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.**&lt;/code&gt;, but selects only the specified levels of the JSON hierarchy. Nesting levels are specified as integers. Level zero corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</source>
          <target state="translated">Like &lt;code&gt;.**&lt;/code&gt; , but selects only the specified levels of the JSON hierarchy. Nesting levels are specified as integers. Level zero corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</target>
        </trans-unit>
        <trans-unit id="7bcb9cac0fa5cedaf3e22ad3fe9503230b5e0b4b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;LIKE&lt;/code&gt;, the &lt;code&gt;SIMILAR TO&lt;/code&gt; operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like &lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt; uses &lt;code&gt;_&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; as wildcard characters denoting any single character and any string, respectively (these are comparable to &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;.*&lt;/code&gt; in POSIX regular expressions).</source>
          <target state="translated">&lt;code&gt;LIKE&lt;/code&gt; と同様に、 &lt;code&gt;SIMILAR TO&lt;/code&gt; 演算子は、そのパターンが文字列全体と一致する場合にのみ成功します。これは、パターンが文字列の任意の部分に一致することができる一般的な正規表現の動作とは異なります。また、 &lt;code&gt;LIKE&lt;/code&gt; と同様に、 &lt;code&gt;SIMILAR TO&lt;/code&gt; は &lt;code&gt;_&lt;/code&gt; および &lt;code&gt;%&lt;/code&gt; をワイルドカード文字として使用し、それぞれ単一の文字と文字列を示します（これらはPOSIX正規表現の &lt;code&gt;.&lt;/code&gt; および &lt;code&gt;.*&lt;/code&gt; に相当します）。</target>
        </trans-unit>
        <trans-unit id="85a2ab4c0cd63cc27de88b6c0b7fbce75e30b6bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;aggfinalmodify&lt;/code&gt;, but for the &lt;code&gt;aggmfinalfn&lt;/code&gt;</source>
          <target state="translated">同様 &lt;code&gt;aggfinalmodify&lt;/code&gt; 、しかしため &lt;code&gt;aggmfinalfn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059422d409e873d3ec537d586c30c482c509b6ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;penalty&lt;/code&gt;, the &lt;code&gt;picksplit&lt;/code&gt; function is crucial to good performance of the index. Designing suitable &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; implementations is where the challenge of implementing well-performing GiST indexes lies.</source>
          <target state="translated">&lt;code&gt;penalty&lt;/code&gt; と同様に、 &lt;code&gt;picksplit&lt;/code&gt; 関数はインデックスの良好なパフォーマンスに不可欠です。適切な &lt;code&gt;penalty&lt;/code&gt; と &lt;code&gt;picksplit&lt;/code&gt; 実装を設計することは、パフォーマンスの高いGiSTインデックスを実装するという課題があるところです。</target>
        </trans-unit>
        <trans-unit id="2af7b72fbf0a8ccd43a00ff740a0fef8b75c0395" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pg_statistic&lt;/code&gt;, &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; should not be readable by the public, since the contents might be considered sensitive. (Example: most common combinations of values in columns might be quite interesting.) &lt;a href=&quot;view-pg-stats-ext&quot;&gt;&lt;code&gt;pg_stats_ext&lt;/code&gt;&lt;/a&gt; is a publicly readable view on &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; (after joining with &lt;code&gt;pg_statistic_ext&lt;/code&gt;) that only exposes information about those tables and columns that are readable by the current user.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; と同様に、 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; は、内容が機密であると見なされる可能性があるため、一般公開されるべきではありません。（例：列の値の最も一般的な組み合わせは非常に興味深いかもしれません。）&lt;a href=&quot;view-pg-stats-ext&quot;&gt; &lt;code&gt;pg_stats_ext&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; のパブリックに読み取り可能なビューであり（ &lt;code&gt;pg_statistic_ext&lt;/code&gt; と結合した後）、現在のユーザーが読み取り可能なテーブルと列に関する情報のみを公開します。</target>
        </trans-unit>
        <trans-unit id="1e283f20748a53829b82b5760d76e1b1a5f034e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;plainto_tsquery&lt;/code&gt;, the &lt;code&gt;phraseto_tsquery&lt;/code&gt; function will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">&lt;code&gt;plainto_tsquery&lt;/code&gt; と同様に、 &lt;code&gt;phraseto_tsquery&lt;/code&gt; 関数は、入力の &lt;code&gt;tsquery&lt;/code&gt; 演算子、重みラベル、またはプレフィックス一致ラベルを認識しません。</target>
        </trans-unit>
        <trans-unit id="176fba135c7656c6b09a34f8083ee1cb69b4df0d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;code&gt;toptag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; と同様ですが、結果からtoptagが省略され &lt;code&gt;toptag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01344dcf6fdc7567e1ebfddcdc592af8624be340" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;em&gt;&lt;code&gt;toptag&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits &lt;em&gt; &lt;code&gt;toptag&lt;/code&gt; &lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="2a092e16f9fe5baae3ebd61fa16eca90ce0ed31e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; but result omits both tags.</source>
          <target state="translated">同様 &lt;code&gt;xpath_nodeset(document, query, toptag, itemtag)&lt;/code&gt; が、両方のタグを省略なります。</target>
        </trans-unit>
        <trans-unit id="79231c4789ce70fc6a3cc412988cea4a45cfbcbb" translate="yes" xml:space="preserve">
          <source>Like GiST and SP-GiST, GIN can support many different user-defined indexing strategies, and the particular operators with which a GIN index can be used vary depending on the indexing strategy. As an example, the standard distribution of PostgreSQL includes a GIN operator class for arrays, which supports indexed queries using these operators:</source>
          <target state="translated">GiSTやSP-GISTと同様に、GINは多くの異なるユーザ定義のインデックス戦略をサポートすることができ、GINインデックスが使用できる特定の演算子はインデックス戦略によって異なります。例として、PostgreSQLの標準配布物には配列用のGIN演算子クラスが含まれており、これらの演算子を使用したインデックス付き問い合わせをサポートしています。</target>
        </trans-unit>
        <trans-unit id="cd7904080c36090327450bf7ffd681d3be365b14" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiSTと同様に、SP-GISTは、データベースの専門家ではなく、データ型のドメインの専門家によって、適切なアクセス方法を持つカスタムデータ型の開発を可能にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="48b6f9b32591a18a649f1f0d5dc992087748dd36" translate="yes" xml:space="preserve">
          <source>Like GiST, SP-GiST supports &amp;ldquo;nearest-neighbor&amp;rdquo; searches. For SP-GiST operator classes that support distance ordering, the corresponding operator is specified in the &amp;ldquo;Ordering Operators&amp;rdquo; column in &lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 65.1&lt;/a&gt;.</source>
          <target state="translated">GiSTと同様に、SP-GiSTは「最近傍」検索をサポートしています。距離の順序付けをサポートするSP-GiST演算子クラスの場合、対応する演算子は、&lt;a href=&quot;spgist-builtin-opclasses#SPGIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;表65.1の&lt;/a&gt;「順序付け演算子」列で指定されています。</target>
        </trans-unit>
        <trans-unit id="60e4d14adfb5f143c50beb7e0713788626061776" translate="yes" xml:space="preserve">
          <source>Like a &lt;code&gt;CASE&lt;/code&gt; expression, &lt;code&gt;COALESCE&lt;/code&gt; only evaluates the arguments that are needed to determine the result; that is, arguments to the right of the first non-null argument are not evaluated. This SQL-standard function provides capabilities similar to &lt;code&gt;NVL&lt;/code&gt; and &lt;code&gt;IFNULL&lt;/code&gt;, which are used in some other database systems.</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 式と同様に、 &lt;code&gt;COALESCE&lt;/code&gt; は結果を決定するために必要な引数のみを評価します。つまり、最初のnull以外の引数の右側にある引数は評価されません。このSQL標準関数は、他の一部のデータベースシステムで使用される &lt;code&gt;NVL&lt;/code&gt; および &lt;code&gt;IFNULL&lt;/code&gt; と同様の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="1b49279f338ded2bdf03d1fe2fa28270882b8852" translate="yes" xml:space="preserve">
          <source>Like all locks in PostgreSQL, a complete list of advisory locks currently held by any session can be found in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">PostgreSQLのすべてのロックと同様に、現在セッションで保持されているアドバイザリロックの完全なリストは、&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt;システムビューにあります。</target>
        </trans-unit>
        <trans-unit id="41cf9a59f49a59843cd96e23e78a1ccf6b90562d" translate="yes" xml:space="preserve">
          <source>Like all statement-logging options, this option can add significant overhead.</source>
          <target state="translated">すべてのステートメントロギングオプションと同様に、このオプションはかなりのオーバーヘッドを追加することができます。</target>
        </trans-unit>
        <trans-unit id="59c02f2aa97036dbf7f53371e80651c744767251" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">他のPostgreSQLクライアントアプリケーションと同様に、pg_dumpはデフォルトで、現在のオペレーティングシステムのユーザー名と同じデータベースユーザー名で接続します。これをオーバーライドするには、 &lt;code&gt;-U&lt;/code&gt; オプションを指定するか、環境変数 &lt;code&gt;PGUSER&lt;/code&gt; を設定します。 pg_dump接続は、通常のクライアント認証メカニズム（&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章で&lt;/a&gt;説明）の影響を受けることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ab5911dcefb73651b71811a18cd1ea69e7e94d92" translate="yes" xml:space="preserve">
          <source>Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt;. Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</source>
          <target state="translated">Like any other PostgreSQL client application, pg_dump will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the &lt;code&gt;-U&lt;/code&gt; option or set the environment variable &lt;code&gt;PGUSER&lt;/code&gt; . Remember that pg_dump connections are subject to the normal client authentication mechanisms (which are described in &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="c9db72f7082c44e13743d7b5d39d781324396c03" translate="yes" xml:space="preserve">
          <source>Like most other relational database products, PostgreSQL supports &lt;em&gt;aggregate functions&lt;/em&gt;. An aggregate function computes a single result from multiple input rows. For example, there are aggregates to compute the &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt; (average), &lt;code&gt;max&lt;/code&gt; (maximum) and &lt;code&gt;min&lt;/code&gt; (minimum) over a set of rows.</source>
          <target state="translated">他のほとんどのリレーショナルデータベース製品と同様に、PostgreSQLは&lt;em&gt;集約関数を&lt;/em&gt;サポートしてい&lt;em&gt;ます&lt;/em&gt;。集約関数は、複数の入力行から単一の結果を計算します。たとえば、行のセットに対して &lt;code&gt;count&lt;/code&gt; 、 &lt;code&gt;sum&lt;/code&gt; 、 &lt;code&gt;avg&lt;/code&gt; （平均）、 &lt;code&gt;max&lt;/code&gt; （最大）、 &lt;code&gt;min&lt;/code&gt; （最小）を計算する集計があります。</target>
        </trans-unit>
        <trans-unit id="e7b37131745c0548a8d7bb256942b653bac4d0f2" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are requested.</source>
          <target state="translated">組み込みの &lt;code&gt;SYSTEM&lt;/code&gt; サンプリング方法と同様に、 &lt;code&gt;SYSTEM_ROWS&lt;/code&gt; はブロックレベルのサンプリングを実行するため、サンプルは完全にランダムではありませんが、特に少数の行のみが要求される場合は、クラスタリングの影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="2764b8aec49f0a51f07f507803e713795f179f24" translate="yes" xml:space="preserve">
          <source>Like the built-in &lt;code&gt;SYSTEM&lt;/code&gt; sampling method, &lt;code&gt;SYSTEM_TIME&lt;/code&gt; performs block-level sampling, so that the sample is not completely random but may be subject to clustering effects, especially if only a small number of rows are selected.</source>
          <target state="translated">組み込みの &lt;code&gt;SYSTEM&lt;/code&gt; サンプリング方法と同様に、 &lt;code&gt;SYSTEM_TIME&lt;/code&gt; はブロックレベルのサンプリングを実行するため、サンプルは完全にランダムではありませんが、特に少数の行しか選択されていない場合、クラスタリングの影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="b3332deec758b17e6fd52517b579fa1eda61782d" translate="yes" xml:space="preserve">
          <source>Likewise, any sequence state changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">Likewise, any sequence state changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</target>
        </trans-unit>
        <trans-unit id="0e207e275fe1f2f0794d071fcc2006657d41ca30" translate="yes" xml:space="preserve">
          <source>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</source>
          <target state="translated">同様に、出力カラムが配列型でJSON値がJSON配列の場合、これらのルールを再帰的に適用することで、JSON配列の要素が出力配列の要素に変換されます。</target>
        </trans-unit>
        <trans-unit id="c63c5f8682585854b3af24acfaa10cdf34814785" translate="yes" xml:space="preserve">
          <source>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</source>
          <target state="translated">同様に、内側のタプルがインデックスページに収まるように大きくなりすぎないようにするのは演算子クラスの責任です。</target>
        </trans-unit>
        <trans-unit id="55246b1bbd1c53d922bbe5662b502ad39d3e6a6a" translate="yes" xml:space="preserve">
          <source>Likewise, the current session's temporary-table schema, &lt;code&gt;pg_temp_nnn&lt;/code&gt;, is always searched if it exists. It can be explicitly listed in the path by using the alias &lt;code&gt;pg_temp&lt;/code&gt;. If it is not listed in the path then it is searched first (even before &lt;code&gt;pg_catalog&lt;/code&gt;). However, the temporary schema is only searched for relation (table, view, sequence, etc) and data type names. It is never searched for function or operator names.</source>
          <target state="translated">同様に、現在のセッションの一時テーブルスキーマ &lt;code&gt;pg_temp_nnn&lt;/code&gt; は、存在する場合は常に検索されます。エイリアス &lt;code&gt;pg_temp&lt;/code&gt; を使用して、パスに明示的にリストできます。パスにリストされていない場合は、最初に検索され &lt;code&gt;pg_catalog&lt;/code&gt; （pg_catalogの前でも）。ただし、一時スキーマは、リレーション（テーブル、ビュー、シーケンスなど）とデータ型名のみが検索されます。関数名や演算子名は検索されません。</target>
        </trans-unit>
        <trans-unit id="23e122f77e2123c0711252ea9a852e626bde8b4c" translate="yes" xml:space="preserve">
          <source>Likewise, while an aggregate final function is normally expected not to modify its input values, sometimes it is impractical to avoid modifying the transition-state argument. Such behavior must be declared using the &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; parameter. The &lt;code&gt;READ_WRITE&lt;/code&gt; value indicates that the final function modifies the transition state in unspecified ways. This value prevents use of the aggregate as a window function, and it also prevents merging of transition states for aggregate calls that share the same input values and transition functions. The &lt;code&gt;SHAREABLE&lt;/code&gt; value indicates that the transition function cannot be applied after the final function, but multiple final-function calls can be performed on the ending transition state value. This value prevents use of the aggregate as a window function, but it allows merging of transition states. (That is, the optimization of interest here is not applying the same final function repeatedly, but applying different final functions to the same ending transition state value. This is allowed as long as none of the final functions are marked &lt;code&gt;READ_WRITE&lt;/code&gt;.)</source>
          <target state="translated">同様に、集約final関数は通常、その入力値を変更しないことが期待されていますが、遷移状態引数を変更しないようにすることは実際的でない場合があります。このような動作は、 &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; パラメーターを使用して宣言する必要があります。 &lt;code&gt;READ_WRITE&lt;/code&gt; の値は、最終的な機能は、不特定の方法で遷移状態を修正することを示しています。この値は、ウィンドウ関数としての集約の使用を防ぎ、同じ入力値と遷移関数を共有する集約呼び出しの遷移状態のマージも防ぎます。 &lt;code&gt;SHAREABLE&lt;/code&gt; 値は、最終関数の後に遷移関数を適用できないことを示しますが、終了遷移状態値に対して複数の最終関数呼び出しを実行できます。この値は、ウィンドウ関数としての集約の使用を防ぎますが、遷移状態のマージを可能にします。（つまり、ここでの最適化は、同じ最終関数を繰り返し適用するのではなく、同じ最終遷移状態値に異なる最終関数を適用することです。これは、最終関数が &lt;code&gt;READ_WRITE&lt;/code&gt; とマークされていない限り許可されます。）</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="b47563cbfdd571c38564d5b781eea43887f5700d" translate="yes" xml:space="preserve">
          <source>Limits and compatibility notes for the &lt;code&gt;xml&lt;/code&gt; data type can be found in &lt;a href=&quot;xml-limits-conformance&quot;&gt;Section D.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; データ型の制限と互換性に関する注意事項は、&lt;a href=&quot;xml-limits-conformance&quot;&gt;セクションD.3にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="96d43f75faf24d1ca67c70ecd2f285a22f1af174" translate="yes" xml:space="preserve">
          <source>Line number of this rule in &lt;code&gt;pg_hba.conf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pg_hba.conf&lt;/code&gt; 内のこのルールの行番号</target>
        </trans-unit>
        <trans-unit id="958c1e90be0b1ef7a3ea1a3a2ab4b6c7d005a8b7" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file the current value was set at (null for values set from sources other than configuration files, or when examined by a user who is neither a superuser or a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;).</source>
          <target state="translated">現在の値が設定された構成ファイル内の行番号（構成ファイル以外のソースから設定された値、またはスーパーユーザーでも &lt;code&gt;pg_read_all_settings&lt;/code&gt; のメンバーでもないユーザーによって検査された場合はnull）。</target>
        </trans-unit>
        <trans-unit id="5b8f36e71eca1491bb5a406fd952255ee2d3703e" translate="yes" xml:space="preserve">
          <source>Line number within the configuration file where the entry appears</source>
          <target state="translated">エントリが表示される設定ファイル内の行番号</target>
        </trans-unit>
        <trans-unit id="883c97e9c14ffbedf2267734a54bef543950a75e" translate="yes" xml:space="preserve">
          <source>Line segments are output using the first syntax.</source>
          <target state="translated">線分は、最初の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="752729c6452eefd378564f7929186a93baad040b" translate="yes" xml:space="preserve">
          <source>Line segments are represented by pairs of points that are the endpoints of the segment. Values of type &lt;code&gt;lseg&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">ラインセグメントは、セグメントの端点であるポイントのペアで表されます。タイプ &lt;code&gt;lseg&lt;/code&gt; の値は、以下の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="16fbbc248c377444909f3461d6f0754204ffd781" translate="yes" xml:space="preserve">
          <source>Lines are represented by the linear equation &lt;code&gt;A&lt;/code&gt;x + &lt;code&gt;B&lt;/code&gt;y + &lt;code&gt;C&lt;/code&gt; = 0, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are not both zero. Values of type &lt;code&gt;line&lt;/code&gt; are input and output in the following form:</source>
          <target state="translated">線は、線形方程式 &lt;code&gt;A&lt;/code&gt; x + &lt;code&gt;B&lt;/code&gt; y + &lt;code&gt;C&lt;/code&gt; = 0で表されます。ここで、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; は両方ともゼロではありません。タイプ &lt;code&gt;line&lt;/code&gt; の値は、次の形式で入力および出力されます。</target>
        </trans-unit>
        <trans-unit id="c8eb4d4a92219b0c43b53ed882184405007c09a3" translate="yes" xml:space="preserve">
          <source>Lines being skipped are parsed normally to identify queries and backslash commands, but queries are not sent to the server, and backslash commands other than conditionals (&lt;code&gt;\if&lt;/code&gt;, &lt;code&gt;\elif&lt;/code&gt;, &lt;code&gt;\else&lt;/code&gt;, &lt;code&gt;\endif&lt;/code&gt;) are ignored. Conditional commands are checked only for valid nesting. Variable references in skipped lines are not expanded, and backquote expansion is not performed either.</source>
          <target state="translated">スキップされた行は通常どおり解析され、クエリとバックスラッシュコマンドが識別されますが、クエリはサーバーに送信されず、条件（ &lt;code&gt;\if&lt;/code&gt; 、 &lt;code&gt;\elif&lt;/code&gt; 、 &lt;code&gt;\else&lt;/code&gt; 、 &lt;code&gt;\endif&lt;/code&gt; ）以外のバックスラッシュコマンドは無視されます。条件付きコマンドは、有効なネストについてのみチェックされます。スキップされた行の変数参照は展開されず、バッククォート展開も実行されません。</target>
        </trans-unit>
        <trans-unit id="292bae73b4b4a6866d3b72fe56f7981ef97aafd8" translate="yes" xml:space="preserve">
          <source>Lines in the file can be commented out, deleted, and reordered. For example:</source>
          <target state="translated">ファイル内の行は、コメントアウト、削除、並び替えが可能です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5f388e9f9cc02768dd9a283f46d4fc51473f089e" translate="yes" xml:space="preserve">
          <source>Linguistic &amp;mdash; Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">Linguistic &amp;mdash; Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</target>
        </trans-unit>
        <trans-unit id="1a1f33913b1ca17a294498b513bfd39ae8063421" translate="yes" xml:space="preserve">
          <source>Linguistic - Ispell dictionaries try to reduce input words to a normalized form; stemmer dictionaries remove word endings</source>
          <target state="translated">言語学的-Ispell辞書は、入力された単語を正規化された形に縮小しようとします。</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="77cec0c3e9d8d25a57ec1badeff796c61ca86f12" translate="yes" xml:space="preserve">
          <source>List Partitioning</source>
          <target state="translated">リストパーティショニング</target>
        </trans-unit>
        <trans-unit id="0f3458dce5820aca7e890c4b2003d0e275648e05" translate="yes" xml:space="preserve">
          <source>List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command &lt;code&gt;\list&lt;/code&gt;.</source>
          <target state="translated">使用可能なすべてのデータベースをリストしてから終了します。他の非接続オプションは無視されます。これは、メタコマンド &lt;code&gt;\list&lt;/code&gt; 似ています。</target>
        </trans-unit>
        <trans-unit id="4286624f672002892b2ca95ea48f927cd5f85422" translate="yes" xml:space="preserve">
          <source>List information about tables or indexes in a partition tree for a given partitioned table or partitioned index, with one row for each partition. Information provided includes the name of the partition, the name of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The value of level begins at &lt;code&gt;0&lt;/code&gt; for the input table or index in its role as the root of the partition tree, &lt;code&gt;1&lt;/code&gt; for its partitions, &lt;code&gt;2&lt;/code&gt; for their partitions, and so on.</source>
          <target state="translated">特定のパーティションテーブルまたはパーティションインデックスのパーティションツリー内のテーブルまたはインデックスに関する情報を、パーティションごとに1行ずつリストします。提供される情報には、パーティションの名前、その直接の親の名前、パーティションがリーフであるかどうかを示すブール値、および階層内のレベルを示す整数が含まれます。levelの値は、パーティションツリーのルートとしての役割を持つ入力テーブルまたはインデックスの場合は &lt;code&gt;0&lt;/code&gt; 、パーティションの場合は &lt;code&gt;1&lt;/code&gt; 、パーティションの場合は &lt;code&gt;2&lt;/code&gt; から始まります。</target>
        </trans-unit>
        <trans-unit id="f561011cb33daf6ca735d20bdacd8bd7a77bc262" translate="yes" xml:space="preserve">
          <source>List of database name(s) to which this rule applies</source>
          <target state="translated">このルールが適用されるデータベース名のリスト</target>
        </trans-unit>
        <trans-unit id="c88853b59f7b2d53c0a2755574e42ba43712f76a" translate="yes" xml:space="preserve">
          <source>List of user and group name(s) to which this rule applies</source>
          <target state="translated">このルールが適用されるユーザー名とグループ名のリスト</target>
        </trans-unit>
        <trans-unit id="d7af7e299822395c971e66ef8de74b892601d575" translate="yes" xml:space="preserve">
          <source>List text search configurations (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索構成をリストします（詳細については &lt;code&gt;+&lt;/code&gt; を追加します）。</target>
        </trans-unit>
        <trans-unit id="75bf8723aef5bc601305334105eb67bae8708809" translate="yes" xml:space="preserve">
          <source>List text search dictionaries (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索辞書をリストします（詳細については &lt;code&gt;+&lt;/code&gt; を追加します）。</target>
        </trans-unit>
        <trans-unit id="f21d1140d1b1ac1f6965e01da259ebe5d03603ab" translate="yes" xml:space="preserve">
          <source>List text search parsers (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索パーサーをリストします（詳細は &lt;code&gt;+&lt;/code&gt; を追加してください）。</target>
        </trans-unit>
        <trans-unit id="a1e1b832b491c08ce8f5b18d1ec93b64f07d2462" translate="yes" xml:space="preserve">
          <source>List text search templates (add &lt;code&gt;+&lt;/code&gt; for more detail).</source>
          <target state="translated">テキスト検索テンプレートをリストします（詳細は &lt;code&gt;+&lt;/code&gt; を追加してください）。</target>
        </trans-unit>
        <trans-unit id="47ced8a7739926f8f4967c561a0debfd00799b0f" translate="yes" xml:space="preserve">
          <source>List the ancestor relations of the given partition, including the partition itself.</source>
          <target state="translated">与えられたパーティションの先祖関係をリストアップします。</target>
        </trans-unit>
        <trans-unit id="1202ae63c3dc8af04c25238d78d5139577abc684" translate="yes" xml:space="preserve">
          <source>List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">ディレクトリの内容を一覧表示します。デフォルトではスーパーユーザに制限されていますが、他のユーザがこの関数を実行するために EXECUTE を許可することができます。</target>
        </trans-unit>
        <trans-unit id="1b401449c4e0d240387a616d5ffbd4a726f02619" translate="yes" xml:space="preserve">
          <source>List the databases in the server and show their names, owners, character set encodings, and access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only databases whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.)</source>
          <target state="translated">サーバー内のデータベースを一覧表示し、それらの名前、所有者、文字セットエンコーディング、およびアクセス権を表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するデータベースのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、データベースサイズ、デフォルトのテーブルスペース、および説明も表示されます。（サイズ情報は、現在のユーザーが接続できるデータベースでのみ使用できます。）</target>
        </trans-unit>
        <trans-unit id="0247fd79dd91c3e0b751440d00b889937665ce82" translate="yes" xml:space="preserve">
          <source>List the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;log_directory&lt;/code&gt; ディレクトリー内のログ・ファイルをリストします</target>
        </trans-unit>
        <trans-unit id="38872979f824f8456260bf7fc7dc4180d1627b73" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL archive status directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WALアーカイブステータスディレクトリ内のファイルの名前、サイズ、最終変更時刻をリストします。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="216f390c14edafdef1abb92a2e408162ca22c8d7" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the WAL directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">WALディレクトリ内のファイルの名前、サイズ、および最終変更時刻をリストします。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="74056411fa2a679687b641cd39f5e9f62ea8d563" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the log directory. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">ログディレクトリ内のファイルの名前、サイズ、最終変更時刻をリストします。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="26197e7b4127b303329ad5784e3d755d4742f8bd" translate="yes" xml:space="preserve">
          <source>List the name, size, and last modification time of files in the temporary directory for &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is used. Access is granted to members of the &lt;code&gt;pg_monitor&lt;/code&gt; role and may be granted to other non-superuser roles.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; の&lt;/em&gt;一時ディレクトリにあるファイルの名前、サイズ、最終変更時刻をリストし&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt;が提供されていない場合、 &lt;code&gt;pg_default&lt;/code&gt; テーブルスペースが使用されます。アクセスは &lt;code&gt;pg_monitor&lt;/code&gt; ロールのメンバーに許可され、他の非スーパーユーザーロールに許可される場合があります。</target>
        </trans-unit>
        <trans-unit id="6c759b89899d2c028e05b2457d4bdd0b88affd68" translate="yes" xml:space="preserve">
          <source>List the table of contents of the archive. The output of this operation can be used as input to the &lt;code&gt;-L&lt;/code&gt; option. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-l&lt;/code&gt;, they will restrict the items listed.</source>
          <target state="translated">アーカイブの目次をリストします。この操作の出力は、 &lt;code&gt;-L&lt;/code&gt; オプションへの入力として使用できます。 &lt;code&gt;-n&lt;/code&gt; や &lt;code&gt;-t&lt;/code&gt; などのフィルタリングスイッチを &lt;code&gt;-l&lt;/code&gt; とともに使用すると、リストされる項目が制限されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c161fe12eda9cadc384d03d0ff29a932c7632490" translate="yes" xml:space="preserve">
          <source>Lists access methods. If &lt;code&gt;pattern&lt;/code&gt; is specified, only access methods whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each access method is listed with its associated handler function and description.</source>
          <target state="translated">アクセス方法をリストします。 &lt;code&gt;pattern&lt;/code&gt; を指定した場合、名前がパターンに一致するアクセスメソッドのみが表示されます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各アクセス方法は、関連するハンドラー関数と説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="b5da05aa6b417885b162fa263cf878dfa1640338" translate="yes" xml:space="preserve">
          <source>Lists aggregate functions, together with their return type and the data types they operate on. If &lt;code&gt;pattern&lt;/code&gt; is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">集計関数を、戻り値の型および関数が操作するデータ型とともにリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する集約のみが表示されます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。</target>
        </trans-unit>
        <trans-unit id="ba7e4d85e717101a207e6ece8fa5eae17728be95" translate="yes" xml:space="preserve">
          <source>Lists collations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database's encoding are shown, so the results may vary in different databases of the same installation.</source>
          <target state="translated">照合順序をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する照合のみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各照合は、関連する説明があればそれとともにリストされます。現在のデータベースのエンコーディングで使用できる照合順序のみが表示されるため、同じインストールの異なるデータベースでは結果が異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6ed6b6d351ec0314d4901220593cc831623e426a" translate="yes" xml:space="preserve">
          <source>Lists conversions between character-set encodings. If &lt;code&gt;pattern&lt;/code&gt; is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">文字セットエンコーディング間の変換をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する変換のみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは関連する説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="b54152fa5b884f8f7bf428a2c5f3834496af64bd" translate="yes" xml:space="preserve">
          <source>Lists data types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only types whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an &lt;code&gt;enum&lt;/code&gt; type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects.</source>
          <target state="translated">データ型をリストします。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致するだけのタイプが記載されています。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各タイプは、その内部名とサイズ、 &lt;code&gt;enum&lt;/code&gt; 型の場合は許可されている値、および関連する権限とともにリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。</target>
        </trans-unit>
        <trans-unit id="1ed12c82d91396faa77acdf69ded0ffcf5a493ea" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\dg&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\du+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">データベースロールを一覧表示します。 （「ユーザー」と「グループ」の概念が「ロール」に統合されたため、このコマンドは &lt;code&gt;\dg&lt;/code&gt; と同等になりました。）デフォルトでは、ユーザーが作成したロールのみが表示されます。システムロールを含めるには、 &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するロールのみがリストされます。 &lt;code&gt;\du+&lt;/code&gt; の形式を使用すると、各役割に関する追加情報が表示されます。現在、これは各ロールのコメントを追加しています。</target>
        </trans-unit>
        <trans-unit id="e29d00c4605108f4d7ba7d0a5a262d70885a0257" translate="yes" xml:space="preserve">
          <source>Lists database roles. (Since the concepts of &amp;ldquo;users&amp;rdquo; and &amp;ldquo;groups&amp;rdquo; have been unified into &amp;ldquo;roles&amp;rdquo;, this command is now equivalent to &lt;code&gt;\du&lt;/code&gt;.) By default, only user-created roles are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system roles. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those roles whose names match the pattern are listed. If the form &lt;code&gt;\dg+&lt;/code&gt; is used, additional information is shown about each role; currently this adds the comment for each role.</source>
          <target state="translated">データベースロールを一覧表示します。（「ユーザー」と「グループ」の概念が「役割」に統合されたため、このコマンドは &lt;code&gt;\du&lt;/code&gt; と同等になりました。）デフォルトでは、ユーザーが作成した役割のみが表示されます。システムロールを含めるには、 &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するロールのみがリストされます。 &lt;code&gt;\dg+&lt;/code&gt; の形式を使用すると、各ロールに関する追加情報が表示されます。現在、これは各ロールのコメントを追加しています。</target>
        </trans-unit>
        <trans-unit id="d0e3c51687d883f635b713be9df17a17913ec4be" translate="yes" xml:space="preserve">
          <source>Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose role name or schema name matches the pattern are listed.</source>
          <target state="translated">デフォルトのアクセス権設定をリストします。組み込みのデフォルトからデフォルトの特権設定が変更されたロール（および該当する場合はスキーマ）ごとにエントリが表示されます。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、ロール名またはスキーマ名がパターンに一致するエントリーのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="ee1fa4ed6c7126c1942282c2d9a97fd2fb17066c" translate="yes" xml:space="preserve">
          <source>Lists defined configuration settings. These settings can be role-specific, database-specific, or both. &lt;code&gt;role-pattern&lt;/code&gt; and &lt;code&gt;database-pattern&lt;/code&gt; are used to select specific roles and databases to list, respectively. If omitted, or if &lt;code&gt;*&lt;/code&gt; is specified, all settings are listed, including those not role-specific or database-specific, respectively.</source>
          <target state="translated">定義された構成設定をリストします。これらの設定は、ロール固有、データベース固有、またはその両方にすることができます。 &lt;code&gt;role-pattern&lt;/code&gt; と &lt;code&gt;database-pattern&lt;/code&gt; は、それぞれ特定のロールとデータベースを選択してリストするために使用されます。省略した場合、または &lt;code&gt;*&lt;/code&gt; を指定した場合は、それぞれロール固有またはデータベース固有ではないものを含め、すべての設定がリストされます。</target>
        </trans-unit>
        <trans-unit id="417307de73c4769c24d10a4a74f461c675665a71" translate="yes" xml:space="preserve">
          <source>Lists domains. If &lt;code&gt;pattern&lt;/code&gt; is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description.</source>
          <target state="translated">ドメインを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するドメインのみが表示されます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、関連する権限と説明とともに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="f274b8d8f8b448f365efc740c76106814f6e8672" translate="yes" xml:space="preserve">
          <source>Lists event triggers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those event triggers whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">イベントトリガーを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するイベントトリガーのみが一覧表示されます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは関連する説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="e79aeba25c72ede19da97f86bce69c0ff45f55b7" translate="yes" xml:space="preserve">
          <source>Lists foreign servers (mnemonic: &amp;ldquo;external servers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those servers whose name matches the pattern are listed. If the form &lt;code&gt;\des+&lt;/code&gt; is used, a full description of each server is shown, including the server's access privileges, type, version, options, and description.</source>
          <target state="translated">外部サーバーをリストします（ニーモニック：「外部サーバー」）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するサーバーのみがリストされます。 &lt;code&gt;\des+&lt;/code&gt; の形式を使用すると、サーバーのアクセス権、タイプ、バージョン、オプション、説明など、各サーバーの完全な説明が表示されます。</target>
        </trans-unit>
        <trans-unit id="78b8f146a38943cc21434e0badfc06780b279a22" translate="yes" xml:space="preserve">
          <source>Lists foreign tables (mnemonic: &amp;ldquo;external tables&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose table name or schema name matches the pattern are listed. If the form &lt;code&gt;\det+&lt;/code&gt; is used, generic options and the foreign table description are also displayed.</source>
          <target state="translated">外部テーブルをリストします（ニーモニック：「外部テーブル」）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、テーブル名またはスキーマ名がパターンに一致するエントリのみがリストされます。 &lt;code&gt;\det+&lt;/code&gt; の形式を使用すると、一般的なオプションと外部テーブルの説明も表示されます。</target>
        </trans-unit>
        <trans-unit id="841607b805a28257bffdea756495ef2cb699e228" translate="yes" xml:space="preserve">
          <source>Lists foreign-data wrappers (mnemonic: &amp;ldquo;external wrappers&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form &lt;code&gt;\dew+&lt;/code&gt; is used, the access privileges, options, and description of the foreign-data wrapper are also shown.</source>
          <target state="translated">外部データラッパーを一覧表示します（ニーモニック：「外部ラッパー」）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する外部データラッパーのみがリストされます。 &lt;code&gt;\dew+&lt;/code&gt; の形式を使用する場合、外部データラッパーのアクセス権限、オプション、および説明も表示されます。</target>
        </trans-unit>
        <trans-unit id="c91d07a0e33c78c3a0a76bd7d8280b785bbd7664" translate="yes" xml:space="preserve">
          <source>Lists functions, together with their result data types, argument data types, and function types, which are classified as &amp;ldquo;agg&amp;rdquo; (aggregate), &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;trigger&amp;rdquo;, or &amp;ldquo;window&amp;rdquo;. To display only functions of specific type(s), add the corresponding letters &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, or &lt;code&gt;w&lt;/code&gt; to the command. If &lt;code&gt;pattern&lt;/code&gt; is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If the form &lt;code&gt;\df+&lt;/code&gt; is used, additional information about each function is shown, including volatility, parallel safety, owner, security classification, access privileges, language, source code and description.</source>
          <target state="translated">関数を、その結果のデータ型、引数のデータ型、および関数の型と共に一覧表示します。これらは、「agg」（集約）、「通常」、「プロシージャ」、「トリガー」、または「ウィンドウ」に分類されます。特定のタイプの関数のみを表示するには、対応する文字 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; 、 &lt;code&gt;t&lt;/code&gt; 、または &lt;code&gt;w&lt;/code&gt; をコマンドに追加します。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致する関数のみが表示されます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。フォーム &lt;code&gt;\df+&lt;/code&gt; を使用すると、ボラティリティ、並列安全性、所有者、セキュリティ分類、アクセス権限、言語、ソースコード、説明など、各関数に関する追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="24ae150e74e52548491a1b8532993c514778868d" translate="yes" xml:space="preserve">
          <source>Lists installed extensions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those extensions whose names match the pattern are listed. If the form &lt;code&gt;\dx+&lt;/code&gt; is used, all the objects belonging to each matching extension are listed.</source>
          <target state="translated">インストールされている拡張機能をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する拡張子のみがリストされます。 &lt;code&gt;\dx+&lt;/code&gt; の形式を使用すると、一致する各拡張子に属するすべてのオブジェクトがリストされます。</target>
        </trans-unit>
        <trans-unit id="9786e0547a160a45eeaaa13b899d2ca350fd4bf0" translate="yes" xml:space="preserve">
          <source>Lists operator classes (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPCLASS&quot;&gt;Section 37.16.1&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator classes associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator classes associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator class is listed with its associated operator family and owner.</source>
          <target state="translated">Lists operator classes (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPCLASS&quot;&gt;Section 37.16.1&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator classes associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator classes associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator class is listed with its associated operator family and owner.</target>
        </trans-unit>
        <trans-unit id="dabc9d2416e57fbb1a6fc125515b7843848c40ff" translate="yes" xml:space="preserve">
          <source>Lists operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPFAMILY&quot;&gt;Section 37.16.5&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator families associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator family is listed with its owner.</source>
          <target state="translated">Lists operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-OPFAMILY&quot;&gt;Section 37.16.5&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;input-type-pattern&lt;/code&gt; is specified, only operator families associated with input types whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator family is listed with its owner.</target>
        </trans-unit>
        <trans-unit id="02fc530a920ec71e97da7b47a26de17857efd30a" translate="yes" xml:space="preserve">
          <source>Lists operators associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only members of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only members of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</source>
          <target state="translated">Lists operators associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only members of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only members of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each operator is listed with its sort operator family (if it is an ordering operator).</target>
        </trans-unit>
        <trans-unit id="7b91d850ae0056bf60018b5ebefbaf56889e4bca" translate="yes" xml:space="preserve">
          <source>Lists operators with their operand and result types. If &lt;code&gt;pattern&lt;/code&gt; is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function.</source>
          <target state="translated">演算子とそのオペランドおよび結果タイプをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する演算子のみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が付加されている場合、各演算子に関する追加情報が表示されます。現在のところ、基礎となる関数の名前のみです。</target>
        </trans-unit>
        <trans-unit id="b6dce10f054bc4a066d94e91eb2653d58925f8ed" translate="yes" xml:space="preserve">
          <source>Lists partitioned relations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only entries whose name matches the pattern are listed. The modifiers &lt;code&gt;t&lt;/code&gt; (tables) and &lt;code&gt;i&lt;/code&gt; (indexes) can be appended to the command, filtering the kind of relations to list. By default, partitioned tables and indexes are listed.</source>
          <target state="translated">分割された関係をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するエントリのみがリストされます。修飾子 &lt;code&gt;t&lt;/code&gt; （テーブル）および &lt;code&gt;i&lt;/code&gt; （インデックス）をコマンドに追加して、リストする関係の種類をフィルタリングできます。デフォルトでは、パーティション分割されたテーブルとインデックスが一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="6639ac93b6964b1629641d3ad0795ccf6bdb89e2" translate="yes" xml:space="preserve">
          <source>Lists procedural languages. If &lt;code&gt;pattern&lt;/code&gt; is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object.</source>
          <target state="translated">手続き言語をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致する言語のみがリストされます。デフォルトでは、ユーザーが作成した言語のみが表示されます。システムオブジェクトを含めるには、 &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各言語は、そのコールハンドラ、バリデータ、アクセス権限、およびシステムオブジェクトかどうかとともに表示されます。</target>
        </trans-unit>
        <trans-unit id="d159d89b43261dc04712aa39d984b98a29983107" translate="yes" xml:space="preserve">
          <source>Lists replication publications. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those publications whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, the tables associated with each publication are shown as well.</source>
          <target state="translated">レプリケーションパブリケーションを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するパブリケーションのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各パブリケーションに関連付けられているテーブルも表示されます。</target>
        </trans-unit>
        <trans-unit id="5edfb1ad4f7a1bcdc13378e73525d95e092cfe45" translate="yes" xml:space="preserve">
          <source>Lists replication subscriptions. If &lt;code&gt;pattern&lt;/code&gt; is specified, only those subscriptions whose names match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, additional properties of the subscriptions are shown.</source>
          <target state="translated">レプリケーションサブスクリプションを一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するサブスクリプションのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、サブスクリプションの追加のプロパティが表示されます。</target>
        </trans-unit>
        <trans-unit id="4fb239c1a080740cf10a3927b46a1262b5ea56d1" translate="yes" xml:space="preserve">
          <source>Lists schemas (namespaces). If &lt;code&gt;pattern&lt;/code&gt; is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the &lt;code&gt;S&lt;/code&gt; modifier to include system objects. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated permissions and description, if any.</source>
          <target state="translated">スキーマ（名前空間）をリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するスキーマのみがリストされます。デフォルトでは、ユーザーが作成したオブジェクトのみが表示されます。システムオブジェクトを含めるには、パターンまたは &lt;code&gt;S&lt;/code&gt; 修飾子を指定します。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは、関連する権限と説明（ある場合）とともに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="f82cdaaaa438cda917a1234e5b948d7815debbbb" translate="yes" xml:space="preserve">
          <source>Lists support functions associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only functions of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</source>
          <target state="translated">Lists support functions associated with operator families (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt;). If &lt;code&gt;access-method-pattern&lt;/code&gt; is specified, only functions of operator families associated with access methods whose names match that pattern are listed. If &lt;code&gt;operator-family-pattern&lt;/code&gt; is specified, only functions of operator families whose names match that pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, functions are displayed verbosely, with their actual parameter lists.</target>
        </trans-unit>
        <trans-unit id="aaa2ebfeff5215f2bad04d9af2cdf2d89c158023" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">テーブル、ビュー、シーケンスを、関連するアクセス権とともに一覧表示します。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致するテーブルのみ、ビュー、シーケンスの一覧が表示されます。</target>
        </trans-unit>
        <trans-unit id="bb59616e451459bc316da05ad410acee2d59778b" translate="yes" xml:space="preserve">
          <source>Lists tables, views and sequences with their associated access privileges. If a &lt;code&gt;pattern&lt;/code&gt; is specified, only tables, views and sequences whose names match the pattern are listed.</source>
          <target state="translated">テーブル、ビュー、シーケンスを、関連するアクセス権とともに一覧表示します。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するテーブル、ビュー、シーケンスのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="ef7de3f6c539d5dd5da460845cd3a63bfcafc2bd" translate="yes" xml:space="preserve">
          <source>Lists tablespaces. If &lt;code&gt;pattern&lt;/code&gt; is specified, only tablespaces whose names match the pattern are shown. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each tablespace is listed with its associated options, on-disk size, permissions and description.</source>
          <target state="translated">テーブルスペースを一覧表示します。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致する専用表領域が表示されます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各テーブルスペースは、関連するオプション、ディスク上のサイズ、権限、説明とともに一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="762f36a63dc0b6ce665e3c2131b6edc15a3446da" translate="yes" xml:space="preserve">
          <source>Lists text search configurations. If &lt;code&gt;pattern&lt;/code&gt; is specified, only configurations whose names match the pattern are shown. If the form &lt;code&gt;\dF+&lt;/code&gt; is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type.</source>
          <target state="translated">テキスト検索構成をリストします。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致する唯一の構成が示されています。 &lt;code&gt;\dF+&lt;/code&gt; の形式を使用すると、基になるテキスト検索パーサーや各パーサートークンタイプのディクショナリリストなど、各構成の完全な説明が表示されます。</target>
        </trans-unit>
        <trans-unit id="f6bb868ceb84c3b85646ce544e1a8e93f3c169f4" translate="yes" xml:space="preserve">
          <source>Lists text search dictionaries. If &lt;code&gt;pattern&lt;/code&gt; is specified, only dictionaries whose names match the pattern are shown. If the form &lt;code&gt;\dFd+&lt;/code&gt; is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values.</source>
          <target state="translated">テキスト検索辞書をリストします。場合は &lt;code&gt;pattern&lt;/code&gt; 指定され、そのパターンに名前が一致するだけで辞書が表示されます。 &lt;code&gt;\dFd+&lt;/code&gt; の形式を使用すると、選択した各辞書について、基礎となるテキスト検索テンプレートやオプション値などの追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="ba01d174c5c6cab6bd3b44d816241b168a44d553" translate="yes" xml:space="preserve">
          <source>Lists text search parsers. If &lt;code&gt;pattern&lt;/code&gt; is specified, only parsers whose names match the pattern are shown. If the form &lt;code&gt;\dFp+&lt;/code&gt; is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types.</source>
          <target state="translated">テキスト検索パーサーをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するパーサーのみが表示されます。 &lt;code&gt;\dFp+&lt;/code&gt; の形式を使用すると、基礎となる関数や認識されるトークンタイプのリストなど、各パーサーの完全な説明が表示されます。</target>
        </trans-unit>
        <trans-unit id="80703d2e971d1dc8cd3056fab4357086f4708060" translate="yes" xml:space="preserve">
          <source>Lists text search templates. If &lt;code&gt;pattern&lt;/code&gt; is specified, only templates whose names match the pattern are shown. If the form &lt;code&gt;\dFt+&lt;/code&gt; is used, additional information is shown about each template, including the underlying function names.</source>
          <target state="translated">テキスト検索テンプレートをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、名前がパターンに一致するテンプレートのみが表示されます。 &lt;code&gt;\dFt+&lt;/code&gt; の形式を使用すると、基になる関数名など、各テンプレートに関する追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="1d9024892b5e72795e533219deec09ad897119d7" translate="yes" xml:space="preserve">
          <source>Lists the ancestor relations of the given partition, including the relation itself. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="translated">与えられたパーティションの祖先関係をリストアップします。関係が存在しない場合や、パーティションやパーティショニングされたテーブルでない場合は、行を返しません。</target>
        </trans-unit>
        <trans-unit id="f51bd1ab303ee9de03bdc15a672decf5bfa818c0" translate="yes" xml:space="preserve">
          <source>Lists the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory.</source>
          <target state="translated">Lists the log files in the &lt;code&gt;log_directory&lt;/code&gt; directory.</target>
        </trans-unit>
        <trans-unit id="78999412a6e9f781edbd7db90370d17b04826c4b" translate="yes" xml:space="preserve">
          <source>Lists the tables or indexes in the partition tree of the given partitioned table or partitioned index, with one row for each partition. Information provided includes the OID of the partition, the OID of its immediate parent, a boolean value telling if the partition is a leaf, and an integer telling its level in the hierarchy. The level value is 0 for the input table or index, 1 for its immediate child partitions, 2 for their partitions, and so on. Returns no rows if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="translated">与えられたパーティショニングテーブルまたはパーティショニングインデックスのパーティションツリー内のテーブルまたはインデックスを、各パーティションごとに一行ずつリストアップします。情報には、パーティションの OID、直接の親の OID、パーティションがリーフであるかどうかを示すブール値、階層内のレベルを示す整数が含まれます。レベル値は、入力テーブルやインデックスの場合は0、その直接の子パーティションの場合は1、そのパーティションの場合は2、などです。関係が存在しない場合や、パーティションやパーティショニングされたテーブルでない場合は、行を返しません。</target>
        </trans-unit>
        <trans-unit id="f0a40588516c3a8604348670da0a879303a508a1" translate="yes" xml:space="preserve">
          <source>Lists type casts. If &lt;code&gt;pattern&lt;/code&gt; is specified, only casts whose source or target types match the pattern are listed. If &lt;code&gt;+&lt;/code&gt; is appended to the command name, each object is listed with its associated description.</source>
          <target state="translated">型キャストをリストします。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、ソースまたはターゲットのタイプがパターンに一致するキャストのみがリストされます。コマンド名に &lt;code&gt;+&lt;/code&gt; が追加されている場合、各オブジェクトは関連する説明とともにリストされます。</target>
        </trans-unit>
        <trans-unit id="b23bce00d2c7c8d6375ab0cd2ad7f38f1f799075" translate="yes" xml:space="preserve">
          <source>Lists user mappings (mnemonic: &amp;ldquo;external users&amp;rdquo;). If &lt;code&gt;pattern&lt;/code&gt; is specified, only those mappings whose user names match the pattern are listed. If the form &lt;code&gt;\deu+&lt;/code&gt; is used, additional information about each mapping is shown.</source>
          <target state="translated">ユーザーマッピングを一覧表示します（ニーモニック： &quot;外部ユーザー&quot;）。 &lt;code&gt;pattern&lt;/code&gt; が指定されている場合、ユーザー名がパターンに一致するマッピングのみがリストされます。 &lt;code&gt;\deu+&lt;/code&gt; の形式を使用すると、各マッピングに関する追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="fee8c64f75222b953355d11e92e46cafb863f042" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the function should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">関数の呼び出しを変換するリストが適用されます。変換は、SQL型と言語固有のデータ型の間で変換します。&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORMを&lt;/a&gt;参照してください。手続き型言語の実装は、通常、組み込み型のハードコードされた知識を持っているため、ここにリストする必要はありません。手続き型言語の実装が型の処理方法を知らず、変換が提供されない場合、データ型を変換するためのデフォルトの動作にフォールバックしますが、これは実装によって異なります。</target>
        </trans-unit>
        <trans-unit id="c221c51fd4371df729302cc73086e8359e205a42" translate="yes" xml:space="preserve">
          <source>Lists which transforms a call to the procedure should apply. Transforms convert between SQL types and language-specific data types; see &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;. Procedural language implementations usually have hardcoded knowledge of the built-in types, so those don't need to be listed here. If a procedural language implementation does not know how to handle a type and no transform is supplied, it will fall back to a default behavior for converting data types, but this depends on the implementation.</source>
          <target state="translated">プロシージャの呼び出しを変換するリストが適用されます。変換は、SQL型と言語固有のデータ型の間で変換します。&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORMを&lt;/a&gt;参照してください。手続き型言語の実装は、通常、組み込み型のハードコードされた知識を持っているため、ここにリストする必要はありません。手続き型言語の実装が型の処理方法を知らず、変換が提供されない場合、データ型を変換するためのデフォルトの動作にフォールバックしますが、これは実装によって異なります。</target>
        </trans-unit>
        <trans-unit id="0c4bdf42add57a2eabb9fb37aeb6c28158bad4b3" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">リテラル &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df214b5bbf763eb7922bad89d00442e94abbaf1f" translate="yes" xml:space="preserve">
          <source>Loading an extension essentially amounts to running the extension's script file. The script will typically create new SQL objects such as functions, data types, operators and index support methods. &lt;code&gt;CREATE EXTENSION&lt;/code&gt; additionally records the identities of all the created objects, so that they can be dropped again if &lt;code&gt;DROP EXTENSION&lt;/code&gt; is issued.</source>
          <target state="translated">拡張機能の読み込みは、基本的に拡張機能のスクリプトファイルを実行することと同じです。スクリプトは通常、関数、データ型、演算子、インデックスサポートメソッドなどの新しいSQLオブジェクトを作成します。 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; はさらに、作成されたすべてのオブジェクトのIDを記録します。これにより、 &lt;code&gt;DROP EXTENSION&lt;/code&gt; が発行された場合にそれらを再度ドロップできます。</target>
        </trans-unit>
        <trans-unit id="e93fcdb23625364e2abff318d75861520536fbf6" translate="yes" xml:space="preserve">
          <source>Loading an extension ordinarily requires the same privileges that would be required to create its component objects. For many extensions this means superuser privileges are needed. However, if the extension is marked &lt;em&gt;trusted&lt;/em&gt; in its control file, then it can be installed by any user who has &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. In this case the extension object itself will be owned by the calling user, but the contained objects will be owned by the bootstrap superuser (unless the extension's script explicitly assigns them to the calling user). This configuration gives the calling user the right to drop the extension, but not to modify individual objects within it.</source>
          <target state="translated">Loading an extension ordinarily requires the same privileges that would be required to create its component objects. For many extensions this means superuser privileges are needed. However, if the extension is marked &lt;em&gt;trusted&lt;/em&gt; in its control file, then it can be installed by any user who has &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. In this case the extension object itself will be owned by the calling user, but the contained objects will be owned by the bootstrap superuser (unless the extension's script explicitly assigns them to the calling user). This configuration gives the calling user the right to drop the extension, but not to modify individual objects within it.</target>
        </trans-unit>
        <trans-unit id="324780c29ae9b46671035da5fbfcca3eeeaa0b74" translate="yes" xml:space="preserve">
          <source>Loading an extension requires the same privileges that would be required to create its component objects. For most extensions this means superuser or database owner privileges are needed. The user who runs &lt;code&gt;CREATE EXTENSION&lt;/code&gt; becomes the owner of the extension for purposes of later privilege checks, as well as the owner of any objects created by the extension's script.</source>
          <target state="translated">拡張機能をロードするには、そのコンポーネントオブジェクトを作成するために必要な権限と同じ権限が必要です。ほとんどの拡張機能では、これはスーパーユーザーまたはデータベース所有者の権限が必要であることを意味します。 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; を実行するユーザーは、後の特権チェックのための拡張の所有者、および拡張のスクリプトによって作成されたオブジェクトの所有者になります。</target>
        </trans-unit>
        <trans-unit id="1ff55ba6c7cc873988ea156302dfd04284604724" translate="yes" xml:space="preserve">
          <source>Locale Support</source>
          <target state="translated">ローカルサポート</target>
        </trans-unit>
        <trans-unit id="1615ae9075efc2383f73fbc3997d85cdd39b60c0" translate="yes" xml:space="preserve">
          <source>Locale support is automatically initialized when a database cluster is created using &lt;code&gt;initdb&lt;/code&gt;. &lt;code&gt;initdb&lt;/code&gt; will initialize the database cluster with the locale setting of its execution environment by default, so if your system is already set to use the locale that you want in your database cluster then there is nothing else you need to do. If you want to use a different locale (or you are not sure which locale your system is set to), you can instruct &lt;code&gt;initdb&lt;/code&gt; exactly which locale to use by specifying the &lt;code&gt;--locale&lt;/code&gt; option. For example:</source>
          <target state="translated">&lt;code&gt;initdb&lt;/code&gt; を使用してデータベースクラスターが作成されると、ロケールサポートは自動的に初期化されます。 &lt;code&gt;initdb&lt;/code&gt; は、デフォルトで実行環境のロケール設定を使用してデータベースクラスターを初期化します。そのため、システムがデータベースクラスターで必要なロケールを使用するようにすでに設定されている場合は、他に必要な作業はありません。別のロケールを使用する場合（またはシステムがどのロケールに設定されているかわからない場合）は、 &lt;code&gt;--locale&lt;/code&gt; オプションを指定して、使用するロケールを &lt;code&gt;initdb&lt;/code&gt; に正確に指示できます。例えば：</target>
        </trans-unit>
        <trans-unit id="b9fc941160f1b0396956bfd39853ec712bd8d1fb" translate="yes" xml:space="preserve">
          <source>Localization</source>
          <target state="translated">Localization</target>
        </trans-unit>
        <trans-unit id="405016b1820c348aea5cd317a6502812cdf4ad22" translate="yes" xml:space="preserve">
          <source>Location of root page (zero if none)</source>
          <target state="translated">ルートページの場所 (ない場合はゼロ)</target>
        </trans-unit>
        <trans-unit id="24d45a6df98cb6f2c1180b96048b79a73fa5f768" translate="yes" xml:space="preserve">
          <source>Location of specified substring</source>
          <target state="translated">指定された部分文字列の位置</target>
        </trans-unit>
        <trans-unit id="dbb39d513ae60400b7ebae4d62c9e5ac6f77044b" translate="yes" xml:space="preserve">
          <source>Location of specified substring (same as &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt;, but note the reversed argument order)</source>
          <target state="translated">指定された部分文字列の &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt; と同じですが、引数の順序が逆になっていることに注意してください）</target>
        </trans-unit>
        <trans-unit id="9c2e448b0989a5090dc489ea6de417d94cf811c0" translate="yes" xml:space="preserve">
          <source>LocationIndex</source>
          <target state="translated">LocationIndex</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="c804bf0349b9527944ec4a3fe74284d562dd49b7" translate="yes" xml:space="preserve">
          <source>Lock Management</source>
          <target state="translated">ロック管理</target>
        </trans-unit>
        <trans-unit id="9f5be0c66691f0334e7d2037502bfeef360b9c5d" translate="yes" xml:space="preserve">
          <source>Lock mode of lockers (more than one if multitransaction), an array of &lt;code&gt;Key Share&lt;/code&gt;, &lt;code&gt;Share&lt;/code&gt;, &lt;code&gt;For No Key Update&lt;/code&gt;, &lt;code&gt;No Key Update&lt;/code&gt;, &lt;code&gt;For Update&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;.</source>
          <target state="translated">ロッカーのロックモード（マルチトランザクションの場合、複数）の配列 &lt;code&gt;Key Share&lt;/code&gt; 、 &lt;code&gt;Share&lt;/code&gt; 、 &lt;code&gt;For No Key Update&lt;/code&gt; 、 &lt;code&gt;No Key Update&lt;/code&gt; 、 &lt;code&gt;For Update&lt;/code&gt; 、 &lt;code&gt;Update&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9404601307758cbcb4a22750c03c625138fcfc8" translate="yes" xml:space="preserve">
          <source>Locking and Indexes</source>
          <target state="translated">ロックとインデックス</target>
        </trans-unit>
        <trans-unit id="8804d3dd97270b8420c7ca1e904a01e8634cbbf1" translate="yes" xml:space="preserve">
          <source>Locking the regular and/or predicate lock manager could have some impact on database performance if this view is very frequently accessed. The locks are held only for the minimum amount of time necessary to obtain data from the lock managers, but this does not completely eliminate the possibility of a performance impact.</source>
          <target state="translated">このビューが非常に頻繁にアクセスされる場合、通常のロックマネージャおよび/または述語ロックマネージャをロックすると、データベースのパフォーマンスに何らかの影響を与える可能性があります。ロックは、ロックマネージャからデータを取得するのに必要な最小限の時間だけ保持されますが、これによってパフォーマンスに影響が出る可能性が完全になくなるわけではありません。</target>
        </trans-unit>
        <trans-unit id="737c6c38b2b84007c82ea914cea8efb3178d5fdf" translate="yes" xml:space="preserve">
          <source>Log File Maintenance</source>
          <target state="translated">ログファイルのメンテナンス</target>
        </trans-unit>
        <trans-unit id="6d6b239b122bc0b05311eb6dfbfaaf45f232b9f3" translate="yes" xml:space="preserve">
          <source>Log Sequence Number, see &lt;a href=&quot;datatype-pg-lsn&quot;&gt;&lt;code&gt;pg_lsn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;wal-internals&quot;&gt;WAL Internals&lt;/a&gt;.</source>
          <target state="translated">ログシーケンス番号&lt;a href=&quot;datatype-pg-lsn&quot;&gt; &lt;code&gt;pg_lsn&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;wal-internals&quot;&gt;WALの内部を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="60c1e625e1e8d8bc204338911a42295c282dd7d9" translate="yes" xml:space="preserve">
          <source>Log file</source>
          <target state="translated">ログファイル</target>
        </trans-unit>
        <trans-unit id="4f0a509232d18cc09dfcbf97250e9485bbc40c4c" translate="yes" xml:space="preserve">
          <source>Log files contain human-readable text lines about events. Examples include login failures, long-running queries, etc.</source>
          <target state="translated">ログファイルには、イベントに関する人間が読めるテキスト行が含まれています。例としては、ログインの失敗、長時間実行されるクエリなどがあります。</target>
        </trans-unit>
        <trans-unit id="ac059a4497d87893d31436f7f08f37f59c88514b" translate="yes" xml:space="preserve">
          <source>Log record</source>
          <target state="translated">ログレコード</target>
        </trans-unit>
        <trans-unit id="d305d15801e1e955744206adafaf8f3e3d1bb78e" translate="yes" xml:space="preserve">
          <source>Log-Shipping Standby Servers</source>
          <target state="translated">ログシッピングスタンバイサーバー</target>
        </trans-unit>
        <trans-unit id="e22cd962d5d7b24a566d7837fcf6043185781e24" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt; to base &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">Logarithm of &lt;em&gt; &lt;code&gt;x&lt;/code&gt; &lt;/em&gt; to base &lt;em&gt; &lt;code&gt;b&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="567a04e87e0264325ea2d8341bf4b0ffb622ca3f" translate="yes" xml:space="preserve">
          <source>Logged</source>
          <target state="translated">Logged</target>
        </trans-unit>
        <trans-unit id="668f966ac31eb810f98d105493f1c5cdc3067858" translate="yes" xml:space="preserve">
          <source>Logger (process)</source>
          <target state="translated">ロガー(プロセス</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">論理 AND</target>
        </trans-unit>
        <trans-unit id="2445214b8389f14bf2045be1111d0264af049737" translate="yes" xml:space="preserve">
          <source>Logical Decoding</source>
          <target state="translated">論理復号化</target>
        </trans-unit>
        <trans-unit id="e7e803ba6df9ebf5f542bc2b7ce91db2dc559f7e" translate="yes" xml:space="preserve">
          <source>Logical NOT</source>
          <target state="translated">論理 NOT</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">論理和</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">論理演算子</target>
        </trans-unit>
        <trans-unit id="e81affcc4578ce875d0e0b75ca689bf2f32a90ae" translate="yes" xml:space="preserve">
          <source>Logical Operators: AND</source>
          <target state="translated">論理演算子。AND</target>
        </trans-unit>
        <trans-unit id="43e083b90a70b3c47c8f0041d3ea2af4e65c51e3" translate="yes" xml:space="preserve">
          <source>Logical Operators: NOT</source>
          <target state="translated">論理演算子。NOT</target>
        </trans-unit>
        <trans-unit id="d639dd9302fac485c5ef253dceb1e3f97c540d72" translate="yes" xml:space="preserve">
          <source>Logical Operators: OR</source>
          <target state="translated">論理演算子。OR</target>
        </trans-unit>
        <trans-unit id="87801dc1bcd5e1df0b7d1f2272c64ee5b039c930" translate="yes" xml:space="preserve">
          <source>Logical Repl.</source>
          <target state="translated">ロジカルレプリカ</target>
        </trans-unit>
        <trans-unit id="b3d8aa18dbe5d539b67385e1079b7cb40cef477e" translate="yes" xml:space="preserve">
          <source>Logical Replication</source>
          <target state="translated">ろんりてきレプリケーション</target>
        </trans-unit>
        <trans-unit id="8922d517c58eafe0151a7cf981679470b4600e69" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">論理デコードを使用して、&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;ストリーミングレプリケーションの&lt;/a&gt;同期レプリケーションと同じユーザーインターフェイスで&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;同期レプリケーション&lt;/a&gt;ソリューションを構築できます。これを行うには、ストリーミングレプリケーションインターフェース（&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-walsender.html&quot;&gt;セクション48.3を&lt;/a&gt;参照）を使用してデータをストリーミングする必要があります。ストリーミングレプリケーションクライアントと同様に、クライアントは &lt;code&gt;Standby status update (F)&lt;/code&gt; （&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4を&lt;/a&gt;参照）メッセージを送信する必要があります。</target>
        </trans-unit>
        <trans-unit id="f503cf64b38f12bede3e30319a09deafda284c40" translate="yes" xml:space="preserve">
          <source>Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</source>
          <target state="translated">Logical decoding can be used to build &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;synchronous replication&lt;/a&gt; solutions with the same user interface as synchronous replication for &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;streaming replication&lt;/a&gt;. To do this, the streaming replication interface (see &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-walsender.html&quot;&gt;Section 48.3&lt;/a&gt;) must be used to stream out data. Clients have to send &lt;code&gt;Standby status update (F)&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;) messages, just like streaming replication clients do.</target>
        </trans-unit>
        <trans-unit id="7b10ab294a9b68fd1f46ed7bc6062a04492e6157" translate="yes" xml:space="preserve">
          <source>Logical group of the parameter</source>
          <target state="translated">パラメータの論理グループ</target>
        </trans-unit>
        <trans-unit id="c580b15c66ecbba918b3e32fb395e268ced977ef" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">論理レプリケーションにより、データベースサーバーはデータ変更のストリームを別のサーバーに送信できます。 PostgreSQL論理レプリケーションは、WALから論理データ変更のストリームを構築します。論理レプリケーションでは、個々のテーブルからのデータ変更をレプリケートできます。論理レプリケーションでは、特定のサーバーをマスターまたはレプリカとして指定する必要はありませんが、データを多方向に流すことができます。論理複製の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章を&lt;/a&gt;参照してください。論理デコードインターフェイス（&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章&lt;/a&gt;）を通じて、サードパーティの拡張機能も同様の機能を提供できます。</target>
        </trans-unit>
        <trans-unit id="efdfc15536907810b351505bdffe988864a38656" translate="yes" xml:space="preserve">
          <source>Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</source>
          <target state="translated">Logical replication allows a database server to send a stream of data modifications to another server. PostgreSQL logical replication constructs a stream of logical data modifications from the WAL. Logical replication allows the data changes from individual tables to be replicated. Logical replication doesn't require a particular server to be designated as a master or a replica but allows data to flow in multiple directions. For more information on logical replication, see &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;. Through the logical decoding interface (&lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;), third-party extensions can also provide similar functionality.</target>
        </trans-unit>
        <trans-unit id="ed65fe8b9917e90ed44964dea1e1dc23e674a9f1" translate="yes" xml:space="preserve">
          <source>Logical replication behaves similarly to normal DML operations in that the data will be updated even if it was changed locally on the subscriber node. If incoming data violates any constraints the replication will stop. This is referred to as a &lt;em&gt;conflict&lt;/em&gt;. When replicating &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations, missing data will not produce a conflict and such operations will simply be skipped.</source>
          <target state="translated">論理複製は、データがサブスクライバーノードでローカルに変更された場合でもデータが更新されるという点で、通常のDML操作と同様に動作します。受信データが制約に違反すると、レプリケーションが停止します。これは、&lt;em&gt;競合&lt;/em&gt;と呼ばれます。 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作を複製する場合、欠落しているデータによって競合が生じることはなく、そのような操作は単にスキップされます。</target>
        </trans-unit>
        <trans-unit id="686d57c78ae4b376c0e25252dd6b05a5049c2f9c" translate="yes" xml:space="preserve">
          <source>Logical replication currently has the following restrictions or missing functionality. These might be addressed in future releases.</source>
          <target state="translated">現在のところ、論理レプリケーションには以下のような制限や機能があります。これらは将来のリリースで対処される可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc5341d79f09d707679a0da10e711069ef1d9d1a" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">論理レプリケーションは、物理ストリーミングレプリケーションと同様のアーキテクチャで構築されています（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）。 「walsender」および「apply」プロセスによって実装されます。 walsenderプロセスは、WALの論理デコード（&lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding.html&quot;&gt;第48章で&lt;/a&gt;説明）を開始し、標準の論理デコードプラグイン（pgoutput）をロードします。プラグインは、WALから読み取った変更を論理レプリケーションプロトコル（&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-logical-replication.html&quot;&gt;セクション52.5を&lt;/a&gt;参照）に変換し、パブリケーションの仕様に従ってデータをフィルタリングします。その後、データはストリーミングレプリケーションプロトコルを使用して適用ワーカーに継続的に転送されます。適用ワーカーは、データをローカルテーブルにマップし、受信した個々の変更を正しいトランザクション順序で適用します。</target>
        </trans-unit>
        <trans-unit id="24f246c37056cfc3d645585b0f76929bd8ff75af" translate="yes" xml:space="preserve">
          <source>Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</source>
          <target state="translated">Logical replication is built with an architecture similar to physical streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). It is implemented by &amp;ldquo;walsender&amp;rdquo; and &amp;ldquo;apply&amp;rdquo; processes. The walsender process starts logical decoding (described in &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding.html&quot;&gt;Chapter 48&lt;/a&gt;) of the WAL and loads the standard logical decoding plugin (pgoutput). The plugin transforms the changes read from WAL to the logical replication protocol (see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-logical-replication.html&quot;&gt;Section 52.5&lt;/a&gt;) and filters the data according to the publication specification. The data is then continuously transferred using the streaming replication protocol to the apply worker, which maps the data to local tables and applies the individual changes as they are received, in correct transactional order.</target>
        </trans-unit>
        <trans-unit id="435079a68c735c2e34e8587daebbc03ec2b4108b" translate="yes" xml:space="preserve">
          <source>Logical replication requires several configuration options to be set.</source>
          <target state="translated">論理レプリケーションでは、いくつかの構成オプションを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e84a093ac80e997279a156ad3e78ff218f69bfc7" translate="yes" xml:space="preserve">
          <source>Logical replication starts by copying a snapshot of the data on the publisher database. Once that is done, changes on the publisher are sent to the subscriber as they occur in real time. The subscriber applies data in the order in which commits were made on the publisher so that transactional consistency is guaranteed for the publications within any single subscription.</source>
          <target state="translated">論理レプリケーションは、パブリッシャーデータベース上のデータのスナップショットをコピーすることから始まります。これが完了すると、パブリッシャー上の変更がリアルタイムで発生すると、サブスクライバーに送信されます。購読者は、パブリッシャー上でコミットが行われた順番でデータを適用するため、単一のサブスクリプション内のパブリッシャーに対してトランザクションの一貫性が保証されます。</target>
        </trans-unit>
        <trans-unit id="27b9470b0624c147b034592fe3f3a73182a2151c" translate="yes" xml:space="preserve">
          <source>Logical replication workers are taken from the pool defined by &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">論理レプリケーションワーカーは、 &lt;code&gt;max_worker_processes&lt;/code&gt; で定義されたプールから取得されます。</target>
        </trans-unit>
        <trans-unit id="a63c3a3aa22b3789bd62013d2f279dd236a57e8e" translate="yes" xml:space="preserve">
          <source>Londiste, Slony</source>
          <target state="translated">ロンディスト、スロニー</target>
        </trans-unit>
        <trans-unit id="7ed5823bb2b8c30b7d42594563eaf3c04e339fc5" translate="yes" xml:space="preserve">
          <source>Look at &lt;code&gt;xsyn_sample.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt;, for an example.</source>
          <target state="translated">例として、 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; にインストールされている &lt;code&gt;xsyn_sample.rules&lt;/code&gt; を見てください。</target>
        </trans-unit>
        <trans-unit id="ca517b17b581321c398ee4798749fdb48a7ae7a7" translate="yes" xml:space="preserve">
          <source>Look at the new state of the data:</source>
          <target state="translated">データの新しい状態を見てください。</target>
        </trans-unit>
        <trans-unit id="30d58e04409362da5a524652a2e000a29c4e8c15" translate="yes" xml:space="preserve">
          <source>Look for the best match.</source>
          <target state="translated">ベストマッチを探してください。</target>
        </trans-unit>
        <trans-unit id="6a2e689d9886aec21b389565fdc3ad34371dc41e" translate="yes" xml:space="preserve">
          <source>Lookahead and lookbehind constraints cannot contain &lt;em&gt;back references&lt;/em&gt; (see &lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;Section 9.7.3.3&lt;/a&gt;), and all parentheses within them are considered non-capturing.</source>
          <target state="translated">先読み制約と後読み制約に&lt;em&gt;後方参照を&lt;/em&gt;含めることはできず（&lt;a href=&quot;functions-matching#POSIX-ESCAPE-SEQUENCES&quot;&gt;セクション9.7.3.3を&lt;/a&gt;参照）、その中の括弧はすべて非キャプチャと見なされます。</target>
        </trans-unit>
        <trans-unit id="5078c384be6b302db7193d0145acae3ffddd4617" translate="yes" xml:space="preserve">
          <source>Looks up a replication origin by name and returns the internal ID. If no such replication origin is found an error is thrown.</source>
          <target state="translated">名前でレプリケーションオリジンを検索し、内部 ID を返します。そのようなレプリケーションオリジンが見つからない場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="56e8f3a9171c421d0883280c2cd97e28c0e45385" translate="yes" xml:space="preserve">
          <source>Lookup a replication origin by name and return the internal id. If no corresponding replication origin is found an error is thrown.</source>
          <target state="translated">レプリケーションオリジンを名前で検索し、内部 ID を返します。対応するレプリケーションオリジンが見つからない場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="55e4cc0e110df2ac3459453907e4bd26c086ff4d" translate="yes" xml:space="preserve">
          <source>Lossiness causes performance degradation due to unnecessary fetches of table records that turn out to be false matches. Since random access to table records is slow, this limits the usefulness of GiST indexes. The likelihood of false matches depends on several factors, in particular the number of unique words, so using dictionaries to reduce this number is recommended.</source>
          <target state="translated">損失は、テーブルレコードの不必要なフェッチにより、偽マッチであることが判明するため、パフォーマンスの低下を引き起こします。テーブルレコードへのランダムアクセスは遅いので、これはGiSTインデックスの有用性を制限します。誤一致の可能性は、いくつかの要因、特に一意な単語の数に依存するので、この数を減らすために辞書を使用することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="1531c1daacaf1bc409855b8d1d0f55e08ee771dd" translate="yes" xml:space="preserve">
          <source>Low Value</source>
          <target state="translated">低価格</target>
        </trans-unit>
        <trans-unit id="21ceb119d4d9e001890111b5576f7f16ef00c26f" translate="yes" xml:space="preserve">
          <source>Low level base backups can be made in a non-exclusive or an exclusive way. The non-exclusive method is recommended and the exclusive one is deprecated and will eventually be removed.</source>
          <target state="translated">低レベルのベースバックアップは、非排他的または排他的な方法で行うことができます。非排他的な方法が推奨され、排他的な方法は非推奨であり、最終的には削除されます。</target>
        </trans-unit>
        <trans-unit id="bddc7c31834ef546bcfbe24e4c18d4afaf657eb8" translate="yes" xml:space="preserve">
          <source>Lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back and dead.</source>
          <target state="translated">Lowest transaction ID that was still active. All transaction IDs less than &lt;code&gt;xmin&lt;/code&gt; are either committed and visible, or rolled back and dead.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="ac4243ecb01964253411eb3c09a126fc164e78e2" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address</source>
          <target state="translated">MAC(メディアアクセスコントロール)アドレス</target>
        </trans-unit>
        <trans-unit id="566c47d211683b88f50af170e2aa6203ef55b10a" translate="yes" xml:space="preserve">
          <source>MAC (Media Access Control) address (EUI-64 format)</source>
          <target state="translated">MAC(メディアアクセス制御)アドレス(EUI-64形式</target>
        </trans-unit>
        <trans-unit id="b3c62ec9e889671f1211f3670d9feb61fe45a931" translate="yes" xml:space="preserve">
          <source>MAC addresses</source>
          <target state="translated">MACアドレス</target>
        </trans-unit>
        <trans-unit id="22afa78dd9eba1a7e4c213c3623011af13b757a5" translate="yes" xml:space="preserve">
          <source>MAC addresses (EUI-64 format)</source>
          <target state="translated">MACアドレス(EUI-64形式</target>
        </trans-unit>
        <trans-unit id="1c27d6be2a8de3b4e76dde98311054d012ea27ef" translate="yes" xml:space="preserve">
          <source>MCV (most-common values) list statistics, serialized as &lt;code&gt;pg_mcv_list&lt;/code&gt; type</source>
          <target state="translated">MCV（最も一般的な値）リストの統計、 &lt;code&gt;pg_mcv_list&lt;/code&gt; タイプとしてシリアル化</target>
        </trans-unit>
        <trans-unit id="b773bed04a48de200b96981bb79467413a222066" translate="yes" xml:space="preserve">
          <source>MD5</source>
          <target state="translated">MD5</target>
        </trans-unit>
        <trans-unit id="43a2b4962eca5b9cc86e8c34c251b4aaf74d69de" translate="yes" xml:space="preserve">
          <source>MD5 crypt</source>
          <target state="translated">MD5 crypt</target>
        </trans-unit>
        <trans-unit id="b7800f24354ba47ad5de45633c8b73e60e95cf0f" translate="yes" xml:space="preserve">
          <source>MD5 hash and SHA1</source>
          <target state="translated">MD5 ハッシュと SHA1</target>
        </trans-unit>
        <trans-unit id="609399527c0412d282c04a9855b05c67f3f4ed44" translate="yes" xml:space="preserve">
          <source>MD5-based crypt</source>
          <target state="translated">MD5 ベースの暗号</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="ab3eeea11f18e2650760cfbc2a9ee637afed8340" translate="yes" xml:space="preserve">
          <source>MOVE &amp;mdash; position a cursor</source>
          <target state="translated">MOVE &amp;mdash;カーソルを配置する</target>
        </trans-unit>
        <trans-unit id="29f17acbc2455f9f492968fd0bda5a0de71679d9" translate="yes" xml:space="preserve">
          <source>MSVC</source>
          <target state="translated">MSVC</target>
        </trans-unit>
        <trans-unit id="a967eb92e41a009b9209426313752a674c43be15" translate="yes" xml:space="preserve">
          <source>MVCC</source>
          <target state="translated">MVCC</target>
        </trans-unit>
        <trans-unit id="f7f38fb90552f61a802690d695bfa4d9b25df00e" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">メッセージ翻訳のカタログを維持するには、PostgreSQLが自分の好みの言語を上手に話すことを望んでいる多くのボランティアの継続的な努力が必要です。あなたの言語のメッセージが現在利用できないか、完全に翻訳されていない場合は、ご協力いただければ幸いです。手助けが必要な場合は、&lt;a href=&quot;https://www.postgresql.org/docs/12/nls.html&quot;&gt;第54章を&lt;/a&gt;参照するか、開発者のメーリングリストに投稿してください。</target>
        </trans-unit>
        <trans-unit id="7106741f20d440f998ee112429f77e03e33f6395" translate="yes" xml:space="preserve">
          <source>Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</source>
          <target state="translated">Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see PostgreSQL speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/nls.html&quot;&gt;Chapter 54&lt;/a&gt; or write to the developers' mailing list.</target>
        </trans-unit>
        <trans-unit id="94de303bbef8935622224c5db48199c807ab7d71" translate="yes" xml:space="preserve">
          <source>Maintenance</source>
          <target state="translated">Maintenance</target>
        </trans-unit>
        <trans-unit id="dce34191f69ff984184a7501bc8f6215cc2b1283" translate="yes" xml:space="preserve">
          <source>Maintenance commands - &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">メンテナンスコマンド- &lt;code&gt;ANALYZE&lt;/code&gt; 、 &lt;code&gt;VACUUM&lt;/code&gt; 、 &lt;code&gt;CLUSTER&lt;/code&gt; 、 &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="292d556449f6baefbefbc7a2798464550e97b523" translate="yes" xml:space="preserve">
          <source>Maintenance commands: &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;</source>
          <target state="translated">Maintenance commands: &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="477597b3a5e3545e4aafdda2f2a69a40df682681" translate="yes" xml:space="preserve">
          <source>Major PostgreSQL releases regularly add new features that often change the layout of the system tables, but the internal data storage format rarely changes. pg_upgrade uses this fact to perform rapid upgrades by creating new system tables and simply reusing the old user data files. If a future major release ever changes the data storage format in a way that makes the old data format unreadable, pg_upgrade will not be usable for such upgrades. (The community will attempt to avoid such situations.)</source>
          <target state="translated">PostgreSQLのメジャーリリースでは定期的に新機能が追加され、システムテーブルのレイアウトが変更されることがよくありますが、内部データ保存形式が変更されることはほとんどありません。 pg_upgradeはこの事実を利用して、新しいシステムテーブルを作成し、古いユーザデータファイルを単純に再利用することで迅速なアップグレードを実行します。将来のメジャーリリースで、古いデータ形式が読めなくなるような方法でデータ保存形式が変更された場合、pg_upgradeはそのようなアップグレードには使用できません。(コミュニティはそのような状況を避けるように努めます)。</target>
        </trans-unit>
        <trans-unit id="634be9b233dfc40349e54f6799f11f557bdc5c75" translate="yes" xml:space="preserve">
          <source>Make a base backup of the primary server (see &lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;Section 25.3.2&lt;/a&gt;), and load this data onto the standby.</source>
          <target state="translated">プライマリ・サーバーのベース・バックアップを作成し（&lt;a href=&quot;continuous-archiving#BACKUP-BASE-BACKUP&quot;&gt;項25.3.2を&lt;/a&gt;参照）、このデータをスタンバイにロードします。</target>
        </trans-unit>
        <trans-unit id="63a128e9fdffb0bd6c880f9009ba685205efe3c8" translate="yes" xml:space="preserve">
          <source>Make a password valid forever:</source>
          <target state="translated">パスワードは永遠に有効なものにしてください。</target>
        </trans-unit>
        <trans-unit id="3d352bc98e86554b9f8e7bb50ec4f35c4891b735" translate="yes" xml:space="preserve">
          <source>Make sure both database servers are stopped using, on Unix, e.g.:</source>
          <target state="translated">Unixの場合、両方のデータベースサーバの使用が停止していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="b9eb7d5c96a8c5d308e0b19059ab781c2cbe473e" translate="yes" xml:space="preserve">
          <source>Make sure that your server keytab file is readable (and preferably only readable, not writable) by the PostgreSQL server account. (See also &lt;a href=&quot;postgres-user&quot;&gt;Section 18.1&lt;/a&gt;.) The location of the key file is specified by the &lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt; configuration parameter. The default is &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; (or whatever directory was specified as &lt;code&gt;sysconfdir&lt;/code&gt; at build time). For security reasons, it is recommended to use a separate keytab just for the PostgreSQL server rather than opening up permissions on the system keytab file.</source>
          <target state="translated">サーバーのキータブファイルがPostgreSQLサーバーアカウントで読み取り可能（できれば読み取りのみで、書き込み不可）であることを確認してください。 （&lt;a href=&quot;postgres-user&quot;&gt;セクション18.1&lt;/a&gt;も参照してください。）鍵ファイルの場所は、&lt;a href=&quot;runtime-config-connection#GUC-KRB-SERVER-KEYFILE&quot;&gt;krb_server_keyfile&lt;/a&gt;構成パラメーターによって指定されます。デフォルトは &lt;code&gt;/usr/local/pgsql/etc/krb5.keytab&lt;/code&gt; （またはビルド時に &lt;code&gt;sysconfdir&lt;/code&gt; として指定されたディレクトリ）です。セキュリティ上の理由から、システムのキータブファイルの権限を開くのではなく、PostgreSQLサーバー専用の別のキータブを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c85ef738c1ba87c2190fc933e484d7ebb7fc1d3b" translate="yes" xml:space="preserve">
          <source>Make sure that your session does not hold more locks than necessary when calling &lt;code&gt;pg_sleep&lt;/code&gt; or its variants. Otherwise other sessions might have to wait for your sleeping process, slowing down the entire system.</source>
          <target state="translated">&lt;code&gt;pg_sleep&lt;/code&gt; またはそのバリアントを呼び出すときに、セッションが必要以上のロックを保持していないことを確認してください。そうしないと、他のセッションがスリーププロセスを待たなければならず、システム全体の速度が低下する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d7b3ea8ab3afc4ab9fbece610d0afa1cdefe9215" translate="yes" xml:space="preserve">
          <source>Make sure the new binaries and support files are installed on all standby servers.</source>
          <target state="translated">新しいバイナリとサポートファイルがすべての待機サーバーにインストールされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="4be89cba4680b61369e645efc68f83ec81c167f1" translate="yes" xml:space="preserve">
          <source>Make sure the new standby data directories do &lt;em&gt;not&lt;/em&gt; exist or are empty. If initdb was run, delete the standby servers' new data directories.</source>
          <target state="translated">新しいスタンバイデータディレクトリが存在し&lt;em&gt;ない&lt;/em&gt;か、空であることを確認してください。initdbを実行した場合は、スタンバイサーバーの新しいデータディレクトリを削除します。</target>
        </trans-unit>
        <trans-unit id="173d02f923c11447cf74a27c2960de0e28e12c9b" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; prompt for a password to give the database superuser. If you don't plan on using password authentication, this is not important. Otherwise you won't be able to use password authentication until you have a password set up.</source>
          <target state="translated">作るには、 &lt;code&gt;initdb&lt;/code&gt; がデータベースのスーパーユーザ権限を与えるためのパスワードのプロンプト。パスワード認証を使用する予定がない場合、これは重要ではありません。そうしないと、パスワードを設定するまでパスワード認証を使用できません。</target>
        </trans-unit>
        <trans-unit id="792a9e540ae77e4ca51fdc9b34493d77aa427a96" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;initdb&lt;/code&gt; read the database superuser's password from a file. The first line of the file is taken as the password.</source>
          <target state="translated">作るには、 &lt;code&gt;initdb&lt;/code&gt; をファイルからデータベースのスーパーユーザのパスワードをお読みください。ファイルの最初の行がパスワードとして使用されます。</target>
        </trans-unit>
        <trans-unit id="272e7aa108f37caed38de50c7bbbc12a4eeb39f5" translate="yes" xml:space="preserve">
          <source>Makes a cube with upper right and lower left coordinates as defined by the two arrays, which must be of the same length.</source>
          <target state="translated">2 つの配列で定義された右上と左下の座標を持つ立方体を作成します。</target>
        </trans-unit>
        <trans-unit id="7896b684cd247a71e6d914ea864835f0a201cfd2" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube, with the same values for both endpoints of the new coordinate. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">既存のキューブにディメンジョンを追加して新しいキューブを作成します。これは、計算された値から 1 つずつキューブを構築する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="43a84f11220bc7ec3aa6c412b1e43c3f1a62c52f" translate="yes" xml:space="preserve">
          <source>Makes a new cube by adding a dimension on to an existing cube. This is useful for building cubes piece by piece from calculated values.</source>
          <target state="translated">既存のキューブにディメンジョンを追加して新しいキューブを作成します。これは、計算された値からキューブを 1 つ 1 つ構築するのに便利です。</target>
        </trans-unit>
        <trans-unit id="cec244b05a82755211877f23eb89341a3e2a9049" translate="yes" xml:space="preserve">
          <source>Makes a new cube from an existing cube, using a list of dimension indexes from an array. Can be used to extract the endpoints of a single dimension, or to drop dimensions, or to reorder them as desired.</source>
          <target state="translated">配列からのディメンジョン・インデックスのリストを使用して、既存のキューブから新しいキューブを作成します。これを使用して、単一ディメンジョンのエンドポイントを抽出したり、ディメンジョンを削除したり、必要に応じて並べ替えたりできます。</target>
        </trans-unit>
        <trans-unit id="7c70237aa382dcfcb4e30da44d32fffb86de7855" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube with both coordinates the same.</source>
          <target state="translated">両方の座標を同じにした一次元立方体を作成します。</target>
        </trans-unit>
        <trans-unit id="36186a49b5b2bc93a1e3ef40c1a52eabef758439" translate="yes" xml:space="preserve">
          <source>Makes a one dimensional cube.</source>
          <target state="translated">一次元の立方体を作成します。</target>
        </trans-unit>
        <trans-unit id="fa2638ba09b880989be4b7b3a19ea5c423840179" translate="yes" xml:space="preserve">
          <source>Makes a single-element array.</source>
          <target state="translated">単一要素の配列を作成します。</target>
        </trans-unit>
        <trans-unit id="aae8d3b9540c85c4e0f867bbcd6f86be7f07d237" translate="yes" xml:space="preserve">
          <source>Makes a single-item &lt;code&gt;hstore&lt;/code&gt;.</source>
          <target state="translated">Makes a single-item &lt;code&gt;hstore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c491ded092df3548669d7b1b5d203277eaee1f2e" translate="yes" xml:space="preserve">
          <source>Makes a zero-volume cube using the coordinates defined by the array.</source>
          <target state="translated">配列で定義された座標を使用して、ゼロボリューム・キューブを作成します。</target>
        </trans-unit>
        <trans-unit id="fefd6a2a56f64d38ec0468fc161189ce50419761" translate="yes" xml:space="preserve">
          <source>Making liberal use of views is a key aspect of good SQL database design. Views allow you to encapsulate the details of the structure of your tables, which might change as your application evolves, behind consistent interfaces.</source>
          <target state="translated">ビューを最大限に活用することは、優れたSQLデータベース設計の重要な側面です。ビューを使用することで、アプリケーションの進化に合わせて変化する可能性のあるテーブルの構造の詳細を、一貫したインターフェースの後ろにカプセル化することができます。</target>
        </trans-unit>
        <trans-unit id="f26b359ba37eb8a50cdf02456f39cff00b1155a4" translate="yes" xml:space="preserve">
          <source>Managing Databases</source>
          <target state="translated">データベースの管理</target>
        </trans-unit>
        <trans-unit id="efd2c6be94610f9dd5980e65687b83de3d52e077" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources</source>
          <target state="translated">カーネルリソースの管理</target>
        </trans-unit>
        <trans-unit id="9edd256f8994898f1394cd9f5902a2fe3a3418a1" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Huge Pages</source>
          <target state="translated">カーネルリソースの管理。Linux の巨大なページ</target>
        </trans-unit>
        <trans-unit id="f84c08e43ab5092b16e87ebd218788d5283b9b4a" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Linux Memory Overcommit</source>
          <target state="translated">カーネルリソースの管理 Linux メモリのオーバーコミット</target>
        </trans-unit>
        <trans-unit id="412c9a22726797c7f1da88a5ca11bb92ea162415" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Resource Limits</source>
          <target state="translated">カーネルリソースの管理 リソースの制限</target>
        </trans-unit>
        <trans-unit id="fc3ccce80bea44ef80a6a994d4e4358186b901da" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: Shared Memory and Semaphores</source>
          <target state="translated">カーネルリソースの管理。共有メモリとセマフォ</target>
        </trans-unit>
        <trans-unit id="67cd2bd0c8dc97a476e8e47ebb9371727475113d" translate="yes" xml:space="preserve">
          <source>Managing Kernel Resources: systemd RemoveIPC</source>
          <target state="translated">カーネルリソースの管理:systemd RemoveIPC</target>
        </trans-unit>
        <trans-unit id="67c48d67ef7ae304937a0a8de822ed104f4b2eb2" translate="yes" xml:space="preserve">
          <source>Manually set the WAL starting location by specifying the name of the next WAL segment file.</source>
          <target state="translated">次のWALセグメントファイル名を指定してWAL開始位置を手動で設定します。</target>
        </trans-unit>
        <trans-unit id="6ccaa7bcfd25bcb3a947594b5b5ad3594bebb3be" translate="yes" xml:space="preserve">
          <source>Manually set the next OID.</source>
          <target state="translated">次のOIDを手動で設定します。</target>
        </trans-unit>
        <trans-unit id="b11b4e5b2d203da27bc1c6504a10632af73bd3c8" translate="yes" xml:space="preserve">
          <source>Manually set the next and oldest multitransaction ID.</source>
          <target state="translated">次のマルチトランザクションIDと最古のマルチトランザクションIDを手動で設定します。</target>
        </trans-unit>
        <trans-unit id="05fcb9c1e9b6c68d58ec688a6b55b68af75801bf" translate="yes" xml:space="preserve">
          <source>Manually set the next multitransaction offset.</source>
          <target state="translated">次のマルチトランザクションのオフセットを手動で設定します。</target>
        </trans-unit>
        <trans-unit id="14870c8a6c58f7f0c07765537e62008b75b3dc73" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID's epoch.</source>
          <target state="translated">次のトランザクションIDのエポックを手動で設定します。</target>
        </trans-unit>
        <trans-unit id="4f4f1e99ced530ddd1fa0f7dac805a0ddcf54b22" translate="yes" xml:space="preserve">
          <source>Manually set the next transaction ID.</source>
          <target state="translated">次のトランザクションIDを手動で設定します。</target>
        </trans-unit>
        <trans-unit id="648bd7a8e83568d94a29f369df1e0064e881bb1c" translate="yes" xml:space="preserve">
          <source>Manually set the oldest and newest transaction IDs for which the commit time can be retrieved.</source>
          <target state="translated">コミット時間を取得できる最古と最新のトランザクションIDを手動で設定します。</target>
        </trans-unit>
        <trans-unit id="ff49c52c5651b25a87adf02de107946b0c6a1108" translate="yes" xml:space="preserve">
          <source>Manufacturers not currently having any products would not appear in the result, since it is an inner join. If we wished to include the names of such manufacturers in the result, we could do:</source>
          <target state="translated">これは内部結合であるため、現在製品を持っていないメーカーは結果に表示されません。もし、そのようなメーカーの名前を結果に含めたい場合は、そのようにすることができます。</target>
        </trans-unit>
        <trans-unit id="5d400bc2fffdc5a10db82b688a6346e4cf189544" translate="yes" xml:space="preserve">
          <source>Many database systems have the notion of a one to many table. Such a table usually sits between two indexed tables, for example:</source>
          <target state="translated">多くのデータベースシステムには、1対多のテーブルという概念があります。このようなテーブルは通常、例えば2つのインデックス付きテーブルの間に置かれます。</target>
        </trans-unit>
        <trans-unit id="95ffbad28eb7bf7f9a21d96e280ac0310171a900" translate="yes" xml:space="preserve">
          <source>Many developers consider explicitly listing the columns better style than relying on the order implicitly.</source>
          <target state="translated">多くの開発者は、暗黙のうちに順序に頼るよりも、明示的に列をリストアップした方が良いスタイルだと考えています。</target>
        </trans-unit>
        <trans-unit id="1cb82d9eaa9bf285209fa61fc5831409cba350d7" translate="yes" xml:space="preserve">
          <source>Many failover systems use just two systems, the primary and the standby, connected by some kind of heartbeat mechanism to continually verify the connectivity between the two and the viability of the primary. It is also possible to use a third system (called a witness server) to prevent some cases of inappropriate failover, but the additional complexity might not be worthwhile unless it is set up with sufficient care and rigorous testing.</source>
          <target state="translated">多くのフェイルオーバーシステムでは、プライマリとスタンバイの 2 つのシステムだけを使用しており、この 2 つのシステム間の接続性とプライマリの実行可能性を継続的に検証するために、ある種のハートビート機構で接続されている。不適切なフェイルオーバーのケースを防ぐために、第 3 のシステム(ウィットネス・サーバと呼ばれる)を使用することも可能ですが、十分な注意と厳格なテストを行って設定しない限り、追加の複雑さは価値がないかもしれません。</target>
        </trans-unit>
        <trans-unit id="de1e6960880fdbfac06a6878d8dd73d232d78b66" translate="yes" xml:space="preserve">
          <source>Many installations create their database clusters on file systems (volumes) other than the machine's &amp;ldquo;root&amp;rdquo; volume. If you choose to do this, it is not advisable to try to use the secondary volume's topmost directory (mount point) as the data directory. Best practice is to create a directory within the mount-point directory that is owned by the PostgreSQL user, and then create the data directory within that. This avoids permissions problems, particularly for operations such as pg_upgrade, and it also ensures clean failures if the secondary volume is taken offline.</source>
          <target state="translated">多くのインストールでは、マシンの「ルート」ボリューム以外のファイルシステム（ボリューム）にデータベースクラスタを作成します。これを行う場合は、セカンダリボリュームの最上位ディレクトリ（マウントポイント）をデータディレクトリとして使用することはお勧めできません。ベストプラクティスは、PostgreSQLユーザーが所有するマウントポイントディレクトリ内にディレクトリを作成し、その中にデータディレクトリを作成することです。これにより、特にpg_upgradeなどの操作での権限の問題が回避され、セカンダリボリュームがオフラインになった場合でもクリーンなエラーが保証されます。</target>
        </trans-unit>
        <trans-unit id="7998a6e83c9395997d176b8166f6ac50148a21ee" translate="yes" xml:space="preserve">
          <source>Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead/lookbehind constraints, and the longest/shortest-match (rather than first-match) matching semantics.</source>
          <target state="translated">ARE拡張機能の多くはPerlから借用されたものですが、それらをクリーンアップするために変更されたものもあり、いくつかのPerl拡張機能は存在しません。注の非互換性には、 &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\B&lt;/code&gt; 、末尾の改行に対する特別な扱いの欠如、改行に敏感なマッチングの影響を受けるものへの補完された括弧式の追加、先読み/後読み制約における括弧と後方参照の制限、および最長/最短一致（最初の一致ではなく）の一致セマンティクス。</target>
        </trans-unit>
        <trans-unit id="c2510bd4f5c7e075d877a23b92664b0d94264d01" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</source>
          <target state="translated">&lt;a href=&quot;functions-json&quot;&gt;セクション9.15で&lt;/a&gt;説明するJSON処理関数の多くは、Unicodeエスケープを通常の文字に変換するため、入力が &lt;code&gt;jsonb&lt;/code&gt; ではなく &lt;code&gt;json&lt;/code&gt; 型であっても、上記と同じタイプのエラーをスローします。 &lt;code&gt;json&lt;/code&gt; 入力関数がこれらのチェックを行わないという事実は、UTF8以外のデータベースエンコーディングでのJSON Unicodeエスケープの単純な格納（処理なし）を可能にしますが、履歴アーティファクトと見なされる場合があります。一般に、可能であれば、JSONのUnicodeエスケープと非UTF8データベースエンコーディングを混在させないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="80b59991b11e3266fbd513366535241df81a8cf9" translate="yes" xml:space="preserve">
          <source>Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt;. The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a database encoding that does not support the represented characters.</source>
          <target state="translated">Many of the JSON processing functions described in &lt;a href=&quot;functions-json&quot;&gt;Section 9.16&lt;/a&gt; will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type &lt;code&gt;json&lt;/code&gt; not &lt;code&gt;jsonb&lt;/code&gt; . The fact that the &lt;code&gt;json&lt;/code&gt; input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a database encoding that does not support the represented characters.</target>
        </trans-unit>
        <trans-unit id="b3ceba3684c41c44915004b6549907098b3d1192" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. Pgpool-II has this capability. Also, this can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">上記のソリューションの多くは、複数のサーバで複数のクエリを処理することを可能にしていますが、1つのクエリで複数のサーバを使用してより速く完了させることを可能にしているものはありません。このソリューションでは、1つのクエリに対して複数のサーバが同時に作業を行うことができます。これは通常、サーバ間でデータを分割し、各サーバにクエリの一部を実行させ、中央サーバに結果を返し、そこでそれらを結合してユーザに返すことで達成されます。Pgpool-II はこの機能を持っています。また、これは PL/Proxy ツールセットを使って実装することができます。</target>
        </trans-unit>
        <trans-unit id="014eb2b75bf8a185a68dd7926fad4b4f2fb6f6a5" translate="yes" xml:space="preserve">
          <source>Many of the above solutions allow multiple servers to handle multiple queries, but none allow a single query to use multiple servers to complete faster. This solution allows multiple servers to work concurrently on a single query. It is usually accomplished by splitting the data among servers and having each server execute its part of the query and return results to a central server where they are combined and returned to the user. This can be implemented using the PL/Proxy tool set.</source>
          <target state="translated">上記のソリューションの多くは、複数のサーバで複数のクエリを処理することを可能にしていますが、1つのクエリで複数のサーバを使用してより速く完了させることを可能にしているものはありません。このソリューションでは、1つのクエリに対して複数のサーバが同時に作業することができます。これは通常、データをサーバ間で分割し、各サーバにクエリの一部を実行させて、結果を中央サーバに返し、そこでそれらを結合してユーザに返すという方法で実現されます。これはPL/Proxyツールセットを使って実装することができます。</target>
        </trans-unit>
        <trans-unit id="686c93751e24bfbb5a5a8babbdffa0304da95e5d" translate="yes" xml:space="preserve">
          <source>Many of the meta-commands act on the &lt;em&gt;current query buffer&lt;/em&gt;. This is simply a buffer holding whatever SQL command text has been typed but not yet sent to the server for execution. This will include previous input lines as well as any text appearing before the meta-command on the same line.</source>
          <target state="translated">メタコマンドの多くは、&lt;em&gt;現在のクエリバッファに&lt;/em&gt;作用し&lt;em&gt;ます&lt;/em&gt;。これは、入力されたSQLコマンドテキストを保持するバッファですが、まだサーバーに送信されて実行されていません。これには、前の入力行と、同じ行のメタコマンドの前に表示されるテキストが含まれます。</target>
        </trans-unit>
        <trans-unit id="d0cfb05fe7e11967ff7a6d7fb5a62aee53e9651c" translate="yes" xml:space="preserve">
          <source>Many of these functions and operators will convert Unicode escapes in JSON strings to the appropriate single character. This is a non-issue if the input is type &lt;code&gt;jsonb&lt;/code&gt;, because the conversion was already done; but for &lt;code&gt;json&lt;/code&gt; input, this may result in throwing an error, as noted in &lt;a href=&quot;datatype-json&quot;&gt;Section 8.14&lt;/a&gt;.</source>
          <target state="translated">これらの関数と演算子の多くは、JSON文字列のUnicodeエスケープを適切な1文字に変換します。入力が &lt;code&gt;jsonb&lt;/code&gt; 型の場合、変換はすでに行われているため、これは問題にはなりません。しかし、 &lt;code&gt;json&lt;/code&gt; 入力の場合、&lt;a href=&quot;datatype-json&quot;&gt;セクション8.14に&lt;/a&gt;記載されているように、これによりエラーがスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7cd10805ee6287ed464e4a751e94e4711b1b75c0" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">これらの機能の多くには、レプリケーションプロトコルに同等のコマンドがあります。&lt;a href=&quot;https://www.postgresql.org/docs/12/protocol-replication.html&quot;&gt;セクション52.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c9991bbe3c7f8082ad3aa4aa507145ca5c59d4fc" translate="yes" xml:space="preserve">
          <source>Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</source>
          <target state="translated">Many of these functions have equivalent commands in the replication protocol; see &lt;a href=&quot;https://www.postgresql.org/docs/13/protocol-replication.html&quot;&gt;Section 52.4&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="09d54c9e108446dcc126d9b9edd300bc8f018b7c" translate="yes" xml:space="preserve">
          <source>Many of these operations are only sensible for one-dimensional arrays. Although they will accept input arrays of more dimensions, the data is treated as though it were a linear array in storage order.</source>
          <target state="translated">これらの操作の多くは,1次元配列に対してのみ有効です.これらの操作は,より多くの次元の入力配列を受け入れますが,データは,あたかも格納順に線形配列であるかのように扱われます.</target>
        </trans-unit>
        <trans-unit id="747ffafd1658c72a0cfd879c2f486677fdad72db" translate="yes" xml:space="preserve">
          <source>Many people choose to use scripts to define their &lt;code&gt;archive_command&lt;/code&gt;, so that their &lt;code&gt;postgresql.conf&lt;/code&gt; entry looks very simple:</source>
          <target state="translated">多くの人々は、スクリプトを使用して &lt;code&gt;archive_command&lt;/code&gt; を定義することを選択しているため、 &lt;code&gt;postgresql.conf&lt;/code&gt; エントリは非常にシンプルに見えます。</target>
        </trans-unit>
        <trans-unit id="871adaf8d8928b9b6cb8b32ef8db751f5c6cf9e4" translate="yes" xml:space="preserve">
          <source>Many programs produce strange and occasionally perverse CSV files, so the file format is more a convention than a standard. Thus you might encounter some files that cannot be imported using this mechanism, and &lt;code&gt;COPY&lt;/code&gt; might produce files that other programs cannot process.</source>
          <target state="translated">多くのプログラムは、奇妙で時折混乱するCSVファイルを生成するため、ファイル形式は標準よりも慣例です。したがって、このメカニズムを使用してインポートできないファイルが発生する可能性があり、 &lt;code&gt;COPY&lt;/code&gt; は他のプログラムが処理できないファイルを生成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c567b905d84b0a334ddbdf37ad683a15fc2dd4c4" translate="yes" xml:space="preserve">
          <source>Many routines are already defined within PostgreSQL itself, but user-defined ones can also be added.</source>
          <target state="translated">多くのルーチンはPostgreSQL自体で既に定義されていますが、ユーザ定義のものを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="aced3527162bd0f606c70ff2d552cd6071f17c5f" translate="yes" xml:space="preserve">
          <source>Many users consider it good practice to always list the column names.</source>
          <target state="translated">多くのユーザーは、カラム名を常にリストアップするのが良い習慣だと考えています。</target>
        </trans-unit>
        <trans-unit id="9e8ae0f81b2286e5d586c06978958263d9a26d81" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using Snowball stemmer rules.</source>
          <target state="translated">スノーボールステム機能のルールを使用して、単語のさまざまなバリエーションを正準形にマッピングします。</target>
        </trans-unit>
        <trans-unit id="8d7f24aaf39a33003cb1dd2dcc4e2ba52ecca563" translate="yes" xml:space="preserve">
          <source>Map different variations of a word to a canonical form using an Ispell dictionary.</source>
          <target state="translated">Ispell辞書を使用して、単語のさまざまなバリエーションを正準形にマッピングします。</target>
        </trans-unit>
        <trans-unit id="7153d307c4a8dd126f6b081d2a4d9f2c3be33e38" translate="yes" xml:space="preserve">
          <source>Map phrases to a single word using a thesaurus.</source>
          <target state="translated">シソーラスを使用して、フレーズを単一の単語にマッピングします。</target>
        </trans-unit>
        <trans-unit id="9b24aee355a7838c5529c7490a65bac5367e010b" translate="yes" xml:space="preserve">
          <source>Map synonyms to a single word using Ispell.</source>
          <target state="translated">Ispellを使用して同義語を単一の単語にマップします。</target>
        </trans-unit>
        <trans-unit id="c4ba0822462e0c373aadd5360a69f205c2a7d036" translate="yes" xml:space="preserve">
          <source>Mar</source>
          <target state="translated">Mar</target>
        </trans-unit>
        <trans-unit id="433632ea5cd64cd163c3a390d5e531d33da3c5e5" translate="yes" xml:space="preserve">
          <source>March</source>
          <target state="translated">March</target>
        </trans-unit>
        <trans-unit id="531a1c0bf44a83aa6422d943626b2d77d47c5593" translate="yes" xml:space="preserve">
          <source>Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">マークカークウッド &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b50963c78fd5ba0ee384ff4f9865fdb85cbddcd7" translate="yes" xml:space="preserve">
          <source>Mark a column as allowing, or not allowing, null values.</source>
          <target state="translated">列を、NULL値を許可する、または許可しないとしてマークします。</target>
        </trans-unit>
        <trans-unit id="45379fe0fd98739ca8b200f2546c07f11e0483e4" translate="yes" xml:space="preserve">
          <source>Mark current scan position. The access method need only support one remembered scan position per scan.</source>
          <target state="translated">現在のスキャン位置をマークします。アクセス方法は、1回のスキャンにつき、記憶されているスキャン位置を1つだけサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="d89c04496b47c6c7add6d623e145d05e0e90beea" translate="yes" xml:space="preserve">
          <source>Mark the current session as replaying from the given origin, allowing replay progress to be tracked. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to revert. Can only be used if no previous origin is configured.</source>
          <target state="translated">現在のセッションを指定された起点からの再生としてマークし、再生の進行状況を追跡できるようにします。 &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; を使用して元に戻します。以前のオリジンが設定されていない場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="3c353ba22d4916c50376ffc56136935d3788b393" translate="yes" xml:space="preserve">
          <source>Mark the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has previously been configured using &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt;.</source>
          <target state="translated">現在のトランザクションを、指定されたLSNおよびタイムスタンプでコミットしたトランザクションを再生するものとしてマークします。以前に複製元が &lt;code&gt;pg_replication_origin_session_setup()&lt;/code&gt; を使用して設定されている場合にのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8026198ec726c859996827cb2a33d945433d7db7" translate="yes" xml:space="preserve">
          <source>Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Marko Kreen &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markokr@gmail.com&quot;&gt;markokr@gmail.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8a93296bb3f7dbd2119f15415d0d529e99efc9" translate="yes" xml:space="preserve">
          <source>Marks the current session as replaying from the given origin, allowing replay progress to be tracked. Can only be used if no origin is currently selected. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to undo.</source>
          <target state="translated">Marks the current session as replaying from the given origin, allowing replay progress to be tracked. Can only be used if no origin is currently selected. Use &lt;code&gt;pg_replication_origin_session_reset&lt;/code&gt; to undo.</target>
        </trans-unit>
        <trans-unit id="6f934292a8f9bb0e504a2267c5d57828e046b931" translate="yes" xml:space="preserve">
          <source>Marks the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has been selected using &lt;code&gt;pg_replication_origin_session_setup&lt;/code&gt;.</source>
          <target state="translated">Marks the current transaction as replaying a transaction that has committed at the given LSN and timestamp. Can only be called when a replication origin has been selected using &lt;code&gt;pg_replication_origin_session_setup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a85793fe091f4b79ea4b1cbe55645a43cdb25119" translate="yes" xml:space="preserve">
          <source>Marks the publication as one that replicates changes for all tables in the database, including tables created in the future.</source>
          <target state="translated">将来作成されるテーブルを含め、データベース内のすべてのテーブルの変更を複製するものとしてパブリケーションにマークを付けます。</target>
        </trans-unit>
        <trans-unit id="48783f4e8092ded2db7efb72ccd9468e6f9f40fe" translate="yes" xml:space="preserve">
          <source>Master (server)</source>
          <target state="translated">マスター(サーバ)</target>
        </trans-unit>
        <trans-unit id="dbea724ab0ab5100a69e78a28b57720c1d6712f2" translate="yes" xml:space="preserve">
          <source>Master failure will never lose data</source>
          <target state="translated">マスターの故障でデータが失われることはない</target>
        </trans-unit>
        <trans-unit id="b17d5df13d0871fd4cf3c5923d856a866da06d96" translate="yes" xml:space="preserve">
          <source>Match the specified columns' values against the null string, even if it has been quoted, and if a match is found set the value to &lt;code&gt;NULL&lt;/code&gt;. In the default case where the null string is empty, this converts a quoted empty string into NULL. This option is allowed only in &lt;code&gt;COPY FROM&lt;/code&gt;, and only when using &lt;code&gt;CSV&lt;/code&gt; format.</source>
          <target state="translated">引用符で囲まれている場合でも、指定された列の値をnull文字列と照合し、一致が見つかった場合は値を &lt;code&gt;NULL&lt;/code&gt; に設定します。null文字列が空であるデフォルトの場合、これは引用された空の文字列をNULLに変換します。このオプションは &lt;code&gt;COPY FROM&lt;/code&gt; でのみ、 &lt;code&gt;CSV&lt;/code&gt; 形式を使用する場合にのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="53d751384b810e580b81b6af15ea342f4112abe1" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case insensitive</source>
          <target state="translated">正規表現にマッチします。</target>
        </trans-unit>
        <trans-unit id="50df7b2381b68eae63b34b5f24c7004fae5bf76b" translate="yes" xml:space="preserve">
          <source>Matches regular expression, case sensitive</source>
          <target state="translated">正規表現にマッチします。</target>
        </trans-unit>
        <trans-unit id="fccd01d6aebb595ebe777cc128bfd2f8fc6bb331" translate="yes" xml:space="preserve">
          <source>Materialized</source>
          <target state="translated">Materialized</target>
        </trans-unit>
        <trans-unit id="6c6539b1b3ecdc0ce5fd2e28965f4dde400d5218" translate="yes" xml:space="preserve">
          <source>Materialized view (relation)</source>
          <target state="translated">マテリアライズドビュー(関係</target>
        </trans-unit>
        <trans-unit id="7844bff419f63af9d9cad339e25621693c32f323" translate="yes" xml:space="preserve">
          <source>Materialized view definition (a reconstructed &lt;code&gt;SELECT&lt;/code&gt; query)</source>
          <target state="translated">マテリアライズドビューの定義（再構築された &lt;code&gt;SELECT&lt;/code&gt; クエリ）</target>
        </trans-unit>
        <trans-unit id="1636e8b4d786c74d148e1a7dc19345ad47a2c025" translate="yes" xml:space="preserve">
          <source>Mathematical operators are provided for many PostgreSQL types. For types without standard mathematical conventions (e.g., date/time types) we describe the actual behavior in subsequent sections.</source>
          <target state="translated">多くのPostgreSQLの型に対して数学演算子が提供されています。標準的な数学的な規則がない型(例:日付/時刻型)については、後のセクションで実際の動作を説明します。</target>
        </trans-unit>
        <trans-unit id="1001c24f338845a2ebfc01ab0741f854faa1aca1" translate="yes" xml:space="preserve">
          <source>Mathematical:  / 2</source>
          <target state="translated">数学的な。/2</target>
        </trans-unit>
        <trans-unit id="c3d70e9435a7845b6f93f885d627357ee254fe09" translate="yes" xml:space="preserve">
          <source>Mathematical: !</source>
          <target state="translated">数学的:!</target>
        </trans-unit>
        <trans-unit id="fdaf7cc1ab57d2149690173f829e4f0c4dd36551" translate="yes" xml:space="preserve">
          <source>Mathematical: !!</source>
          <target state="translated">数学的:!</target>
        </trans-unit>
        <trans-unit id="5e2823abc00a4631871d8a38e715d143884de402" translate="yes" xml:space="preserve">
          <source>Mathematical: !! 5</source>
          <target state="translated">数学的:! 5</target>
        </trans-unit>
        <trans-unit id="b5aaa56c60d256db29a89bc57b92703c0f7cb305" translate="yes" xml:space="preserve">
          <source>Mathematical: #</source>
          <target state="translated">数学的に #</target>
        </trans-unit>
        <trans-unit id="181ffc47f204d3f9ba3ff486f0f30c0c0ef1d5b9" translate="yes" xml:space="preserve">
          <source>Mathematical: %</source>
          <target state="translated">数学的:%.</target>
        </trans-unit>
        <trans-unit id="ab7340ae469c4484dcc6f33a45b64f2dbe2c6ff3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;amp;</source>
          <target state="translated">数学：＆</target>
        </trans-unit>
        <trans-unit id="c195fef9b5d30c42138e890a55d18aa8f3e74af3" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;gt;&amp;gt;</source>
          <target state="translated">数学：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="14a14395161c1fa4a496e90e3da92831d4e7dcdb" translate="yes" xml:space="preserve">
          <source>Mathematical: &amp;lt;&amp;lt;</source>
          <target state="translated">数学：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddb29852cc33e3b226c0621b50ee13e25c0315f2" translate="yes" xml:space="preserve">
          <source>Mathematical: *</source>
          <target state="translated">数学的に。*</target>
        </trans-unit>
        <trans-unit id="59ea67514b35bce8cb0c2fb98d96ab75e1042145" translate="yes" xml:space="preserve">
          <source>Mathematical: +</source>
          <target state="translated">数学的に。+</target>
        </trans-unit>
        <trans-unit id="573654821f774c0055526f71d6224f85263be0a1" translate="yes" xml:space="preserve">
          <source>Mathematical: + 3.5</source>
          <target state="translated">数学的に。+3.5</target>
        </trans-unit>
        <trans-unit id="9634adf0f4c35060714ef3c74218c7741d96738c" translate="yes" xml:space="preserve">
          <source>Mathematical: -</source>
          <target state="translated">数学的な:-。</target>
        </trans-unit>
        <trans-unit id="bc7be2afb633a5ef91761e59ad8b5a5f36c92a00" translate="yes" xml:space="preserve">
          <source>Mathematical: /</source>
          <target state="translated">数学的に。/</target>
        </trans-unit>
        <trans-unit id="14509827aaea9ada84591d506dac7b95163f05fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 0</source>
          <target state="translated">数学的:0</target>
        </trans-unit>
        <trans-unit id="1dcad53763c2d6ad82f715b19ab8fec7ddeae22b" translate="yes" xml:space="preserve">
          <source>Mathematical: 1 &amp;lt;&amp;lt; 4</source>
          <target state="translated">Mathematical: 1 &amp;lt;&amp;lt; 4</target>
        </trans-unit>
        <trans-unit id="ca7f29cf58cb7d77da0870ecda08106919ba5797" translate="yes" xml:space="preserve">
          <source>Mathematical: 17 # 5</source>
          <target state="translated">数学:17#5</target>
        </trans-unit>
        <trans-unit id="aba60cec6fd188d73cb4b2c6daf41d7e269b2755" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 * 3</source>
          <target state="translated">数学:2*3</target>
        </trans-unit>
        <trans-unit id="a09b3f64871c9fa59aafabb2d8aac651ddf945f1" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 + 3</source>
          <target state="translated">数学:2+3</target>
        </trans-unit>
        <trans-unit id="46a2737a7e89745b3ae76fb70bc9a67e72cce41a" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 - 3</source>
          <target state="translated">数学:2-3</target>
        </trans-unit>
        <trans-unit id="4e4ae222002ab6c8851226d9e26b9eb6997461fb" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3</source>
          <target state="translated">数学:2 ^ 3</target>
        </trans-unit>
        <trans-unit id="b1453f807f48dca3215386cb463d776ee41b48c5" translate="yes" xml:space="preserve">
          <source>Mathematical: 2 ^ 3 ^ 3</source>
          <target state="translated">数学:2 ^ 3 ^ 3</target>
        </trans-unit>
        <trans-unit id="0910b16e152e2fe676e014eac4265186a97fa07e" translate="yes" xml:space="preserve">
          <source>Mathematical: 32 | 3</source>
          <target state="translated">数学:32|3</target>
        </trans-unit>
        <trans-unit id="7585f445437546f28802c19197028b4f366b5a52" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 !</source>
          <target state="translated">数学:5 !</target>
        </trans-unit>
        <trans-unit id="b13db5517bdad3caace02ad3155beb1c731b5ca2" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 % 4</source>
          <target state="translated">数学:5 % 4</target>
        </trans-unit>
        <trans-unit id="23a81ae0fa61623f6df83d0e9447d29d062d3a97" translate="yes" xml:space="preserve">
          <source>Mathematical: 5 / 2</source>
          <target state="translated">数学:5/2</target>
        </trans-unit>
        <trans-unit id="d4f45fa3de4c530e7fd6305fbfcd48feef5d74a8" translate="yes" xml:space="preserve">
          <source>Mathematical: 5.0 / 2</source>
          <target state="translated">数学:5.0/2</target>
        </trans-unit>
        <trans-unit id="11e8ff6a5010dabe71633aac622636270030f6a1" translate="yes" xml:space="preserve">
          <source>Mathematical: 8 &amp;gt;&amp;gt; 2</source>
          <target state="translated">Mathematical: 8 &amp;gt;&amp;gt; 2</target>
        </trans-unit>
        <trans-unit id="1211cb8df037247151be58836d25635e55e30011" translate="yes" xml:space="preserve">
          <source>Mathematical: 91 &amp;amp; 15</source>
          <target state="translated">Mathematical: 91 &amp;amp; 15</target>
        </trans-unit>
        <trans-unit id="3196927fede8cfa3807fe6508ad4afd6a4dd5c10" translate="yes" xml:space="preserve">
          <source>Mathematical: @</source>
          <target state="translated">数学的に @</target>
        </trans-unit>
        <trans-unit id="ae31f2afe49c847bd7b50bc7534ffe77332ef912" translate="yes" xml:space="preserve">
          <source>Mathematical: @ -5.0</source>
          <target state="translated">数学的に @ -5.0</target>
        </trans-unit>
        <trans-unit id="1dadfd5f33c390a7d584396b6077f56229e94a33" translate="yes" xml:space="preserve">
          <source>Mathematical: ^</source>
          <target state="translated">数学的に。^</target>
        </trans-unit>
        <trans-unit id="20a199d0df7c3ce2a80fb78024a1d00c66d000a9" translate="yes" xml:space="preserve">
          <source>Mathematical: abs</source>
          <target state="translated">数学的:不在</target>
        </trans-unit>
        <trans-unit id="df0e19fdb206e36a2205ad9d44520f7fee9d3470" translate="yes" xml:space="preserve">
          <source>Mathematical: acos</source>
          <target state="translated">数学:アコス</target>
        </trans-unit>
        <trans-unit id="f1cae65774f5f13f2e415042ed98b64f1dc67f0f" translate="yes" xml:space="preserve">
          <source>Mathematical: acosd</source>
          <target state="translated">数学的:acosd</target>
        </trans-unit>
        <trans-unit id="f713fa364b0d2333d09caea3c059cdf323feaaae" translate="yes" xml:space="preserve">
          <source>Mathematical: acosh</source>
          <target state="translated">数学:アコッシュ</target>
        </trans-unit>
        <trans-unit id="15392ccce532b37463508b07d4825a05d6fb2837" translate="yes" xml:space="preserve">
          <source>Mathematical: asin</source>
          <target state="translated">数学的:アシン</target>
        </trans-unit>
        <trans-unit id="4629299dfc93830669825b7184510d53113981f0" translate="yes" xml:space="preserve">
          <source>Mathematical: asind</source>
          <target state="translated">数学的:アシンド</target>
        </trans-unit>
        <trans-unit id="3fe074bf9a455acf4922429fcb4f7cd46c3c843a" translate="yes" xml:space="preserve">
          <source>Mathematical: asinh</source>
          <target state="translated">数学:アシン</target>
        </trans-unit>
        <trans-unit id="83a2bb5d54e23969b5a04d6c088114146c9dc45d" translate="yes" xml:space="preserve">
          <source>Mathematical: atan</source>
          <target state="translated">数学:アタン</target>
        </trans-unit>
        <trans-unit id="c731e727bd85d0cc74cb9191f3962ed11a8f3b3b" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2</source>
          <target state="translated">数学的:atan2</target>
        </trans-unit>
        <trans-unit id="5b918761ab75eba1fab60d1e4fd5336ac01d2bf8" translate="yes" xml:space="preserve">
          <source>Mathematical: atan2d</source>
          <target state="translated">数学:atan2d</target>
        </trans-unit>
        <trans-unit id="a929d56a5b59eb4bc6c164cae3d9675502095c0e" translate="yes" xml:space="preserve">
          <source>Mathematical: atand</source>
          <target state="translated">数学的:アタンド</target>
        </trans-unit>
        <trans-unit id="583724a9264d7b0976ad47dcd14d4ac28456738f" translate="yes" xml:space="preserve">
          <source>Mathematical: atanh</source>
          <target state="translated">数学的な:atanh</target>
        </trans-unit>
        <trans-unit id="177cd0bc699b2203fdf2d4c75fe30163594d7b7e" translate="yes" xml:space="preserve">
          <source>Mathematical: cbrt</source>
          <target state="translated">数学的:cbrt</target>
        </trans-unit>
        <trans-unit id="2693815a9d6a69c69854809a47650e0275c1e989" translate="yes" xml:space="preserve">
          <source>Mathematical: ceil</source>
          <target state="translated">数学的:天井</target>
        </trans-unit>
        <trans-unit id="d952c9a3323ba3a0a0aaeb01f24cc8dfd99821d9" translate="yes" xml:space="preserve">
          <source>Mathematical: ceiling</source>
          <target state="translated">数学的な:天井</target>
        </trans-unit>
        <trans-unit id="9db09acf97836fbc07512e622eb6635d3a02dc78" translate="yes" xml:space="preserve">
          <source>Mathematical: cos</source>
          <target state="translated">数学的:cos</target>
        </trans-unit>
        <trans-unit id="85e771e6ddf496ad7e9555f4d093d90654ec2a2a" translate="yes" xml:space="preserve">
          <source>Mathematical: cosd</source>
          <target state="translated">数学的:cosd</target>
        </trans-unit>
        <trans-unit id="ae9e7e216cc8b38acc3988effacc0b9c9f145f6e" translate="yes" xml:space="preserve">
          <source>Mathematical: cosh</source>
          <target state="translated">数学:コッシュ</target>
        </trans-unit>
        <trans-unit id="6bd28a5aa54b3401f41f88e5856f7384f5d30c00" translate="yes" xml:space="preserve">
          <source>Mathematical: cot</source>
          <target state="translated">数学的:コット</target>
        </trans-unit>
        <trans-unit id="e063ca4c3718afe3730ed0658e8574f03540c88a" translate="yes" xml:space="preserve">
          <source>Mathematical: cotd</source>
          <target state="translated">数学的:cotd</target>
        </trans-unit>
        <trans-unit id="18ccdbc8bc11a04cc3a6bf245df208da8e2cae56" translate="yes" xml:space="preserve">
          <source>Mathematical: degrees</source>
          <target state="translated">数学:度</target>
        </trans-unit>
        <trans-unit id="aca19fd89939c16cdb0569b07e58a53ad9349a7b" translate="yes" xml:space="preserve">
          <source>Mathematical: div</source>
          <target state="translated">数学的:div</target>
        </trans-unit>
        <trans-unit id="8af560e7bf42dc0411068f58a59ae9f72df77793" translate="yes" xml:space="preserve">
          <source>Mathematical: e</source>
          <target state="translated">数学的:e</target>
        </trans-unit>
        <trans-unit id="1e46d6487f521a5afb4ed4dd6a23a59fc059e6e5" translate="yes" xml:space="preserve">
          <source>Mathematical: exp</source>
          <target state="translated">数学的な:exp</target>
        </trans-unit>
        <trans-unit id="5d515a5291a2aa6b90f086dc95105de6456c2b72" translate="yes" xml:space="preserve">
          <source>Mathematical: factorial</source>
          <target state="translated">数学的:階乗</target>
        </trans-unit>
        <trans-unit id="573fe26c7738f0584a8c6cbc5489e02fe641fddb" translate="yes" xml:space="preserve">
          <source>Mathematical: floor</source>
          <target state="translated">数学:床</target>
        </trans-unit>
        <trans-unit id="0875b243f27c954dcb0311da83af45540779329c" translate="yes" xml:space="preserve">
          <source>Mathematical: gcd</source>
          <target state="translated">数学的な:gcd</target>
        </trans-unit>
        <trans-unit id="585a4c28147c569040ed981c6a2b550fc5404fd3" translate="yes" xml:space="preserve">
          <source>Mathematical: lcm</source>
          <target state="translated">数学的:lcm</target>
        </trans-unit>
        <trans-unit id="402d0cd4fdb985e3812799945b9fceb07540a0b6" translate="yes" xml:space="preserve">
          <source>Mathematical: ln</source>
          <target state="translated">数学的:ln</target>
        </trans-unit>
        <trans-unit id="85d8f0757c4bc05932d8f5d5e562c9da71c34f89" translate="yes" xml:space="preserve">
          <source>Mathematical: log</source>
          <target state="translated">数学的:対数</target>
        </trans-unit>
        <trans-unit id="c83ba153e80e1ad83154d81618c218abe75464e9" translate="yes" xml:space="preserve">
          <source>Mathematical: log10</source>
          <target state="translated">数学的:log10</target>
        </trans-unit>
        <trans-unit id="b72fa934be334bbd661a4dd4724fb9f4f43c1c9b" translate="yes" xml:space="preserve">
          <source>Mathematical: min_scale</source>
          <target state="translated">数学的:min_scale</target>
        </trans-unit>
        <trans-unit id="342c1a68d26670cf3f8565a0897aa5cb7ba34b4e" translate="yes" xml:space="preserve">
          <source>Mathematical: mod</source>
          <target state="translated">数学的:モデム</target>
        </trans-unit>
        <trans-unit id="1c34dfef32b83a1764b863b4bbe019d5862c9c11" translate="yes" xml:space="preserve">
          <source>Mathematical: pi</source>
          <target state="translated">数学的に:円周率</target>
        </trans-unit>
        <trans-unit id="886814dcb54a703998bbc0cf8f2f8499a7b62fa5" translate="yes" xml:space="preserve">
          <source>Mathematical: power</source>
          <target state="translated">数学:力</target>
        </trans-unit>
        <trans-unit id="256f270ce3f202545798a4267069da319d55bdce" translate="yes" xml:space="preserve">
          <source>Mathematical: radians</source>
          <target state="translated">数学的:ラジアン</target>
        </trans-unit>
        <trans-unit id="fa28188b7b4ce61e7fd1e57eb3d3850d1782d895" translate="yes" xml:space="preserve">
          <source>Mathematical: random</source>
          <target state="translated">数学的:ランダム</target>
        </trans-unit>
        <trans-unit id="38618634f79b9464f7b75f0213cc7c4516883f3f" translate="yes" xml:space="preserve">
          <source>Mathematical: round</source>
          <target state="translated">数学的:ラウンド</target>
        </trans-unit>
        <trans-unit id="d57a36e95bfa64f5eb46d773fdde749c2cb84fc4" translate="yes" xml:space="preserve">
          <source>Mathematical: scale</source>
          <target state="translated">数学的:スケール</target>
        </trans-unit>
        <trans-unit id="bf096078393c2c98a0b1e6c717f74e687f878163" translate="yes" xml:space="preserve">
          <source>Mathematical: setseed</source>
          <target state="translated">数学的:セットシード</target>
        </trans-unit>
        <trans-unit id="39f4ee6bf2c1ebbb6d092ca5116d3c60ea228290" translate="yes" xml:space="preserve">
          <source>Mathematical: sign</source>
          <target state="translated">数学:符号</target>
        </trans-unit>
        <trans-unit id="21776ac559594087e48aa9a00b1065f77ca338fd" translate="yes" xml:space="preserve">
          <source>Mathematical: sin</source>
          <target state="translated">数学的:罪</target>
        </trans-unit>
        <trans-unit id="e9237291333d54a9e72bd4303ce991cb654f9866" translate="yes" xml:space="preserve">
          <source>Mathematical: sind</source>
          <target state="translated">数学的な:インド</target>
        </trans-unit>
        <trans-unit id="00e2992e6f676f0cd18285a72f0c1e9d55b0d240" translate="yes" xml:space="preserve">
          <source>Mathematical: sinh</source>
          <target state="translated">数学的に:sinh</target>
        </trans-unit>
        <trans-unit id="aae7a6e9b70d02f4e993a9db74c8db3083ef0bfc" translate="yes" xml:space="preserve">
          <source>Mathematical: sqrt</source>
          <target state="translated">数学的:sqrt</target>
        </trans-unit>
        <trans-unit id="02a3ee3cf42cf2113efd88c1ad458433f9a69197" translate="yes" xml:space="preserve">
          <source>Mathematical: tan</source>
          <target state="translated">数学的な:タン</target>
        </trans-unit>
        <trans-unit id="a12d29e8482347b79de73aeb0357bed2e637f2fc" translate="yes" xml:space="preserve">
          <source>Mathematical: tand</source>
          <target state="translated">数学的:タンド</target>
        </trans-unit>
        <trans-unit id="43ac9c6f98336e23241f94c577f53cb99b066801" translate="yes" xml:space="preserve">
          <source>Mathematical: tanh</source>
          <target state="translated">数学的に:タン</target>
        </trans-unit>
        <trans-unit id="4cead06e1e3ecd61366e9c73534c51a69696eb50" translate="yes" xml:space="preserve">
          <source>Mathematical: trim_scale</source>
          <target state="translated">数学的:trim_scale</target>
        </trans-unit>
        <trans-unit id="fd05d42d41de6870056e68c4ccd289ca842197c7" translate="yes" xml:space="preserve">
          <source>Mathematical: trunc</source>
          <target state="translated">数学的:切り捨て</target>
        </trans-unit>
        <trans-unit id="b3fcfe03e83f0fd3f41685d5a0a35fa941c16d42" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket</source>
          <target state="translated">数学的:width_bucket</target>
        </trans-unit>
        <trans-unit id="102ae47fccbd9d1f7766efee6bfebf34706bb020" translate="yes" xml:space="preserve">
          <source>Mathematical: width_bucket, array::timestamptz)</source>
          <target state="translated">数学:width_bucket,array::timestamptz)</target>
        </trans-unit>
        <trans-unit id="dfa1e770f800f341e62dbc76cea5befa40e67f50" translate="yes" xml:space="preserve">
          <source>Mathematical: |</source>
          <target state="translated">数学的に。|</target>
        </trans-unit>
        <trans-unit id="b18f08aa2ba95d26e5185b6a71ed15ce174e5b8f" translate="yes" xml:space="preserve">
          <source>Mathematical: |/</source>
          <target state="translated">数学的に。|/</target>
        </trans-unit>
        <trans-unit id="b1d8eaf643a6e6b2e7be95b78f55ac71c3eeed5c" translate="yes" xml:space="preserve">
          <source>Mathematical: |/ 25.0</source>
          <target state="translated">数学的に。|/25.0</target>
        </trans-unit>
        <trans-unit id="51e150fa17498f246e415139012baeb22d8f4d4a" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/</source>
          <target state="translated">数学的に。||/</target>
        </trans-unit>
        <trans-unit id="6da4178d25c27664a5aeecdd5149efed87a71eaa" translate="yes" xml:space="preserve">
          <source>Mathematical: ||/ 64.0</source>
          <target state="translated">数学的に。||/64.0</target>
        </trans-unit>
        <trans-unit id="3eacd2f34aae3951141d12b3b8bacb1b57ee7e7b" translate="yes" xml:space="preserve">
          <source>Mathematical: ~</source>
          <target state="translated">数学的に:〜。</target>
        </trans-unit>
        <trans-unit id="28cbee48973403ffe3820780daffa38b195ca4b1" translate="yes" xml:space="preserve">
          <source>Mathematical: ~1</source>
          <target state="translated">数学:~1</target>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="eebfdb589d2a38f34e9a5e134f62af1ef891433d" translate="yes" xml:space="preserve">
          <source>Max Password Length</source>
          <target state="translated">パスワードの最大長さ</target>
        </trans-unit>
        <trans-unit id="462156397b99eeccfdb0f5b4ea63ec4407a809bc" translate="yes" xml:space="preserve">
          <source>Maximum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">パラメータの最大許容値(数値以外の場合はnull</target>
        </trans-unit>
        <trans-unit id="f4c49a25b4f19cb0213949aa3e28ef3557be3a93" translate="yes" xml:space="preserve">
          <source>Maximum amount of time allowed to complete client authentication. If a would-be client has not completed the authentication protocol in this much time, the server closes the connection. This prevents hung clients from occupying a connection indefinitely. If this value is specified without units, it is taken as seconds. The default is one minute (&lt;code&gt;1m&lt;/code&gt;). This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">クライアント認証を完了するために許可される最大時間。予定クライアントがこの時間内に認証プロトコルを完了しなかった場合、サーバーは接続を閉じます。これにより、ハングしたクライアントが接続を無期限に占有するのを防ぎます。この値が単位なしで指定された場合、秒として取得されます。デフォルトは1分（ &lt;code&gt;1m&lt;/code&gt; ）です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="16d4343ca4b0ff10b386fabaeb90ec48c83feb93" translate="yes" xml:space="preserve">
          <source>Maximum depth to descend to, or zero for unlimited depth</source>
          <target state="translated">下降する最大深度、または無制限の深度の場合はゼロ</target>
        </trans-unit>
        <trans-unit id="6e382e12a5004b51a9fb6db4c19fb4ad8b8e10a3" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphore identifiers (i.e., sets)</source>
          <target state="translated">セマフォ識別子の最大数(すなわちセット)</target>
        </trans-unit>
        <trans-unit id="0c59e3da96b0612eb2065c185976ccb89f3be9d6" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores per set</source>
          <target state="translated">セットあたりのセマフォの最大数</target>
        </trans-unit>
        <trans-unit id="352ff6e41f28fb4dd9615ad5c6b893bc2f0820a2" translate="yes" xml:space="preserve">
          <source>Maximum number of semaphores system-wide</source>
          <target state="translated">システム全体のセマフォの最大数</target>
        </trans-unit>
        <trans-unit id="c815c1aa92e98505761f17e71fb912e2b0d50481" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments per process</source>
          <target state="translated">プロセスあたりの共有メモリセグメントの最大数</target>
        </trans-unit>
        <trans-unit id="f5eb5768d25d1069e687fbff6c4cdff705aae7ad" translate="yes" xml:space="preserve">
          <source>Maximum number of shared memory segments system-wide</source>
          <target state="translated">システム全体の共有メモリセグメントの最大数</target>
        </trans-unit>
        <trans-unit id="e4a5cf08c55be90a96549a51c4d65339bafeb337" translate="yes" xml:space="preserve">
          <source>Maximum number of synchronization workers per subscription. This parameter controls the amount of parallelism of the initial data copy during the subscription initialization or when new tables are added.</source>
          <target state="translated">サブスクリプションごとの同期ワーカーの最大数。このパラメータは、サブスクリプションの初期化時、または新しいテーブルが追加されたときの初期データコピーの並列性の量を制御します。</target>
        </trans-unit>
        <trans-unit id="cf9da86e68e4a7c2a1bc302b1edbdee46483b5d4" translate="yes" xml:space="preserve">
          <source>Maximum size of shared memory segment (bytes)</source>
          <target state="translated">共有メモリセグメントの最大サイズ(バイト</target>
        </trans-unit>
        <trans-unit id="3bc5354a68835f6648f33d79497a82c72e86de3c" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow during automatic checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_size&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">自動チェックポイント中にWALを拡張できる最大サイズ。これはソフト制限です。WALサイズは、高負荷、 &lt;code&gt;archive_command&lt;/code&gt; の失敗、または &lt;code&gt;wal_keep_size&lt;/code&gt; の高い設定などの特別な状況では、 &lt;code&gt;max_wal_size&lt;/code&gt; を超える可能性があります。この値が単位なしで指定された場合、メガバイトと見なされます。デフォルトは1GBです。このパラメーターを増やすと、クラッシュの回復に必要な時間が長くなる可能性があります。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="d78433a672e983d650938d0f8874ea0c01c8e279" translate="yes" xml:space="preserve">
          <source>Maximum size to let the WAL grow to between automatic WAL checkpoints. This is a soft limit; WAL size can exceed &lt;code&gt;max_wal_size&lt;/code&gt; under special circumstances, such as heavy load, a failing &lt;code&gt;archive_command&lt;/code&gt;, or a high &lt;code&gt;wal_keep_segments&lt;/code&gt; setting. If this value is specified without units, it is taken as megabytes. The default is 1 GB. Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WALが自動WALチェックポイント間で拡大できる最大サイズ。これは弱い制限です。 WALのサイズは、高負荷、失敗した &lt;code&gt;archive_command&lt;/code&gt; 、高い &lt;code&gt;wal_keep_segments&lt;/code&gt; 設定などの特殊な状況下では &lt;code&gt;max_wal_size&lt;/code&gt; を超える可能性があります。この値を単位なしで指定すると、メガバイトとして扱われます。デフォルトは1 GBです。このパラメーターを大きくすると、クラッシュの回復に必要な時間が長くなる可能性があります。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="a6663cd5d04ec15d3d8cb068011883bb72c21769" translate="yes" xml:space="preserve">
          <source>Maximum time between automatic WAL checkpoints. If this value is specified without units, it is taken as seconds. The valid range is between 30 seconds and one day. The default is five minutes (&lt;code&gt;5min&lt;/code&gt;). Increasing this parameter can increase the amount of time needed for crash recovery. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">自動WALチェックポイント間の最大時間。この値が単位なしで指定された場合、秒として取得されます。有効な範囲は30秒から1日です。デフォルトは5分（ &lt;code&gt;5min&lt;/code&gt; ）です。このパラメーターを大きくすると、クラッシュの回復に必要な時間が長くなる可能性があります。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="a6f1ed8f82cbd62e299f9090b927f2f26026550f" translate="yes" xml:space="preserve">
          <source>Maximum time spent executing the statement, in milliseconds</source>
          <target state="translated">ステートメントの実行時間の最大値(ミリ秒単位</target>
        </trans-unit>
        <trans-unit id="4455b92ac909b4c5503624f3e50369ecbf4e7112" translate="yes" xml:space="preserve">
          <source>Maximum time spent in the statement, in milliseconds</source>
          <target state="translated">ステートメント内での最大使用時間(ミリ秒単位</target>
        </trans-unit>
        <trans-unit id="80cb793c865edc2335fb8eab0406dd5a5723c352" translate="yes" xml:space="preserve">
          <source>Maximum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">ステートメントの計画に費やされた最大時間（ミリ秒単位）（ &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; が有効になっている場合、それ以外の場合はゼロ）</target>
        </trans-unit>
        <trans-unit id="e356bc07e535e04e9d9c3334c083fcc3488e0bee" translate="yes" xml:space="preserve">
          <source>Maximum value of semaphore</source>
          <target state="translated">セマフォの最大値</target>
        </trans-unit>
        <trans-unit id="d73ff195380431a5bbd14d7218270378e35474ca" translate="yes" xml:space="preserve">
          <source>Maximum value of the sequence</source>
          <target state="translated">シーケンスの最大値</target>
        </trans-unit>
        <trans-unit id="c94f479833c5d401cffdfa7afe6c9c2d56448019" translate="yes" xml:space="preserve">
          <source>May</source>
          <target state="translated">May</target>
        </trans-unit>
        <trans-unit id="9a0ffa2f24694ff69c95e89a55aa229e9cda8b30" translate="yes" xml:space="preserve">
          <source>Mean time spent executing the statement, in milliseconds</source>
          <target state="translated">ステートメントの実行に要した時間の平均値(ミリ秒</target>
        </trans-unit>
        <trans-unit id="181d211e960e06792dfe28bfac1abd601a4c5a9d" translate="yes" xml:space="preserve">
          <source>Mean time spent in the statement, in milliseconds</source>
          <target state="translated">ステートメントに費やした平均時間(ミリ秒</target>
        </trans-unit>
        <trans-unit id="e1349b1d8078a8f519127952739b8b28f7e70925" translate="yes" xml:space="preserve">
          <source>Mean time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">ステートメントの計画に費やされた平均時間（ミリ秒単位）（ &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; が有効になっている場合、それ以外の場合はゼロ）</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f0f833c6521b2d19b94ba8d0789e74dc9ccb5388" translate="yes" xml:space="preserve">
          <source>Measuring Executor Timing Overhead</source>
          <target state="translated">エグゼキュータのタイミングオーバーヘッドの測定</target>
        </trans-unit>
        <trans-unit id="1c83efb5aa232017e707b79cbf793fdfcf4c42d0" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name is a named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules of an identifier, it must be enclosed in double quotes as a character string literal.</source>
          <target state="translated">指定されたキーを持つオブジェクトメンバーを返すメンバーアクセサー。キー名が &lt;code&gt;$&lt;/code&gt; で始まる名前付き変数であるか、識別子のJavaScriptルールを満たしていない場合は、文字列リテラルとして二重引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="016eb9bcfce0ff8bda70ffdf100d2c6f5e38a6fe" translate="yes" xml:space="preserve">
          <source>Member accessor that returns an object member with the specified key. If the key name matches some named variable starting with &lt;code&gt;$&lt;/code&gt; or does not meet the JavaScript rules for an identifier, it must be enclosed in double quotes to make it a string literal.</source>
          <target state="translated">指定されたキーを持つオブジェクトメンバーを返すメンバーアクセサー。キー名が &lt;code&gt;$&lt;/code&gt; で始まる名前付き変数と一致する場合、または識別子のJavaScriptルールに適合しない場合は、文字列リテラルにするために二重引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="dc3e8f88c1e4c9777ada8c4e159672ef60421a6a" translate="yes" xml:space="preserve">
          <source>Merge join requires its input data to be sorted on the join keys. In this plan the &lt;code&gt;tenk1&lt;/code&gt; data is sorted by using an index scan to visit the rows in the correct order, but a sequential scan and sort is preferred for &lt;code&gt;onek&lt;/code&gt;, because there are many more rows to be visited in that table. (Sequential-scan-and-sort frequently beats an index scan for sorting many rows, because of the nonsequential disk access required by the index scan.)</source>
          <target state="translated">マージ結合では、その入力データを結合キーでソートする必要があります。このプランでは、インデックススキャンを使用して &lt;code&gt;tenk1&lt;/code&gt; データをソートし、正しい順序で行にアクセスしますが、 &lt;code&gt;onek&lt;/code&gt; には順次スキャンとソートが推奨されます。 （インデックススキャンで必要な非順次ディスクアクセスのため、シーケンシャルスキャンアンドソートは、多くの行をソートするためのインデックススキャンを頻繁に上回ります。）</target>
        </trans-unit>
        <trans-unit id="5df467aa951005c5f7e89731194b036d002c4227" translate="yes" xml:space="preserve">
          <source>Merge joins also have measurement artifacts that can confuse the unwary. A merge join will stop reading one input if it's exhausted the other input and the next key value in the one input is greater than the last key value of the other input; in such a case there can be no more matches and so no need to scan the rest of the first input. This results in not reading all of one child, with results like those mentioned for &lt;code&gt;LIMIT&lt;/code&gt;. Also, if the outer (first) child contains rows with duplicate key values, the inner (second) child is backed up and rescanned for the portion of its rows matching that key value. &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; counts these repeated emissions of the same inner rows as if they were real additional rows. When there are many outer duplicates, the reported actual row count for the inner child plan node can be significantly larger than the number of rows that are actually in the inner relation.</source>
          <target state="translated">マージ結合には、不注意を混乱させる可能性のある測定アーティファクトもあります。マージ結合は、他の入力を使い果たし、1つの入力の次のキー値が他の入力の最後のキー値より大きい場合、1つの入力の読み取りを停止します。このような場合、一致がなくなるため、最初の入力の残りをスキャンする必要はありません。これにより、1つの子のすべてが読み取られず、 &lt;code&gt;LIMIT&lt;/code&gt; で説明されているような結果になります。また、外側の（最初の）子に重複するキー値を持つ行が含まれている場合、内側の（2番目の）子がバックアップされ、そのキー値に一致する行の部分が再スキャンされます。 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 同じ内部行のこれらの繰り返し放出を、実際の追加行であるかのようにカウントします。外部の重複が多数ある場合、内部の子プランノードについて報告される実際の行数は、実際に内部リレーションにある行の数よりも大幅に大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7a6317b9601e7c09c328490aa43dfe87e04fe54d" translate="yes" xml:space="preserve">
          <source>Messages like this indicate that you contacted the server, and it is willing to talk to you, but not until you pass the authorization method specified in the &lt;code&gt;pg_hba.conf&lt;/code&gt; file. Check the password you are providing, or check your Kerberos or ident software if the complaint mentions one of those authentication types.</source>
          <target state="translated">このようなメッセージは、サーバーに接続したことを示しており、サーバーと通信する意思はありますが、 &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルで指定された認証方法を渡すまでは通信しません。提供しているパスワードを確認するか、苦情がこれらの認証タイプのいずれかについて言及している場合は、Kerberosまたはidentソフトウェアを確認してください。</target>
        </trans-unit>
        <trans-unit id="9c2097f911138f2466e5f32e8351dcd5fd749692" translate="yes" xml:space="preserve">
          <source>Meta-Commands</source>
          <target state="translated">Meta-Commands</target>
        </trans-unit>
        <trans-unit id="f693f5960d30f7053e205f6d9a4425df858962e1" translate="yes" xml:space="preserve">
          <source>Metaphone, like Soundex, is based on the idea of constructing a representative code for an input string. Two strings are then deemed similar if they have the same codes.</source>
          <target state="translated">メタフォンは、Soundexと同様に、入力文字列の代表的なコードを構築するという考えに基づいています。2つの文字列は、同じコードを持っていれば類似しているとみなされます。</target>
        </trans-unit>
        <trans-unit id="e1c1b37b805340abcc2257db6a661352b683548e" translate="yes" xml:space="preserve">
          <source>Method used for forcing WAL updates out to disk. If &lt;code&gt;fsync&lt;/code&gt; is off then this setting is irrelevant, since WAL file updates will not be forced out at all. Possible values are:</source>
          <target state="translated">WALの更新をディスクに強制するために使用される方法。 &lt;code&gt;fsync&lt;/code&gt; がオフの場合、WALファイルの更新は強制的に行われないため、この設定は重要ではありません。可能な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="628dc441c2bafa1afab14e359fb44c6e901b8f85" translate="yes" xml:space="preserve">
          <source>Michael J. Fromberger</source>
          <target state="translated">マイケル・J・フロムバーガー</target>
        </trans-unit>
        <trans-unit id="06fca8ee037d3a593497ab6d139577328dd86787" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C</source>
          <target state="translated">マイクロソフトビジュアルC</target>
        </trans-unit>
        <trans-unit id="f0e91d657447be038c5b83745dffb09499d6baf9" translate="yes" xml:space="preserve">
          <source>Military abbreviation for UTC</source>
          <target state="translated">UTCの軍事的略語</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="0d47fa8c3e389b0763d87f2daa4ec6a50fb18dc1" translate="yes" xml:space="preserve">
          <source>Minimum allowed value of the parameter (null for non-numeric values)</source>
          <target state="translated">パラメータの最小許容値 (数値以外の場合はnull)</target>
        </trans-unit>
        <trans-unit id="c5ae78e276525910ef27ff7ddf6b5c2559e2cb00" translate="yes" xml:space="preserve">
          <source>Minimum number of concurrent open transactions to require before performing the &lt;code&gt;commit_delay&lt;/code&gt; delay. A larger value makes it more probable that at least one other transaction will become ready to commit during the delay interval. The default is five transactions.</source>
          <target state="translated">&lt;code&gt;commit_delay&lt;/code&gt; 遅延を実行する前に必要な同時オープントランザクションの最小数。値が大きいほど、遅延期間中に他のトランザクションが少なくとも1つコミットできるようになる可能性が高くなります。デフォルトは5つのトランザクションです。</target>
        </trans-unit>
        <trans-unit id="0fb2ca68f01f33cc64d2c1311c2afe2326caa75d" translate="yes" xml:space="preserve">
          <source>Minimum scale (number of fractional decimal digits) needed to represent the supplied value precisely</source>
          <target state="translated">与えられた値を正確に表現するために必要な最小目盛(小数点以下の端数桁数)。</target>
        </trans-unit>
        <trans-unit id="c373999e365b4d5993611993a45677502343dcde" translate="yes" xml:space="preserve">
          <source>Minimum size of shared memory segment (bytes)</source>
          <target state="translated">共有メモリセグメントの最小サイズ(バイト)</target>
        </trans-unit>
        <trans-unit id="78afeaf9c6ff0f3ee6d2c5532d4ad21e157dee73" translate="yes" xml:space="preserve">
          <source>Minimum time spent executing the statement, in milliseconds</source>
          <target state="translated">ステートメントの実行に要する最短時間(ミリ秒単位</target>
        </trans-unit>
        <trans-unit id="613154c6477db737a4ffc935d45b4f35e3a112f3" translate="yes" xml:space="preserve">
          <source>Minimum time spent in the statement, in milliseconds</source>
          <target state="translated">ステートメント内での最短時間(ミリ秒単位</target>
        </trans-unit>
        <trans-unit id="f3052f7c6782d78980f79d735a2525db3585b208" translate="yes" xml:space="preserve">
          <source>Minimum time spent planning the statement, in milliseconds (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">ステートメントの計画に費やされた最小時間（ミリ秒単位）（ &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; が有効になっている場合、それ以外の場合はゼロ）</target>
        </trans-unit>
        <trans-unit id="9119800734f587e7d9508436d6ce2f949b6a319c" translate="yes" xml:space="preserve">
          <source>Minimum value of the sequence</source>
          <target state="translated">シーケンスの最小値</target>
        </trans-unit>
        <trans-unit id="f39b9975fa394daf9211460e65ad5e53c2e0737a" translate="yes" xml:space="preserve">
          <source>Minor releases never change the internal storage format and are always compatible with earlier and later minor releases of the same major version number. For example, version 10.1 is compatible with version 10.0 and version 10.6. Similarly, for example, 9.5.3 is compatible with 9.5.0, 9.5.1, and 9.5.6. To update between compatible versions, you simply replace the executables while the server is down and restart the server. The data directory remains unchanged &amp;mdash; minor upgrades are that simple.</source>
          <target state="translated">マイナーリリースは内部ストレージ形式を変更することはなく、常に同じメジャーバージョン番号の以前およびそれ以降のマイナーリリースと互換性があります。たとえば、バージョン10.1はバージョン10.0およびバージョン10.6と互換性があります。同様に、たとえば9.5.3は9.5.0、9.5.1、9.5.6と互換性があります。互換性のあるバージョン間で更新するには、サーバーがダウンしている間に実行可能ファイルを置き換え、サーバーを再起動するだけです。データディレクトリは変更されません。マイナーアップグレードは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="c1792a6389bbff158897922be21e2febd6b41e73" translate="yes" xml:space="preserve">
          <source>Minor updates to this package were made by Bruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; in August/September of 2002. These include changing the precision from single precision to double precision and adding some new functions.</source>
          <target state="translated">このパッケージのマイナーアップデートは、2002年8月/ 9月にBruno Wolff III &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:bruno@wolff.to&quot;&gt;bruno@wolff.to&lt;/a&gt;&amp;gt;&lt;/code&gt; によって行われました。これには、単精度から倍精度への精度の変更や、いくつかの新しい関数の追加が含まれます。</target>
        </trans-unit>
        <trans-unit id="026961d2894207df681418954ca48774a983ec15" translate="yes" xml:space="preserve">
          <source>Minus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">SQL/JSONシーケンスを反復処理するマイナス演算子</target>
        </trans-unit>
        <trans-unit id="dc6ddd468d33fb3431787f38241bee7260f00eb6" translate="yes" xml:space="preserve">
          <source>Minutes (in the time part)</source>
          <target state="translated">分(時間の部分で</target>
        </trans-unit>
        <trans-unit id="dc12f1b1cf6a0bbb2272d3d7ce2040c69a7ecda0" translate="yes" xml:space="preserve">
          <source>Mixed Interval</source>
          <target state="translated">混合インターバル</target>
        </trans-unit>
        <trans-unit id="70c257e1738553c63bcb8eca3e2dc0f60349ef49" translate="yes" xml:space="preserve">
          <source>Mixing temporary and permanent relations in the same partition tree is not allowed. Hence, if the partitioned table is permanent, so must be its partitions and likewise if the partitioned table is temporary. When using temporary relations, all members of the partition tree have to be from the same session.</source>
          <target state="translated">同じパーティションツリーに一時的な関係と永続的な関係を混在させることは許されません。したがって、パーティショニングされたテーブルが永続的であれば、そのパーティションも永続的でなければなりませんし、パーティショニングされたテーブルが一時的であれば同様です。一時的なリレーションを使う場合、パーティションツリーのすべてのメンバは同じセッションのものでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="b543d8b0cd27fd8c88c5dd290fcb9193a6d18588" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.26&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">修飾子をテンプレートパターンに適用して、その動作を変更できます。たとえば、 &lt;code&gt;FMMonth&lt;/code&gt; は &lt;code&gt;FM&lt;/code&gt; 修飾子を使用した &lt;code&gt;Month&lt;/code&gt; パターンです。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;表9.26&lt;/a&gt;は、日付/時刻フォーマットの修飾子パターンを示しています。</target>
        </trans-unit>
        <trans-unit id="aa8e787d356e5a4bed4106486ef340d55a04bda6" translate="yes" xml:space="preserve">
          <source>Modifiers can be applied to any template pattern to alter its behavior. For example, &lt;code&gt;FMMonth&lt;/code&gt; is the &lt;code&gt;Month&lt;/code&gt; pattern with the &lt;code&gt;FM&lt;/code&gt; modifier. &lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;Table 9.27&lt;/a&gt; shows the modifier patterns for date/time formatting.</source>
          <target state="translated">修飾子を任意のテンプレートパターンに適用して、その動作を変更できます。たとえば、 &lt;code&gt;FMMonth&lt;/code&gt; は、 &lt;code&gt;FM&lt;/code&gt; 修飾子を使用した &lt;code&gt;Month&lt;/code&gt; パターンです。&lt;a href=&quot;functions-formatting#FUNCTIONS-FORMATTING-DATETIMEMOD-TABLE&quot;&gt;表9.27に&lt;/a&gt;、日付/時刻フォーマットの修飾子パターンを示します。</target>
        </trans-unit>
        <trans-unit id="ca58f6edfb3451890686c36bc73c14bf67559162" translate="yes" xml:space="preserve">
          <source>Modify an existing record using the values from an &lt;code&gt;hstore&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; の値を使用して既存のレコードを変更します。</target>
        </trans-unit>
        <trans-unit id="4f15aa8ca874492770383bfd8d9e19998f3752e1" translate="yes" xml:space="preserve">
          <source>Modifying Tables</source>
          <target state="translated">テーブルの修正</target>
        </trans-unit>
        <trans-unit id="a72464d357e833dd19b1829bd5b00731edf82afe" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Column</source>
          <target state="translated">テーブルの変更。列の追加</target>
        </trans-unit>
        <trans-unit id="b0a82b15be32cf23af7a5403931cbba2c3a6b302" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Adding a Constraint</source>
          <target state="translated">テーブルの変更。制約の追加</target>
        </trans-unit>
        <trans-unit id="8c76fff9cefc32ac15f30b5883253ecb9faf24b5" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Data Type</source>
          <target state="translated">テーブルの変更：列のデータ型の変更</target>
        </trans-unit>
        <trans-unit id="bad9bdb3a7e14e2048b20553d6893b9f2daeb0f9" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Changing a Column&amp;#x27;s Default Value</source>
          <target state="translated">テーブルの変更：列のデフォルト値の変更</target>
        </trans-unit>
        <trans-unit id="8649a9592e4298a7e8e6b1abb9ef2b90d9a5be2a" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Column</source>
          <target state="translated">テーブルの変更。列の削除</target>
        </trans-unit>
        <trans-unit id="98650a2f5b97076e75384a35883a830ea83870d0" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Removing a Constraint</source>
          <target state="translated">テーブルの変更。制約の削除</target>
        </trans-unit>
        <trans-unit id="6ee7fe42d54596a2449882ee5313efaaa712af34" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Column</source>
          <target state="translated">テーブルの変更。列の名前を変更する</target>
        </trans-unit>
        <trans-unit id="dc81484063645f8a58302e10322fd29ad17f1b92" translate="yes" xml:space="preserve">
          <source>Modifying Tables: Renaming a Table</source>
          <target state="translated">テーブルの変更。テーブルの名前を変更する</target>
        </trans-unit>
        <trans-unit id="c1e625a012d4612de9e088d7c2a093342964bb1f" translate="yes" xml:space="preserve">
          <source>Modifying a partitioned table or a table with inheritance children fires statement-level triggers attached to the explicitly named table, but not statement-level triggers for its partitions or child tables. In contrast, row-level triggers are fired on the rows in affected partitions or child tables, even if they are not explicitly named in the query. If a statement-level trigger has been defined with transition relations named by a &lt;code&gt;REFERENCING&lt;/code&gt; clause, then before and after images of rows are visible from all affected partitions or child tables. In the case of inheritance children, the row images include only columns that are present in the table that the trigger is attached to. Currently, row-level triggers with transition relations cannot be defined on partitions or inheritance child tables.</source>
          <target state="translated">パーティションテーブルまたは継承の子を持つテーブルを変更すると、明示的に名前が付けられたテーブルにアタッチされたステートメントレベルのトリガーが起動されますが、そのパーティションまたは子テーブルのステートメントレベルのトリガーは起動されません。対照的に、行レベルのトリガーは、クエリで明示的に指定されていなくても、影響を受けるパーティションまたは子テーブルの行で起動されます。ステートメントレベルのトリガーが &lt;code&gt;REFERENCING&lt;/code&gt; 句で指定された遷移関係で定義されている場合、影響を受けるすべてのパーティションまたは子テーブルから行の変更前と変更後のイメージが表示されます。継承の子の場合、行イメージには、トリガーがアタッチされているテーブルに存在する列のみが含まれます。現在、遷移関係を持つ行レベルのトリガーは、パーティションまたは継承の子テーブルでは定義できません。</target>
        </trans-unit>
        <trans-unit id="5a03c6c23d3b223671b9d8eba84851fccb59e4a7" translate="yes" xml:space="preserve">
          <source>Module for storing (key, value) pairs</source>
          <target state="translated">(キー、値)のペアを格納するためのモジュール</target>
        </trans-unit>
        <trans-unit id="8f46472981bee7fae7b3d41646aaa681175d3eb8" translate="yes" xml:space="preserve">
          <source>Modulo (remainder)</source>
          <target state="translated">モデュロ(余剰</target>
        </trans-unit>
        <trans-unit id="0216fd9c439582b27771fa19ad3c81fdf577f4c0" translate="yes" xml:space="preserve">
          <source>Modulo (remainder); available for &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">モジュロ（剰余）; &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、 &lt;code&gt;bigint&lt;/code&gt; 、 &lt;code&gt;numeric&lt;/code&gt; で使用できます</target>
        </trans-unit>
        <trans-unit id="58a0f28806f53fd75308c3f2a793267cf1428ae8" translate="yes" xml:space="preserve">
          <source>Modulus</source>
          <target state="translated">Modulus</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="6463498da98840aa3b093c82890614171c30b5ef" translate="yes" xml:space="preserve">
          <source>Monetary Types</source>
          <target state="translated">通貨の種類</target>
        </trans-unit>
        <trans-unit id="881c22df54316f0107467a0277ce497e98935f6d" translate="yes" xml:space="preserve">
          <source>Monetary Types: money</source>
          <target state="translated">貨幣の種類:貨幣</target>
        </trans-unit>
        <trans-unit id="a81434589757e654444719de434c44e9adc0c708" translate="yes" xml:space="preserve">
          <source>Monitoring</source>
          <target state="translated">Monitoring</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="ca09870a2f60b20cbbb11a8f1bfa5c112c7f2481" translate="yes" xml:space="preserve">
          <source>Months (in the date part)</source>
          <target state="translated">月(日付部分</target>
        </trans-unit>
        <trans-unit id="b362fae8ba4022e7ee2c51f663135e4f46fe57f1" translate="yes" xml:space="preserve">
          <source>More about &lt;code&gt;createdb&lt;/code&gt; and &lt;code&gt;dropdb&lt;/code&gt; can be found in &lt;a href=&quot;app-createdb&quot;&gt;createdb&lt;/a&gt; and &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; respectively.</source>
          <target state="translated">詳細を &lt;code&gt;createdb&lt;/code&gt; や &lt;code&gt;dropdb&lt;/code&gt; の中に見つけることができます&lt;a href=&quot;app-createdb&quot;&gt;CREATEDB&lt;/a&gt;や&lt;a href=&quot;app-dropdb&quot;&gt;dropdbの&lt;/a&gt;それぞれ。</target>
        </trans-unit>
        <trans-unit id="7d8a150db9b3697af1b840b6b8689717b67bec26" translate="yes" xml:space="preserve">
          <source>More complex grouping operations than those described above are possible using the concept of &lt;em&gt;grouping sets&lt;/em&gt;. The data selected by the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses is grouped separately by each specified grouping set, aggregates computed for each group just as for simple &lt;code&gt;GROUP BY&lt;/code&gt; clauses, and then the results returned. For example:</source>
          <target state="translated">上記のグループ化よりも複雑なグループ化操作は、&lt;em&gt;グループ化セットの&lt;/em&gt;概念を使用して可能です。 &lt;code&gt;FROM&lt;/code&gt; 句と &lt;code&gt;WHERE&lt;/code&gt; 句によって選択されたデータは、指定されたグループ化セットごとに個別にグループ化され、単純な &lt;code&gt;GROUP BY&lt;/code&gt; 句の場合と同様に各グループに対して集計が計算され、結果が返されます。例えば：</target>
        </trans-unit>
        <trans-unit id="32d9dc5690a3f6016671ea3b2ef25dc790df4069" translate="yes" xml:space="preserve">
          <source>More complex usage can produce undesirable results in Read Committed mode. For example, consider a &lt;code&gt;DELETE&lt;/code&gt; command operating on data that is being both added and removed from its restriction criteria by another command, e.g., assume &lt;code&gt;website&lt;/code&gt; is a two-row table with &lt;code&gt;website.hits&lt;/code&gt; equaling &lt;code&gt;9&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt;:</source>
          <target state="translated">より複雑な使用は、Read Committedモードで望ましくない結果を生成する可能性があります。たとえば、別のコマンドによって制限基準から追加および削除されているデータを操作する &lt;code&gt;DELETE&lt;/code&gt; コマンドを考えてみます。たとえば、 &lt;code&gt;website&lt;/code&gt; は、 &lt;code&gt;website.hits&lt;/code&gt; が &lt;code&gt;9&lt;/code&gt; と &lt;code&gt;10&lt;/code&gt; に等しい2行のテーブルであるとします。</target>
        </trans-unit>
        <trans-unit id="aa123892162b2a296320ac735b855a11c0d07673" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">ウィンドウ関数の詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.21&lt;/a&gt;、&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;セクション7.2.5&lt;/a&gt;、および&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;リファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="61e5e0cc940bc717e85dc5f00f1f583f6b05a316" translate="yes" xml:space="preserve">
          <source>More details about window functions can be found in &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;, and the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; reference page.</source>
          <target state="translated">ウィンドウ関数の詳細については、&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8&lt;/a&gt;、&lt;a href=&quot;functions-window&quot;&gt;セクション9.22&lt;/a&gt;、&lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;セクション7.2.5&lt;/a&gt;、および&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;リファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="dbf3214eaae892986b24caa3a28e76373d96aaab" translate="yes" xml:space="preserve">
          <source>More examples of using &lt;code&gt;jsonpath&lt;/code&gt; operators and methods within path expressions appear below in &lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;Section 9.16.2.2&lt;/a&gt;.</source>
          <target state="translated">パス式内で &lt;code&gt;jsonpath&lt;/code&gt; 演算子とメソッドを使用するその他の例は、以下の&lt;a href=&quot;functions-json#FUNCTIONS-SQLJSON-PATH-OPERATORS&quot;&gt;セクション9.16.2.2に示されてい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b706c980fab74ceb0b82c89e1d0e57333d172c3f" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">適切な入力および出力関数を含むその他の例は、&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html&quot;&gt;セクション37.13にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c2b364915a6606c0ca2495dd2cb97f36c000aeda" translate="yes" xml:space="preserve">
          <source>More examples, including suitable input and output functions, are in &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html&quot;&gt;Section 37.13&lt;/a&gt;.</source>
          <target state="translated">適切な入力および出力機能を含むその他の例は、&lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html&quot;&gt;セクション37.13にあり&lt;/a&gt;ます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
