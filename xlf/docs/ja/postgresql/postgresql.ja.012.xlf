<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d39ed9f52193cbb9703d5a56c5956b148e841314" translate="yes" xml:space="preserve">
          <source>On Linux 2.6 and later, it is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">Linux 2.6以降では、メモリを「オーバーコミット」しないようにカーネルの動作を変更することができます。この設定によって&lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOMキラー&lt;/a&gt;が完全に呼び出されるのを防ぐことはできませんが、可能性が大幅に低下するため、システムの動作がより堅牢になります。これは、 &lt;code&gt;sysctl&lt;/code&gt; を介して厳密なオーバーコミットモードを選択することによって行われます。</target>
        </trans-unit>
        <trans-unit id="501ddfe2d2530fe9fcac7688b14da5778270cdb1" translate="yes" xml:space="preserve">
          <source>On Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; determines the maximum number of open files that the kernel will support. It can be changed by writing a different number into the file or by adding an assignment in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. The maximum limit of files per process is fixed at the time the kernel is compiled; see &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; for more information.</source>
          <target state="translated">Linuxでは、 &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; は、カーネルがサポートするオープンファイルの最大数を決定します。これは、ファイルに別の番号を書き込むか、/ &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 割り当てを追加することで変更できます。プロセスあたりのファイルの最大数は、カーネルのコンパイル時に固定されています。詳細については、/ &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f009fe3fb04da9e8adcc93565c99cbfd73e2affe" translate="yes" xml:space="preserve">
          <source>On Linux and POSIX platforms &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; allows to force the OS that pages written by the checkpoint should be flushed to disk after a configurable number of bytes. Otherwise, these pages may be kept in the OS's page cache, inducing a stall when &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint. This setting will often help to reduce transaction latency, but it also can have an adverse effect on performance; particularly for workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache.</source>
          <target state="translated">LinuxおよびPOSIXプラットフォームでは、&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_afterを&lt;/a&gt;使用すると、チェックポイントによって書き込まれたページを、構成可能なバイト数の後にディスクにフラッシュすることをOSに強制できます。そうしないと、これらのページがOSのページキャッシュに保持され、チェックポイントの最後に &lt;code&gt;fsync&lt;/code&gt; が発行されたときにストールが発生する可能性があります。この設定は、多くの場合、トランザクションの待ち時間を短縮するのに役立ちますが、パフォーマンスに悪影響を与える可能性もあります。特に、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;よりも大きいが、OSのページキャッシュよりは小さいワークロードの場合。</target>
        </trans-unit>
        <trans-unit id="c936f58f7f62e48372e8a8076ff322928b68bb04" translate="yes" xml:space="preserve">
          <source>On Linux or Unix systems, you might use:</source>
          <target state="translated">LinuxやUnixシステムでは、使用するかもしれません。</target>
        </trans-unit>
        <trans-unit id="3f7c8c1bd4d71387a1210efd816cb3bef4ae3f74" translate="yes" xml:space="preserve">
          <source>On Linux systems either add</source>
          <target state="translated">Linuxシステムでは</target>
        </trans-unit>
        <trans-unit id="dc805fd8588880f607d3f4520d6ee5e450aee68a" translate="yes" xml:space="preserve">
          <source>On Linux, IDE and SATA drives can be queried using &lt;code&gt;hdparm -I&lt;/code&gt;; write caching is enabled if there is a &lt;code&gt;*&lt;/code&gt; next to &lt;code&gt;Write cache&lt;/code&gt;. &lt;code&gt;hdparm -W 0&lt;/code&gt; can be used to turn off write caching. SCSI drives can be queried using &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;. Use &lt;code&gt;sdparm --get=WCE&lt;/code&gt; to check whether the write cache is enabled and &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; to disable it.</source>
          <target state="translated">Linuxでは、IDEおよびSATAドライブは &lt;code&gt;hdparm -I&lt;/code&gt; を使用して照会できます。ある場合は、書き込みキャッシュが有効になっている &lt;code&gt;*&lt;/code&gt; 次へ &lt;code&gt;Write cache&lt;/code&gt; 。 &lt;code&gt;hdparm -W 0&lt;/code&gt; を使用して、書き込みキャッシュをオフにすることができます。SCSIドライブは&lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;を使用して照会できます。 &lt;code&gt;sdparm --get=WCE&lt;/code&gt; を使用して書き込みキャッシュが有効かどうかを確認し、 &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; を使用して無効にします。</target>
        </trans-unit>
        <trans-unit id="55da6c1d848d4260b86ebf92495a2847786e7138" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, also:</source>
          <target state="translated">Microsoft Windowsでも。</target>
        </trans-unit>
        <trans-unit id="3630213a83c6eeeff64f72e78908e323507bf7bd" translate="yes" xml:space="preserve">
          <source>On NetBSD, use either the FreeBSD or Linux start scripts, depending on preference.</source>
          <target state="translated">NetBSD では、好みに応じて FreeBSD または Linux の起動スクリプトを使用してください。</target>
        </trans-unit>
        <trans-unit id="ba742d094af1abbc78f9a3859fd3be730c7188af" translate="yes" xml:space="preserve">
          <source>On OpenBSD, add the following lines to the file &lt;code&gt;/etc/rc.local&lt;/code&gt;:</source>
          <target state="translated">OpenBSDでは、次の行をファイル &lt;code&gt;/etc/rc.local&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="6c2c1726b1c50e52c768b284b11ed29bfb8afb96" translate="yes" xml:space="preserve">
          <source>On Solaris, create a file called &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; that contains the following line:</source>
          <target state="translated">Solarisでは、次の行を含む &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; というファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="2bb8949d83fc7ef1475b557895bfe563a925aea9" translate="yes" xml:space="preserve">
          <source>On Solaris, the disk write cache is controlled by &lt;code&gt;format -e&lt;/code&gt;. (The Solaris ZFS file system is safe with disk write-cache enabled because it issues its own disk cache flush commands.)</source>
          <target state="translated">Solarisでは、ディスク書き込みキャッシュは &lt;code&gt;format -e&lt;/code&gt; によって制御されます。（Solaris ZFSファイルシステムは、独自のディスクキャッシュフラッシュコマンドを発行するため、ディスク書き込みキャッシュを有効にしても安全です。）</target>
        </trans-unit>
        <trans-unit id="d85af98780490009a295939145f84e031804f11c" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter reports the permissions of the data directory defined by (&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;) at startup. (On Microsoft Windows this parameter will always display &lt;code&gt;0700&lt;/code&gt;). See &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;group access&lt;/a&gt; for more information.</source>
          <target state="translated">Unixシステムでは、このパラメーターは、起動時に（&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;）によって定義されたデータディレクトリの権限を報告します。（Microsoft Windowsでは、このパラメーターは常に &lt;code&gt;0700&lt;/code&gt; を表示します）。詳細については、&lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;グループアクセス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5d93a70eed193dd90ef032ea7d63d19a6516eb0a" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter sets the permissions for log files when &lt;code&gt;logging_collector&lt;/code&gt; is enabled. (On Microsoft Windows this parameter is ignored.) The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="translated">Unixシステムでは、 &lt;code&gt;logging_collector&lt;/code&gt; が有効な場合、このパラメーターはログファイルの権限を設定します。 （Microsoft Windowsでは、このパラメーターは無視されます。）パラメーター値は、 &lt;code&gt;chmod&lt;/code&gt; および &lt;code&gt;umask&lt;/code&gt; システムコールで受け入れられる形式で指定された数値モードであることが期待されています。 （通常の8進形式を使用するには、数値は &lt;code&gt;0&lt;/code&gt; （ゼロ）で始まる必要があります。）</target>
        </trans-unit>
        <trans-unit id="aec768083a143a16efefa19e77bcef93265299f5" translate="yes" xml:space="preserve">
          <source>On Unix systems, the permissions on &lt;code&gt;server.key&lt;/code&gt; must disallow any access to world or group; achieve this by the command &lt;code&gt;chmod 0600 server.key&lt;/code&gt;. Alternatively, the file can be owned by root and have group read access (that is, &lt;code&gt;0640&lt;/code&gt; permissions). That setup is intended for installations where certificate and key files are managed by the operating system. The user under which the PostgreSQL server runs should then be made a member of the group that has access to those certificate and key files.</source>
          <target state="translated">Unixシステムでは、 &lt;code&gt;server.key&lt;/code&gt; の権限は、ワールドまたはグループへのアクセスをすべて許可しない必要があります。コマンド &lt;code&gt;chmod 0600 server.key&lt;/code&gt; でこれを実現します。または、ファイルをrootが所有し、グループに読み取りアクセス権（つまり &lt;code&gt;0640&lt;/code&gt; 権限）を付与することもできます。このセットアップは、証明書とキーファイルがオペレーティングシステムによって管理されるインストールを対象としています。次に、PostgreSQLサーバーを実行するユーザーを、それらの証明書とキーファイルにアクセスできるグループのメンバーにする必要があります。</target>
        </trans-unit>
        <trans-unit id="e0de69e7d7ec6add644868e783650d15d55a6f2e" translate="yes" xml:space="preserve">
          <source>On Windows hosts, preloading a library at server start will not reduce the time required to start each new server process; each server process will re-load all preload libraries. However, &lt;code&gt;shared_preload_libraries&lt;/code&gt; is still useful on Windows hosts for libraries that need to perform operations at postmaster start time.</source>
          <target state="translated">Windowsホストでは、サーバーの起動時にライブラリをプリロードしても、新しい各サーバープロセスの起動に必要な時間は短縮されません。各サーバープロセスは、すべてのプリロードライブラリを再ロードします。ただし、 &lt;code&gt;shared_preload_libraries&lt;/code&gt; 開始時に操作を実行する必要があるライブラリーのWindowsホストでは、shared_preload_librariesが引き続き役立ちます。</target>
        </trans-unit>
        <trans-unit id="08c92789aa023ae69cee69a7db7a2ae77f278c4c" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;wal_sync_method&lt;/code&gt; is &lt;code&gt;open_datasync&lt;/code&gt; (the default), write caching can be disabled by unchecking &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt;. Alternatively, set &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync&lt;/code&gt; or &lt;code&gt;fsync_writethrough&lt;/code&gt;, which prevent write caching.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;wal_sync_method&lt;/code&gt; が &lt;code&gt;open_datasync&lt;/code&gt; （デフォルト）の場合、 &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt; cache on the diskのチェックを外すと、書き込みキャッシュを無効にできます。また、セット &lt;code&gt;wal_sync_method&lt;/code&gt; へ &lt;code&gt;fsync&lt;/code&gt; または &lt;code&gt;fsync_writethrough&lt;/code&gt; で書き込みキャッシュを防ぐため、。</target>
        </trans-unit>
        <trans-unit id="81eec3e42d4f18ead15b1e929550fb213358fb1f" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 1 second, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">Windowsでは、システムのデフォルト値を読み取る方法がないため、値を0に設定すると、このパラメータは1秒に設定されます。</target>
        </trans-unit>
        <trans-unit id="53478c470af75305cb8745b03e7cb49bde700061" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 2 hours, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">Windowsでは、システムのデフォルト値を読み取る方法がないため、値を0に設定すると、このパラメータは2時間に設定されます。</target>
        </trans-unit>
        <trans-unit id="c0312ea0b4215b07b7b0ad5539831203f3c1aa4d" translate="yes" xml:space="preserve">
          <source>On Windows, when you use the &lt;code&gt;eventlog&lt;/code&gt; option for &lt;code&gt;log_destination&lt;/code&gt;, you should register an event source and its library with the operating system so that the Windows Event Viewer can display event log messages cleanly. See &lt;a href=&quot;event-log-registration&quot;&gt;Section 18.12&lt;/a&gt; for details.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;log_destination&lt;/code&gt; に &lt;code&gt;eventlog&lt;/code&gt; オプションを使用する場合、イベントソースとそのライブラリをオペレーティングシステムに登録して、Windowsイベントビューアがイベントログメッセージをきれいに表示できるようにする必要があります。詳細は&lt;a href=&quot;event-log-registration&quot;&gt;項18.12&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5ae51b938e943ee6107b7e5c25bdb8c42c5ee40" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;received_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">ホットスタンバイでは、&lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt;ビューを介してWALレシーバープロセスのステータスを取得できます。 &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; とビューの &lt;code&gt;received_lsn&lt;/code&gt; の大きな違いは、WALが再生よりも速く受信されていることを示しています。</target>
        </trans-unit>
        <trans-unit id="a87ef11e5bf076fa4c6ca218448b2458c3ebe4c9" translate="yes" xml:space="preserve">
          <source>On all currently supported platforms, the &lt;code&gt;real&lt;/code&gt; type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The &lt;code&gt;double precision&lt;/code&gt; type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</source>
          <target state="translated">現在サポートされているすべてのプラットフォームで、 &lt;code&gt;real&lt;/code&gt; 型の範囲は約1E-37から1E + 37で、精度は少なくとも10進数です。 &lt;code&gt;double precision&lt;/code&gt; 型は、少なくとも15桁の精度で1E + 308の周りの1E-307の範囲を有します。値が大きすぎたり小さすぎたりすると、エラーが発生します。入力数値の精度が高すぎる場合、丸めが行われる可能性があります。ゼロとは異なり、表現できないゼロに近すぎる数値は、アンダーフローエラーの原因になります。</target>
        </trans-unit>
        <trans-unit id="fc9f60ea02e43afcbb3f8733c606556d9627a339" translate="yes" xml:space="preserve">
          <source>On all platforms, the collations named &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; are available. Additional collations may be available depending on operating system support. The &lt;code&gt;default&lt;/code&gt; collation selects the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; values specified at database creation time. The &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations both specify &amp;ldquo;traditional C&amp;rdquo; behavior, in which only the ASCII letters &amp;ldquo;&lt;code&gt;A&lt;/code&gt;&amp;rdquo; through &amp;ldquo;&lt;code&gt;Z&lt;/code&gt;&amp;rdquo; are treated as letters, and sorting is done strictly by character code byte values.</source>
          <target state="translated">すべてのプラットフォームで、 &lt;code&gt;default&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; 、および &lt;code&gt;POSIX&lt;/code&gt; という名前の照合が使用可能です。オペレーティングシステムのサポートによっては、追加の照合が使用できる場合があります。 &lt;code&gt;default&lt;/code&gt; 照合が選択 &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の値は、データベースの作成時に指定しました。 &lt;code&gt;C&lt;/code&gt; と &lt;code&gt;POSIX&lt;/code&gt; 照合のみASCII文字「とは、「伝統的なC」挙動、指定両方 &lt;code&gt;A&lt;/code&gt; 」から「 &lt;code&gt;Z&lt;/code&gt; が」文字として扱われ、ソートは、文字コードのバイト値によって厳密に行われています。</target>
        </trans-unit>
        <trans-unit id="1c0634f5bf5f884787664141e116cb74ad234b48" translate="yes" xml:space="preserve">
          <source>On error, the server can abort the authentication at any stage, and send an ErrorMessage.</source>
          <target state="translated">エラーが発生した場合、サーバは任意の段階で認証を中止し、ErrorMessageを送信することができます。</target>
        </trans-unit>
        <trans-unit id="5350086780663aaf1bd7a44ba47818175298a073" translate="yes" xml:space="preserve">
          <source>On macOS, write caching can be prevented by setting &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync_writethrough&lt;/code&gt;.</source>
          <target state="translated">macOSでは、 &lt;code&gt;wal_sync_method&lt;/code&gt; を &lt;code&gt;fsync_writethrough&lt;/code&gt; に設定することにより、書き込みキャッシュを防止できます。</target>
        </trans-unit>
        <trans-unit id="befd8f0dca607b26fc6d2d970cd74ce25f6b225a" translate="yes" xml:space="preserve">
          <source>On many systems, however, syslog is not very reliable, particularly with large log messages; it might truncate or drop messages just when you need them the most. Also, on Linux, syslog will flush each message to disk, yielding poor performance. (You can use a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; at the start of the file name in the syslog configuration file to disable syncing.)</source>
          <target state="translated">ただし、多くのシステムでは、特に大きなログメッセージの場合、syslogの信頼性はあまり高くありません。最も必要なときにだけメッセージを切り捨てるか、ドロップする可能性があります。また、Linuxでは、syslogが各メッセージをディスクにフラッシュするため、パフォーマンスが低下します。（syslog構成ファイルのファイル名の先頭に「 &lt;code&gt;-&lt;/code&gt; 」を使用して、同期を無効にすることができます。）</target>
        </trans-unit>
        <trans-unit id="cb6093f7e35a1c20e326af32dcefbf608a486601" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, PostgreSQL modifies its command title as reported by &lt;code&gt;ps&lt;/code&gt;, so that individual server processes can readily be identified. A sample display is</source>
          <target state="translated">ほとんどのUnixプラットフォームでは、PostgreSQLは &lt;code&gt;ps&lt;/code&gt; によって報告されたコマンドタイトルを変更するため、個々のサーバープロセスを簡単に識別できます。表示例は</target>
        </trans-unit>
        <trans-unit id="d3b91e78aa6712803e0d5864f8e480013e5bf3c9" translate="yes" xml:space="preserve">
          <source>On most Unix systems, you will need to alter the configuration of your system's syslog daemon in order to make use of the syslog option for &lt;code&gt;log_destination&lt;/code&gt;. PostgreSQL can log to syslog facilities &lt;code&gt;LOCAL0&lt;/code&gt; through &lt;code&gt;LOCAL7&lt;/code&gt; (see &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;), but the default syslog configuration on most platforms will discard all such messages. You will need to add something like:</source>
          <target state="translated">ほとんどのUnixシステムでは、 &lt;code&gt;log_destination&lt;/code&gt; の syslogオプションを利用するために、システムのsyslogデーモンの構成を変更する必要があります。 PostgreSQLはsyslogのファシリティにログインすることができます &lt;code&gt;LOCAL0&lt;/code&gt; を通じて &lt;code&gt;LOCAL7&lt;/code&gt; （参照&lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;SYSLOG_FACILITYを&lt;/a&gt;）が、ほとんどのプラットフォームのデフォルトのsyslog設定では、すべてのそのようなメッセージを破棄します。次のようなものを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="50e3c6b1dcc491688ab2b7696ca3d74d8a9db77d" translate="yes" xml:space="preserve">
          <source>On most modern operating systems, PostgreSQL can determine which character set is implied by the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting.</source>
          <target state="translated">最近のほとんどのオペレーティングシステムでは、PostgreSQLは &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定によってどの文字セットが暗示されるかを判別でき、一致するデータベースエンコーディングのみが使用されるように強制します。古いシステムでは、選択したロケールで想定されているエンコーディングを使用するようにする必要があります。この領域での間違いは、ソートなどのロケールに依存する操作の奇妙な動作につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b2260de2d5df529fa47da0a7e6dd5d8bb23e03ee" translate="yes" xml:space="preserve">
          <source>On most platforms, if PostgreSQL is built with &lt;code&gt;--enable-dtrace&lt;/code&gt;, the arguments to a trace macro will be evaluated whenever control passes through the macro, &lt;em&gt;even if no tracing is being done&lt;/em&gt;. This is usually not worth worrying about if you are just reporting the values of a few local variables. But beware of putting expensive function calls into the arguments. If you need to do that, consider protecting the macro with a check to see if the trace is actually enabled:</source>
          <target state="translated">ほとんどのプラットフォームでは、PostgreSQLが &lt;code&gt;--enable-dtrace&lt;/code&gt; を使用してビルドされ&lt;em&gt;ている場合、トレースが実行されていなくても&lt;/em&gt;、制御がマクロを通過するたびにトレースマクロへの引数が評価&lt;em&gt;され&lt;/em&gt;ます。いくつかのローカル変数の値をレポートするだけの場合、これは通常心配する価値はありません。ただし、引数に高価な関数呼び出しを含めることに注意してください。これを行う必要がある場合は、チェックを使用してマクロを保護し、トレースが実際に有効になっているかどうかを確認することを検討してください。</target>
        </trans-unit>
        <trans-unit id="d1a020e1e97e31739abdd2c2ef2354878b9e297e" translate="yes" xml:space="preserve">
          <source>On one system, an &lt;code&gt;EXPLAIN&lt;/code&gt; showed a query with a cost of 8488 was reduced to a cost of 329. The original query was a join involving the &lt;code&gt;one_to_many&lt;/code&gt; table, which was replaced by:</source>
          <target state="translated">1つのシステムで、 &lt;code&gt;EXPLAIN&lt;/code&gt; は8488のコストのクエリが329のコストに削減されたことを示しました。元のクエリは、 &lt;code&gt;one_to_many&lt;/code&gt; テーブルを含む結合でした。</target>
        </trans-unit>
        <trans-unit id="46913037bc93da8c08a056c91624219985822221" translate="yes" xml:space="preserve">
          <source>On output, double quotes always surround keys and values, even when it's not strictly necessary.</source>
          <target state="translated">出力では、二重引用符は、厳密には必要でない場合でも、常にキーと値を囲みます。</target>
        </trans-unit>
        <trans-unit id="bac2b8b67734755e62d6acef24655269b5ebc6a2" translate="yes" xml:space="preserve">
          <source>On some newer Linux systems, it's possible to change the clock source used to collect timing data at any time. A second example shows the slowdown possible from switching to the slower acpi_pm time source, on the same system used for the fast results above:</source>
          <target state="translated">いくつかの新しい Linux システムでは、タイミングデータの収集に使用するクロックソースをいつでも変更することができます。2 番目の例は、上記の高速な結果に使用したのと同じシステムで、遅い acpi_pm のタイムソースに切り替えた場合のスローダウンを示しています。</target>
        </trans-unit>
        <trans-unit id="9ce5931c68b8a455769ec944aab5c902a50f0a9b" translate="yes" xml:space="preserve">
          <source>On some operating systems, the status of data in the kernel's page cache is unknown after a write-back failure. In some cases it might have been entirely forgotten, making it unsafe to retry; the second attempt may be reported as successful, when in fact the data has been lost. In these circumstances, the only way to avoid data loss is to recover from the WAL after any failure is reported, preferably after investigating the root cause of the failure and replacing any faulty hardware.</source>
          <target state="translated">オペレーティングシステムによっては、書き込みに失敗した後、カーネルのページキャッシュ内のデータの状態が不明な場合があります。場合によっては、データが完全に忘れ去られていて、再試行が安全でないこともあります。このような状況では、データの損失を避ける唯一の方法は、障害が報告された後、障害の根本原因を調査し、障害のあるハードウェアを交換した後に、WALから回復することです。</target>
        </trans-unit>
        <trans-unit id="eee21b404ba214868f7afb4e8cb293a79759405b" translate="yes" xml:space="preserve">
          <source>On some systems, this locale category does not exist. Setting this variable will still work, but there will be no effect. Also, there is a chance that no translated messages for the desired language exist. In that case you will continue to see the English messages.</source>
          <target state="translated">システムによっては、このロケールカテゴリが存在しない場合があります。この変数を設定しても動作しますが、何の効果もありません。また、希望する言語に翻訳されたメッセージが存在しない可能性もあります。その場合、英語のメッセージが表示され続けます。</target>
        </trans-unit>
        <trans-unit id="d8426bc3d71cab36b2e69aeb3bfdd7499b750f4a" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*recheck&lt;/code&gt; should be set to true if the heap tuple needs to be rechecked against the query operator, or false if the index test is exact. That is, a false return value guarantees that the heap tuple does not match the query; a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to false guarantees that the heap tuple does match the query; and a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to true means that the heap tuple might match the query, so it needs to be fetched and rechecked by evaluating the query operator directly against the originally indexed item.</source>
          <target state="translated">成功した場合、ヒープタプルをクエリ演算子に対して再チェックする必要がある場合は &lt;code&gt;*recheck&lt;/code&gt; をtrueに設定し、インデックステストが正確な場合はfalseに設定する必要があります。つまり、falseの戻り値は、ヒープタプルがクエリと一致しないことを保証します。 &lt;code&gt;*recheck&lt;/code&gt; がfalseに設定されたtrueの戻り値は、ヒープタプルがクエリに一致することを保証します。 &lt;code&gt;*recheck&lt;/code&gt; がtrueに設定されたtrueの戻り値は、ヒープタプルがクエリと一致する可能性があることを意味します。そのため、クエリ演算子を最初にインデックス付けされたアイテムに対して直接評価することにより、フェッチして再チェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="471ab7df5323b9c1beeab9b6ad11a4a3d81ba199" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;COPY&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;COPY&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="a330b5f61b3e5eaefa54001cda5edd47cd225306" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;DELETE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;DELETE&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="606df5c042bda87282091ed6e870632af55a409b" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;FETCH&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;FETCH&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="522cefa61331276f75d9354dde07beed068c55b2" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;MOVE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;MOVE&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="10a00a825ef1af18a74c6369608739640c2c6694" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;INSERT&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;INSERT&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="adea3b7cb9bb8d678c08759a0633a3db722c1eb8" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;UPDATE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">正常に完了すると、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドは次の形式のコマンドタグを返します</target>
        </trans-unit>
        <trans-unit id="17c3054fe4ff4e4031ec1aca452c9f2fbf414b42" translate="yes" xml:space="preserve">
          <source>On systems that have PostgreSQL started at boot time, there is probably a start-up file that will accomplish the same thing. For example, on a Red Hat Linux system one might find that this works:</source>
          <target state="translated">ブート時にPostgreSQLを起動するシステムでは、おそらく同じことを行う起動ファイルがあるでしょう。例えば、Red Hat Linuxシステムでは、これが動作していることがわかるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5c79b94518a5311140dc7e0d3b2812f742d2b393" translate="yes" xml:space="preserve">
          <source>On systems that support the keepalive socket option, setting &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;, &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; helps the primary promptly notice a broken connection.</source>
          <target state="translated">キープアライブソケットオプションをサポートするシステムでは、&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;、&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt;、および&lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt;を設定すると、プライマリが接続の切断に迅速に気付くのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1fa1a4c2c8b8530e986a78ada66b4ce0e77848ad" translate="yes" xml:space="preserve">
          <source>On systems with less than 1GB of RAM, a smaller percentage of RAM is appropriate, so as to leave adequate space for the operating system.</source>
          <target state="translated">RAMが1GB未満のシステムでは、オペレーティングシステムのための十分なスペースを残すために、RAMの割合を小さくすることが適切です。</target>
        </trans-unit>
        <trans-unit id="f7c83da74a1e6d13c844e01daa0931d96bf79bb8" translate="yes" xml:space="preserve">
          <source>On that date, there were two possible interpretations of 2:30AM; there was 2:30AM EDT, and then an hour later after the reversion to standard time, there was 2:30AM EST. Again, PostgreSQL interprets the given time as if it were standard time (UTC-5). We can force the matter by specifying daylight-savings time:</source>
          <target state="translated">その日の午前2時30分には2つの解釈が考えられます。午前2時30分EDTと、標準時に戻ってから1時間後に午前2時30分ESTとなりました。ここでもPostgreSQLは、与えられた時間をあたかも標準時(UTC-5)であるかのように解釈します。サマータイムを指定することで、この問題を強制的に解決することができます。</target>
        </trans-unit>
        <trans-unit id="108bc1acbd3eb627957c49ac13cf1805b058d6fd" translate="yes" xml:space="preserve">
          <source>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</source>
          <target state="translated">一方、JSON存在演算子は入れ子になっていないので、JSON値の最上位で指定されたキーや配列要素のみを探します。</target>
        </trans-unit>
        <trans-unit id="0944856f78282776625887773317f5e5a29f6901" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet:</source>
          <target state="translated">一方、以下のクエリは、州都ではなく、標高500フィート以上の場所にあるすべての都市を検索します。</target>
        </trans-unit>
        <trans-unit id="8d66d041f4d766c1f0ee27254b9b736aa4e0885c" translate="yes" xml:space="preserve">
          <source>On the other hand, the prefix operator &lt;code&gt;~&lt;/code&gt; (bitwise negation) is defined only for integer data types, not for &lt;code&gt;float8&lt;/code&gt;. So, if we try a similar case with &lt;code&gt;~&lt;/code&gt;, we get:</source>
          <target state="translated">一方、接頭辞演算子 &lt;code&gt;~&lt;/code&gt; （ビットごとの否定）は、整数データ型に対してのみ定義され、 &lt;code&gt;float8&lt;/code&gt; に対しては定義されません。したがって、 &lt;code&gt;~&lt;/code&gt; で同様のケースを試すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e3fb0b420bf61dd2f01fedc471af93946522a689" translate="yes" xml:space="preserve">
          <source>On the other hand, the structurally similar case</source>
          <target state="translated">一方、構造的に類似している場合</target>
        </trans-unit>
        <trans-unit id="aa512d53935676cc08f57c9480c2f5a40cb3a7f6" translate="yes" xml:space="preserve">
          <source>On the other side of the coin, some systems allow individual processes to open large numbers of files; if more than a few processes do so then the system-wide limit can easily be exceeded. If you find this happening, and you do not want to alter the system-wide limit, you can set PostgreSQL's &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; configuration parameter to limit the consumption of open files.</source>
          <target state="translated">反対に、一部のシステムでは、個々のプロセスが多数のファイルを開くことができます。いくつかのプロセスがそうする場合、システム全体の制限を簡単に超える可能性があります。これが発生していて、システム全体の制限を変更したくない場合は、PostgreSQLの&lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt;構成パラメーターを設定して、開いているファイルの消費を制限できます。</target>
        </trans-unit>
        <trans-unit id="e90706123ac00808e07c484e32d4635f07e67a74" translate="yes" xml:space="preserve">
          <source>On the primary server, these cases simply result in waiting; and the user might choose to cancel either of the conflicting actions. However, on the standby there is no choice: the WAL-logged action already occurred on the primary so the standby must not fail to apply it. Furthermore, allowing WAL application to wait indefinitely may be very undesirable, because the standby's state will become increasingly far behind the primary's. Therefore, a mechanism is provided to forcibly cancel standby queries that conflict with to-be-applied WAL records.</source>
          <target state="translated">プライマリサーバでは、これらのケースは単に待機状態になるだけであり、ユーザは相反するアクションのいずれかをキャンセルすることを選ぶかもしれない。しかし、スタンバイ側では選択の余地はありません。WALがログに記録されたアクションはプライマリ側で既に発生しているので、スタンバイ側ではその適用に失敗してはいけません。さらに、WALの適用を無期限に待機させることは、スタンバイの状態がプライマリの状態よりもずっと遅れてしまうので、非常に望ましくないかもしれません。そこで、適用されるべきWALレコードと競合するスタンバイクエリを強制的にキャンセルする仕組みが提供されています。</target>
        </trans-unit>
        <trans-unit id="12047b5caa5d65a62660b71617de0d4a759ef067" translate="yes" xml:space="preserve">
          <source>On the primary, parameters &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; have no effect if set on the primary.</source>
          <target state="translated">プライマリでは、パラメータ&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;を使用できます。&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;と&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;は、プライマリで設定しても効果がありません。</target>
        </trans-unit>
        <trans-unit id="f4d2789c0f0275ad798be7e6d4e299236ebe91e1" translate="yes" xml:space="preserve">
          <source>On the publisher side, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;max_replication_slots&lt;/code&gt; must be set to at least the number of subscriptions expected to connect, plus some reserve for table synchronization. And &lt;code&gt;max_wal_senders&lt;/code&gt; should be set to at least the same as &lt;code&gt;max_replication_slots&lt;/code&gt; plus the number of physical replicas that are connected at the same time.</source>
          <target state="translated">出版社側では、 &lt;code&gt;wal_level&lt;/code&gt; をに設定する必要があります &lt;code&gt;logical&lt;/code&gt; 、および &lt;code&gt;max_replication_slots&lt;/code&gt; は少なくとも接続することが予想サブスクリプションの数に加え、テーブルの同期のためのいくつかの予備に設定する必要があります。また、 &lt;code&gt;max_wal_senders&lt;/code&gt; は、少なくとも &lt;code&gt;max_replication_slots&lt;/code&gt; と、同時に接続されている物理レプリカの数を足したものと同じに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="35745b04684e80ded8dc5507c072fa2674283617" translate="yes" xml:space="preserve">
          <source>On the standby, parameters &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; has no effect as long as the server remains in standby mode, though it will become relevant if the standby becomes primary.</source>
          <target state="translated">スタンバイでは、パラメータ&lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;、&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt;を使用できます。&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;は、サーバーがスタンバイモードである限り効果がありませんが、スタンバイがプライマリになると関連性が出てきます。</target>
        </trans-unit>
        <trans-unit id="70715c6fbe3e407765f6386cd308c88b6865cc56" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;UNLISTEN&lt;/code&gt; has been executed, further &lt;code&gt;NOTIFY&lt;/code&gt; messages will be ignored:</source>
          <target state="translated">一度 &lt;code&gt;UNLISTEN&lt;/code&gt; が実行された、更なる &lt;code&gt;NOTIFY&lt;/code&gt; メッセージは無視されます。</target>
        </trans-unit>
        <trans-unit id="ec65ec416b46f0c02b02945a4d9803e7d39332ca" translate="yes" xml:space="preserve">
          <source>Once a client is connected to the database, PostgreSQL provides two additional SQL commands (and equivalent functions) to interact with session-local configuration settings:</source>
          <target state="translated">クライアントがデータベースに接続されると、PostgreSQLはセッションローカルの設定と対話するための2つの追加SQLコマンド(および同等の関数)を提供します。</target>
        </trans-unit>
        <trans-unit id="356c49cf82618dc4e123a48d759d153fd0e38847" translate="yes" xml:space="preserve">
          <source>Once a connection is established the client process can send a query to the &lt;em&gt;backend&lt;/em&gt; (server). The query is transmitted using plain text, i.e., there is no parsing done in the &lt;em&gt;frontend&lt;/em&gt; (client). The server parses the query, creates an &lt;em&gt;execution plan&lt;/em&gt;, executes the plan and returns the retrieved rows to the client by transmitting them over the established connection.</source>
          <target state="translated">接続が確立されると、クライアントプロセスはクエリを&lt;em&gt;バックエンド&lt;/em&gt;（サーバー）に送信できます。クエリはプレーンテキストを使用して送信されます。つまり、&lt;em&gt;フロントエンド&lt;/em&gt;（クライアント）で解析は行われません。サーバーはクエリを解析し、&lt;em&gt;実行プランを&lt;/em&gt;作成し、&lt;em&gt;プラン&lt;/em&gt;を実行し、確立された接続を介してそれらを送信することにより、取得した行をクライアントに返します。</target>
        </trans-unit>
        <trans-unit id="5ad9c4a6213a012c3300efd580e40047d30505b8" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held till end of transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">いったん獲得されると、ロックは通常、トランザクションの終わりまで保持されます。ただし、セーブポイントの確立後にロックが取得された場合、セーブポイントがロールバックされるとすぐにロックが解除されます。これは、セーブポイント以降、 &lt;code&gt;ROLLBACK&lt;/code&gt; がコマンドのすべての効果をキャンセルするという原則と一致しています。 PL / pgSQL例外ブロック内で取得されたロックについても同様です。ブロックからのエラーエスケープは、ブロック内で取得されたロックを解放します。</target>
        </trans-unit>
        <trans-unit id="41f916b016e9381b5815b3e4089f244578b1cdbc" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">インデックスが作成されると、それ以上の介入は必要ありません。システムはテーブルが変更されたときにインデックスを更新し、順次テーブルスキャンよりも効率的であると考えられる場合はクエリでインデックスを使用します。ただし、統計を更新してクエリプランナーが適切な判断を下せるようにするには、 &lt;code&gt;ANALYZE&lt;/code&gt; コマンドを定期的に実行する必要がある場合があります。インデックスが使用されているかどうか、およびプランナがインデックスを使用し&lt;em&gt;ない&lt;/em&gt;場合とその理由を確認する方法については、&lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;第14章を&lt;/a&gt;参照してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e5421d611a483b4f3357d11ff23a5acc44acb58" translate="yes" xml:space="preserve">
          <source>Once any valuable objects have been transferred to new owners, any remaining objects owned by the role-to-be-dropped can be dropped with the &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command. Again, this command cannot access objects in other databases, so it is necessary to run it in each database that contains objects owned by the role. Also, &lt;code&gt;DROP OWNED&lt;/code&gt; will not drop entire databases or tablespaces, so it is necessary to do that manually if the role owns any databases or tablespaces that have not been transferred to new owners.</source>
          <target state="translated">貴重なオブジェクトが新しい所有者に転送されると、&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt;コマンドを使用して、削除するロールが所有する残りのオブジェクトを削除できます。繰り返しますが、このコマンドは他のデータベースのオブジェクトにアクセスできないため、ロールが所有するオブジェクトを含む各データベースで実行する必要があります。また、 &lt;code&gt;DROP OWNED&lt;/code&gt; はデータベースまたはテーブルスペース全体を削除しないため、新しい所有者に転送されていないデータベースまたはテーブルスペースをロールが所有している場合は、手動で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="e81389b8f98e0c4fa0978b0ecbccf3ec2c7326c5" translate="yes" xml:space="preserve">
          <source>Once created, a tablespace can be used from any database, provided the requesting user has sufficient privilege. This means that a tablespace cannot be dropped until all objects in all databases using the tablespace have been removed.</source>
          <target state="translated">一度作成された表空間は、要求するユーザーが十分な権限を持っていれば、どのデータベースからでも使用することができます。これは、テーブルスペースを使用しているすべてのデータベースのすべてのオブジェクトが削除されるまで、テーブルスペースを削除できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="73da0c6102d03c025cdbc83b1b38fc971869013e" translate="yes" xml:space="preserve">
          <source>Once created, the enum type can be used in table and function definitions much like any other type:</source>
          <target state="translated">一度作成された enum 型は、他の型と同様にテーブルや関数の定義で使用することができます。</target>
        </trans-unit>
        <trans-unit id="c9f4d5e2b4aa9fc314da7481d260ca60dd53ed46" translate="yes" xml:space="preserve">
          <source>Once failover to the standby occurs, there is only a single server in operation. This is known as a degenerate state. The former standby is now the primary, but the former primary is down and might stay down. To return to normal operation, a standby server must be recreated, either on the former primary system when it comes up, or on a third, possibly new, system. The &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; utility can be used to speed up this process on large clusters. Once complete, the primary and standby can be considered to have switched roles. Some people choose to use a third server to provide backup for the new primary until the new standby server is recreated, though clearly this complicates the system configuration and operational processes.</source>
          <target state="translated">スタンバイへのフェイルオーバーが発生すると、稼働中のサーバーは1つだけになります。これは縮退状態と呼ばれます。以前のスタンバイは現在プライマリですが、以前のプライマリはダウンしており、ダウンしたままになる可能性があります。通常の動作に戻すには、スタンバイサーバーが、元のプライマリシステムが起動したとき、または3番目の、場合によっては新しいシステムで再作成する必要があります。&lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt;ユーティリティは、大規模なクラスタ上で、このプロセスをスピードアップするために使用することができます。完了すると、プライマリとスタンバイの役割が切り替わったと見なすことができます。一部の人々は、新しいスタンバイサーバーが再作成されるまで、新しいプライマリのバックアップを提供するために3番目のサーバーを使用することを選択しますが、これは明らかにシステム構成と運用プロセスを複雑にします。</target>
        </trans-unit>
        <trans-unit id="99eb90b007ab371c4c054db1b4a14dc72baaf9ae" translate="yes" xml:space="preserve">
          <source>Once prepared, a transaction can later be committed or rolled back with &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; or &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;, respectively. Those commands can be issued from any session, not only the one that executed the original transaction.</source>
          <target state="translated">準備が完了すると、トランザクションは後でそれぞれ&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;または&lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;を使用してコミットまたはロールバックできます。これらのコマンドは、元のトランザクションを実行したセッションだけでなく、どのセッションからでも発行できます。</target>
        </trans-unit>
        <trans-unit id="a26efc323b5a3b586fc58ac6b6adb6fb3937603a" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each database so the optimizer has useful statistics. You can also run &lt;code&gt;vacuumdb -a -z&lt;/code&gt; to analyze all databases.</source>
          <target state="translated">復元したら、各データベースで &lt;code&gt;ANALYZE&lt;/code&gt; を実行して、オプティマイザが有用な統計を取得できるようにすることをお勧めします。また、 &lt;code&gt;vacuumdb -a -z&lt;/code&gt; を実行して、すべてのデータベースを分析することもできます。</target>
        </trans-unit>
        <trans-unit id="e1c807b866ed2972017d5380e0a876fec0d03a30" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each restored table so the optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">復元されたら、復元された各テーブルで &lt;code&gt;ANALYZE&lt;/code&gt; を実行して、オプティマイザが有用な統計を取得することをお勧めします。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4f22ae97ca76db6661c3c1f5a88b003eb151976f" translate="yes" xml:space="preserve">
          <source>Once started, &lt;code&gt;pg_upgrade&lt;/code&gt; will verify the two clusters are compatible and then do the upgrade. You can use &lt;code&gt;pg_upgrade --check&lt;/code&gt; to perform only the checks, even if the old server is still running. &lt;code&gt;pg_upgrade --check&lt;/code&gt; will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link or clone mode, you should use the option &lt;code&gt;--link&lt;/code&gt; or &lt;code&gt;--clone&lt;/code&gt; with &lt;code&gt;--check&lt;/code&gt; to enable mode-specific checks. &lt;code&gt;pg_upgrade&lt;/code&gt; requires write permission in the current directory.</source>
          <target state="translated">起動すると、 &lt;code&gt;pg_upgrade&lt;/code&gt; は2つのクラスターに互換性があることを確認してからアップグレードを実行します。 &lt;code&gt;pg_upgrade --check&lt;/code&gt; を使用して、古いサーバーがまだ実行されている場合でも、チェックのみを実行できます。 &lt;code&gt;pg_upgrade --check&lt;/code&gt; は、アップグレード後に行う必要がある手動調整の概要も示します。リンクモードまたはクローンモードを使用する場合は、オプション &lt;code&gt;--link&lt;/code&gt; または &lt;code&gt;--clone&lt;/code&gt; を &lt;code&gt;--check&lt;/code&gt; とともに使用して、モード固有のチェックを有効にする必要があります。 &lt;code&gt;pg_upgrade&lt;/code&gt; には、現在のディレクトリでの書き込み権限が必要です。</target>
        </trans-unit>
        <trans-unit id="c713ae812f1782bcff8d86ab36ed9c6d151c330d" translate="yes" xml:space="preserve">
          <source>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; must be set to a non-empty value. &lt;code&gt;synchronous_commit&lt;/code&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but since this is the default value, typically no change is required. (See &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Section 19.5.1&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Section 19.6.2&lt;/a&gt;.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. &lt;code&gt;synchronous_commit&lt;/code&gt; can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</source>
          <target state="translated">ストリーミングレプリケーションが設定された後、同期レプリケーションを設定することは一つだけ追加の設定手順が必要です。&lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_namesは&lt;/a&gt;空でない値に設定する必要があります。 &lt;code&gt;synchronous_commit&lt;/code&gt; も &lt;code&gt;on&lt;/code&gt; に設定する必要がありますが、これはデフォルト値であるため、通常は変更する必要はありません。（&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;セクション19.5.1&lt;/a&gt;および&lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;セクション19.6.2を&lt;/a&gt;参照してください。）この構成により、各コミットは、スタンバイがコミットレコードを永続ストレージに書き込んだことの確認を待機します。 &lt;code&gt;synchronous_commit&lt;/code&gt; 個々のユーザーが設定できるため、特定のユーザーまたはデータベースの構成ファイルで構成することも、アプリケーションごとに動的に構成して、トランザクションごとに永続性の保証を制御することもできます。</target>
        </trans-unit>
        <trans-unit id="9871853da7c650c2f0dd2795f59e948ae7531634" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s first return value is the last segment that is required to form a complete set of backup files. On a primary, if &lt;code&gt;archive_mode&lt;/code&gt; is enabled and the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. On a standby, &lt;code&gt;archive_mode&lt;/code&gt; must be &lt;code&gt;always&lt;/code&gt; in order for &lt;code&gt;pg_stop_backup&lt;/code&gt; to wait. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of &lt;code&gt;pg_stop_backup&lt;/code&gt;, set an appropriate &lt;code&gt;statement_timeout&lt;/code&gt; value, but make note that if &lt;code&gt;pg_stop_backup&lt;/code&gt; terminates because of this your backup may not be valid.</source>
          <target state="translated">バックアップ中にアクティブなWALセグメントファイルがアーカイブされると、完了です。 &lt;code&gt;pg_stop_backup&lt;/code&gt; の最初の戻り値で識別されるファイルは、バックアップファイルの完全なセットを形成するために必要な最後のセグメントです。プライマリでは、 &lt;code&gt;archive_mode&lt;/code&gt; が有効で、 &lt;code&gt;wait_for_archive&lt;/code&gt; パラメータが &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; は最後のセグメントがアーカイブされるまで戻りません。スタンバイでは、 &lt;code&gt;pg_stop_backup&lt;/code&gt; が待機するために、 &lt;code&gt;archive_mode&lt;/code&gt; は &lt;code&gt;always&lt;/code&gt; なければなりません。これらのファイルのアーカイブは、 &lt;code&gt;archive_command&lt;/code&gt; がすでに構成されているため、自動的に行われます。。ほとんどの場合、これはすぐに発生しますが、アーカイブシステムを監視して、遅延がないことを確認することをお勧めします。アーカイブコマンドの失敗によりアーカイブプロセスが遅れた場合、アーカイブが成功してバックアップが完了するまで、再試行が続けられます。 &lt;code&gt;pg_stop_backup&lt;/code&gt; の実行に時間制限を設けたい場合は、適切な &lt;code&gt;statement_timeout&lt;/code&gt; 値を設定しますが、これが原因で &lt;code&gt;pg_stop_backup&lt;/code&gt; が終了した場合、バックアップが無効になる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="32e5f3f159f9a76e583d7e4dd4b47490f3262b2b" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s result is the last segment that is required to form a complete set of backup files. If &lt;code&gt;archive_mode&lt;/code&gt; is enabled, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete.</source>
          <target state="translated">バックアップ中にアクティブなWALセグメントファイルがアーカイブされると、完了です。 &lt;code&gt;pg_stop_backup&lt;/code&gt; の結果によって識別されるファイルは、バックアップファイルの完全なセットを形成するために必要な最後のセグメントです。 &lt;code&gt;archive_mode&lt;/code&gt; が有効な場合、 &lt;code&gt;pg_stop_backup&lt;/code&gt; は最後のセグメントがアーカイブされるまで戻りません。これらのファイルのアーカイブは、すでに &lt;code&gt;archive_command&lt;/code&gt; を構成しているため、自動的に行われます。ほとんどの場合、これはすぐに発生しますが、アーカイブシステムを監視して、遅延がないことを確認することをお勧めします。アーカイブコマンドの失敗によりアーカイブプロセスが遅れた場合、アーカイブが成功してバックアップが完了するまで、再試行が続けられます。</target>
        </trans-unit>
        <trans-unit id="5f47c9896865faba1d610987fd3b05badac486b3" translate="yes" xml:space="preserve">
          <source>Once the delay specified by &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; has been exceeded, conflicting queries will be canceled. This usually results just in a cancellation error, although in the case of replaying a &lt;code&gt;DROP DATABASE&lt;/code&gt; the entire conflicting session will be terminated. Also, if the conflict is over a lock held by an idle transaction, the conflicting session is terminated (this behavior might change in the future).</source>
          <target state="translated">&lt;code&gt;max_standby_archive_delay&lt;/code&gt; または &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; で指定された遅延を超えると、競合するクエリはキャンセルされます。 &lt;code&gt;DROP DATABASE&lt;/code&gt; を再生する場合、競合するセッション全体が終了しますが、これは通常、キャンセルエラーになります。また、競合がアイドルトランザクションによって保持されているロックを超えている場合、競合するセッションは終了します（この動作は将来変更される可能性があります）。</target>
        </trans-unit>
        <trans-unit id="b8e1074216e0451321cd3f251827b2e9872eaede" translate="yes" xml:space="preserve">
          <source>Once the group role exists, you can add and remove members using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands:</source>
          <target state="translated">グループの役割が存在する場合、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt;コマンドを使用してメンバーを追加および削除できます。</target>
        </trans-unit>
        <trans-unit id="69a71607e88d378416ed92ac7ffd6286dc445378" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">アップグレードに満足したら、 &lt;code&gt;pg_upgrade&lt;/code&gt; の完了時に言及されたスクリプトを実行して、古いクラスターのデータディレクトリを削除できます。（古いデータディレクトリ内にユーザー定義のテーブルスペースがある場合、自動削除はできません。）古いインストールディレクトリ（例： &lt;code&gt;bin&lt;/code&gt; 、 &lt;code&gt;share&lt;/code&gt; ）を削除することもできます。</target>
        </trans-unit>
        <trans-unit id="d5a7bdde6e82e682c3584d24535e62c92a86edd3" translate="yes" xml:space="preserve">
          <source>Once you have created a database, you can access it by:</source>
          <target state="translated">データベースを作成したら、以下の方法でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a17a3f555279791537a8bafe938cf8c6379fa784" translate="yes" xml:space="preserve">
          <source>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include &lt;code&gt;-i&lt;/code&gt;, that is</source>
          <target state="translated">あなたが必要な設定を行っているしたら、あなたは含まれていないコマンドを使用してベンチマークを実行することができます &lt;code&gt;-i&lt;/code&gt; をつまり、</target>
        </trans-unit>
        <trans-unit id="61eda2a3b905b905ee98026b455b6eb92908a307" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;postgres&lt;/code&gt; instance always manages the data of exactly one database cluster. A database cluster is a collection of databases that is stored at a common file system location (the &amp;ldquo;data area&amp;rdquo;). More than one &lt;code&gt;postgres&lt;/code&gt; instance can run on a system at one time, so long as they use different data areas and different communication ports (see below). When &lt;code&gt;postgres&lt;/code&gt; starts it needs to know the location of the data area. The location must be specified by the &lt;code&gt;-D&lt;/code&gt; option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable; there is no default. Typically, &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt; points directly to the data area directory created by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Other possible file layouts are discussed in &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt;.</source>
          <target state="translated">1つの &lt;code&gt;postgres&lt;/code&gt; インスタンスが常に1つのデータベースクラスタのデータを管理します。データベースクラスターは、一般的なファイルシステムの場所（「データ領域」）に格納されているデータベースの集まりです。異なるデータ領域と異なる通信ポートを使用している限り（以下を参照）、システム上で複数の &lt;code&gt;postgres&lt;/code&gt; インスタンスを同時に実行できます。とき &lt;code&gt;postgres&lt;/code&gt; 起動するには、データ領域の場所を知っている必要があります。場所は、 &lt;code&gt;-D&lt;/code&gt; オプションまたは &lt;code&gt;PGDATA&lt;/code&gt; 環境変数で指定する必要があります。デフォルトはありません。通常、 &lt;code&gt;-D&lt;/code&gt; または &lt;code&gt;PGDATA&lt;/code&gt; は、&lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;によって作成されたデータ領域ディレクトリを直接指します。。その他の可能なファイルレイアウトについては、&lt;a href=&quot;runtime-config-file-locations&quot;&gt;セクション19.2で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="8d2b8f4e1b139546c73a22f8f91fadc862c3170c" translate="yes" xml:space="preserve">
          <source>One advantage of GIN is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert. This is much the same advantage as using GiST.</source>
          <target state="translated">GINの利点の一つは、データベースの専門家ではなく、データ型のドメインの専門家によって、適切なアクセス方法でカスタムデータ型を開発できることです。これはGiSTを使用するのとほぼ同じ利点です。</target>
        </trans-unit>
        <trans-unit id="e058cfc0d2adb864aa10f7c9c5f44bcfe8be50f0" translate="yes" xml:space="preserve">
          <source>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiSTの利点の1つは、データベースの専門家ではなく、データ型のドメインに精通した専門家が、適切なアクセス方法でカスタムデータ型を開発できることです。</target>
        </trans-unit>
        <trans-unit id="f48b87ea34b25adefa4f3efa4a97db47fb753d95" translate="yes" xml:space="preserve">
          <source>One advantage of the separate-column approach over an expression index is that it is not necessary to explicitly specify the text search configuration in queries in order to make use of the index. As shown in the example above, the query can depend on &lt;code&gt;default_text_search_config&lt;/code&gt;. Another advantage is that searches will be faster, since it will not be necessary to redo the &lt;code&gt;to_tsvector&lt;/code&gt; calls to verify index matches. (This is more important when using a GiST index than a GIN index; see &lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;.) The expression-index approach is simpler to set up, however, and it requires less disk space since the &lt;code&gt;tsvector&lt;/code&gt; representation is not stored explicitly.</source>
          <target state="translated">式インデックスに対する個別列アプローチの利点の1つは、インデックスを利用するためにクエリでテキスト検索構成を明示的に指定する必要がないことです。上記の例に示すように、クエリは &lt;code&gt;default_text_search_config&lt;/code&gt; に依存する場合があります。もう1つの利点は、インデックスの一致を確認するために &lt;code&gt;to_tsvector&lt;/code&gt; 呼び出しをやり直す必要がないため、検索が高速になることです。（これは、GINインデックスよりもGiSTインデックスを使用する場合により重要です。&lt;a href=&quot;textsearch-indexes&quot;&gt;セクション12.9を&lt;/a&gt;参照してください。）ただし、式-インデックスアプローチは設定が簡単です。また、 &lt;code&gt;tsvector&lt;/code&gt; 表現が明示的に格納されないため、必要なディスク容量が少なくなります。</target>
        </trans-unit>
        <trans-unit id="c591e2a82e983192d18fdc29edda9221e37c6723" translate="yes" xml:space="preserve">
          <source>One advantage of using concatenation in the vector form, rather than concatenating text before applying &lt;code&gt;to_tsvector&lt;/code&gt;, is that you can use different configurations to parse different sections of the document. Also, because the &lt;code&gt;setweight&lt;/code&gt; function marks all lexemes of the given vector the same way, it is necessary to parse the text and do &lt;code&gt;setweight&lt;/code&gt; before concatenating if you want to label different parts of the document with different weights.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; を適用する前にテキストを連結するのではなく、ベクター形式で連結を使用する利点の1つは、さまざまな構成を使用してドキュメントのさまざまなセクションを解析できることです。また、関数 &lt;code&gt;setweight&lt;/code&gt; は指定されたベクトルのすべての語彙素を同じ方法でマークするため、ドキュメントの異なる部分に異なる重みでラベルを付ける場合は、連結する前にテキストを解析して &lt;code&gt;setweight&lt;/code&gt; を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="7aa492c47d8ea5d45e5da9a09ed3c6c96f7a96e5" translate="yes" xml:space="preserve">
          <source>One application of the rewrite system is in the realization of &lt;em&gt;views&lt;/em&gt;. Whenever a query against a view (i.e., a &lt;em&gt;virtual table&lt;/em&gt;) is made, the rewrite system rewrites the user's query to a query that accesses the &lt;em&gt;base tables&lt;/em&gt; given in the &lt;em&gt;view definition&lt;/em&gt; instead.</source>
          <target state="translated">書き換えシステムの1つのアプリケーションは、&lt;em&gt;ビュー&lt;/em&gt;の実現です。ビュー（つまり、&lt;em&gt;仮想テーブル&lt;/em&gt;）に対するクエリが作成されるたびに、書き換えシステムはユーザーのクエリを、&lt;em&gt;ビュー定義で&lt;/em&gt;指定された&lt;em&gt;ベーステーブルに&lt;/em&gt;アクセスするクエリに書き換えます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bee7fd28573b33fce2d46ef1ac5fa8251ec94562" translate="yes" xml:space="preserve">
          <source>One component of the statistics is the total number of entries in each table and index, as well as the number of disk blocks occupied by each table and index. This information is kept in the table &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;, in the columns &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt;. We can look at it with queries similar to this one:</source>
          <target state="translated">統計の1つの要素は、各テーブルとインデックスのエントリの総数、および各テーブルとインデックスが占めるディスクブロックの数です。この情報は、テーブル&lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt;の列 &lt;code&gt;reltuples&lt;/code&gt; および &lt;code&gt;relpages&lt;/code&gt; に保持されます。次のようなクエリで確認できます。</target>
        </trans-unit>
        <trans-unit id="4bd99552b099beafc96cbe7829988f7a06eb967b" translate="yes" xml:space="preserve">
          <source>One convenient way to create a compatible table that will later be made a new child is to use the &lt;code&gt;LIKE&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;. This creates a new table with the same columns as the source table. If there are any &lt;code&gt;CHECK&lt;/code&gt; constraints defined on the source table, the &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; option to &lt;code&gt;LIKE&lt;/code&gt; should be specified, as the new child must have constraints matching the parent to be considered compatible.</source>
          <target state="translated">後で新しい子になる互換性のあるテーブルを作成する便利な方法の1つは、 &lt;code&gt;CREATE TABLE&lt;/code&gt; で &lt;code&gt;LIKE&lt;/code&gt; 句を使用することです。これにより、ソーステーブルと同じ列を持つ新しいテーブルが作成されます。任意の存在する場合 &lt;code&gt;CHECK&lt;/code&gt; ソーステーブルの上に定義された制約は、 &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; のオプション &lt;code&gt;LIKE&lt;/code&gt; は、新しい子が互換性の考慮すべき親のマッチング制約を持たなければならないとして、指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="313d199647b14e908c91b6831b2ac1803fbc36c9" translate="yes" xml:space="preserve">
          <source>One could accomplish the same thing with, say,</source>
          <target state="translated">同じことを成し遂げることができます。</target>
        </trans-unit>
        <trans-unit id="7bcb03e673340a4965d50eadd319bf1730dddebc" translate="yes" xml:space="preserve">
          <source>One disadvantage of decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; is that it might cause &lt;code&gt;VACUUM&lt;/code&gt; to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; を減らすことの1つの欠点は、 &lt;code&gt;VACUUM&lt;/code&gt; が無駄な作業を行う可能性があることです。行バージョンを凍結すると、その行がすぐに変更された場合（新しいXIDを取得するため）、時間の無駄になります。そのため、設定は、行が変更されなくなるまで行が凍結されないように十分な大きさにする必要があります。</target>
        </trans-unit>
        <trans-unit id="d99c8486b08ccc8839ea87cdfcd9e4516a4d63fc" translate="yes" xml:space="preserve">
          <source>One disadvantage of the longitude/latitude representation is that you need to be careful about the edge conditions near the poles and near +/- 180 degrees of longitude. The &lt;code&gt;cube&lt;/code&gt;-based representation avoids these discontinuities.</source>
          <target state="translated">経度/緯度表現の1つの欠点は、極付近および経度の+/- 180度付近のエッジ条件に注意する必要があることです。 &lt;code&gt;cube&lt;/code&gt; ベースの表現は、これらの不連続を回避することができます。</target>
        </trans-unit>
        <trans-unit id="17918ae437c6b6c4eb55d620ac26a6167c3d73b5" translate="yes" xml:space="preserve">
          <source>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</source>
          <target state="translated">このメカニズムの使用例の一つは、ファイルの内容をテーブルのカラムにコピーすることです。最初にファイルを変数にロードし、変数の値を引用符付きの文字列として補間します。</target>
        </trans-unit>
        <trans-unit id="11e396823958b9942ef20dabe2804d32c8c47de7" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g. have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">テーブルアクセスメソッドAPIのかなり大きな制約の1つは、現在、AMが変更やインデックスをサポートする場合、各タプルがブロック番号とアイテム番号で構成されるタプル識別子（TID）を持つ必要があることです。 （&lt;a href=&quot;storage-page-layout&quot;&gt;セクション68.6&lt;/a&gt;も参照）。 TIDのサブパートが、たとえば &lt;code&gt;heap&lt;/code&gt; の場合と同じ意味である必要はありませんが、ビットマップスキャンのサポートが必要な場合（オプション）、ブロック番号はローカリティを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea6157e87abd7338811eb2303b2c46792b171e86" translate="yes" xml:space="preserve">
          <source>One major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; shows a possible application of this idea.</source>
          <target state="translated">部分インデックスを使用する主な理由の1つは、一般的な値のインデックス作成を回避することです。共通の値（すべてのテーブル行の数パーセント以上を占めるもの）を検索するクエリはインデックスを使用しないため、これらの行をインデックスに保持しても意味がありません。これにより、インデックスのサイズが小さくなり、インデックスを使用するクエリが高速化されます。また、すべての場合にインデックスを更新する必要がないため、多くのテーブル更新操作が高速化されます。&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;例11.1&lt;/a&gt;は、このアイデアの可能なアプリケーションを示しています。</target>
        </trans-unit>
        <trans-unit id="d407807dcbba44e4e2aa91e451040ac8b91fe898" translate="yes" xml:space="preserve">
          <source>One might need to insert a large amount of data when first populating a database. This section contains some suggestions on how to make this process as efficient as possible.</source>
          <target state="translated">最初にデータベースにデータを挿入するときに、大量のデータを挿入する必要があるかもしれません。このセクションでは、このプロセスを可能な限り効率的にするためのいくつかの提案が含まれています。</target>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="translated">の一つです。</target>
        </trans-unit>
        <trans-unit id="0e3d57db8bbc433a035cda8e815f996da30de43e" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt;; this specifies the event that will fire the trigger. Multiple events can be specified using &lt;code&gt;OR&lt;/code&gt;, except when transition relations are requested.</source>
          <target state="translated">一つの &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;TRUNCATE&lt;/code&gt; ;これは、トリガーを起動するイベントを指定します。遷移関係が要求されている場合を除き、 &lt;code&gt;OR&lt;/code&gt; を使用して複数のイベントを指定できます。</target>
        </trans-unit>
        <trans-unit id="1d58cd9872ba6b984b5aaf4db1dd4f254a5318e3" translate="yes" xml:space="preserve">
          <source>One of the most critical design decisions will be the column or columns by which you partition your data. Often the best choice will be to partition by the column or set of columns which most commonly appear in &lt;code&gt;WHERE&lt;/code&gt; clauses of queries being executed on the partitioned table. &lt;code&gt;WHERE&lt;/code&gt; clause items that match and are compatible with the partition key can be used to prune unneeded partitions. However, you may be forced into making other decisions by requirements for the &lt;code&gt;PRIMARY KEY&lt;/code&gt; or a &lt;code&gt;UNIQUE&lt;/code&gt; constraint. Removal of unwanted data is also a factor to consider when planning your partitioning strategy. An entire partition can be detached fairly quickly, so it may be beneficial to design the partition strategy in such a way that all data to be removed at once is located in a single partition.</source>
          <target state="translated">最も重要な設計決定の1つは、データをパーティション化する1つまたは複数の列です。多くの場合、最良の選択は、パーティション化されたテーブルで実行されるクエリの &lt;code&gt;WHERE&lt;/code&gt; 句に最も一般的に現れる列または列のセットでパーティション化することです。パーティションキーと一致し、互換性がある &lt;code&gt;WHERE&lt;/code&gt; 句の項目を使用して、不要なパーティションをプルーニングできます。ただし、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; または &lt;code&gt;UNIQUE&lt;/code&gt; の要件により、他の決定を余儀なくされる場合があります。制約。不要なデータの削除も、パーティション化戦略を計画する際に考慮すべき要素です。パーティション全体をかなり迅速に切り離すことができるので、一度に削除されるすべてのデータが単一のパーティションに配置されるようにパーティション戦略を設計することが有益な場合があります。</target>
        </trans-unit>
        <trans-unit id="dd64b8780a8987f51d6cf827b3649d1c335b7dcc" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be logging to a CSV file, which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; の明らかな用途の1つは、PostgreSQLアクティビティログをクエリ用のテーブルとして利用できるようにすることです。これを行うには、まずCSVファイルにログを記録する必要があります。ここでは &lt;code&gt;pglog.csv&lt;/code&gt; と呼びます。まず、 &lt;code&gt;file_fdw&lt;/code&gt; としてfile_fdwをインストールします。</target>
        </trans-unit>
        <trans-unit id="01a9a0754bb2d47df04d6f754f8a9d26cef931fd" translate="yes" xml:space="preserve">
          <source>One of the problems with the JDBC driver (and this affects the ODBC driver also), is that the specification assumes that references to BLOBs (Binary Large OBjects) are stored within a table, and if that entry is changed, the associated BLOB is deleted from the database.</source>
          <target state="translated">JDBCドライバの問題の1つは(これはODBCドライバにも影響します)、BLOB(Binary Large OBjects)への参照がテーブル内に格納され、そのエントリが変更された場合、関連するBLOBがデータベースから削除されることを仕様では想定しているということです。</target>
        </trans-unit>
        <trans-unit id="5e5610f45b959ec0066fbadc6e622bf504204314" translate="yes" xml:space="preserve">
          <source>One of the values estimated by &lt;code&gt;ANALYZE&lt;/code&gt; is the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; によって推定される値の1つは、各列に表示される個別の値の数です。行のサブセットのみが検査されるため、可能な限り最大の統計ターゲットであっても、この見積もりは非常に不正確になる場合があります。この不正確さがクエリプランの不良につながる場合、より正確な値を手動で決定し、 &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; インストールできます（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="493483fbe186caeb533f2587ea2f5c9911b94b74" translate="yes" xml:space="preserve">
          <source>One or more server-challenge and client-response message will follow. Each server-challenge is sent in an AuthenticationSASLContinue message, followed by a response from client in an SASLResponse message. The particulars of the messages are mechanism specific.</source>
          <target state="translated">1つ以上のサーバーチャレンジとクライアント応答メッセージが続く。それぞれのサーバーチャレンジは、AuthenticationSASLContinueメッセージで送られ、その後にクライアントからの応答がSASLResponseメッセージで送られます。メッセージの詳細はメカニズム固有のものです。</target>
        </trans-unit>
        <trans-unit id="425be19de627a14da7ab3bb185d550dfbfe3423c" translate="yes" xml:space="preserve">
          <source>One parameter is specified per line. The equal sign between name and value is optional. Whitespace is insignificant (except within a quoted parameter value) and blank lines are ignored. Hash marks (&lt;code&gt;#&lt;/code&gt;) designate the remainder of the line as a comment. Parameter values that are not simple identifiers or numbers must be single-quoted. To embed a single quote in a parameter value, write either two quotes (preferred) or backslash-quote. If the file contains multiple entries for the same parameter, all but the last one are ignored.</source>
          <target state="translated">1行に1つのパラメーターを指定します。名前と値の間の等号はオプションです。空白は重要ではなく（引用符で囲まれたパラメータ値内を除く）、空白行は無視されます。ハッシュマーク（ &lt;code&gt;#&lt;/code&gt; ）は、行の残りをコメントとして指定します。単純な識別子または数値ではないパラメーター値は、単一引用符で囲む必要があります。パラメータ値に単一引用符を埋め込むには、2つの引用符（推奨）またはバックスラッシュ引用符を記述します。ファイルに同じパラメータの複数のエントリが含まれている場合、最後のエントリ以外はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="80b5eb3c3d07dabe60de983aaa0a3518afd885a7" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; を実行しているバックエンド（autovacuumワーカープロセスを含む）ごとに1行、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;セクション27.4.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e814a8df1ec5e7ba9113e201d150026719d20049" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; または &lt;code&gt;VACUUM FULL&lt;/code&gt; を実行しているバックエンドごとに1行で、現在の進行状況を示します。&lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;セクション27.4.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="592609ed9243ae5def10fa9f090855998b555b8d" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; または &lt;code&gt;REINDEX&lt;/code&gt; を実行するバックエンドごとに1行。現在の進行状況を示します。&lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;セクション27.4.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="636789b8fa3526dcb7ffa47252873c271555303c" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのインデックスごとに1行。その特定のインデックスのI / Oに関する統計を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="c843f1eedf963b1dea0a4c471c30395c4850fb0a" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのインデックスごとに1行。その特定のインデックスへのアクセスに関する統計が表示されます。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="c2a19a27308f1c1e0f487d86ec09bd9389b70b95" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのシーケンスごとに1行。その特定のシーケンスのI / Oに関する統計を示します。詳細については、&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="876cb7f3198f93830f07de3b355cbda033ba5c5c" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのテーブルごとに1行。その特定のテーブルのI / Oに関する統計を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e1a2d424d05fad0ce8a503aad44ed8e2890ec86d" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">現在のデータベースのテーブルごとに1つの行。特定のテーブルへのアクセスに関する統計を示します。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-TABLES-VIEW&quot;&gt;pg_stat_all_tables&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5e4f1c454b46b07db5b5caff74a33b9a88d14f14" translate="yes" xml:space="preserve">
          <source>One row for each tracked function, showing statistics about executions of that function. See &lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt; for details.</source>
          <target state="translated">追跡された関数ごとに1行。その関数の実行に関する統計を示します。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-USER-FUNCTIONS-VIEW&quot;&gt;pg_stat_user_functions&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2a27e9764cf42abc447770a40b26ae4110256df1" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the WAL archiver process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt; for details.</source>
          <target state="translated">WALアーカイバプロセスのアクティビティに関する統計を示す1行のみ。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-ARCHIVER-VIEW&quot;&gt;pg_stat_archiver&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="08ff69da529511355514d8fad09917a768f3dfee" translate="yes" xml:space="preserve">
          <source>One row only, showing statistics about the background writer process's activity. See &lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt; for details.</source>
          <target state="translated">バックグラウンドライタープロセスのアクティビティに関する統計を示す1行のみ。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-BGWRITER-VIEW&quot;&gt;pg_stat_bgwriter&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="41761c4e3d769b5a97047d2af3c904ca9b99e019" translate="yes" xml:space="preserve">
          <source>One row per WAL sender process, showing statistics about replication to that sender's connected standby server. See &lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt; for details.</source>
          <target state="translated">WAL送信者プロセスごとに1行。その送信者の接続されたスタンバイサーバーへのレプリケーションに関する統計を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-REPLICATION-VIEW&quot;&gt;pg_stat_replication&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="04eefccf9acdca920d874c55aed10830947f2ad0" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about GSSAPI authentication and encryption used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt; for details.</source>
          <target state="translated">接続ごとに1行（通常および複製）。この接続で使用されるGSSAPI認証および暗号化に関する情報を示します。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-GSSAPI-VIEW&quot;&gt;pg_stat_gssapi&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ff2500623059c396127b50986a7192b6dece4045" translate="yes" xml:space="preserve">
          <source>One row per connection (regular and replication), showing information about SSL used on this connection. See &lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt; for details.</source>
          <target state="translated">接続ごとに1行（通常およびレプリケーション）。この接続で使用されるSSLに関する情報を示します。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-SSL-VIEW&quot;&gt;pg_stat_ssl&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1e2bdd85f6f61ca9f60bf24ae4eb4fe127af69af" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics about query cancels due to conflict with recovery on standby servers. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.</source>
          <target state="translated">データベースごとに1行。スタンバイサーバーでの回復との競合によるクエリキャンセルに関するデータベース全体の統計を示します。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="28ca9a3ad9c0527d7bf8067a93b52b4e199755b8" translate="yes" xml:space="preserve">
          <source>One row per database, showing database-wide statistics. See &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt; for details.</source>
          <target state="translated">データベースごとに1行で、データベース全体の統計を示します。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-VIEW&quot;&gt;pg_stat_database&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="02ad092a9644445754a24d9ccf37920da6663d5c" translate="yes" xml:space="preserve">
          <source>One row per server process, showing information related to the current activity of that process, such as state and current query. See &lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt; for details.</source>
          <target state="translated">サーバープロセスごとに1行。状態や現在のクエリなど、そのプロセスの現在のアクティビティに関連する情報を示します。詳細については、&lt;a href=&quot;monitoring-stats#PG-STAT-ACTIVITY-VIEW&quot;&gt;pg_stat_activity&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cd0d7184c558c048e1447f27b2e4a45d43e212a8" translate="yes" xml:space="preserve">
          <source>One semantically-insignificant detail worth noting is that in &lt;code&gt;jsonb&lt;/code&gt;, numbers will be printed according to the behavior of the underlying &lt;code&gt;numeric&lt;/code&gt; type. In practice this means that numbers entered with &lt;code&gt;E&lt;/code&gt; notation will be printed without it, for example:</source>
          <target state="translated">注目に値する意味的に重要ではない詳細の1つは、 &lt;code&gt;jsonb&lt;/code&gt; では、基になる &lt;code&gt;numeric&lt;/code&gt; 型の動作に従って数値が出力されることです。実際には、これは、 &lt;code&gt;E&lt;/code&gt; 表記で入力された数値がそれなしで印刷されることを意味します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="eee0b1a9ad748e96945cdf21735c3cba379b36e1" translate="yes" xml:space="preserve">
          <source>One should be wary of statements of the form</source>
          <target state="translated">一つは、フォームのステートメントを警戒する必要があります。</target>
        </trans-unit>
        <trans-unit id="0503270d022d51df4a5d1385ddb363763c100a21" translate="yes" xml:space="preserve">
          <source>One should be wary that the POSIX-style time zone feature can lead to silently accepting bogus input, since there is no check on the reasonableness of the zone abbreviations. For example, &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; will work, leaving the system effectively using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX time zone names, positive offsets are used for locations &lt;em&gt;west&lt;/em&gt; of Greenwich. Everywhere else, PostgreSQL follows the ISO-8601 convention that positive timezone offsets are &lt;em&gt;east&lt;/em&gt; of Greenwich.</source>
          <target state="translated">ゾーンの省略形の妥当性のチェックがないため、POSIXスタイルのタイムゾーン機能が誤って偽の入力を受け入れる可能性があることに注意する必要があります。たとえば、 &lt;code&gt;SET TIMEZONE TO FOOBAR0&lt;/code&gt; は機能し、システムはUTCのかなり変わった略語を効果的に使用します。留意すべきもう1つの問題は、POSIXタイムゾーン名では、グリニッジの&lt;em&gt;西側&lt;/em&gt;の場所に正のオフセットが使用されることです。それ以外の場所では、PostgreSQLは正のタイムゾーンオフセットがグリニッジの&lt;em&gt;東&lt;/em&gt;にあるというISO-8601規則に従います。</target>
        </trans-unit>
        <trans-unit id="07761093680f0435d07de4dfbf3133e5f6e33451" translate="yes" xml:space="preserve">
          <source>One upgrade method is to dump data from one major version of PostgreSQL and reload it in another &amp;mdash; to do this, you must use a &lt;em&gt;logical&lt;/em&gt; backup tool like pg_dumpall; file system level backup methods will not work. (There are checks in place that prevent you from using a data directory with an incompatible version of PostgreSQL, so no great harm can be done by trying to start the wrong server version on a data directory.)</source>
          <target state="translated">アップグレード方法の1つは、PostgreSQLの1つのメジャーバージョンからデータをダンプして別のバージョンに再ロードすることです。これを行うには、pg_dumpallなどの&lt;em&gt;論理&lt;/em&gt;バックアップツールを使用する必要があります。ファイルシステムレベルのバックアップ方法は機能しません。 （互換性のないバージョンのPostgreSQLでデータディレクトリを使用できないようにするためのチェックが行われているため、データディレクトリで間違ったサーバーバージョンを起動しようとしても大きな害はありません。）</target>
        </trans-unit>
        <trans-unit id="3c2ef0cb6e16fe638517e00044d9fddafd2f1f0e" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is to run PostgreSQL on a machine where you can be sure that other processes will not run the machine out of memory. If memory is tight, increasing the swap space of the operating system can help avoid the problem, because the out-of-memory (OOM) killer is invoked only when physical memory and swap space are exhausted.</source>
          <target state="translated">この問題を回避する1つの方法は、他のプロセスがメモリ切れでマシンを実行しないことが確実なマシン上でPostgreSQLを実行することです。メモリが逼迫している場合は、オペレーティングシステムのスワップ領域を増やすことで問題を回避することができます。</target>
        </trans-unit>
        <trans-unit id="cb720ead71b0312fba38d640c63f7a5801cc13dc" translate="yes" xml:space="preserve">
          <source>One way to do this is to shut down the server and start a single-user PostgreSQL server with the &lt;code&gt;-P&lt;/code&gt; option included on its command line. Then, &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SYSTEM&lt;/code&gt;, &lt;code&gt;REINDEX TABLE&lt;/code&gt;, or &lt;code&gt;REINDEX INDEX&lt;/code&gt; can be issued, depending on how much you want to reconstruct. If in doubt, use &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; to select reconstruction of all system indexes in the database. Then quit the single-user server session and restart the regular server. See the &lt;a href=&quot;app-postgres&quot;&gt;postgres&lt;/a&gt; reference page for more information about how to interact with the single-user server interface.</source>
          <target state="translated">これを行う1つの方法は、サーバーをシャットダウンし、コマンドラインに &lt;code&gt;-P&lt;/code&gt; オプションを含めてシングルユーザーのPostgreSQLサーバーを起動することです。次に、再構築する量に応じて、 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; 、 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 、 &lt;code&gt;REINDEX TABLE&lt;/code&gt; 、または &lt;code&gt;REINDEX INDEX&lt;/code&gt; を発行できます。疑わしい場合は、 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; を使用して、データベース内のすべてのシステムインデックスの再構築を選択します。次に、シングルユーザーサーバーセッションを終了し、通常のサーバーを再起動します。シングルユーザーサーバーインターフェイスの操作方法の詳細については、&lt;a href=&quot;app-postgres&quot;&gt;postgresの&lt;/a&gt;リファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="76a318a5204a34131edd8add7164960e6a6851df" translate="yes" xml:space="preserve">
          <source>One way to look at variant plans is to force the planner to disregard whatever strategy it thought was the cheapest, using the enable/disable flags described in &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;Section 19.7.1&lt;/a&gt;. (This is a crude tool, but useful. See also &lt;a href=&quot;explicit-joins&quot;&gt;Section 14.3&lt;/a&gt;.) For example, if we're unconvinced that sequential-scan-and-sort is the best way to deal with table &lt;code&gt;onek&lt;/code&gt; in the previous example, we could try</source>
          <target state="translated">バリアントプランを確認する1つの方法は、&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-ENABLE&quot;&gt;セクション19.7.1で&lt;/a&gt;説明されている有効化/無効化フラグを使用して、最もコストが低いと思われる戦略をプランナに無視させることです。 （これは粗雑なツールですが、便利です。&lt;a href=&quot;explicit-joins&quot;&gt;セクション14.3&lt;/a&gt;も参照してください。）たとえば、前の例でテーブル &lt;code&gt;onek&lt;/code&gt; を処理するには、順次スキャンとソートが最善の方法であると確信できない場合、</target>
        </trans-unit>
        <trans-unit id="0391e7fdb45313d9e4e2f5f1634bb9ecb7a05ff9" translate="yes" xml:space="preserve">
          <source>One way to prevent spoofing of &lt;code&gt;local&lt;/code&gt; connections is to use a Unix domain socket directory (&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;) that has write permission only for a trusted local user. This prevents a malicious user from creating their own socket file in that directory. If you are concerned that some applications might still reference &lt;code&gt;/tmp&lt;/code&gt; for the socket file and hence be vulnerable to spoofing, during operating system startup create a symbolic link &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; that points to the relocated socket file. You also might need to modify your &lt;code&gt;/tmp&lt;/code&gt; cleanup script to prevent removal of the symbolic link.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 接続のなりすましを防ぐ1つの方法は、信頼できるローカルユーザーのみに書き込み権限を持つUnixドメインソケットディレクトリ（&lt;a href=&quot;runtime-config-connection#GUC-UNIX-SOCKET-DIRECTORIES&quot;&gt;unix_socket_directories&lt;/a&gt;）を使用することです。これにより、悪意のあるユーザーがそのディレクトリに独自のソケットファイルを作成することを防ぎます。一部のアプリケーションがまだソケットファイルの &lt;code&gt;/tmp&lt;/code&gt; を参照しているためになりすましに対して脆弱であることが懸念される場合は、オペレーティングシステムの起動中に、再配置されたソケットファイルを指すシンボリックリンク &lt;code&gt;/tmp/.s.PGSQL.5432&lt;/code&gt; を作成します。また、シンボリックリンクが削除されないように、 &lt;code&gt;/tmp&lt;/code&gt; クリーンアップスクリプトを変更する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="839eb373f7e57c0c527b6ab4498f37574f9b1b5d" translate="yes" xml:space="preserve">
          <source>Online Analytical Processing</source>
          <target state="translated">オンライン分析処理</target>
        </trans-unit>
        <trans-unit id="9bc8e24fa431e83abb8ee45cbd92647ad8e714f7" translate="yes" xml:space="preserve">
          <source>Online Transaction Processing</source>
          <target state="translated">オンライン取引処理</target>
        </trans-unit>
        <trans-unit id="0b59497ee41bee58e3cf2969b674c4903d4bc6b0" translate="yes" xml:space="preserve">
          <source>Online statistics:</source>
          <target state="translated">オンライン統計。</target>
        </trans-unit>
        <trans-unit id="95683a3aebf06f5e3b349d234f74e1173b887f29" translate="yes" xml:space="preserve">
          <source>Only an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock blocks a &lt;code&gt;SELECT&lt;/code&gt; (without &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt;) statement.</source>
          <target state="translated">&lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックのみが &lt;code&gt;SELECT&lt;/code&gt; （ &lt;code&gt;FOR UPDATE/SHARE&lt;/code&gt; なし）ステートメントをブロックします。</target>
        </trans-unit>
        <trans-unit id="6428d0603b66d67294f1af1eb460cffe5ea43327" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum), like &lt;code&gt;--analyze-only&lt;/code&gt;. Run several (currently three) stages of analyze with different configuration settings, to produce usable statistics faster.</source>
          <target state="translated">&lt;code&gt;--analyze-only&lt;/code&gt; のように、オプティマイザ（バキュームなし）で使用する統計のみを計算します。さまざまな構成設定で分析のいくつかのステージ（現在は3つ）を実行して、使用可能な統計をより速く生成します。</target>
        </trans-unit>
        <trans-unit id="e4af2b2a347593a2587cd89d5c7edc042fe1b2ae" translate="yes" xml:space="preserve">
          <source>Only calculate statistics for use by the optimizer (no vacuum).</source>
          <target state="translated">オプティマイザで使用するための統計情報のみを計算します(真空ではありません)。</target>
        </trans-unit>
        <trans-unit id="1ff76f6d5463fac41b779622c32a96a9ae59972a" translate="yes" xml:space="preserve">
          <source>Only certain data types support TOAST &amp;mdash; there is no need to impose the overhead on data types that cannot produce large field values. To support TOAST, a data type must have a variable-length (&lt;em&gt;varlena&lt;/em&gt;) representation, in which, ordinarily, the first four-byte word of any stored value contains the total length of the value in bytes (including itself). TOAST does not constrain the rest of the data type's representation. The special representations collectively called &lt;em&gt;TOASTed values&lt;/em&gt; work by modifying or reinterpreting this initial length word. Therefore, the C-level functions supporting a TOAST-able data type must be careful about how they handle potentially TOASTed input values: an input might not actually consist of a four-byte length word and contents until after it's been &lt;em&gt;detoasted&lt;/em&gt;. (This is normally done by invoking &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; before doing anything with an input value, but in some cases more efficient approaches are possible. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt; for more detail.)</source>
          <target state="translated">TOASTをサポートするのは特定のデータ型のみです。大きなフィールド値を生成できないデータ型にオーバーヘッドを課す必要はありません。 TOASTをサポートするには、データ型に可変長（&lt;em&gt;varlena&lt;/em&gt;）表現が必要です。通常、格納された値の最初の4バイトワードには、バイト単位の値（それ自体を含む）の合計長が含まれます。 TOASTは、残りのデータ型の表現を制約しません。&lt;em&gt;TOAST値&lt;/em&gt;と総称される特別な表現は、この初期の長さの単語を変更または再解釈することによって機能します。したがって、TOAST可能なデータ型をサポートするCレベルの関数は、TOASTされる可能性のある入力値の処理方法に注意する必要があります。入力が実際に行われるまで、実際には入力が4バイト長の単語と内容で構成されていない場合があります&lt;em&gt;detoasted&lt;/em&gt;。（これは通常、入力値で何かを行う前に &lt;code&gt;PG_DETOAST_DATUM&lt;/code&gt; を呼び出すことによって行われますが、場合によってはより効率的なアプローチが可能です。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;セクション37.13.1&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="27a5875a715917165876854e17c248ccf4f95f13" translate="yes" xml:space="preserve">
          <source>Only display records generated by the specified resource manager. If &lt;code&gt;list&lt;/code&gt; is passed as name, print a list of valid resource manager names, and exit.</source>
          <target state="translated">指定したリソースマネージャによって生成されたレコードのみを表示します。 &lt;code&gt;list&lt;/code&gt; が名前として渡された場合、有効なリソースマネージャ名のリストを出力して終了します。</target>
        </trans-unit>
        <trans-unit id="1eec6acc7fed503402488b3ba82909c46aae0483" translate="yes" xml:space="preserve">
          <source>Only display records marked with the given transaction ID.</source>
          <target state="translated">指定されたトランザクションIDでマークされたレコードのみを表示します。</target>
        </trans-unit>
        <trans-unit id="df686aa57f8a0399728798091a1185e8914758e9" translate="yes" xml:space="preserve">
          <source>Only dump the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to dump all sections.</source>
          <target state="translated">名前付きセクションのみをダンプします。セクション名は、 &lt;code&gt;pre-data&lt;/code&gt; 、 &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;post-data&lt;/code&gt; のいずれかです。このオプションを複数回指定して、複数のセクションを選択できます。デフォルトでは、すべてのセクションをダンプします。</target>
        </trans-unit>
        <trans-unit id="8c62a53b547108de76ccc1531107eb8cfedb9cfb" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a multixact ID age of at least &lt;code&gt;mxid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent multixact ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;Section 24.1.5.1&lt;/a&gt;).</source>
          <target state="translated">multixact IDの &lt;code&gt;mxid_age&lt;/code&gt; 以上のテーブルで、vacuumまたはanalyzeコマンドのみを実行してください。この設定は、multixact IDラップアラウンドを防止するために処理するテーブルに優先順位を付ける場合に役立ちます（&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-MULTIXACT-WRAPAROUND&quot;&gt;セクション24.1.5.1を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="22cc7a345e3b6c6eac0bd069839bf36f1185ab25" translate="yes" xml:space="preserve">
          <source>Only execute the vacuum or analyze commands on tables with a transaction ID age of at least &lt;code&gt;xid_age&lt;/code&gt;. This setting is useful for prioritizing tables to process to prevent transaction ID wraparound (see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;xid_age&lt;/code&gt; 以上のトランザクションIDエージを持つテーブルで、vacuumコマンドまたはanalyzeコマンドのみを実行してください。この設定は、トランザクションIDの折り返しを防止するために処理するテーブルに優先順位を付ける場合に役立ちます（&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;セクション24.1.5を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="30caad55acba8eaee72cd0eb2b22ca9a6e1cfcaa" translate="yes" xml:space="preserve">
          <source>Only has effect if &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; are enabled.</source>
          <target state="translated">&lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;データチェックサム&lt;/a&gt;が有効な場合にのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="4930a6bbf0f1c4de7f538ff4072a1668f8d281a2" translate="yes" xml:space="preserve">
          <source>Only lowercase &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; spellings are accepted</source>
          <target state="translated">小文字の &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; のスペルのみが受け入れられます</target>
        </trans-unit>
        <trans-unit id="5d755b459eeaa6b733e81509898e0f04066e3489" translate="yes" xml:space="preserve">
          <source>Only one comment string is stored for each object, so to modify a comment, issue a new &lt;code&gt;COMMENT&lt;/code&gt; command for the same object. To remove a comment, write &lt;code&gt;NULL&lt;/code&gt; in place of the text string. Comments are automatically dropped when their object is dropped.</source>
          <target state="translated">オブジェクトごとに1つのコメント文字列のみが保存されるため、コメントを変更するには、同じオブジェクトに対して新しい &lt;code&gt;COMMENT&lt;/code&gt; コマンドを発行します。コメントを削除するには、テキスト文字列の代わりに &lt;code&gt;NULL&lt;/code&gt; を書き込みます。オブジェクトが削除されると、コメントは自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="6b3d566bcef3dc1ca42fe3bd8ea05bbe930d19d6" translate="yes" xml:space="preserve">
          <source>Only one parameter may be supplied to the function in a &lt;code&gt;CREATE TRIGGER&lt;/code&gt; statement, and that is optional. If supplied it will be used for the channel name for the notifications. If omitted &lt;code&gt;tcn&lt;/code&gt; will be used for the channel name.</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; ステートメントで関数に指定できるパラメーターは1つだけで、これはオプションです。指定した場合、通知のチャネル名に使用されます。省略した場合、チャネル名には &lt;code&gt;tcn&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="52d2c18b8c742c722526abc3884826a2891d9cd5" translate="yes" xml:space="preserve">
          <source>Only one row, showing statistics about the WAL receiver from that receiver's connected server. See &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; for details.</source>
          <target state="translated">その受信者の接続サーバーからのWAL受信者に関する統計を示す1行のみ。詳細については&lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6e141ed896712b895fe333210a9bdff25138d7ab" translate="yes" xml:space="preserve">
          <source>Only operator classes for &lt;code&gt;int4&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; are included with the module.</source>
          <target state="translated">モジュールには、 &lt;code&gt;int4&lt;/code&gt; および &lt;code&gt;text&lt;/code&gt; 演算子クラスのみが含まれています。</target>
        </trans-unit>
        <trans-unit id="36554985b3656b4dddfbe30677cd178826516027" translate="yes" xml:space="preserve">
          <source>Only persistent base tables can be part of a publication. Temporary tables, unlogged tables, foreign tables, materialized views, regular views, and partitioned tables cannot be part of a publication. To replicate a partitioned table, add the individual partitions to the publication.</source>
          <target state="translated">永続的なベース・テーブルのみがパブリケーションの一部になることができます。一時テーブル、ログされていないテーブル、外部テーブル、マテリアライズド・ビュー、レギュラー・ビュー、およびパーティショニングされたテーブルは、パブリケーションの一部にはできません。パーティショニングされたテーブルを複製するには、個々のパーティションをパブリケーションに追加します。</target>
        </trans-unit>
        <trans-unit id="b0f9131e0157ccbc9f71702565357129b8273efc" translate="yes" xml:space="preserve">
          <source>Only restore the named section. The section name can be &lt;code&gt;pre-data&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, or &lt;code&gt;post-data&lt;/code&gt;. This option can be specified more than once to select multiple sections. The default is to restore all sections.</source>
          <target state="translated">名前付きセクションのみを復元します。セクション名は、 &lt;code&gt;pre-data&lt;/code&gt; 、 &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;post-data&lt;/code&gt; のいずれかです。このオプションを複数回指定して、複数のセクションを選択できます。デフォルトでは、すべてのセクションが復元されます。</target>
        </trans-unit>
        <trans-unit id="9d94341e83b6e3cc09be7f96d9ae2bbdbd997a3f" translate="yes" xml:space="preserve">
          <source>Only roles that have the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be used as the initial role name for a database connection. A role with the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be considered the same as a &amp;ldquo;database user&amp;rdquo;. To create a role with login privilege, use either:</source>
          <target state="translated">データベース接続の初期ロール名として使用できるのは、 &lt;code&gt;LOGIN&lt;/code&gt; 属性を持つロールのみです。 &lt;code&gt;LOGIN&lt;/code&gt; 属性を持つロールは、「データベースユーザー」と同じと見なすことができます。ログイン権限を持つロールを作成するには、次のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="d85fc142dd33473e697f51542b02c504f67a9b35" translate="yes" xml:space="preserve">
          <source>Only shared libraries specifically intended to be used with PostgreSQL can be loaded this way. Every PostgreSQL-supported library has a &amp;ldquo;magic block&amp;rdquo; that is checked to guarantee compatibility. For this reason, non-PostgreSQL libraries cannot be loaded in this way. You might be able to use operating-system facilities such as &lt;code&gt;LD_PRELOAD&lt;/code&gt; for that.</source>
          <target state="translated">この方法でロードできるのは、PostgreSQLで使用することを特に意図した共有ライブラリのみです。PostgreSQLがサポートするすべてのライブラリには、互換性を保証するためにチェックされる「マジックブロック」があります。このため、PostgreSQL以外のライブラリをこの方法でロードすることはできません。そのために、 &lt;code&gt;LD_PRELOAD&lt;/code&gt; などのオペレーティングシステム機能を使用できる場合があります。</target>
        </trans-unit>
        <trans-unit id="7bf905053544478968750f95521ca3e30e70375f" translate="yes" xml:space="preserve">
          <source>Only superusers can alter foreign-data wrappers. Additionally, only superusers can own foreign-data wrappers.</source>
          <target state="translated">スーパーユーザのみが外部データラッパーを変更することができます。さらに、スーパーユーザのみが外部データラッパーを所有することができます。</target>
        </trans-unit>
        <trans-unit id="b9d1a65de15d43acfd7df441e250838c198f3037" translate="yes" xml:space="preserve">
          <source>Only superusers can call &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">スーパーユーザーだけが &lt;code&gt;CHECKPOINT&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="6b3d5ff53d3f29afdf3319b912d99cf3260a4f77" translate="yes" xml:space="preserve">
          <source>Only superusers can change this setting, because it affects the messages sent to the server log as well as to the client, and an improper value might obscure the readability of the server logs.</source>
          <target state="translated">この設定を変更できるのはスーパーユーザだけです。なぜなら、この設定はクライアントだけでなくサーバログに送信されるメッセージにも影響するからです。</target>
        </trans-unit>
        <trans-unit id="b2be6ed45f348313973635f2ddfd082cf6f9717d" translate="yes" xml:space="preserve">
          <source>Only superusers can create event triggers.</source>
          <target state="translated">イベントトリガーを作成できるのはスーパーユーザーのみです。</target>
        </trans-unit>
        <trans-unit id="2ae5bc67902361297a54dbc3f2c9fc4cdf0facde" translate="yes" xml:space="preserve">
          <source>Only superusers can create foreign-data wrappers.</source>
          <target state="translated">スーパーユーザのみが外部データのラッパーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="a0a550e0a836899716e0fe5ebdbfaa0d54059384" translate="yes" xml:space="preserve">
          <source>Only superusers can define new access methods.</source>
          <target state="translated">スーパーユーザのみが新しいアクセス方法を定義することができます。</target>
        </trans-unit>
        <trans-unit id="d11423b98472dc3dca65de17ed52b8e73990fa3d" translate="yes" xml:space="preserve">
          <source>Only superusers can use &lt;code&gt;ALTER SYSTEM&lt;/code&gt;. Also, since this command acts directly on the file system and cannot be rolled back, it is not allowed inside a transaction block or function.</source>
          <target state="translated">スーパーユーザーだけが &lt;code&gt;ALTER SYSTEM&lt;/code&gt; を使用できます。また、このコマンドはファイルシステムで直接機能し、ロールバックできないため、トランザクションブロックまたは関数内では使用できません。</target>
        </trans-unit>
        <trans-unit id="d0b0ed2869d7ce3fc0379f4c0080abfebb839775" translate="yes" xml:space="preserve">
          <source>Only superusers may connect to foreign servers without password authentication, so always specify the &lt;code&gt;password&lt;/code&gt; option for user mappings belonging to non-superusers.</source>
          <target state="translated">スーパーユーザーのみがパスワード認証なしで外部サーバーに接続できるため、非スーパーユーザーに属するユーザーマッピングには常に &lt;code&gt;password&lt;/code&gt; オプションを指定してください。</target>
        </trans-unit>
        <trans-unit id="add5aed352ded84ef9a29f07c8afce866831ef29" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;=&lt;/code&gt; operator is supported for search. But it is possible to add support for arrays with union and intersection operations in the future.</source>
          <target state="translated">検索では、 &lt;code&gt;=&lt;/code&gt; 演算子のみがサポートされています。ただし、将来的にユニオンおよびインターセクション演算を伴う配列のサポートを追加することが可能です。</target>
        </trans-unit>
        <trans-unit id="a2c2cf173b45b1ac1a32e3ec0d5fe77ba32623c7" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VERBOSE&lt;/code&gt; options can be specified, and only in that order, without surrounding the option list in parentheses. Prior to PostgreSQL 9.0, the unparenthesized syntax was the only one supported. It is expected that all new options will be supported only in the parenthesized syntax.</source>
          <target state="translated">オプションリストを括弧で囲まずに、 &lt;code&gt;ANALYZE&lt;/code&gt; オプションと &lt;code&gt;VERBOSE&lt;/code&gt; オプションのみをこの順序でのみ指定できます。PostgreSQL 9.0より前のバージョンでは、括弧なしの構文のみがサポートされていました。新しいオプションはすべて、括弧で囲まれた構文でのみサポートされることが予想されます。</target>
        </trans-unit>
        <trans-unit id="5022f8e7bdd77bf8c02d9d1490318561a8027b6a" translate="yes" xml:space="preserve">
          <source>Only the custom and directory archive formats are supported with this option. The input must be a regular file or directory (not, for example, a pipe). This option is ignored when emitting a script rather than connecting directly to a database server. Also, multiple jobs cannot be used together with the option &lt;code&gt;--single-transaction&lt;/code&gt;.</source>
          <target state="translated">このオプションでは、カスタムおよびディレクトリアーカイブ形式のみがサポートされます。入力は、通常のファイルまたはディレクトリー（例えば、パイプではない）でなければなりません。データベースサーバーに直接接続するのではなく、スクリプトを発行する場合、このオプションは無視されます。また、オプション &lt;code&gt;--single-transaction&lt;/code&gt; と一緒に複数のジョブを使用することはできません。</target>
        </trans-unit>
        <trans-unit id="5e47b4720ff6f0582001899cb68bf4bdb2a0ac11" translate="yes" xml:space="preserve">
          <source>Only the owner of the database, or a superuser, can drop a database. Dropping a database removes all objects that were contained within the database. The destruction of a database cannot be undone.</source>
          <target state="translated">データベースを削除できるのは、データベースの所有者またはスーパーユーザーだけです。データベースを削除すると、データベース内に含まれていたすべてのオブジェクトが削除されます。データベースの破壊は元に戻すことができません。</target>
        </trans-unit>
        <trans-unit id="992702029b9e3a50c611dc6825669adb061c4f3f" translate="yes" xml:space="preserve">
          <source>Only the specified timeline is displayed (or the default, if none is specified). Records in other timelines are ignored.</source>
          <target state="translated">指定されたタイムラインのみが表示されます(何も指定されていない場合はデフォルト)。他のタイムラインのレコードは無視されます。</target>
        </trans-unit>
        <trans-unit id="0e8a66b6f0be3b6d7c6a27438485bc034b86bede" translate="yes" xml:space="preserve">
          <source>Only validate checksums in the relation with filenode &lt;code&gt;filenode&lt;/code&gt;.</source>
          <target state="translated">filenode &lt;code&gt;filenode&lt;/code&gt; との関係でチェックサムのみを検証します。</target>
        </trans-unit>
        <trans-unit id="e0b885bbfd4f3bfc263123d67cbabd608309adfe" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity</source>
          <target state="translated">オープンデータベースの接続性</target>
        </trans-unit>
        <trans-unit id="904b1a9c4f30cf27ea883ca5fa7d3ff036c36eb9" translate="yes" xml:space="preserve">
          <source>Open interval with lower bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">下限 &lt;code&gt;x&lt;/code&gt; の開いた区間</target>
        </trans-unit>
        <trans-unit id="5a8b4a983dd22778ee9f002679eacd86bf69191d" translate="yes" xml:space="preserve">
          <source>Open interval with upper bound &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">上限 &lt;code&gt;x&lt;/code&gt; の開いた区間</target>
        </trans-unit>
        <trans-unit id="45de3417dc1987111074bc170202fbf751c567d8" translate="yes" xml:space="preserve">
          <source>Open path</source>
          <target state="translated">オープンパス</target>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="50ef244d7dd70cb29f22ada32d04825a64fc9036" translate="yes" xml:space="preserve">
          <source>OpenBSD sys/crypto</source>
          <target state="translated">OpenBSD の sys/crypto</target>
        </trans-unit>
        <trans-unit id="e301ca795081a87c0033bddb2e90503f9f7929d2" translate="yes" xml:space="preserve">
          <source>OpenPGP message format.</source>
          <target state="translated">OpenPGP メッセージフォーマット。</target>
        </trans-unit>
        <trans-unit id="2188261ca504497d39a1689d5dff920fe8b50f79" translate="yes" xml:space="preserve">
          <source>OpenSSL names for the most common curves are: &lt;code&gt;prime256v1&lt;/code&gt; (NIST P-256), &lt;code&gt;secp384r1&lt;/code&gt; (NIST P-384), &lt;code&gt;secp521r1&lt;/code&gt; (NIST P-521). The full list of available curves can be shown with the command &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt;. Not all of them are usable in TLS though.</source>
          <target state="translated">最も一般的な曲線のOpenSSL名は、 &lt;code&gt;prime256v1&lt;/code&gt; （NIST P-256）、 &lt;code&gt;secp384r1&lt;/code&gt; （NIST P-384）、 &lt;code&gt;secp521r1&lt;/code&gt; （NIST P-521）です。使用可能な曲線の完全なリストは、コマンド &lt;code&gt;openssl ecparam -list_curves&lt;/code&gt; で表示できます。ただし、それらすべてがTLSで使用できるわけではありません。</target>
        </trans-unit>
        <trans-unit id="5c972fdff495c397d3150e0515793a7f4559382c" translate="yes" xml:space="preserve">
          <source>OpenSSL supports a wide range of ciphers and authentication algorithms, of varying strength. While a list of ciphers can be specified in the OpenSSL configuration file, you can specify ciphers specifically for use by the database server by modifying &lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">OpenSSLは、さまざまな強度の幅広い暗号および認証アルゴリズムをサポートしています。暗号のリストはOpenSSL構成ファイルで指定できますが、 &lt;code&gt;postgresql.conf&lt;/code&gt; の&lt;a href=&quot;runtime-config-connection#GUC-SSL-CIPHERS&quot;&gt;ssl_ciphers&lt;/a&gt;を変更することにより、データベースサーバーで使用するための暗号を指定できます。</target>
        </trans-unit>
        <trans-unit id="c3b0974ebaa95408edcf74b52711fc4f50a804a3" translate="yes" xml:space="preserve">
          <source>Operations such as TRUNCATE which normally affect a table and all of its inheritance children will cascade to all partitions, but may also be performed on an individual partition. Note that dropping a partition with &lt;code&gt;DROP TABLE&lt;/code&gt; requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">TRUNCATEなどの通常テーブルとそのすべての継承の子に影響する操作は、すべてのパーティションにカスケードされますが、個々のパーティションで実行することもできます。 &lt;code&gt;DROP TABLE&lt;/code&gt; でパーティションを削除するには、親テーブルで &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックを取得する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="b07cfafa5cefef04cd848e7642b8acf9013a81e6" translate="yes" xml:space="preserve">
          <source>Operator Classes and Operator Families</source>
          <target state="translated">オペレータクラスとオペレータファミリー</target>
        </trans-unit>
        <trans-unit id="b398f34e06d00a1a82db7c5bd5884749c340c3d5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 1</source>
          <target state="translated">オペレーターの戦略1</target>
        </trans-unit>
        <trans-unit id="244ef231d648a8011796f75d8ba0c200ff67c490" translate="yes" xml:space="preserve">
          <source>Operator Strategy 10</source>
          <target state="translated">オペレーター戦略10</target>
        </trans-unit>
        <trans-unit id="aa5d9755365c2952ee3e6f612eacdbdd1a1d7624" translate="yes" xml:space="preserve">
          <source>Operator Strategy 11</source>
          <target state="translated">オペレーター戦略 11</target>
        </trans-unit>
        <trans-unit id="d4a97822fa5fff84d7420e13e887c2193e9890f0" translate="yes" xml:space="preserve">
          <source>Operator Strategy 12</source>
          <target state="translated">オペレーター戦略12</target>
        </trans-unit>
        <trans-unit id="84afbc51b4cffb9fe60bc11408d20fc3c75207ff" translate="yes" xml:space="preserve">
          <source>Operator Strategy 2</source>
          <target state="translated">オペレーターの戦略2</target>
        </trans-unit>
        <trans-unit id="32970bd5b0dc670174fa5e603b715a1879812041" translate="yes" xml:space="preserve">
          <source>Operator Strategy 20</source>
          <target state="translated">オペレーター戦略20</target>
        </trans-unit>
        <trans-unit id="151eb78f3e104abebf3876024563a961e2605d2c" translate="yes" xml:space="preserve">
          <source>Operator Strategy 21</source>
          <target state="translated">オペレーター戦略21</target>
        </trans-unit>
        <trans-unit id="8684f3d138a78992a0b771dfbb423682326c65f8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 22</source>
          <target state="translated">オペレーター戦略22</target>
        </trans-unit>
        <trans-unit id="71205740f8d9e86efeb0bd151835d85c0a6b3446" translate="yes" xml:space="preserve">
          <source>Operator Strategy 23</source>
          <target state="translated">オペレーター戦略23</target>
        </trans-unit>
        <trans-unit id="e0c4fa7b818964dd91a014987dc2cbf9d0f35f95" translate="yes" xml:space="preserve">
          <source>Operator Strategy 3</source>
          <target state="translated">オペレーターの戦略3</target>
        </trans-unit>
        <trans-unit id="c0698fd0a94af9d76a35b8038b94b51dc5055fa5" translate="yes" xml:space="preserve">
          <source>Operator Strategy 4</source>
          <target state="translated">オペレーター戦略4</target>
        </trans-unit>
        <trans-unit id="7f6f8898348de22423f28b86e1d340d71a2b39e6" translate="yes" xml:space="preserve">
          <source>Operator Strategy 5</source>
          <target state="translated">オペレーター戦略5</target>
        </trans-unit>
        <trans-unit id="3b8f252bde4d01adf4e5020737ab0f39249112c8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 6, 18</source>
          <target state="translated">オペレーター戦略6、18</target>
        </trans-unit>
        <trans-unit id="63882822a5b9fac73c626ceb2fedd6c07953d3d2" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7</source>
          <target state="translated">オペレーター戦略7</target>
        </trans-unit>
        <trans-unit id="614f640543a97c56dc41fc006e5e6df302593992" translate="yes" xml:space="preserve">
          <source>Operator Strategy 7, 13, 16, 24, 25</source>
          <target state="translated">オペレーター戦略7、13、16、24、25</target>
        </trans-unit>
        <trans-unit id="f5666e86d614f20d9c6c6d654b73870444a0a7b8" translate="yes" xml:space="preserve">
          <source>Operator Strategy 8, 14, 26, 27</source>
          <target state="translated">オペレーター戦略 8,14,26,27</target>
        </trans-unit>
        <trans-unit id="6bd466b077248c905be85a30157069ea7d392f05" translate="yes" xml:space="preserve">
          <source>Operator Strategy 9</source>
          <target state="translated">オペレーター戦略9</target>
        </trans-unit>
        <trans-unit id="23a5e32675db7a6dae8947caf6f8b77d2fb419f2" translate="yes" xml:space="preserve">
          <source>Operator class member</source>
          <target state="translated">演算子クラスメンバー</target>
        </trans-unit>
        <trans-unit id="a154991f482d1ef020b50f829693f6a3e7645883" translate="yes" xml:space="preserve">
          <source>Operator classes are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">演算子クラスについては、&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;セクション37.16で詳しく&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="58080c4fb9795121bf1294991f50a6dd258005c4" translate="yes" xml:space="preserve">
          <source>Operator classes that implement completely different semantics are also possible, provided implementations of the four main support functions described above are written. Note that backwards compatibility across major releases is not guaranteed: for example, additional support functions might be required in later releases.</source>
          <target state="translated">上記で説明した4つの主要なサポート関数の実装が書かれていれば、全く異なるセマンティクスを実装する演算子クラスも可能です。メジャーリリース間の下位互換性は保証されていないことに注意してください:例えば、後のリリースで追加のサポート関数が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="eb753b5f274e2276c93849eb8d4d017ef67b8b0d" translate="yes" xml:space="preserve">
          <source>Operator families are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">演算子族は&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;セクション37.16で詳しく&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="089453e64460e24c4860d90b978d73331899e626" translate="yes" xml:space="preserve">
          <source>Operator family containing the operator class</source>
          <target state="translated">演算子クラスを含む演算子ファミリー</target>
        </trans-unit>
        <trans-unit id="d001f433bb040727266e2e45232ebf1b96c87507" translate="yes" xml:space="preserve">
          <source>Operator purpose, either &lt;code&gt;s&lt;/code&gt; for search or &lt;code&gt;o&lt;/code&gt; for ordering</source>
          <target state="translated">演算子の目的、検索には &lt;code&gt;s&lt;/code&gt; 、注文には &lt;code&gt;o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="912efd8e18516ea9637e59e441f7f7a9add7dc7b" translate="yes" xml:space="preserve">
          <source>Operator strategy number</source>
          <target state="translated">オペレーターの戦略番号</target>
        </trans-unit>
        <trans-unit id="2e8cb1b3b6dd7d5c36991fdde1327aa3fa525b70" translate="yes" xml:space="preserve">
          <source>Operator/Element</source>
          <target state="translated">Operator/Element</target>
        </trans-unit>
        <trans-unit id="2d08499adb61cbc2e5aa0edb02bd1f8b9de48e7f" translate="yes" xml:space="preserve">
          <source>Operator/Method</source>
          <target state="translated">Operator/Method</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="245cf7f12c2bf5a2fc5aaf31f347829fe389252a" translate="yes" xml:space="preserve">
          <source>Operators are represented by &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt;, writing the type names exactly as they appear in the &lt;code&gt;pg_operator.dat&lt;/code&gt; entry's &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields. (Write &lt;code&gt;0&lt;/code&gt; for the omitted operand of a unary operator.)</source>
          <target state="translated">演算子は &lt;code&gt;oprname(lefttype,righttype)&lt;/code&gt; で表され、 &lt;code&gt;pg_operator.dat&lt;/code&gt; エントリの &lt;code&gt;oprleft&lt;/code&gt; および &lt;code&gt;oprright&lt;/code&gt; フィールドに表示されるとおりに型名を記述します。 （単項演算子の省略されたオペランドには &lt;code&gt;0&lt;/code&gt; を書き込みます。）</target>
        </trans-unit>
        <trans-unit id="1f5c0ba13f00010cbbfefca8a52453ff0cb4b539" translate="yes" xml:space="preserve">
          <source>Optimality of the query plan</source>
          <target state="translated">クエリプランの最適化</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="30ea09691f79f4f3b53ede4678ab841460419294" translate="yes" xml:space="preserve">
          <source>Optional data-manipulation: compression, conversion to UTF-8, and/or conversion of line-endings.</source>
          <target state="translated">オプションのデータ操作:圧縮、UTF-8への変換、および/または行末の変換。</target>
        </trans-unit>
        <trans-unit id="dda0500e72a6b8d9415eee2d2bd9c2b4bddc1e78" translate="yes" xml:space="preserve">
          <source>Optional key words. They have no effect.</source>
          <target state="translated">任意のキーワード。何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="be700c602b6a0f91e2d0a7efd9323b26ffbdc0e3" translate="yes" xml:space="preserve">
          <source>Optional parameters can be written in any order, not only the order illustrated above.</source>
          <target state="translated">オプションのパラメータは、上で図示した順序に限らず、任意の順序で記述することができます。</target>
        </trans-unit>
        <trans-unit id="a1ddbf1be07fc433b776138e1087ccfcfc7bb295" translate="yes" xml:space="preserve">
          <source>Optional planner support function for this function (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;Section 37.11&lt;/a&gt;)</source>
          <target state="translated">この関数のオプションのプランナーサポート関数（&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-optimization.html&quot;&gt;セクション37.11を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="2fd16c799a777633af7110bcb3365acd2d2f9b6f" translate="yes" xml:space="preserve">
          <source>Optional server type, potentially useful to foreign-data wrappers.</source>
          <target state="translated">外部データラッパーに便利なサーバ型。</target>
        </trans-unit>
        <trans-unit id="23e65fc5f0e4b9be1c8551d9648425aede4fa734" translate="yes" xml:space="preserve">
          <source>Optional server version, potentially useful to foreign-data wrappers.</source>
          <target state="translated">外部データラッパーに有用な可能性のあるサーババージョン。</target>
        </trans-unit>
        <trans-unit id="8080182e2b9ea49c9096dd85079cd9c704e16363" translate="yes" xml:space="preserve">
          <source>Optionally one can add the key word &lt;code&gt;ASC&lt;/code&gt; (ascending) or &lt;code&gt;DESC&lt;/code&gt; (descending) after any expression in the &lt;code&gt;ORDER BY&lt;/code&gt; clause. If not specified, &lt;code&gt;ASC&lt;/code&gt; is assumed by default. Alternatively, a specific ordering operator name can be specified in the &lt;code&gt;USING&lt;/code&gt; clause. An ordering operator must be a less-than or greater-than member of some B-tree operator family. &lt;code&gt;ASC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;lt;&lt;/code&gt; and &lt;code&gt;DESC&lt;/code&gt; is usually equivalent to &lt;code&gt;USING &amp;gt;&lt;/code&gt;. (But the creator of a user-defined data type can define exactly what the default sort ordering is, and it might correspond to operators with other names.)</source>
          <target state="translated">オプションで、 &lt;code&gt;ORDER BY&lt;/code&gt; 句の式の後にキーワード &lt;code&gt;ASC&lt;/code&gt; （昇順）または &lt;code&gt;DESC&lt;/code&gt; （降順）を追加できます。指定しない場合、デフォルトで &lt;code&gt;ASC&lt;/code&gt; が想定されます。または、特定の順序付け演算子名を &lt;code&gt;USING&lt;/code&gt; 句で指定できます。順序付け演算子は、一部のBツリー演算子ファミリの小なりまたは大なりメンバーである必要があります。 &lt;code&gt;ASC&lt;/code&gt; は通常 &lt;code&gt;USING &amp;lt;&lt;/code&gt; と同等であり、 &lt;code&gt;DESC&lt;/code&gt; は通常 &lt;code&gt;USING &amp;gt;&lt;/code&gt; と同等です。 （しかし、ユーザー定義のデータ型の作成者は、デフォルトのソート順を正確に定義でき、他の名前の演算子に対応している場合があります。）</target>
        </trans-unit>
        <trans-unit id="25a8ce77c093de9028c29694dad75d1d0b46f922" translate="yes" xml:space="preserve">
          <source>Optionally specifies an existing replication slot to be used when connecting to the sending server via streaming replication to control resource removal on the upstream node (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). This parameter can only be set at server start. This setting has no effect if &lt;code&gt;primary_conninfo&lt;/code&gt; is not set.</source>
          <target state="translated">必要に応じて、ストリーミングレプリケーションを介して送信サーバーに接続し、上流ノードでのリソースの削除を制御するときに使用する既存のレプリケーションスロットを指定します（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;セクション26.2.6を&lt;/a&gt;参照）。このパラメータは、サーバーの起動時にのみ設定できます。 &lt;code&gt;primary_conninfo&lt;/code&gt; が設定されていない場合、この設定は効果がありません。</target>
        </trans-unit>
        <trans-unit id="a9e1a54cb19d7f45ef6c62130cbc0ebd54aaaeaa" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;CREATE SCHEMA&lt;/code&gt; can include subcommands to create objects within the new schema. The subcommands are treated essentially the same as separate commands issued after creating the schema, except that if the &lt;code&gt;AUTHORIZATION&lt;/code&gt; clause is used, all the created objects will be owned by that user.</source>
          <target state="translated">オプションで、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; には、新しいスキーマ内にオブジェクトを作成するサブコマンドを含めることができます。サブコマンドは、 &lt;code&gt;AUTHORIZATION&lt;/code&gt; 句が使用される場合、作成されたすべてのオブジェクトがそのユーザーによって所有されることを除いて、スキーマの作成後に発行された個別のコマンドと基本的に同じように扱われます。</target>
        </trans-unit>
        <trans-unit id="fb213cf60cad5118b118598f7c3788d5e4cf965c" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt; can be written before &lt;code&gt;TEMPORARY&lt;/code&gt; or &lt;code&gt;TEMP&lt;/code&gt;. This presently makes no difference in PostgreSQL and is deprecated; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;Compatibility&lt;/a&gt;.</source>
          <target state="translated">オプションで、 &lt;code&gt;GLOBAL&lt;/code&gt; または &lt;code&gt;LOCAL&lt;/code&gt; を &lt;code&gt;TEMPORARY&lt;/code&gt; または &lt;code&gt;TEMP&lt;/code&gt; の前に書き込むことができます。現在、これはPostgreSQLで違いはなく、非推奨です。&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-COMPATIBILITY&quot;&gt;互換性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="38ce22db7991e92cf37c1757c548b3362a7ca1aa" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;in_range&lt;/em&gt; support function(s), registered under support function number 3. These are not used during btree index operations; rather, they extend the semantics of the operator family so that it can support window clauses containing the &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;PRECEDING&lt;/code&gt; and &lt;code&gt;RANGE&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt;&lt;code&gt;FOLLOWING&lt;/code&gt; frame bound types (see &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt;). Fundamentally, the extra information provided is how to add or subtract an &lt;code&gt;offset&lt;/code&gt; value in a way that is compatible with the family's data ordering.</source>
          <target state="translated">オプションで、btree演算子ファミリは、サポート関数番号3で登録された&lt;em&gt;in_range&lt;/em&gt;サポート関数を提供できます。これらは、btreeインデックス操作中には使用されません。むしろ、それらは演算子ファミリのセマンティクスを拡張して、 &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;PRECEDING&lt;/code&gt; および &lt;code&gt;RANGE&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; &lt;code&gt;FOLLOWING&lt;/code&gt; フレームバインドタイプを含むウィンドウ句をサポートできるようにします（&lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;セクション4.2.8を&lt;/a&gt;参照）。基本的に、提供される追加情報は、ファミリのデータ順序と互換性のある方法で &lt;code&gt;offset&lt;/code&gt; 値を加算または減算する方法です。</target>
        </trans-unit>
        <trans-unit id="478c790850d122e707e8f7883dedaa4fc2abbd82" translate="yes" xml:space="preserve">
          <source>Optionally, a btree operator family may provide &lt;em&gt;sort support&lt;/em&gt; function(s), registered under support function number 2. These functions allow implementing comparisons for sorting purposes in a more efficient way than naively calling the comparison support function. The APIs involved in this are defined in &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt;.</source>
          <target state="translated">オプションで、btree演算子ファミリーは、サポート関数番号2で登録された&lt;em&gt;ソートサポート&lt;/em&gt;関数を提供でき&lt;em&gt;ます&lt;/em&gt;。これらの関数により、比較サポート関数を単純に呼び出すよりも効率的な方法でソート目的の比較を実装できます。これに関係するAPIは &lt;code&gt;src/include/utils/sortsupport.h&lt;/code&gt; で定義されています。</target>
        </trans-unit>
        <trans-unit id="8d0b1d8f44651eff9c08018d57dc26658e0d79ec" translate="yes" xml:space="preserve">
          <source>Optionally, an operator class for GIN can supply the following method:</source>
          <target state="translated">オプションとして、GIN用の演算子クラスは、以下のメソッドを提供することができます。</target>
        </trans-unit>
        <trans-unit id="555fcafecaac1b7a79da77571a044c4fcd960ef4" translate="yes" xml:space="preserve">
          <source>Optionally, integer &lt;em&gt;positions&lt;/em&gt; can be attached to lexemes:</source>
          <target state="translated">オプションで、整数&lt;em&gt;位置&lt;/em&gt;を語彙素に付加できます。</target>
        </trans-unit>
        <trans-unit id="ba2c90dde0ab03dd101be9fe39552cd35bcc19fc" translate="yes" xml:space="preserve">
          <source>Optionally, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with one or more weight letters, which restricts them to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes with one of those weights:</source>
          <target state="translated">オプションで、 &lt;code&gt;tsquery&lt;/code&gt; 内の語彙素は1つ以上の重み文字でラベル付けできます。これにより、それらの重みのいずれかを持つ &lt;code&gt;tsvector&lt;/code&gt; 語彙素のみに一致するように制限されます。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="bfb2e74b331377cdefa56e8103510af4757e8e75" translate="yes" xml:space="preserve">
          <source>Options are named to be similar to GnuPG. An option's value should be given after an equal sign; separate options from each other with commas. For example:</source>
          <target state="translated">オプションは GnuPG と似たような名前が付けられています。オプションの値は等号の後に与えなければなりません。オプションはカンマで区切ってください。</target>
        </trans-unit>
        <trans-unit id="01c5d645df020042965df6656c79fbcb52302c6d" translate="yes" xml:space="preserve">
          <source>Options for Single-User Mode</source>
          <target state="translated">シングルユーザーモードのオプション</target>
        </trans-unit>
        <trans-unit id="2cc6e913a91a4d81d0ee2eacb713152c147c5122" translate="yes" xml:space="preserve">
          <source>Options for Windows</source>
          <target state="translated">Windows用オプション</target>
        </trans-unit>
        <trans-unit id="0807432116c5005f30d6e9cc2d8f5760b3400db2" translate="yes" xml:space="preserve">
          <source>Options specified for authentication method, if any</source>
          <target state="translated">認証方法に指定されたオプションがある場合</target>
        </trans-unit>
        <trans-unit id="2ba952bec3ffacb85d251e04c62c8891e8cc4022" translate="yes" xml:space="preserve">
          <source>Options to be associated with the new foreign table or one of its columns. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Duplicate option names are not allowed (although it's OK for a table option and a column option to have the same name).</source>
          <target state="translated">新しい外部テーブルあるいはそのカラムのひとつに関連付けられるオプション。許可されるオプション名や値は、それぞれの外部データラッパーに固有のものであり、 外部データラッパーのバリデータ機能を用いて検証されます。オプション名の重複は許されていません(テーブルオプションとカラムオプションが同じ名前であっても構いません)。</target>
        </trans-unit>
        <trans-unit id="ea0cc8f54bce88ccfd10bba527220a016a032c30" translate="yes" xml:space="preserve">
          <source>Options to be used during the import. The allowed option names and values are specific to each foreign data wrapper.</source>
          <target state="translated">インポート中に使用されるオプションです。許可されるオプション名と値は、各外部データラッパーに固有のものです。</target>
        </trans-unit>
        <trans-unit id="9a0c5ecf28319808109742741597da1a162506e4" translate="yes" xml:space="preserve">
          <source>Or, if no array size is to be specified:</source>
          <target state="translated">または、配列サイズを指定しない場合。</target>
        </trans-unit>
        <trans-unit id="57f20b026b33a5f996b1722a8963058f7f139ed9" translate="yes" xml:space="preserve">
          <source>Order in which the entries are processed (1..&lt;code&gt;n&lt;/code&gt;)</source>
          <target state="translated">エントリが処理される順序（1 .. &lt;code&gt;n&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6b71865e60556421edb3dc5a27a33115f8d23b2c" translate="yes" xml:space="preserve">
          <source>Order in which to consult this entry (lower &lt;code&gt;mapseqno&lt;/code&gt;s first)</source>
          <target state="translated">このエントリを参照する順序（最初に &lt;code&gt;mapseqno&lt;/code&gt; を下げる）</target>
        </trans-unit>
        <trans-unit id="9032c5927654c6b139387affcba7ab64e16f3699" translate="yes" xml:space="preserve">
          <source>Ordering Operators</source>
          <target state="translated">演算子を注文する</target>
        </trans-unit>
        <trans-unit id="bb496dd08aebe7c50e13b0f636e3490f9e72e352" translate="yes" xml:space="preserve">
          <source>Ordinarily a cast must have different source and target data types. However, it is allowed to declare a cast with identical source and target types if it has a cast implementation function with more than one argument. This is used to represent type-specific length coercion functions in the system catalogs. The named function is used to coerce a value of the type to the type modifier value given by its second argument.</source>
          <target state="translated">通常、キャストはソースとターゲットのデータ型が異なるものでなければなりません。しかし、複数の引数を持つキャスト実装関数を持つ場合は、ソースとターゲットのデータ型が同一のキャストを宣言することが許されています。これは、システムカタログで型別の長さ強制関数を表現するために使用されます。名前付き関数は、その型の値をその第2引数で与えられた型修飾子の値に強制するために使用されます。</target>
        </trans-unit>
        <trans-unit id="23ae1f89c4cafddef64330187ff525b64ad51110" translate="yes" xml:space="preserve">
          <source>Ordinarily, PostgreSQL functions are expected to be true functions that do not modify their input values. However, an aggregate transition function, &lt;em&gt;when used in the context of an aggregate&lt;/em&gt;, is allowed to cheat and modify its transition-state argument in place. This can provide substantial performance benefits compared to making a fresh copy of the transition state each time.</source>
          <target state="translated">通常、PostgreSQL関数は、入力値を変更しない真の関数であることが期待されます。ただし、集約遷移関数&lt;em&gt;は、集約のコンテキストで使用された場合、&lt;/em&gt;その遷移状態引数を適切にチートおよび変更できます。これにより、遷移状態の新しいコピーを毎回作成する場合と比較して、パフォーマンスが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="7c0095250f58080cd4f7b0263a9f790d13029e21" translate="yes" xml:space="preserve">
          <source>Ordinarily, if a date/time string is syntactically valid but contains out-of-range field values, an error will be thrown. For example, input specifying the 31st of February will be rejected.</source>
          <target state="translated">通常、日付/時刻文字列が構文的には有効であるが、範囲外のフィールド値を含む場合、エラーがスローされる。例えば、2月31日を指定した入力は拒否されます。</target>
        </trans-unit>
        <trans-unit id="d469c00e9517d285e5591f4a6f0cfdb929fc4475" translate="yes" xml:space="preserve">
          <source>Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege &amp;ldquo;with grant option&amp;rdquo;, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege. For details see the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; reference pages.</source>
          <target state="translated">通常、オブジェクトの所有者（またはスーパーユーザー）のみがオブジェクトの権限を付与または取り消すことができます。ただし、「付与オプション付き」の権限を付与することもできます。これにより、受信者は、権限を他のユーザーに付与することができます。その後、付与オプションが取り消されると、その受信者から（直接または一連の付与を通じて）特権を受け取ったすべてのユーザーが特権を失います。詳細については、&lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt;および&lt;a href=&quot;sql-revoke&quot;&gt;REVOKEの&lt;/a&gt;リファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="1198b431d5751f4a8f2d46d9894c80568e5c546c" translate="yes" xml:space="preserve">
          <source>Ordinarily, the input rows are fed to the aggregate function in an unspecified order. In many cases this does not matter; for example, &lt;code&gt;min&lt;/code&gt; produces the same result no matter what order it receives the inputs in. However, some aggregate functions (such as &lt;code&gt;array_agg&lt;/code&gt; and &lt;code&gt;string_agg&lt;/code&gt;) produce results that depend on the ordering of the input rows. When using such an aggregate, the optional &lt;code&gt;order_by_clause&lt;/code&gt; can be used to specify the desired ordering. The &lt;code&gt;order_by_clause&lt;/code&gt; has the same syntax as for a query-level &lt;code&gt;ORDER BY&lt;/code&gt; clause, as described in &lt;a href=&quot;queries-order&quot;&gt;Section 7.5&lt;/a&gt;, except that its expressions are always just expressions and cannot be output-column names or numbers. For example:</source>
          <target state="translated">通常、入力行は不特定の順序で集約関数に送られます。多くの場合、これは問題ではありません。たとえば、 &lt;code&gt;min&lt;/code&gt; は入力を受け取る順序に関係なく同じ結果を生成します。ただし、一部の集計関数（ &lt;code&gt;array_agg&lt;/code&gt; や &lt;code&gt;string_agg&lt;/code&gt; など）は、入力行の順序に依存する結果を生成します。このような集約を使用する場合、オプションの &lt;code&gt;order_by_clause&lt;/code&gt; を使用して、目的の順序を指定できます。 &lt;code&gt;order_by_clause&lt;/code&gt; には、クエリ・レベルと同じシンタックスを有する &lt;code&gt;ORDER BY&lt;/code&gt; に記載されるように、句&lt;a href=&quot;queries-order&quot;&gt;節7.5&lt;/a&gt;。ただし、その式は常に単なる式であり、出力列の名前や数値にすることはできません。例えば：</target>
        </trans-unit>
        <trans-unit id="2a1751155e24c2b7f81369ad2aa106588546c4f5" translate="yes" xml:space="preserve">
          <source>Ordinarily, the user must have the PostgreSQL superuser privilege to register a new language. However, the owner of a database can register a new language within that database if the language is listed in the &lt;code&gt;pg_pltemplate&lt;/code&gt; catalog and is marked as allowed to be created by database owners (&lt;code&gt;tmpldbacreate&lt;/code&gt; is true). The default is that trusted languages can be created by database owners, but this can be adjusted by superusers by modifying the contents of &lt;code&gt;pg_pltemplate&lt;/code&gt;. The creator of a language becomes its owner and can later drop it, rename it, or assign it to a new owner.</source>
          <target state="translated">通常、ユーザーが新しい言語を登録するには、PostgreSQLスーパーユーザー権限が必要です。ただし、言語が &lt;code&gt;pg_pltemplate&lt;/code&gt; カタログにリストされており、データベース所有者による作成が許可されているとマークされている場合（ &lt;code&gt;tmpldbacreate&lt;/code&gt; がtrue）、データベースの所有者はそのデータベース内に新しい言語を登録できます。デフォルトでは、信頼できる言語はデータベース所有者が作成できますが、これは &lt;code&gt;pg_pltemplate&lt;/code&gt; の内容を変更することにより、スーパーユーザーが調整できます。言語の作成者はその所有者になり、後で削除、名前変更、または新しい所有者に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="49558321bc55879a8f79a252d13bd83f15cac2ec" translate="yes" xml:space="preserve">
          <source>Ordinary comparison operators yield null (signifying &amp;ldquo;unknown&amp;rdquo;), not true or false, when either input is null. For example, &lt;code&gt;7 = NULL&lt;/code&gt; yields null, as does &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt;. When this behavior is not suitable, use the &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; predicates:</source>
          <target state="translated">通常の比較演算子は、いずれかの入力がnullの場合、trueまたはfalseではなくnull（「不明」を示す）を生成します。たとえば、 &lt;code&gt;7 = NULL&lt;/code&gt; &lt;code&gt;7 &amp;lt;&amp;gt; NULL&lt;/code&gt; と同様に、7 = NULLはnullを生成します。この動作が適切でない場合は、 &lt;code&gt;IS [ NOT ] DISTINCT FROM&lt;/code&gt; 述部を使用します。</target>
        </trans-unit>
        <trans-unit id="1f51e9682012527e72ed015353424811e9ad8a4d" translate="yes" xml:space="preserve">
          <source>Ordinary text is allowed in &lt;code&gt;to_char&lt;/code&gt; templates and will be output literally. You can put a substring in double quotes to force it to be interpreted as literal text even if it contains template patterns. For example, in &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt;, the &lt;code&gt;YYYY&lt;/code&gt; will be replaced by the year data, but the single &lt;code&gt;Y&lt;/code&gt; in &lt;code&gt;Year&lt;/code&gt; will not be. In &lt;code&gt;to_date&lt;/code&gt;, &lt;code&gt;to_number&lt;/code&gt;, and &lt;code&gt;to_timestamp&lt;/code&gt;, literal text and double-quoted strings result in skipping the number of characters contained in the string; for example &lt;code&gt;&quot;XX&quot;&lt;/code&gt; skips two input characters (whether or not they are &lt;code&gt;XX&lt;/code&gt;).</source>
          <target state="translated">通常のテキストは &lt;code&gt;to_char&lt;/code&gt; テンプレートで使用でき、文字どおりに出力されます。テンプレートパターンが含まれている場合でも、サブストリングを二重引用符で囲んでリテラルテキストとして強制的に解釈させることができます。例えば、で &lt;code&gt;'&quot;Hello Year &quot;YYYY'&lt;/code&gt; 、 &lt;code&gt;YYYY&lt;/code&gt; は年データに置き換えられますが、単一 &lt;code&gt;Y&lt;/code&gt; における &lt;code&gt;Year&lt;/code&gt; ではありません。で &lt;code&gt;to_date&lt;/code&gt; 、 &lt;code&gt;to_number&lt;/code&gt; 、および &lt;code&gt;to_timestamp&lt;/code&gt; 、リテラルテキストと二重引用符で囲まれた文字列は、文字列に含まれる文字の数をスキップになります。たとえば、 &lt;code&gt;&quot;XX&quot;&lt;/code&gt; は2つの入力文字をスキップします（ &lt;code&gt;XX&lt;/code&gt; かどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="47deb2333130b0b71a558b913d84907ec715a39c" translate="yes" xml:space="preserve">
          <source>Original UNIX crypt</source>
          <target state="translated">オリジナルのUNIX暗号</target>
        </trans-unit>
        <trans-unit id="728421f1a8e764e582012583a50320fee679ab3e" translate="yes" xml:space="preserve">
          <source>Original author: Gene Selkov, Jr. &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt;, Mathematics and Computer Science Division, Argonne National Laboratory.</source>
          <target state="translated">原作者：ジーンセルコフジュニア &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:selkovjr@mcs.anl.gov&quot;&gt;selkovjr@mcs.anl.gov&lt;/a&gt;&amp;gt;&lt;/code&gt; 、アルゴンヌ国立研究所、数学およびコンピュータサイエンス部門。</target>
        </trans-unit>
        <trans-unit id="15c3cbc7d90ec04ca02171128016ae7aa1d06c07" translate="yes" xml:space="preserve">
          <source>Original version by Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt;. Rewritten in version 8.4 to suit new FSM implementation by Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Mark Kirkwood &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:markir@paradise.net.nz&quot;&gt;markir@paradise.net.nz&lt;/a&gt;&amp;gt;&lt;/code&gt; によるオリジナルバージョン。Heikki Linnakangas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;mailto:heikki@enterprisedb.com&quot;&gt;heikki@enterprisedb.com&lt;/a&gt; &amp;gt;による新しいFSM実装に合わせてバージョン8.4で書き直されました</target>
        </trans-unit>
        <trans-unit id="6c3f5ca5b9a803aee38134c4fbdc2dd67fcb8f9e" translate="yes" xml:space="preserve">
          <source>Other clients and libraries might provide their own mechanisms, via the shell or otherwise, that allow the user to alter session settings without direct use of SQL commands.</source>
          <target state="translated">他のクライアントやライブラリは、ユーザーがSQLコマンドを直接使用せずにセッション設定を変更できるように、シェルやその他の方法で独自のメカニズムを提供しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="1b025a6555e41ac8947f0005aa2f96a2fbcedc20" translate="yes" xml:space="preserve">
          <source>Other database systems might advance these values more frequently.</source>
          <target state="translated">他のデータベースシステムでは、これらの値をより頻繁に進めることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="16dab4fb6d3b76123e52d90af3ba7c8bf6cdec38" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future.</source>
          <target state="translated">将来的には他の依存関係のフレーバーが必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d54e9e4d1cedbb61d73910e1c0331a6b34276e3c" translate="yes" xml:space="preserve">
          <source>Other dependency flavors might be needed in future. Note in particular that the current definition only supports roles as referenced objects.</source>
          <target state="translated">将来的には他の依存関係が必要になるかもしれません。特に、現在の定義では、参照オブジェクトとしてのロールのみをサポートしていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b090b2cc862f6eb58c39020ceea8daeedfe6f7b3" translate="yes" xml:space="preserve">
          <source>Other digest algorithms</source>
          <target state="translated">その他のダイジェストアルゴリズム</target>
        </trans-unit>
        <trans-unit id="dd97a9c89af824879fb23956d987ca3355ff4cc8" translate="yes" xml:space="preserve">
          <source>Other libraries can also be preloaded. By preloading a shared library, the library startup time is avoided when the library is first used. However, the time to start each new server process might increase slightly, even if that process never uses the library. So this parameter is recommended only for libraries that will be used in most sessions. Also, changing this parameter requires a server restart, so this is not the right setting to use for short-term debugging tasks, say. Use &lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt; for that instead.</source>
          <target state="translated">他のライブラリもプリロードできます。共有ライブラリをプリロードすることにより、ライブラリが最初に使用されるときのライブラリの起動時間が回避されます。ただし、そのプロセスがライブラリを使用しない場合でも、新しいサーバープロセスを開始する時間はわずかに増加する可能性があります。したがって、このパラメーターは、ほとんどのセッションで使用されるライブラリーに対してのみ推奨されます。また、このパラメーターを変更するとサーバーの再起動が必要になるため、これは短期的なデバッグタスクに使用するのに適切な設定ではありません。代わりに、&lt;a href=&quot;runtime-config-client#GUC-SESSION-PRELOAD-LIBRARIES&quot;&gt;session_preload_libraries&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="8b6d149d1176a026cafb96a0f82667c8ba54a10c" translate="yes" xml:space="preserve">
          <source>Other options are also available:</source>
          <target state="translated">その他のオプションもご用意しております。</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">その他のオプション</target>
        </trans-unit>
        <trans-unit id="da25b0d9d5dc45c67ed8cb3f27503780b4aa4443" translate="yes" xml:space="preserve">
          <source>Other recommended kernel setting changes for database servers which will have a large number of connections are:</source>
          <target state="translated">その他、接続数が多くなるデータベースサーバに推奨されるカーネルの設定変更は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3903dba9afe98748981ae8bb62ee1e14b5b5b0bf" translate="yes" xml:space="preserve">
          <source>Other scan types, such as scans of non-btree indexes, may support parallel scans in the future.</source>
          <target state="translated">非ツリーインデックスのスキャンなど、他のスキャンタイプも将来的には並列スキャンをサポートするようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c88c65d71407192da2177c969f1b4c3e1b24c5ec" translate="yes" xml:space="preserve">
          <source>Other systems may only allow setting the time source on boot. On older Linux systems the &quot;clock&quot; kernel setting is the only way to make this sort of change. And even on some more recent ones, the only option you'll see for a clock source is &quot;jiffies&quot;. Jiffies are the older Linux software clock implementation, which can have good resolution when it's backed by fast enough timing hardware, as in this example:</source>
          <target state="translated">他のシステムでは、起動時に時間のソースを設定できるだけかもしれません。古い Linux システムでは &quot;clock&quot; カーネル設定がこの種の変更を行う唯一の方法です。最近のシステムでも、クロックソースのオプションは &quot;jiffies&quot; のみです。Jiffies は古い Linux ソフトウェアのクロックの実装で、この例のように十分に高速なタイミングハードウェアに支えられていれば、良い解像度を持つことができます。</target>
        </trans-unit>
        <trans-unit id="4a2d21cbb1de6f88a1dcf3d541f364a9e95c1127" translate="yes" xml:space="preserve">
          <source>Other than configuration of the negotiation behavior, GSSAPI encryption requires no setup beyond that which is necessary for GSSAPI authentication. (For more information on configuring that, see &lt;a href=&quot;gssapi-auth&quot;&gt;Section 20.6&lt;/a&gt;.)</source>
          <target state="translated">GSSAPI暗号化では、ネゴシエーション動作の構成以外に、GSSAPI認証に必要な設定以外の設定は必要ありません。（その構成の詳細は、&lt;a href=&quot;gssapi-auth&quot;&gt;20.6項を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="d21779594b1e9934ec89f12215df7e04fc45898b" translate="yes" xml:space="preserve">
          <source>Other ways of looking at the statistics can be set up by writing queries that use the same underlying statistics access functions used by the standard views shown above. For details such as the functions' names, consult the definitions of the standard views. (For example, in psql you could issue &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt;.) The access functions for per-database statistics take a database OID as an argument to identify which database to report on. The per-table and per-index functions take a table or index OID. The functions for per-function statistics take a function OID. Note that only tables, indexes, and functions in the current database can be seen with these functions.</source>
          <target state="translated">上記の標準ビューで使用されているのと同じ基礎となる統計アクセス関数を使用するクエリを記述することで、統計を表示する他の方法を設定できます。関数名などの詳細については、標準ビューの定義を参照してください。 （たとえば、psqlでは、 &lt;code&gt;\d+ pg_stat_activity&lt;/code&gt; 発行できます。）データベースごとの統計のアクセス関数は、レポートするデータベースを識別するための引数としてデータベースOIDを受け取ります。テーブルごとおよびインデックスごとの関数は、テーブルまたはインデックスのOIDを取ります。関数ごとの統計の関数は関数OIDを取ります。これらの関数で表示できるのは、現在のデータベースのテーブル、インデックス、および関数のみであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5209293ce5b675774d27db322f4e25b9f78fde50" translate="yes" xml:space="preserve">
          <source>Other, less commonly used, options are also available:</source>
          <target state="translated">その他、あまり使用されていないオプションもあります。</target>
        </trans-unit>
        <trans-unit id="86f791018da698782167efe67330f3a311425f18" translate="yes" xml:space="preserve">
          <source>Otherwise the date field ordering is assumed to follow the &lt;code&gt;DateStyle&lt;/code&gt; setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd. Throw an error if a month or day field is found to be out of range.</source>
          <target state="translated">それ以外の場合、日付フィールドの順序は、 &lt;code&gt;DateStyle&lt;/code&gt; 設定（mm-dd-yy、dd-mm-yy、またはyy-mm-dd）に従うと見なされます。月または日のフィールドが範囲外であることが判明した場合、エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="456174149b4fb59cccb0b858ebfab00191262c8b" translate="yes" xml:space="preserve">
          <source>Otherwise, all input expressions must have the same implicit collation derivation or the default collation. If any non-default collation is present, that is the result of the collation combination. Otherwise, the result is the default collation.</source>
          <target state="translated">そうでなければ、すべての入力式は、同じ暗黙の照合順序の派生またはデフォルトの照合順序を持っていなければなりません。デフォルト以外の照合順序が存在する場合、それは照合順序の組み合わせの結果です。そうでない場合は、その結果がデフォルトの照合順序となります。</target>
        </trans-unit>
        <trans-unit id="d7ebacc516a1689e9342c3f059955ce6038791c1" translate="yes" xml:space="preserve">
          <source>Otherwise, choose the last non-unknown input type that allows all the preceding non-unknown inputs to be implicitly converted to it. (There always is such a type, since at least the first type in the list must satisfy this condition.)</source>
          <target state="translated">それ以外の場合は、前にあるすべての非未知の入力を暗黙のうちに変換できる最後の非未知の入力型を選択します。(リストの少なくとも最初の型がこの条件を満たしていなければならないので,このような型は常に存在します).</target>
        </trans-unit>
        <trans-unit id="b9c2a604b8999f698fdb4a51e3a4309645319d17" translate="yes" xml:space="preserve">
          <source>Otherwise, if the JSON value is a string literal, the contents of the string are fed to the input conversion function for the column's data type.</source>
          <target state="translated">そうでなければ、JSON値が文字列リテラルである場合、文字列の内容はカラムのデータ型の入力変換関数に供給されます。</target>
        </trans-unit>
        <trans-unit id="7bead17837ca29580c9cb15e38f0a813be5d9242" translate="yes" xml:space="preserve">
          <source>Otherwise, the ordinary text representation of the JSON value is fed to the input conversion function for the column's data type.</source>
          <target state="translated">それ以外の場合は、JSON値の通常のテキスト表現が、その列のデータ型の入力変換関数に供給されます。</target>
        </trans-unit>
        <trans-unit id="c91502e459c401481e3ca0162bbcb613cfb57d2b" translate="yes" xml:space="preserve">
          <source>Otherwise, try to convert the expression to the target type. This is possible if an &lt;em&gt;assignment cast&lt;/em&gt; between the two types is registered in the &lt;code&gt;pg_cast&lt;/code&gt; catalog (see &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;). Alternatively, if the expression is an unknown-type literal, the contents of the literal string will be fed to the input conversion routine for the target type.</source>
          <target state="translated">それ以外の場合は、式をターゲットの型に変換してみてください。これは、2つのタイプ間の&lt;em&gt;割り当てキャスト&lt;/em&gt;が &lt;code&gt;pg_cast&lt;/code&gt; カタログに登録されている場合に可能です（&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CASTを&lt;/a&gt;参照）。または、式が不明なタイプのリテラルである場合、リテラル文字列の内容がターゲットタイプの入力変換ルーチンに送られます。</target>
        </trans-unit>
        <trans-unit id="43c3af901aa493d7824a6ced3329413231661c11" translate="yes" xml:space="preserve">
          <source>Out-of-line values are divided (after compression if used) into chunks of at most &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; bytes (by default this value is chosen so that four chunk rows will fit on a page, making it about 2000 bytes). Each chunk is stored as a separate row in the TOAST table belonging to the owning table. Every TOAST table has the columns &lt;code&gt;chunk_id&lt;/code&gt; (an OID identifying the particular TOASTed value), &lt;code&gt;chunk_seq&lt;/code&gt; (a sequence number for the chunk within its value), and &lt;code&gt;chunk_data&lt;/code&gt; (the actual data of the chunk). A unique index on &lt;code&gt;chunk_id&lt;/code&gt; and &lt;code&gt;chunk_seq&lt;/code&gt; provides fast retrieval of the values. A pointer datum representing an out-of-line on-disk TOASTed value therefore needs to store the OID of the TOAST table in which to look and the OID of the specific value (its &lt;code&gt;chunk_id&lt;/code&gt;). For convenience, pointer datums also store the logical datum size (original uncompressed data length) and physical stored size (different if compression was applied). Allowing for the varlena header bytes, the total size of an on-disk TOAST pointer datum is therefore 18 bytes regardless of the actual size of the represented value.</source>
          <target state="translated">行外の値は、最大で &lt;code&gt;TOAST_MAX_CHUNK_SIZE&lt;/code&gt; バイトのチャンクに分割されます（使用される場合は圧縮後）（デフォルトでは、この値は4つのチャンク行が1ページに収まるように選択され、約2000バイトになります）。各チャンクは、所有するテーブルに属するTOASTテーブルの個別の行として格納されます。すべてのTOASTテーブルは、列が持つ &lt;code&gt;chunk_id&lt;/code&gt; （特にトースト値を識別するOID）、 &lt;code&gt;chunk_seq&lt;/code&gt; 列（その値内のチャンクのシーケンス番号）、及び &lt;code&gt;chunk_data&lt;/code&gt; （チャンクの実際のデータ）。一意索引 &lt;code&gt;chunk_id&lt;/code&gt; と &lt;code&gt;chunk_seq&lt;/code&gt; 列値の高速検索を提供します。したがって、ディスク上のTOASTされた値がアウトオブラインであることを表すポインターデータは、参照先のTOASTテーブルのOIDと特定の値（その &lt;code&gt;chunk_id&lt;/code&gt; ）のOIDを格納する必要があります。便宜上、ポインタデータムは論理データムサイズ（元の非圧縮データ長）と物理保存サイズ（圧縮が適用されている場合は異なる）も保存します。したがって、varlenaヘッダーバイトを考慮に入れると、ディスク上のTOASTポインターデータの合計サイズは、表現された値の実際のサイズに関係なく18バイトになります。</target>
        </trans-unit>
        <trans-unit id="97c53cd2b521753c0d717a86dd39f58035793149" translate="yes" xml:space="preserve">
          <source>Output Length</source>
          <target state="translated">出力長</target>
        </trans-unit>
        <trans-unit id="afe32b815eb6ac2d448375f1b337e892bc780a8c" translate="yes" xml:space="preserve">
          <source>Output Result</source>
          <target state="translated">出力結果</target>
        </trans-unit>
        <trans-unit id="a19289a8a65e3eaa1c70019f70d69f0ccdc7e3cc" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">オブジェクトの所有権を判別するために、 &lt;code&gt;ALTER OWNER&lt;/code&gt; コマンドではなく、SQL標準の &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; コマンドを出力します。これにより、ダンプの互換性が向上しますが、ダンプ内のオブジェクトの履歴によっては、正しく復元されない場合があります。</target>
        </trans-unit>
        <trans-unit id="8d49ccd8d61f0c2e0d773215d12c820e621fe051" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly.</source>
          <target state="translated">オブジェクトの所有権を判別するために、 &lt;code&gt;ALTER OWNER&lt;/code&gt; コマンドではなく、SQL標準の &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; コマンドを出力します。これにより、ダンプの標準互換性が向上しますが、ダンプ内のオブジェクトの履歴によっては、正しく復元されない場合があります。</target>
        </trans-unit>
        <trans-unit id="4625db4629522bcdf0c7c483ff44db087396b6a5" translate="yes" xml:space="preserve">
          <source>Output SQL-standard &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; commands instead of &lt;code&gt;ALTER OWNER&lt;/code&gt; commands to determine object ownership. This makes the dump more standards-compatible, but depending on the history of the objects in the dump, might not restore properly. Also, a dump using &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; will certainly require superuser privileges to restore correctly, whereas &lt;code&gt;ALTER OWNER&lt;/code&gt; requires lesser privileges.</source>
          <target state="translated">オブジェクトの所有権を判別するために、 &lt;code&gt;ALTER OWNER&lt;/code&gt; コマンドではなく、SQL標準の &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; コマンドを出力します。これにより、ダンプの標準互換性が向上しますが、ダンプ内のオブジェクトの履歴によっては、正しく復元されない場合があります。また、 &lt;code&gt;SET SESSION AUTHORIZATION&lt;/code&gt; を使用したダンプでは、正しく復元するためにスーパーユーザー権限が必要になりますが、 &lt;code&gt;ALTER OWNER&lt;/code&gt; にはそれほど権限は必要ありません。</target>
        </trans-unit>
        <trans-unit id="2005b7d907d65c19aff7a047dfc1b1dcc52ef1ca" translate="yes" xml:space="preserve">
          <source>Output a &lt;code&gt;tar&lt;/code&gt;-format archive suitable for input into pg_restore. The tar format is compatible with the directory format: extracting a tar-format archive produces a valid directory-format archive. However, the tar format does not support compression. Also, when using tar format the relative order of table data items cannot be changed during restore.</source>
          <target state="translated">pg_restoreへの入力に適した &lt;code&gt;tar&lt;/code&gt; 形式のアーカイブを出力します。tar形式はディレクトリ形式と互換性があります。tar形式のアーカイブを抽出すると、有効なディレクトリ形式のアーカイブが生成されます。ただし、tar形式は圧縮をサポートしていません。また、tar形式を使用している場合、テーブルデータアイテムの相対的な順序を復元中に変更することはできません。</target>
        </trans-unit>
        <trans-unit id="2eb830dc0187c951bb3c38e2fc9ae11b3f83d2a4" translate="yes" xml:space="preserve">
          <source>Output a custom-format archive suitable for input into pg_restore. Together with the directory output format, this is the most flexible output format in that it allows manual selection and reordering of archived items during restore. This format is also compressed by default.</source>
          <target state="translated">pg_restoreへの入力に適したカスタムフォーマットのアーカイブを出力します。これはディレクトリ出力形式とともに、リストア中にアーカイブされた項目を手動で選択して並べ替えることができるという点で、最も柔軟性の高い出力形式です。また、この形式はデフォルトで圧縮されています。</target>
        </trans-unit>
        <trans-unit id="314bcb0a58dea88f5b77ecfb141e26b87d6cd0bf" translate="yes" xml:space="preserve">
          <source>Output a directory-format archive suitable for input into pg_restore. This will create a directory with one file for each table and blob being dumped, plus a so-called Table of Contents file describing the dumped objects in a machine-readable format that pg_restore can read. A directory format archive can be manipulated with standard Unix tools; for example, files in an uncompressed archive can be compressed with the gzip tool. This format is compressed by default and also supports parallel dumps.</source>
          <target state="translated">pg_restoreへの入力に適したディレクトリ形式のアーカイブを出力します。これにより、ダンプされるテーブルとブロブごとに1つのファイルと、pg_restoreが読める機械読み取り可能な形式でダンプされたオブジェクトを記述したいわゆる目次ファイルを含むディレクトリが作成されます。ディレクトリ形式のアーカイブは標準的なUnixツールで操作することができます。例えば、非圧縮アーカイブ内のファイルはgzipツールで圧縮することができます。この形式はデフォルトで圧縮されており、並列ダンプもサポートしています。</target>
        </trans-unit>
        <trans-unit id="9af173b4747fa54411d828576f57ede6b623e6c6" translate="yes" xml:space="preserve">
          <source>Output a plain-text SQL script file (the default).</source>
          <target state="translated">プレーンテキストのSQLスクリプトファイルを出力します(デフォルト)。</target>
        </trans-unit>
        <trans-unit id="8bdf0890d1e63cc1cfc92f91594ac95c633ba722" translate="yes" xml:space="preserve">
          <source>Output commands to clean (drop) database objects prior to outputting the commands for creating them. (Unless &lt;code&gt;--if-exists&lt;/code&gt; is also specified, restore might generate some harmless error messages, if any objects were not present in the destination database.)</source>
          <target state="translated">データベースオブジェクトを作成するためのコマンドを出力する前に、データベースオブジェクトをクリーン（ドロップ）するためのコマンドを出力します。（ &lt;code&gt;--if-exists&lt;/code&gt; も指定されていない限り、宛先データベースにオブジェクトが存在しなかった場合、restoreは無害なエラーメッセージを生成する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="48cd5d324665dcd708893b4a104e4fb4fecb1e8f" translate="yes" xml:space="preserve">
          <source>Output conversion function (binary format), or 0 if none</source>
          <target state="translated">出力変換機能(バイナリ形式)、ない場合は0</target>
        </trans-unit>
        <trans-unit id="3bc8730df1e12ab656e0ea8398920726728cdbcd" translate="yes" xml:space="preserve">
          <source>Output conversion function (text format)</source>
          <target state="translated">出力変換機能(テキスト形式</target>
        </trans-unit>
        <trans-unit id="2d850ce6c63d0f20826daa05520cced6f2083334" translate="yes" xml:space="preserve">
          <source>Output detailed information about backup blocks.</source>
          <target state="translated">バックアップブロックの詳細情報を出力します。</target>
        </trans-unit>
        <trans-unit id="babad7640e9f136cd19423d495f4b1ee0fee89a9" translate="yes" xml:space="preserve">
          <source>Output is always in the standard form.</source>
          <target state="translated">出力は常に標準形式で行われます。</target>
        </trans-unit>
        <trans-unit id="7835db447bc76230b5b0d736b2d78c671d7100a1" translate="yes" xml:space="preserve">
          <source>Outputs</source>
          <target state="translated">Outputs</target>
        </trans-unit>
        <trans-unit id="cdfe59de620bc8ec7ec39dbaf869451006fe122e" translate="yes" xml:space="preserve">
          <source>Outputs information about the current database connection.</source>
          <target state="translated">現在のデータベース接続に関する情報を出力します。</target>
        </trans-unit>
        <trans-unit id="a3ae7cd3ba4b5d3440099a3b3e44c0885cc411f2" translate="yes" xml:space="preserve">
          <source>Overlaps or is left of &amp;mdash; This might be better read as &amp;ldquo;does not extend to right of&amp;rdquo;. It is true when b &amp;lt;= d.</source>
          <target state="translated">重なり合っている、または左にある&amp;mdash;これは「右に拡張しない」と読む方がよいでしょう。b &amp;lt;= dの場合はtrueです。</target>
        </trans-unit>
        <trans-unit id="e3d201e01172e474738c7662f57e70ca764bc088" translate="yes" xml:space="preserve">
          <source>Overlaps or is right of &amp;mdash; This might be better read as &amp;ldquo;does not extend to left of&amp;rdquo;. It is true when a &amp;gt;= c.</source>
          <target state="translated">重なり合っている、または右側にある&amp;mdash;これは、「左側に拡張されない」と読む方がよいでしょう。a&amp;gt; = cの場合、それは真です。</target>
        </trans-unit>
        <trans-unit id="7af34d74e482413c9143a47da7e672969aed843a" translate="yes" xml:space="preserve">
          <source>Overlaps? (One point in common makes this true.)</source>
          <target state="translated">オーバーラップ?(共通点が一つあるだけで、これが真実になる)</target>
        </trans-unit>
        <trans-unit id="cb2f163ccc20cb7388203cf1edbc6860b44ea0f0" translate="yes" xml:space="preserve">
          <source>Overloading</source>
          <target state="translated">Overloading</target>
        </trans-unit>
        <trans-unit id="a2fd113f354ec9ec1edb291682b81f94fe430ddc" translate="yes" xml:space="preserve">
          <source>Owner of the collation</source>
          <target state="translated">照合の所有者</target>
        </trans-unit>
        <trans-unit id="b7eb54933c030e119dce1086dc82e09c41077f94" translate="yes" xml:space="preserve">
          <source>Owner of the configuration</source>
          <target state="translated">設定の所有者</target>
        </trans-unit>
        <trans-unit id="a47511340c90f2c223a36694793ee22b0651e345" translate="yes" xml:space="preserve">
          <source>Owner of the conversion</source>
          <target state="translated">変換の所有者</target>
        </trans-unit>
        <trans-unit id="9adb637b26bc7a0111112afdc905c0fa9b433b1f" translate="yes" xml:space="preserve">
          <source>Owner of the database, usually the user who created it</source>
          <target state="translated">データベースの所有者、通常はそれを作成したユーザー</target>
        </trans-unit>
        <trans-unit id="1e1395f6076a153ad4fcc55b23348741788d9a0e" translate="yes" xml:space="preserve">
          <source>Owner of the dictionary</source>
          <target state="translated">辞書の所有者</target>
        </trans-unit>
        <trans-unit id="873852f61944660a0d123bafc40c1182f58cd2a5" translate="yes" xml:space="preserve">
          <source>Owner of the event trigger</source>
          <target state="translated">イベントトリガーの所有者</target>
        </trans-unit>
        <trans-unit id="e618675166fd8eccc064277b88953a8fdc0951cf" translate="yes" xml:space="preserve">
          <source>Owner of the extended statistics</source>
          <target state="translated">拡張統計の所有者</target>
        </trans-unit>
        <trans-unit id="0e0062122acfc3428eb36e8494aa91cdda1bb823" translate="yes" xml:space="preserve">
          <source>Owner of the extension</source>
          <target state="translated">拡張子の所有者</target>
        </trans-unit>
        <trans-unit id="1b3fd58bbcd1cbede99d727eb332a616ef746459" translate="yes" xml:space="preserve">
          <source>Owner of the foreign server</source>
          <target state="translated">海外サーバーの所有者</target>
        </trans-unit>
        <trans-unit id="4abeec384f4e4e4fd2630496e361931c03792e90" translate="yes" xml:space="preserve">
          <source>Owner of the foreign-data wrapper</source>
          <target state="translated">外部データラッパーのオーナー</target>
        </trans-unit>
        <trans-unit id="045ebe36026cc33372375251adb04267dd08a6f9" translate="yes" xml:space="preserve">
          <source>Owner of the function</source>
          <target state="translated">機能の所有者</target>
        </trans-unit>
        <trans-unit id="3de3b296802701c83666e4a9e6c77ad8e092b09c" translate="yes" xml:space="preserve">
          <source>Owner of the language</source>
          <target state="translated">言語の所有者</target>
        </trans-unit>
        <trans-unit id="5f358242f17294414495cbc231ac35ed8a7ef36f" translate="yes" xml:space="preserve">
          <source>Owner of the large object</source>
          <target state="translated">大型物体の所有者</target>
        </trans-unit>
        <trans-unit id="08c133834660a3f3265245c9248f60f1979449d5" translate="yes" xml:space="preserve">
          <source>Owner of the namespace</source>
          <target state="translated">名前空間の所有者</target>
        </trans-unit>
        <trans-unit id="f3d409145414a207ad5ab1a06298cf4de3e3d79d" translate="yes" xml:space="preserve">
          <source>Owner of the operator</source>
          <target state="translated">運営者のオーナー</target>
        </trans-unit>
        <trans-unit id="4fe1d02890b80f29d14de9cf7c7d720b98ec4436" translate="yes" xml:space="preserve">
          <source>Owner of the operator class</source>
          <target state="translated">演算子クラスの所有者</target>
        </trans-unit>
        <trans-unit id="34a092b8bf19aa76f83af3f5f7f00fd4abe9f1da" translate="yes" xml:space="preserve">
          <source>Owner of the operator family</source>
          <target state="translated">オペレーターファミリーのオーナー</target>
        </trans-unit>
        <trans-unit id="530840c2bedf8afbc58ec145a817bd5855b5da2c" translate="yes" xml:space="preserve">
          <source>Owner of the publication</source>
          <target state="translated">出版物の所有者</target>
        </trans-unit>
        <trans-unit id="f104f465825a18941861fe36eee16972af35d0fd" translate="yes" xml:space="preserve">
          <source>Owner of the relation</source>
          <target state="translated">関係者の所有者</target>
        </trans-unit>
        <trans-unit id="d2d338d2c9f46fc9058acd6bf8b505d62cfd7125" translate="yes" xml:space="preserve">
          <source>Owner of the statistics object</source>
          <target state="translated">統計オブジェクトの所有者</target>
        </trans-unit>
        <trans-unit id="27aa59e6a53863d7fc75c728e631589d9ef875ce" translate="yes" xml:space="preserve">
          <source>Owner of the subscription</source>
          <target state="translated">サブスクリプションの所有者</target>
        </trans-unit>
        <trans-unit id="3ca261d2ecfb68a9f64ba043ec469131179f4f2d" translate="yes" xml:space="preserve">
          <source>Owner of the tablespace, usually the user who created it</source>
          <target state="translated">テーブルスペースの所有者、通常はそれを作成したユーザ</target>
        </trans-unit>
        <trans-unit id="451938c2f2732dd84e3e87dd05cdd4be024d9498" translate="yes" xml:space="preserve">
          <source>Owner of the type</source>
          <target state="translated">タイプの所有者</target>
        </trans-unit>
        <trans-unit id="7a88ac00bf4b0ee2c311712a067ae74712fb2321" translate="yes" xml:space="preserve">
          <source>Ownership of objects can be transferred one at a time using &lt;code&gt;ALTER&lt;/code&gt; commands, for example:</source>
          <target state="translated">オブジェクトの所有権は、 &lt;code&gt;ALTER&lt;/code&gt; コマンドを使用して一度に1つずつ転送できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="880684f9ec2b7a622ac555da2f5f06938c962c51" translate="yes" xml:space="preserve">
          <source>P''(t)</source>
          <target state="translated">P''(t)</target>
        </trans-unit>
        <trans-unit id="6c4b4caa40b248d284230f88cbcd7f13476b2cac" translate="yes" xml:space="preserve">
          <source>P(t)</source>
          <target state="translated">P(t)</target>
        </trans-unit>
        <trans-unit id="f8475eae73fea7de999190d28ead30c11cd46b3b" translate="yes" xml:space="preserve">
          <source>P-1Y-2M3DT-4H-5M-6S</source>
          <target state="translated">P-1Y-2M3DT-4H-5M-6S</target>
        </trans-unit>
        <trans-unit id="c066b74bc2c03f3472bba6e63d39e90c2e2d20c7" translate="yes" xml:space="preserve">
          <source>P0001-02-03T04:05:06</source>
          <target state="translated">P0001-02-03T04:05:06</target>
        </trans-unit>
        <trans-unit id="579e8ed8bf53a5860299c4787471ee73ec431b5e" translate="yes" xml:space="preserve">
          <source>P1Y2M</source>
          <target state="translated">P1Y2M</target>
        </trans-unit>
        <trans-unit id="bd1aaf321a587301c665f6a19e72881af023a930" translate="yes" xml:space="preserve">
          <source>P1Y2M3DT4H5M6S</source>
          <target state="translated">P1Y2M3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="9ba0b6685e5baca573f3acd95f81a092797985f3" translate="yes" xml:space="preserve">
          <source>P3DT4H5M6S</source>
          <target state="translated">P3DT4H5M6S</target>
        </trans-unit>
        <trans-unit id="1dc752ba52c4ea05107706b7e03df6ab354e39ff" translate="yes" xml:space="preserve">
          <source>PAM</source>
          <target state="translated">PAM</target>
        </trans-unit>
        <trans-unit id="388c2af7f59c6eee722356ebc329cec67a8389d7" translate="yes" xml:space="preserve">
          <source>PAM Authentication</source>
          <target state="translated">PAM 認証</target>
        </trans-unit>
        <trans-unit id="9e8eaf2f87853067037437397fcd30a4aa337b20" translate="yes" xml:space="preserve">
          <source>PAM service name.</source>
          <target state="translated">PAMサービス名。</target>
        </trans-unit>
        <trans-unit id="0bfd8f66160aa4b77dcdec5d43e4805495e07e18" translate="yes" xml:space="preserve">
          <source>PGP Public-Key encryption</source>
          <target state="translated">PGP公開鍵暗号化</target>
        </trans-unit>
        <trans-unit id="76646f05da6bf5eb4fecf712e1a4c9bffc428604" translate="yes" xml:space="preserve">
          <source>PGP Symmetric encryption</source>
          <target state="translated">PGP対称暗号化</target>
        </trans-unit>
        <trans-unit id="4e09cf6b34360609cb4cdd2c5b437e8b7854a05d" translate="yes" xml:space="preserve">
          <source>PGSQL</source>
          <target state="translated">PGSQL</target>
        </trans-unit>
        <trans-unit id="3ba27c9c3666ed10b53aa3320fe270149336d75a" translate="yes" xml:space="preserve">
          <source>PGXS</source>
          <target state="translated">PGXS</target>
        </trans-unit>
        <trans-unit id="dde57e820d65c87a0777da46aba7cd35a0c8436a" translate="yes" xml:space="preserve">
          <source>PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="feee1d9b13144a255359aea6e303897e613b068c" translate="yes" xml:space="preserve">
          <source>PITR</source>
          <target state="translated">PITR</target>
        </trans-unit>
        <trans-unit id="3238a2c23ec52b54d1a9d62034bcdec3628b7db6" translate="yes" xml:space="preserve">
          <source>PL</source>
          <target state="translated">PL</target>
        </trans-unit>
        <trans-unit id="beec5d503ed58c40992ce7fab4af575b48a55538" translate="yes" xml:space="preserve">
          <source>PL/pgSQL handles output parameters in &lt;code&gt;CALL&lt;/code&gt; commands differently; see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;Section 42.6.3&lt;/a&gt;.</source>
          <target state="translated">PL / pgSQLは &lt;code&gt;CALL&lt;/code&gt; コマンドの出力パラメーターを異なる方法で処理します。&lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-control-structures.html#PLPGSQL-STATEMENTS-CALLING-PROCEDURE&quot;&gt;セクション42.6.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="f586c4a0642bd8530bd206b6d1e6d9b7d935f68f" translate="yes" xml:space="preserve">
          <source>POSIX interprets character classes such as &lt;code&gt;\w&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;) according to the prevailing locale (which you can control by attaching a &lt;code&gt;COLLATE&lt;/code&gt; clause to the operator or function). XQuery specifies these classes by reference to Unicode character properties, so equivalent behavior is obtained only with a locale that follows the Unicode rules.</source>
          <target state="translated">POSIXは、 &lt;code&gt;\w&lt;/code&gt; （&lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;表9.20を&lt;/a&gt;参照）などの文字クラスを、一般的なロケール（演算子または関数に &lt;code&gt;COLLATE&lt;/code&gt; 句を付加することによって制御できる）に従って解釈します。XQueryはこれらのクラスをUnicode文字プロパティを参照して指定するため、同等の動作はUnicodeルールに従うロケールでのみ取得されます。</target>
        </trans-unit>
        <trans-unit id="e102feaa5742be5a0f3d3fc50f40fceae7d340a6" translate="yes" xml:space="preserve">
          <source>POSIX regular expressions provide a more powerful means for pattern matching than the &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;SIMILAR TO&lt;/code&gt; operators. Many Unix tools such as &lt;code&gt;egrep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, or &lt;code&gt;awk&lt;/code&gt; use a pattern matching language that is similar to the one described here.</source>
          <target state="translated">POSIX正規表現は、 &lt;code&gt;LIKE&lt;/code&gt; および &lt;code&gt;SIMILAR TO&lt;/code&gt; 演算子よりも強力なパターンマッチング手段を提供します。 &lt;code&gt;egrep&lt;/code&gt; 、 &lt;code&gt;sed&lt;/code&gt; 、または &lt;code&gt;awk&lt;/code&gt; などの多くのUnixツールは、ここで説明するものと同様のパターンマッチング言語を使用します。</target>
        </trans-unit>
        <trans-unit id="46e0e2f3d2a15c3b14b95e0c1c7504bef70da246" translate="yes" xml:space="preserve">
          <source>POSIX-style time zone specification</source>
          <target state="translated">ポジックススタイル時間帯指定</target>
        </trans-unit>
        <trans-unit id="66e2f96d2e144c19219f34885e8aed66af8ec26f" translate="yes" xml:space="preserve">
          <source>PREPARE</source>
          <target state="translated">PREPARE</target>
        </trans-unit>
        <trans-unit id="497f657a7bd6c59491c1afe2f14778a0325e0aeb" translate="yes" xml:space="preserve">
          <source>PREPARE &amp;mdash; prepare a statement for execution</source>
          <target state="translated">PREPARE &amp;mdash;実行のためにステートメントを準備する</target>
        </trans-unit>
        <trans-unit id="37fb488fc1130c92529c23ebb00239237637a743" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION</source>
          <target state="translated">トランザクションの準備</target>
        </trans-unit>
        <trans-unit id="a6c4ba5ff6212b5c43bdc5722e0f091244559eda" translate="yes" xml:space="preserve">
          <source>PREPARE TRANSACTION &amp;mdash; prepare the current transaction for two-phase commit</source>
          <target state="translated">PREPARE TRANSACTION &amp;mdash;現在のトランザクションを2フェーズコミット用に準備します。</target>
        </trans-unit>
        <trans-unit id="5ddcb3afaebc491f73714dc172d37266e6be3bda" translate="yes" xml:space="preserve">
          <source>Packaging and deployment scripts should be careful to create the &lt;code&gt;postgres&lt;/code&gt; user as a system user by using &lt;code&gt;useradd -r&lt;/code&gt;, &lt;code&gt;adduser --system&lt;/code&gt;, or equivalent.</source>
          <target state="translated">パッケージ化およびデプロイメントスクリプトは、 &lt;code&gt;useradd -r&lt;/code&gt; 、 &lt;code&gt;adduser --system&lt;/code&gt; 、または同等のものを使用して、システムユーザーとして &lt;code&gt;postgres&lt;/code&gt; ユーザーを作成するように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="a10c2d221e8eba42e9b331576d9daca086bdfe95" translate="yes" xml:space="preserve">
          <source>Packet containing a session key &amp;mdash; either symmetric-key or public-key encrypted.</source>
          <target state="translated">セッションキーを含むパケット&amp;mdash;対称キーまたは公開キーの暗号化。</target>
        </trans-unit>
        <trans-unit id="fe9ad910809dee7861d17df7e5f096ed938e0ab2" translate="yes" xml:space="preserve">
          <source>Packet containing data encrypted with the session key.</source>
          <target state="translated">セッションキーで暗号化されたデータを含むパケット。</target>
        </trans-unit>
        <trans-unit id="5dd9f751429eb18847bb4ae66caf8a2fda2b0c20" translate="yes" xml:space="preserve">
          <source>Page checksum</source>
          <target state="translated">ページチェックサム</target>
        </trans-unit>
        <trans-unit id="10d741089ed07914a82a77ba0b90a6a76cd492d4" translate="yes" xml:space="preserve">
          <source>Page number of this page within its large object (counting from zero)</source>
          <target state="translated">その大きなオブジェクト内のこのページのページ番号(ゼロから数えます</target>
        </trans-unit>
        <trans-unit id="fc5666da83404ee33adbe94f98f1c6ba4503d3c8" translate="yes" xml:space="preserve">
          <source>Page number targeted by the lock within the relation, or null if the target is not a relation page or tuple</source>
          <target state="translated">リレーション内でロックの対象となるページ番号、または対象がリレーションのページやタプルでない場合はnull。</target>
        </trans-unit>
        <trans-unit id="05fe9679957eb1665689044c2d47f231b7b99aa3" translate="yes" xml:space="preserve">
          <source>Page number within the relation</source>
          <target state="translated">関連するページ番号</target>
        </trans-unit>
        <trans-unit id="2b355a7b15353314735e75b8e122c5ae1fcd5a22" translate="yes" xml:space="preserve">
          <source>Page size and layout version number information</source>
          <target state="translated">ページサイズとレイアウトのバージョン番号情報</target>
        </trans-unit>
        <trans-unit id="a03c41b78d25bf18f06cd333e2c95e267c66a660" translate="yes" xml:space="preserve">
          <source>PageHeaderData</source>
          <target state="translated">PageHeaderData</target>
        </trans-unit>
        <trans-unit id="2750093ba2a279af4331fd53d0a8cee7be245d4f" translate="yes" xml:space="preserve">
          <source>PageXLogRecPtr</source>
          <target state="translated">PageXLogRecPtr</target>
        </trans-unit>
        <trans-unit id="d90de0896be6c5efa3c782fa286f1c3cdb9a7b50" translate="yes" xml:space="preserve">
          <source>Parallel Plans</source>
          <target state="translated">平行平面図</target>
        </trans-unit>
        <trans-unit id="686414fccc150dceb0e9f56ace196fdc729a14bb" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Aggregation</source>
          <target state="translated">並列計画。並列集計</target>
        </trans-unit>
        <trans-unit id="b75e7cdb23627ee4086ddf3246e9c894f0ce11d0" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Append</source>
          <target state="translated">平行計画。パラレルアペンド</target>
        </trans-unit>
        <trans-unit id="976b16b543b8304722b64b1a24c59b4c0b79488f" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Joins</source>
          <target state="translated">平行計画。平行結合</target>
        </trans-unit>
        <trans-unit id="9010e7d56024ae4a3d31f2d2290191dd0b36e537" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Plan Tips</source>
          <target state="translated">パラレルプラン 平行計画のヒント</target>
        </trans-unit>
        <trans-unit id="039109d587d0e62745986a2cf6f26a04992e1351" translate="yes" xml:space="preserve">
          <source>Parallel Plans: Parallel Scans</source>
          <target state="translated">平行平面図。平行スキャン</target>
        </trans-unit>
        <trans-unit id="cfafb44924e6a5f388ef259a64814a132f966833" translate="yes" xml:space="preserve">
          <source>Parallel Query</source>
          <target state="translated">パラレルクエリ</target>
        </trans-unit>
        <trans-unit id="82124baa3b5560bbd5720a4765dc2466961bc53a" translate="yes" xml:space="preserve">
          <source>Parallel Safety</source>
          <target state="translated">パラレルセーフティー</target>
        </trans-unit>
        <trans-unit id="0fe56d7979154496310d56ea233bf1c11643ddc4" translate="yes" xml:space="preserve">
          <source>Parallel Safety: Parallel Labeling for Functions and Aggregates</source>
          <target state="translated">パラレル安全性。関数と集約のための並列ラベリング</target>
        </trans-unit>
        <trans-unit id="5ab3e8fa2d7856e75083b2a36c41793361958622" translate="yes" xml:space="preserve">
          <source>Parallel aggregation is not supported in all situations. Each aggregate must be &lt;a href=&quot;parallel-safety&quot;&gt;safe&lt;/a&gt; for parallelism and must have a combine function. If the aggregate has a transition state of type &lt;code&gt;internal&lt;/code&gt;, it must have serialization and deserialization functions. See &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; for more details. Parallel aggregation is not supported if any aggregate function call contains &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clause and is also not supported for ordered set aggregates or when the query involves &lt;code&gt;GROUPING SETS&lt;/code&gt;. It can only be used when all joins involved in the query are also part of the parallel portion of the plan.</source>
          <target state="translated">並列集約は、すべての状況でサポートされているわけではありません。各集合体は、並列処理に対して&lt;a href=&quot;parallel-safety&quot;&gt;安全&lt;/a&gt;である必要があり、結合関数を持っている必要があります。アグリゲートに &lt;code&gt;internal&lt;/code&gt; 型の遷移状態がある場合は、シリアライズおよびデシリアライズ関数が必要です。詳細については、&lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt;を参照してください。集約関数呼び出しに &lt;code&gt;DISTINCT&lt;/code&gt; 句または &lt;code&gt;ORDER BY&lt;/code&gt; 句が含まれている場合、並列集約はサポートされていません。また、順序付き集合集約やクエリに &lt;code&gt;GROUPING SETS&lt;/code&gt; が含まれる場合もサポートされません。クエリに含まれるすべての結合がプランの並列部分の一部でもある場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="04d6d9331b5a5aaad9590228fe97b2a4cfe26295" translate="yes" xml:space="preserve">
          <source>Parallel index builds may benefit from increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt; where an equivalent serial index build will see little or no benefit. Note that &lt;code&gt;maintenance_work_mem&lt;/code&gt; may influence the number of worker processes requested, since parallel workers must have at least a &lt;code&gt;32MB&lt;/code&gt; share of the total &lt;code&gt;maintenance_work_mem&lt;/code&gt; budget. There must also be a remaining &lt;code&gt;32MB&lt;/code&gt; share for the leader process. Increasing &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workers&lt;/a&gt; may allow more workers to be used, which will reduce the time needed for index creation, so long as the index build is not already I/O bound. Of course, there should also be sufficient CPU capacity that would otherwise lie idle.</source>
          <target state="translated">パラレルインデックスビルドは、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; を増やすことでメリットが得られる可能性があり、同等のシリアルインデックスビルドではほとんどまたはまったくメリットがありません。並列ワーカーには総 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 予算の少なくとも &lt;code&gt;32MB&lt;/code&gt; のシェアが必要であるため、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; はリクエストされたワーカープロセスの数に影響を与える可能性があることに注意してください。リーダープロセスには、残りの &lt;code&gt;32MB&lt;/code&gt; の共有も必要です。&lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS-MAINTENANCE&quot;&gt;max_parallel_maintenance_workersを&lt;/a&gt;増やすと、より多くのワーカーを使用できるようになる可能性があります。これにより、インデックスのビルドがまだI / Oバインドされていない限り、インデックスの作成に必要な時間が短縮されます。もちろん、そうでなければアイドル状態になるであろう十分なCPU容量も必要です。</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="09be2449f5c7874ea156950916c870b9f0c9269d" translate="yes" xml:space="preserve">
          <source>Parameter type (&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">パラメータタイプ（ &lt;code&gt;bool&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、 &lt;code&gt;real&lt;/code&gt; 、または &lt;code&gt;string&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="044b6f8bb6500f64950a5a00b3fc891db56006e8" translate="yes" xml:space="preserve">
          <source>Parameter value assumed at server startup if the parameter is not otherwise set</source>
          <target state="translated">パラメータが設定されていない場合、サーバ起動時に想定されるパラメータ値</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="2f389ed6f97b68ab045fe7feae01a113660deba4" translate="yes" xml:space="preserve">
          <source>Parameters - &lt;code&gt;SHOW&lt;/code&gt;, &lt;code&gt;SET&lt;/code&gt;, &lt;code&gt;RESET&lt;/code&gt;</source>
          <target state="translated">パラメータ &lt;code&gt;SHOW&lt;/code&gt; 、 &lt;code&gt;SET&lt;/code&gt; 、 &lt;code&gt;RESET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d605d3acb20f72158d3fdf0384d4816df27da77" translate="yes" xml:space="preserve">
          <source>Parameters set in this way provide default values for the cluster. The settings seen by active sessions will be these values unless they are overridden. The following sections describe ways in which the administrator or user can override these defaults.</source>
          <target state="translated">このように設定されたパラメータは、クラスタのデフォルト値を提供します。アクティブなセッションに表示される設定は、上書きされない限りこれらの値になります。以下のセクションでは、管理者やユーザーがこれらのデフォルト値を上書きする方法を説明します。</target>
        </trans-unit>
        <trans-unit id="f9c46bf34fcbc732066fd8d85a736b2f71975d85" translate="yes" xml:space="preserve">
          <source>Parentheses (&lt;code&gt;()&lt;/code&gt;) have their usual meaning to group expressions and enforce precedence. In some cases parentheses are required as part of the fixed syntax of a particular SQL command.</source>
          <target state="translated">括弧（ &lt;code&gt;()&lt;/code&gt; ）には、式をグループ化して優先順位を付けるという通常の意味があります。場合によっては、特定のSQLコマンドの固定構文の一部として括弧が必要です。</target>
        </trans-unit>
        <trans-unit id="98e95b8350c1e439f335fb041362e108a0725712" translate="yes" xml:space="preserve">
          <source>Parentheses &lt;code&gt;()&lt;/code&gt; can be used to group items into a single logical item.</source>
          <target state="translated">括弧 &lt;code&gt;()&lt;/code&gt; を使用して、項目を単一の論理項目にグループ化できます。</target>
        </trans-unit>
        <trans-unit id="6bd6d9306fafc7f371b0f3c8451bd6a999eda172" translate="yes" xml:space="preserve">
          <source>Parentheses are used to resolve ambiguities. In the following example, the first statement assigns the alias &lt;code&gt;b&lt;/code&gt; to the second instance of &lt;code&gt;my_table&lt;/code&gt;, but the second statement assigns the alias to the result of the join:</source>
          <target state="translated">括弧はあいまいさを解決するために使用されます。次の例では、最初のステートメントがエイリアス &lt;code&gt;b&lt;/code&gt; を &lt;code&gt;my_table&lt;/code&gt; の2番目のインスタンスに割り当てますが、2番目のステートメントはエイリアスを結合の結果に割り当てます。</target>
        </trans-unit>
        <trans-unit id="8a18942798320d682a81a99742ced66e1f7dcd4f" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to control nesting of the &lt;code&gt;tsquery&lt;/code&gt; operators. Without parentheses, &lt;code&gt;|&lt;/code&gt; binds least tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt;, then &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt; most tightly.</source>
          <target state="translated">括弧は、 &lt;code&gt;tsquery&lt;/code&gt; 演算子のネストを制御するために使用できます。括弧なし、 &lt;code&gt;|&lt;/code&gt; バインド少なくともしっかりと、そして &lt;code&gt;&amp;amp;&lt;/code&gt; 、その後、 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 、および &lt;code&gt;!&lt;/code&gt; 最もしっかり。</target>
        </trans-unit>
        <trans-unit id="0de9a8d461cec2b96e138a5742063451fce829dd" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to enforce grouping of these operators. In the absence of parentheses, &lt;code&gt;!&lt;/code&gt; (NOT) binds most tightly, &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) next most tightly, then &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), with &lt;code&gt;|&lt;/code&gt; (OR) binding the least tightly.</source>
          <target state="translated">括弧を使用して、これらの演算子をグループ化することができます。括弧がない場合、 &lt;code&gt;!&lt;/code&gt; （NOT）が最も強く結合し、 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; （FOLLOWED BY）次に最も強く結合し、 &lt;code&gt;&amp;amp;&lt;/code&gt; （AND）、 &lt;code&gt;|&lt;/code&gt; で（OR）緊密に結合しない。</target>
        </trans-unit>
        <trans-unit id="1050a7f51685a531fe35b29d9845b1171bb5126c" translate="yes" xml:space="preserve">
          <source>Parentheses, which can be used to provide filter expressions or define the order of path evaluation.</source>
          <target state="translated">括弧は、フィルタ式を提供したり、パス評価の順序を定義するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="dde89c96be949ecdb36498952ab75fb083c95513" translate="yes" xml:space="preserve">
          <source>Parse and validate the reloptions array for an index. This is called only when a non-null reloptions array exists for the index. &lt;em&gt;&lt;code&gt;reloptions&lt;/code&gt;&lt;/em&gt; is a &lt;code&gt;text&lt;/code&gt; array containing entries of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt;. The function should construct a &lt;code&gt;bytea&lt;/code&gt; value, which will be copied into the &lt;code&gt;rd_options&lt;/code&gt; field of the index's relcache entry. The data contents of the &lt;code&gt;bytea&lt;/code&gt; value are open for the access method to define; most of the standard access methods use struct &lt;code&gt;StdRdOptions&lt;/code&gt;. When &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is true, the function should report a suitable error message if any of the options are unrecognized or have invalid values; when &lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false, invalid entries should be silently ignored. (&lt;em&gt;&lt;code&gt;validate&lt;/code&gt;&lt;/em&gt; is false when loading options already stored in &lt;code&gt;pg_catalog&lt;/code&gt;; an invalid entry could only be found if the access method has changed its rules for options, and in that case ignoring obsolete entries is appropriate.) It is OK to return NULL if default behavior is wanted.</source>
          <target state="translated">インデックスのreloptions配列を解析して検証します。これは、インデックスにnull以外のreloptions配列が存在する場合にのみ呼び出されます。&lt;em&gt; &lt;code&gt;reloptions&lt;/code&gt; &lt;/em&gt;は、 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; の形式のエントリを含む &lt;code&gt;text&lt;/code&gt; 配列です。関数は、構築すべき &lt;code&gt;bytea&lt;/code&gt; 型にコピーされます値、 &lt;code&gt;rd_options&lt;/code&gt; のインデックスのrelcacheエントリのフィールドを。 &lt;code&gt;bytea&lt;/code&gt; 値のデータ内容は、アクセス方法を定義するために開かれています。ほとんどの標準アクセスメソッドはstruct &lt;code&gt;StdRdOptions&lt;/code&gt; を使用します。ときに&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt;真であるのいずれかのオプションが認識されているか、無効な値を持っている場合、この関数は適切なエラーメッセージを報告しなければなりません。いつ&lt;em&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt;がfalseの場合、無効なエントリは無視されます。 （ &lt;code&gt;pg_catalog&lt;/code&gt; にすでに保存されているオプションをロードする場合、&lt;em&gt; &lt;code&gt;validate&lt;/code&gt; &lt;/em&gt;はfalseです。無効なエントリは、アクセス方法がオプションのルールを変更した場合にのみ見つかります。その場合、古いエントリを無視することが適切です。）デフォルトの動作の場合、NULLを返しても問題ありません。欲しいです。</target>
        </trans-unit>
        <trans-unit id="e963287c4fec77476e5d1bf8476b1e7cc102ae88" translate="yes" xml:space="preserve">
          <source>Parse system include files as well.</source>
          <target state="translated">システムインクルードファイルも解析します。</target>
        </trans-unit>
        <trans-unit id="0c8772d05d1a8b9d8d78cf0c1c4a6eb499eca0c8" translate="yes" xml:space="preserve">
          <source>Parser Stage</source>
          <target state="translated">パーサステージ</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="b58d58ace5fa0761b582d29360f9eac7d42ba9f0" translate="yes" xml:space="preserve">
          <source>Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence &lt;code&gt;\\&lt;/code&gt; (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line.</source>
          <target state="translated">引数の解析は、行の終わり、または引用符で囲まれていない別のバックスラッシュが見つかったときに停止します。引用符で囲まれていないバックスラッシュは、新しいメタコマンドの始まりと見なされます。特殊なシーケンス &lt;code&gt;\\&lt;/code&gt; （2つの円記号）は、引数の終わりを示し、SQLコマンドがあれば、それを解析し続けます。これにより、SQLコマンドとpsqlコマンドを1行に自由に混在させることができます。しかし、いずれにせよ、メタコマンドの引数は行末を超えて続けることはできません。</target>
        </trans-unit>
        <trans-unit id="07c159051320590e27d53f2ca68bc5552c059bb0" translate="yes" xml:space="preserve">
          <source>Part II. The SQL Language</source>
          <target state="translated">パート II.SQL言語</target>
        </trans-unit>
        <trans-unit id="ed99b73ba1d17331570cbb8c11cb9612833219a4" translate="yes" xml:space="preserve">
          <source>Part III. Server Administration</source>
          <target state="translated">パート III.サーバー管理</target>
        </trans-unit>
        <trans-unit id="233b8f2c1ff53528b0a2395bfd96a5533e5bf211" translate="yes" xml:space="preserve">
          <source>Part VII. Internals</source>
          <target state="translated">パートVII.内部</target>
        </trans-unit>
        <trans-unit id="1c0b1424932f39a83140c4ab14b4b9ddde6b4f52" translate="yes" xml:space="preserve">
          <source>Part VIII. Appendixes</source>
          <target state="translated">第VIII部 付録</target>
        </trans-unit>
        <trans-unit id="53657ace24d508d9d61d6689474a05a11f116ca4" translate="yes" xml:space="preserve">
          <source>Partial (including parallel) aggregation is currently not supported for ordered-set aggregates. Also, it will never be used for aggregate calls that include &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; clauses, since those semantics cannot be supported during partial aggregation.</source>
          <target state="translated">現在、部分的な（並列を含む）集計は、順序セット集計ではサポートされていません。また、 &lt;code&gt;DISTINCT&lt;/code&gt; 句や &lt;code&gt;ORDER BY&lt;/code&gt; 句を含む集計呼び出しには使用されません。これらのセマンティクスは部分集計中にサポートできないためです。</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">部分インデックス</target>
        </trans-unit>
        <trans-unit id="21eb60b5918acacccb4909c31bcd93a4758e3020" translate="yes" xml:space="preserve">
          <source>Partial Mode</source>
          <target state="translated">部分モード</target>
        </trans-unit>
        <trans-unit id="f7fabd14af4eb6ccfa3f503f4e268b2ad2693497" translate="yes" xml:space="preserve">
          <source>Partial indexes also have interesting interactions with index-only scans. Consider the partial index shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;:</source>
          <target state="translated">部分インデックスには、インデックスのみのスキャンとの興味深い相互作用もあります。&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;例11.3に&lt;/a&gt;示す部分インデックスを考えてみます。</target>
        </trans-unit>
        <trans-unit id="7a5ba09370f100d4b05c522688c9cba42e037f6a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be disabled using the &lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-ENABLE-PARTITION-PRUNING&quot;&gt;enable_partition_pruning&lt;/a&gt;設定を使用して、パーティションのプルーニングを無効にできます。</target>
        </trans-unit>
        <trans-unit id="2325b1acc0d3782c122e1bc1c9eed9984fc2f19a" translate="yes" xml:space="preserve">
          <source>Partition pruning can be performed not only during the planning of a given query, but also during its execution. This is useful as it can allow more partitions to be pruned when clauses contain expressions whose values are not known at query planning time, for example, parameters defined in a &lt;code&gt;PREPARE&lt;/code&gt; statement, using a value obtained from a subquery, or using a parameterized value on the inner side of a nested loop join. Partition pruning during execution can be performed at any of the following times:</source>
          <target state="translated">パーティションプルーニングは、特定のクエリの計画中だけでなく、その実行中にも実行できます。これは、クエリの計画時に値が不明な式（たとえば、 &lt;code&gt;PREPARE&lt;/code&gt; ステートメントで定義されたパラメーター、サブクエリから取得した値を使用したパラメーター、またはネストされたループ結合の内側。実行中のパーティションプルーニングは、次のいずれかの時間に実行できます。</target>
        </trans-unit>
        <trans-unit id="25be32546f15fa3443a67e839c875e6c98ffb53d" translate="yes" xml:space="preserve">
          <source>Partitioned tables do not support &lt;code&gt;EXCLUDE&lt;/code&gt; constraints; however, you can define these constraints on individual partitions.</source>
          <target state="translated">分割テーブルは &lt;code&gt;EXCLUDE&lt;/code&gt; 制約をサポートしていません。ただし、これらの制約を個々のパーティションに定義できます。</target>
        </trans-unit>
        <trans-unit id="cdd1ab913d96a23c99606f41fe3792bb2b1fe894" translate="yes" xml:space="preserve">
          <source>Partitioning of big collections and the proper use of GIN and GiST indexes allows the implementation of very fast searches with online update. Partitioning can be done at the database level using table inheritance, or by distributing documents over servers and collecting external search results, e.g. via &lt;a href=&quot;ddl-foreign-data&quot;&gt;Foreign Data&lt;/a&gt; access. The latter is possible because ranking functions use only local information.</source>
          <target state="translated">大きなコレクションの分割とGINおよびGiSTインデックスの適切な使用により、オンライン更新で非常に高速な検索を実装できます。パーティション分割は、テーブル継承を使用してデータベースレベルで実行できます。または、サーバーにドキュメントを配布し、外部&lt;a href=&quot;ddl-foreign-data&quot;&gt;データ&lt;/a&gt;アクセスなどを介して外部検索結果を収集することによって実行できます。ランキング関数はローカル情報のみを使用するため、後者は可能です。</target>
        </trans-unit>
        <trans-unit id="de0bffd921d00f01c704a415da77618af1ad1157" translate="yes" xml:space="preserve">
          <source>Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits:</source>
          <target state="translated">パーティショニングとは、論理的に1つの大きなテーブルをより小さな物理的な部分に分割することです。パーティショニングにはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="7c73b5aa4d6c05a53fb97d25c9d92f2517cfd521" translate="yes" xml:space="preserve">
          <source>Partitioning strategy; &lt;code&gt;h&lt;/code&gt; = hash partitioned table, &lt;code&gt;l&lt;/code&gt; = list partitioned table, &lt;code&gt;r&lt;/code&gt; = range partitioned table</source>
          <target state="translated">パーティショニング戦略; &lt;code&gt;h&lt;/code&gt; =ハッシュパーティションテーブル、 &lt;code&gt;l&lt;/code&gt; =リストパーティションテーブル、 &lt;code&gt;r&lt;/code&gt; =範囲パーティションテーブル</target>
        </trans-unit>
        <trans-unit id="ac39e0014a08ee6c92f0e5cdb5959d966b4de171" translate="yes" xml:space="preserve">
          <source>Partitions can also be foreign tables, although they have some limitations that normal tables do not; see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">パーティションは外部テーブルにすることもできますが、通常のテーブルにはないいくつかの制限があります。詳細については、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="742a14b2e0099a02fc2828373fdc246b43a7d658" translate="yes" xml:space="preserve">
          <source>Partitions cannot have columns that are not present in the parent. It is not possible to specify columns when creating partitions with &lt;code&gt;CREATE TABLE&lt;/code&gt;, nor is it possible to add columns to partitions after-the-fact using &lt;code&gt;ALTER TABLE&lt;/code&gt;. Tables may be added as a partition with &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; only if their columns exactly match the parent.</source>
          <target state="translated">パーティションには、親に存在しない列を含めることはできません。 &lt;code&gt;CREATE TABLE&lt;/code&gt; を使用してパーティションを作成するときに列を指定することはできません。また、 &lt;code&gt;ALTER TABLE&lt;/code&gt; を使用して、事後的にパーティションに列を追加することもできません。テーブルは、列が親と完全に一致する場合にのみ、 &lt;code&gt;ALTER TABLE ... ATTACH PARTITION&lt;/code&gt; を使用してパーティションとして追加できます。</target>
        </trans-unit>
        <trans-unit id="90542a9f44eb209be50c576524ab51cf75180838" translate="yes" xml:space="preserve">
          <source>Partitions may themselves be defined as partitioned tables, using what is called &lt;em&gt;sub-partitioning&lt;/em&gt;. Partitions may have their own indexes, constraints and default values, distinct from those of other partitions. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details on creating partitioned tables and partitions.</source>
          <target state="translated">パーティション自体は、&lt;em&gt;サブパーティション&lt;/em&gt;と呼ばれるものを使用して、パーティションテーブルとして定義できます。パーティションには、他のパーティションのものとは異なる独自のインデックス、制約、およびデフォルト値を設定できます。パーティションテーブルとパーティションの作成の詳細については、「&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0fe4b4dd2ad3e0c4391acf69fe76d976b85276f5" translate="yes" xml:space="preserve">
          <source>Partitions thus created are in every way normal PostgreSQL tables (or, possibly, foreign tables). It is possible to specify a tablespace and storage parameters for each partition separately.</source>
          <target state="translated">このようにして作成されたパーティションは、あらゆる意味で通常のPostgreSQLのテーブル(あるいは外部テーブル)です。各パーティションのテーブル空間とストレージパラメータを個別に指定することができます。</target>
        </trans-unit>
        <trans-unit id="88b62432a05ee62c1b6215e5aa74e2720815cc44" translate="yes" xml:space="preserve">
          <source>Parts of the GEQO module are adapted from D. Whitley's Genitor algorithm.</source>
          <target state="translated">GEQO モジュールの一部は、D.Whitley の Genitor アルゴリズムから採用されています。</target>
        </trans-unit>
        <trans-unit id="f1c5d9114d4f8eeeec0857bd19317d948e267875" translate="yes" xml:space="preserve">
          <source>Pass the option &lt;code&gt;name&lt;/code&gt; to the output plugin with, if specified, the option value &lt;code&gt;value&lt;/code&gt;. Which options exist and their effects depends on the used output plugin.</source>
          <target state="translated">指定されている場合は、オプション値 &lt;code&gt;value&lt;/code&gt; とともにオプション &lt;code&gt;name&lt;/code&gt; を出力プラグインに渡します。存在するオプションとその効果は、使用される出力プラグインによって異なります。</target>
        </trans-unit>
        <trans-unit id="adee4d3938c90062826aa15c6cd38c8f321a8960" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. See &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; for details of how encrypted passwords are stored.</source>
          <target state="translated">パスワード（暗号化されている可能性があります）; ない場合はnull。参照してください。&lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt;暗号化されたパスワードが保存されている方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="99366622edd98624e0f268beb5dfad9b43284c50" translate="yes" xml:space="preserve">
          <source>Password (possibly encrypted); null if none. The format depends on the form of encryption used.</source>
          <target state="translated">パスワード (暗号化されている可能性があります)。フォーマットは使用される暗号化の形式に依存します。</target>
        </trans-unit>
        <trans-unit id="e6148812de885ba8e1911ccd743a2dc2463667a7" translate="yes" xml:space="preserve">
          <source>Password Authentication</source>
          <target state="translated">パスワード認証</target>
        </trans-unit>
        <trans-unit id="e8e30ae74424dc989ae9149964d67afb93a52bdb" translate="yes" xml:space="preserve">
          <source>Password Encryption</source>
          <target state="translated">パスワード暗号化</target>
        </trans-unit>
        <trans-unit id="36eca0e0aafbe2102ac86aee3d25cb85966cbaa6" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication)</source>
          <target state="translated">パスワードの有効期限 (パスワード認証にのみ使用)</target>
        </trans-unit>
        <trans-unit id="de5ff361027e5b08609865471d6dc5846a389286" translate="yes" xml:space="preserve">
          <source>Password expiry time (only used for password authentication); null if no expiration</source>
          <target state="translated">パスワードの有効期限(パスワード認証にのみ使用)、有効期限がない場合はnull</target>
        </trans-unit>
        <trans-unit id="238db8fa438548c1928f9502d7d8e1e30eb6d531" translate="yes" xml:space="preserve">
          <source>Password for the user to run the service as.</source>
          <target state="translated">サービスを実行するユーザーのパスワードです。</target>
        </trans-unit>
        <trans-unit id="3fa38ad80d289fe4c73a95809bdea71d6cbf450b" translate="yes" xml:space="preserve">
          <source>Password for user to bind to the directory with to perform the search when doing search+bind authentication.</source>
          <target state="translated">検索+バインド認証を行う際に、ユーザが検索を行うディレクトリにバインドするためのパスワード。</target>
        </trans-unit>
        <trans-unit id="d33984b00815ba0da90a3eeaeb545efb634cbde4" translate="yes" xml:space="preserve">
          <source>Path construction using functions:</source>
          <target state="translated">関数を使ったパス構築</target>
        </trans-unit>
        <trans-unit id="463f854670c23f477bbd78e96423f8e31931e339" translate="yes" xml:space="preserve">
          <source>Path literals of JSON primitive types: Unicode text, numeric, true, false, or null.</source>
          <target state="translated">JSONプリミティブ型のパスリテラル。Unicodeテキスト、数値、true、false、またはnull。</target>
        </trans-unit>
        <trans-unit id="7b6339b7ad3d2b4abc5be8c19dc30583042c4165" translate="yes" xml:space="preserve">
          <source>Path of a Query</source>
          <target state="translated">クエリのパス</target>
        </trans-unit>
        <trans-unit id="266a8e23c8475feda63519f1c3d2f320f2aaac65" translate="yes" xml:space="preserve">
          <source>Path of shared library that implements language</source>
          <target state="translated">言語を実装した共有ライブラリのパス</target>
        </trans-unit>
        <trans-unit id="6a3675336ca9e8caece923ce6c69021ab35c9b34" translate="yes" xml:space="preserve">
          <source>Path variables listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;Table 8.24&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#TYPE-JSONPATH-VARIABLES&quot;&gt;表8.24に&lt;/a&gt;リストされているパス変数。</target>
        </trans-unit>
        <trans-unit id="55707d92267c5187de428b55c28d908802787d98" translate="yes" xml:space="preserve">
          <source>Paths are output using the first or second syntax, as appropriate.</source>
          <target state="translated">パスは、必要に応じて第1または第2の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="d21eb60eb90443c1e0fde7a365afe587f415ae66" translate="yes" xml:space="preserve">
          <source>Paths are represented by lists of connected points. Paths can be &lt;em&gt;open&lt;/em&gt;, where the first and last points in the list are considered not connected, or &lt;em&gt;closed&lt;/em&gt;, where the first and last points are considered connected.</source>
          <target state="translated">パスは、接続されたポイントのリストで表されます。パスとすることができる&lt;em&gt;オープン&lt;/em&gt;リストの最初と最後の点がないと考え接続、またはされている場合、&lt;em&gt;閉じた&lt;/em&gt;最初と最後の点を接続したとみなされる場合、。</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="535ab3a1c5459ace2d0b0bcb8fc022e58a4100d9" translate="yes" xml:space="preserve">
          <source>Pattern Matching</source>
          <target state="translated">パターンマッチング</target>
        </trans-unit>
        <trans-unit id="1a43195d59d6b988e5bc825ea91ee5fa2ee54455" translate="yes" xml:space="preserve">
          <source>Pattern Matching: LIKE</source>
          <target state="translated">パターンマッチング:LIKE</target>
        </trans-unit>
        <trans-unit id="577a01dd1c0e8f649068e70f9cf054970915cb36" translate="yes" xml:space="preserve">
          <source>Pattern Matching: POSIX Regular Expressions</source>
          <target state="translated">パターンマッチング:POSIX正規表現</target>
        </trans-unit>
        <trans-unit id="1aca0dbf2888e4f1bc7d10adb1a49bb94a808a60" translate="yes" xml:space="preserve">
          <source>Pattern Matching: SIMILAR TO Regular Expressions</source>
          <target state="translated">パターンマッチング:正規表現に似ている</target>
        </trans-unit>
        <trans-unit id="2cca6a6a36d34faa5c5f178fbe489846badc8fb5" translate="yes" xml:space="preserve">
          <source>Pattern matching operators (&lt;code&gt;LIKE&lt;/code&gt;, &lt;code&gt;SIMILAR TO&lt;/code&gt;, and POSIX-style regular expressions); locales affect both case insensitive matching and the classification of characters by character-class regular expressions</source>
          <target state="translated">パターンマッチング演算子（ &lt;code&gt;LIKE&lt;/code&gt; 、 &lt;code&gt;SIMILAR TO&lt;/code&gt; 、およびPOSIXスタイルの正規表現）; ロケールは、大文字と小文字を区別しないマッチングと、文字クラスの正規表現による文字の分類の両方に影響します</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="ca382c16294c214dbe3191677fc4669d70c86654" translate="yes" xml:space="preserve">
          <source>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).</source>
          <target state="translated">リカバリーを直ちに一時停止します(デフォルトではスーパーユーザーに制限されていますが、他のユーザーには機能を実行するためのEXECUTEを許可することができます)。</target>
        </trans-unit>
        <trans-unit id="12a0f150ca4476ed5b576c007ac1865d1fb8bb74" translate="yes" xml:space="preserve">
          <source>Peer Authentication</source>
          <target state="translated">ピア認証</target>
        </trans-unit>
        <trans-unit id="7140c44c7da9185cfa0b73cd8cc49f9de3bc1489" translate="yes" xml:space="preserve">
          <source>Peer authentication is only available on operating systems providing the &lt;code&gt;getpeereid()&lt;/code&gt; function, the &lt;code&gt;SO_PEERCRED&lt;/code&gt; socket parameter, or similar mechanisms. Currently that includes Linux, most flavors of BSD including macOS, and Solaris.</source>
          <target state="translated">ピア認証は、 &lt;code&gt;getpeereid()&lt;/code&gt; 関数、 &lt;code&gt;SO_PEERCRED&lt;/code&gt; ソケットパラメータ、または同様のメカニズムを提供するオペレーティングシステムでのみ使用できます。現在、これにはLinux、macOSを含むほとんどのBSD、およびSolarisが含まれます。</target>
        </trans-unit>
        <trans-unit id="9cdd79a05b9da966c26a1f6a5e99a7a9fb8d64a3" translate="yes" xml:space="preserve">
          <source>Per-Command Policies</source>
          <target state="translated">コマンドごとのポリシー</target>
        </trans-unit>
        <trans-unit id="ed1d3a75054b9592b198ba465dda151b09c333ea" translate="yes" xml:space="preserve">
          <source>Per-Statement Latencies</source>
          <target state="translated">ステートメントごとのレイテンシ</target>
        </trans-unit>
        <trans-unit id="db0ae07882c18b5649ee33de907e97a3481ed614" translate="yes" xml:space="preserve">
          <source>Per-Transaction Logging</source>
          <target state="translated">トランザクションごとのロギング</target>
        </trans-unit>
        <trans-unit id="f973c235a702ba0b4882340692bc401f9c1e7c7c" translate="yes" xml:space="preserve">
          <source>Per-index value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-CLEANUP-INDEX-SCALE-FACTOR&quot;&gt;vacuum_cleanup_index_scale_factorの&lt;/a&gt;インデックスごとの値。</target>
        </trans-unit>
        <trans-unit id="6aee541129a013df791c695dddfe4b66f3b0804a" translate="yes" xml:space="preserve">
          <source>Per-table granularity</source>
          <target state="translated">テーブルごとの粒度</target>
        </trans-unit>
        <trans-unit id="df6300430e05243fb8623c3dacf21a834f4ec9db" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR&quot;&gt;autovacuum_analyze_scale_factor&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="13bcc410c7f9ecd5027e7aabb4054809e94a5637" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-ANALYZE-THRESHOLD&quot;&gt;autovacuum_analyze_threshold&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="b4cc49570c37ddaf0ad982835227bdfeb5fb34fc" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;パラメータのテーブルごとの値。autovacuumは、システム全体の設定よりも大きいテーブル &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; パラメーターを無視することに注意してください（これはより小さく設定することしかできません）。</target>
        </trans-unit>
        <trans-unit id="adc3bbc6bde46e7a977a3d025522a0b130c2221c" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; parameters that are larger than the system-wide setting (it can only be set smaller).</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;パラメータのテーブルごとの値。autovacuumは、システム全体の設定よりも大きいテーブル &lt;code&gt;autovacuum_multixact_freeze_max_age&lt;/code&gt; パラメーターを無視することに注意してください（これは、より小さく設定することしかできません）。</target>
        </trans-unit>
        <trans-unit id="52ee90bf83a221126d345af63a697f023bf7aaf2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-DELAY&quot;&gt;autovacuum_vacuum_cost_delay&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="b8f18627239c76784b53c354db6754ba7815a1a8" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-COST-LIMIT&quot;&gt;autovacuum_vacuum_cost_limit&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="3dd4eed61fa80fd43095c3741dd5dd959fac77e2" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="4413713442ca0dbea5e7f8130793f8e4a24e0cef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="3d2800f8c07e42c6c33e28d11f8d0822c4287722" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-autovacuum#GUC-LOG-AUTOVACUUM-MIN-DURATION&quot;&gt;log_autovacuum_min_duration&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="223ad5e2d00a73119ddde400e71e2b1ba9280ccb" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-MIN-AGE&quot;&gt;vacuum_freeze_min_age&lt;/a&gt;パラメータのテーブルごとの値。autovacuumは、システム全体の&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-FREEZE-MAX-AGE&quot;&gt;autovacuum_freeze_max_age&lt;/a&gt;設定の半分よりも大きいテーブル &lt;code&gt;autovacuum_freeze_min_age&lt;/code&gt; パラメーターを無視することに注意してください。</target>
        </trans-unit>
        <trans-unit id="68a4d3118ea45821db0cebd7519f0ea146995887" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-FREEZE-TABLE-AGE&quot;&gt;vacuum_freeze_table_age&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="aed713d91e51cd08cd23d16d2810e44fceb208ef" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt; parameter. Note that autovacuum will ignore per-table &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; parameters that are larger than half the system-wide &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE&quot;&gt;vacuum_multixact_freeze_min_age&lt;/a&gt;パラメータのテーブルごとの値。autovacuumは、システム全体の&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;設定の半分よりも大きいテーブル &lt;code&gt;autovacuum_multixact_freeze_min_age&lt;/code&gt; パラメーターを無視することに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d6a639607b9fecb0af2c41612e5b2768fa56a2e" translate="yes" xml:space="preserve">
          <source>Per-table value for &lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE&quot;&gt;vacuum_multixact_freeze_table_age&lt;/a&gt;パラメータのテーブルごとの値。</target>
        </trans-unit>
        <trans-unit id="e975b3d41bbeabc6eb00c97d7e30fbafd1d2457e" translate="yes" xml:space="preserve">
          <source>Percentage of dead tuples</source>
          <target state="translated">死んだタプルの割合</target>
        </trans-unit>
        <trans-unit id="b0cd75c0030dceadd02cefb1f4f8cdfe1c43c19b" translate="yes" xml:space="preserve">
          <source>Percentage of free space</source>
          <target state="translated">空きスペースの割合</target>
        </trans-unit>
        <trans-unit id="026e26a6ed3d13c32e91d16667b4fce6169c8f91" translate="yes" xml:space="preserve">
          <source>Percentage of live tuples</source>
          <target state="translated">ライブタプルの割合</target>
        </trans-unit>
        <trans-unit id="20574a809cad3d22e4de78bb07a64ea3c84d8769" translate="yes" xml:space="preserve">
          <source>Percentage of table scanned</source>
          <target state="translated">テーブルをスキャンした割合</target>
        </trans-unit>
        <trans-unit id="cecafd6247612c74017c4324067017c519c963f3" translate="yes" xml:space="preserve">
          <source>Perform &amp;ldquo;full&amp;rdquo; vacuuming.</source>
          <target state="translated">「完全な」バキューム処理を実行します。</target>
        </trans-unit>
        <trans-unit id="feca8a5ed5223a5437966dd095f2b42b084450e7" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">SCRAM-SHA-256認証を実行して、ユーザーのパスワードを確認します。詳細は&lt;a href=&quot;auth-password&quot;&gt;項20.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cee9d96cd6bf238088136c000e640e78e06aa374" translate="yes" xml:space="preserve">
          <source>Perform SCRAM-SHA-256 or MD5 authentication to verify the user's password. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">SCRAM-SHA-256またはMD5認証を実行して、ユーザーのパスワードを確認します。詳細は&lt;a href=&quot;auth-password&quot;&gt;項20.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e17faacf8a7556f475f5c4f9f96ab42fd904d29" translate="yes" xml:space="preserve">
          <source>Perform a variable assignment, like the &lt;code&gt;\set&lt;/code&gt; meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during command line processing, so variables that reflect connection state will get overwritten later.</source>
          <target state="translated">&lt;code&gt;\set&lt;/code&gt; メタコマンドのように、変数の割り当てを実行します。コマンドラインでは、名前と値を等号で区切る必要があることに注意してください。変数を設定解除するには、等号を省略します。空の値で変数を設定するには、等号を使用しますが、値は省略します。これらの割り当てはコマンドライン処理中に行われるため、接続状態を反映する変数は後で上書きされます。</target>
        </trans-unit>
        <trans-unit id="b34d3d05facf882ae3a691abd30e8b6cd4a6e677" translate="yes" xml:space="preserve">
          <source>Perform just a selected set of the normal initialization steps. &lt;code&gt;init_steps&lt;/code&gt; specifies the initialization steps to be performed, using one character per step. Each step is invoked in the specified order. The default is &lt;code&gt;dtgvp&lt;/code&gt;. The available steps are:</source>
          <target state="translated">通常の初期化手順の選択したセットのみを実行します。 &lt;code&gt;init_steps&lt;/code&gt; は、ステップごとに1文字を使用して、実行する初期化ステップを指定します。各ステップは、指定された順序で呼び出されます。デフォルトは &lt;code&gt;dtgvp&lt;/code&gt; です。利用可能な手順は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5f6bc160364e3493898bf7d6bb17edbe09454bda" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming before running the test. This option is &lt;em&gt;necessary&lt;/em&gt; if you are running a custom test scenario that does not include the standard tables &lt;code&gt;pgbench_accounts&lt;/code&gt;, &lt;code&gt;pgbench_branches&lt;/code&gt;, &lt;code&gt;pgbench_history&lt;/code&gt;, and &lt;code&gt;pgbench_tellers&lt;/code&gt;.</source>
          <target state="translated">テストを実行する前に、掃除機をかけないでください。このオプションは、標準テーブル &lt;code&gt;pgbench_accounts&lt;/code&gt; 、 &lt;code&gt;pgbench_branches&lt;/code&gt; 、 &lt;code&gt;pgbench_history&lt;/code&gt; 、および &lt;code&gt;pgbench_tellers&lt;/code&gt; を含まないカスタムテストシナリオを実行している場合に&lt;em&gt;必要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="8a366494657843694e57b5bad59c50324f01a651" translate="yes" xml:space="preserve">
          <source>Perform no vacuuming during initialization. (This option suppresses the &lt;code&gt;v&lt;/code&gt; initialization step, even if it was specified in &lt;code&gt;-I&lt;/code&gt;.)</source>
          <target state="translated">初期化中にバキューム処理を実行しません。（このオプションは、 &lt;code&gt;-I&lt;/code&gt; で指定されていたとしても、 &lt;code&gt;v&lt;/code&gt; 初期化ステップを抑制します。）</target>
        </trans-unit>
        <trans-unit id="ae7a93c9cfd5aa5e2e72b1ed16236cb5de67de61" translate="yes" xml:space="preserve">
          <source>Perform the backup, using any convenient file-system-backup tool such as tar or cpio (not pg_dump or pg_dumpall). It is neither necessary nor desirable to stop normal operation of the database while you do this. See &lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;Section 25.3.3.3&lt;/a&gt; for things to consider during this backup.</source>
          <target state="translated">tarやcpio（pg_dumpやpg_dumpallではない）などの便利なファイルシステムバックアップツールを使用して、バックアップを実行します。これを実行している間、データベースの通常の操作を停止する必要はなく、また望ましくありません。このバックアップ中の考慮事項については、&lt;a href=&quot;continuous-archiving#BACKUP-LOWLEVEL-BASE-BACKUP-DATA&quot;&gt;セクション25.3.3.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d0828d0154023185a4f3f08252e7050a26fc998a" translate="yes" xml:space="preserve">
          <source>Perform the same operation and return the updated entries:</source>
          <target state="translated">同じ操作を行い、更新されたエントリを返します。</target>
        </trans-unit>
        <trans-unit id="ca80079033f0036f2ec138c62dcdab998ede3b1d" translate="yes" xml:space="preserve">
          <source>Perform the same operation, using a sub-select in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 句で副選択を使用して、同じ操作を実行します。</target>
        </trans-unit>
        <trans-unit id="6d4af32e4acc11996347bfaec82c71604728dd29" translate="yes" xml:space="preserve">
          <source>Performance Tips</source>
          <target state="translated">パフォーマンスのヒント</target>
        </trans-unit>
        <trans-unit id="fc8d14b954dfe439eb5ef6988b32004ef49622c0" translate="yes" xml:space="preserve">
          <source>Performs a frontend (client) copy. This is an operation that runs an SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required.</source>
          <target state="translated">フロントエンド（クライアント）コピーを実行します。これはSQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;コマンドを実行する操作ですが、サーバーが指定されたファイルを読み書きする代わりに、psqlはファイルを読み書きして、サーバーとローカルファイルシステム間でデータをルーティングします。つまり、ファイルのアクセス可能性と権限はサーバーではなくローカルユーザーのものであり、SQLスーパーユーザー権限は必要ありません。</target>
        </trans-unit>
        <trans-unit id="6c344e1248da1978bc3644d43b9d891fff2e39be" translate="yes" xml:space="preserve">
          <source>Peter Eisentraut &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ピーターアイゼントラウト &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter_e@gmx.net&quot;&gt;peter_e@gmx.net&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da078a3d051b083b829b48a189bf09b75dac6cd7" translate="yes" xml:space="preserve">
          <source>Peter Mount &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ピーターマウント &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:peter@retep.org.uk&quot;&gt;peter@retep.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac972e7b24283f21a917e63d12ab81c028b6b619" translate="yes" xml:space="preserve">
          <source>Phantom Read</source>
          <target state="translated">ファントムリード</target>
        </trans-unit>
        <trans-unit id="f6371a4980dacd0f821ddeb75bac77ae4886ba72" translate="yes" xml:space="preserve">
          <source>Phase</source>
          <target state="translated">Phase</target>
        </trans-unit>
        <trans-unit id="042205072874b99f497a9509acb6db1b05f17fb3" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database File Layout</source>
          <target state="translated">物理ストレージ。データベースファイルのレイアウト</target>
        </trans-unit>
        <trans-unit id="3fc82c3858fa9eb0fe848a4e73244b155ecf922b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Database Page Layout</source>
          <target state="translated">物理的なストレージ。データベースページのレイアウト</target>
        </trans-unit>
        <trans-unit id="bb5882e77d3988624189c0ed4e594bfe45615e1a" translate="yes" xml:space="preserve">
          <source>Physical Storage: Free Space Map</source>
          <target state="translated">物理的なストレージ。フリースペースマップ</target>
        </trans-unit>
        <trans-unit id="1aa3f80bb2e1afaf99e1bd935f3605582854ea4b" translate="yes" xml:space="preserve">
          <source>Physical Storage: Initialization Fork</source>
          <target state="translated">物理ストレージ。初期化フォーク</target>
        </trans-unit>
        <trans-unit id="365026e65b63752c65e5cd29c199d84c6b17ab3e" translate="yes" xml:space="preserve">
          <source>Physical Storage: TOAST</source>
          <target state="translated">物理ストレージ。TOAST</target>
        </trans-unit>
        <trans-unit id="2b725586447f2023155afd853eb7071d04362c03" translate="yes" xml:space="preserve">
          <source>Physical Storage: Visibility Map</source>
          <target state="translated">物理的なストレージ。可視性マップ</target>
        </trans-unit>
        <trans-unit id="27e67533896359d51a605428384ec08a0b4ccbfe" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes</source>
          <target state="translated">物理的な関係の長さ(バイト数</target>
        </trans-unit>
        <trans-unit id="53d91fab1719e32b08f04ca110073dde614b240a" translate="yes" xml:space="preserve">
          <source>Physical relation length in bytes (exact)</source>
          <target state="translated">物理的な関係の長さをバイト単位で表示します。</target>
        </trans-unit>
        <trans-unit id="2d0ec6f0ef721a8a8cb1c82f207caf7adfca229f" translate="yes" xml:space="preserve">
          <source>Place the database cluster's data directory in a memory-backed file system (i.e. RAM disk). This eliminates all database disk I/O, but limits data storage to the amount of available memory (and perhaps swap).</source>
          <target state="translated">データベースクラスタのデータディレクトリをメモリバックアップされたファイルシステム(RAMディスクなど)に配置します。これにより、データベースディスクのI/Oはすべて排除されますが、データの保存は利用可能なメモリの量に制限されます(おそらくスワップも)。</target>
        </trans-unit>
        <trans-unit id="eeb237570f0f7f892d4ed491876f26dd479a782a" translate="yes" xml:space="preserve">
          <source>Placing &lt;code&gt;ORDER BY&lt;/code&gt; within the aggregate's regular argument list, as described so far, is used when ordering the input rows for general-purpose and statistical aggregates, for which ordering is optional. There is a subclass of aggregate functions called &lt;em&gt;ordered-set aggregates&lt;/em&gt; for which an &lt;code&gt;order_by_clause&lt;/code&gt; is &lt;em&gt;required&lt;/em&gt;, usually because the aggregate's computation is only sensible in terms of a specific ordering of its input rows. Typical examples of ordered-set aggregates include rank and percentile calculations. For an ordered-set aggregate, the &lt;code&gt;order_by_clause&lt;/code&gt; is written inside &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt;, as shown in the final syntax alternative above. The expressions in the &lt;code&gt;order_by_clause&lt;/code&gt; are evaluated once per input row just like regular aggregate arguments, sorted as per the &lt;code&gt;order_by_clause&lt;/code&gt;'s requirements, and fed to the aggregate function as input arguments. (This is unlike the case for a non-&lt;code&gt;WITHIN GROUP&lt;/code&gt;&lt;code&gt;order_by_clause&lt;/code&gt;, which is not treated as argument(s) to the aggregate function.) The argument expressions preceding &lt;code&gt;WITHIN GROUP&lt;/code&gt;, if any, are called &lt;em&gt;direct arguments&lt;/em&gt; to distinguish them from the &lt;em&gt;aggregated arguments&lt;/em&gt; listed in the &lt;code&gt;order_by_clause&lt;/code&gt;. Unlike regular aggregate arguments, direct arguments are evaluated only once per aggregate call, not once per input row. This means that they can contain variables only if those variables are grouped by &lt;code&gt;GROUP BY&lt;/code&gt;; this restriction is the same as if the direct arguments were not inside an aggregate expression at all. Direct arguments are typically used for things like percentile fractions, which only make sense as a single value per aggregation calculation. The direct argument list can be empty; in this case, write just &lt;code&gt;()&lt;/code&gt; not &lt;code&gt;(*)&lt;/code&gt;. (PostgreSQL will actually accept either spelling, but only the first way conforms to the SQL standard.)</source>
          <target state="translated">これまでに説明したように、 &lt;code&gt;ORDER BY&lt;/code&gt; を集計の通常の引数リスト内に配置することは、汎用および統計集計の入力行を並べ替えるときに使用されます。呼ばれる集約関数のサブクラスがあり&lt;em&gt;命じセット集計&lt;/em&gt;いる &lt;code&gt;order_by_clause&lt;/code&gt; にはされて&lt;em&gt;必要な&lt;/em&gt;集計の計算は、入力行の特定の順序の面で唯一賢明であるため、通常は、。順序付き集合の典型的な例には、ランクとパーセンタイルの計算が含まれます。順序付き集合の場合、上記の最後の代替構文に示すように、 &lt;code&gt;order_by_clause&lt;/code&gt; は &lt;code&gt;WITHIN GROUP (...)&lt;/code&gt; 内に記述されます。の表現 &lt;code&gt;order_by_clause&lt;/code&gt; 通常の集計引数と同様に、order_by_clauseは入力行ごとに1回評価され、 &lt;code&gt;order_by_clause&lt;/code&gt; の要件に従って並べ替えられ、入力引数として集計関数に渡されます。 （これは、集合関数への引数として扱われない非 &lt;code&gt;WITHIN GROUP&lt;/code&gt; &lt;code&gt;order_by_clause&lt;/code&gt; の場合とは異なります。） &lt;code&gt;WITHIN GROUP&lt;/code&gt; の前にある引数式は、&lt;em&gt;集約引数&lt;/em&gt;と区別するために、&lt;em&gt;直接引数&lt;/em&gt;と呼ばれ&lt;em&gt;ます。&lt;/em&gt; &lt;code&gt;order_by_clause&lt;/code&gt; にリストされています。通常の集計引数とは異なり、直接引数は集計呼び出しごとに1回だけ評価され、入力行ごとに1回は評価されません。つまり、これらの変数が &lt;code&gt;GROUP BY&lt;/code&gt; によってグループ化されている場合にのみ、変数を含めることができます。この制限は、直接の引数が集約式の内部にまったくない場合と同じです。直接引数は通常、パーセンタイル分数などに使用されます。これは、集計計算ごとに1つの値としてのみ意味があります。直接引数リストは空にすることができます。この場合、 &lt;code&gt;(*)&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; なく（）だけを記述します。 （PostgreSQLは実際にはどちらのスペルも受け入れますが、最初の方法のみがSQL標準に準拠します。）</target>
        </trans-unit>
        <trans-unit id="050a736fd59911f8226167a2c6f31c24c2830d29" translate="yes" xml:space="preserve">
          <source>Placing the function in a &lt;code&gt;LATERAL&lt;/code&gt;&lt;code&gt;FROM&lt;/code&gt; item keeps it from being invoked more than once per row. &lt;code&gt;m.*&lt;/code&gt; is still expanded into &lt;code&gt;m.a, m.b, m.c&lt;/code&gt;, but now those variables are just references to the output of the &lt;code&gt;FROM&lt;/code&gt; item. (The &lt;code&gt;LATERAL&lt;/code&gt; keyword is optional here, but we show it to clarify that the function is getting &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;some_table&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; &lt;code&gt;FROM&lt;/code&gt; アイテムに関数を配置すると、行ごとに複数回呼び出されなくなります。 &lt;code&gt;m.*&lt;/code&gt; はまだ &lt;code&gt;m.a, m.b, m.c&lt;/code&gt; に展開されていますが、これらの変数は &lt;code&gt;FROM&lt;/code&gt; アイテムの出力への参照にすぎません。 （ここでは &lt;code&gt;LATERAL&lt;/code&gt; キーワードはオプションですが、関数が &lt;code&gt;some_table&lt;/code&gt; から &lt;code&gt;x&lt;/code&gt; を取得していることを明確にするために示しています。）</target>
        </trans-unit>
        <trans-unit id="b4a1219ff91be25a0770f7df590b928d12b8a2c5" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;) simply reclaims space and makes it available for re-use. This form of the command can operate in parallel with normal reading and writing of the table, as an exclusive lock is not obtained. However, extra space is not returned to the operating system (in most cases); it's just kept available for re-use within the same table. &lt;code&gt;VACUUM FULL&lt;/code&gt; rewrites the entire contents of the table into a new disk file with no extra space, allowing unused space to be returned to the operating system. This form is much slower and requires an exclusive lock on each table while it is being processed.</source>
          <target state="translated">平野 &lt;code&gt;VACUUM&lt;/code&gt; （なし &lt;code&gt;FULL&lt;/code&gt; は）単純にスペースを再利用し、再使用できるようになります。この形式のコマンドは、排他ロックが取得されないため、テーブルの通常の読み取りおよび書き込みと並行して動作できます。ただし、余分なスペースはオペレーティングシステムに返されません（ほとんどの場合）。同じテーブル内で再利用できるように保持されているだけです。 &lt;code&gt;VACUUM FULL&lt;/code&gt; は、テーブルの内容全体を余分なスペースのない新しいディスクファイルに再書き込みし、未使用のスペースをオペレーティングシステムに返すことができます。この形式ははるかに遅く、処理中は各テーブルに排他ロックが必要です。</target>
        </trans-unit>
        <trans-unit id="8499132893d83a3f2ae11d9668e227a0e6596484" translate="yes" xml:space="preserve">
          <source>Plain &lt;code&gt;VACUUM&lt;/code&gt; may not be satisfactory when a table contains large numbers of dead row versions as a result of massive update or delete activity. If you have such a table and you need to reclaim the excess disk space it occupies, you will need to use &lt;code&gt;VACUUM FULL&lt;/code&gt;, or alternatively &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the table-rewriting variants of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. These commands rewrite an entire new copy of the table and build new indexes for it. All these options require exclusive lock. Note that they also temporarily use extra disk space approximately equal to the size of the table, since the old copies of the table and indexes can't be released until the new ones are complete.</source>
          <target state="translated">大量の更新または削除アクティビティの結果としてテーブルに多数の無効な行バージョンが含まれている場合、プレーンな &lt;code&gt;VACUUM&lt;/code&gt; では不十分な場合があります。そのようなテーブルがあり、そのテーブルが占有する過剰なディスク領域を再利用する必要がある場合は、 &lt;code&gt;VACUUM FULL&lt;/code&gt; 、または&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;または&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;テーブル書き換えバリアントのいずれかを使用する必要があります。これらのコマンドは、テーブルの新しいコピー全体を書き換え、新しいインデックスを作成します。これらすべてのオプションには、排他ロックが必要です。また、テーブルとインデックスの古いコピーは新しいものが完了するまで解放できないため、テーブルのサイズとほぼ同じ追加のディスク領域を一時的に使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a9dba597737e71648392c996cea122250f0bead7" translate="yes" xml:space="preserve">
          <source>Plan nodes to which an &lt;code&gt;InitPlan&lt;/code&gt; is attached.</source>
          <target state="translated">&lt;code&gt;InitPlan&lt;/code&gt; が接続されているノードを計画します。</target>
        </trans-unit>
        <trans-unit id="2bae7f24c9eebd1039795f1be6ffdf3da89d373b" translate="yes" xml:space="preserve">
          <source>Plan nodes which reference a correlated &lt;code&gt;SubPlan&lt;/code&gt;.</source>
          <target state="translated">相関 &lt;code&gt;SubPlan&lt;/code&gt; プランを参照するプランノード。</target>
        </trans-unit>
        <trans-unit id="fd8eca8ef866c5503502580ce3a00558f59a9928" translate="yes" xml:space="preserve">
          <source>Plannable queries (that is, &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;) are combined into a single &lt;code&gt;pg_stat_statements&lt;/code&gt; entry whenever they have identical query structures according to an internal hash calculation. Typically, two queries will be considered the same for this purpose if they are semantically equivalent except for the values of literal constants appearing in the query. Utility commands (that is, all other commands) are compared strictly on the basis of their textual query strings, however.</source>
          <target state="translated">計画可能なクエリ（つまり、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; ）は、内部ハッシュ計算に従って同一のクエリ構造を持っている場合は常に、単一の &lt;code&gt;pg_stat_statements&lt;/code&gt; エントリに結合されます。通常、2つのクエリは、クエリに現れるリテラル定数の値を除いて、意味的に同等である場合、この目的では同じと見なされます。ただし、ユーティリティコマンド（つまり、他のすべてのコマンド）は、テキストクエリ文字列に基づいて厳密に比較されます。</target>
        </trans-unit>
        <trans-unit id="1c065dbb4470e9d21b7a921d317fd42a4a204fc8" translate="yes" xml:space="preserve">
          <source>Planner Statistics and Security</source>
          <target state="translated">プランナーの統計とセキュリティ</target>
        </trans-unit>
        <trans-unit id="20ef8925a22326d996284c55f97493dce8cb35b8" translate="yes" xml:space="preserve">
          <source>Planner/Optimizer</source>
          <target state="translated">Planner/Optimizer</target>
        </trans-unit>
        <trans-unit id="88b7699abe5df4b9c91f2b6e5ea1aabcde7ea7fc" translate="yes" xml:space="preserve">
          <source>Plans and resources - &lt;code&gt;PREPARE&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DEALLOCATE&lt;/code&gt;, &lt;code&gt;DISCARD&lt;/code&gt;</source>
          <target state="translated">計画とリソース- &lt;code&gt;PREPARE&lt;/code&gt; 、 &lt;code&gt;EXECUTE&lt;/code&gt; 、 &lt;code&gt;DEALLOCATE&lt;/code&gt; 、 &lt;code&gt;DISCARD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60e74c5b37f496e9f5820d20828439504e47ddb6" translate="yes" xml:space="preserve">
          <source>Please enter all the commands shown above so you have some data to work with in the following sections.</source>
          <target state="translated">上記のコマンドをすべて入力して、次のセクションで作業するデータがあるようにしてください。</target>
        </trans-unit>
        <trans-unit id="a932052bd8c1c2c9d99c8557aa55ac6cb1e71319" translate="yes" xml:space="preserve">
          <source>Please note that you may see some or all of the following notifications depending on the particular versions you have of libselinux and selinux-policy:</source>
          <target state="translated">libselinux と selinux-policy の特定のバージョンによっては、以下の通知の一部または全部が表示されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0db2f66cabcb72c7d5c5552d7794e37b6384e5d6" translate="yes" xml:space="preserve">
          <source>Please note the following points when using the generic WAL record facility:</source>
          <target state="translated">一般的なWALレコード施設をご利用の際は、以下の点にご注意ください。</target>
        </trans-unit>
        <trans-unit id="86f9d988d7b8b2829ff9e18a117a22f3c6c12cda" translate="yes" xml:space="preserve">
          <source>Pluggable Authentication Modules</source>
          <target state="translated">プラグ可能な認証モジュール</target>
        </trans-unit>
        <trans-unit id="3dfb3c336b3693041700e2e10c00427b27b0180f" translate="yes" xml:space="preserve">
          <source>Plugins and extensions - &lt;code&gt;LOAD&lt;/code&gt;</source>
          <target state="translated">プラグインと拡張 &lt;code&gt;LOAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efefb1be830f67be53a399ad23055160dfbce160" translate="yes" xml:space="preserve">
          <source>Plus operator that iterates over the SQL/JSON sequence</source>
          <target state="translated">SQL/JSONシーケンスを反復処理するプラス演算子</target>
        </trans-unit>
        <trans-unit id="65afde293357ae741287178244c36bbcce3cc736" translate="yes" xml:space="preserve">
          <source>Point on a plane</source>
          <target state="translated">平面上の点</target>
        </trans-unit>
        <trans-unit id="609adbe0655f07f14c79208d551f8d9718fabd23" translate="yes" xml:space="preserve">
          <source>Point or box of intersection</source>
          <target state="translated">交点の点または箱</target>
        </trans-unit>
        <trans-unit id="09812b4d0aeaa487df4bde731b3996675a249aaa" translate="yes" xml:space="preserve">
          <source>Points are output using the first syntax.</source>
          <target state="translated">ポイントは最初の構文で出力されます。</target>
        </trans-unit>
        <trans-unit id="44c9844a5c8235f295a2612b30b79553235db5c0" translate="yes" xml:space="preserve">
          <source>Points are the fundamental two-dimensional building block for geometric types. Values of type &lt;code&gt;point&lt;/code&gt; are specified using either of the following syntaxes:</source>
          <target state="translated">ポイントは、ジオメトリタイプの基本的な2次元のビルディングブロックです。タイプ &lt;code&gt;point&lt;/code&gt; 値は、次の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="7f6158e808f6832883a61fff6f7473e7ffa8d937" translate="yes" xml:space="preserve">
          <source>Points to note:</source>
          <target state="translated">注意すべき点</target>
        </trans-unit>
        <trans-unit id="da968837807c4a4627a6c38281eebcac2e2aa0b7" translate="yes" xml:space="preserve">
          <source>Policies are created using the &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt; command, altered using the &lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt; command, and dropped using the &lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt; command. To enable and disable row security for a given table, use the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command.</source>
          <target state="translated">ポリシーは、&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;コマンドを使用して作成され、&lt;a href=&quot;sql-alterpolicy&quot;&gt;ALTER POLICY&lt;/a&gt;コマンドを使用して変更され、&lt;a href=&quot;sql-droppolicy&quot;&gt;DROP POLICY&lt;/a&gt;コマンドを使用してドロップされます。特定のテーブルの行セキュリティを有効または無効にするには、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="1624c281a60434d712e179fdb6ff898796130b43" translate="yes" xml:space="preserve">
          <source>Policies can be applied for specific commands or for specific roles. The default for newly created policies is that they apply for all commands and roles, unless otherwise specified. Multiple policies may apply to a single command; see below for more details. &lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;Table 256&lt;/a&gt; summarizes how the different types of policy apply to specific commands.</source>
          <target state="translated">ポリシーは、特定のコマンドまたは特定の役割に適用できます。新しく作成されたポリシーのデフォルトは、特に指定されていない限り、すべてのコマンドとロールに適用されます。1つのコマンドに複数のポリシーを適用できます。詳細については、以下を参照してください。&lt;a href=&quot;sql-createpolicy#SQL-CREATEPOLICY-SUMMARY&quot;&gt;表256&lt;/a&gt;は、さまざまなタイプのポリシーが特定のコマンドにどのように適用されるかを要約しています。</target>
        </trans-unit>
        <trans-unit id="9218496f73981d3e04361890ce5e81c103eeff2b" translate="yes" xml:space="preserve">
          <source>Policies stored in &lt;code&gt;pg_policy&lt;/code&gt; are applied only when &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relrowsecurity&lt;/code&gt; is set for their table.</source>
          <target state="translated">&lt;code&gt;pg_policy&lt;/code&gt; に格納されたポリシーは、 &lt;code&gt;pg_class&lt;/code&gt; の場合にのみ適用されます。 &lt;code&gt;relrowsecurity&lt;/code&gt; がテーブルに設定されています。</target>
        </trans-unit>
        <trans-unit id="64fe90225d9ffc87de024a67667003d6e6192eb8" translate="yes" xml:space="preserve">
          <source>Policy names are per-table. Therefore, one policy name can be used for many different tables and have a definition for each table which is appropriate to that table.</source>
          <target state="translated">ポリシー名はテーブルごとに定義されています。したがって、1つのポリシー名を多くの異なるテーブルに使用することができ、そのテーブルに適した各テーブルの定義を持つことができます。</target>
        </trans-unit>
        <trans-unit id="a028a9272b54da3da6db504ed096a2910de4d948" translate="yes" xml:space="preserve">
          <source>Polygon (similar to closed path)</source>
          <target state="translated">多角形(閉じたパスに似ている</target>
        </trans-unit>
        <trans-unit id="358c4e4d5755c21f01067425fdfdaf1bfdcb7099" translate="yes" xml:space="preserve">
          <source>Polygons are output using the first syntax.</source>
          <target state="translated">ポリゴンは、最初の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="7fb66bc5a7ec5dcfcc725c19a5a1e5c03cd32e7e" translate="yes" xml:space="preserve">
          <source>Polygons are represented by lists of points (the vertexes of the polygon). Polygons are very similar to closed paths, but are stored differently and have their own set of support routines.</source>
          <target state="translated">ポリゴンは点(ポリゴンの頂点)のリストで表されます。ポリゴンは閉じたパスに非常に似ていますが、保存方法が異なり、独自のサポートルーチンを持っています。</target>
        </trans-unit>
        <trans-unit id="274e42ad6449f3252ec5038abe402083876dea88" translate="yes" xml:space="preserve">
          <source>Populating a Database</source>
          <target state="translated">データベースの作成</target>
        </trans-unit>
        <trans-unit id="7fbc9b4eb9f4bb4e95de4acb2d6d7f0b43e20913" translate="yes" xml:space="preserve">
          <source>Population standard deviation of time spent in the statement, in milliseconds</source>
          <target state="translated">文中に費やした時間の母集団標準偏差(ミリ秒単位</target>
        </trans-unit>
        <trans-unit id="384cecb2d7b1b2012eaea272977d2cf0c551884e" translate="yes" xml:space="preserve">
          <source>Port number of the PostgreSQL instance this WAL receiver is connected to.</source>
          <target state="translated">WAL 受信機が接続する PostgreSQL インスタンスのポート番号。</target>
        </trans-unit>
        <trans-unit id="008e62801aaa400319958b2b2b06cc2182c60162" translate="yes" xml:space="preserve">
          <source>Port number on LDAP server to connect to. If no port is specified, the LDAP library's default port setting will be used.</source>
          <target state="translated">接続先の LDAP サーバーのポート番号。ポートが指定されていない場合は、LDAPライブラリのデフォルトのポート設定が使用されます。</target>
        </trans-unit>
        <trans-unit id="c75704d05c6e22d0fdf67c00eb401f9b1c6b139b" translate="yes" xml:space="preserve">
          <source>Portable Operating System Interface</source>
          <target state="translated">ポータブルオペレーティングシステムインタフェース</target>
        </trans-unit>
        <trans-unit id="e7c56d55f410fd275aaccf8ba063a18761b3e5c0" translate="yes" xml:space="preserve">
          <source>Position values in &lt;code&gt;tsvector&lt;/code&gt; must be greater than 0 and no more than 16,383</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; の位置の値は0より大きく、16,383以下である必要があります</target>
        </trans-unit>
        <trans-unit id="bbb340fe5bf8594afaa03b969bb8e8f82eef71df" translate="yes" xml:space="preserve">
          <source>Positional notation is the traditional mechanism for passing arguments to functions in PostgreSQL. An example is:</source>
          <target state="translated">位置記法は、PostgreSQLの関数に引数を渡すための伝統的な仕組みです。例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="dd8bd0b5027f70c1cefa9f905da80fd30083ef2a" translate="yes" xml:space="preserve">
          <source>Possible</source>
          <target state="translated">Possible</target>
        </trans-unit>
        <trans-unit id="6db8a7e83593975ece623b8f9b3fe94d53e8a1b1" translate="yes" xml:space="preserve">
          <source>Possible limitations of the &lt;code&gt;query&lt;/code&gt; clause are documented under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; 句の考えられる制限は、&lt;a href=&quot;sql-select&quot;&gt;SELECTに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e46bf54baa1011e163ced28f70574e61876f70d3" translate="yes" xml:space="preserve">
          <source>Possible variants of the above queries are:</source>
          <target state="translated">上記のクエリの可能なバリエーションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="92818ef9b703eafdfca9b984fb83c6ed173e8358" translate="yes" xml:space="preserve">
          <source>Possibly, your site administrator has already created a database for your use. In that case you can omit this step and skip ahead to the next section.</source>
          <target state="translated">おそらく、あなたのサイト管理者があなたの使用のためにすでにデータベースを作成しているのでしょう。その場合、このステップを省略して次のセクションに進んでください。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="0c5bb15ce4cd87c929efa330565ff6d28cd04381" translate="yes" xml:space="preserve">
          <source>PostgreSQL Client Applications</source>
          <target state="translated">PostgreSQLクライアントアプリケーション</target>
        </trans-unit>
        <trans-unit id="c24f12993bca195ad8365e3a9f46bba7d548c46e" translate="yes" xml:space="preserve">
          <source>PostgreSQL Error Codes</source>
          <target state="translated">PostgreSQLエラーコード</target>
        </trans-unit>
        <trans-unit id="179caa7e2f2ae5bcccafd6de1029390b28df93ea" translate="yes" xml:space="preserve">
          <source>PostgreSQL Extension System</source>
          <target state="translated">PostgreSQL拡張システム</target>
        </trans-unit>
        <trans-unit id="bde4caa4f627d1ed1cd6258230a52653ae368364" translate="yes" xml:space="preserve">
          <source>PostgreSQL Limits</source>
          <target state="translated">PostgreSQLの限界</target>
        </trans-unit>
        <trans-unit id="831c73ba52cb3a865742b364e490e3d33fd67271" translate="yes" xml:space="preserve">
          <source>PostgreSQL Log Sequence Number</source>
          <target state="translated">PostgreSQLログシーケンス番号</target>
        </trans-unit>
        <trans-unit id="d6e7156cbc0b3b93da375064bee0966e60cdb8ac" translate="yes" xml:space="preserve">
          <source>PostgreSQL Rule System</source>
          <target state="translated">PostgreSQLルールシステム</target>
        </trans-unit>
        <trans-unit id="452e61af45168fd75ac971dbf646f72b427da732" translate="yes" xml:space="preserve">
          <source>PostgreSQL Server Applications</source>
          <target state="translated">PostgreSQLサーバアプリケーション</target>
        </trans-unit>
        <trans-unit id="67fae22a18c43950aa1922954f1d91e59073538b" translate="yes" xml:space="preserve">
          <source>PostgreSQL User Account</source>
          <target state="translated">PostgreSQLユーザアカウント</target>
        </trans-unit>
        <trans-unit id="c5ec2d5a5859a9a3bd680edc1c2f24695d8620d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a &lt;code&gt;BEGIN&lt;/code&gt; command, then each individual statement has an implicit &lt;code&gt;BEGIN&lt;/code&gt; and (if successful) &lt;code&gt;COMMIT&lt;/code&gt; wrapped around it. A group of statements surrounded by &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; is sometimes called a &lt;em&gt;transaction block&lt;/em&gt;.</source>
          <target state="translated">PostgreSQLは実際にはすべてのSQLステートメントをトランザクション内で実行されているものとして扱います。 &lt;code&gt;BEGIN&lt;/code&gt; コマンドを発行しない場合、個々のステートメントには暗黙の &lt;code&gt;BEGIN&lt;/code&gt; および（成功した場合は） &lt;code&gt;COMMIT&lt;/code&gt; が含まれます。 &lt;code&gt;BEGIN&lt;/code&gt; と &lt;code&gt;COMMIT&lt;/code&gt; で囲まれたステートメントのグループは、&lt;em&gt;トランザクションブロック&lt;/em&gt;と呼ばれることもあり&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a08fed9d9b5168502be31cd2bf857824ed3fb1b6" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; to be used as &lt;code&gt;WITH&lt;/code&gt; queries. This is not found in the SQL standard.</source>
          <target state="translated">PostgreSQLでは、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; を &lt;code&gt;WITH&lt;/code&gt; クエリとして使用できます。これは、SQL標準にはありません。</target>
        </trans-unit>
        <trans-unit id="4ae0ed23837a44ee80fff5d2d48a225d0adbd095" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a function call to be written directly as a member of the &lt;code&gt;FROM&lt;/code&gt; list. In the SQL standard it would be necessary to wrap such a function call in a sub-&lt;code&gt;SELECT&lt;/code&gt;; that is, the syntax &lt;code&gt;FROM func(...) alias&lt;/code&gt; is approximately equivalent to &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt;. Note that &lt;code&gt;LATERAL&lt;/code&gt; is considered to be implicit; this is because the standard requires &lt;code&gt;LATERAL&lt;/code&gt; semantics for an &lt;code&gt;UNNEST()&lt;/code&gt; item in &lt;code&gt;FROM&lt;/code&gt;. PostgreSQL treats &lt;code&gt;UNNEST()&lt;/code&gt; the same as other set-returning functions.</source>
          <target state="translated">PostgreSQLでは、関数呼び出しを &lt;code&gt;FROM&lt;/code&gt; リストのメンバーとして直接書き込むことができます。 SQL標準では、このような関数呼び出しをサブ &lt;code&gt;SELECT&lt;/code&gt; でラップする必要があります。つまり、構文 &lt;code&gt;FROM func(...) alias&lt;/code&gt; は、 &lt;code&gt;FROM LATERAL (SELECT func(...)) alias&lt;/code&gt; とほぼ同等です。 &lt;code&gt;LATERAL&lt;/code&gt; は暗黙的であると見なされることに注意してください。これは、標準では &lt;code&gt;FROM&lt;/code&gt; の &lt;code&gt;UNNEST()&lt;/code&gt; 項目に &lt;code&gt;LATERAL&lt;/code&gt; セマンティクスが必要であるためです。 PostgreSQLは、 &lt;code&gt;UNNEST()&lt;/code&gt; を他のセットを返す関数と同じように扱います。</target>
        </trans-unit>
        <trans-unit id="1fec2c228fe0347b7815e3014f29d97d5a87acca" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table of no columns to be created (for example, &lt;code&gt;CREATE TABLE foo();&lt;/code&gt;). This is an extension from the SQL standard, which does not allow zero-column tables. Zero-column tables are not in themselves very useful, but disallowing them creates odd special cases for &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt;, so it seems cleaner to ignore this spec restriction.</source>
          <target state="translated">PostgreSQLでは、列のないテーブルを作成できます（たとえば、 &lt;code&gt;CREATE TABLE foo();&lt;/code&gt; ）。これは、SQL標準からの拡張であり、ゼロ列テーブルを許可していません。ゼロ列のテーブル自体はあまり有用ではありませんが、それらを許可しないと、 &lt;code&gt;ALTER TABLE DROP COLUMN&lt;/code&gt; の奇妙な特殊なケースが作成されるため、この仕様の制限を無視する方がきれいに見えます。</target>
        </trans-unit>
        <trans-unit id="5a502e4f8d9c2660f0a8eba2540286883c5cd8c9" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a table to have more than one identity column. The standard specifies that a table can have at most one identity column. This is relaxed mainly to give more flexibility for doing schema changes or migrations. Note that the &lt;code&gt;INSERT&lt;/code&gt; command supports only one override clause that applies to the entire statement, so having multiple identity columns with different behaviors is not well supported.</source>
          <target state="translated">PostgreSQLでは、テーブルに複数のID列を含めることができます。この規格では、テーブルに含めることができるID列は1つだけであると規定されています。これは主に、スキーマの変更または移行を行うための柔軟性を高めるために緩和されています。 &lt;code&gt;INSERT&lt;/code&gt; コマンドはステートメント全体に適用されるオーバーライド句を1つだけサポートするため、動作が異なる複数のID列を持つことはサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b3ae4855b2a3e72640693b7d20d3ad5d9fb47042" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows a trailing &lt;code&gt;*&lt;/code&gt; to be written to explicitly specify the non-&lt;code&gt;ONLY&lt;/code&gt; behavior of including child tables. The standard does not allow this.</source>
          <target state="translated">PostgreSQLでは、後続の &lt;code&gt;*&lt;/code&gt; を記述して、子テーブルを含めるという非 &lt;code&gt;ONLY&lt;/code&gt; 動作のみを明示的に指定できます。標準ではこれを許可していません。</target>
        </trans-unit>
        <trans-unit id="0222c8fe2334be83692d30a209d5aa08ec24134f" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows an object owner to revoke their own ordinary privileges: for example, a table owner can make the table read-only to themselves by revoking their own &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt; privileges. This is not possible according to the SQL standard. The reason is that PostgreSQL treats the owner's privileges as having been granted by the owner to themselves; therefore they can revoke them too. In the SQL standard, the owner's privileges are granted by an assumed entity &amp;ldquo;_SYSTEM&amp;rdquo;. Not being &amp;ldquo;_SYSTEM&amp;rdquo;, the owner cannot revoke these rights.</source>
          <target state="translated">PostgreSQLでは、オブジェクトの所有者が自分の通常の権限を取り消すことができます。たとえば、テーブルの所有者は、自分の &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、および &lt;code&gt;TRUNCATE&lt;/code&gt; 権限を取り消すことにより、自分自身に対してテーブルを読み取り専用にすることができます。これは、SQL標準では不可能です。その理由は、PostgreSQLが所有者の権限を所有者から自分に付与されたものとして扱うためです。したがって、それらを取り消すこともできます。 SQL標準では、所有者の権限は想定エンティティ「_SYSTEM」によって付与されます。 「_SYSTEM」ではないため、所有者はこれらの権利を取り消すことはできません。</target>
        </trans-unit>
        <trans-unit id="d75f3d8cbebcea3de67f82faaf69d14b5b967380" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows columns of a table to be defined as variable-length multidimensional arrays. Arrays of any built-in or user-defined base type, enum type, composite type, range type, or domain can be created.</source>
          <target state="translated">PostgreSQLでは、テーブルの列を可変長の多次元配列として定義することができます。任意の組み込みまたはユーザ定義の基底型、列挙型、複合型、範囲型、ドメインの配列を作成することができます。</target>
        </trans-unit>
        <trans-unit id="bbbdf4cafaaa4dcf65d19eea36b6d2663f13d7b7" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows database sessions to synchronize their snapshots. A &lt;em&gt;snapshot&lt;/em&gt; determines which data is visible to the transaction that is using the snapshot. Synchronized snapshots are necessary when two or more sessions need to see identical content in the database. If two sessions just start their transactions independently, there is always a possibility that some third transaction commits between the executions of the two &lt;code&gt;START TRANSACTION&lt;/code&gt; commands, so that one session sees the effects of that transaction and the other does not.</source>
          <target state="translated">PostgreSQLでは、データベースセッションでスナップショットを同期できます。&lt;em&gt;スナップショットは、&lt;/em&gt;データのスナップショットを使用しているトランザクションに表示されるかを決定します。 2つ以上のセッションがデータベース内の同一のコンテンツを表示する必要がある場合は、同期されたスナップショットが必要です。 2つのセッションが独立してトランザクションを開始するだけの場合、2つの &lt;code&gt;START TRANSACTION&lt;/code&gt; コマンドの実行の間にいくつかの3番目のトランザクションがコミットする可能性が常にあるため、一方のセッションはそのトランザクションの影響を認識し、もう一方のトランザクションは影響を与えません。</target>
        </trans-unit>
        <trans-unit id="2f376988cf3adab23de6270e27f2d8af7b43d3dc" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows expressions with prefix and postfix unary (one-argument) operators, as well as binary (two-argument) operators. Like functions, operators can be overloaded, so the same problem of selecting the right operator exists.</source>
          <target state="translated">PostgreSQLでは、接頭辞と接尾辞の単項演算子(1引数)とバイナリ演算子(2引数)を用いた式を使用することができます。関数と同様に、演算子はオーバーロードすることができますので、正しい演算子を選択するという同じ問題が存在します。</target>
        </trans-unit>
        <trans-unit id="38e06aff61270fa25d3a83fecc14dbc49c17fa73" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows function &lt;em&gt;overloading&lt;/em&gt;; that is, the same name can be used for several different functions so long as they have distinct input argument types. Whether or not you use it, this capability entails security precautions when calling functions in databases where some users mistrust other users; see &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLでは関数の&lt;em&gt;オーバーロード&lt;/em&gt;が可能です。つまり、入力引数の型が異なる限り、複数の異なる関数に同じ名前を使用できます。これを使用するかどうかに関係なく、この機能は、一部のユーザーが他のユーザーを信頼していないデータベースで関数を呼び出すときにセキュリティ対策を必要とします。&lt;a href=&quot;typeconv-func&quot;&gt;セクション10.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="885786b4f5cdfbf8b703cb2cdbcec19a632c472d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows functions that have named parameters to be called using either &lt;em&gt;positional&lt;/em&gt; or &lt;em&gt;named&lt;/em&gt; notation. Named notation is especially useful for functions that have a large number of parameters, since it makes the associations between parameters and actual arguments more explicit and reliable. In positional notation, a function call is written with its argument values in the same order as they are defined in the function declaration. In named notation, the arguments are matched to the function parameters by name and can be written in any order. For each notation, also consider the effect of function argument types, documented in &lt;a href=&quot;typeconv-func&quot;&gt;Section 10.3&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLでは、名前付きパラメーターを持つ関数を、&lt;em&gt;位置&lt;/em&gt;表記法または&lt;em&gt;名前付き&lt;/em&gt;表記法のいずれかを使用して呼び出すことができます。名前付き表記法は、パラメーターと実際の引数の間の関連付けをより明示的かつ信頼できるものにするため、多数のパラメーターを持つ関数に特に役立ちます。位置表記では、関数呼び出しは、関数宣言で定義されているのと同じ順序で引数値を使用して記述されます。名前付き表記では、引数は名前で関数パラメーターと照合され、任意の順序で記述できます。それぞれの表記について、&lt;a href=&quot;typeconv-func&quot;&gt;セクション10.3&lt;/a&gt;で説明されている関数の引数型の影響も考慮してください。</target>
        </trans-unit>
        <trans-unit id="ccedf68ac95013795d6781ac353bb002bbdac9bd" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows identifier syntax (&lt;code&gt;&quot;rolename&quot;&lt;/code&gt;), while the SQL standard requires the role name to be written as a string literal. SQL does not allow this command during a transaction; PostgreSQL does not make this restriction because there is no reason to. The &lt;code&gt;SESSION&lt;/code&gt; and &lt;code&gt;LOCAL&lt;/code&gt; modifiers are a PostgreSQL extension, as is the &lt;code&gt;RESET&lt;/code&gt; syntax.</source>
          <target state="translated">PostgreSQLでは識別子構文（ &lt;code&gt;&quot;rolename&quot;&lt;/code&gt; ）を使用できますが、SQL標準ではロール名を文字列リテラルとして記述する必要があります。SQLでは、トランザクション中にこのコマンドを使用できません。PostgreSQLには理由がないため、この制限はありません。 &lt;code&gt;SESSION&lt;/code&gt; および &lt;code&gt;LOCAL&lt;/code&gt; 修飾子はようで、PostgreSQLの拡張です &lt;code&gt;RESET&lt;/code&gt; の構文。</target>
        </trans-unit>
        <trans-unit id="aee304bddb0add35cce98f16acc2e91d76460499" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows one to omit the &lt;code&gt;FROM&lt;/code&gt; clause. It has a straightforward use to compute the results of simple expressions:</source>
          <target state="translated">PostgreSQLでは、 &lt;code&gt;FROM&lt;/code&gt; 句を省略できます。単純な式の結果を計算するための簡単な使用法があります。</target>
        </trans-unit>
        <trans-unit id="d0eb6de17c126effc5a1502158efa04db9cdf59d" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed.</source>
          <target state="translated">PostgreSQLでは、データベースごとに1つの文字集合エンコーディングしかできません。そのため、データベースのエンコーディングがUTF8でない限り、JSON型がJSON仕様に厳密に準拠することはできません。データベースの文字コードで表現できない文字を直接含めようとすると失敗します。逆に、データベースの文字コードで表現できてもUTF8ではない文字は許可されます。</target>
        </trans-unit>
        <trans-unit id="6f4d7c19f392d3d32e2ae22627f8334829c75a1e" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows the application developer to specify the durability level required via replication. This can be specified for the system overall, though it can also be specified for specific users or connections, or even individual transactions.</source>
          <target state="translated">PostgreSQLでは、アプリケーション開発者はレプリケーションを介して必要な耐久性レベルを指定することができます。これはシステム全体に対して指定することができますが、特定のユーザや接続、あるいは個々のトランザクションに対しても指定することができます。</target>
        </trans-unit>
        <trans-unit id="67e964073140451a310c8055af1d484d7e584b05" translate="yes" xml:space="preserve">
          <source>PostgreSQL allows you to specify time zones in three different forms:</source>
          <target state="translated">PostgreSQLでは、3つの形式で時間帯を指定することができます。</target>
        </trans-unit>
        <trans-unit id="2091ac924b203b9490fe163a62e56fac7f983c3f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts &amp;ldquo;escape&amp;rdquo; string constants, which are an extension to the SQL standard. An escape string constant is specified by writing the letter &lt;code&gt;E&lt;/code&gt; (upper or lower case) just before the opening single quote, e.g., &lt;code&gt;E'foo'&lt;/code&gt;. (When continuing an escape string constant across lines, write &lt;code&gt;E&lt;/code&gt; only before the first opening quote.) Within an escape string, a backslash character (&lt;code&gt;\&lt;/code&gt;) begins a C-like &lt;em&gt;backslash escape&lt;/em&gt; sequence, in which the combination of backslash and following character(s) represent a special byte value, as shown in &lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;Table 4.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLは、SQL標準の拡張である「エスケープ」文字列定数も受け入れます。エスケープ文字列定数は、 &lt;code&gt;E'foo'&lt;/code&gt; ように、開始の単一引用符の直前に文字 &lt;code&gt;E&lt;/code&gt; （大文字または小文字）を書き込むことによって指定されます。 （エスケープ文字列定数を複数の行にまたがる場合は、最初の引用符の前にのみ &lt;code&gt;E&lt;/code&gt; を記述します。）エスケープ文字列内では、バックスラッシュ文字（ &lt;code&gt;\&lt;/code&gt; ）がCのような&lt;em&gt;バックスラッシュエスケープ&lt;/em&gt;シーケンスを開始します。 s）&lt;a href=&quot;sql-syntax-lexical#SQL-BACKSLASH-TABLE&quot;&gt;表4.1に&lt;/a&gt;示すように、特別なバイト値を表します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8e26c666446bf180bc1b3bdb6835476bef38f80" translate="yes" xml:space="preserve">
          <source>PostgreSQL also accepts the following alternative forms for input: use of upper-case digits, the standard format surrounded by braces, omitting some or all hyphens, adding a hyphen after any group of four digits. Examples are:</source>
          <target state="translated">PostgreSQLは以下の入力形式も受け付けています。大文字の使用、中括弧で囲まれた標準形式、一部またはすべてのハイフンの省略、4つの数字のグループの後にハイフンを追加します。例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="d551afc59236ea284f4ca849fa7d2277a7469049" translate="yes" xml:space="preserve">
          <source>PostgreSQL also has native support for using GSSAPI to encrypt client/server communications for increased security. Support requires that a GSSAPI implementation (such as MIT krb5) is installed on both client and server systems, and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQLは、GSSAPIを使用してクライアント/サーバー通信を暗号化し、セキュリティを強化するためのネイティブサポートも備えています。サポートには、クライアントシステムとサーバーシステムの両方にGSSAPI実装（MIT krb5など）がインストールされていること、およびPostgreSQLでのサポートがビルド時に有効になっていることが必要です（&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7d7d486aaa9f91eb610db7317aa89991dcace483" translate="yes" xml:space="preserve">
          <source>PostgreSQL also protects against some kinds of data corruption on storage devices that may occur because of hardware errors or media failure over time, such as reading/writing garbage data.</source>
          <target state="translated">また、PostgreSQLは、ガベージデータの読み書きなど、ハードウェアエラーやメディア障害が原因で長期的に発生する可能性のあるストレージデバイス上のデータ破損の種類にも対応しています。</target>
        </trans-unit>
        <trans-unit id="bc4957185fda95801e3489431ec80f6cc95ed9d3" translate="yes" xml:space="preserve">
          <source>PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is:</source>
          <target state="translated">PostgreSQLはまた、現在の文の開始時刻と、関数が呼び出された瞬間の実際の現在時刻を返す関数も提供しています。非SQL標準の時刻関数の完全なリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="73c105cc11eec562c7842e40a45124c8ca33cfca" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports &lt;em&gt;mixed&lt;/em&gt; notation, which combines positional and named notation. In this case, positional parameters are written first and named parameters appear after them.</source>
          <target state="translated">PostgreSQL は、位置表記と名前表記を組み合わせた&lt;em&gt;混合&lt;/em&gt;表記もサポートしています。この場合、定位置パラメーターが最初に書き込まれ、名前付きパラメーターがそれらの後に表示されます。</target>
        </trans-unit>
        <trans-unit id="ca59eb947715e169590d0f69e1f5c9da2f5d3e56" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports a parameter to strip the realm from the principal. This method is supported for backwards compatibility and is strongly discouraged as it is then impossible to distinguish different users with the same user name but coming from different realms. To enable this, set &lt;code&gt;include_realm&lt;/code&gt; to 0. For simple single-realm installations, doing that combined with setting the &lt;code&gt;krb_realm&lt;/code&gt; parameter (which checks that the principal's realm matches exactly what is in the &lt;code&gt;krb_realm&lt;/code&gt; parameter) is still secure; but this is a less capable approach compared to specifying an explicit mapping in &lt;code&gt;pg_ident.conf&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLは、プリンシパルからレルムを取り除くパラメーターもサポートしています。このメソッドは、下位互換性のためにサポートされており、同じユーザー名を持つが異なるレルムに由来する異なるユーザーを区別することは不可能であるため、強くお勧めしません。これを有効にするには、 &lt;code&gt;include_realm&lt;/code&gt; を0 に設定します。単純な単一レルムのインストールでは、 &lt;code&gt;krb_realm&lt;/code&gt; パラメーターの設定（プリンシパルのレルムが &lt;code&gt;krb_realm&lt;/code&gt; パラメーターの内容と正確に一致することを確認する）と組み合わせてこれを実行しても安全です。しかし、これは &lt;code&gt;pg_ident.conf&lt;/code&gt; で明示的なマッピングを指定することと比較して、能力が劣ります。</target>
        </trans-unit>
        <trans-unit id="0b477944494e7d8e126d3d69b3ea2e26c69eb1df" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports another type of escape syntax for strings that allows specifying arbitrary Unicode characters by code point. A Unicode escape string constant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case letter U followed by ampersand) immediately before the opening quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the string &lt;code&gt;'data'&lt;/code&gt; could be written as</source>
          <target state="translated">PostgreSQLは、コードポイントで任意のUnicode文字を指定できる、文字列の別のタイプのエスケープ構文もサポートしています。 Unicodeエスケープ文字列定数は、 &lt;code&gt;U&amp;amp;&lt;/code&gt; （大文字Uまたは小文字Uの後にアンパサンドが続く）で開始引用符の直前にあり、間にスペースはありません（例： &lt;code&gt;U&amp;amp;'foo'&lt;/code&gt; 。 （これにより、演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; で曖昧さが生じることに注意してください。この問題を回避するために、演算子の周りにスペースを使用してください。）引用符内では、バックスラッシュとそれに続く4桁の16進コードポイント番号またはまたは、バックスラッシュとそれに続くプラス記号、それに続く6桁の16進コードポイント番号。たとえば、文字列 &lt;code&gt;'data'&lt;/code&gt; 次のように書くことができます</target>
        </trans-unit>
        <trans-unit id="8b4d1cfe50623e59a66d0a1accf91a989fc0e27f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports reporting dynamic information about exactly what is going on in the system right now, such as the exact command currently being executed by other server processes, and which other connections exist in the system. This facility is independent of the collector process.</source>
          <target state="translated">PostgreSQLはまた、他のサーバプロセスによって現在実行されている正確なコマンドや、システム内にどのような接続が存在しているかなど、現在システム内で何が起こっているかについての動的な情報を報告することもサポートしています。この機能はコレクタプロセスから独立しています。</target>
        </trans-unit>
        <trans-unit id="478c7623d400e727e3280b1e79d887e002061f8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports the SQL-standard notations &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;float(p)&lt;/code&gt; for specifying inexact numeric types. Here, &lt;code&gt;p&lt;/code&gt; specifies the minimum acceptable precision in &lt;em&gt;binary&lt;/em&gt; digits. PostgreSQL accepts &lt;code&gt;float(1)&lt;/code&gt; to &lt;code&gt;float(24)&lt;/code&gt; as selecting the &lt;code&gt;real&lt;/code&gt; type, while &lt;code&gt;float(25)&lt;/code&gt; to &lt;code&gt;float(53)&lt;/code&gt; select &lt;code&gt;double precision&lt;/code&gt;. Values of &lt;code&gt;p&lt;/code&gt; outside the allowed range draw an error. &lt;code&gt;float&lt;/code&gt; with no precision specified is taken to mean &lt;code&gt;double precision&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLは、不正確な数値型を指定するためのSQL標準表記 &lt;code&gt;float&lt;/code&gt; および &lt;code&gt;float(p)&lt;/code&gt; もサポートしています。ここで、 &lt;code&gt;p&lt;/code&gt; は&lt;em&gt;2進&lt;/em&gt;数で最小許容精度を指定します。PostgreSQLは、 &lt;code&gt;float(1)&lt;/code&gt; から &lt;code&gt;float(24)&lt;/code&gt; を &lt;code&gt;real&lt;/code&gt; 型を選択するものとして受け入れ、 &lt;code&gt;float(25)&lt;/code&gt; から &lt;code&gt;float(53)&lt;/code&gt; は &lt;code&gt;double precision&lt;/code&gt; 選択します。許容範囲外の &lt;code&gt;p&lt;/code&gt; の値はエラーになります。 &lt;code&gt;float&lt;/code&gt; を意味すると解釈され、指定なしの精度で &lt;code&gt;double precision&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de648c643b7990a2f17212f7c4a34e709bba19e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an &lt;em&gt;embedded option&lt;/em&gt; to the RE pattern, as described in &lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;Section 9.7.3.4&lt;/a&gt;. This can be useful for compatibility with applications that expect exactly the POSIX 1003.2 rules.</source>
          <target state="translated">PostgreSQLは常に、正規表現がARE規則に従うことを最初に前提としています。ただし、&lt;a href=&quot;functions-matching#POSIX-METASYNTAX&quot;&gt;セクション9.7.3.4で&lt;/a&gt;説明されているように、RE &lt;em&gt;オプション&lt;/em&gt;に&lt;em&gt;埋め込みオプション&lt;/em&gt;を付加することで、より限定的なEREまたはBREルールを選択できます。これは、POSIX 1003.2のルールを正確に想定しているアプリケーションとの互換性のために役立ちます。</target>
        </trans-unit>
        <trans-unit id="54903aca24fd73df3d0ecfd618b2abc92e61f984" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input row. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when rows are inserted or updated, and not at other times. (The warning above about not referencing other table data is really a special case of this restriction.)</source>
          <target state="translated">PostgreSQLは &lt;code&gt;CHECK&lt;/code&gt; 制約の条件が不変であると想定しています。つまり、それらは同じ入力行に対して常に同じ結果を提供します。この仮定は調べ正当化するものです &lt;code&gt;CHECK&lt;/code&gt; 行が他の回で挿入または更新されておらず、ときにのみ制約を。（他のテーブルデータを参照しないことに関する上記の警告は、この制限の特別なケースです。）</target>
        </trans-unit>
        <trans-unit id="ff088d9be54485de195a863d4cf5285816323947" translate="yes" xml:space="preserve">
          <source>PostgreSQL assumes that &lt;code&gt;CHECK&lt;/code&gt; constraints' conditions are immutable, that is, they will always give the same result for the same input value. This assumption is what justifies examining &lt;code&gt;CHECK&lt;/code&gt; constraints only when a value is first converted to be of a domain type, and not at other times. (This is essentially the same as the treatment of table &lt;code&gt;CHECK&lt;/code&gt; constraints, as described in &lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;Section 5.4.1&lt;/a&gt;.)</source>
          <target state="translated">PostgreSQLは &lt;code&gt;CHECK&lt;/code&gt; 制約の条件が不変であると想定しています。つまり、それらは同じ入力値に対して常に同じ結果を与えることになります。この仮定は、値が最初にドメインタイプに変換された場合にのみ &lt;code&gt;CHECK&lt;/code&gt; 制約の検査を正当化するものであり、他の場合にはそうではありません。 （これは、&lt;a href=&quot;ddl-constraints#DDL-CONSTRAINTS-CHECK-CONSTRAINTS&quot;&gt;セクション5.4.1で&lt;/a&gt;説明されているように、テーブル &lt;code&gt;CHECK&lt;/code&gt; 制約の処理と本質的に同じです。）</target>
        </trans-unit>
        <trans-unit id="a2bff8b5a2ca5d91db2860fea9c0dad6138d0027" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates a unique index when a unique constraint or primary key is defined for a table. The index covers the columns that make up the primary key or unique constraint (a multicolumn index, if appropriate), and is the mechanism that enforces the constraint.</source>
          <target state="translated">PostgreSQLは、テーブルに対して一意な制約や主キーが定義されている場合、自動的に一意なインデックスを作成します。インデックスは主キーまたは一意制約を構成する列(適切な場合は複数列インデックス)をカバーし、制約を強制する機構です。</target>
        </trans-unit>
        <trans-unit id="f26b59affbadfc237829843f54d3c4584d266882" translate="yes" xml:space="preserve">
          <source>PostgreSQL automatically creates an index for each unique constraint and primary key constraint to enforce uniqueness. Thus, it is not necessary to create an index explicitly for primary key columns. (See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for more information.)</source>
          <target state="translated">PostgreSQLは、一意性を強制するために、一意の制約と主キー制約ごとにインデックスを自動的に作成します。したがって、主キー列に対して明示的に索引を作成する必要はありません。（詳細については、「&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt;」を参照してください。）</target>
        </trans-unit>
        <trans-unit id="71faf5408aef54cef3ab5e08ed45e5e43ecd20a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL can build indexes while leveraging multiple CPUs in order to process the table rows faster. This feature is known as &lt;em&gt;parallel index build&lt;/em&gt;. For index methods that support building indexes in parallel (currently, only B-tree), &lt;code&gt;maintenance_work_mem&lt;/code&gt; specifies the maximum amount of memory that can be used by each index build operation as a whole, regardless of how many worker processes were started. Generally, a cost model automatically determines how many worker processes should be requested, if any.</source>
          <target state="translated">PostgreSQLは、テーブルの行をより速く処理するために、複数のCPUを活用しながらインデックスを構築できます。この機能は、&lt;em&gt;並列インデックス作成&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。インデックスの並列作成（現在はBツリーのみ）をサポートするインデックスメソッドの場合、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; は、開始されたワーカープロセスの数に関係なく、各インデックス作成操作全体で使用できる最大メモリ量を指定します。一般に、コストモデルは、必要に応じてワーカープロセスの数を自動的に決定します。</target>
        </trans-unit>
        <trans-unit id="b61a24efb840bbdfd7121333fc936cd259d1497d" translate="yes" xml:space="preserve">
          <source>PostgreSQL can sometimes exhaust various operating system resource limits, especially when multiple copies of the server are running on the same system, or in very large installations. This section explains the kernel resources used by PostgreSQL and the steps you can take to resolve problems related to kernel resource consumption.</source>
          <target state="translated">PostgreSQLは、特にサーバの複数のコピーが同じシステム上で実行されている場合や、非常に大規模なインストールでは、さまざまなオペレーティングシステムのリソース制限を使い果たしてしまうことがあります。このセクションでは、PostgreSQLが使用するカーネルリソースと、カーネルリソースの消費に関連する問題を解決するために取ることができる手順について説明します。</target>
        </trans-unit>
        <trans-unit id="b2e725f00d6a809e37502a0cf8c2fc8a68d3f58c" translate="yes" xml:space="preserve">
          <source>PostgreSQL comes with the following built-in range types:</source>
          <target state="translated">PostgreSQLは以下の組み込み範囲型を持っています。</target>
        </trans-unit>
        <trans-unit id="cb387a6689d06faa79aaca21b4c8e065a066ab23" translate="yes" xml:space="preserve">
          <source>PostgreSQL considers distinct collation objects to be incompatible even when they have identical properties. Thus for example,</source>
          <target state="translated">PostgreSQLは、異なる照合オブジェクトが同一のプロパティを持っていても互換性がないと考えています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="390d5417e842d1a1814896813c380671ee3b4fd0" translate="yes" xml:space="preserve">
          <source>PostgreSQL creates a temporary variable of data type &lt;code&gt;stype&lt;/code&gt; to hold the current internal state of the aggregate. At each input row, the aggregate argument value(s) are calculated and the state transition function is invoked with the current state value and the new argument value(s) to calculate a new internal state value. After all the rows have been processed, the final function is invoked once to calculate the aggregate's return value. If there is no final function then the ending state value is returned as-is.</source>
          <target state="translated">PostgreSQLは、データ型 &lt;code&gt;stype&lt;/code&gt; の一時変数を作成して、集計の現在の内部状態を保持します。各入力行で、集約引数値が計算され、現在の状態値と新しい引数値を使用して状態遷移関数が呼び出され、新しい内部状態値が計算されます。すべての行が処理された後、集約の戻り値を計算するために最後の関数が1回呼び出されます。最終関数がない場合は、終了状態の値がそのまま返されます。</target>
        </trans-unit>
        <trans-unit id="14a71a515034c71c679dfb591fbd291cd9591d60" translate="yes" xml:space="preserve">
          <source>PostgreSQL currently does not support multi-character collating elements. This information describes possible future behavior.</source>
          <target state="translated">PostgreSQLは現在、複数文字の照合要素をサポートしていません。この情報は、将来起こりうる動作について説明しています。</target>
        </trans-unit>
        <trans-unit id="7e2fde7f5f9c9a2ecbda1c45fded6817737c8d70" translate="yes" xml:space="preserve">
          <source>PostgreSQL database passwords are separate from operating system user passwords. The password for each database user is stored in the &lt;code&gt;pg_authid&lt;/code&gt; system catalog. Passwords can be managed with the SQL commands &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;, e.g., &lt;strong&gt;&lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt;&lt;/strong&gt;, or the psql command &lt;code&gt;\password&lt;/code&gt;. If no password has been set up for a user, the stored password is null and password authentication will always fail for that user.</source>
          <target state="translated">PostgreSQLデータベースのパスワードは、オペレーティングシステムのユーザーパスワードとは異なります。各データベースユーザーのパスワードは、 &lt;code&gt;pg_authid&lt;/code&gt; システムカタログに格納されます。パスワードは、SQLコマンド&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;および&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;で管理できます。たとえば、&lt;strong&gt; &lt;code&gt;CREATE ROLE foo WITH LOGIN PASSWORD 'secret'&lt;/code&gt; &lt;/strong&gt;またはpsqlコマンド &lt;code&gt;\password&lt;/code&gt; 。ユーザーにパスワードが設定されていない場合、保存されているパスワードはnullであり、そのユーザーのパスワード認証は常に失敗します。</target>
        </trans-unit>
        <trans-unit id="ae07be10ad05f8eb77e791ce859f3046663e8d9e" translate="yes" xml:space="preserve">
          <source>PostgreSQL databases require periodic maintenance known as &lt;em&gt;vacuuming&lt;/em&gt;. For many installations, it is sufficient to let vacuuming be performed by the &lt;em&gt;autovacuum daemon&lt;/em&gt;, which is described in &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt;. You might need to adjust the autovacuuming parameters described there to obtain best results for your situation. Some database administrators will want to supplement or replace the daemon's activities with manually-managed &lt;code&gt;VACUUM&lt;/code&gt; commands, which typically are executed according to a schedule by cron or Task Scheduler scripts. To set up manually-managed vacuuming properly, it is essential to understand the issues discussed in the next few subsections. Administrators who rely on autovacuuming may still wish to skim this material to help them understand and adjust autovacuuming.</source>
          <target state="translated">PostgreSQLデータベースには、&lt;em&gt;バキューム処理と&lt;/em&gt;呼ばれる定期的なメンテナンスが必要です。多くのインストールでは、&lt;em&gt;自動バキュームデーモン&lt;/em&gt;によってバキュームを実行できれば十分&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;です&lt;/a&gt;。これについては、セクション24.1.6で説明しています。状況に最適な結果を得るには、そこで説明されている自動バキュームパラメータを調整する必要がある場合があります。一部のデータベース管理者は、デーモンのアクティビティを手動で管理される &lt;code&gt;VACUUM&lt;/code&gt; で補完または置き換えたいと思うでしょう。コマンドは通常、cronまたはタスクスケジューラスクリプトによってスケジュールに従って実行されます。手動管理のバキューム処理を適切に設定するには、次のいくつかのサブセクションで説明する問題を理解することが不可欠です。自動バキュームに依存している管理者は、自動バキュームの理解と調整に役立つように、この資料を読み飛ばしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="0b15ec468b17952447cfdd51a679958ed70d2e48" translate="yes" xml:space="preserve">
          <source>PostgreSQL devises a &lt;em&gt;query plan&lt;/em&gt; for each query it receives. Choosing the right plan to match the query structure and the properties of the data is absolutely critical for good performance, so the system includes a complex &lt;em&gt;planner&lt;/em&gt; that tries to choose good plans. You can use the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command to see what query plan the planner creates for any query. Plan-reading is an art that requires some experience to master, but this section attempts to cover the basics.</source>
          <target state="translated">PostgreSQLは、受け取ったクエリごとに&lt;em&gt;クエリプラン&lt;/em&gt;を考案し&lt;em&gt;ます&lt;/em&gt;。クエリ構造とデータのプロパティに一致する適切なプランを選択することは、優れたパフォーマンスにとって絶対に重要です。そのため、システムには、適切なプランを選択しようとする複雑な&lt;em&gt;プランナー&lt;/em&gt;が含まれています。&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;コマンドを使用して、プランナがクエリに対して作成するクエリプランを確認できます。プランリーディングは、習得するにはある程度の経験が必要なアートですが、このセクションでは基本を取り上げます。</target>
        </trans-unit>
        <trans-unit id="c6bdc7ca1f027f4e423efc6001869a2aac8718c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not have an explicit &lt;code&gt;OPEN&lt;/code&gt; cursor statement; a cursor is considered open when it is declared. Use the &lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt; statement to declare a cursor.</source>
          <target state="translated">PostgreSQLには明示的な &lt;code&gt;OPEN&lt;/code&gt; カーソルステートメントはありません。カーソルは宣言されたときに開いていると見なされます。&lt;a href=&quot;sql-declare&quot;&gt;DECLARE&lt;/a&gt;ステートメントを使用して、カーソルを宣言します。</target>
        </trans-unit>
        <trans-unit id="0dfef93504eab39387d43751a55a477c2955176f" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not offer this type of replication, though PostgreSQL two-phase commit (&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; and &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;) can be used to implement this in application code or middleware.</source>
          <target state="translated">PostgreSQLはこのタイプのレプリケーションを提供していませんが、PostgreSQLの2フェーズコミット（&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;および&lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt;）を使用して、これをアプリケーションコードまたはミドルウェアに実装できます。</target>
        </trans-unit>
        <trans-unit id="bcb2a401b7b0ac69a360f9b7c695ed89ed9ebff0" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection.</source>
          <target state="translated">PostgreSQLは修正可能なメモリエラーからは保護されておらず、業界標準のエラー修正コード(ECC)を使用したRAMを使用して操作するか、より良い保護を行うことが前提となっています。</target>
        </trans-unit>
        <trans-unit id="13d3dc2372c98003c5a49c2b15eff6ff46f18e90" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not protect against correctable memory errors and it is assumed you will operate using RAM that uses industry standard Error Correcting Codes (ECC) or better protection. However, ECC memory is typically only immune to single-bit errors, and should not be assumed to provide &lt;em&gt;absolute&lt;/em&gt; protection against failures that result in memory corruption.</source>
          <target state="translated">PostgreSQLは修正可能なメモリエラーから保護しません。また、業界標準のエラー修正コード（ECC）またはより優れた保護を使用するRAMを使用して操作することを前提としています。ただし、ECCメモリは通常、シングルビットエラーの影響を受けないだけであり、メモリの破損を引き起こす障害に対する&lt;em&gt;絶対的な&lt;/em&gt;保護を提供するとは想定されていません。</target>
        </trans-unit>
        <trans-unit id="1217e1656a3a27412f47a2f27ca6ddad0011cb8d" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not provide the system software required to identify a failure on the primary and notify the standby database server. Many such tools exist and are well integrated with the operating system facilities required for successful failover, such as IP address migration.</source>
          <target state="translated">PostgreSQLは、プライマリ上の障害を識別し、スタンバイデータベースサーバに通知するために必要なシステムソフトウェアを提供していません。このようなツールは多く存在し、IPアドレスの移行など、フェイルオーバーを成功させるために必要なオペレーティングシステムの機能とうまく統合されています。</target>
        </trans-unit>
        <trans-unit id="1d796e67fd8db9494e77a87bae072c969985dce1" translate="yes" xml:space="preserve">
          <source>PostgreSQL does not support &lt;code&gt;CHECK&lt;/code&gt; constraints that reference table data other than the new or updated row being checked. While a &lt;code&gt;CHECK&lt;/code&gt; constraint that violates this rule may appear to work in simple tests, it cannot guarantee that the database will not reach a state in which the constraint condition is false (due to subsequent changes of the other row(s) involved). This would cause a database dump and reload to fail. The reload could fail even when the complete database state is consistent with the constraint, due to rows not being loaded in an order that will satisfy the constraint. If possible, use &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, or &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints to express cross-row and cross-table restrictions.</source>
          <target state="translated">PostgreSQLは、 &lt;code&gt;CHECK&lt;/code&gt; される新規または更新された行以外のテーブルデータを参照するCHECK制約をサポートしません。一方で &lt;code&gt;CHECK&lt;/code&gt; このルールに違反する制約は簡単なテストで動作するように見えることがあり、それはデータベースが制約条件は（原因関与する他の行（複数可）の後続の変更に）偽である状態に到達しないという保証はありません。これにより、データベースのダンプとリロードが失敗します。制約を満たす順序でローがロードされていないため、データベースの完全な状態が制約と一致している場合でも、リロードは失敗する可能性があります。可能であれば、 &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;EXCLUDE&lt;/code&gt; 、または &lt;code&gt;FOREIGN KEY&lt;/code&gt; 制約を使用して、行間および表間の制限を表現します。</target>
        </trans-unit>
        <trans-unit id="cef8ed11bde695868953cc0c745e366d96215f8a" translate="yes" xml:space="preserve">
          <source>PostgreSQL doesn't remember any information about modified rows in memory, so there is no limit on the number of rows locked at one time. However, locking a row might cause a disk write, e.g., &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; modifies selected rows to mark them locked, and so will result in disk writes.</source>
          <target state="translated">PostgreSQLはメモリ内の変更された行に関する情報を記憶しないため、一度にロックされる行の数に制限はありません。ただし、行をロックするとディスクへの書き込みが発生する可能性があります。たとえば、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; は選択された行を変更して、それらにロック済みのマークを付けるため、ディスクへの書き込みが発生します。</target>
        </trans-unit>
        <trans-unit id="63ab1d6406e057a762f3f310fecdc3a3bbd6104e" translate="yes" xml:space="preserve">
          <source>PostgreSQL endeavors to be compatible with the SQL standard definitions for typical usage. However, the SQL standard has an odd mix of date and time types and capabilities. Two obvious problems are:</source>
          <target state="translated">PostgreSQLは、典型的な使用法についてはSQL標準の定義と互換性があるように努めています。しかし、SQL標準は日付と時刻の型と機能が奇妙に混在しています。2つの明らかな問題があります。</target>
        </trans-unit>
        <trans-unit id="66d120b7abdf73ead6dc3fd9f48bfc40f4f89b99" translate="yes" xml:space="preserve">
          <source>PostgreSQL enforces SQL uniqueness constraints using &lt;em&gt;unique indexes&lt;/em&gt;, which are indexes that disallow multiple entries with identical keys. An access method that supports this feature sets &lt;code&gt;amcanunique&lt;/code&gt; true. (At present, only b-tree supports it.) Columns listed in the &lt;code&gt;INCLUDE&lt;/code&gt; clause are not considered when enforcing uniqueness.</source>
          <target state="translated">PostgreSQL は、&lt;em&gt;一意のインデックス&lt;/em&gt;を使用してSQL一意性制約を適用し&lt;em&gt;ます&lt;/em&gt;。これは、同じキーを持つ複数のエントリを許可しないインデックスです。この機能をサポートするアクセス方法は &lt;code&gt;amcanunique&lt;/code&gt; を trueに設定します。（現時点では、bツリーのみがサポートしています。）一意性を適用する場合、 &lt;code&gt;INCLUDE&lt;/code&gt; 句にリストされている列は考慮されません。</target>
        </trans-unit>
        <trans-unit id="46cf5e94b98f5acb847fc69a661150beb395793b" translate="yes" xml:space="preserve">
          <source>PostgreSQL grants privileges on some types of objects to &lt;code&gt;PUBLIC&lt;/code&gt; by default when the objects are created. No privileges are granted to &lt;code&gt;PUBLIC&lt;/code&gt; by default on tables, table columns, sequences, foreign data wrappers, foreign servers, large objects, schemas, or tablespaces. For other types of objects, the default privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt; are as follows: &lt;code&gt;CONNECT&lt;/code&gt; and &lt;code&gt;TEMPORARY&lt;/code&gt; (create temporary tables) privileges for databases; &lt;code&gt;EXECUTE&lt;/code&gt; privilege for functions and procedures; and &lt;code&gt;USAGE&lt;/code&gt; privilege for languages and data types (including domains). The object owner can, of course, &lt;code&gt;REVOKE&lt;/code&gt; both default and expressly granted privileges. (For maximum security, issue the &lt;code&gt;REVOKE&lt;/code&gt; in the same transaction that creates the object; then there is no window in which another user can use the object.) Also, these default privilege settings can be overridden using the &lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQL は、オブジェクトが作成されると、デフォルトでいくつかのタイプのオブジェクトに対する特権を &lt;code&gt;PUBLIC&lt;/code&gt; に付与します。テーブル、テーブルカラム、シーケンス、外部データラッパー、外部サーバー、ラージオブジェクト、スキーマ、またはテーブルスペースでは、デフォルトで &lt;code&gt;PUBLIC&lt;/code&gt; に権限は付与されません。その他のタイプのオブジェクトの場合、 &lt;code&gt;PUBLIC&lt;/code&gt; に付与されるデフォルトの特権は次のとおりです。データベースに対する &lt;code&gt;CONNECT&lt;/code&gt; および &lt;code&gt;TEMPORARY&lt;/code&gt; （一時テーブルの作成）特権。関数およびプロシージャの &lt;code&gt;EXECUTE&lt;/code&gt; 権限。そして、 &lt;code&gt;USAGE&lt;/code&gt; （ドメインを含む）の言語とデータ型の特権。オブジェクトの所有者はもちろん &lt;code&gt;REVOKE&lt;/code&gt; ことができますデフォルトと明示的に付与された特権の両方。（最大限のセキュリティを確保するには、オブジェクトを作成するのと同じトランザクションで &lt;code&gt;REVOKE&lt;/code&gt; を発行します。その後、別のユーザーがオブジェクトを使用できるウィンドウはありません。）また、&lt;a href=&quot;sql-alterdefaultprivileges&quot;&gt;ALTER DEFAULT PRIVILEGES&lt;/a&gt;コマンドを使用して、これらのデフォルトの権限設定を上書きできます。</target>
        </trans-unit>
        <trans-unit id="7a3b4b281714f98b0b025baa01ab2e4079267b58" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles column expansion by actually transforming the first form into the second. So, in this example, &lt;code&gt;myfunc()&lt;/code&gt; would get invoked three times per row with either syntax. If it's an expensive function you may wish to avoid that, which you can do with a query like:</source>
          <target state="translated">PostgreSQLは、最初の形式を2番目の形式に実際に変換することにより、列の拡張を処理します。したがって、この例では、 &lt;code&gt;myfunc()&lt;/code&gt; はどちらの構文でも行ごとに3回呼び出されます。これが高価な関数である場合は、次のようなクエリで回避できます。</target>
        </trans-unit>
        <trans-unit id="df3dd7b1a171b6d6a80edc47008e7fbb158239c5" translate="yes" xml:space="preserve">
          <source>PostgreSQL handles temporary tables in a way rather different from the standard; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">PostgreSQLは、一時テーブルを標準とはかなり異なる方法で処理します。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6d2f14dc9f7becae572a0674a0a8f299b6b7b7aa" translate="yes" xml:space="preserve">
          <source>PostgreSQL has a rich set of native data types available to users. Users can add new types to PostgreSQL using the &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; command.</source>
          <target state="translated">PostgreSQLには、ユーザーが使用できる豊富なネイティブデータ型のセットがあります。ユーザーは、&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;コマンドを使用して、PostgreSQLに新しいタイプを追加できます。</target>
        </trans-unit>
        <trans-unit id="78dda5739ec01795bd873fabe7ba9d163840acc7" translate="yes" xml:space="preserve">
          <source>PostgreSQL has an optional but highly recommended feature called &lt;em&gt;autovacuum&lt;/em&gt;, whose purpose is to automate the execution of &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;ANALYZE&lt;/code&gt; commands. When enabled, autovacuum checks for tables that have had a large number of inserted, updated or deleted tuples. These checks use the statistics collection facility; therefore, autovacuum cannot be used unless &lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;track_counts&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;. In the default configuration, autovacuuming is enabled and the related configuration parameters are appropriately set.</source>
          <target state="translated">PostgreSQLにはオプションですが強く推奨される&lt;em&gt;autovacuum&lt;/em&gt;と呼ばれる機能が&lt;em&gt;あり&lt;/em&gt;、その目的は &lt;code&gt;VACUUM&lt;/code&gt; および &lt;code&gt;ANALYZE&lt;/code&gt; コマンドの実行を自動化することです。自動バキュームを有効にすると、挿入、更新、または削除されたタプルが多数あるテーブルがチェックされます。これらのチェックは統計収集機能を使用します。したがって、track_countsが &lt;code&gt;true&lt;/code&gt; に設定されていない限り、&lt;a href=&quot;runtime-config-statistics#GUC-TRACK-COUNTS&quot;&gt;autovacuum&lt;/a&gt;は使用できません。デフォルトの構成では、自動バキュームが有効になっており、関連する構成パラメーターが適切に設定されています。</target>
        </trans-unit>
        <trans-unit id="745a9a5fff0d46d735897a2bfe230fa0dcd833f5" translate="yes" xml:space="preserve">
          <source>PostgreSQL has builtin support to perform JIT compilation using &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; when PostgreSQL is built with &lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt;&lt;code&gt;--with-llvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLには、PostgreSQLが&lt;a href=&quot;https://www.postgresql.org/docs/12/install-procedure.html#CONFIGURE-WITH-LLVM&quot;&gt; &lt;code&gt;--with-llvm&lt;/code&gt; で&lt;/a&gt;ビルドされている場合に、&lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt;を使用してJITコンパイルを実行するための組み込みサポートがあります。</target>
        </trans-unit>
        <trans-unit id="1f59e9103489b1a27d73e875b095c1816ff90ee6" translate="yes" xml:space="preserve">
          <source>PostgreSQL has many features not touched upon in this tutorial introduction, which has been oriented toward newer users of SQL. These features are discussed in more detail in the remainder of this book.</source>
          <target state="translated">PostgreSQLには、このチュートリアルの紹介では触れられていない多くの機能があります。これらの機能については、本書の残りの部分で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="34f532154e5db2109f00a916c27e879723393e79" translate="yes" xml:space="preserve">
          <source>PostgreSQL has native support for using SSL connections to encrypt client/server communications for increased security. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time (see &lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;Chapter 16&lt;/a&gt;).</source>
          <target state="translated">PostgreSQLは、SSL接続を使用してクライアント/サーバー通信を暗号化し、セキュリティを強化するためのネイティブサポートを備えています。これには、OpenSSLがクライアントシステムとサーバーシステムの両方にインストールされ、PostgreSQLでのサポートがビルド時に有効になっていることが必要です（&lt;a href=&quot;https://www.postgresql.org/docs/12/installation.html&quot;&gt;第16章を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2cee738042d576fe56c5cf2614b5d2a89ef2ed35" translate="yes" xml:space="preserve">
          <source>PostgreSQL has the ability to report the progress of certain commands during command execution. Currently, the only commands which support progress reporting are &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;CLUSTER&lt;/code&gt;. This may be expanded in the future.</source>
          <target state="translated">PostgreSQLには、コマンドの実行中に特定のコマンドの進行状況を報告する機能があります。現在、進行状況レポートをサポートするコマンドは &lt;code&gt;CREATE INDEX&lt;/code&gt; 、 &lt;code&gt;VACUUM&lt;/code&gt; および &lt;code&gt;CLUSTER&lt;/code&gt; のみです。これは将来拡張されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a153bd140b6eee429afa97ad0154361013ce149c" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements portions of the SQL/MED specification, allowing you to access data that resides outside PostgreSQL using regular SQL queries. Such data is referred to as &lt;em&gt;foreign data&lt;/em&gt;. (Note that this usage is not to be confused with foreign keys, which are a type of constraint within the database.)</source>
          <target state="translated">PostgreSQLはSQL / MED仕様の一部を実装しているため、通常のSQLクエリを使用してPostgreSQLの外部にあるデータにアクセスできます。このようなデータは&lt;em&gt;外部データ&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。（この使用法は、データベース内の制約の一種である外部キーと混同しないように注意してください。）</target>
        </trans-unit>
        <trans-unit id="45ba54515ef38ae8443e32276665e58fc7c44f3d" translate="yes" xml:space="preserve">
          <source>PostgreSQL implements table inheritance, which can be a useful tool for database designers. (SQL:1999 and later define a type inheritance feature, which differs in many respects from the features described here.)</source>
          <target state="translated">PostgreSQLはテーブル継承を実装しており、データベース設計者にとって有用なツールとなります。(SQL:1999以降では型継承機能が定義されていますが、ここで説明した機能とは多くの点で異なります)。</target>
        </trans-unit>
        <trans-unit id="9a4293b24f0d18f72db2fd6c1c67a47c9fab41ed" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt; that has the same functionality as &lt;code&gt;CREATE ROLE&lt;/code&gt; (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQLには、 &lt;code&gt;CREATE ROLE&lt;/code&gt; （実際にはこのコマンドを呼び出します）と同じ機能を持つプログラム&lt;a href=&quot;app-createuser&quot;&gt;createuser&lt;/a&gt;が含まれていますが、コマンドシェルから実行できます。</target>
        </trans-unit>
        <trans-unit id="84114ad3110b572f55729ff61c07b1a5d40daec3" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a program &lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt; that has the same functionality as this command (in fact, it calls this command) but can be run from the command shell.</source>
          <target state="translated">PostgreSQLには、このコマンドと同じ機能を持つプログラム&lt;a href=&quot;app-dropuser&quot;&gt;dropuser&lt;/a&gt;が含まれています（実際、このコマンドを呼び出します）が、コマンドシェルから実行できます。</target>
        </trans-unit>
        <trans-unit id="682b0969ef85f21e73efd9cc0f1d64eca421eb6a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to &lt;a href=&quot;datatype&quot;&gt;Chapter 8&lt;/a&gt;. Some of the frequently used data types are &lt;code&gt;integer&lt;/code&gt; for whole numbers, &lt;code&gt;numeric&lt;/code&gt; for possibly fractional numbers, &lt;code&gt;text&lt;/code&gt; for character strings, &lt;code&gt;date&lt;/code&gt; for dates, &lt;code&gt;time&lt;/code&gt; for time-of-day values, and &lt;code&gt;timestamp&lt;/code&gt; for values containing both date and time.</source>
          <target state="translated">PostgreSQLには、多くのアプリケーションに適合する大量の組み込みデータ型のセットが含まれています。ユーザーは独自のデータ型を定義することもできます。ほとんどの組み込みデータ型には明らかな名前とセマンティクスがあるため、詳細な説明は&lt;a href=&quot;datatype&quot;&gt;第8章に&lt;/a&gt;委ねます。頻繁に使用されるデータ型には、 &lt;code&gt;integer&lt;/code&gt; には整数、小数の場合には &lt;code&gt;numeric&lt;/code&gt; 、文字列には &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;date&lt;/code&gt; には日付、 &lt;code&gt;time&lt;/code&gt; は時刻、日付と時刻の両方を含む値には &lt;code&gt;timestamp&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="735559b54f06b3f3f206e8111b18e4ea8d9566e4" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an &amp;ldquo;autovacuum&amp;rdquo; facility which can automate routine vacuum maintenance. For more information about automatic and manual vacuuming, see &lt;a href=&quot;routine-vacuuming&quot;&gt;Section 24.1&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLには、定期的な真空メンテナンスを自動化できる「autovacuum」機能が含まれています。自動および手動バキュームの詳細については、&lt;a href=&quot;routine-vacuuming&quot;&gt;セクション24.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ffa60848047cd6b07df3ba1987237f159ca48b0a" translate="yes" xml:space="preserve">
          <source>PostgreSQL includes an implementation of the standard btree (multi-way balanced tree) index data structure. Any data type that can be sorted into a well-defined linear order can be indexed by a btree index. The only limitation is that an index entry cannot exceed approximately one-third of a page (after TOAST compression, if applicable).</source>
          <target state="translated">PostgreSQLには、標準のbtree(多元バランスツリー)インデックスデータ構造の実装が含まれています。十分に定義された直線的な順序に並べ替えることができるデータ型はすべて、btreeインデックスによってインデックス化することができます。唯一の制限は、インデックス項目がページの約3分の1を超えることができないということです(該当する場合はTOAST圧縮後)。</target>
        </trans-unit>
        <trans-unit id="821fe06f71c1808348a7b91e09179799740b9a95" translate="yes" xml:space="preserve">
          <source>PostgreSQL is a &lt;em&gt;relational database management system&lt;/em&gt; (RDBMS). That means it is a system for managing data stored in &lt;em&gt;relations&lt;/em&gt;. Relation is essentially a mathematical term for &lt;em&gt;table&lt;/em&gt;. The notion of storing data in tables is so commonplace today that it might seem inherently obvious, but there are a number of other ways of organizing databases. Files and directories on Unix-like operating systems form an example of a hierarchical database. A more modern development is the object-oriented database.</source>
          <target state="translated">PostgreSQLは、&lt;em&gt;リレーショナルデータベース管理システム&lt;/em&gt;（RDBMS）です。つまり、&lt;em&gt;リレーションに&lt;/em&gt;保存されているデータを管理するシステムです。 Relationは、本質的には&lt;em&gt;tableの&lt;/em&gt;数学的用語です。データをテーブルに格納するという概念は今日では一般的であるので、本質的に明白に思えるかもしれませんが、データベースを編成する方法は他にもいくつかあります。 Unixライクなオペレーティングシステム上のファイルとディレクトリは、階層型データベースの例です。より最近の開発はオブジェクト指向データベースです。</target>
        </trans-unit>
        <trans-unit id="9cfd426182152d61be1e2778a072f15bc552fcab" translate="yes" xml:space="preserve">
          <source>PostgreSQL is implemented using a simple &amp;ldquo;process per user&amp;rdquo; client/server model. In this model there is one &lt;em&gt;client process&lt;/em&gt; connected to exactly one &lt;em&gt;server process&lt;/em&gt;. As we do not know ahead of time how many connections will be made, we have to use a &lt;em&gt;master process&lt;/em&gt; that spawns a new server process every time a connection is requested. This master process is called &lt;code&gt;postgres&lt;/code&gt; and listens at a specified TCP/IP port for incoming connections. Whenever a request for a connection is detected the &lt;code&gt;postgres&lt;/code&gt; process spawns a new server process. The server tasks communicate with each other using &lt;em&gt;semaphores&lt;/em&gt; and &lt;em&gt;shared memory&lt;/em&gt; to ensure data integrity throughout concurrent data access.</source>
          <target state="translated">PostgreSQLは、単純な「ユーザーごとのプロセス」クライアント/サーバーモデルを使用して実装されます。このモデルでは、1つの&lt;em&gt;クライアントプロセス&lt;/em&gt;が1つの&lt;em&gt;サーバープロセスに&lt;/em&gt;接続されてい&lt;em&gt;ます&lt;/em&gt;。事前に接続の数がわからないため、接続が要求されるたびに新しいサーバープロセスを生成する&lt;em&gt;マスタープロセス&lt;/em&gt;を使用する必要があります。このマスタープロセスは &lt;code&gt;postgres&lt;/code&gt; と呼ばれ、指定されたTCP / IPポートで着信接続をリッスンします。接続の要求が検出されるたびに、 &lt;code&gt;postgres&lt;/code&gt; プロセスは新しいサーバープロセスを生成します。サーバータスクは、&lt;em&gt;セマフォ&lt;/em&gt;と&lt;em&gt;共有メモリ&lt;/em&gt;を使用して相互に通信し&lt;em&gt;ます。&lt;/em&gt; 同時データアクセス全体でデータの整合性を確保するため。</target>
        </trans-unit>
        <trans-unit id="e5b0c6c6215c78ea032d3a013c7f4ae434fd6519" translate="yes" xml:space="preserve">
          <source>PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See &lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;Appendix B&lt;/a&gt; for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.</source>
          <target state="translated">PostgreSQLは、SQL標準が要求するよりも柔軟に日付/時刻入力を処理できます。日付/時刻入力の正確な解析規則と、月、曜日、およびタイムゾーンを含む認識されるテキストフィールドについては、&lt;a href=&quot;https://www.postgresql.org/docs/12/datetime-appendix.html&quot;&gt;付録B&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c828eb4cf5a62919aaf9e56822812dfeb42eacd5" translate="yes" xml:space="preserve">
          <source>PostgreSQL is very extensible and allows new data types, functions, operators and other database objects to be defined; see &lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;Chapter 37&lt;/a&gt;. In fact the built-in objects are implemented using nearly the same mechanisms. This extensibility implies some overhead, for example due to function calls (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt;). To reduce that overhead, JIT compilation can inline the bodies of small functions into the expressions using them. That allows a significant percentage of the overhead to be optimized away.</source>
          <target state="translated">PostgreSQLは非常に拡張性が高く、新しいデータ型、関数、演算子、その他のデータベースオブジェクトを定義できます。&lt;a href=&quot;https://www.postgresql.org/docs/12/extend.html&quot;&gt;第37章を&lt;/a&gt;参照してください。実際、組み込みオブジェクトは、ほぼ同じメカニズムを使用して実装されています。この拡張性は、たとえば関数呼び出し（&lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;セクション37.3を&lt;/a&gt;参照）が原因で、ある程度のオーバーヘッドを意味します。そのオーバーヘッドを削減するために、JITコンパイルは、小さな関数の本体をそれらを使用する式にインライン化できます。これにより、オーバーヘッドのかなりの部分を最適化することができます。</target>
        </trans-unit>
        <trans-unit id="66bf58dffda176b2af709bb0e9bb018d0b319b34" translate="yes" xml:space="preserve">
          <source>PostgreSQL lets you reference columns of other tables in the &lt;code&gt;WHERE&lt;/code&gt; condition by specifying the other tables in the &lt;code&gt;USING&lt;/code&gt; clause. For example, to delete all films produced by a given producer, one can do:</source>
          <target state="translated">PostgreSQLでは、 &lt;code&gt;USING&lt;/code&gt; 句で他のテーブルを指定することにより、 &lt;code&gt;WHERE&lt;/code&gt; 条件で他のテーブルの列を参照できます。たとえば、特定のプロデューサーが制作したすべての映画を削除するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="575317fbf767c3750ee89eec8e188302800f4189" translate="yes" xml:space="preserve">
          <source>PostgreSQL makes use of symbolic links to simplify the implementation of tablespaces. This means that tablespaces can be used &lt;em&gt;only&lt;/em&gt; on systems that support symbolic links.</source>
          <target state="translated">PostgreSQLはシンボリックリンクを利用して、テーブルスペースの実装を簡素化します。つまり、テーブルスペースはシンボリックリンクをサポートするシステムで&lt;em&gt;のみ&lt;/em&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="c0ca6dd2831d7be94912fd0050870a1cb327936d" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers a way to specify how to divide a table into pieces called partitions. The table that is divided is referred to as a &lt;em&gt;partitioned table&lt;/em&gt;. The specification consists of the &lt;em&gt;partitioning method&lt;/em&gt; and a list of columns or expressions to be used as the &lt;em&gt;partition key&lt;/em&gt;.</source>
          <target state="translated">PostgreSQLは、テーブルをパーティションと呼ばれる部分に分割する方法を指定する方法を提供します。分割された&lt;em&gt;テーブル&lt;/em&gt;は、&lt;em&gt;パーティションテーブル&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。仕様は、&lt;em&gt;パーティション化方法&lt;/em&gt;と、&lt;em&gt;パーティションキー&lt;/em&gt;として使用される列または式のリストで構成され&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="891f5d2a022ddd1dd671a070027ea1cff8f75e34" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers built-in support for the following forms of partitioning:</source>
          <target state="translated">PostgreSQLは以下の形式のパーティショニングをビルトインでサポートしています。</target>
        </trans-unit>
        <trans-unit id="5662adc70468d34652ede9f811304c570cee30e3" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses, as shown in &lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;Table 8.21&lt;/a&gt;. It is better to use these types instead of plain text types to store network addresses, because these types offer input error checking and specialized operators and functions (see &lt;a href=&quot;functions-net&quot;&gt;Section 9.12&lt;/a&gt;).</source>
          <target state="translated">PostgreSQLは、&lt;a href=&quot;datatype-net-types#DATATYPE-NET-TYPES-TABLE&quot;&gt;表8.21に&lt;/a&gt;示すように、IPv4、IPv6、およびMACアドレスを格納するデータ型を提供します。これらのタイプは入力エラーチェックと特殊な演算子および関数を提供するため（&lt;a href=&quot;functions-net&quot;&gt;セクション9.12を&lt;/a&gt;参照）、プレーンテキストタイプの代わりにこれらのタイプを使用してネットワークアドレスを格納することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="84c215e752220c438a12a8423b6fe5998d9faf4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers encryption at several levels, and provides flexibility in protecting data from disclosure due to database server theft, unscrupulous administrators, and insecure networks. Encryption might also be required to secure sensitive data such as medical records or financial transactions.</source>
          <target state="translated">PostgreSQLはいくつかのレベルで暗号化を提供し、データベースサーバの盗難、不正な管理者、安全でないネットワークによるデータの漏洩からデータを保護する柔軟性を提供します。また、医療記録や金融取引などの機密データを保護するために暗号化が必要な場合もあります。</target>
        </trans-unit>
        <trans-unit id="69f5fb450ee35fca9053db0e9cf0fee2e325d788" translate="yes" xml:space="preserve">
          <source>PostgreSQL offers two types for storing JSON data: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt;. To implement efficient query mechanisms for these data types, PostgreSQL also provides the &lt;code&gt;jsonpath&lt;/code&gt; data type described in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLは、JSONデータを格納するために &lt;code&gt;json&lt;/code&gt; と &lt;code&gt;jsonb&lt;/code&gt; の 2つのタイプを提供します。これらのデータ型に対して効率的なクエリメカニズムを実装するために、PostgreSQL は&lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;セクション8.14.6で&lt;/a&gt;説明されている &lt;code&gt;jsonpath&lt;/code&gt; データ型も提供しています。</target>
        </trans-unit>
        <trans-unit id="926dbd334c49f127c9efe79cdb0a9983f9b87b3a" translate="yes" xml:space="preserve">
          <source>PostgreSQL only allows the execution of a user-defined function for the triggered action. The standard allows the execution of a number of other SQL commands, such as &lt;code&gt;CREATE TABLE&lt;/code&gt;, as the triggered action. This limitation is not hard to work around by creating a user-defined function that executes the desired commands.</source>
          <target state="translated">PostgreSQLは、トリガーされたアクションに対してユーザー定義関数の実行のみを許可します。標準では、トリガーされたアクションとして、 &lt;code&gt;CREATE TABLE&lt;/code&gt; などの他のいくつかのSQLコマンドを実行できます。この制限は、目的のコマンドを実行するユーザー定義関数を作成することで回避するのは難しくありません。</target>
        </trans-unit>
        <trans-unit id="43083b6336b02575039a2d9d8f76b5988935b20e" translate="yes" xml:space="preserve">
          <source>PostgreSQL procedural language libraries can be preloaded in this way, typically by using the syntax &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; where &lt;code&gt;XXX&lt;/code&gt; is &lt;code&gt;pgsql&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt;, &lt;code&gt;tcl&lt;/code&gt;, or &lt;code&gt;python&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL手続き型言語ライブラリは、この方法でプリロードできます。通常、構文 &lt;code&gt;'$libdir/plXXX'&lt;/code&gt; を使用します。ここで、 &lt;code&gt;XXX&lt;/code&gt; は &lt;code&gt;pgsql&lt;/code&gt; 、 &lt;code&gt;perl&lt;/code&gt; 、 &lt;code&gt;tcl&lt;/code&gt; 、または &lt;code&gt;python&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f59dd80e652539f7d5e5bc6cc2d156491128c008" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a JIT implementation based on LLVM. The interface to the JIT provider is pluggable and the provider can be changed without recompiling (although currently, the build process only provides inlining support data for LLVM). The active provider is chosen via the setting &lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLはLLVMに基づくJIT実装を提供します。JITプロバイダーへのインターフェースはプラグ可能であり、プロバイダーは再コンパイルせずに変更できます（現在、ビルドプロセスはLLVMのインラインサポートデータのみを提供しています）。アクティブなプロバイダーは&lt;a href=&quot;runtime-config-client#GUC-JIT-PROVIDER&quot;&gt;jit_provider&lt;/a&gt;の設定で選択されます。</target>
        </trans-unit>
        <trans-unit id="fe91789313046ec6475705a372e78ba71b0024c0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a function to inspect complex statistics defined using the &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command.</source>
          <target state="translated">PostgreSQLは、 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; コマンドを使用して定義された複雑な統計を検査する機能を提供します。</target>
        </trans-unit>
        <trans-unit id="46fdddf06cc7902f32855be5f7713801b1905af6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a means for creating locks that have application-defined meanings. These are called &lt;em&gt;advisory locks&lt;/em&gt;, because the system does not enforce their use &amp;mdash; it is up to the application to use them correctly. Advisory locks can be useful for locking strategies that are an awkward fit for the MVCC model. For example, a common use of advisory locks is to emulate pessimistic locking strategies typical of so-called &amp;ldquo;flat file&amp;rdquo; data management systems. While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session.</source>
          <target state="translated">PostgreSQLは、アプリケーション定義の意味を持つロックを作成する手段を提供します。これらは、システムが強制的に使用しないため、&lt;em&gt;アドバイザリロック&lt;/em&gt;と呼ばれます。これらを正しく使用するかどうかは、アプリケーション次第です。アドバイザリロックは、MVCCモデルに適合しないロック戦略に役立ちます。たとえば、アドバイザリロックの一般的な用途は、いわゆる「フラットファイル」データ管理システムに典型的な悲観的ロック戦略をエミュレートすることです。テーブルに格納されたフラグを同じ目的で使用することもできますが、アドバイザリロックの方が高速で、テーブルの膨張を回避し、セッションの終了時にサーバーによって自動的にクリーンアップされます。</target>
        </trans-unit>
        <trans-unit id="0cfb1fbdc7aff0cefa972216042683bcba69e5d6" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a number of functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction:</source>
          <target state="translated">PostgreSQLは、現在の日付と時刻に関連する値を返す多くの関数を提供しています。これらのSQL標準関数はすべて、現在のトランザクションの開始時刻に基づいた値を返します。</target>
        </trans-unit>
        <trans-unit id="b4d4d96a6016bf1a3419a8adde28df6d7f17d284" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a rich set of tools for developers to manage concurrent access to data. Internally, data consistency is maintained by using a multiversion model (Multiversion Concurrency Control, MVCC). This means that each SQL statement sees a snapshot of data (a &lt;em&gt;database version&lt;/em&gt;) as it was some time ago, regardless of the current state of the underlying data. This prevents statements from viewing inconsistent data produced by concurrent transactions performing updates on the same data rows, providing &lt;em&gt;transaction isolation&lt;/em&gt; for each database session. MVCC, by eschewing the locking methodologies of traditional database systems, minimizes lock contention in order to allow for reasonable performance in multiuser environments.</source>
          <target state="translated">PostgreSQLは、開発者がデータへの同時アクセスを管理するための豊富なツールセットを提供します。内部的には、マルチバージョンモデル（Multiversion Concurrency Control、MVCC）を使用してデータの整合性が維持されます。つまり、各SQLステートメントは、基礎となるデータの現在の状態に関係なく、少し前のデータ（&lt;em&gt;データベースバージョン&lt;/em&gt;）のスナップショットを参照します。これにより、ステートメントが同じデータ行で更新を実行する同時トランザクションによって生成された不整合なデータを表示するのを防ぎ、各データベースセッションに&lt;em&gt;トランザクションの分離&lt;/em&gt;を提供します。 MVCCは、従来のデータベースシステムのロック方法論を回避することで、ロックの競合を最小限に抑え、マルチユーザー環境で妥当なパフォーマンスを実現します。</target>
        </trans-unit>
        <trans-unit id="1ecdd68232ab41018a2aebf2b36bf6bfee6f90a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides a set of default roles which provide access to certain, commonly needed, privileged capabilities and information. Administrators can GRANT these roles to users and/or other roles in their environment, providing those users with access to the specified capabilities and information.</source>
          <target state="translated">PostgreSQLは、特定の、一般的に必要とされる、特権的な機能や情報へのアクセスを提供するデフォルトのロールのセットを提供しています。管理者は、これらのロールをユーザや環境内の他のロールに付与することができ、指定された機能や情報へのアクセスをユーザに提供することができます。</target>
        </trans-unit>
        <trans-unit id="12a7e7c8c66bad39574adedb86e60a5508ed2a12" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides facilities to support dynamic tracing of the database server. This allows an external utility to be called at specific points in the code and thereby trace execution.</source>
          <target state="translated">PostgreSQLはデータベースサーバの動的トレースをサポートする機能を提供します。これにより、コードの特定のポイントで外部ユーティリティを呼び出すことができ、それによって実行をトレースすることができます。</target>
        </trans-unit>
        <trans-unit id="93788cdb40903d97aaf58bdd1f296a2d0af57e6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides predefined dictionaries for many languages. There are also several predefined templates that can be used to create new dictionaries with custom parameters. Each predefined dictionary template is described below. If no existing template is suitable, it is possible to create new ones; see the &lt;code&gt;contrib/&lt;/code&gt; area of the PostgreSQL distribution for examples.</source>
          <target state="translated">PostgreSQLは、多くの言語用に事前定義された辞書を提供しています。カスタムパラメータを使用して新しい辞書を作成するために使用できる定義済みのテンプレートもいくつかあります。定義済みの各ディクショナリテンプレートについて、以下で説明します。適切な既存のテンプレートがない場合は、新しいテンプレートを作成できます。例については、PostgreSQLディストリビューションの &lt;code&gt;contrib/&lt;/code&gt; エリアを参照してください。</target>
        </trans-unit>
        <trans-unit id="abe4b5b2c2d17d1440228c909b7105d20d3d03a0" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several features for breaking down complex &lt;code&gt;postgresql.conf&lt;/code&gt; files into sub-files. These features are especially useful when managing multiple servers with related, but not identical, configurations.</source>
          <target state="translated">PostgreSQLは、複雑な &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルをサブファイルに分解するためのいくつかの機能を提供します。これらの機能は、関連しているが同一ではない構成を持つ複数のサーバーを管理する場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="12ddc3899973df221c8322e34a526586b23ebfaa" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST, GIN and BRIN. Each index type uses a different algorithm that is best suited to different types of queries. By default, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command creates B-tree indexes, which fit the most common situations.</source>
          <target state="translated">PostgreSQLは、Bツリー、ハッシュ、GiST、SP-GiST、GIN、およびBRINのいくつかのインデックスタイプを提供します。各インデックスタイプは、さまざまなタイプのクエリに最適な異なるアルゴリズムを使用します。デフォルトでは、 &lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドは、最も一般的な状況に適合するBツリーインデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="4d643a989351582bdcc707ed3905be058a733c4a" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides storage and comparison functions for UUIDs, but the core database does not include any function for generating UUIDs, because no single algorithm is well suited for every application. The &lt;a href=&quot;uuid-ossp&quot;&gt;uuid-ossp&lt;/a&gt; module provides functions that implement several standard algorithms. The &lt;a href=&quot;pgcrypto&quot;&gt;pgcrypto&lt;/a&gt; module also provides a generation function for random UUIDs. Alternatively, UUIDs could be generated by client applications or other libraries invoked through a server-side function.</source>
          <target state="translated">PostgreSQLはUUIDの保存および比較関数を提供しますが、コアデータベースにはUUIDを生成するための関数が含まれていません。これは、すべてのアプリケーションに適した単一のアルゴリズムがないためです。&lt;a href=&quot;uuid-ossp&quot;&gt;UUID-OSSPの&lt;/a&gt;モジュールは、いくつかの標準的なアルゴリズムを実装する機能を提供します。&lt;a href=&quot;pgcrypto&quot;&gt;pgcryptoの&lt;/a&gt;モジュールは、ランダムのUUIDの生成機能を提供します。または、サーバー側の関数を介して呼び出されるクライアントアプリケーションまたは他のライブラリによってUUIDを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="a8055d8a3fe512bf9a836cadb5eae9c2e8b86c5c" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the function &lt;code&gt;to_tsvector&lt;/code&gt; for converting a document to the &lt;code&gt;tsvector&lt;/code&gt; data type.</source>
          <target state="translated">PostgreSQLは、ドキュメントを &lt;code&gt;tsvector&lt;/code&gt; データ型に変換するための関数 &lt;code&gt;to_tsvector&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="987c367c1a1efc0cb03cfb3dd34409cf91adaf69" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, &lt;code&gt;phraseto_tsquery&lt;/code&gt; and &lt;code&gt;websearch_to_tsquery&lt;/code&gt; for converting a query to the &lt;code&gt;tsquery&lt;/code&gt; data type. &lt;code&gt;to_tsquery&lt;/code&gt; offers access to more features than either &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;phraseto_tsquery&lt;/code&gt;, but it is less forgiving about its input. &lt;code&gt;websearch_to_tsquery&lt;/code&gt; is a simplified version of &lt;code&gt;to_tsquery&lt;/code&gt; with an alternative syntax, similar to the one used by web search engines.</source>
          <target state="translated">PostgreSQLは関数提供 &lt;code&gt;to_tsquery&lt;/code&gt; 、 &lt;code&gt;plainto_tsquery&lt;/code&gt; 、 &lt;code&gt;phraseto_tsquery&lt;/code&gt; と &lt;code&gt;websearch_to_tsquery&lt;/code&gt; にクエリを変換するため &lt;code&gt;tsquery&lt;/code&gt; データ型。 &lt;code&gt;to_tsquery&lt;/code&gt; は、 &lt;code&gt;plainto_tsquery&lt;/code&gt; や &lt;code&gt;phraseto_tsquery&lt;/code&gt; よりも多くの機能へのアクセスを提供しますが、その入力に関して寛容ではありません。 &lt;code&gt;websearch_to_tsquery&lt;/code&gt; はの簡易版である &lt;code&gt;to_tsquery&lt;/code&gt; ウェブ検索エンジンで使用されるものに似た代替構文を持ちます。</target>
        </trans-unit>
        <trans-unit id="d433b9e1cb0cc5f1366352a11ce9410f17e6d0fd" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the index methods B-tree, hash, GiST, SP-GiST, GIN, and BRIN. Users can also define their own index methods, but that is fairly complicated.</source>
          <target state="translated">PostgreSQLは、B-tree、hash、GiST、SP-GiST、GIN、BRINのインデックスメソッドを提供しています。ユーザは独自のインデックスメソッドを定義することもできますが、これはかなり複雑です。</target>
        </trans-unit>
        <trans-unit id="bed8f31d13fc879249d79e50cd113d8dd0d3c306" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides the standard SQL type &lt;code&gt;boolean&lt;/code&gt;; see &lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;Table 8.19&lt;/a&gt;. The &lt;code&gt;boolean&lt;/code&gt; type can have several states: &amp;ldquo;true&amp;rdquo;, &amp;ldquo;false&amp;rdquo;, and a third state, &amp;ldquo;unknown&amp;rdquo;, which is represented by the SQL null value.</source>
          <target state="translated">PostgreSQLは標準のSQL型 &lt;code&gt;boolean&lt;/code&gt; を提供します。&lt;a href=&quot;datatype-boolean#DATATYPE-BOOLEAN-TABLE&quot;&gt;表8.19を&lt;/a&gt;参照してください。 &lt;code&gt;boolean&lt;/code&gt; 「真」、「偽」、およびSQLのNULL値で表される第3の状態、「不明」、：タイプは、いくつかの状態を持つことができます。</target>
        </trans-unit>
        <trans-unit id="112d712cbd3f4abfdabfc159cdc6a3584db95c15" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides three SQL commands to establish configuration defaults. The already-mentioned &lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt; command provides a SQL-accessible means of changing global defaults; it is functionally equivalent to editing &lt;code&gt;postgresql.conf&lt;/code&gt;. In addition, there are two commands that allow setting of defaults on a per-database or per-role basis:</source>
          <target state="translated">PostgreSQLには、構成のデフォルトを確立するための3つのSQLコマンドが用意されています。すでに述べた&lt;a href=&quot;sql-altersystem&quot;&gt;ALTER SYSTEM&lt;/a&gt;コマンドは、グローバルデフォルトを変更するSQLアクセス可能な手段を提供します。機能的には、 &lt;code&gt;postgresql.conf&lt;/code&gt; を編集することと同じです。さらに、データベースごとまたはロールごとにデフォルトを設定できる2つのコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="d071c1667c54c5d765a697ea20deb60db45601b3" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two data types that are designed to support full text search, which is the activity of searching through a collection of natural-language &lt;em&gt;documents&lt;/em&gt; to locate those that best match a &lt;em&gt;query&lt;/em&gt;. The &lt;code&gt;tsvector&lt;/code&gt; type represents a document in a form optimized for text search; the &lt;code&gt;tsquery&lt;/code&gt; type similarly represents a text query. &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; provides a detailed explanation of this facility, and &lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt; summarizes the related functions and operators.</source>
          <target state="translated">PostgreSQLは、全文検索をサポートするように設計された2つのデータ型を提供します。これは、自然言語&lt;em&gt;ドキュメントの&lt;/em&gt;コレクションを検索して、&lt;em&gt;クエリに&lt;/em&gt;最も一致する&lt;em&gt;ドキュメント&lt;/em&gt;を見つけるアクティビティです。 &lt;code&gt;tsvector&lt;/code&gt; タイプは、テキスト検索用に最適化された形式で文書を表し、 &lt;code&gt;tsquery&lt;/code&gt; タイプも同様にテキストクエリを表します。&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;はこの機能の詳細な説明を提供し、&lt;a href=&quot;functions-textsearch&quot;&gt;セクション9.13&lt;/a&gt;は関連する関数と演算子を要約します。</target>
        </trans-unit>
        <trans-unit id="8d5de0e98d735e8c10c90f072b5e772ac6f8ca44" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides two functions introduced in SQL:2006, but in variants that use the XPath 1.0 language, rather than XML Query as specified for them in the standard.</source>
          <target state="translated">PostgreSQLはSQL:2006で導入された2つの関数を提供していますが、標準で指定されているXMLクエリではなく、XPath 1.0言語を使用しています。</target>
        </trans-unit>
        <trans-unit id="6e29f8f292e01eb034e6335e7938f34ec555db8f" translate="yes" xml:space="preserve">
          <source>PostgreSQL provides various lock modes to control concurrent access to data in tables. These modes can be used for application-controlled locking in situations where MVCC does not give the desired behavior. Also, most PostgreSQL commands automatically acquire locks of appropriate modes to ensure that referenced tables are not dropped or modified in incompatible ways while the command executes. (For example, &lt;code&gt;TRUNCATE&lt;/code&gt; cannot safely be executed concurrently with other operations on the same table, so it obtains an exclusive lock on the table to enforce that.)</source>
          <target state="translated">PostgreSQLは、テーブル内のデータへの同時アクセスを制御するさまざまなロックモードを提供します。これらのモードは、MVCCが望ましい動作を行わない状況で、アプリケーション制御のロックに使用できます。また、ほとんどのPostgreSQLコマンドは、適切なモードのロックを自動的に取得して、コマンドの実行中に参照テーブルが互換性のない方法で削除または変更されないようにします。 （たとえば、 &lt;code&gt;TRUNCATE&lt;/code&gt; は同じテーブルで他の操作と同時に安全に実行できないため、強制的にテーブルに排他ロックを取得します。）</target>
        </trans-unit>
        <trans-unit id="aca67cd10f6b55fba07fefeab32464592e84bd50" translate="yes" xml:space="preserve">
          <source>PostgreSQL reads the system-wide OpenSSL configuration file. By default, this file is named &lt;code&gt;openssl.cnf&lt;/code&gt; and is located in the directory reported by &lt;code&gt;openssl version -d&lt;/code&gt;. This default can be overridden by setting environment variable &lt;code&gt;OPENSSL_CONF&lt;/code&gt; to the name of the desired configuration file.</source>
          <target state="translated">PostgreSQLはシステム全体のOpenSSL構成ファイルを読み取ります。デフォルトでは、このファイルは &lt;code&gt;openssl.cnf&lt;/code&gt; という名前で、 &lt;code&gt;openssl version -d&lt;/code&gt; によって報告されるディレクトリにあります。このデフォルトは、環境変数 &lt;code&gt;OPENSSL_CONF&lt;/code&gt; を目的の構成ファイルの名前に設定することで上書きできます。</target>
        </trans-unit>
        <trans-unit id="0e141c534293f75601bff1fea667fc64a4f6c7d7" translate="yes" xml:space="preserve">
          <source>PostgreSQL recognizes functional dependency (allowing columns to be omitted from &lt;code&gt;GROUP BY&lt;/code&gt;) only when a table's primary key is included in the &lt;code&gt;GROUP BY&lt;/code&gt; list. The SQL standard specifies additional conditions that should be recognized.</source>
          <target state="translated">PostgreSQLは、テーブルの主キーが &lt;code&gt;GROUP BY&lt;/code&gt; リストに含まれている場合にのみ、機能の依存関係を認識します（列を &lt;code&gt;GROUP BY&lt;/code&gt; から省略できます）。SQL標準では、認識すべき追加の条件が指定されています。</target>
        </trans-unit>
        <trans-unit id="d151da8167491478df86aef81ab6d8ffea35f9fb" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases before 7.4 used a different binary file format.</source>
          <target state="translated">7.4以前のPostgreSQLのリリースでは、異なるバイナリファイル形式を使用していました。</target>
        </trans-unit>
        <trans-unit id="b128f368f0a60d65746b559a252c4dc977c1b44f" translate="yes" xml:space="preserve">
          <source>PostgreSQL releases prior to 8.1 would accept queries of this form, and add an implicit entry to the query's &lt;code&gt;FROM&lt;/code&gt; clause for each table referenced by the query. This is no longer allowed.</source>
          <target state="translated">8.1より前のPostgreSQLリリースは、この形式のクエリを受け入れ、クエリによって参照される各テーブルのクエリの &lt;code&gt;FROM&lt;/code&gt; 句に暗黙のエントリを追加します。これは許可されなくなりました。</target>
        </trans-unit>
        <trans-unit id="63fb6169ba8a1a0f974f4aea96b8b4aa6c3f1759" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires a few bytes of System V shared memory (typically 48 bytes, on 64-bit platforms) for each copy of the server. On most modern operating systems, this amount can easily be allocated. However, if you are running many copies of the server or you explicitly configure the server to use large amounts of System V shared memory (see &lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt; and &lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_type&lt;/a&gt;), it may be necessary to increase &lt;code&gt;SHMALL&lt;/code&gt;, which is the total amount of System V shared memory system-wide. Note that &lt;code&gt;SHMALL&lt;/code&gt; is measured in pages rather than bytes on many systems.</source>
          <target state="translated">PostgreSQLでは、サーバーのコピーごとに数バイトのSystem V共有メモリ（通常、64ビットプラットフォームでは48バイト）が必要です。最近のほとんどのオペレーティングシステムでは、この量を簡単に割り当てることができます。ただし、サーバーの多数のコピーを実行している場合、または大量のSystem V共有メモリを使用するようにサーバーを明示的に構成している場合（&lt;a href=&quot;runtime-config-resource#GUC-SHARED-MEMORY-TYPE&quot;&gt;shared_memory_type&lt;/a&gt;および&lt;a href=&quot;runtime-config-resource#GUC-DYNAMIC-SHARED-MEMORY-TYPE&quot;&gt;dynamic_shared_memory_typeを&lt;/a&gt;参照）、System V共有の合計量である &lt;code&gt;SHMALL&lt;/code&gt; を増やす必要がある場合があります。システム全体のメモリ。多くのシステムでは、 &lt;code&gt;SHMALL&lt;/code&gt; はバイト単位ではなくページ単位で測定されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c2c20c79653dcae8f8fc047710211c040521d5bc" translate="yes" xml:space="preserve">
          <source>PostgreSQL requires the operating system to provide inter-process communication (IPC) features, specifically shared memory and semaphores. Unix-derived systems typically provide &amp;ldquo;System V&amp;rdquo; IPC, &amp;ldquo;POSIX&amp;rdquo; IPC, or both. Windows has its own implementation of these features and is not discussed here.</source>
          <target state="translated">PostgreSQLでは、オペレーティングシステムにプロセス間通信（IPC）機能、特に共有メモリとセマフォを提供する必要があります。Unix派生システムは、通常、「System V」IPC、「POSIX」IPC、またはその両方を提供します。Windowsにはこれらの機能の独自の実装があり、ここでは説明しません。</target>
        </trans-unit>
        <trans-unit id="36d337a94d7ba7a46b07377e19460ac78dd155d2" translate="yes" xml:space="preserve">
          <source>PostgreSQL streaming replication is asynchronous by default. If the primary server crashes then some transactions that were committed may not have been replicated to the standby server, causing data loss. The amount of data loss is proportional to the replication delay at the time of failover.</source>
          <target state="translated">PostgreSQLストリーミングレプリケーションはデフォルトでは非同期です。プライマリサーバがクラッシュした場合、コミットされたトランザクションの一部が待機サーバにレプリケートされていない可能性があり、データ損失の原因となります。データ損失の量は、フェイルオーバー時のレプリケーション遅延に比例します。</target>
        </trans-unit>
        <trans-unit id="7c42d1cce1b2b6028e2490c0570386d5f856bca2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports a powerful &lt;em&gt;rule system&lt;/em&gt; for the specification of &lt;em&gt;views&lt;/em&gt; and ambiguous &lt;em&gt;view updates&lt;/em&gt;. Originally the PostgreSQL rule system consisted of two implementations:</source>
          <target state="translated">PostgreSQLは、&lt;em&gt;ビューの指定&lt;/em&gt;とあいまいな&lt;em&gt;ビューの更新の&lt;/em&gt;ための強力な&lt;em&gt;ルールシステム&lt;/em&gt;をサポートしてい&lt;em&gt;ます&lt;/em&gt;。もともとPostgreSQLルールシステムは、2つの実装で構成されていました。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2241743d9fa8eb9bf19ded10e2bc6c68ceaf9df2" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports automatic character set conversion between server and client for certain character set combinations. The conversion information is stored in the &lt;code&gt;pg_conversion&lt;/code&gt; system catalog. PostgreSQL comes with some predefined conversions, as shown in &lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;Table 23.2&lt;/a&gt;. You can create a new conversion using the SQL command &lt;code&gt;CREATE CONVERSION&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLは、特定の文字セットの組み合わせについて、サーバーとクライアント間の自動文字セット変換をサポートしています。変換情報は、 &lt;code&gt;pg_conversion&lt;/code&gt; システムカタログに格納されます。 PostgreSQLには、&lt;a href=&quot;multibyte#MULTIBYTE-TRANSLATION-TABLE&quot;&gt;表23.2に&lt;/a&gt;示すように、いくつかの定義済みの変換が付属しています。 SQLコマンド &lt;code&gt;CREATE CONVERSION&lt;/code&gt; を使用して、新しい変換を作成できます。</target>
        </trans-unit>
        <trans-unit id="a7c3b9018391e76aa16042a998f014061b76d5bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design.</source>
          <target state="translated">PostgreSQLは基本的なテーブル分割をサポートしています。この項では、データベース設計の一部としてパーティショニングを実装する理由と方法について説明します。</target>
        </trans-unit>
        <trans-unit id="1e97f638eb1274873aa3e4e622cb72d93b7b7f24" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;CREATE INDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.</source>
          <target state="translated">PostgreSQLは書き込みをロックアウトせずにインデックスの構築をサポートしています。このメソッドは、 &lt;code&gt;CREATE INDEX&lt;/code&gt; の &lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションを指定することによって呼び出されます。このオプションを使用する場合、PostgreSQLはテーブルの2つのスキャンを実行する必要があり、さらに、インデックスを変更または使用する可能性のある既存のトランザクションがすべて終了するまで待機する必要があります。したがって、この方法では、標準のインデックス作成よりも多くの作業が必要であり、完了するまでに大幅に時間がかかります。ただし、インデックスが作成されている間も通常の操作を続行できるため、この方法は本番環境に新しいインデックスを追加する場合に役立ちます。もちろん、インデックスの作成によってCPUとI / Oの負荷が増えると、他の操作が遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf603007c3689d71b489ed77c1b75a8fa44bed1c" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports parallel aggregation by aggregating in two stages. First, each process participating in the parallel portion of the query performs an aggregation step, producing a partial result for each group of which that process is aware. This is reflected in the plan as a &lt;code&gt;Partial Aggregate&lt;/code&gt; node. Second, the partial results are transferred to the leader via &lt;code&gt;Gather&lt;/code&gt; or &lt;code&gt;Gather Merge&lt;/code&gt;. Finally, the leader re-aggregates the results across all workers in order to produce the final result. This is reflected in the plan as a &lt;code&gt;Finalize Aggregate&lt;/code&gt; node.</source>
          <target state="translated">PostgreSQLは、2段階で集計することにより、並列集計をサポートしています。まず、クエリの並列部分に参加している各プロセスが集計ステップを実行し、そのプロセスが認識しているグループごとに部分的な結果を生成します。これは &lt;code&gt;Partial Aggregate&lt;/code&gt; ノードとして計画に反映されます。次に、部分的な結果が &lt;code&gt;Gather&lt;/code&gt; または &lt;code&gt;Gather Merge&lt;/code&gt; を介してリーダーに転送されます。最後に、リーダーは、最終結果を生成するために、すべてのワーカーにわたって結果を再集計します。これは、 &lt;code&gt;Finalize Aggregate&lt;/code&gt; ノードとして計画に反映されます。</target>
        </trans-unit>
        <trans-unit id="98c96f2dead7b89b38c3c2461ff7cd5a4376ae6d" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports rebuilding indexes with minimum locking of writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;REINDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table for each index that needs to be rebuilt and wait for termination of all existing transactions that could potentially use the index. This method requires more total work than a standard index rebuild and takes significantly longer to complete as it needs to wait for unfinished transactions that might modify the index. However, since it allows normal operations to continue while the index is being rebuilt, this method is useful for rebuilding indexes in a production environment. Of course, the extra CPU, memory and I/O load imposed by the index rebuild may slow down other operations.</source>
          <target state="translated">PostgreSQLは、書き込みの最小限のロックでインデックスの再構築をサポートします。このメソッドは、 &lt;code&gt;REINDEX&lt;/code&gt; の &lt;code&gt;CONCURRENTLY&lt;/code&gt; オプションを指定することによって呼び出されます。このオプションを使用する場合、PostgreSQLは再構築する必要のあるインデックスごとにテーブルの2つのスキャンを実行し、インデックスを使用する可能性のある既存のトランザクションがすべて終了するまで待機する必要があります。この方法では、標準的なインデックスの再構築よりも多くの作業が必要であり、インデックスを変更する可能性のある未完了のトランザクションを待機する必要があるため、完了までにかなり時間がかかります。ただし、インデックスを再構築している間も通常の操作を続行できるため、この方法は本番環境でインデックスを再構築する場合に役立ちます。もちろん、インデックスの再構築によって課せられる余分なCPU、メモリ、I / O負荷により、他の操作が遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b659630282ce6fbd7aba80155fab2795874d42d4" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports row-level access, but &lt;code&gt;sepgsql&lt;/code&gt; does not.</source>
          <target state="translated">PostgreSQLは行レベルのアクセスをサポートしていますが、 &lt;code&gt;sepgsql&lt;/code&gt; はサポートしていません。</target>
        </trans-unit>
        <trans-unit id="ef19df889c26aff47b13a779090fcd37550d60bb" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several methods for logging server messages, including stderr, csvlog and syslog. On Windows, eventlog is also supported. Set this parameter to a list of desired log destinations separated by commas. The default is to log to stderr only. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">PostgreSQLは、stderr、csvlog、syslogなど、サーバーメッセージのログを記録するいくつかの方法をサポートしています。 Windowsでは、イベントログもサポートされています。このパラメーターを、コンマで区切られた目的のログ宛先のリストに設定します。デフォルトでは、stderrのみにログを記録します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="51899fa8eebb3b3aa74bb4a137479eee2fd66147" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports several special date/time input values for convenience, as shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;Table 8.13&lt;/a&gt;. The values &lt;code&gt;infinity&lt;/code&gt; and &lt;code&gt;-infinity&lt;/code&gt; are specially represented inside the system and will be displayed unchanged; but the others are simply notational shorthands that will be converted to ordinary date/time values when read. (In particular, &lt;code&gt;now&lt;/code&gt; and related strings are converted to a specific time value as soon as they are read.) All of these values need to be enclosed in single quotes when used as constants in SQL commands.</source>
          <target state="translated">PostgreSQLは、&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-SPECIAL-TABLE&quot;&gt;表8.13に&lt;/a&gt;示すように、便宜上、いくつかの特別な日付/時刻入力値をサポートしています。値 &lt;code&gt;infinity&lt;/code&gt; および &lt;code&gt;-infinity&lt;/code&gt; は、システム内で特別に表され、変更されずに表示されます。しかし、その他は単に表記上の省略形であり、読み取られると通常の日付/時刻値に変換されます。 （特に、 &lt;code&gt;now&lt;/code&gt; および関連する文字列は、読み取られるとすぐに特定の時間値に変換されます。）これらの値はすべて、SQLコマンドで定数として使用する場合、単一引用符で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="f6c41dd3d36631eef9a60ad49bfd703137d3f4d8" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the full set of SQL date and time types, shown in &lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;Table 8.9&lt;/a&gt;. The operations available on these data types are described in &lt;a href=&quot;functions-datetime&quot;&gt;Section 9.9&lt;/a&gt;. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced (see &lt;a href=&quot;datetime-units-history&quot;&gt;Section B.5&lt;/a&gt; for more information).</source>
          <target state="translated">PostgreSQLは、&lt;a href=&quot;datatype-datetime#DATATYPE-DATETIME-TABLE&quot;&gt;表8.9&lt;/a&gt;に示すSQLの日付と時刻タイプの完全なセットをサポートしています。これらのデータ型で使用できる操作については、&lt;a href=&quot;functions-datetime&quot;&gt;9.9項で&lt;/a&gt;説明しています。日付は、その暦が導入される前の年でさえ、グレゴリオ暦に従ってカウントされます（詳細については、&lt;a href=&quot;datetime-units-history&quot;&gt;セクションB.5&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="f14a3d6cb75702f32d5dc071e65c1dc41ad01772" translate="yes" xml:space="preserve">
          <source>PostgreSQL supports the standard SQL types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;char(N)&lt;/code&gt;, &lt;code&gt;varchar(N)&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt;, as well as other types of general utility and a rich set of geometric types. PostgreSQL can be customized with an arbitrary number of user-defined data types. Consequently, type names are not key words in the syntax, except where required to support special cases in the SQL standard.</source>
          <target state="translated">PostgreSQLは、標準SQL型の &lt;code&gt;int&lt;/code&gt; 、 &lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;real&lt;/code&gt; 、 &lt;code&gt;double precision&lt;/code&gt; 、 &lt;code&gt;char(N)&lt;/code&gt; 、 &lt;code&gt;varchar(N)&lt;/code&gt; 、 &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;timestamp&lt;/code&gt; 、および &lt;code&gt;interval&lt;/code&gt; だけでなく、他のタイプの一般的なユーティリティと豊富なジオメトリックタイプのセットをサポートしています。 PostgreSQLは、任意の数のユーザー定義データ型でカスタマイズできます。したがって、SQL標準で特殊なケースをサポートする必要がある場合を除いて、型名は構文のキーワードではありません。</target>
        </trans-unit>
        <trans-unit id="0d51b565fec4c2b0e44f5a1d45ac9c129a9f5580" translate="yes" xml:space="preserve">
          <source>PostgreSQL treats the settings &lt;code&gt;origin&lt;/code&gt; and &lt;code&gt;local&lt;/code&gt; the same internally. Third-party replication systems may use these two values for their internal purposes, for example using &lt;code&gt;local&lt;/code&gt; to designate a session whose changes should not be replicated.</source>
          <target state="translated">PostgreSQLは、設定の &lt;code&gt;origin&lt;/code&gt; と &lt;code&gt;local&lt;/code&gt; 内部的に同じように扱います。サードパーティのレプリケーションシステムは、内部でこれら2つの値を使用する場合があります。たとえば、 &lt;code&gt;local&lt;/code&gt; を使用して、変更をレプリケートしないセッションを指定します。</target>
        </trans-unit>
        <trans-unit id="749a4f6a11ea83f98676b6594e8c9efc963bc390" translate="yes" xml:space="preserve">
          <source>PostgreSQL type</source>
          <target state="translated">PostgreSQL型</target>
        </trans-unit>
        <trans-unit id="47a27d79e52ae2c7462f626790ad2829a449a676" translate="yes" xml:space="preserve">
          <source>PostgreSQL uses a fixed page size (commonly 8 kB), and does not allow tuples to span multiple pages. Therefore, it is not possible to store very large field values directly. To overcome this limitation, large field values are compressed and/or broken up into multiple physical rows. This happens transparently to the user, with only small impact on most of the backend code. The technique is affectionately known as TOAST (or &amp;ldquo;the best thing since sliced bread&amp;rdquo;). The TOAST infrastructure is also used to improve handling of large data values in-memory.</source>
          <target state="translated">PostgreSQLは固定ページサイズ（通常8 kB）を使用し、タプルが複数のページにまたがることを許可していません。したがって、非常に大きなフィールド値を直接格納することはできません。この制限を克服するために、大きなフィールド値は圧縮されるか、複数の物理行に分割されます。これはユーザーに対して透過的に行われ、ほとんどのバックエンドコードへの影響はわずかです。この技法は、TOAST（または「スライスしたパン以来の最高のもの」）として愛情を込めて知られています。TOASTインフラストラクチャは、メモリ内の大きなデータ値の処理を改善するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="e1529abe3421ea489100f9759672bf8f68aa03a3" translate="yes" xml:space="preserve">
          <source>PostgreSQL version information. See also &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt; for a machine-readable version.</source>
          <target state="translated">PostgreSQLバージョン情報。マシンが読み取り可能なバージョンについては、&lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="79b79e94e250861d3a37b2b81991c08edde567f2" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.5 used slightly different operator precedence rules. In particular, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; used to be treated as generic operators; &lt;code&gt;IS&lt;/code&gt; tests used to have higher priority; and &lt;code&gt;NOT BETWEEN&lt;/code&gt; and related constructs acted inconsistently, being taken in some cases as having the precedence of &lt;code&gt;NOT&lt;/code&gt; rather than &lt;code&gt;BETWEEN&lt;/code&gt;. These rules were changed for better compliance with the SQL standard and to reduce confusion from inconsistent treatment of logically equivalent constructs. In most cases, these changes will result in no behavioral change, or perhaps in &amp;ldquo;no such operator&amp;rdquo; failures which can be resolved by adding parentheses. However there are corner cases in which a query might change behavior without any parsing error being reported. If you are concerned about whether these changes have silently broken something, you can test your application with the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warning&lt;/a&gt; turned on to see if any warnings are logged.</source>
          <target state="translated">9.5より前のバージョンのPostgreSQLでは、若干異なる演算子の優先順位ルールが使用されていました。特に、 &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; と &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は、一般的な演算子として扱われていました。以前は &lt;code&gt;IS&lt;/code&gt; テストの優先度が高かった。および &lt;code&gt;NOT BETWEEN&lt;/code&gt; および関連する構成要素の動作に一貫性がなく、場合によっては &lt;code&gt;BETWEEN&lt;/code&gt; ではなく &lt;code&gt;NOT&lt;/code&gt; の優先順位があると見なされる。これらのルールは、SQL標準への準拠を改善し、論理的に等価な構造の一貫性のない扱いによる混乱を減らすために変更されました。ほとんどの場合、これらの変更によって動作が変更されることはなく、かっこを追加することで解決できる「そのような演算子はありません」というエラーが発生する可能性があります。ただし、解析エラーが報告されずにクエリが動作を変更する場合があります。これらの変更によってメッセージが表示されずに問題が発生するかどうかが心配な場合は、構成パラメーター&lt;a href=&quot;runtime-config-compatible#GUC-OPERATOR-PRECEDENCE-WARNING&quot;&gt;operator_precedence_warningを&lt;/a&gt;オンにしてアプリケーションをテストし、警告がログに記録されているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="b12aba1a6149cc1a1cc6de75b2d9db3d7327f976" translate="yes" xml:space="preserve">
          <source>PostgreSQL versions before 9.6 did not provide any guarantees about the timing of evaluation of output expressions versus sorting and limiting; it depended on the form of the chosen query plan.</source>
          <target state="translated">9.6以前のPostgreSQLのバージョンでは、出力式の評価のタイミングとソートや制限のタイミングについての保証は提供されていませんでした。</target>
        </trans-unit>
        <trans-unit id="a330d6e333f0e705b7dbdae815c080baf029fd11" translate="yes" xml:space="preserve">
          <source>PostgreSQL will accept &lt;code&gt;BY VALUE&lt;/code&gt; or &lt;code&gt;BY REF&lt;/code&gt; in an &lt;code&gt;XMLEXISTS&lt;/code&gt; or &lt;code&gt;XMLTABLE&lt;/code&gt; construct, but it ignores them. The &lt;code&gt;xml&lt;/code&gt; data type holds a character-string serialized representation, so there is no node identity to preserve, and passing is always effectively &lt;code&gt;BY VALUE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQLは、 &lt;code&gt;XMLEXISTS&lt;/code&gt; または &lt;code&gt;XMLTABLE&lt;/code&gt; 構文で &lt;code&gt;BY VALUE&lt;/code&gt; または &lt;code&gt;BY REF&lt;/code&gt; を受け入れますが、無視します。 &lt;code&gt;xml&lt;/code&gt; データ型は、その保全にどのノードIDが存在しない、と通過は常に効果的である、文字列直列化表現を保持している &lt;code&gt;BY VALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46668d602303093fd5436b07b8510921686fe19b" translate="yes" xml:space="preserve">
          <source>PostgreSQL will allow superusers to create databases with &lt;code&gt;SQL_ASCII&lt;/code&gt; encoding even when &lt;code&gt;LC_CTYPE&lt;/code&gt; is not &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt;. As noted above, &lt;code&gt;SQL_ASCII&lt;/code&gt; does not enforce that the data stored in the database has any particular encoding, and so this choice poses risks of locale-dependent misbehavior. Using this combination of settings is deprecated and may someday be forbidden altogether.</source>
          <target state="translated">PostgreSQLでは、スーパーユーザーが &lt;code&gt;LC_CTYPE&lt;/code&gt; が &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;POSIX&lt;/code&gt; でない場合でも、 &lt;code&gt;SQL_ASCII&lt;/code&gt; エンコーディングでデータベースを作成できます。上記のように、 &lt;code&gt;SQL_ASCII&lt;/code&gt; は、データベースに格納されたデータに特定のエンコーディングがあることを強制しないため、この選択はロケールに依存する誤動作のリスクをもたらします。この設定の組み合わせの使用は推奨されておらず、いつかは完全に禁止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b4c3b94e027418ea1293e7cfc1afc35261ba39ee" translate="yes" xml:space="preserve">
          <source>PostgreSQL will apply this expansion behavior to any composite-valued expression, although as shown &lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;above&lt;/a&gt;, you need to write parentheses around the value that &lt;code&gt;.*&lt;/code&gt; is applied to whenever it's not a simple table name. For example, if &lt;code&gt;myfunc()&lt;/code&gt; is a function returning a composite type with columns &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then these two queries have the same result:</source>
          <target state="translated">PostgreSQLはこの拡張動作を任意の複合値式に適用しますが、&lt;a href=&quot;rowtypes#ROWTYPES-ACCESSING&quot;&gt;上記のよう&lt;/a&gt;に、単純なテーブル名ではない場合は常に &lt;code&gt;.*&lt;/code&gt; が適用される値を括弧で囲む必要があります。たとえば、 &lt;code&gt;myfunc()&lt;/code&gt; が列 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; の複合型を返す関数である場合、これらの2つのクエリは同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="c89f6a3f1560a7bd4653723f3e72dbf1311168a6" translate="yes" xml:space="preserve">
          <source>PostgreSQL will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards.</source>
          <target state="translated">PostgreSQLは、列のデフォルト値(もしあれば)を新しい型に変換しようとします。しかし、これらの変換は失敗したり、驚くような結果になったりするかもしれません。多くの場合、型を変更する前に列に対する制約をすべて削除し、適切に変更された制約を後から追加するのが最善です。</target>
        </trans-unit>
        <trans-unit id="23adfa969a97323ee3ec177a7dcb8f6884bb3a0c" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt; transaction semantics depend on being able to compare transaction ID (XID) numbers: a row version with an insertion XID greater than the current transaction's XID is &amp;ldquo;in the future&amp;rdquo; and should not be visible to the current transaction. But since transaction IDs have limited size (32 bits) a cluster that runs for a long time (more than 4 billion transactions) would suffer &lt;em&gt;transaction ID wraparound&lt;/em&gt;: the XID counter wraps around to zero, and all of a sudden transactions that were in the past appear to be in the future &amp;mdash; which means their output become invisible. In short, catastrophic data loss. (Actually the data is still there, but that's cold comfort if you cannot get at it.) To avoid this, it is necessary to vacuum every table in every database at least once every two billion transactions.</source>
          <target state="translated">PostgreSQLの&lt;a href=&quot;mvcc-intro&quot;&gt;MVCC&lt;/a&gt;トランザクションセマンティクスは、トランザクションID（XID）番号を比較できるかどうかに依存します。現在のトランザクションのXIDよりも大きい挿入XIDを持つ行バージョンは「将来」であり、現在のトランザクションからは見えません。ただし、トランザクションIDにはサイズ（32ビット）の制限があるため、長時間（40億を超えるトランザクション）実行されるクラスターは、&lt;em&gt;トランザクションIDのラップアラウンド&lt;/em&gt;を被り&lt;em&gt;ます。&lt;/em&gt;：XIDカウンターはゼロに戻り、過去にあった突然のトランザクションはすべて未来にあるように見えます。つまり、出力が見えなくなります。つまり、壊滅的なデータ損失です。（実際にはデータはまだ残っていますが、それが得られない場合はそれで十分です。）これを回避するには、少なくとも20億トランザクションごとに、すべてのデータベースのすべてのテーブルをバキュームする必要があります。</target>
        </trans-unit>
        <trans-unit id="d01ad7a96af1c4c37b0765a65b29de55d59ec177" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt; command has to process each table on a regular basis for several reasons:</source>
          <target state="translated">PostgreSQLの&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドは、いくつかの理由で定期的に各テーブルを処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="1d397eedb2e425cb61e6640819576e2ece268547" translate="yes" xml:space="preserve">
          <source>PostgreSQL's &lt;em&gt;statistics collector&lt;/em&gt; is a subsystem that supports collection and reporting of information about server activity. Presently, the collector can count accesses to tables and indexes in both disk-block and individual-row terms. It also tracks the total number of rows in each table, and information about vacuum and analyze actions for each table. It can also count calls to user-defined functions and the total time spent in each one.</source>
          <target state="translated">PostgreSQLの&lt;em&gt;統計コレクター&lt;/em&gt;は、サーバーアクティビティに関する情報の収集とレポートをサポートするサブシステムです。現在、コレクターはテーブルとインデックスへのアクセスをディスクブロックと個別行の両方でカウントできます。また、各テーブルの行の総数、および各テーブルのバキュームと分析アクションに関する情報も追跡します。また、ユーザー定義関数の呼び出しと、各関数で費やされた合計時間もカウントできます。</target>
        </trans-unit>
        <trans-unit id="fa34938a4c0bdb7ddaed6ea9437aad3e7e7c20a7" translate="yes" xml:space="preserve">
          <source>PostgreSQL's JIT implementation can inline the bodies of functions of types &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt;, as well as operators based on such functions. To do so for functions in extensions, the definitions of those functions need to be made available. When using &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt; to build an extension against a server that has been compiled with LLVM JIT support, the relevant files will be built and installed automatically.</source>
          <target state="translated">PostgreSQLのJIT実装は、タイプ &lt;code&gt;C&lt;/code&gt; および &lt;code&gt;internal&lt;/code&gt; の関数の本体と、そのような関数に基づく演算子をインライン化できます。拡張機能の関数に対してこれを行うには、それらの関数の定義を使用可能にする必要があります。&lt;a href=&quot;https://www.postgresql.org/docs/12/extend-pgxs.html&quot;&gt;PGXS&lt;/a&gt;を使用して、LLVM JITサポートでコンパイルされたサーバーに対して拡張機能を構築する場合、関連ファイルが自動的に構築およびインストールされます。</target>
        </trans-unit>
        <trans-unit id="b2ce9be22eb538937b290524f1a893fff9a3a342" translate="yes" xml:space="preserve">
          <source>PostgreSQL's foreign-data functionality is still under active development. Optimization of queries is primitive (and mostly left to the wrapper, too). Thus, there is considerable room for future performance improvements.</source>
          <target state="translated">PostgreSQLの外部データ機能はまだ活発な開発中です。クエリの最適化は原始的なものです(そして、ほとんどはラッパーに委ねられています)。したがって、将来の性能向上の余地はかなりあります。</target>
        </trans-unit>
        <trans-unit id="045ba636eac8c350bd9d92d07f5b544b6d689ef6" translate="yes" xml:space="preserve">
          <source>PostgreSQL's implementation of SQL/JSON path language has the following deviations from the SQL/JSON standard:</source>
          <target state="translated">PostgreSQLのSQL/JSONパス言語の実装は、SQL/JSON標準から以下のような逸脱があります。</target>
        </trans-unit>
        <trans-unit id="b6512655ce0206ad2e55af59128437c19a85eef8" translate="yes" xml:space="preserve">
          <source>PostgreSQL's regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual.</source>
          <target state="translated">PostgreSQLの正規表現はHenry Spencerによって書かれたソフトウェアパッケージを使用して実装されています。以下の正規表現の説明の多くは、彼のマニュアルからそのままコピーしたものです。</target>
        </trans-unit>
        <trans-unit id="8b89dce84ea21263b16697e60b4c1b4c85d27493" translate="yes" xml:space="preserve">
          <source>PostgreSQL's text search features are described at length in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLのテキスト検索機能については、&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="39f6a42a4fb0039de8b2fce0531aa5cf8bf17009" translate="yes" xml:space="preserve">
          <source>PostgreSQL-style typecast</source>
          <target state="translated">PostgreSQL スタイルの型キャスト</target>
        </trans-unit>
        <trans-unit id="19b427c5cf5eb995bfcd7725e3fbf7217d1adcbd" translate="yes" xml:space="preserve">
          <source>Poul-Henning Kamp</source>
          <target state="translated">ポール・ヘニングキャンプ</target>
        </trans-unit>
        <trans-unit id="17ae45bd355f880cc7401f24ea563dca0df2e7d4" translate="yes" xml:space="preserve">
          <source>Pre-loaded catalog rows must have preassigned OIDs if there are OID references to them in other pre-loaded rows. A preassigned OID is also needed if the row's OID must be referenced from C code. If neither case applies, the &lt;code&gt;oid&lt;/code&gt; metadata field can be omitted, in which case the bootstrap code assigns an OID automatically. In practice we usually preassign OIDs for all or none of the pre-loaded rows in a given catalog, even if only some of them are actually cross-referenced.</source>
          <target state="translated">プリロードされた他の行にOID参照がある場合、プリロードされたカタログ行にはOIDが事前に割り当てられている必要があります。行のOIDをCコードから参照する必要がある場合は、事前に割り当てられたOIDも必要です。どちらの場合も当てはまらない場合は、 &lt;code&gt;oid&lt;/code&gt; メタデータフィールドを省略できます。その場合、ブートストラップコードはOIDを自動的に割り当てます。実際には、実際に相互参照されている行が一部だけであっても、特定のカタログ内のプリロードされた行のすべてにOIDを事前に割り当てるか、まったく割り当てません。</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="24fe09a1cf90d17df4307cd57797792c845342fc" translate="yes" xml:space="preserve">
          <source>Predicate locks in PostgreSQL, like in most other database systems, are based on data actually accessed by a transaction. These will show up in the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view with a &lt;code&gt;mode&lt;/code&gt; of &lt;code&gt;SIReadLock&lt;/code&gt;. The particular locks acquired during execution of a query will depend on the plan used by the query, and multiple finer-grained locks (e.g., tuple locks) may be combined into fewer coarser-grained locks (e.g., page locks) during the course of the transaction to prevent exhaustion of the memory used to track the locks. A &lt;code&gt;READ ONLY&lt;/code&gt; transaction may be able to release its SIRead locks before completion, if it detects that no conflicts can still occur which could lead to a serialization anomaly. In fact, &lt;code&gt;READ ONLY&lt;/code&gt; transactions will often be able to establish that fact at startup and avoid taking any predicate locks. If you explicitly request a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction, it will block until it can establish this fact. (This is the &lt;em&gt;only&lt;/em&gt; case where Serializable transactions block but Repeatable Read transactions don't.) On the other hand, SIRead locks often need to be kept past transaction commit, until overlapping read write transactions complete.</source>
          <target state="translated">他のほとんどのデータベースシステムと同様に、PostgreSQLの述語ロックは、トランザクションによって実際にアクセスされるデータに基づいています。これらは、 &lt;code&gt;SIReadLock&lt;/code&gt; の &lt;code&gt;mode&lt;/code&gt; で&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt;システムビューに表示されます。クエリの実行中に取得される特定のロックは、クエリで使用されるプランに依存し、複数の細かいロック（タプルロックなど）は、コース中に、より粗いロック（ページロックなど）に結合されることがあります。ロックの追跡に使用されるメモリの枯渇を防ぐためのトランザクション。 A &lt;code&gt;READ ONLY&lt;/code&gt; トランザクションは、それが何の競合がまだ異常シリアライズにつながる可能性が発生しないことを検出した場合、完了する前にそのSIReadロックを解除することができるかもしれません。実際、 &lt;code&gt;READ ONLY&lt;/code&gt; トランザクションは、多くの場合、起動時にその事実を確立し、述語ロックの取得を回避できます。 &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; トランザクションを明示的に要求すると、この事実を確立できるまでブロックされます。 （これは、直列化可能トランザクションがブロックするが反復可能読み取りトランザクションはブロックし&lt;em&gt;ない唯一の&lt;/em&gt;ケースです。）一方、SIReadロックは、多くの場合、重複する読み取り書き込みトランザクションが完了するまで、トランザクションコミットを超えて保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="7a2a4f6fed53f092f075c647902092f49dff565c" translate="yes" xml:space="preserve">
          <source>Prepare all statements before using them. Libecpg will keep a cache of prepared statements and reuse a statement if it gets executed again. If the cache runs full, libecpg will free the least used statement.</source>
          <target state="translated">使用する前にすべてのステートメントを準備してください。Libecpgは準備されたステートメントのキャッシュを保持し、再実行された場合にステートメントを再利用します。キャッシュが一杯になった場合、libecpgは最も使われていないステートメントを解放します。</target>
        </trans-unit>
        <trans-unit id="805b0426cd8c493c6395add1e59cb6d57cc782f6" translate="yes" xml:space="preserve">
          <source>Prepare for an index scan. The &lt;code&gt;nkeys&lt;/code&gt; and &lt;code&gt;norderbys&lt;/code&gt; parameters indicate the number of quals and ordering operators that will be used in the scan; these may be useful for space allocation purposes. Note that the actual values of the scan keys aren't provided yet. The result must be a palloc'd struct. For implementation reasons the index access method &lt;em&gt;must&lt;/em&gt; create this struct by calling &lt;code&gt;RelationGetIndexScan()&lt;/code&gt;. In most cases &lt;code&gt;ambeginscan&lt;/code&gt; does little beyond making that call and perhaps acquiring locks; the interesting parts of index-scan startup are in &lt;code&gt;amrescan&lt;/code&gt;.</source>
          <target state="translated">インデックススキャンの準備をします。 &lt;code&gt;nkeys&lt;/code&gt; と &lt;code&gt;norderbys&lt;/code&gt; パラメータはQUALSとスキャンで使用される順序演算子の数を示します。これらは、スペース割り当ての目的で役立つ場合があります。スキャンキーの実際の値はまだ提供されていないことに注意してください。結果は、pallocされた構造体でなければなりません。実装上の理由から、インデックスアクセスメソッド&lt;em&gt;は&lt;/em&gt; &lt;code&gt;RelationGetIndexScan()&lt;/code&gt; を呼び出してこの構造体を作成する&lt;em&gt;必要があり&lt;/em&gt;ます。ほとんどの場合、 &lt;code&gt;ambeginscan&lt;/code&gt; はその呼び出しを実行し、おそらくロックを取得する以外にほとんど何もしません。インデックススキャンのスタートアップの興味深い部分は &lt;code&gt;amrescan&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="1badb6123149d2dd80187b1001e17317e0376a45" translate="yes" xml:space="preserve">
          <source>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</source>
          <target state="translated">オンラインバックアップの実行準備(デフォルトではスーパーユーザに制限されていますが、他のユーザには機能を実行するためのEXECUTEを許可することができます</target>
        </trans-unit>
        <trans-unit id="ea6420d9e6ea0b317eaaff702554d4ab07b95961" translate="yes" xml:space="preserve">
          <source>Prepare the current transaction for two-phase commit, using &lt;code&gt;foobar&lt;/code&gt; as the transaction identifier:</source>
          <target state="translated">&lt;code&gt;foobar&lt;/code&gt; をトランザクション識別子として使用して、現在のトランザクションを2フェーズコミット用に準備します。</target>
        </trans-unit>
        <trans-unit id="5eccdbb667192934bc79ff3dadac066bfd3213f5" translate="yes" xml:space="preserve">
          <source>Prepared statements (either explicitly prepared or implicitly generated, for example by PL/pgSQL) can be executed using custom or generic plans. Custom plans are made afresh for each execution using its specific set of parameter values, while generic plans do not rely on the parameter values and can be re-used across executions. Thus, use of a generic plan saves planning time, but if the ideal plan depends strongly on the parameter values then a generic plan may be inefficient. The choice between these options is normally made automatically, but it can be overridden with &lt;code&gt;plan_cache_mode&lt;/code&gt;. The allowed values are &lt;code&gt;auto&lt;/code&gt; (the default), &lt;code&gt;force_custom_plan&lt;/code&gt; and &lt;code&gt;force_generic_plan&lt;/code&gt;. This setting is considered when a cached plan is to be executed, not when it is prepared. For more information see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;.</source>
          <target state="translated">準備されたステートメント（明示的に準備されたか、またはPL / pgSQLなどによって暗黙的に生成されたもの）は、カスタムまたは汎用プランを使用して実行できます。カスタムプランは、特定のパラメーター値のセットを使用して実行ごとに新しく作成されますが、一般的なプランはパラメーター値に依存せず、実行全体で再利用できます。したがって、一般的な計画を使用すると計画時間を節約できますが、理想的な計画がパラメータ値に強く依存している場合、一般的な計画は非効率的です。これらのオプションの選択は通常自動的に行われますが、 &lt;code&gt;plan_cache_mode&lt;/code&gt; で上書きできます。許可される値は、 &lt;code&gt;auto&lt;/code&gt; （デフォルト）、 &lt;code&gt;force_custom_plan&lt;/code&gt; 、および &lt;code&gt;force_generic_plan&lt;/code&gt; です。。この設定は、キャッシュされたプランが準備されるときではなく、実行されるときに考慮されます。詳細については、「&lt;a href=&quot;sql-prepare&quot;&gt;準備&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="5d2d9ca4ec55b877233447dcb48943c2ef02e7aa" translate="yes" xml:space="preserve">
          <source>Prepared statements can take parameters: values that are substituted into the statement when it is executed. When creating the prepared statement, refer to parameters by position, using &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. A corresponding list of parameter data types can optionally be specified. When a parameter's data type is not specified or is declared as &lt;code&gt;unknown&lt;/code&gt;, the type is inferred from the context in which the parameter is first referenced (if possible). When executing the statement, specify the actual values for these parameters in the &lt;code&gt;EXECUTE&lt;/code&gt; statement. Refer to &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; for more information about that.</source>
          <target state="translated">準備されたステートメントはパラメーターをとることができます。パラメーターは実行時にステートメントに代入されます。準備済みステートメントを作成するときは、 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などを使用して、位置によってパラメーターを参照します。パラメーターのデータ型の対応するリストは、オプションで指定できます。パラメータのデータ型が指定されていないか、 &lt;code&gt;unknown&lt;/code&gt; として宣言されている場合、型は、パラメータが最初に参照されたコンテキストから推測されます（可能な場合）。ステートメントを実行するときに、これらのパラメーターの実際の値を &lt;code&gt;EXECUTE&lt;/code&gt; ステートメントで指定します。詳細については、&lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="23037ec79dcb923a75cebd6186549d643c581e91" translate="yes" xml:space="preserve">
          <source>Prepared statements only last for the duration of the current database session. When the session ends, the prepared statement is forgotten, so it must be recreated before being used again. This also means that a single prepared statement cannot be used by multiple simultaneous database clients; however, each client can create their own prepared statement to use. Prepared statements can be manually cleaned up using the &lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt; command.</source>
          <target state="translated">準備されたステートメントは、現在のデータベースセッションの間のみ持続します。セッションが終了すると、準備済みステートメントは忘れられるため、再度使用する前に再作成する必要があります。これは、1つの準備済みステートメントを複数の同時データベースクライアントで使用できないことも意味します。ただし、各クライアントは使用する独自の準備済みステートメントを作成できます。準備済みステートメントは、&lt;a href=&quot;sql-deallocate&quot;&gt;DEALLOCATE&lt;/a&gt;コマンドを使用して手動でクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="a483a03c91ae871a21f8ef97015a97d796c2feb5" translate="yes" xml:space="preserve">
          <source>Prepared statements potentially have the largest performance advantage when a single session is being used to execute a large number of similar statements. The performance difference will be particularly significant if the statements are complex to plan or rewrite, e.g. if the query involves a join of many tables or requires the application of several rules. If the statement is relatively simple to plan and rewrite but relatively expensive to execute, the performance advantage of prepared statements will be less noticeable.</source>
          <target state="translated">1つのセッションが多数の類似したステートメントの実行に使用されている場合、準備されたステートメントは潜在的に最大のパフォーマンスの優位性を持っています。例えば、クエリが多くのテーブルの結合を含んでいたり、複数のルールを適用する必要がある場合など、ステートメントの計画や書き換えが複雑な場合、パフォーマンスの差は特に大きくなります。ステートメントが計画や書き換えは比較的簡単ですが、実行には比較的コストがかかる場合は、準備されたステートメントのパフォーマンスの優位性はあまり目立たないでしょう。</target>
        </trans-unit>
        <trans-unit id="16e489d5458780c56ecec5255859ffa473005ad5" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;COPY TO&lt;/code&gt; will never emit an octal or hex-digits backslash sequence, but it does use the other sequences listed above for those control characters.</source>
          <target state="translated">現在、 &lt;code&gt;COPY TO&lt;/code&gt; は8進数または16進数のバックスラッシュシーケンスを発行することはありませんが、これらの制御文字については、上記の他のシーケンスを使用しています。</target>
        </trans-unit>
        <trans-unit id="aa75b2cb1f42b5b78ef47e3bac6d7cbc20568a8c" translate="yes" xml:space="preserve">
          <source>Presently, &lt;code&gt;ON SELECT&lt;/code&gt; rules must be unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rules and must have actions that consist of a single &lt;code&gt;SELECT&lt;/code&gt; command. Thus, an &lt;code&gt;ON SELECT&lt;/code&gt; rule effectively turns the table into a view, whose visible contents are the rows returned by the rule's &lt;code&gt;SELECT&lt;/code&gt; command rather than whatever had been stored in the table (if anything). It is considered better style to write a &lt;code&gt;CREATE VIEW&lt;/code&gt; command than to create a real table and define an &lt;code&gt;ON SELECT&lt;/code&gt; rule for it.</source>
          <target state="translated">現在、 &lt;code&gt;ON SELECT&lt;/code&gt; ルールは無条件の &lt;code&gt;INSTEAD&lt;/code&gt; ルールである必要があり、単一の &lt;code&gt;SELECT&lt;/code&gt; コマンドで構成されるアクションが必要です。したがって、 &lt;code&gt;ON SELECT&lt;/code&gt; ルールはテーブルをビューに効果的に変換します。その表示内容は、テーブルに格納されていたもの（存在する場合）ではなく、ルールの &lt;code&gt;SELECT&lt;/code&gt; コマンドによって返された行です。実際のテーブルを作成して &lt;code&gt;ON SELECT&lt;/code&gt; ルールを定義するよりも、 &lt;code&gt;CREATE VIEW&lt;/code&gt; コマンドを記述する方が適切なスタイルと見なされます。</target>
        </trans-unit>
        <trans-unit id="52172a45fa35ea47ee37481a7598605f94332941" translate="yes" xml:space="preserve">
          <source>Presently, all data values in a binary-format file are assumed to be in binary format (format code one). It is anticipated that a future extension might add a header field that allows per-column format codes to be specified.</source>
          <target state="translated">現在のところ、バイナリ形式のファイル内のすべてのデータ値はバイナリ形式(フォーマットコード1)であると仮定されています。将来の拡張機能では、列ごとにフォーマットコードを指定できるヘッダフィールドが追加されることが予想されます。</target>
        </trans-unit>
        <trans-unit id="07a55fa2dfc20be04c1afe40194156f4b790bc71" translate="yes" xml:space="preserve">
          <source>Presently, if a rule action contains a &lt;code&gt;NOTIFY&lt;/code&gt; command, the &lt;code&gt;NOTIFY&lt;/code&gt; command will be executed unconditionally, that is, the &lt;code&gt;NOTIFY&lt;/code&gt; will be issued even if there are not any rows that the rule should apply to. For example, in:</source>
          <target state="translated">現在、ルールアクションに &lt;code&gt;NOTIFY&lt;/code&gt; コマンドが含まれている場合、 &lt;code&gt;NOTIFY&lt;/code&gt; コマンドは無条件に実行されます。つまり、ルールが適用される行がない場合でも、 &lt;code&gt;NOTIFY&lt;/code&gt; が発行されます。たとえば、</target>
        </trans-unit>
        <trans-unit id="70f8a5644dc2d0fd28dd5618b027e4363107a89a" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt; or, preferably, run pg_restore as a PostgreSQL superuser.</source>
          <target state="translated">現在、 &lt;code&gt;--disable-triggers&lt;/code&gt; に対して発行されるコマンドは、スーパーユーザーとして実行する必要があります。そのため、 &lt;code&gt;-S&lt;/code&gt; を使用してスーパーユーザー名も指定するか、できればPostgreSQLスーパーユーザーとしてpg_restoreを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="48866779c6574ae0eb32e070be6be5c56e3ca440" translate="yes" xml:space="preserve">
          <source>Presently, the commands emitted for &lt;code&gt;--disable-triggers&lt;/code&gt; must be done as superuser. So, you should also specify a superuser name with &lt;code&gt;-S&lt;/code&gt;, or preferably be careful to start the resulting script as a superuser.</source>
          <target state="translated">現在、 &lt;code&gt;--disable-triggers&lt;/code&gt; に対して発行されるコマンドは、スーパーユーザーとして実行する必要があります。したがって、 &lt;code&gt;-S&lt;/code&gt; を使用してスーパーユーザー名も指定する必要があります。できれば、結果のスクリプトをスーパーユーザーとして開始するように注意してください。</target>
        </trans-unit>
        <trans-unit id="334d01d9c8e3bbf43f71d7eda4f0774b3bc44f64" translate="yes" xml:space="preserve">
          <source>Preset Options</source>
          <target state="translated">プリセットオプション</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="ee7bdb0dff39839c1fd827f5826a7bfd60c2d7e2" translate="yes" xml:space="preserve">
          <source>Prevent dumping of access privileges (grant/revoke commands).</source>
          <target state="translated">アクセス権のダンピング(コマンドの付与/取り消し)を防止します。</target>
        </trans-unit>
        <trans-unit id="a0771736ef9369c38d7919dcb8f69f80ef4855cc" translate="yes" xml:space="preserve">
          <source>Prevent restoration of access privileges (grant/revoke commands).</source>
          <target state="translated">アクセス権の回復(コマンドの付与/取り消し)を防止します。</target>
        </trans-unit>
        <trans-unit id="233b752a1d979d1b03bfc00189d385eb81deac5c" translate="yes" xml:space="preserve">
          <source>Preventing Server Spoofing</source>
          <target state="translated">サーバのスプーフィングの防止</target>
        </trans-unit>
        <trans-unit id="b97befde20e55eaecab9bab9cc63c02e247c4a9f" translate="yes" xml:space="preserve">
          <source>Previous releases failed to preserve a lock which is upgraded by a later savepoint. For example, this code:</source>
          <target state="translated">以前のリリースでは、後のセーブポイントでアップグレードされたロックを保持できませんでした。例えば、次のようなコードです。</target>
        </trans-unit>
        <trans-unit id="5e203068f90ee842092a40f00034de5e2bf0c940" translate="yes" xml:space="preserve">
          <source>Primary keys are useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely. There are also various ways in which the database system makes use of a primary key if one has been declared; for example, the primary key defines the default target column(s) for foreign keys referencing its table.</source>
          <target state="translated">主キーは、文書化の目的でもクライアントアプリケーションでも有用です。例えば、行の値を変更できるGUIアプリケーションでは、行を一意に識別するためにテーブルの主キーを知る必要があるでしょう。また、主キーが宣言されていれば、データベースシステムが主キーを利用する方法もいろいろあります。例えば、主キーは、そのテーブルを参照する外部キーのデフォルトのターゲット列を定義します。</target>
        </trans-unit>
        <trans-unit id="302096a883e851361a7c65e770ac4a2f93b77640" translate="yes" xml:space="preserve">
          <source>Primary keys can span more than one column; the syntax is similar to unique constraints:</source>
          <target state="translated">主キーは複数の列にまたがることができます。構文は一意の制約に似ています。</target>
        </trans-unit>
        <trans-unit id="54c622f5b5e8c75c7d4757c68339aa2e8b25f7fc" translate="yes" xml:space="preserve">
          <source>Primary log file name, or log in the requested format, currently in use by the logging collector</source>
          <target state="translated">プライマリログファイル名、または要求された形式のログ。</target>
        </trans-unit>
        <trans-unit id="4a03aad5c247b986acad6d97b6927c2a6ffb1095" translate="yes" xml:space="preserve">
          <source>Primitive JSON values are compared using the same comparison rules as for the underlying PostgreSQL data type. Strings are compared using the default database collation.</source>
          <target state="translated">プリミティブJSON値は、基礎となるPostgreSQLデータ型と同じ比較規則を使用して比較されます。文字列は、デフォルトのデータベース照合を使用して比較されます。</target>
        </trans-unit>
        <trans-unit id="9f9dd23572b66164559cf3545fb93e79c89e5d8a" translate="yes" xml:space="preserve">
          <source>Principal used to authenticate this connection, or NULL if GSSAPI was not used to authenticate this connection. This field is truncated if the principal is longer than &lt;code&gt;NAMEDATALEN&lt;/code&gt; (64 characters in a standard build).</source>
          <target state="translated">この接続の認証に使用されるプリンシパル、またはこの接続の認証にGSSAPIが使用されなかった場合はNULL。プリンシパルが &lt;code&gt;NAMEDATALEN&lt;/code&gt; （標準ビルドでは64文字）より長い場合、このフィールドは切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="a7e7318f55e0c844d9e1050c000b470ae6a8596e" translate="yes" xml:space="preserve">
          <source>Print additional information including the version and the &quot;include&quot; path.</source>
          <target state="translated">バージョンと &quot;include &quot;パスを含む追加情報を印刷します。</target>
        </trans-unit>
        <trans-unit id="e8de0f5082ac6065288eac684400de412407c144" translate="yes" xml:space="preserve">
          <source>Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">空でないすべての入力行が読み取られたときに標準出力に出力します。（これは、対話的に読み取られる行には適用されません。）これは、変数 &lt;code&gt;ECHO&lt;/code&gt; を &lt;code&gt;all&lt;/code&gt; に設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="ebb9a1e5bbdb1243d5e4a31dff31eebe9fc06f03" translate="yes" xml:space="preserve">
          <source>Print debugging output from the bootstrap backend and a few other messages of lesser interest for the general public. The bootstrap backend is the program &lt;code&gt;initdb&lt;/code&gt; uses to create the catalog tables. This option generates a tremendous amount of extremely boring output.</source>
          <target state="translated">ブートストラップバックエンドからのデバッグ出力と、一般の人々にとってあまり関心のない他のいくつかのメッセージを出力します。ブートストラップバックエンドは、 &lt;code&gt;initdb&lt;/code&gt; がカタログテーブルを作成するために使用するプログラムです。このオプションは、非常に退屈な出力を大量に生成します。</target>
        </trans-unit>
        <trans-unit id="a7c370355f00f0bd758a9808623b790c218141fd" translate="yes" xml:space="preserve">
          <source>Print debugging output.</source>
          <target state="translated">デバッグ出力を印刷します。</target>
        </trans-unit>
        <trans-unit id="f0d63d35347e807b3cd5630fcccfcb97aefdff03" translate="yes" xml:space="preserve">
          <source>Print detailed information during processing.</source>
          <target state="translated">処理中の詳細情報を印刷します。</target>
        </trans-unit>
        <trans-unit id="c073dbd6b543c579fb650eb5ea8d11e57c402573" translate="yes" xml:space="preserve">
          <source>Print failed SQL commands to standard error output. This is equivalent to setting the variable &lt;code&gt;ECHO&lt;/code&gt; to &lt;code&gt;errors&lt;/code&gt;.</source>
          <target state="translated">失敗したSQLコマンドを標準エラー出力に出力します。これは、変数 &lt;code&gt;ECHO&lt;/code&gt; を &lt;code&gt;errors&lt;/code&gt; に設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="597bb464eafa276a5ad0cc91e76eaf6190c85748" translate="yes" xml:space="preserve">
          <source>Print lots of debug logging output on &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">大量のデバッグログ出力を &lt;code&gt;stderr&lt;/code&gt; に出力します。</target>
        </trans-unit>
        <trans-unit id="a75f64b677ea04810bae39f5467bba0bd440ec28" translate="yes" xml:space="preserve">
          <source>Print only errors, no informational messages.</source>
          <target state="translated">印刷はエラーのみで、情報メッセージはありません。</target>
        </trans-unit>
        <trans-unit id="4f01f9df20b27d4321c4eb47d64e1ce581df8c21" translate="yes" xml:space="preserve">
          <source>Print psql's command line history to &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support.</source>
          <target state="translated">psqlのコマンドライン履歴を &lt;code&gt;filename&lt;/code&gt; に出力します。場合は &lt;code&gt;filename&lt;/code&gt; 省略され、履歴が（適切な場合には、ポケットベルを使用して）標準出力に書き込まれます。このコマンドは、psqlがReadlineサポートなしでビルドされた場合は使用できません。</target>
        </trans-unit>
        <trans-unit id="827ff74717cfd2b965ff32b6c6548085dff68335" translate="yes" xml:space="preserve">
          <source>Print the clusterdb version and exit.</source>
          <target state="translated">clusterdbのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="f6d64dc0309d9d3b50923addc35c2349b3a13866" translate="yes" xml:space="preserve">
          <source>Print the createdb version and exit.</source>
          <target state="translated">作成したbバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="f9c1069309fb6fad15e176f641cc5f92410a215f" translate="yes" xml:space="preserve">
          <source>Print the createuser version and exit.</source>
          <target state="translated">createuserのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="6ca986b09253f90ac05485c4d1b53fd88df68efc" translate="yes" xml:space="preserve">
          <source>Print the current query buffer to the standard output. If the current query buffer is empty, the most recently executed query is printed instead.</source>
          <target state="translated">現在のクエリバッファを標準出力に出力します。現在のクエリバッファが空の場合、代わりに最近実行されたクエリが出力されます。</target>
        </trans-unit>
        <trans-unit id="1947bab167f53773caffcdb3abd24d61e23f4340" translate="yes" xml:space="preserve">
          <source>Print the dropdb version and exit.</source>
          <target state="translated">dropdbのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="c27b83ad0e23795e57b1563b077c538c9ab60bb3" translate="yes" xml:space="preserve">
          <source>Print the dropuser version and exit.</source>
          <target state="translated">ドロップユーザー版を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="e9eeca2b3e3f27d8960033787d850e4053105026" translate="yes" xml:space="preserve">
          <source>Print the ecpg version and exit.</source>
          <target state="translated">ecpg版を印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="657af6d675a70187bdfd892abd1e767e65979526" translate="yes" xml:space="preserve">
          <source>Print the initdb version and exit.</source>
          <target state="translated">initdbのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="a31c7045982c28354a2311d649532f2714d0cd52" translate="yes" xml:space="preserve">
          <source>Print the location of C header files for server programming.</source>
          <target state="translated">サーバープログラミング用のCヘッダファイルの場所を表示します。</target>
        </trans-unit>
        <trans-unit id="c7399f9aea54b81806345b5fe9d88c09f2b217c4" translate="yes" xml:space="preserve">
          <source>Print the location of C header files of the client interfaces.</source>
          <target state="translated">クライアントインターフェースのCヘッダファイルの場所を表示します。</target>
        </trans-unit>
        <trans-unit id="595d5d7d00e3b9031bcf9b394461136007040d8b" translate="yes" xml:space="preserve">
          <source>Print the location of HTML documentation files.</source>
          <target state="translated">HTMLドキュメントファイルの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="2c45a54aeef843a3b47abadef8be23a9c8c5faa3" translate="yes" xml:space="preserve">
          <source>Print the location of architecture-independent support files.</source>
          <target state="translated">アーキテクチャに依存しないサポートファイルの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="6938b263f35a6474ff201cc4e757d0f937313671" translate="yes" xml:space="preserve">
          <source>Print the location of documentation files.</source>
          <target state="translated">ドキュメントファイルの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="38bf4c616b7c56d3f58464d10d1a64af7f6e8779" translate="yes" xml:space="preserve">
          <source>Print the location of dynamically loadable modules, or where the server would search for them. (Other architecture-dependent data files might also be installed in this directory.)</source>
          <target state="translated">動的にロード可能なモジュールの場所や、サーバがそれらを検索する場所を表示します。(他のアーキテクチャに依存するデータファイルもこのディレクトリにインストールされているかもしれません)。</target>
        </trans-unit>
        <trans-unit id="53148cc85f0f5372b92b4adab97d78f0cf599385" translate="yes" xml:space="preserve">
          <source>Print the location of extension makefiles.</source>
          <target state="translated">拡張makefileの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="4dee3cc7ede35752aad16661b510c6ddc2cb5087" translate="yes" xml:space="preserve">
          <source>Print the location of locale support files. (This will be an empty string if locale support was not configured when PostgreSQL was built.)</source>
          <target state="translated">ロケールサポートファイルの場所を表示します。(PostgreSQLの構築時にロケールサポートが設定されていない場合は空文字列となります)。</target>
        </trans-unit>
        <trans-unit id="8935ed932264eb12d05dc3d54390bc5894e6a109" translate="yes" xml:space="preserve">
          <source>Print the location of manual pages.</source>
          <target state="translated">マニュアルページの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="5c6b2cdac40039c6a4b46eed898e35031563c475" translate="yes" xml:space="preserve">
          <source>Print the location of object code libraries.</source>
          <target state="translated">オブジェクトコードライブラリの場所を表示します。</target>
        </trans-unit>
        <trans-unit id="cc4be32137a130cb7e8939f72a35980a1297a7e0" translate="yes" xml:space="preserve">
          <source>Print the location of other C header files.</source>
          <target state="translated">他のCヘッダファイルの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="348ec650580d85aaddcb30661d2eb9345e76019a" translate="yes" xml:space="preserve">
          <source>Print the location of system-wide configuration files.</source>
          <target state="translated">システム全体の設定ファイルの場所を印刷します。</target>
        </trans-unit>
        <trans-unit id="4773e766d5cc8cfc3ce755cd29aeb486a0dd05ae" translate="yes" xml:space="preserve">
          <source>Print the location of user executables. Use this, for example, to find the &lt;code&gt;psql&lt;/code&gt; program. This is normally also the location where the &lt;code&gt;pg_config&lt;/code&gt; program resides.</source>
          <target state="translated">ユーザー実行可能ファイルの場所を印刷します。たとえば、これを使用して、 &lt;code&gt;psql&lt;/code&gt; プログラムを検索します。これは通常、 &lt;code&gt;pg_config&lt;/code&gt; プログラムが存在する場所でもあります。</target>
        </trans-unit>
        <trans-unit id="53049ab5ef89f22bb5a6370fb0f7681de3a90603" translate="yes" xml:space="preserve">
          <source>Print the names of the files that would have been removed on &lt;code&gt;stdout&lt;/code&gt; (performs a dry run).</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; で削除されるファイルの名前を出力します（ドライランを実行します）。</target>
        </trans-unit>
        <trans-unit id="9c56e3a83e3c5d8c7d0ed82cb15ca361eb64f1dd" translate="yes" xml:space="preserve">
          <source>Print the options that were given to the &lt;code&gt;configure&lt;/code&gt; script when PostgreSQL was configured for building. This can be used to reproduce the identical configuration, or to find out with what options a binary package was built. (Note however that binary packages often contain vendor-specific custom patches.) See also the examples below.</source>
          <target state="translated">ビルド用にPostgreSQLが設定されたときに &lt;code&gt;configure&lt;/code&gt; スクリプトに指定されたオプションを出力します。これを使用して、同じ構成を再現したり、バイナリパッケージがビルドされたオプションを確認したりできます。（ただし、バイナリパッケージには多くの場合、ベンダー固有のカスタムパッチが含まれています。）以下の例も参照してください。</target>
        </trans-unit>
        <trans-unit id="b85724f77cfb0e7f274dc964acb424d6648ba3f5" translate="yes" xml:space="preserve">
          <source>Print the pg_archivecleanup version and exit.</source>
          <target state="translated">pg_archivecleanupのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="74b744744ac1bd9386b12893ce62c91739371ca7" translate="yes" xml:space="preserve">
          <source>Print the pg_basebackup version and exit.</source>
          <target state="translated">pg_basebackupのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="1fca2718d1cfc02986e8abfd6906319ca68c5805" translate="yes" xml:space="preserve">
          <source>Print the pg_checksums version and exit.</source>
          <target state="translated">pg_checksumsのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="bff35bc331305f42d0adc605e5c4b58b8bea0e9f" translate="yes" xml:space="preserve">
          <source>Print the pg_ctl version and exit.</source>
          <target state="translated">pg_ctlのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="2f2c8e42d192d577eaeaaebcc2a4ef29dbe17a60" translate="yes" xml:space="preserve">
          <source>Print the pg_dump version and exit.</source>
          <target state="translated">pg_dumpのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="711f70c380c99649a9e35f12c5de7cf7f0629905" translate="yes" xml:space="preserve">
          <source>Print the pg_dumpall version and exit.</source>
          <target state="translated">pg_dumpallのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="8234e166090222ac3be3d5f09ddf8625331bebb7" translate="yes" xml:space="preserve">
          <source>Print the pg_isready version and exit.</source>
          <target state="translated">pg_isreadyバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="521a97d4453901044173e646cb65a707141a7eb2" translate="yes" xml:space="preserve">
          <source>Print the pg_receivewal version and exit.</source>
          <target state="translated">pg_receivewalのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="8fea9240f920d019a51b3b8ffd1d91229e6f0d5d" translate="yes" xml:space="preserve">
          <source>Print the pg_recvlogical version and exit.</source>
          <target state="translated">pg_recvlogicalバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="70b6553fafd53c48b770a9da4d3ec37d70a8b1bd" translate="yes" xml:space="preserve">
          <source>Print the pg_restore version and exit.</source>
          <target state="translated">pg_restoreのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="6c61b85690c18a6b2ca1bca9177c45ff31b5bf02" translate="yes" xml:space="preserve">
          <source>Print the pg_test_fsync version and exit.</source>
          <target state="translated">pg_test_fsyncのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="b30cd37e82aef2f652a2277ade9f7c97f25f875b" translate="yes" xml:space="preserve">
          <source>Print the pg_test_timing version and exit.</source>
          <target state="translated">pg_test_timingのバージョンを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="a75796fa54df85333380d1e7052d5f64abec4dce" translate="yes" xml:space="preserve">
          <source>Print the pg_waldump version and exit.</source>
          <target state="translated">pg_waldumpのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="835f88fb67301afbc19bedf23ff78555f1978387" translate="yes" xml:space="preserve">
          <source>Print the pgbench version and exit.</source>
          <target state="translated">pgbench のバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="f24e000355bdd04337ccc4fe4d288fbdae421623" translate="yes" xml:space="preserve">
          <source>Print the postgres version and exit.</source>
          <target state="translated">postgresのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="a240d07648994ecf31009ecc7c34fcbc6cd8c620" translate="yes" xml:space="preserve">
          <source>Print the psql version and exit.</source>
          <target state="translated">psqlのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="9739b8f99cc181f488382f72fe14dfc0f6cbc479" translate="yes" xml:space="preserve">
          <source>Print the reindexdb version and exit.</source>
          <target state="translated">reindexdbのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="ecaad77a21e5cec5eaf16f12e5d3692f68b6cf4f" translate="yes" xml:space="preserve">
          <source>Print the vacuumdb version and exit.</source>
          <target state="translated">vacuumdbのバージョンを印刷して終了します。</target>
        </trans-unit>
        <trans-unit id="860a0a17430dffac960ad73d395384c352d45cdd" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CC&lt;/code&gt; variable that was used for building PostgreSQL. This shows the C compiler used.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;CC&lt;/code&gt; 変数の値を出力します。これは、使用されているCコンパイラを示しています。</target>
        </trans-unit>
        <trans-unit id="7872c242661cddddfe9f42b05b47dc0212422396" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;CFLAGS&lt;/code&gt; 変数の値を出力します。これはCコンパイラスイッチを示しています。</target>
        </trans-unit>
        <trans-unit id="04b3c2f0676508a38269ff7567031f4ef2b568d8" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows extra C compiler switches used for building shared libraries.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;CFLAGS_SL&lt;/code&gt; 変数の値を出力します。これは、共有ライブラリの構築に使用される追加のCコンパイラスイッチを示しています。</target>
        </trans-unit>
        <trans-unit id="7c0bdef9295fb7af405415912b5de766b9d4853d" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;CPPFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows C compiler switches needed at preprocessing time (typically, &lt;code&gt;-I&lt;/code&gt; switches).</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;CPPFLAGS&lt;/code&gt; 変数の値を出力します。これは、前処理時に必要なCコンパイラスイッチ（通常は &lt;code&gt;-I&lt;/code&gt; スイッチ）を示しています。</target>
        </trans-unit>
        <trans-unit id="0696181ec9c948b2b028ffaf665cb6bea3b893d7" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;LDFLAGS&lt;/code&gt; 変数の値を出力します。これはリンカスイッチを示しています。</target>
        </trans-unit>
        <trans-unit id="6bb0fe5ffeea6cad2f014a2a3a3b8da60923296c" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_EX&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building executables only.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;LDFLAGS_EX&lt;/code&gt; 変数の値を出力します。これは、実行可能ファイルのビルドのみに使用されるリンカースイッチを示しています。</target>
        </trans-unit>
        <trans-unit id="afbd4079f245521defb38cf6819d6a459fcf80ee" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LDFLAGS_SL&lt;/code&gt; variable that was used for building PostgreSQL. This shows linker switches used for building shared libraries only.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;LDFLAGS_SL&lt;/code&gt; 変数の値を出力します。これは、共有ライブラリのビルドにのみ使用されるリンカースイッチを示しています。</target>
        </trans-unit>
        <trans-unit id="6ca57dae88c29583c5d57897894867bc83f03e6b" translate="yes" xml:space="preserve">
          <source>Print the value of the &lt;code&gt;LIBS&lt;/code&gt; variable that was used for building PostgreSQL. This normally contains &lt;code&gt;-l&lt;/code&gt; switches for external libraries linked into PostgreSQL.</source>
          <target state="translated">PostgreSQLの構築に使用された &lt;code&gt;LIBS&lt;/code&gt; 変数の値を出力します。これには通常、PostgreSQLにリンクされた外部ライブラリの &lt;code&gt;-l&lt;/code&gt; スイッチが含まれます。</target>
        </trans-unit>
        <trans-unit id="8570b6b8795434406c72b8b33b0f9520fcd7b330" translate="yes" xml:space="preserve">
          <source>Print the version of PostgreSQL.</source>
          <target state="translated">PostgreSQLのバージョンを印刷します。</target>
        </trans-unit>
        <trans-unit id="c7df780f62e4b06755a28e7503d78d06b7b6aac8" translate="yes" xml:space="preserve">
          <source>Print time information and other statistics at the end of each command. This is useful for benchmarking or for use in tuning the number of buffers.</source>
          <target state="translated">各コマンドの最後に時間情報やその他の統計情報を表示します。これは、ベンチマークを行う際や、バッファの数を調整する際に使用するのに便利です。</target>
        </trans-unit>
        <trans-unit id="7df4a5fb243017c5e16941bc4e0dfea430b29b29" translate="yes" xml:space="preserve">
          <source>Print timing statistics for each query relating to each of the major system modules. This option cannot be used together with the &lt;code&gt;-s&lt;/code&gt; option.</source>
          <target state="translated">主要なシステムモジュールのそれぞれに関連する各クエリのタイミング統計を出力します。このオプションは、 &lt;code&gt;-s&lt;/code&gt; オプションと一緒に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="85a0746f8a9b8ded581582b11332c0023bccc928" translate="yes" xml:space="preserve">
          <source>Print verbose debugging output that is mostly useful for developers debugging pg_rewind.</source>
          <target state="translated">pg_rewindをデバッグする開発者にとって主に有用な、冗長なデバッグ出力を出力します。</target>
        </trans-unit>
        <trans-unit id="97b0c0a03f737e5ff32021d5ed70701853641a62" translate="yes" xml:space="preserve">
          <source>Prints a detailed vacuum activity report for each table.</source>
          <target state="translated">各テーブルの詳細な真空活動レポートを印刷します。</target>
        </trans-unit>
        <trans-unit id="fdb87a5e1b1bdc10bff754f8e203de6fe5cda103" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each index is reindexed.</source>
          <target state="translated">各インデックスが再インデックス化された際の進捗レポートを表示します。</target>
        </trans-unit>
        <trans-unit id="aa656d5b9337debc039cad558013cd97db922af4" translate="yes" xml:space="preserve">
          <source>Prints a progress report as each table is clustered.</source>
          <target state="translated">各テーブルがクラスタ化されているので、進捗レポートを印刷します。</target>
        </trans-unit>
        <trans-unit id="b8b2b40104cd92cd0c519f2553360402afa05710" translate="yes" xml:space="preserve">
          <source>Prints the arguments to the standard output, separated by one space and followed by a newline. This can be useful to intersperse information in the output of scripts. For example:</source>
          <target state="translated">引数をスペースで区切って改行して標準出力に出力します。これは、スクリプトの出力に情報を散りばめたいときに便利です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f89aa4d95dc992bd35115af766260f55953c5bc3" translate="yes" xml:space="preserve">
          <source>Prints the value of the named run-time parameter, and exits. (See the &lt;code&gt;-c&lt;/code&gt; option above for details.) This can be used on a running server, and returns values from &lt;code&gt;postgresql.conf&lt;/code&gt;, modified by any parameters supplied in this invocation. It does not reflect parameters supplied when the cluster was started.</source>
          <target state="translated">指定された実行時パラメータの値を出力して、終了します。（詳細については、上記の &lt;code&gt;-c&lt;/code&gt; オプションを参照してください。）これは実行中のサーバーで使用でき、 &lt;code&gt;postgresql.conf&lt;/code&gt; からの値を返します。この呼び出しで指定されたパラメーターによって変更されます。クラスターの起動時に提供されたパラメーターは反映されません。</target>
        </trans-unit>
        <trans-unit id="4dcba485023d207a9206ea5fc3e3c00fb561414e" translate="yes" xml:space="preserve">
          <source>Prior releases of PostgreSQL also had an R-tree index method. This method has been removed because it had no significant advantages over the GiST method. If &lt;code&gt;USING rtree&lt;/code&gt; is specified, &lt;code&gt;CREATE INDEX&lt;/code&gt; will interpret it as &lt;code&gt;USING gist&lt;/code&gt;, to simplify conversion of old databases to GiST.</source>
          <target state="translated">PostgreSQLの以前のリリースには、Rツリーインデックスメソッドもありました。このメソッドは、GiSTメソッドに比べて大きな利点がないため削除されました。場合は &lt;code&gt;USING rtree&lt;/code&gt; 指定され、 &lt;code&gt;CREATE INDEX&lt;/code&gt; としてそれを解釈する &lt;code&gt;USING gist&lt;/code&gt; のGiSTに古いデータベースの変換を簡単にするために、。</target>
        </trans-unit>
        <trans-unit id="3bafe92248149caf71bc79d94b8990987f12cfb7" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 10, this rule did not exist, and unspecified-type literals in a &lt;code&gt;SELECT&lt;/code&gt; output list were left as type &lt;code&gt;unknown&lt;/code&gt;. That had assorted bad consequences, so it's been changed.</source>
          <target state="translated">PostgreSQL 10より前のバージョンでは、このルールは存在せず、 &lt;code&gt;SELECT&lt;/code&gt; 出力リスト内の指定されていないタイプのリテラルはタイプ &lt;code&gt;unknown&lt;/code&gt; のままでした。それはさまざまな悪い結果をもたらしたので、変更されました。</target>
        </trans-unit>
        <trans-unit id="35b1eb24223c97f90cf161ff4a23f9a4840e576e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 12, it was possible to skip arbitrary text in the input string using non-letter or non-digit characters. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; used to work. Now you can only use letter characters for this purpose. For example, &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; skip &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 12より前のバージョンでは、非文字または非数字文字を使用して、入力文字列の任意のテキストをスキップすることが可能でした。たとえば、 &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy-MM-DD')&lt;/code&gt; 以前は機能していました。現在、この目的で使用できるのは文字のみです。たとえば、 &lt;code&gt;to_timestamp('2000y6m1d', 'yyyytMMtDDt')&lt;/code&gt; および &lt;code&gt;to_timestamp('2000y6m1d', 'yyyy&quot;y&quot;MM&quot;m&quot;DD&quot;d&quot;')&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;m&lt;/code&gt; 、および &lt;code&gt;d&lt;/code&gt; をスキップします。</target>
        </trans-unit>
        <trans-unit id="857acef4a685e40620b468c416dd0a4e24020172" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; cases were not handled per SQL specification. A comparison like &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; was implemented as &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; whereas the correct behavior is equivalent to &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 8.2より前のバージョンでは、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;gt;=&lt;/code&gt; のケースはSQL仕様に従って処理されませんでした。 &lt;code&gt;ROW(a,b) &amp;lt; ROW(c,d)&lt;/code&gt; ような比較はa &lt;code&gt;a &amp;lt; c AND b &amp;lt; d&lt;/code&gt; として実装されましたが、正しい動作は &lt;code&gt;a &amp;lt; c OR (a = c AND b &amp;lt; d)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="4ebe12687d87000c523fc24a0eeeef23def50ea6" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were called &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;, respectively. These names are still available, but are deprecated and will eventually be removed. Notice that the old names are reversed from the convention formerly followed by the core geometric data types!</source>
          <target state="translated">PostgreSQL 8.2以前では、包含演算子 &lt;code&gt;@&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;@&lt;/code&gt; はそれぞれ &lt;code&gt;@&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; と呼ばれていました。これらの名前は引き続き使用できますが、非推奨であり、最終的には削除されます。古い名前は、従来のコアジオメトリックデータタイプが後に続く規則とは逆になっていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5348a6ba1728be7d24665ecab38998e34ce72cc3" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.0, there was no permission structure associated with large objects. As a result, &lt;code&gt;pg_largeobject&lt;/code&gt; was publicly readable and could be used to obtain the OIDs (and contents) of all large objects in the system. This is no longer the case; use &lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt;&lt;code&gt;pg_largeobject_metadata&lt;/code&gt;&lt;/a&gt; to obtain a list of large object OIDs.</source>
          <target state="translated">PostgreSQL 9.0より前のバージョンでは、ラージオブジェクトに関連付けられた権限構造はありませんでした。その結果、 &lt;code&gt;pg_largeobject&lt;/code&gt; はパブリックに読み取り可能であり、システム内のすべてのラージオブジェクトのOID（およびコンテンツ）を取得するために使用できました。これはもう当てはまりません。&lt;a href=&quot;catalog-pg-largeobject-metadata&quot;&gt; &lt;code&gt;pg_largeobject_metadata&lt;/code&gt; &lt;/a&gt;を使用して、ラージオブジェクトOIDのリストを取得します。</target>
        </trans-unit>
        <trans-unit id="b601cf233ea62fc96a74bc628fe24fcc3e36d22e" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL 9.3, only System V shared memory was used, so the amount of System V shared memory required to start the server was much larger. If you are running an older version of the server, please consult the documentation for your server version.</source>
          <target state="translated">PostgreSQL 9.3より前のバージョンでは、System Vの共有メモリしか使用していなかったため、サーバの起動に必要なSystem Vの共有メモリの量が多くなっていました。古いバージョンのサーバを実行している場合は、お使いのサーバのバージョンのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="aa951ebcd4fe7e0105a5593fae4e308d45c56780" translate="yes" xml:space="preserve">
          <source>Prior to PostgreSQL version 9.1, a request for the Serializable transaction isolation level provided exactly the same behavior described here. To retain the legacy Serializable behavior, Repeatable Read should now be requested.</source>
          <target state="translated">PostgreSQLバージョン9.1以前では、Serializableトランザクション分離レベルの要求は、ここで説明した動作と全く同じ動作を提供していました。従来のSerializableの動作を保持するために、Repeatable Readを要求するようになりました。</target>
        </trans-unit>
        <trans-unit id="284364f281ed56be49bcacf7f01665e2a0a6fd04" translate="yes" xml:space="preserve">
          <source>Priority of this standby server for being chosen as the synchronous standby in a priority-based synchronous replication. This has no effect in a quorum-based synchronous replication.</source>
          <target state="translated">優先度ベースの同期レプリケーションで同期スタンバイとして選択されるこのスタンバイサーバの優先度。これは、クォーラムベースの同期レプリケーションでは効果がありません。</target>
        </trans-unit>
        <trans-unit id="515ede092cef3c82a110d9534d9f8d3d6afc3135" translate="yes" xml:space="preserve">
          <source>Privilege</source>
          <target state="translated">Privilege</target>
        </trans-unit>
        <trans-unit id="f10ec7ea8e1d8b3a37e319a1b22811778ff9078d" translate="yes" xml:space="preserve">
          <source>Privilege and Ownership - &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;REASSIGN&lt;/code&gt;</source>
          <target state="translated">特権と所有権 &lt;code&gt;GRANT&lt;/code&gt; 、 &lt;code&gt;REVOKE&lt;/code&gt; 、 &lt;code&gt;REASSIGN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de3a5e762db24187db518d22a3b23c1896a649d9" translate="yes" xml:space="preserve">
          <source>Privileges</source>
          <target state="translated">Privileges</target>
        </trans-unit>
        <trans-unit id="2a58093a093ab7a9a99a1645efb525934d0d372c" translate="yes" xml:space="preserve">
          <source>Privileges are only checked once at the start of a replication connection. They are not re-checked as each change record is read from the publisher, nor are they re-checked for each change when applied.</source>
          <target state="translated">特権のチェックはレプリケーション接続の開始時に一度だけ行われます。各変更レコードがパブリッシャーから読み込まれるたびに再チェックされることはありませんし、適用されるたびに再チェックされることもありません。</target>
        </trans-unit>
        <trans-unit id="1787c604579783f25be8d303f900f7717e89e48f" translate="yes" xml:space="preserve">
          <source>Privileges on databases, tablespaces, schemas, and languages are PostgreSQL extensions.</source>
          <target state="translated">データベース、テーブル空間、スキーマ、言語の特権はPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="46289836967711686edf2dff70a298178c49970e" translate="yes" xml:space="preserve">
          <source>Probe that fires after dirty buffers have been written to the kernel, and before starting to issue fsync requests.</source>
          <target state="translated">ダーティバッファがカーネルに書き込まれた後、fsync リクエストの発行を開始する前に発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="53ee2024c54dc2129f5d4dce9249284ce7d962e4" translate="yes" xml:space="preserve">
          <source>Probe that fires after each buffer is written during checkpoint. arg0 is the ID number of the buffer.</source>
          <target state="translated">チェックポイント中に各バッファが書き込まれた後に発生するプローブ arg0 はバッファの ID 番号です。</target>
        </trans-unit>
        <trans-unit id="3c4f6900a8f3d94a47b827dad74ca58a7f090a3e" translate="yes" xml:space="preserve">
          <source>Probe that fires anytime the server process updates its &lt;code&gt;pg_stat_activity&lt;/code&gt;.&lt;code&gt;status&lt;/code&gt;. arg0 is the new status string.</source>
          <target state="translated">サーバープロセスが &lt;code&gt;pg_stat_activity&lt;/code&gt; を更新するたびに起動するプローブ。 &lt;code&gt;status&lt;/code&gt; 。arg0は新しいステータス文字列です。</target>
        </trans-unit>
        <trans-unit id="453f8db7eb85902c8d7efba2100824b715baeb8d" translate="yes" xml:space="preserve">
          <source>Probe that fires at the start of a new transaction. arg0 is the transaction ID.</source>
          <target state="translated">新しいトランザクションの開始時に発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="3a3aefacb2b30c73490e38f66077f014ccc50ebf" translate="yes" xml:space="preserve">
          <source>Probe that fires before issuing any write request for a shared buffer. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">arg0 と arg1 にはページのフォーク番号とブロック番号が格納されます。</target>
        </trans-unit>
        <trans-unit id="33d263a06d1f645788a7d9cc687ecf761651c94e" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL record is inserted. arg0 is the resource manager (rmid) for the record. arg1 contains the info flags.</source>
          <target state="translated">WALレコードが挿入されたときに発生するプローブです。 arg0はレコードのリソースマネージャ(rmid)です。</target>
        </trans-unit>
        <trans-unit id="9f1168c24751c9cc0c2a8a2c6b3927e1a19c2275" translate="yes" xml:space="preserve">
          <source>Probe that fires when a WAL segment switch is requested.</source>
          <target state="translated">WAL セグメントスイッチが要求されたときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="8e4d476400e68096572772c60276c43e69c8a62b" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block read is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually read, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">ブロック読み取りが完了したときに起動するプローブ。 arg0とarg1には、ページのフォーク番号とブロック番号が含まれています。 arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。 arg5は、ローカルバッファーの一時的な関係を作成したバックエンドのID、または共有バッファーの &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）です。 arg6は実際に読み取られたバイト数ですが、arg7は要求された数です（これらが異なる場合は問題があることを示します）。</target>
        </trans-unit>
        <trans-unit id="bec87f01b3c4ae7574229debd84c5fd432c77b1a" translate="yes" xml:space="preserve">
          <source>Probe that fires when a block write is complete. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is the number of bytes actually written, while arg7 is the number requested (if these are different it indicates trouble).</source>
          <target state="translated">ブロック書き込みが完了したときに起動するプローブ。 arg0とarg1には、ページのフォーク番号とブロック番号が含まれています。 arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。 arg5は、ローカルバッファーの一時的な関係を作成したバックエンドのID、または共有バッファーの &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）です。 arg6は実際に書き込まれたバイト数であり、arg7は要求された数です（これらが異なる場合、問題を示します）。</target>
        </trans-unit>
        <trans-unit id="46f91b3dd629f638c1e5b0918321dc6a1503deb9" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is complete. arg0 and arg1 contain the fork and block numbers of the page (if this is a relation extension request, arg1 now contains the block number of the newly added block). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read. arg7 is true if the buffer was found in the pool, false if not.</source>
          <target state="translated">バッファーの読み取りが完了したときに起動するプローブ。 arg0とarg1には、ページのフォーク番号とブロック番号が含まれます（これがリレーション拡張要求の場合、arg1には新しく追加されたブロックのブロック番号が含まれます）。 arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。 arg5は、ローカルバッファーの一時的な関係を作成したバックエンドのID、または共有バッファーの &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）です。 arg6は、関係拡張リクエストの場合はtrue、通常の読み取りの場合はfalseです。 arg7は、バッファーがプールで見つかった場合はtrue、見つからなかった場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="58ba85ae8dc3ff12abd986e1bbe24ce88cd6ffee" translate="yes" xml:space="preserve">
          <source>Probe that fires when a buffer read is started. arg0 and arg1 contain the fork and block numbers of the page (but arg1 will be -1 if this is a relation extension request). arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer. arg6 is true for a relation extension request, false for normal read.</source>
          <target state="translated">バッファーの読み取りが開始されたときに起動するプローブ。arg0とarg1には、ページのフォーク番号とブロック番号が含まれます（ただし、これが関係拡張リクエストの場合、arg1は-1になります）。arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。arg5は、ローカルバッファーの一時的な関係を作成したバックエンドのID、または共有バッファーの &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）です。arg6は、関係拡張リクエストの場合はtrue、通常の読み取りの場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="0fbe84f59555154d75e50194b6717675ebf83d0f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is complete. (The probes listed next fire in sequence during checkpoint processing.) arg0 is the number of buffers written. arg1 is the total number of buffers. arg2, arg3 and arg4 contain the number of WAL files added, removed and recycled respectively.</source>
          <target state="translated">チェックポイントが完了したときに起動するプローブ。arg0は書き込まれたバッファの数、arg1はバッファの総数、arg2、arg3、arg4はそれぞれWALファイルの追加数、削除数、リサイクル数を格納します。</target>
        </trans-unit>
        <trans-unit id="23fe54bf3cce9571085cc7cf6504d3feaa949415" translate="yes" xml:space="preserve">
          <source>Probe that fires when a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">チェックポイントが開始されたときに発生するプローブ arg0 は、シャットダウン、即時、強制など、異なるチェックポイントタイプを区別するために使用されるビット単位のフラグを保持しています。</target>
        </trans-unit>
        <trans-unit id="93bbd1ca880ff804d869958124aceb46cced58c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when a deadlock is found by the deadlock detector.</source>
          <target state="translated">デッドロック検出器でデッドロックが検出された場合に発火するプローブ。</target>
        </trans-unit>
        <trans-unit id="cd2095b8769349eb00b3e4c4c59eb7c9f09aa65d" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty WAL buffer write is complete.</source>
          <target state="translated">ダーティな WAL バッファ書き込みが完了したときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="e06e64448ac61e5f30e9d0aae09a59b087a40467" translate="yes" xml:space="preserve">
          <source>Probe that fires when a dirty-buffer write is complete. The arguments are the same as for &lt;code&gt;buffer-write-dirty-start&lt;/code&gt;.</source>
          <target state="translated">ダーティバッファの書き込みが完了したときに起動するプローブ。引数は &lt;code&gt;buffer-write-dirty-start&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="bc7ff5d60d95edecd39d25ce953e04898f2adf03" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has begun to wait because the lock is not available. arg0 through arg3 are the tag fields identifying the object being locked. arg4 indicates the type of object being locked. arg5 indicates the lock type being requested.</source>
          <target state="translated">arg0 ~ arg3 はロックされているオブジェクトを識別するタグフィールド、 arg4 はロックされているオブジェクトのタイプ、 arg5 は要求されているロックのタイプを示します。</target>
        </trans-unit>
        <trans-unit id="4162528ebd10f947261c421936db3a10071c6bda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a request for a heavyweight lock (lmgr lock) has finished waiting (i.e., has acquired the lock). The arguments are the same as for &lt;code&gt;lock-wait-start&lt;/code&gt;.</source>
          <target state="translated">重量ロック（lmgrロック）の要求が待機を終了した（つまり、ロックを取得した）ときに起動するプローブ。引数は &lt;code&gt;lock-wait-start&lt;/code&gt; の場合と同じです。</target>
        </trans-unit>
        <trans-unit id="c611257e152cea80f6cfc845709b8d0de904351c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty WAL buffer because no more WAL buffer space is available. (If this happens often, it implies that &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; is too small.)</source>
          <target state="translated">使用可能なWALバッファースペースがなくなったため、サーバープロセスがダーティWALバッファーの書き込みを開始したときに起動するプローブ。（これが頻繁に発生する場合は、&lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt;が小さすぎることを意味します。）</target>
        </trans-unit>
        <trans-unit id="f78264e8172fbf9d18964b5de63c4b5c50a37b93" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process begins to write a dirty buffer. (If this happens often, it implies that &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; is too small or the background writer control parameters need adjustment.) arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation.</source>
          <target state="translated">サーバープロセスがダーティバッファの書き込みを開始したときに起動するプローブ。（これが頻繁に発生する場合は、&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;が小さすぎるか、バックグラウンドライターの制御パラメーターを調整する必要があることを意味します。）arg0とarg1には、ページのフォーク番号とブロック番号が含まれています。arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。</target>
        </trans-unit>
        <trans-unit id="ab6028b90f757cbb259294d12f57f8c712860524" translate="yes" xml:space="preserve">
          <source>Probe that fires when a server process has been released from its wait for an LWLock (it does not actually have the lock yet). arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0 は LWLock のトランシェ、arg1 は要求されたロックモード (exclusive または shared)です。</target>
        </trans-unit>
        <trans-unit id="327d56ed2b9d3f4cc36bd9b948fbb4da61129ae8" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort is complete. arg0 is true for external sort, false for internal sort. arg1 is the number of disk blocks used for an external sort, or kilobytes of memory used for an internal sort.</source>
          <target state="translated">arg0 は外部ソートの場合は true、内部ソートの場合は false です。 arg1 は外部ソートで使用するディスクブロック数、内部ソートで使用するメモリのキロバイト数です。</target>
        </trans-unit>
        <trans-unit id="4a9847b929f87d2af0af81f9222c2554ede52eda" translate="yes" xml:space="preserve">
          <source>Probe that fires when a sort operation is started. arg0 indicates heap, index or datum sort. arg1 is true for unique-value enforcement. arg2 is the number of key columns. arg3 is the number of kilobytes of work memory allowed. arg4 is true if random access to the sort result is required. arg5 indicates serial when &lt;code&gt;0&lt;/code&gt;, parallel worker when &lt;code&gt;1&lt;/code&gt;, or parallel leader when &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">ソート操作が開始されたときに起動するプローブ。arg0は、ヒープ、インデックス、またはデータのソートを示します。arg1は、一意の値を適用する場合にtrueです。arg2はキー列の数です。arg3は、許可される作業メモリーのキロバイト数です。ソート結果へのランダムアクセスが必要な場合、arg4はtrueです。arg5は、 &lt;code&gt;0&lt;/code&gt; の場合はシリアル、 &lt;code&gt;1&lt;/code&gt; の場合はパラレルワーカー、 &lt;code&gt;2&lt;/code&gt; の場合はパラレルリーダーを示します。</target>
        </trans-unit>
        <trans-unit id="9a6c578cf9ebf6dafcb797b30e10c8c0ea10449f" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes successfully. arg0 is the transaction ID.</source>
          <target state="translated">トランザクションが正常に完了したときに発生するプローブ arg0 はトランザクション ID です。</target>
        </trans-unit>
        <trans-unit id="4a8dcaad5632a5c029ca8a4cd70eeafe1ca847b1" translate="yes" xml:space="preserve">
          <source>Probe that fires when a transaction completes unsuccessfully. arg0 is the transaction ID.</source>
          <target state="translated">トランザクションが正常に完了しなかった場合に発生するプローブ arg0 はトランザクション ID です。</target>
        </trans-unit>
        <trans-unit id="17050254a1180d83c2f09021018121a20c9a108c" translate="yes" xml:space="preserve">
          <source>Probe that fires when a write request is complete. (Note that this just reflects the time to pass the data to the kernel; it's typically not actually been written to disk yet.) The arguments are the same as for &lt;code&gt;buffer-flush-start&lt;/code&gt;.</source>
          <target state="translated">書き込み要求が完了したときに起動するプローブ。（これは、データをカーネルに渡す時間を反映していることに注意してください。通常、実際にはまだディスクに書き込まれていません。）引数は、 &lt;code&gt;buffer-flush-start&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="8e023e6af3bb6f75b33af22efff6aa6afa3fd941" translate="yes" xml:space="preserve">
          <source>Probe that fires when all dirty buffers have been written. arg0 is the total number of buffers. arg1 is the number of buffers actually written by the checkpoint process. arg2 is the number that were expected to be written (arg1 of &lt;code&gt;buffer-sync-start&lt;/code&gt;); any difference reflects other processes flushing buffers during the checkpoint.</source>
          <target state="translated">すべてのダーティバッファが書き込まれたときに起動するプローブ。arg0はバッファーの総数です。arg1は、チェックポイントプロセスによって実際に書き込まれたバッファの数です。arg2は、書き込まれると予想された番号です（ &lt;code&gt;buffer-sync-start&lt;/code&gt; の arg1 ）。違いは、チェックポイント中にバッファをフラッシュする他のプロセスを反映しています。</target>
        </trans-unit>
        <trans-unit id="466cfd0176351b56d635f32f0410727040245d40" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been acquired. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0 は LWLock のトランシェ、arg1 は要求されたロックモードです。</target>
        </trans-unit>
        <trans-unit id="6121be81d01b11fd11854f3cc9d63c7a9a5f1cbf" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock has been released (but note that any released waiters have not yet been awakened). arg0 is the LWLock's tranche.</source>
          <target state="translated">LWLock がリリースされたときに起動するプローブです (ただし、リリースされたウェイターはまだ目覚めていないことに注意してください)。 arg0 は LWLock のトランシェです。</target>
        </trans-unit>
        <trans-unit id="eee4a231a6a278d84a4bf21d96cfbf0b033695e4" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not immediately available and a server process has begun to wait for the lock to become available. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0 は LWLock のトランシェ、arg1 は要求されたロックモード (exclusive または shared)です。</target>
        </trans-unit>
        <trans-unit id="32b5dee951d8d8bbcc4c527b18fd9921e80f05ea" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was not successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0 は LWLock のトランシェ、arg1 は要求されたロックモード (排他的または共有)です。</target>
        </trans-unit>
        <trans-unit id="29ccd443bca3bd38a197795375408911c2de33c3" translate="yes" xml:space="preserve">
          <source>Probe that fires when an LWLock was successfully acquired when the caller specified no waiting. arg0 is the LWLock's tranche. arg1 is the requested lock mode, either exclusive or shared.</source>
          <target state="translated">arg0 は LWLock のトランシェ、arg1 は要求されたロックモード (排他的または共有)です。</target>
        </trans-unit>
        <trans-unit id="9fe33e9001aca2852cd9dca52b36bdbecb7c1f32" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to read a block from a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">リレーションからブロックの読み取りを開始したときに起動するプローブ。arg0とarg1には、ページのフォーク番号とブロック番号が含まれています。arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。arg5は、ローカルバッファーの一時的な関係を作成したバックエンドのID、または共有バッファーの &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）です。</target>
        </trans-unit>
        <trans-unit id="d3f7e8aeab722a5eb71c03e5e72e466f6f7d683f" translate="yes" xml:space="preserve">
          <source>Probe that fires when beginning to write a block to a relation. arg0 and arg1 contain the fork and block numbers of the page. arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs identifying the relation. arg5 is the ID of the backend which created the temporary relation for a local buffer, or &lt;code&gt;InvalidBackendId&lt;/code&gt; (-1) for a shared buffer.</source>
          <target state="translated">リレーションへのブロックの書き込みを開始したときに起動するプローブ。arg0とarg1には、ページのフォーク番号とブロック番号が含まれています。arg2、arg3、およびarg4には、テーブルスペース、データベース、および関係を識別する関係OIDが含まれています。arg5は、ローカルバッファーの一時的な関係を作成したバックエンドのID、または共有バッファーの &lt;code&gt;InvalidBackendId&lt;/code&gt; （-1）です。</target>
        </trans-unit>
        <trans-unit id="9cef86798a06a87b1e53005af8b7cffd9544c2ff" translate="yes" xml:space="preserve">
          <source>Probe that fires when syncing of buffers to disk is complete.</source>
          <target state="translated">バッファのディスクへの同期が完了したときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="7e4496f8bfaa3cf215e7723d1b3f6a6a44062ac3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;clog-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">チェックポイントのCLOG部分が完了したときに起動するプローブ。arg0は &lt;code&gt;clog-checkpoint-start&lt;/code&gt; と同じ意味です。</target>
        </trans-unit>
        <trans-unit id="1ce40580bfe3cc60932d40bba9c3a62201a4d419" translate="yes" xml:space="preserve">
          <source>Probe that fires when the CLOG portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">チェックポイントの CLOG 部分が開始されたときに発生するプローブ arg0 は通常のチェックポイントでは true、シャットダウンチェックポイントでは false です。</target>
        </trans-unit>
        <trans-unit id="f127e8e58e69f04b50616b0e221c7c59b7f1f3d1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;multixact-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">チェックポイントのMultiXact部分が完了したときに起動するプローブ。arg0は &lt;code&gt;multixact-checkpoint-start&lt;/code&gt; と同じ意味です。</target>
        </trans-unit>
        <trans-unit id="7db7d3684151dd5b3ccf2213972ecca8de60eb5e" translate="yes" xml:space="preserve">
          <source>Probe that fires when the MultiXact portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">チェックポイントの MultiXact 部分が開始されたときに発生するプローブ arg0 は通常のチェックポイントでは true、シャットダウンチェックポイントでは false です。</target>
        </trans-unit>
        <trans-unit id="19d184e6d4448ad19f4409d088d396f7df8c32d3" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is complete. arg0 has the same meaning as for &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt;.</source>
          <target state="translated">チェックポイントのSUBTRANS部分が完了したときに起動するプローブ。arg0は &lt;code&gt;subtrans-checkpoint-start&lt;/code&gt; と同じ意味です。</target>
        </trans-unit>
        <trans-unit id="406309c24a9ce7d667e2ff79d8bf7268a9ff9831" translate="yes" xml:space="preserve">
          <source>Probe that fires when the SUBTRANS portion of a checkpoint is started. arg0 is true for normal checkpoint, false for shutdown checkpoint.</source>
          <target state="translated">チェックポイントの SUBTRANS 部分が開始されたときに発生するプローブ arg0 は通常のチェックポイントでは true、シャットダウンチェックポイントでは false です。</target>
        </trans-unit>
        <trans-unit id="2d124d93cd049bd0371700c2959bdf0770b013e0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the buffer-writing portion of a checkpoint is started. arg0 holds the bitwise flags used to distinguish different checkpoint types, such as shutdown, immediate or force.</source>
          <target state="translated">チェックポイントのバッファ書き込み部分が開始されたときに発生するプローブ arg0 には、シャットダウン、即時、強制など、異なるチェックポイントタイプを区別するためのビット単位のフラグが格納されています。</target>
        </trans-unit>
        <trans-unit id="931b1ed777e93c094dcd52151780b666556374f1" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is complete.</source>
          <target state="translated">クエリの実行が完了したときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="6643c1646d73651ecf6358eff359f77c5055c16d" translate="yes" xml:space="preserve">
          <source>Probe that fires when the execution of a query is started.</source>
          <target state="translated">クエリの実行が開始されたときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="0944a082320c7bc732281e77e7ca49f36f32c834" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is complete. arg0 is the query string.</source>
          <target state="translated">クエリの解析が完了したときに発生するプローブ arg0 はクエリ文字列です。</target>
        </trans-unit>
        <trans-unit id="d96fa9e5daed0c63d0c0481d8ca8ebbe0a261583" translate="yes" xml:space="preserve">
          <source>Probe that fires when the parsing of a query is started. arg0 is the query string.</source>
          <target state="translated">クエリの解析が開始されたときに発生するプローブ arg0 はクエリ文字列です。</target>
        </trans-unit>
        <trans-unit id="9452ef2f9dd8e46c1c62afe77724fc190b423661" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is complete.</source>
          <target state="translated">クエリの計画が完了したときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="a1d4370c7121e9a518ec9800f508633ae2640459" translate="yes" xml:space="preserve">
          <source>Probe that fires when the planning of a query is started.</source>
          <target state="translated">クエリのプランニングが開始されたときに発生するプローブ。</target>
        </trans-unit>
        <trans-unit id="96a4a695589b1af8e96af229876a85b1ac6a6721" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is complete. arg0 is the query string.</source>
          <target state="translated">クエリの処理が完了したときに発生するプローブ arg0 はクエリ文字列です。</target>
        </trans-unit>
        <trans-unit id="17d08bdfb5f9889597cd8fad97751d8760642495" translate="yes" xml:space="preserve">
          <source>Probe that fires when the processing of a query is started. arg0 is the query string.</source>
          <target state="translated">クエリの処理が開始されたときに発生するプローブ arg0 はクエリ文字列です。</target>
        </trans-unit>
        <trans-unit id="eab217356aa735f20b49ab127f241495b6ade066" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is complete. arg0 is the query string.</source>
          <target state="translated">クエリの書き換えが完了したときに発生するプローブ arg0 はクエリ文字列です。</target>
        </trans-unit>
        <trans-unit id="a428364242cf9691158e2fd27eee09f0cdf33ee9" translate="yes" xml:space="preserve">
          <source>Probe that fires when the rewriting of a query is started. arg0 is the query string.</source>
          <target state="translated">クエリの書き換えが開始されたときに発生するプローブ arg0 はクエリ文字列です。</target>
        </trans-unit>
        <trans-unit id="21185778a7abdae335897b758940d7f751d2a6f0" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is complete.</source>
          <target state="translated">チェックポイントの二相部分が完了したときに発光するプローブ。</target>
        </trans-unit>
        <trans-unit id="0b37c215587e2b196fc6e3605c0952c5abaaeaa4" translate="yes" xml:space="preserve">
          <source>Probe that fires when the two-phase portion of a checkpoint is started.</source>
          <target state="translated">チェックポイントの二相部分が開始されたときに発光するプローブ。</target>
        </trans-unit>
        <trans-unit id="64dbe1e4375ac3d8c100dcc3b4624e32ba635dcb" translate="yes" xml:space="preserve">
          <source>Probe that fires when we begin to write dirty buffers during checkpoint (after identifying which buffers must be written). arg0 is the total number of buffers. arg1 is the number that are currently dirty and need to be written.</source>
          <target state="translated">チェックポイント中にダーティバッファの書き込みを開始したときに発生するプローブです(どのバッファを書き込まなければならないかを特定した後)。</target>
        </trans-unit>
        <trans-unit id="0e17699a3879dd39ab092b19091e781ba0c3179a" translate="yes" xml:space="preserve">
          <source>Procedural Languages (server-side)</source>
          <target state="translated">手続き型言語(サーバ側</target>
        </trans-unit>
        <trans-unit id="d23b357b75ad2622370788956db89d9cceb43ba0" translate="yes" xml:space="preserve">
          <source>Procedural languages are local to individual databases. However, a language can be installed into the &lt;code&gt;template1&lt;/code&gt; database, which will cause it to be available automatically in all subsequently-created databases.</source>
          <target state="translated">手続き型言語は、個々のデータベースに対してローカルです。ただし、言語は &lt;code&gt;template1&lt;/code&gt; データベースにインストールできます。これにより、その後作成されるすべてのデータベースで言語が自動的に使用可能になります。</target>
        </trans-unit>
        <trans-unit id="c80cc4229f5a9d3da6a7c3b6c8547ced65049640" translate="yes" xml:space="preserve">
          <source>Process ID</source>
          <target state="translated">プロセスID</target>
        </trans-unit>
        <trans-unit id="be2c2eb824ea5b51d9b5bce07c9b40cd34577acf" translate="yes" xml:space="preserve">
          <source>Process ID of a WAL sender process</source>
          <target state="translated">WAL送信者プロセスのプロセスID</target>
        </trans-unit>
        <trans-unit id="af10df8d6082fa39f1e4f58ff138720439c3d068" translate="yes" xml:space="preserve">
          <source>Process ID of a backend</source>
          <target state="translated">バックエンドのプロセスID</target>
        </trans-unit>
        <trans-unit id="373864156198cbd9c04a34d7ab3e6735c02719d2" translate="yes" xml:space="preserve">
          <source>Process ID of a backend or WAL sender process</source>
          <target state="translated">バックエンドまたはWAL送信者プロセスのプロセスID</target>
        </trans-unit>
        <trans-unit id="c5da887d9f68351aff22198bf3916a2bd05dd9d7" translate="yes" xml:space="preserve">
          <source>Process ID of backend.</source>
          <target state="translated">バックエンドのプロセスID。</target>
        </trans-unit>
        <trans-unit id="1aca36c0622a2538e27d8bf063d83ca00390c145" translate="yes" xml:space="preserve">
          <source>Process ID of the WAL receiver process</source>
          <target state="translated">WAL 受信プロセスのプロセス ID</target>
        </trans-unit>
        <trans-unit id="5d7d2e19d28ca6186fcc59c93b80889377f993f2" translate="yes" xml:space="preserve">
          <source>Process ID of the locker currently being waited for.</source>
          <target state="translated">現在待機中のロッカーのプロセスID</target>
        </trans-unit>
        <trans-unit id="01681ffc812bd9e058f3a6c5baf1409c4f0ba3bc" translate="yes" xml:space="preserve">
          <source>Process ID of the server process attached to the current session</source>
          <target state="translated">現在のセッションに接続されているサーバープロセスのプロセスID</target>
        </trans-unit>
        <trans-unit id="af8e0118b6d9e8d86d67cf0400739aba8210dd2b" translate="yes" xml:space="preserve">
          <source>Process ID of the server process handling the current session</source>
          <target state="translated">現在のセッションを処理しているサーバプロセスのプロセスID</target>
        </trans-unit>
        <trans-unit id="03fbcc6f1367738e610a0cace02a8fd6438fb048" translate="yes" xml:space="preserve">
          <source>Process ID of the server process holding or awaiting this lock, or null if the lock is held by a prepared transaction</source>
          <target state="translated">このロックを保持または待機しているサーバプロセスのプロセス ID、または準備されたトランザクショ ンによってロックが保持されている場合は NULL。</target>
        </trans-unit>
        <trans-unit id="999d9e41cb5cf7f111cc6e19904f6e291da38b6e" translate="yes" xml:space="preserve">
          <source>Process ID of the subscription worker process</source>
          <target state="translated">サブスクリプションワーカープロセスのプロセスID</target>
        </trans-unit>
        <trans-unit id="e1f52d5447d8eaecbf7bddfce74b35d1ffb039b9" translate="yes" xml:space="preserve">
          <source>Process ID of this backend</source>
          <target state="translated">このバックエンドのプロセスID</target>
        </trans-unit>
        <trans-unit id="d15b210cc1e134700f907b8b25d7b1043aa0ca7b" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a lock</source>
          <target state="translated">指定されたサーバプロセスIDのロック取得をブロックしているプロセスID</target>
        </trans-unit>
        <trans-unit id="6f132a3ada7bb531c167b75bc5eeea4c4aebfc18" translate="yes" xml:space="preserve">
          <source>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</source>
          <target state="translated">指定されたサーバプロセスIDが安全なスナップショットを取得することをブロックしているプロセスID</target>
        </trans-unit>
        <trans-unit id="f9b1d2668cc983dbc740512036c3c2a0339f13e5" translate="yes" xml:space="preserve">
          <source>Process IDs of locking backends (more than one if multitransaction)</source>
          <target state="translated">ロックバックエンドのプロセスID(マルチトランザクションの場合は複数)</target>
        </trans-unit>
        <trans-unit id="f966bc3f73e4a99fa5d7b7c8751d4573456fa586" translate="yes" xml:space="preserve">
          <source>Process Identifier</source>
          <target state="translated">プロセス識別子</target>
        </trans-unit>
        <trans-unit id="9404f1b149e0fa2944f7fe7f5a9758a8f27d7f2a" translate="yes" xml:space="preserve">
          <source>Process start time stamp</source>
          <target state="translated">プロセス開始タイムスタンプ</target>
        </trans-unit>
        <trans-unit id="9b87f820c5635b5c920ad2cf5059d2207d8f59e5" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. If the constraint is deferred, this error will be produced at constraint check time if there still exist any referencing rows. This is the default action.</source>
          <target state="translated">削除または更新により外部キー制約違反が発生することを示すエラーを生成します。制約が延期されている場合、このエラーは、参照する行がまだ存在する場合に制約チェック時に生成されます。これがデフォルトのアクションです。</target>
        </trans-unit>
        <trans-unit id="19db911f45836f08f67324db7d1d1b7713f59b5d" translate="yes" xml:space="preserve">
          <source>Produce an error indicating that the deletion or update would create a foreign key constraint violation. This is the same as &lt;code&gt;NO ACTION&lt;/code&gt; except that the check is not deferrable.</source>
          <target state="translated">削除または更新によって外部キー制約違反が発生することを示すエラーを生成します。これは、チェックを延期できないことを除いて、 &lt;code&gt;NO ACTION&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="595741604d266c8ba7ee063d34ab349a2aac4f77" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns, where &lt;code&gt;N&lt;/code&gt; is determined by the row type specified in the calling query</source>
          <target state="translated">行名と &lt;code&gt;N&lt;/code&gt; 値列を含む「ピボットテーブル」を作成します &lt;code&gt;N&lt;/code&gt; は、呼び出し元のクエリで指定された行タイプによって決定されます</target>
        </trans-unit>
        <trans-unit id="3b7d934bad462d22e3d780a0512ef5f70c8fefe7" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; containing row names plus &lt;code&gt;N&lt;/code&gt; value columns. &lt;code&gt;crosstab2&lt;/code&gt;, &lt;code&gt;crosstab3&lt;/code&gt;, and &lt;code&gt;crosstab4&lt;/code&gt; are predefined, but you can create additional &lt;code&gt;crosstabN&lt;/code&gt; functions as described below</source>
          <target state="translated">行名と &lt;code&gt;N&lt;/code&gt; 値列を含む「ピボットテーブル」を作成します。 &lt;code&gt;crosstab2&lt;/code&gt; 、 &lt;code&gt;crosstab3&lt;/code&gt; 、および &lt;code&gt;crosstab4&lt;/code&gt; は事前定義されていますが、以下で説明するように、追加の &lt;code&gt;crosstabN&lt;/code&gt; 関数を作成できます。</target>
        </trans-unit>
        <trans-unit id="953361f0fb07cbbdc30a8c3d39ada8d75e41aa1b" translate="yes" xml:space="preserve">
          <source>Produces a &amp;ldquo;pivot table&amp;rdquo; with the value columns specified by a second query</source>
          <target state="translated">2番目のクエリで指定された値列を含む「ピボットテーブル」を作成する</target>
        </trans-unit>
        <trans-unit id="eeb96fffad25790b78f8b2fd976762cd22e0262e" translate="yes" xml:space="preserve">
          <source>Produces a representation of a hierarchical tree structure</source>
          <target state="translated">階層的なツリー構造の表現を生成します。</target>
        </trans-unit>
        <trans-unit id="d2cf09a7cb7a5d996def491486e555116c8e56fe" translate="yes" xml:space="preserve">
          <source>Produces a set of normally distributed random values</source>
          <target state="translated">正規分布のランダム値の集合を生成します.</target>
        </trans-unit>
        <trans-unit id="9b3d37859bb87e00841bf5b68801363110571121" translate="yes" xml:space="preserve">
          <source>Produces no output, but tells non-session processes to stop at this point in the string; ignored by session processes</source>
          <target state="translated">出力を生成しませんが、セッションプロセス以外のプロセスに文字列のこの時点で停止するように指示します。</target>
        </trans-unit>
        <trans-unit id="c4cc122a953a1ad9e9d147019c31d589653986fa" translate="yes" xml:space="preserve">
          <source>Produces the intersection of two cubes.</source>
          <target state="translated">2つの立方体の交点を生成します。</target>
        </trans-unit>
        <trans-unit id="bc2b03c140585a107e123dbad9c7907236c487ae" translate="yes" xml:space="preserve">
          <source>Produces the union of two cubes.</source>
          <target state="translated">2つの立方体の和を生成します。</target>
        </trans-unit>
        <trans-unit id="3a873ea551f5b656a037c9a2775158084055a3fb" translate="yes" xml:space="preserve">
          <source>Programs using C code with embedded SQL have to be linked against the &lt;code&gt;libecpg&lt;/code&gt; library, for example using the linker options &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt;.</source>
          <target state="translated">組み込みSQLでCコードを使用するプログラムは、例えばリンカーオプション &lt;code&gt;-L/usr/local/pgsql/lib -lecpg&lt;/code&gt; を使用して &lt;code&gt;libecpg&lt;/code&gt; ライブラリーにリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="62babe4510e8d8a8ee8afda900ec73acd0a5dab6" translate="yes" xml:space="preserve">
          <source>Progress Reporting</source>
          <target state="translated">進捗報告</target>
        </trans-unit>
        <trans-unit id="3d02226c16e2d7d25eeaba8bd347cdb833f33050" translate="yes" xml:space="preserve">
          <source>Promotes a physical standby server. With &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; set to &lt;code&gt;true&lt;/code&gt; (the default), the function waits until promotion is completed or &lt;em&gt;&lt;code&gt;wait_seconds&lt;/code&gt;&lt;/em&gt; seconds have passed, and returns &lt;code&gt;true&lt;/code&gt; if promotion is successful and &lt;code&gt;false&lt;/code&gt; otherwise. If &lt;em&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/em&gt; is set to &lt;code&gt;false&lt;/code&gt;, the function returns &lt;code&gt;true&lt;/code&gt; immediately after sending &lt;code&gt;SIGUSR1&lt;/code&gt; to the postmaster to trigger the promotion. This function is restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">フィジカルスタンバイサーバーを昇格させます。&lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt;にセット &lt;code&gt;true&lt;/code&gt; プロモーションが完了するまで、または（デフォルト）、機能が待機&lt;em&gt; &lt;code&gt;wait_seconds&lt;/code&gt; の&lt;/em&gt;秒が経過している、と戻って &lt;code&gt;true&lt;/code&gt; プロモーションは成功している場合 &lt;code&gt;false&lt;/code&gt; そう。&lt;em&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/em&gt;が &lt;code&gt;false&lt;/code&gt; に設定されている場合、プロモーションをトリガーするために &lt;code&gt;SIGUSR1&lt;/code&gt; をポストマスターに送信した直後に、関数は &lt;code&gt;true&lt;/code&gt; を返します。この関数はデフォルトでスーパーユーザーに制限されていますが、他のユーザーにEXECUTEを付与して関数を実行できます。</target>
        </trans-unit>
        <trans-unit id="310745705e4b51911f7ad05e685132e85803b43c" translate="yes" xml:space="preserve">
          <source>Prompt for confirmation before actually removing the user, and prompt for the user name if none is specified on the command line.</source>
          <target state="translated">実際にユーザを削除する前に確認を促し、コマンドラインでユーザ名が指定されていない場合にはユーザ名の入力を促します。</target>
        </trans-unit>
        <trans-unit id="a4139dbdd33b4ca75eb092bf7d5f911f9e520f3e" translate="yes" xml:space="preserve">
          <source>Prompt for the user name if none is specified on the command line, and also prompt for whichever of the options &lt;code&gt;-d&lt;/code&gt;/&lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;/&lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;/&lt;code&gt;-S&lt;/code&gt; is not specified on the command line. (This was the default behavior up to PostgreSQL 9.1.)</source>
          <target state="translated">コマンドラインで何も指定されていない場合はユーザー名を要求し、コマンドラインで指定されていないオプション &lt;code&gt;-d&lt;/code&gt; / &lt;code&gt;-D&lt;/code&gt; 、 &lt;code&gt;-r&lt;/code&gt; / &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;-S&lt;/code&gt; のいずれかを要求します。（これはPostgreSQL 9.1までのデフォルトの動作でした。）</target>
        </trans-unit>
        <trans-unit id="4d970e24b22fc0f6e277e6e1b9c10241b2293ff1" translate="yes" xml:space="preserve">
          <source>Prompting</source>
          <target state="translated">Prompting</target>
        </trans-unit>
        <trans-unit id="7b9401a5b590107a8b6c6f9423644051eff19629" translate="yes" xml:space="preserve">
          <source>Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with &lt;code&gt;%[&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt;. Multiple pairs of these can occur within the prompt. For example:</source>
          <target state="translated">プロンプトには、たとえば、プロンプトテキストの色、背景、スタイルを変更したり、端末ウィンドウのタイトルを変更したりする端末制御文字を含めることができます。Readlineの行編集機能を適切に機能させるには、これらの非印刷制御文字を &lt;code&gt;%[&lt;/code&gt; および &lt;code&gt;%]&lt;/code&gt; で囲むことにより、非表示として指定する必要があります。これらの複数のペアがプロンプト内で発生する可能性があります。例えば：</target>
        </trans-unit>
        <trans-unit id="068e4f6fa6576b1f7eb180c4d966c9c332e88e9a" translate="yes" xml:space="preserve">
          <source>Prompts the user to supply text, which is assigned to the variable &lt;code&gt;name&lt;/code&gt;. An optional prompt string, &lt;code&gt;text&lt;/code&gt;, can be specified. (For multiword prompts, surround the text with single quotes.)</source>
          <target state="translated">変数 &lt;code&gt;name&lt;/code&gt; に割り当てられているテキストを入力するようにユーザーに要求します。オプションのプロンプト文字列 &lt;code&gt;text&lt;/code&gt; を指定できます。（マルチワードプロンプトの場合は、テキストを一重引用符で囲みます。）</target>
        </trans-unit>
        <trans-unit id="25a719c409be1921beafe5e788d439d93b07f5ff" translate="yes" xml:space="preserve">
          <source>Protocol head</source>
          <target state="translated">プロトコルヘッド</target>
        </trans-unit>
        <trans-unit id="1a9320a6ee345a64538cc41c73838b336f61862b" translate="yes" xml:space="preserve">
          <source>Protocol to use for submitting queries to the server:</source>
          <target state="translated">サーバにクエリを送信する際に使用するプロトコル。</target>
        </trans-unit>
        <trans-unit id="c1ac8c14d0bafdecefeefa05418d3e4bf8d46ea4" translate="yes" xml:space="preserve">
          <source>Provide an extension that will be stripped from all file names before deciding if they should be deleted. This is typically useful for cleaning up archives that have been compressed during storage, and therefore have had an extension added by the compression program. For example: &lt;code&gt;-x .gz&lt;/code&gt;.</source>
          <target state="translated">削除するかどうかを決定する前に、すべてのファイル名から削除される拡張子を指定します。これは通常、保存中に圧縮され、圧縮プログラムによって拡張子が追加されたアーカイブをクリーンアップするのに役立ちます。例： &lt;code&gt;-x .gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5c7f8ac0c8dc8b2a3526acf0eb6df53ded419c3" translate="yes" xml:space="preserve">
          <source>Provide information about extensions of client certificate: extension name, extension value, and if it is a critical extension.</source>
          <target state="translated">クライアント証明書の拡張子に関する情報を提供する:拡張子名、拡張子の値、およびそれが重要な拡張子である場合。</target>
        </trans-unit>
        <trans-unit id="7bc2350bc3b2039d9e0afed6b3606b6e8d63eb56" translate="yes" xml:space="preserve">
          <source>Provide the correct path to the database directory with &lt;code&gt;-D&lt;/code&gt;, or make sure that the environment variable &lt;code&gt;PGDATA&lt;/code&gt; is set. Also specify the name of the particular database you want to work in.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; を使用してデータベースディレクトリへの正しいパスを指定するか、環境変数 &lt;code&gt;PGDATA&lt;/code&gt; が設定されていることを確認してください。また、作業する特定のデータベースの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="7fba2085619c6e697d55f8299ef0ca805ea435a8" translate="yes" xml:space="preserve">
          <source>Provider of the collation: &lt;code&gt;d&lt;/code&gt; = database default, &lt;code&gt;c&lt;/code&gt; = libc, &lt;code&gt;i&lt;/code&gt; = icu</source>
          <target state="translated">照合のプロバイダー： &lt;code&gt;d&lt;/code&gt; =データベースのデフォルト、 &lt;code&gt;c&lt;/code&gt; = libc、 &lt;code&gt;i&lt;/code&gt; = icu</target>
        </trans-unit>
        <trans-unit id="b0a624c98e3417bfbf37f095267adcc37f1bdf46" translate="yes" xml:space="preserve">
          <source>Provider-specific version of the collation. This is recorded when the collation is created and then checked when it is used, to detect changes in the collation definition that could lead to data corruption.</source>
          <target state="translated">照合順序のプロバイダ固有のバージョン。これは照合順序の作成時に記録され、使用時にチェックされ、データ破損につながる可能性のある照合順序の定義の変更を検出します。</target>
        </trans-unit>
        <trans-unit id="813380993db87b7b78063d3b522dabe042e0e038" translate="yes" xml:space="preserve">
          <source>Provides information implicitly requested by the user, e.g., output from &lt;code&gt;VACUUM VERBOSE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM VERBOSE&lt;/code&gt; からの出力など、ユーザーが暗黙的に要求する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="de28296ee358cb5c7a7c1493346ff358cf83bc56" translate="yes" xml:space="preserve">
          <source>Provides information that might be helpful to users, e.g., notice of truncation of long identifiers.</source>
          <target state="translated">長い識別子の切り捨てに関する注意事項など、ユーザーにとって有用な情報を提供します。</target>
        </trans-unit>
        <trans-unit id="b544ef7e317c450388c8e22bbca337ffb169c783" translate="yes" xml:space="preserve">
          <source>Provides successively-more-detailed information for use by developers.</source>
          <target state="translated">開発者が使用するために、より詳細な情報を順次提供します。</target>
        </trans-unit>
        <trans-unit id="4085a3488b9b927970106c990aa79f6421cbdb9c" translate="yes" xml:space="preserve">
          <source>Provides warnings of likely problems, e.g., &lt;code&gt;COMMIT&lt;/code&gt; outside a transaction block.</source>
          <target state="translated">トランザクションブロック外での &lt;code&gt;COMMIT&lt;/code&gt; など、起こりそうな問題の警告を提供します。</target>
        </trans-unit>
        <trans-unit id="ff659eeee4de0858f88b33fd3f4e7746d59a5ad2" translate="yes" xml:space="preserve">
          <source>Pseudo-Types</source>
          <target state="translated">Pseudo-Types</target>
        </trans-unit>
        <trans-unit id="4ece916bc1c6f84ddff998832df4ef0ea2024f0a" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: any</source>
          <target state="translated">疑似タイプ:任意</target>
        </trans-unit>
        <trans-unit id="b47d9ee644ffb538aa98ee437eec99c988a8d15d" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyarray</source>
          <target state="translated">擬似型:anyarray</target>
        </trans-unit>
        <trans-unit id="22e5a6f841dae2418964bcaa84aa6a0a7f245549" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyelement</source>
          <target state="translated">擬似型:anyelement</target>
        </trans-unit>
        <trans-unit id="7a3f6d920428a6c8e5967a26fb4e46758728f6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyenum</source>
          <target state="translated">擬似型:anyenum</target>
        </trans-unit>
        <trans-unit id="84a873dc734548a1fe95e38fb333bb6d8bee10ef" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anynonarray</source>
          <target state="translated">疑似型:非配列</target>
        </trans-unit>
        <trans-unit id="3f53e360e11fbb973d5b222308c28fd5706c50dd" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: anyrange</source>
          <target state="translated">擬似型:anyrange</target>
        </trans-unit>
        <trans-unit id="df7657db40732623a8894c06b0028cc7640273e5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: cstring</source>
          <target state="translated">擬似型:cstring</target>
        </trans-unit>
        <trans-unit id="facd216b2d58500521e9c80e073f3f02e67f467b" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: event_trigger</source>
          <target state="translated">擬似型:event_trigger</target>
        </trans-unit>
        <trans-unit id="0c5c3ab69652fb55ae765ca8240e7c3bf40db9ce" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: fdw_handler</source>
          <target state="translated">擬似型:fdw_handler</target>
        </trans-unit>
        <trans-unit id="8d96c1feed021f0bd14872d446a70c55ec2a02e1" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: index_am_handler</source>
          <target state="translated">擬似型:index_am_handler</target>
        </trans-unit>
        <trans-unit id="8be67788a823313be97039f4a4b82ee6108f4b0f" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: internal</source>
          <target state="translated">疑似タイプ:内部</target>
        </trans-unit>
        <trans-unit id="c054109c5cb702aee10dbb32b0def25f56488525" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: language_handler</source>
          <target state="translated">擬似型:language_handler</target>
        </trans-unit>
        <trans-unit id="20a35bc47475d7650010ce766369afc8aabfb683" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: opaque</source>
          <target state="translated">疑似タイプ:不透明</target>
        </trans-unit>
        <trans-unit id="3674c8f90a9e09b98f639dae572ceb4253fed389" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: pg_ddl_command</source>
          <target state="translated">擬似型:pg_ddl_command</target>
        </trans-unit>
        <trans-unit id="c0325a47d21e05370cdf2a42ac118a73e10a48da" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: record</source>
          <target state="translated">疑似タイプ:レコード</target>
        </trans-unit>
        <trans-unit id="d51593e94e15db79bb52c20320be4240d42cc899" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: trigger</source>
          <target state="translated">疑似タイプ:トリガー</target>
        </trans-unit>
        <trans-unit id="4e60d0c02309d5445a01602a98db4ff91365738e" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: tsm_handler</source>
          <target state="translated">疑似型:tsm_handler</target>
        </trans-unit>
        <trans-unit id="17a7daa819e8dc7b6c6317f25efa7b50fffc1bab" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: unknown</source>
          <target state="translated">疑似タイプ:不明</target>
        </trans-unit>
        <trans-unit id="ad3dfebd9fb48eb5727ce6fe6f50844a86efc6a5" translate="yes" xml:space="preserve">
          <source>Pseudo-Types: void</source>
          <target state="translated">擬似型:void</target>
        </trans-unit>
        <trans-unit id="6c4dc2e4c074e37178229f858d4eb2dfaf30038f" translate="yes" xml:space="preserve">
          <source>Pseudo-types</source>
          <target state="translated">Pseudo-types</target>
        </trans-unit>
        <trans-unit id="cfb71764f58cd5ce25681b038025973a34e3322a" translate="yes" xml:space="preserve">
          <source>Pseudocode for a suitable &lt;code&gt;restore_command&lt;/code&gt; is:</source>
          <target state="translated">適切な &lt;code&gt;restore_command&lt;/code&gt; の疑似コードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="88d402501992d3fecf47cb438f8e35c65835d25d" translate="yes" xml:space="preserve">
          <source>PuTTY</source>
          <target state="translated">PuTTY</target>
        </trans-unit>
        <trans-unit id="e00441c49bf6cb62a4a537860a47c6b85de694f6" translate="yes" xml:space="preserve">
          <source>Publication</source>
          <target state="translated">Publication</target>
        </trans-unit>
        <trans-unit id="1c3179d96f0fdc556230a1396cdf463d5208ef82" translate="yes" xml:space="preserve">
          <source>Publications are different from schemas and do not affect how the table is accessed. Each table can be added to multiple publications if needed. Publications may currently only contain tables. Objects must be added explicitly, except when a publication is created for &lt;code&gt;ALL TABLES&lt;/code&gt;.</source>
          <target state="translated">パブリケーションはスキーマとは異なり、テーブルへのアクセス方法には影響しません。必要に応じて、各テーブルを複数のパブリケーションに追加できます。現在、パブリケーションにはテーブルのみが含まれている場合があります。 &lt;code&gt;ALL TABLES&lt;/code&gt; のパブリケーションが作成される場合を除き、オブジェクトは明示的に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="58589c3756a9812c4f0f3e4873d1e342581ef4c0" translate="yes" xml:space="preserve">
          <source>Publications can choose to limit the changes they produce to any combination of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;TRUNCATE&lt;/code&gt;, similar to how triggers are fired by particular event types. By default, all operation types are replicated.</source>
          <target state="translated">パブリケーションは、生成する変更を、特定のイベントタイプによるトリガーの起動と同様に、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、および &lt;code&gt;TRUNCATE&lt;/code&gt; の任意の組み合わせに制限することを選択できます。デフォルトでは、すべての操作タイプが複製されます。</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="18900d3584ded79ec60330adb7d33689eb4bab06" translate="yes" xml:space="preserve">
          <source>Put all query output into file &lt;code&gt;filename&lt;/code&gt;. This is equivalent to the command &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">すべてのクエリ出力をファイル &lt;code&gt;filename&lt;/code&gt; に入れます。これは、コマンド &lt;code&gt;\o&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="877e59f50b56dd32ce7ae2762957d53396b6d9d9" translate="yes" xml:space="preserve">
          <source>Qualified joins</source>
          <target state="translated">有資格者が参加</target>
        </trans-unit>
        <trans-unit id="3eb467853e78723a75783ad177cb3b81ed614c2e" translate="yes" xml:space="preserve">
          <source>Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by &lt;em&gt;unqualified names&lt;/em&gt;, which consist of just the table name. The system determines which table is meant by following a &lt;em&gt;search path&lt;/em&gt;, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database.</source>
          <target state="translated">修飾名は書くのが面倒で、多くの場合、特定のスキーマ名をアプリケーションにワイヤリングしないことが最善です。したがって、テーブルは多くの場合、&lt;em&gt;修飾&lt;/em&gt;されてい&lt;em&gt;ない名前&lt;/em&gt;で参照されます。&lt;em&gt;修飾&lt;/em&gt;されてい&lt;em&gt;ない名前&lt;/em&gt;は、テーブル名のみで構成されています。システムは、&lt;em&gt;検索する&lt;/em&gt;スキーマのリストである&lt;em&gt;検索パスをたどる&lt;/em&gt;ことによって、どのテーブルが意味されるかを決定します。検索パス内の最初に一致するテーブルが必要なテーブルと見なされます。検索パスに一致がない場合、一致するテーブル名がデータベース内の他のスキーマに存在していても、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="29bac22a5e177f5c85c1a4ee3241bc0678be6667" translate="yes" xml:space="preserve">
          <source>Quantifier</source>
          <target state="translated">Quantifier</target>
        </trans-unit>
        <trans-unit id="5370954c958801abba850882cd6534802d171dbc" translate="yes" xml:space="preserve">
          <source>Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, &lt;code&gt;'1 12:59:10'&lt;/code&gt; is read the same as &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt;. Also, a combination of years and months can be specified with a dash; for example &lt;code&gt;'200-10'&lt;/code&gt; is read the same as &lt;code&gt;'200 years 10 months'&lt;/code&gt;. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt;.)</source>
          <target state="translated">日、時間、分、秒の数量は、明示的なユニットマーキングなしで指定できます。たとえば、 &lt;code&gt;'1 12:59:10'&lt;/code&gt; は &lt;code&gt;'1 day 12 hours 59 min 10 sec'&lt;/code&gt; と同じように読み取られます。また、年と月の組み合わせをダッシュ​​で指定できます。たとえば、 &lt;code&gt;'200-10'&lt;/code&gt; は &lt;code&gt;'200 years 10 months'&lt;/code&gt; と同じように読み取られます。（これらの短い形式は実際にはSQL標準で許可されている唯一の形式であり、 &lt;code&gt;IntervalStyle&lt;/code&gt; が &lt;code&gt;sql_standard&lt;/code&gt; に設定されている場合に出力に使用されます。）</target>
        </trans-unit>
        <trans-unit id="2644b7d942f174a4bbf0bc8675c1badf9352393e" translate="yes" xml:space="preserve">
          <source>Queries</source>
          <target state="translated">Queries</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">クエリプランニング</target>
        </trans-unit>
        <trans-unit id="b65f94596db8e112e4f92d4f1acdc4bb922a6268" translate="yes" xml:space="preserve">
          <source>Query access - &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;COPY TO&lt;/code&gt;</source>
          <target state="translated">クエリアクセス &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;COPY TO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb0b645346d8b6276dfe9ec30dfc16f0625329b2" translate="yes" xml:space="preserve">
          <source>Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory.</source>
          <target state="translated">クエリのパフォーマンスは、特定の状況では劇的に改善されることがあります。特に、テーブルのアクセスの多い行のほとんどが単一のパーティションまたは少数のパーティションにある場合です。パーティショニングはインデックスの先頭列の代わりになり、インデックスサイズを小さくし、インデックスの多用な部分がメモリに収まる可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="198d3f9fde17e740d63372e1985f338979a36a67" translate="yes" xml:space="preserve">
          <source>Query tree (in the form of a &lt;code&gt;nodeToString()&lt;/code&gt; representation) for the rule's action</source>
          <target state="translated">ルールのアクションのクエリツリー（ &lt;code&gt;nodeToString()&lt;/code&gt; 表現の形式）</target>
        </trans-unit>
        <trans-unit id="a6002c5c363574bc4fe16e6079b6e23f671de172" translate="yes" xml:space="preserve">
          <source>Querying this view is similar to using &lt;code&gt;SHOW ALL&lt;/code&gt; but provides more detail. It is also more flexible, since it's possible to specify filter conditions or join against other relations.</source>
          <target state="translated">このビューのクエリは &lt;code&gt;SHOW ALL&lt;/code&gt; の使用に似ていますが、より詳細な情報を提供します。また、フィルター条件を指定したり、他の関係に対して結合したりできるため、より柔軟です。</target>
        </trans-unit>
        <trans-unit id="33208d59d48811565117bf5ce172585c48018ea8" translate="yes" xml:space="preserve">
          <source>Quick Setup</source>
          <target state="translated">クイックセットアップ</target>
        </trans-unit>
        <trans-unit id="d17b23cd28367fcd27d5f878512b5e25587ec17b" translate="yes" xml:space="preserve">
          <source>Quits the psql program. In a script file, only execution of that script is terminated.</source>
          <target state="translated">psqlプログラムを終了します。スクリプトファイルでは、そのスクリプトの実行のみが終了します。</target>
        </trans-unit>
        <trans-unit id="472cc72a1798e7f5b5bbceeb0bca7885d9d12809" translate="yes" xml:space="preserve">
          <source>Quoted identifiers can contain any character, except the character with code zero. (To include a double quote, write two double quotes.) This allows constructing table or column names that would otherwise not be possible, such as ones containing spaces or ampersands. The length limitation still applies.</source>
          <target state="translated">引用符で囲まれた識別子には、コードゼロの文字を除いて、任意の文字を含めることができます(二重引用符を含めるには、二重引用符を2つ書きます)。(二重引用符を含むには、二重引用符を2つ書きます。)これにより、スペースやアンパサンドを含むテーブル名やカラム名など、他の方法では不可能な名前を作成することができます。長さの制限は依然として適用されます。</target>
        </trans-unit>
        <trans-unit id="9a777f2b79b97851a7b855a9429a5ebde18f036d" translate="yes" xml:space="preserve">
          <source>Quoting an identifier also makes it case-sensitive, whereas unquoted names are always folded to lower case. For example, the identifiers &lt;code&gt;FOO&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt;, and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered the same by PostgreSQL, but &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; are different from these three and each other. (The folding of unquoted names to lower case in PostgreSQL is incompatible with the SQL standard, which says that unquoted names should be folded to upper case. Thus, &lt;code&gt;foo&lt;/code&gt; should be equivalent to &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; not &lt;code&gt;&quot;foo&quot;&lt;/code&gt; according to the standard. If you want to write portable applications you are advised to always quote a particular name or never quote it.)</source>
          <target state="translated">識別子を引用すると大文字と小文字が区別されますが、引用符で囲まれていない名前は常に小文字に変換されます。たとえば、識別子 &lt;code&gt;FOO&lt;/code&gt; 、 &lt;code&gt;foo&lt;/code&gt; 、および &lt;code&gt;&quot;foo&quot;&lt;/code&gt; はPostgreSQLでは同じと見なされますが、 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; および &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; はこれら3つとは異なります。 （PostgreSQLで引用符で囲まれていない名前を小文字に変換することは、SQL標準と互換性がありません。つまり、引用符で囲まれていない名前は大文字に &lt;code&gt;foo&lt;/code&gt; 必要があるということです。したがって、fooは、標準では &lt;code&gt;&quot;foo&quot;&lt;/code&gt; &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; なく「FOO」と同等である必要があります。ポータブルアプリケーションを作成する場合は、常に特定の名前を引用するか、絶対に引用しないことをお勧めします）。</target>
        </trans-unit>
        <trans-unit id="115088ecccb3000708edba51535672720b3a9ec6" translate="yes" xml:space="preserve">
          <source>Quoting rules for lexemes are the same as described previously for lexemes in &lt;code&gt;tsvector&lt;/code&gt;; and, as with &lt;code&gt;tsvector&lt;/code&gt;, any required normalization of words must be done before converting to the &lt;code&gt;tsquery&lt;/code&gt; type. The &lt;code&gt;to_tsquery&lt;/code&gt; function is convenient for performing such normalization:</source>
          <target state="translated">語彙素の引用規則は、 &lt;code&gt;tsvector&lt;/code&gt; の語彙素について以前に説明したものと同じです。 &lt;code&gt;tsvector&lt;/code&gt; と同様に、必要な単語の正規化は、 &lt;code&gt;tsquery&lt;/code&gt; 型に変換する前に行う必要があります。 &lt;code&gt;to_tsquery&lt;/code&gt; の機能は、このような正規化を行うための便利です。</target>
        </trans-unit>
        <trans-unit id="b79583615e1227273c81a5db2662b19ad81511a9" translate="yes" xml:space="preserve">
          <source>RADIUS Authentication</source>
          <target state="translated">RADIUS認証</target>
        </trans-unit>
        <trans-unit id="7edcf4d8bc4d16588d07b8848c85c166b827fdc9" translate="yes" xml:space="preserve">
          <source>RD-Tree for one-dimensional array of int4 values</source>
          <target state="translated">int4値の1次元配列のRD-Tree</target>
        </trans-unit>
        <trans-unit id="ff426c74c79867f7bf13e61c4f68d776339590f2" translate="yes" xml:space="preserve">
          <source>RDBMS</source>
          <target state="translated">RDBMS</target>
        </trans-unit>
        <trans-unit id="633fabe87d723214b65f1db2d624431f04c32334" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED</source>
          <target state="translated">所有権の再譲渡</target>
        </trans-unit>
        <trans-unit id="7b6e0d55ca8c5d1c174cbdd39c8e88014cc1d924" translate="yes" xml:space="preserve">
          <source>REASSIGN OWNED &amp;mdash; change the ownership of database objects owned by a database role</source>
          <target state="translated">REASSIGN OWNED &amp;mdash;データベースロールが所有するデータベースオブジェクトの所有権を変更する</target>
        </trans-unit>
        <trans-unit id="d9cbb3a44e5994b48186107b069ebdee3f1ded8c" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW</source>
          <target state="translated">リフレッシュマテリアルビュー</target>
        </trans-unit>
        <trans-unit id="044770dd01baff51d49560ba1c3262f9b7a5e296" translate="yes" xml:space="preserve">
          <source>REFRESH MATERIALIZED VIEW &amp;mdash; replace the contents of a materialized view</source>
          <target state="translated">マテリアライズドビューのリフレッシュ&amp;mdash;マテリアライズドビューのコンテンツを置き換えます</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="d68887fcf8498472cf8183721de3d160d3d8a3bb" translate="yes" xml:space="preserve">
          <source>REINDEX &amp;mdash; rebuild indexes</source>
          <target state="translated">REINDEX &amp;mdash;インデックスを再構築する</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">リリースセーブポイント</target>
        </trans-unit>
        <trans-unit id="d33a2b2590d58d2a81b75053789ac9fe4aed380a" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT &amp;mdash; destroy a previously defined savepoint</source>
          <target state="translated">RELEASE SAVEPOINT &amp;mdash;以前に定義されたセーブポイントを破棄します</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="c157890fb1f2fab533caebe2d7bbafd037ee3504" translate="yes" xml:space="preserve">
          <source>RESET &amp;mdash; restore the value of a run-time parameter to the default value</source>
          <target state="translated">RESET &amp;mdash;ランタイムパラメータの値をデフォルト値に戻します</target>
        </trans-unit>
        <trans-unit id="d173eb30e8b9fe61478a02d722cdc111a632ca90" translate="yes" xml:space="preserve">
          <source>REVOKE</source>
          <target state="translated">REVOKE</target>
        </trans-unit>
        <trans-unit id="6d5e97f2b0b3bc9eba1622d19f4c033f547d2f10" translate="yes" xml:space="preserve">
          <source>REVOKE &amp;mdash; remove access privileges</source>
          <target state="translated">REVOKE &amp;mdash;アクセス権限を削除する</target>
        </trans-unit>
        <trans-unit id="285e88316b0d14455ae0c18a656f7e4c2153f4a5" translate="yes" xml:space="preserve">
          <source>RFC</source>
          <target state="translated">RFC</target>
        </trans-unit>
        <trans-unit id="709f9208ad6c95b7efb1b7aea432fe35dfaffef8" translate="yes" xml:space="preserve">
          <source>RFC 3629</source>
          <target state="translated">RFC3629</target>
        </trans-unit>
        <trans-unit id="2e9a9191aa9d2f384e00599efbf540e0c6906e72" translate="yes" xml:space="preserve">
          <source>RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by &lt;code&gt;\uXXXX&lt;/code&gt;. In the input function for the &lt;code&gt;json&lt;/code&gt; type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow &lt;code&gt;\u&lt;/code&gt;). However, the input function for &lt;code&gt;jsonb&lt;/code&gt; is stricter: it disallows Unicode escapes for non-ASCII characters (those above &lt;code&gt;U+007F&lt;/code&gt;) unless the database encoding is UTF8. The &lt;code&gt;jsonb&lt;/code&gt; type also rejects &lt;code&gt;\u0000&lt;/code&gt; (because that cannot be represented in PostgreSQL's &lt;code&gt;text&lt;/code&gt; type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character.</source>
          <target state="translated">RFC 7159では、JSON文字列に &lt;code&gt;\uXXXX&lt;/code&gt; 示されるUnicodeエスケープシーケンスを含めることが許可されています。 &lt;code&gt;json&lt;/code&gt; タイプの入力関数では、データベースのエンコードに関係なくUnicodeエスケープが許可され、構文の正確性（つまり、4つの16進数が &lt;code&gt;\u&lt;/code&gt; 続く）のみがチェックされます。ただし、 &lt;code&gt;jsonb&lt;/code&gt; の入力関数はより厳密です。データベースのエンコーディングがUTF8でない限り、非ASCII文字（ &lt;code&gt;U+007F&lt;/code&gt; を超える文字）のUnicodeエスケープは許可されません。 &lt;code&gt;jsonb&lt;/code&gt; のタイプも拒否し &lt;code&gt;\u0000&lt;/code&gt; それはPostgreSQLの中で表現することができないので、（ &lt;code&gt;text&lt;/code&gt; タイプ）、およびUnicodeサロゲートペアを使用して、Unicode Basic Multilingual Plane外の文字を指定することは正しいと主張しています。有効なUnicodeエスケープは、保存用に同等のASCIIまたはUTF8文字に変換されます。これには、サロゲートペアを単一の文字に折りたたむことが含まれます。</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="59a24d752da80d40b19238fcc5ec55b82fdc443e" translate="yes" xml:space="preserve">
          <source>ROLLBACK &amp;mdash; abort the current transaction</source>
          <target state="translated">ROLLBACK &amp;mdash;現在のトランザクションを中止する</target>
        </trans-unit>
        <trans-unit id="e90e1449c7ef5b8820b08718a11f2da71c8d13be" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED</source>
          <target state="translated">ロールバックの準備</target>
        </trans-unit>
        <trans-unit id="48a2a83386a59b9b2fdad5e2cd3606242846748b" translate="yes" xml:space="preserve">
          <source>ROLLBACK PREPARED &amp;mdash; cancel a transaction that was earlier prepared for two-phase commit</source>
          <target state="translated">ROLLBACK PREPARED &amp;mdash; 2フェーズコミット用に以前に準備されたトランザクションをキャンセルする</target>
        </trans-unit>
        <trans-unit id="61b9b7603e40508bc503ee4691737e409606fd90" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT</source>
          <target state="translated">セーブポイントへのロールバック</target>
        </trans-unit>
        <trans-unit id="d35ebfad8fd6f928fec74d3875a90f0020c24317" translate="yes" xml:space="preserve">
          <source>ROLLBACK TO SAVEPOINT &amp;mdash; roll back to a savepoint</source>
          <target state="translated">セーブポイントへのロールバック&amp;mdash;セーブポイントまでロールバックします</target>
        </trans-unit>
        <trans-unit id="5a8f649047eb74a2e378d2089854762723ab49ef" translate="yes" xml:space="preserve">
          <source>ROW EXCLUSIVE</source>
          <target state="translated">ロウ・エクスクルーシブ</target>
        </trans-unit>
        <trans-unit id="14cb7a6b49bc39b1cc0a49d9f930265fc065d308" translate="yes" xml:space="preserve">
          <source>ROW SHARE</source>
          <target state="translated">ローシェア</target>
        </trans-unit>
        <trans-unit id="498fa9be2d32c469ac4cde84af98396f043472d9" translate="yes" xml:space="preserve">
          <source>Random access to mechanical disk storage is normally much more expensive than four times sequential access. However, a lower default is used (4.0) because the majority of random accesses to disk, such as indexed reads, are assumed to be in cache. The default value can be thought of as modeling random access as 40 times slower than sequential, while expecting 90% of random reads to be cached.</source>
          <target state="translated">機械式ディスクストレージへのランダムアクセスは、通常、4回のシーケンシャルアクセスよりもはるかに高価です。しかし、インデックス付きリードのようなディスクへのランダムアクセスの大部分がキャッシュにあると想定されるため、より低いデフォルト値(4.0)が使用されています。デフォルト値は、ランダムアクセスをシーケンシャルの40倍の速度でモデル化し、ランダムリードの90%がキャッシュされることを想定していると考えることができます。</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="a12932077f1a02e9d49ac217bf48adda8287e429" translate="yes" xml:space="preserve">
          <source>Range Partitioning</source>
          <target state="translated">範囲分割</target>
        </trans-unit>
        <trans-unit id="150371fe63779db9b501fedeeefe579700f1d7d0" translate="yes" xml:space="preserve">
          <source>Range Types</source>
          <target state="translated">レンジタイプ</target>
        </trans-unit>
        <trans-unit id="53d929e1fb8ce766a0948419773ae86cbb9a3971" translate="yes" xml:space="preserve">
          <source>Range Types: daterange</source>
          <target state="translated">レンジタイプ:データレンジ</target>
        </trans-unit>
        <trans-unit id="a3693b9f49e1d1bce857f56deb98c373c7aef619" translate="yes" xml:space="preserve">
          <source>Range Types: int4range</source>
          <target state="translated">範囲タイプ:int4range</target>
        </trans-unit>
        <trans-unit id="8a82ac3da25ee609b2aeb0f2103e7ae7eeded8ea" translate="yes" xml:space="preserve">
          <source>Range Types: int8range</source>
          <target state="translated">範囲タイプ:int8範囲</target>
        </trans-unit>
        <trans-unit id="744cc477872918910432194727cf36fb5632f253" translate="yes" xml:space="preserve">
          <source>Range Types: numrange</source>
          <target state="translated">レンジタイプ:numrange</target>
        </trans-unit>
        <trans-unit id="f03184b38e676b9e59d518680c29ef81d475b159" translate="yes" xml:space="preserve">
          <source>Range Types: tsrange</source>
          <target state="translated">レンジタイプ:tsrange</target>
        </trans-unit>
        <trans-unit id="010e27d6ddc0ef1f60c30945a5ab60be84e20b61" translate="yes" xml:space="preserve">
          <source>Range Types: tstzrange</source>
          <target state="translated">レンジタイプ:tstzrange</target>
        </trans-unit>
        <trans-unit id="19eccf536154da069167603ea475b5f422e59b33" translate="yes" xml:space="preserve">
          <source>Range and list partitioning require a btree operator class, while hash partitioning requires a hash operator class. If no operator class is specified explicitly, the default operator class of the appropriate type will be used; if no default operator class exists, an error will be raised. When hash partitioning is used, the operator class used must implement support function 2 (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;Section 37.16.3&lt;/a&gt; for details).</source>
          <target state="translated">範囲とリストのパーティション化にはbtree演算子クラスが必要ですが、ハッシュパーティション化にはハッシュ演算子クラスが必要です。演算子クラスが明示的に指定されていない場合、適切なタイプのデフォルトの演算子クラスが使用されます。デフォルトの演算子クラスが存在しない場合、エラーが発生します。ハッシュ分割を使用する場合、使用する演算子クラスはサポート関数2を実装する必要があります（詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-SUPPORT&quot;&gt;セクション37.16.3&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="translated">レンジタイプ</target>
        </trans-unit>
        <trans-unit id="152d9f920b5a18dd2e34c468823a545e1a1c8d0c" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's &lt;em&gt;subtype&lt;/em&gt;). For instance, ranges of &lt;code&gt;timestamp&lt;/code&gt; might be used to represent the ranges of time that a meeting room is reserved. In this case the data type is &lt;code&gt;tsrange&lt;/code&gt; (short for &amp;ldquo;timestamp range&amp;rdquo;), and &lt;code&gt;timestamp&lt;/code&gt; is the subtype. The subtype must have a total order so that it is well-defined whether element values are within, before, or after a range of values.</source>
          <target state="translated">範囲タイプは、ある要素タイプ（範囲の&lt;em&gt;サブタイプ&lt;/em&gt;と呼ばれる）の値の範囲を表すデータタイプです。たとえば、 &lt;code&gt;timestamp&lt;/code&gt; の範囲は、会議室が予約されている時間の範囲を表すために使用できます。この場合、データタイプは &lt;code&gt;tsrange&lt;/code&gt; （「タイムスタンプ範囲」の略）であり、 &lt;code&gt;timestamp&lt;/code&gt; はサブタイプです。要素の値が値の範囲内、値の前、または後のいずれであるかが明確に定義されるように、サブタイプには完全な順序が必要です。</target>
        </trans-unit>
        <trans-unit id="10501cb18e09508ff10076b64f0cc428df172882" translate="yes" xml:space="preserve">
          <source>Range types are useful because they represent many element values in a single range value, and because concepts such as overlapping ranges can be expressed clearly. The use of time and date ranges for scheduling purposes is the clearest example; but price ranges, measurement ranges from an instrument, and so forth can also be useful.</source>
          <target state="translated">レンジタイプは、1つのレンジ値の中に多くの要素値を表現し、重複するレンジなどの概念を明確に表現できるので便利です。スケジューリング目的での日時範囲の使用が最も分かりやすい例ですが、価格範囲や計器からの測定範囲なども有用です。</target>
        </trans-unit>
        <trans-unit id="a9a5ac13ea7278862eadf429fec1a6d53e07ac45" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;amp;</source>
          <target state="translated">範囲： ＆＆</target>
        </trans-unit>
        <trans-unit id="5138aeeb99cbf6ebff075b87fadb3ac93d6e5193" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;gt;</source>
          <target state="translated">範囲：＆&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d72ae278ac597396584e8c02a1741c100edfca80" translate="yes" xml:space="preserve">
          <source>Range: &amp;amp;&amp;lt;</source>
          <target state="translated">範囲：＆&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e3887b799dded8092c6301d5be1aefa3d0dd6d3a" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;</source>
          <target state="translated">範囲：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="798e0e9e88e4e32e73dc02d11defb73693566666" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;&amp;gt;</source>
          <target state="translated">範囲：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e6946ee5453b7aafe3852ad6a413e04bbe70b3f" translate="yes" xml:space="preserve">
          <source>Range: &amp;gt;=</source>
          <target state="translated">範囲：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="50827e59e82c8b9b94902deba9c0cd7d740e2584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;</source>
          <target state="translated">範囲：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6f037363a29496f0699d11afa7d6227f3803584" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;gt;</source>
          <target state="translated">範囲：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f6f0031a9d4355c819448b50757c3487642b742" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;&amp;lt;</source>
          <target state="translated">範囲：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="278020aa13725565b03e23b783ab30ead6a5d971" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;=</source>
          <target state="translated">範囲：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="8fd029989c2ed32bcffaf5576523df4934fcb6aa" translate="yes" xml:space="preserve">
          <source>Range: &amp;lt;@</source>
          <target state="translated">範囲：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="519ae404f51d7cdda5157d728a679f6ac34e633b" translate="yes" xml:space="preserve">
          <source>Range: *</source>
          <target state="translated">範囲は?*</target>
        </trans-unit>
        <trans-unit id="2eb640bcc9834e28157d86493366688f7c5d38a2" translate="yes" xml:space="preserve">
          <source>Range: +</source>
          <target state="translated">範囲。+</target>
        </trans-unit>
        <trans-unit id="c8e5cef097bd3910fe5e0190257f34cad206f4c2" translate="yes" xml:space="preserve">
          <source>Range: -</source>
          <target state="translated">範囲:--.</target>
        </trans-unit>
        <trans-unit id="b30626f6a47ecd0abac84acd28b5ffc7444c5618" translate="yes" xml:space="preserve">
          <source>Range: -|-</source>
          <target state="translated">範囲:-|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------1.5</target>
        </trans-unit>
        <trans-unit id="d7943ac61251b0e439e59453d3c9bd4d92cbe7db" translate="yes" xml:space="preserve">
          <source>Range: =</source>
          <target state="translated">範囲:==のように</target>
        </trans-unit>
        <trans-unit id="5c9fd1a7ffb6cd6aed893574001127ea193ec53e" translate="yes" xml:space="preserve">
          <source>Range: @&amp;gt;</source>
          <target state="translated">範囲：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5df42bdba4fe9375d8ecde65d144985e2fa123da" translate="yes" xml:space="preserve">
          <source>Range: isempty</source>
          <target state="translated">範囲:空</target>
        </trans-unit>
        <trans-unit id="7cf1b8f7817c42e33a217bf084388d7956ddb800" translate="yes" xml:space="preserve">
          <source>Range: lower</source>
          <target state="translated">範囲:下</target>
        </trans-unit>
        <trans-unit id="41561998090e13cce0a01b7784c0b3af97242f0c" translate="yes" xml:space="preserve">
          <source>Range: lower_inc</source>
          <target state="translated">範囲:lower_inc</target>
        </trans-unit>
        <trans-unit id="2cc53727481a0808617729c756b990601f85da64" translate="yes" xml:space="preserve">
          <source>Range: lower_inf</source>
          <target state="translated">範囲:lower_inf</target>
        </trans-unit>
        <trans-unit id="4ace460c813343c7a659f92c463b48f8e9497c10" translate="yes" xml:space="preserve">
          <source>Range: range_merge</source>
          <target state="translated">範囲:range_merge</target>
        </trans-unit>
        <trans-unit id="1f28a3c6d0b4768f8b324bd884ab8839d0315ae6" translate="yes" xml:space="preserve">
          <source>Range: upper</source>
          <target state="translated">範囲:上</target>
        </trans-unit>
        <trans-unit id="254cd3d46f3b050314f0a32b8ccaf21bfef8428c" translate="yes" xml:space="preserve">
          <source>Range: upper_inc</source>
          <target state="translated">範囲:upper_inc</target>
        </trans-unit>
        <trans-unit id="15a1bf88678aec9c8e638569577cf68508681fb4" translate="yes" xml:space="preserve">
          <source>Range: upper_inf</source>
          <target state="translated">範囲:upper_inf</target>
        </trans-unit>
        <trans-unit id="16773cb5b6a39b09024cc881604849b2ada6e7b5" translate="yes" xml:space="preserve">
          <source>Ranking attempts to measure how relevant documents are to a particular query, so that when there are many matches the most relevant ones can be shown first. PostgreSQL provides two predefined ranking functions, which take into account lexical, proximity, and structural information; that is, they consider how often the query terms appear in the document, how close together the terms are in the document, and how important is the part of the document where they occur. However, the concept of relevancy is vague and very application-specific. Different applications might require additional information for ranking, e.g., document modification time. The built-in ranking functions are only examples. You can write your own ranking functions and/or combine their results with additional factors to fit your specific needs.</source>
          <target state="translated">ランキングは、特定の問い合わせに対する文書の関連性を測定しようとするもので、多くの一致がある場合、最も関連性の高いものを最初に表示することができます。PostgreSQLは2つの定義済みのランキング関数を提供しており、語彙情報、近接情報、構造情報を考慮に入れています。しかし、関連性の概念は曖昧で、アプリケーション固有のものです。異なるアプリケーションでは、例えば文書の修正時間など、ランキングに追加の情報を必要とする場合があります。組み込みのランキング関数は一例に過ぎません。独自のランキング関数を作成したり、その結果を特定のニーズに合わせて追加の要因と組み合わせたりすることができます。</target>
        </trans-unit>
        <trans-unit id="6d643b0d7aa4393d4d9da3687d8322d0a81e0cab" translate="yes" xml:space="preserve">
          <source>Ranking can be expensive since it requires consulting the &lt;code&gt;tsvector&lt;/code&gt; of each matching document, which can be I/O bound and therefore slow. Unfortunately, it is almost impossible to avoid since practical queries often result in large numbers of matches.</source>
          <target state="translated">ランク &lt;code&gt;tsvector&lt;/code&gt; は、一致する各ドキュメントのtsvectorを調べる必要があるため、高コストになる可能性があります。残念ながら、実際のクエリは多くの場合、多数の一致を引き起こすため、回避することはほとんど不可能です。</target>
        </trans-unit>
        <trans-unit id="19afdfa41a0ed827f969267ae295f3b913f28c70" translate="yes" xml:space="preserve">
          <source>Ranks vectors based on the frequency of their matching lexemes.</source>
          <target state="translated">一致する語彙の頻度に基づいて,ベクトルをランク付けします.</target>
        </trans-unit>
        <trans-unit id="236c736d2b53bb667d136c499a0d1ba402fdd25d" translate="yes" xml:space="preserve">
          <source>Rather than look at &lt;code&gt;pg_statistic&lt;/code&gt; directly, it's better to look at its view &lt;a href=&quot;view-pg-stats&quot;&gt;&lt;code&gt;pg_stats&lt;/code&gt;&lt;/a&gt; when examining the statistics manually. &lt;code&gt;pg_stats&lt;/code&gt; is designed to be more easily readable. Furthermore, &lt;code&gt;pg_stats&lt;/code&gt; is readable by all, whereas &lt;code&gt;pg_statistic&lt;/code&gt; is only readable by a superuser. (This prevents unprivileged users from learning something about the contents of other people's tables from the statistics. The &lt;code&gt;pg_stats&lt;/code&gt; view is restricted to show only rows about tables that the current user can read.) For example, we might do:</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; を直接見るのではなく、手動で統計を調べるときは&lt;a href=&quot;view-pg-stats&quot;&gt; &lt;code&gt;pg_stats&lt;/code&gt; の&lt;/a&gt;ビューを見るほうが良いです。 &lt;code&gt;pg_stats&lt;/code&gt; はより読みやすく設計されています。さらに、 &lt;code&gt;pg_stats&lt;/code&gt; はすべてのユーザーが読み取り可能ですが、 &lt;code&gt;pg_statistic&lt;/code&gt; はスーパーユーザーのみが読み取り可能です。 （これにより、権限のないユーザーが統計から他の人のテーブルの内容について何かを知ることができなくなります &lt;code&gt;pg_stats&lt;/code&gt; ビューは、現在のユーザーが読み取ることができるテーブルに関する行のみを表示するように制限されています。）たとえば、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e2bec5c61f15a407e756ab05a685ad23bb7e5511" translate="yes" xml:space="preserve">
          <source>Raw encryption</source>
          <target state="translated">生の暗号化</target>
        </trans-unit>
        <trans-unit id="c3a99e9a4728dc2bda56a78db524b67989b4e597" translate="yes" xml:space="preserve">
          <source>Read all configuration variables, even those normally visible only to superusers.</source>
          <target state="translated">すべての設定変数を読み込み、通常はスーパーユーザのみが閲覧できる設定変数も読み込みます。</target>
        </trans-unit>
        <trans-unit id="38c5a7218bb22d1b28959f625c6bfbea27ffbf82" translate="yes" xml:space="preserve">
          <source>Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superusers.</source>
          <target state="translated">すべてのpg_stat_*ビューを読み込み、通常はスーパーユーザのみが閲覧できるものであっても、様々な統計関連の拡張機能を使用することができます。</target>
        </trans-unit>
        <trans-unit id="f317af3bdf1a98cfc777a36424de3b09eb202cb2" translate="yes" xml:space="preserve">
          <source>Read commands from the file &lt;code&gt;filename&lt;/code&gt;, rather than standard input. This option can be repeated and combined in any order with the &lt;code&gt;-c&lt;/code&gt; option. When either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;-f&lt;/code&gt; is specified, psql does not read commands from standard input; instead it terminates after processing all the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; options in sequence. Except for that, this option is largely equivalent to the meta-command &lt;code&gt;\i&lt;/code&gt;.</source>
          <target state="translated">標準入力ではなく、ファイル &lt;code&gt;filename&lt;/code&gt; からコマンドを読み取ります。このオプションは、 &lt;code&gt;-c&lt;/code&gt; オプションを使用して繰り返し、任意の順序で組み合わせることができます。 &lt;code&gt;-c&lt;/code&gt; または &lt;code&gt;-f&lt;/code&gt; のいずれかが指定されている場合、psqlは標準入力からコマンドを読み取りません。代わりに、すべての &lt;code&gt;-c&lt;/code&gt; および &lt;code&gt;-f&lt;/code&gt; オプションを順番に処理した後に終了します。それを除いて、このオプションはメタコマンド &lt;code&gt;\i&lt;/code&gt; とほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="9076a937057025c12698c82a06c40b255a1ab2fe" translate="yes" xml:space="preserve">
          <source>Read committed</source>
          <target state="translated">コミットされた読み取り</target>
        </trans-unit>
        <trans-unit id="a95dbf92f08a3c417ee95bdad4ed061db64fdec6" translate="yes" xml:space="preserve">
          <source>Read only transactions and transaction rollbacks need not wait for replies from standby servers. Subtransaction commits do not wait for responses from standby servers, only top-level commits. Long running actions such as data loading or index building do not wait until the very final commit message. All two-phase commit actions require commit waits, including both prepare and commit.</source>
          <target state="translated">読み取り専用のトランザクションとトランザクションのロールバックは、待機サーバからの応答を待つ必要はありません。サブトランザクションのコミットは待機サーバからの応答を待たず、トップレベルのコミットのみを待ちます。データの読み込みやインデックスの構築など、長時間実行されているアクションは、最後のコミットメッセージまで待つ必要はありません。すべての二段階のコミットアクションは、準備とコミットの両方を含むコミット待ちを必要とします。</target>
        </trans-unit>
        <trans-unit id="6be205ecd14d327027894365b4c4da763eabaefb" translate="yes" xml:space="preserve">
          <source>Read uncommitted</source>
          <target state="translated">未コミットを読む</target>
        </trans-unit>
        <trans-unit id="6eb06aa586fee4fadd30e615b431af9599c0f350" translate="yes" xml:space="preserve">
          <source>Read/execute various monitoring views and functions. This role is a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt;.</source>
          <target state="translated">さまざまな監視ビューおよび機能の読み取り/実行。このロールは &lt;code&gt;pg_read_all_settings&lt;/code&gt; 、 &lt;code&gt;pg_read_all_stats&lt;/code&gt; および &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; のメンバーです。</target>
        </trans-unit>
        <trans-unit id="208855ca97c0a555c27eb1fe53c1f9d25c951c72" translate="yes" xml:space="preserve">
          <source>Reads input from the file &lt;code&gt;filename&lt;/code&gt; and executes it as though it had been typed on the keyboard.</source>
          <target state="translated">ファイル &lt;code&gt;filename&lt;/code&gt; から入力を読み取り、キーボードで入力されたかのように実行します。</target>
        </trans-unit>
        <trans-unit id="8c6e304c0494e1083fecdbe3327bbaf955efd2c7" translate="yes" xml:space="preserve">
          <source>Reads the large object with OID &lt;code&gt;loid&lt;/code&gt; from the database and writes it to &lt;code&gt;filename&lt;/code&gt;. Note that this is subtly different from the server function &lt;code&gt;lo_export&lt;/code&gt;, which acts with the permissions of the user that the database server runs as and on the server's file system.</source>
          <target state="translated">データベースからOID &lt;code&gt;loid&lt;/code&gt; を持つラージオブジェクトを読み取り、それを &lt;code&gt;filename&lt;/code&gt; に書き込みます。これは、サーバー関数 &lt;code&gt;lo_export&lt;/code&gt; とは微妙に異なることに注意してください。lo_exportは、データベースサーバーがサーバーのファイルシステムで実行されるユーザーの権限で動作します。</target>
        </trans-unit>
        <trans-unit id="b773130a64ad2044832f0c09fb6170f96c3c7a41" translate="yes" xml:space="preserve">
          <source>Real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">実際の使用法では、&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章で&lt;/a&gt;説明するように、テキスト検索構成にそれを含める必要があります。次のようになります。</target>
        </trans-unit>
        <trans-unit id="ae23f1294951923b0cc23537cc39645d564d2aab" translate="yes" xml:space="preserve">
          <source>Rebuild a single index:</source>
          <target state="translated">単一のインデックスを再構築します。</target>
        </trans-unit>
        <trans-unit id="7641f144c3aa51f565ab278ebea2baf02cb12776" translate="yes" xml:space="preserve">
          <source>Rebuild all indexes in a particular database, without trusting the system indexes to be valid already:</source>
          <target state="translated">システムインデックスがすでに有効であることを信頼せずに、特定のデータベース内のすべてのインデックスを再構築します。</target>
        </trans-unit>
        <trans-unit id="4bafd726bbf407899b495d1dbf54642ee4ba4831" translate="yes" xml:space="preserve">
          <source>Rebuild all the indexes on the table &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">テーブル &lt;code&gt;my_table&lt;/code&gt; のすべてのインデックスを再構築します。</target>
        </trans-unit>
        <trans-unit id="5e240124d901fd858d5ecb298dbf587210bc9d05" translate="yes" xml:space="preserve">
          <source>Rebuild indexes for a table, without blocking read and write operations on involved relations while reindexing is in progress:</source>
          <target state="translated">テーブルのインデックスを再構築し、インデックスの再作成中に関係するリレーションの読み書き操作をブロックすることなく、テーブルのインデックスを再構築します。</target>
        </trans-unit>
        <trans-unit id="9a65666fb054ac024fe44494209417a92c10f6a1" translate="yes" xml:space="preserve">
          <source>Rebuilding Indexes Concurrently</source>
          <target state="translated">インデックスの再構築を並行して行う</target>
        </trans-unit>
        <trans-unit id="988c4afb32e29d0f56df1f4ce3ed4b7fe8a47d56" translate="yes" xml:space="preserve">
          <source>Rebuilding an index can interfere with regular operation of a database. Normally PostgreSQL locks the table whose index is rebuilt against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index rebuild is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index rebuild can lock out writers for periods that are unacceptably long for a production system.</source>
          <target state="translated">インデックスの再構築は、データベースの通常の運用に支障をきたす可能性があります。通常、PostgreSQLはインデックスが再構築されたテーブルを書き込みに対してロックし、テーブルの1回のスキャンで全体のインデックス構築を実行します。他のトランザクションはまだテーブルを読むことができますが、テーブル内の行を挿入、更新、削除しようとすると、インデックスの再構築が完了するまでブロックされます。これは、システムが本番のデータベースである場合、深刻な影響を及ぼす可能性があります。非常に大きなテーブルではインデックス化に何時間もかかりますし、小さなテーブルでもインデックスの再構築により、本番システムでは許容できないほど長い時間、ライターがロックアウトされてしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="82bd8c2397d7ac2c1c641075498f1fce81c5df27" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; that SQL does not, in general, provide a unique identifier for rows. Therefore it is not always possible to directly specify which row to update. Instead, you specify which conditions a row must meet in order to be updated. Only if you have a primary key in the table (independent of whether you declared it or not) can you reliably address individual rows by choosing a condition that matches the primary key. Graphical database access tools rely on this fact to allow you to update rows individually.</source>
          <target state="translated">SQLは通常、行に一意の識別子を提供しないことを&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;第5章&lt;/a&gt;から思い出してください。したがって、更新する行を直接指定できるとは限りません。代わりに、更新するために行が満たす必要がある条件を指定します。（宣言したかどうかに関係なく）テーブルに主キーがある場合のみ、主キーと一致する条件を選択することにより、個々の行に確実に対処できます。グラフィカルデータベースアクセスツールはこの事実に基づいて、行を個別に更新できます。</target>
        </trans-unit>
        <trans-unit id="4efef42b9260b682732a87952d0c648c37aa88b4" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; that the PostgreSQL server provides a large number of run-time configuration variables. You can set database-specific default values for many of these settings.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;から、PostgreSQLサーバーは多数のランタイム構成変数を提供することを思い出してください。これらの設定の多くに対して、データベース固有のデフォルト値を設定できます。</target>
        </trans-unit>
        <trans-unit id="2f93654028aee4dea14c9a1eae10f967b20dc5e9" translate="yes" xml:space="preserve">
          <source>Recall the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables from &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt;. Consider the following problem: You want to make sure that no one can insert rows in the &lt;code&gt;weather&lt;/code&gt; table that do not have a matching entry in the &lt;code&gt;cities&lt;/code&gt; table. This is called maintaining the &lt;em&gt;referential integrity&lt;/em&gt; of your data. In simplistic database systems this would be implemented (if at all) by first looking at the &lt;code&gt;cities&lt;/code&gt; table to check if a matching record exists, and then inserting or rejecting the new &lt;code&gt;weather&lt;/code&gt; records. This approach has a number of problems and is very inconvenient, so PostgreSQL can do this for you.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;第2章の&lt;/a&gt; &lt;code&gt;weather&lt;/code&gt; と &lt;code&gt;cities&lt;/code&gt; 表を思い出してください。次の問題を考えてみます。 &lt;code&gt;cities&lt;/code&gt; テーブルに一致するエントリがない行を &lt;code&gt;weather&lt;/code&gt; 表に挿入できないようにする必要があります。これは、データの&lt;em&gt;参照整合性&lt;/em&gt;の維持と呼ばれます。単純化したデータベースシステムでは、これは（もしあれば）最初に &lt;code&gt;cities&lt;/code&gt; テーブルを調べて一致するレコードが存在するかどうかを確認し、次に新しい &lt;code&gt;weather&lt;/code&gt; レコードを挿入または拒否することで実装されます。このアプローチには多くの問題があり、非常に不便なので、PostgreSQLがこれを行うことができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0eaa953826e935204b6a44cd6a2370cac662b344" translate="yes" xml:space="preserve">
          <source>Receipt time of last message received from origin WAL sender</source>
          <target state="translated">オリジンから最後に受信したメッセージの受信時刻 WAL送信者</target>
        </trans-unit>
        <trans-unit id="3cc37caa6d46528f9045d282984fbf57211a9456" translate="yes" xml:space="preserve">
          <source>Recent SATA drives (those following ATAPI-6 or later) offer a drive cache flush command (&lt;code&gt;FLUSH CACHE EXT&lt;/code&gt;), while SCSI drives have long supported a similar command &lt;code&gt;SYNCHRONIZE CACHE&lt;/code&gt;. These commands are not directly accessible to PostgreSQL, but some file systems (e.g., ZFS, ext4) can use them to flush data to the platters on write-back-enabled drives. Unfortunately, such file systems behave suboptimally when combined with battery-backup unit (BBU) disk controllers. In such setups, the synchronize command forces all data from the controller cache to the disks, eliminating much of the benefit of the BBU. You can run the &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt; program to see if you are affected. If you are affected, the performance benefits of the BBU can be regained by turning off write barriers in the file system or reconfiguring the disk controller, if that is an option. If write barriers are turned off, make sure the battery remains functional; a faulty battery can potentially lead to data loss. Hopefully file system and disk controller designers will eventually address this suboptimal behavior.</source>
          <target state="translated">最近のSATAドライブ（ATAPI-6以降に続くもの）は、ドライブキャッシュフラッシュコマンド（ &lt;code&gt;FLUSH CACHE EXT&lt;/code&gt; ）を提供していますが、SCSIドライブは同様のコマンド &lt;code&gt;SYNCHRONIZE CACHE&lt;/code&gt; を長い間サポートしています。これらのコマンドはPostgreSQLに直接アクセスできませんが、一部のファイルシステム（ZFS、ext4など）は、それらを使用して、ライトバックが有効なドライブのプラッターにデータをフラッシュできます。残念ながら、そのようなファイルシステムは、バッテリーバックアップユニット（BBU）ディスクコントローラーと組み合わせると次善の動作をします。このようなセットアップでは、同期コマンドはすべてのデータをコントローラーキャッシュからディスクに強制的に送信し、BBUの利点の多くを排除します。&lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt;を実行できますあなたが影響を受けているかどうかを確認するプログラム。影響を受ける場合は、ファイルシステムで書き込みバリアをオフにするか、オプションの場合はディスクコントローラーを再構成することにより、BBUのパフォーマンス上の利点を取り戻すことができます。書き込みバリアがオフになっている場合は、バッテリーが機能していることを確認してください。バッテリーに欠陥があると、データが失われる可能性があります。うまくいけば、ファイルシステムとディスクコントローラーの設計者は、最終的にはこの次善の振る舞いに対処するでしょう。</target>
        </trans-unit>
        <trans-unit id="bb81291c24a22a0d7ee2d0164ff6f4bb7150f01b" translate="yes" xml:space="preserve">
          <source>Recent XPath versions begin to offer capabilities overlapping with these (such as functional-style &lt;code&gt;for-each&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt;, anonymous functions, and &lt;code&gt;parse-xml&lt;/code&gt; to create a node from a string), but such features were not available before XPath 3.0.</source>
          <target state="translated">最近のXPathバージョンは、これらと重複する機能（機能スタイルの &lt;code&gt;for-each&lt;/code&gt; および &lt;code&gt;sort&lt;/code&gt; 、無名関数、文字列からノードを作成するための &lt;code&gt;parse-xml&lt;/code&gt; など）を提供し始めますが、そのような機能はXPath 3.0以前では利用できませんでした。</target>
        </trans-unit>
        <trans-unit id="e74ab6cfa0460d1693f4b9e4a5ccdbb1ddbfa73f" translate="yes" xml:space="preserve">
          <source>Recompile and verify that the new probes are available</source>
          <target state="translated">リコンパイルして、新しいプローブが使用可能であることを確認します。</target>
        </trans-unit>
        <trans-unit id="c56b9211f3ee693b17cfa7d6c447d7f6c0a97469" translate="yes" xml:space="preserve">
          <source>Record commit time of transactions. This parameter can only be set in &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">トランザクションのコミット時間を記録します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e1e650b68eeccef8d69d91d12499b2ffe7f56b1b" translate="yes" xml:space="preserve">
          <source>Recovery performance is sufficiently good that the standby will typically be only moments away from full availability once it has been activated. As a result, this is called a warm standby configuration which offers high availability. Restoring a server from an archived base backup and rollforward will take considerably longer, so that technique only offers a solution for disaster recovery, not high availability. A standby server can also be used for read-only queries, in which case it is called a Hot Standby server. See &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt; for more information.</source>
          <target state="translated">回復パフォーマンスは十分に良好であり、スタンバイがアクティブ化された後は、通常、完全な可用性からほんの少し離れています。その結果、これは高可用性を提供するウォームスタンバイ構成と呼ばれます。アーカイブされた基本バックアップとロールフォワードからサーバーを復元するにはかなり時間がかかるため、この手法は障害復旧のためのソリューションのみを提供し、高可用性は提供しません。スタンバイサーバーは、読み取り専用クエリにも使用できます。この場合、ホットスタンバイサーバーと呼ばれます。詳細は&lt;a href=&quot;hot-standby&quot;&gt;項26.5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fc32ecc375b8a61098de0a79de9f7d52b34ebeb9" translate="yes" xml:space="preserve">
          <source>Recovery treats the WAL archive as read-only, so once a WAL file has been copied to the standby system it can be copied to tape at the same time as it is being read by the standby database server. Thus, running a standby server for high availability can be performed at the same time as files are stored for longer term disaster recovery purposes.</source>
          <target state="translated">リカバリーは WAL アーカイブを読み取り専用として扱うので、WAL ファイルがスタンバイシステムにコピーされると、スタンバイデータベースサーバーで読み込まれると同時にテープにコピーすることができます。このように、高可用性のための待機サーバーを実行することで、ファイルが長期的な災害復旧の目的で保存されると同時に実行することができます。</target>
        </trans-unit>
        <trans-unit id="a3bc2f178f62154c386cd90668f7442aeca7ac4b" translate="yes" xml:space="preserve">
          <source>Recreate &lt;code&gt;index&lt;/code&gt; only. Multiple indexes can be recreated by writing multiple &lt;code&gt;-i&lt;/code&gt; switches.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; のみを再作成します。複数の &lt;code&gt;-i&lt;/code&gt; スイッチを記述することにより、複数のインデックスを再作成できます。</target>
        </trans-unit>
        <trans-unit id="5ab8e4cf2bee361b549d0a7652eba7adf3a2e36d" translate="yes" xml:space="preserve">
          <source>Recreate all indexes of the specified schema. If a table of this schema has a secondary &amp;ldquo;TOAST&amp;rdquo; table, that is reindexed as well. Indexes on shared system catalogs are also processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">指定されたスキーマのすべてのインデックスを再作成します。このスキーマのテーブルに2次的な「TOAST」テーブルがある場合、それもインデックスが再作成されます。共有システムカタログのインデックスも処理されます。この形式の &lt;code&gt;REINDEX&lt;/code&gt; は、トランザクションブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="54a36c0b2b1b570c5b51a6a3b47c25f473f3cfb8" translate="yes" xml:space="preserve">
          <source>Recreate all indexes of the specified table. If the table has a secondary &amp;ldquo;TOAST&amp;rdquo; table, that is reindexed as well.</source>
          <target state="translated">指定したテーブルのすべてのインデックスを再作成します。テーブルにセカンダリの「TOAST」テーブルがある場合は、それにもインデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="b3546f5e2e55d429c2387304c29dfa4c36ee5973" translate="yes" xml:space="preserve">
          <source>Recreate all indexes on system catalogs within the current database. Indexes on shared system catalogs are included. Indexes on user tables are not processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">現在のデータベース内のシステムカタログのすべてのインデックスを再作成します。共有システムカタログのインデックスが含まれます。ユーザーテーブルのインデックスは処理されません。この形式の &lt;code&gt;REINDEX&lt;/code&gt; は、トランザクションブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="b8026b4ad3f9457c0e184493f3e0aa052fee5538" translate="yes" xml:space="preserve">
          <source>Recreate all indexes within the current database. Indexes on shared system catalogs are also processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">現在のデータベース内のすべてのインデックスを再作成します。共有システムカタログのインデックスも処理されます。この形式の &lt;code&gt;REINDEX&lt;/code&gt; は、トランザクションブロック内では実行できません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
