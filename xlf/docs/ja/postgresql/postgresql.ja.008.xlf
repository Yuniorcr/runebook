<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d06f9c00387f2a47db4df9d5fd9d29afd85a64d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.60. General-Purpose Window Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.60。汎用ウィンドウ関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a7332511d931adb3973faa13e02e9a2f58c70fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.61. Series Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.61。シリーズ生成関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09c4a37f6c6f303582adee38d96973e59b8f1d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.62. Subscript Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.62。下付き文字生成関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2135932869620b53f88c3e6313d35e2e57eb9554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.63. Session Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.63。セッション情報関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39be6ee87ea95e25c83a72d132334349eca53d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.64. Access Privilege Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.64 権限照会機能へのアクセス&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f88ee46d75d93ee18420ab0ac7544df7b69f3ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.65. &lt;code&gt;aclitem&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.65。 &lt;code&gt;aclitem&lt;/code&gt; オペレーター&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bff51c4fac1999b618aa6e81c66b1e1f53e8a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.66. &lt;code&gt;aclitem&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.66 &lt;code&gt;aclitem&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6ba9eacd371b2f2875e8cef1278fb77ebcd99c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.67. Schema Visibility Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.67 スキーマ可視性照会関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47c6aca319addf46ce6b419f1af927dda7149772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.68. System Catalog Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.68 システムカタログ情報関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59944c027b46284746c3c0d85e815a750a8891d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.69. Index Column Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.69。インデックス列のプロパティ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1714aed665ee3ec122913f297f2add6146e8617b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.7. Trigonometric Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.7。三角関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1931873243f7b29fd60849cb0265f82b1b3daa21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.70. Index Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.70 インデックスのプロパティ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="494455ae6249fdb9eaf4bc96c399bcc0b3287c53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.71. Index Access Method Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.71 インデックスアクセスメソッドのプロパティ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d4a0d7f19cdaf9dd206d8238d622ef290fa34c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.72. Object Information and Addressing Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.72 オブジェクト情報とアドレス指定関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2397166ddbff9e584fb4c1463d367dec3f650e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.73. Comment Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.73。コメント情報関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9e98e7f47369de4f674860d137be126fa8ff10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.74。トランザクションIDとスナップショット情報機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80e1c97f51ff6d0e29990ff06de5f0ff4842e1bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction IDs and Snapshots&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.74。トランザクションIDとスナップショット&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9297bd2822b43f167f4851fa970b2be7bc55e646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.75. Snapshot Components&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.75 スナップショットコンポーネント&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9fe3f4e24a04a45285feb4f7f3c39797576ff14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Committed Transaction Information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.76 コミットされたトランザクション情報&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec457094df6650e5b59b2d695b38d59162000858" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Deprecated Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.76。非推奨のトランザクションIDおよびスナップショット情報関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="037beea666806eb579eb1e15cade8169bb088d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Committed Transaction Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.77。コミットされたトランザクション情報機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22faf23155a7f6cdba38cb993e993be8e97bdafa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Control Data Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.77。制御データ関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10369b4d2384de89827853c38a3dbb088df94279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.78 &lt;code&gt;pg_control_checkpoint&lt;/code&gt; の列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4c03e3db71b0f0e87bd2ea049915cd526ae3e4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. Control Data Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.78。制御データ機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a853addac70ca1f81119d41bef07e20f8877b599" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.79。 &lt;code&gt;pg_control_checkpoint&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be67b2ae4fcc41758e4db5cec6bff447ce947830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_system&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.79 &lt;code&gt;pg_control_system&lt;/code&gt; の列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc142fb66ffa0a6f7f6394c00a57cfad199c4be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.8. Hyperbolic Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.8。双曲線関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69d99a933c31e93d42b87a8d05638885de6cef43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_init&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.80 &lt;code&gt;pg_control_init&lt;/code&gt; の列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f8b6c4cc1095d92081bffbb653c34b6d02d3743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_system&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.80。 &lt;code&gt;pg_control_system&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a173f9966d00cc18bb434a3a4ab064b9459dfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_init&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.81。 &lt;code&gt;pg_control_init&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efe7424b608f8ebbc9334ad7d348b73c225f8065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_recovery&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.81 &lt;code&gt;pg_control_recovery&lt;/code&gt; の列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a159d3ea3ae4f3ccfc518444dfa8484fdb024615" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. &lt;code&gt;pg_control_recovery&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.82。 &lt;code&gt;pg_control_recovery&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="258d4eca1eec881df06fbf6eb5c508a7eb4defe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.82 構成設定関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e119847bd2faa7c76a5c66565911ba36a9ec0410" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.83。構成設定機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af63c82b09a5fd893d3cbed8d4c9b65a84c8cc49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.83 サーバーシグナリング機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e11c93734b157fd8c86baa8c5096f64613f03240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Backup Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.84。バックアップ制御機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acca3a24f9bc4df489286e833e69b95dc624f3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.84。サーバーシグナリング機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2eccbc931adbf83e2e35ba4730cc92f21be424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Backup Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.85。バックアップ制御機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1cf89f9807ef48af5dc5feac483e531ed89fb76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.85。回復情報関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb7192e9cdc53717cb1d3a3d7a47063c367c5fd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.86 リカバリー制御機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18d1b2e85a47e7957190d7b5366cb8b95a8619e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.86。リカバリ情報機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c22940566328cfb562e298f923b5c5b854ba617" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.87。回復制御機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cc57c799c7d7ee53ed8b4b0bf37c2b80ea6845e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.87 スナップショット同期機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56158ae74f61cf23e3e86908ca0820720f4c8518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Replication SQL Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.88 レプリケーションSQL関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e4a778f3f4aea3b01888a18431c4aec5450cf91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.88。スナップショット同期機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53a72ba96b99dede4aa68dbbb8f2f4f443280905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.89 データベースオブジェクトサイズ関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7eb24e29872bb8ce841d184195dca28e365a088" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Replication Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.89。レプリケーション管理機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0821b82f66d9f4a6e0cd038e52ed04c3f7a05a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.9. SQL String Functions and Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.9。SQL文字列関数と演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8690793f9807c3f5f8ee02a7cc52f489067f885d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.90 データベースオブジェクトロケーション関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57f81cd7ef731234c1aa58e5ac57c4b20d50b59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.90。データベースオブジェクトサイズ関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1dac1ecbd39f8f56220a662263d1df23c3bd1d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Collation Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.91 照合管理関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="648f3f86b8b877c2a7cf1d1174a61e4e892421ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.91。データベースオブジェクトの場所の関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75784f3209f818a7b4abe3d1335fa8a55370c481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Collation Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.92。照合管理機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1d40194ab60a69acde4e12b20bea43def6aedf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.92。パーティショニング情報関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c370022e15dfd2d0b3991d342e19956b98c04f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.93 インデックスメンテナンス機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2937ed5c90d57a915d7a2b0a154f93953f850843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.93。情報機能の分割&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8379ad039963b5ac568013d446df9562b67c6abc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.94 汎用ファイルアクセス関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b95f05574afc667abf5b3192f21fdebd527e31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.94。インデックスメンテナンス機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5e2d3bc1f47aa4a1635eb7f3cff3425017bca1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.95。勧告的ロック機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3110ab11d26d5acb24d0ef4008dbf1062e59f19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表9.95。一般的なファイルアクセス機能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="669703497d2e61484f74a9f852b77c7dbe96af61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.96. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.96. Advisory Lock Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd947ce6d00206881c9746604187286ad479d127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table A.1. PostgreSQL Error Codes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表A.1。PostgreSQLエラーコード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a05dac2107a5f9f2ac31f3b94de8292ede9abce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.1. Month Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表B.1。月の名前&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ce6d7b1e15e8e01aa65312fb0df9adeaf930d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.2. Day of the Week Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表B.2。曜日の名前&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4035fdc79af664ad037421045dfc08f552eb1aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.3. Date/Time Field Modifiers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表B.3。日付/時刻フィールド修飾子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="559edd83cb5073785f38017209bf4a3b36ac0ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table C.1. SQL Key Words&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表C.1。SQLキーワード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d10534ea211538918961793e09cac043e6061f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.1. &lt;code&gt;adminpack&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.1。 &lt;code&gt;adminpack&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b519c1bf6f735544d2045d66c60755bcd006027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.10. &lt;code&gt;intarray&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.10。 &lt;code&gt;intarray&lt;/code&gt; 演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c07b2821b106599e7e19c067ef0623853754e74b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.11. &lt;code&gt;isn&lt;/code&gt; Data Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.11。 &lt;code&gt;isn&lt;/code&gt; データ型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9de57df1bb6bd0b8cf1c93e4ac13f3f2cd6cec28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.12. &lt;code&gt;isn&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.12。 &lt;code&gt;isn&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5fc76943f1f53439b794c832fa0195dc25753eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.13. &lt;code&gt;ltree&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.13。 &lt;code&gt;ltree&lt;/code&gt; オペレーター&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f47dedf5cd81c558ae828df89aeceeffbcca4ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.14. &lt;code&gt;ltree&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.14。 &lt;code&gt;ltree&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db1ea3c10d5f847276d5255278d415ebe4cfbb7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.15. &lt;code&gt;pg_buffercache&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.15。 &lt;code&gt;pg_buffercache&lt;/code&gt; の列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb70b4765f6524df3f91e44d66f42eb9ce59f1f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.16. Supported Algorithms for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.16。 &lt;code&gt;crypt()&lt;/code&gt; でサポートされるアルゴリズム&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74efd3a20d0a5ca77d9ec0d65a88482478d0db59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.17. Iteration Counts for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.17。 &lt;code&gt;crypt()&lt;/code&gt; の反復回数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16082250b8218899af06afb261507b192bd2a3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.18. Hash Algorithm Speeds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.18。ハッシュアルゴリズムの速度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="023c35c98f9f91629573b50cb356cd985b32d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.19. Summary of Functionality with and without OpenSSL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.19。OpenSSLを使用した場合と使用しない場合の機能の概要&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97b5d7566b2274950bfb99f59140174951e32afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.2. Cube External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.2 キューブの外部表現&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="31519ff8934e1c9d30bb975be3e1d15050040610" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.20. &lt;code&gt;pgrowlocks&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.20。 &lt;code&gt;pgrowlocks&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40ee7b256a4076cfeae51995de13c374ee02588a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.21. &lt;code&gt;pg_stat_statements&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.21。 &lt;code&gt;pg_stat_statements&lt;/code&gt; の列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2bf9da321dec29d80c37b3aec85adcfd8d4e6ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.22. &lt;code&gt;pgstattuple&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.22。 &lt;code&gt;pgstattuple&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36d397f9b671a3e1925bb2eb0936f8f0832e9789" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.23. &lt;code&gt;pgstattuple_approx&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.23。 &lt;code&gt;pgstattuple_approx&lt;/code&gt; 出力列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c437a7af148f8e8389f5c7449218ce3b637fba68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.24. &lt;code&gt;pg_trgm&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.24。 &lt;code&gt;pg_trgm&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76d05073c0bf7063af3660fac90eb31ef8a83d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.25. &lt;code&gt;pg_trgm&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.25。 &lt;code&gt;pg_trgm&lt;/code&gt; 演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b53fc25e7d7cf3149fa7d701cb97669cc4302291" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.26. &lt;code&gt;seg&lt;/code&gt; External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.26。 &lt;code&gt;seg&lt;/code&gt; 外部表現&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fce95711636b8b7c0ab0c8c90a10676ec4c5dd99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.27. Examples of Valid &lt;code&gt;seg&lt;/code&gt; Input&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.27。有効な &lt;code&gt;seg&lt;/code&gt; 入力の例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0703329077e17e37589124cf687bfbdb4ff5f02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.28. Seg GiST Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.28。Seg GiSTオペレーター&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efb677aa5a54059bffe378ceabe3ff851dc97be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.29. Sepgsql Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.29。Sepgsql関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a4b5bfe663b6c86554a4fe157eb1e9883705ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.3. Cube Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.3。キューブ演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2f068919e3f99a106ec1019bd78e8bde34335d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.30. &lt;code&gt;tablefunc&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.30。 &lt;code&gt;tablefunc&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c27a41af6ae7cee6f4a14c9d9a0b8aef27e683da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.31. &lt;code&gt;connectby&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.31。 &lt;code&gt;connectby&lt;/code&gt; パラメータ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eccc0fa14874dcf09c6ccf36766eb1c65d7a9d87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.32. Functions for UUID Generation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.32。UUID生成のための関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="285949d92f8186403bfcd2046f6dcc6813339504" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.33. Functions Returning UUID Constants&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.33。UUID定数を返す関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce4775173e0a8d85b3a4c68976acfaac26cdbeba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. &lt;code&gt;xml2&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table F.34. &lt;code&gt;xml2&lt;/code&gt; Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2710d2338031518ccc53baf6792d41b5ad8f677" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.34。関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e4038c34dc95dfcc18297824a175effec134055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.35. &lt;code&gt;xpath_table&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.35。 &lt;code&gt;xpath_table&lt;/code&gt; パラメータ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b35f9c6abb36ad8fc92db8bdc01beb1c4250a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.4. Cube Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.4。キューブ関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e92b11d7884dfede47b04bfcbf5a41bf72e63d9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.5. Cube-Based Earthdistance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.5。キューブベースの地球距離関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e051b81229455604f98408865a6ac1b4addebbc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.6. Point-Based Earthdistance Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.6。ポイントベースの地球距離演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abcf169338c4abfd8292e2d9fff28e5b2b09033c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.7. &lt;code&gt;hstore&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.7。 &lt;code&gt;hstore&lt;/code&gt; オペレーター&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40c6e68eca0fdcd7802454203dbb36dbc3ddb825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.8. &lt;code&gt;hstore&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.8。 &lt;code&gt;hstore&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d86c143b9375e6f997fb5dadf92e3e129f96c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.9. &lt;code&gt;intarray&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表F.9。 &lt;code&gt;intarray&lt;/code&gt; 関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d890fb1a42200a1b33e3307e2ccd5c9035ab6794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table K.1. PostgreSQL Limitations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;表K.1 PostgreSQLの制限&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="696c4ceafbfe949ae4e1ac9f260a8e4f375683bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table of Contents&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;目次&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bf69c48186996b82fe7b81247ad9250cfca6c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table-Level Lock Modes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;テーブルレベルのロックモード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be38ff52aef87b71c69cb929026cdf03c79939a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type Resolution for &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;CASE&lt;/code&gt;, and Related Constructs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;CASE&lt;/code&gt; 、および関連する構成の型解決&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5460fb3b002cb82e36bdab3a44937749c957abe2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upgrade streaming replication and log-shipping standby servers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ストリーミングレプリケーションとログ配布スタンバイサーバーのアップグレード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0c5de3159b80d3a3ca8692e2ddf1964928d7107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;split&lt;/code&gt;. &lt;/strong&gt; The &lt;code&gt;split&lt;/code&gt; command allows you to split the output into smaller files that are acceptable in size to the underlying file system. For example, to make chunks of 1 megabyte:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;split&lt;/code&gt; を使用します。&lt;/strong&gt; &lt;code&gt;split&lt;/code&gt; コマンドを使用すると、基本的なファイルシステムのサイズが許容される小さなファイルに出力を分割することができます。たとえば、1メガバイトのチャンクを作成するには：</target>
        </trans-unit>
        <trans-unit id="1a80b9aa68fb3c8b73036c3ce7eec622afb708fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use compressed dumps. &lt;/strong&gt; You can use your favorite compression program, for example gzip:</source>
          <target state="translated">&lt;strong&gt;圧縮ダンプを使用します。&lt;/strong&gt;gzipなど、お好みの圧縮プログラムを使用できます。</target>
        </trans-unit>
        <trans-unit id="1abab695321f295c720b6c84d1b5599f942c1413" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's custom dump format. &lt;/strong&gt; If PostgreSQL was built on a system with the zlib compression library installed, the custom dump format will compress data as it writes it to the output file. This will produce dump file sizes similar to using &lt;code&gt;gzip&lt;/code&gt;, but it has the added advantage that tables can be restored selectively. The following command dumps a database using the custom dump format:</source>
          <target state="translated">&lt;strong&gt;pg_dumpのカスタムダンプ形式を使用します。&lt;/strong&gt;PostgreSQLがzlib圧縮ライブラリがインストールされているシステムで構築されている場合、カスタムダンプ形式は、データを出力ファイルに書き込むときにデータを圧縮します。これにより、 &lt;code&gt;gzip&lt;/code&gt; を使用した場合と同様のダンプファイルサイズが生成されますが、テーブルを選択的に復元できるという利点もあります。次のコマンドは、カスタムダンプ形式を使用してデータベースをダンプします。</target>
        </trans-unit>
        <trans-unit id="cbfe9fc7a7a29e0a0178f83061d2c90c3e3b191c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's parallel dump feature. &lt;/strong&gt; To speed up the dump of a large database, you can use pg_dump's parallel mode. This will dump multiple tables at the same time. You can control the degree of parallelism with the &lt;code&gt;-j&lt;/code&gt; parameter. Parallel dumps are only supported for the &quot;directory&quot; archive format.</source>
          <target state="translated">&lt;strong&gt;pg_dumpの並列ダンプ機能を使用します。&lt;/strong&gt;大規模なデータベースのダンプを高速化するには、pg_dumpの並列モードを使用できます。これにより、複数のテーブルが同時にダンプされます。 &lt;code&gt;-j&lt;/code&gt; パラメーターを使用して、並列度を制御できます。並列ダンプは、「ディレクトリ」アーカイブ形式でのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="edfa928646e2342a7f8cd8c011c0572d9d895659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value Storage Type Conversion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;値のストレージタイプの変換&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf7bb1fedc9115854eb42fd28c3bf8a588f25119" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons</source>
          <target state="translated">@ 1年2ヶ月</target>
        </trans-unit>
        <trans-unit id="03555338c898371183a9886d4e4b1c92f3732990" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</source>
          <target state="translated">@ 1年2ヶ月-3日4時間5分6秒前</target>
        </trans-unit>
        <trans-unit id="81d943392746fd8a7d1a28c6c2928f65ea407380" translate="yes" xml:space="preserve">
          <source>@ 3 days 4 hours 5 mins 6 secs</source>
          <target state="translated">@ 3日4時間5分6秒</target>
        </trans-unit>
        <trans-unit id="bf2057e4a34b0143c5ca30f416938d0496f64cf4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;from SQL&amp;rdquo; function that converts the type from the SQL environment to the language. This function will be invoked on the arguments of a function written in the language.</source>
          <target state="translated">タイプをSQL環境から言語に変換する「from SQL」関数。この関数は、言語で記述された関数の引数で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5d8d466be36923654e1e5048281d3752210ffa26" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;nil&amp;rdquo; UUID constant, which does not occur as a real UUID.</source>
          <target state="translated">「nil」UUID定数。実際のUUIDとしては発生しません。</target>
        </trans-unit>
        <trans-unit id="2762eb369c90d7266035a7f6c6fc6bc10aa918a6" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;search&amp;rdquo; operator entry indicates that an index of this operator family can be searched to find all rows satisfying &lt;code&gt;WHERE&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Obviously, such an operator must return &lt;code&gt;boolean&lt;/code&gt;, and its left-hand input type must match the index's column data type.</source>
          <target state="translated">「検索」演算子エントリは、この演算子ファミリのインデックスを検索して、 &lt;code&gt;WHERE&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; を満たすすべての行を見つけることができることを示しています。明らかに、そのような演算子は &lt;code&gt;boolean&lt;/code&gt; を返す必要があり、その左側の入力型はインデックスの列のデータ型と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="cb8c23a8cc28795360368ac535c18eb45a0b60b7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;to SQL&amp;rdquo; function that converts the type from the language to the SQL environment. This function will be invoked on the return value of a function written in the language.</source>
          <target state="translated">型を言語からSQL環境に変換する「to SQL」関数。この関数は、言語で記述された関数の戻り値で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3ae930caf5146f65e1ff7504137e6bf65415863f" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;user logging out&amp;rdquo; might happen as part of a maintenance job or manually when an administrator logs in as the &lt;code&gt;postgres&lt;/code&gt; user or something similar, so it is hard to prevent in general.</source>
          <target state="translated">「ユーザーのログアウト」は、メンテナンスジョブの一部として、または管理者が &lt;code&gt;postgres&lt;/code&gt; ユーザーまたは同様のユーザーとしてログインしたときに手動で発生する可能性があるため、一般的に防止するのは困難です。</target>
        </trans-unit>
        <trans-unit id="1ff3ebb0f8189d5c79fdc8dc5893085ae875532b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that is paired with a &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; database and is maintaining a copy of some or all of the primary database's data. The foremost reasons for doing this are to allow for greater access to that data, and to maintain availability of the data in the event that the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; becomes unavailable.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that is paired with a &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; database and is maintaining a copy of some or all of the primary database's data. The foremost reasons for doing this are to allow for greater access to that data, and to maintain availability of the data in the event that the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; becomes unavailable.</target>
        </trans-unit>
        <trans-unit id="3b194a0aad401cf33db00ac53a2bc3183f5f056e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;cluster&lt;/a&gt;'s storage space comprises the data directory plus any additional tablespaces.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;cluster&lt;/a&gt;'s storage space comprises the data directory plus any additional tablespaces.</target>
        </trans-unit>
        <trans-unit id="4c2f7268e91d10d9931079a4060abb1b24912d62" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; that combines (&lt;em&gt;aggregates&lt;/em&gt;) multiple input values, for example by counting, averaging or adding, yielding a single output value.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; that combines (&lt;em&gt;aggregates&lt;/em&gt;) multiple input values, for example by counting, averaging or adding, yielding a single output value.</target>
        </trans-unit>
        <trans-unit id="b8de6f610e2bf77390b8a376c81b44793683355f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; which can be defined to execute whenever a certain operation (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;) is applied to a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. A trigger executes within the same &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; as the statement which invoked it, and if the function fails, then the invoking statement also fails.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; which can be defined to execute whenever a certain operation ( &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; ) is applied to a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. A trigger executes within the same &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; as the statement which invoked it, and if the function fails, then the invoking statement also fails.</target>
        </trans-unit>
        <trans-unit id="0e2fccb32e2fa61d4f930e061e62abd8488bb50a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that contains data derived from a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;. Its internal structure supports fast retrieval of and access to the original data.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that contains data derived from a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;. Its internal structure supports fast retrieval of and access to the original data.</target>
        </trans-unit>
        <trans-unit id="584813927fa0b70a127a5ac34c88fc5f5c387c54" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement (just like a &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;), but stores data in the same way that a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; does. It cannot be modified via &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; operations.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement (just like a &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;), but stores data in the same way that a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; does. It cannot be modified via &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , or &lt;code&gt;DELETE&lt;/code&gt; operations.</target>
        </trans-unit>
        <trans-unit id="389fa46ef8422aab8a4910b862a288c61f74078c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement, but has no storage of its own. Any time a query references a view, the definition of the view is substituted into the query as if the user had typed it as a subquery instead of the name of the view.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement, but has no storage of its own. Any time a query references a view, the definition of the view is substituted into the query as if the user had typed it as a subquery instead of the name of the view.</target>
        </trans-unit>
        <trans-unit id="53c9b267d1a3c53d206839f21ecc0e74a5743f97" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is in semantic terms the same as a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but whose storage is distributed across several &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partitions&lt;/a&gt;.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is in semantic terms the same as a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but whose storage is distributed across several &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partitions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4beb53d2dd032e24132f47b79c4ab9ee08f60da3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; transmitted from a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend process&lt;/a&gt; to a &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client&lt;/a&gt; upon the completion of an SQL command, usually a &lt;code&gt;SELECT&lt;/code&gt; but it can be an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command if the &lt;code&gt;RETURNING&lt;/code&gt; clause is specified.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; transmitted from a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend process&lt;/a&gt; to a &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client&lt;/a&gt; upon the completion of an SQL command, usually a &lt;code&gt;SELECT&lt;/code&gt; but it can be an &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , or &lt;code&gt;DELETE&lt;/code&gt; command if the &lt;code&gt;RETURNING&lt;/code&gt; clause is specified.</target>
        </trans-unit>
        <trans-unit id="15e75dd492c3448df99f37b47329397dc097e33f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which appears to have &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; similar to a regular &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but will forward requests for data through its &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;, which will return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result sets&lt;/a&gt; structured according to the definition of the &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign table&lt;/a&gt;.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which appears to have &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; similar to a regular &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but will forward requests for data through its &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;, which will return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result sets&lt;/a&gt; structured according to the definition of the &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign table&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2896c9fab918dbff2c145f3310c61dcc0ebaadf8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; that has the &lt;code&gt;LOGIN&lt;/code&gt; privilege.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; that has the &lt;code&gt;LOGIN&lt;/code&gt; privilege.</target>
        </trans-unit>
        <trans-unit id="e0269b93f9965a7efd0bd4de79b884ef8ce24927" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; is considered &lt;a href=&quot;glossary#GLOSSARY-LOGGED&quot;&gt;logged&lt;/a&gt; if changes to it are sent to the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. By default, all regular tables are logged. A table can be specified as &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;unlogged&lt;/a&gt; either at creation time or via the &lt;code&gt;ALTER TABLE&lt;/code&gt; command.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; is considered &lt;a href=&quot;glossary#GLOSSARY-LOGGED&quot;&gt;logged&lt;/a&gt; if changes to it are sent to the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. By default, all regular tables are logged. A table can be specified as &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;unlogged&lt;/a&gt; either at creation time or via the &lt;code&gt;ALTER TABLE&lt;/code&gt; command.</target>
        </trans-unit>
        <trans-unit id="87f22694b8568dac5808dc2163d1d852566c139b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the columns and rows of the view.</source>
          <target state="translated">A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;または&lt;a href=&quot;sql-values&quot;&gt;VALUESは、&lt;/a&gt;ビューの列と行を提供しますどのコマンド。</target>
        </trans-unit>
        <trans-unit id="f5f1049f4109dc5db352ab8d92ece996eabd228c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the rows to be returned by the cursor.</source>
          <target state="translated">A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;または&lt;a href=&quot;sql-values&quot;&gt;値が&lt;/a&gt;カーソルによって返される行を提供するであろうコマンド。</target>
        </trans-unit>
        <trans-unit id="b8b71200935bf14bcaf475eabe324c9a915be563" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command, or an &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; command that runs a prepared &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; query.</source>
          <target state="translated">A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;、&lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;、または&lt;a href=&quot;sql-values&quot;&gt;VALUESは、&lt;/a&gt;コマンド、または&lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt;準備し実行するコマンド &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;TABLE&lt;/code&gt; 、または &lt;code&gt;VALUES&lt;/code&gt; のクエリを。</target>
        </trans-unit>
        <trans-unit id="b516d250c25b6e73cb44ebe944600ea4dcdfab57" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command. This query will run within a security-restricted operation; in particular, calls to functions that themselves create temporary tables will fail.</source>
          <target state="translated">A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;、&lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;、または&lt;a href=&quot;sql-values&quot;&gt;VALUESの&lt;/a&gt;コマンド。このクエリは、セキュリティが制限された操作内で実行されます。特に、それ自体が一時テーブルを作成する関数の呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="4c32cd6f04f46fa40c66ced5598180206388bcb3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;, &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command whose results are to be copied. Note that parentheses are required around the query.</source>
          <target state="translated">A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;、&lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;、&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;結果コピーされるコマンド。クエリの前後に括弧が必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3aac443fc49c397d670128be5de3b30376a87d25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;&lt;/code&gt; operator must be a strong ordering relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 演算子は、強力な順序関係でなければなりません。つまり、null以外のすべての値 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="819a83c6160f87b8fbe9b47f7e8c2fcb8b3441e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; construct used in this fashion will defeat optimization attempts, so it should only be done when necessary. (In this particular example, it would be better to sidestep the problem by writing &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; instead.)</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; の最適化の試みを打ち負かすだろう、この方法で用いた構築物は、それが必要なときにのみ行われるべきです。（この特定の例では、代わりに &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; 書いて問題を回避する方が良いでしょう。）</target>
        </trans-unit>
        <trans-unit id="6247b7100ee328df210a70a605d94770307d4618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; expression does not evaluate any subexpressions that are not needed to determine the result. For example, this is a possible way of avoiding a division-by-zero failure:</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; の式は、結果を決定するために必要されていない任意の部分式を評価しません。たとえば、これはゼロ除算の失敗を回避する可能な方法です。</target>
        </trans-unit>
        <trans-unit id="99c1d2ec7824e3f9be873b53497fbe438c59e00f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE FUNCTION&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. The attributes are not portable, neither are the different available languages.</source>
          <target state="translated">Aは、 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; コマンドはSQL標準で定義されています。PostgreSQLのバージョンは類似していますが、完全には互換性がありません。属性は移植可能ではなく、使用可能な言語も異なります。</target>
        </trans-unit>
        <trans-unit id="72fba28ad575d8675106f7a64f95b2cad77d64bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. For details see also &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</source>
          <target state="translated">Aは &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; コマンドはSQL標準で定義されています。 PostgreSQLのバージョンは類似していますが、完全には互換性がありません。詳細については、&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="4d8bad9823a1eeb3d425248ce5d647ad68ad9035" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DELETE&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being deleted from the relation, so that there is no new row to check.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; ポリシーが持つことができません &lt;code&gt;WITH CHECK&lt;/code&gt; それはレコードのみを関係から削除される場合に適用されるよう確認するための新しい行が存在しないのでこと、表現します。</target>
        </trans-unit>
        <trans-unit id="ffed91b9d2e2689c8f9096a3b8e654e3487952c0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JOIN&lt;/code&gt; clause combines two &lt;code&gt;FROM&lt;/code&gt; items, which for convenience we will refer to as &amp;ldquo;tables&amp;rdquo;, though in reality they can be any type of &lt;code&gt;FROM&lt;/code&gt; item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt;s nest left-to-right. In any case &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than the commas separating &lt;code&gt;FROM&lt;/code&gt;-list items.</source>
          <target state="translated">Aは &lt;code&gt;JOIN&lt;/code&gt; 句のコンバイン2 &lt;code&gt;FROM&lt;/code&gt; 現実には、彼らは、任意のタイプかも知れません便宜のため、我々は、「テーブル」と呼びます項目、 &lt;code&gt;FROM&lt;/code&gt; アイテムを。必要に応じて括弧を使用して、ネストの順序を決定します。括弧がない場合、 &lt;code&gt;JOIN&lt;/code&gt; は左から右にネストします。いずれにせよ、 &lt;code&gt;JOIN&lt;/code&gt; は &lt;code&gt;FROM&lt;/code&gt; -listアイテムを区切るコンマよりも強くバインドします。</target>
        </trans-unit>
        <trans-unit id="22a84ad9de4a47f15eabedf603ec63031e192119" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LATERAL&lt;/code&gt; item can appear at top level in the &lt;code&gt;FROM&lt;/code&gt; list, or within a &lt;code&gt;JOIN&lt;/code&gt; tree. In the latter case it can also refer to any items that are on the left-hand side of a &lt;code&gt;JOIN&lt;/code&gt; that it is on the right-hand side of.</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; 項目はトップレベルで表示されることが &lt;code&gt;FROM&lt;/code&gt; リスト、または内部 &lt;code&gt;JOIN&lt;/code&gt; の木。後者の場合、 &lt;code&gt;JOIN&lt;/code&gt; の左側にあり、右側にある項目を参照することもできます。</target>
        </trans-unit>
        <trans-unit id="e8ae34e725d60cc08b18c4661033d9a5986eedac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SECURITY DEFINER&lt;/code&gt; procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">&lt;code&gt;SECURITY DEFINER&lt;/code&gt; の手順は、（例えば、トランザクション制御ステートメントを実行することができない &lt;code&gt;COMMIT&lt;/code&gt; と &lt;code&gt;ROLLBACK&lt;/code&gt; 言語に応じて、）。</target>
        </trans-unit>
        <trans-unit id="24640de38cd7e79e6c26b95c139e86bc1984a68f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT&lt;/code&gt; sub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.</source>
          <target state="translated">その前の括弧で囲まれた列リストにリストされているのと同じ数の出力列を生成する &lt;code&gt;SELECT&lt;/code&gt; サブクエリ。サブクエリの実行時に生成される行は1行のみです。 1つの行が生成される場合、その列の値がターゲット列に割り当てられます。行が生成されない場合、NULL値がターゲット列に割り当てられます。サブクエリは、更新されるテーブルの現在の行の古い値を参照できます。</target>
        </trans-unit>
        <trans-unit id="9f32387ffee5e380629abaa1525601dc9d6facaf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ShareLock&lt;/code&gt; is required on the target index by &lt;code&gt;bt_index_parent_check&lt;/code&gt; (a &lt;code&gt;ShareLock&lt;/code&gt; is also acquired on the heap relation). These locks prevent concurrent data modification from &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; commands. The locks also prevent the underlying relation from being concurrently processed by &lt;code&gt;VACUUM&lt;/code&gt;, as well as all other utility commands. Note that the function holds locks only while running, not for the entire transaction.</source>
          <target state="translated">A &lt;code&gt;ShareLock&lt;/code&gt; はによってターゲットインデックスに必要とされる &lt;code&gt;bt_index_parent_check&lt;/code&gt; （ &lt;code&gt;ShareLock&lt;/code&gt; はまた、ヒープ関係に取得されます）。これらのロックにより、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; コマンドによる同時データ変更が防止されます。ロックはまた、基になる関係が &lt;code&gt;VACUUM&lt;/code&gt; や他のすべてのユーティリティコマンドによって同時に処理されるのを防ぎます。関数は、トランザクション全体ではなく、実行中にのみロックを保持することに注意してください。</target>
        </trans-unit>
        <trans-unit id="f5a2d75bff2c30ff411c224c9fe1259bed07345e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause after a &lt;code&gt;table_name&lt;/code&gt; indicates that the specified &lt;code&gt;sampling_method&lt;/code&gt; should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as &lt;code&gt;WHERE&lt;/code&gt; clauses. The standard PostgreSQL distribution includes two sampling methods, &lt;code&gt;BERNOULLI&lt;/code&gt; and &lt;code&gt;SYSTEM&lt;/code&gt;, and other sampling methods can be installed in the database via extensions.</source>
          <target state="translated">&lt;code&gt;TABLESAMPLE&lt;/code&gt; の後句 &lt;code&gt;table_name&lt;/code&gt; 指定されたことを示している &lt;code&gt;sampling_method&lt;/code&gt; は、そのテーブル内の行のサブセットを取得するために使用されるべきです。このサンプリングは、 &lt;code&gt;WHERE&lt;/code&gt; 句などの他のフィルターの適用に先行します。標準のPostgreSQLディストリビューションには、 &lt;code&gt;BERNOULLI&lt;/code&gt; と &lt;code&gt;SYSTEM&lt;/code&gt; の 2つのサンプリング方法が含まれており、その他のサンプリング方法は拡張機能を介してデータベースにインストールできます。</target>
        </trans-unit>
        <trans-unit id="0e67a4c57a74dd900aa610f5f6c701a6078b7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TZH&lt;/code&gt; template pattern can match a signed number. Without the &lt;code&gt;FX&lt;/code&gt; option, minus signs may be ambiguous, and could be interpreted as a separator. This ambiguity is resolved as follows: If the number of separators before &lt;code&gt;TZH&lt;/code&gt; in the template string is less than the number of separators before the minus sign in the input string, the minus sign is interpreted as part of &lt;code&gt;TZH&lt;/code&gt;. Otherwise, the minus sign is considered to be a separator between values. For example, &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; matches &lt;code&gt;-10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;, but &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; matches &lt;code&gt;10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TZH&lt;/code&gt; のテンプレートパターンは、署名された番号と一致することができます。 &lt;code&gt;FX&lt;/code&gt; オプションを使用しないと、マイナス記号があいまいになり、区切り文字として解釈される可能性があります。このあいまいさは次のように解決されます。テンプレート文字列の &lt;code&gt;TZH&lt;/code&gt; の前のセパレータの数が入力文字列のマイナス記号の前のセパレータの数より少ない場合、マイナス記号は &lt;code&gt;TZH&lt;/code&gt; の一部として解釈されます。それ以外の場合、マイナス記号は値間の区切り文字と見なされます。たとえば、 &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; &lt;code&gt;-10&lt;/code&gt; から &lt;code&gt;TZH&lt;/code&gt; に一致しますが、 &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; &lt;code&gt;10&lt;/code&gt; から &lt;code&gt;TZH&lt;/code&gt; に一致します。</target>
        </trans-unit>
        <trans-unit id="975d4d7cc350f909c3d56a227d26009cd1f3f678" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WITH&lt;/code&gt; query is referenced by writing its name, just as though the query's name were a table name. (In fact, the &lt;code&gt;WITH&lt;/code&gt; query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.</source>
          <target state="translated">A &lt;code&gt;WITH&lt;/code&gt; クエリは、クエリの名前は、テーブル名だけだったかのように、その名前を書くことで参照されています。（実際、 &lt;code&gt;WITH&lt;/code&gt; クエリは、プライマリクエリの目的で同じ名前の実際のテーブルを非表示にします。必要に応じて、テーブル名をスキーマ修飾することにより、同じ名前の実際のテーブルを参照できます。）エイリアスはテーブルと同じ方法で提供されます。</target>
        </trans-unit>
        <trans-unit id="ff3f18d6b0d0d8ef8e261f092333e8ac1a83778d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bloom&lt;/code&gt; index accepts the following parameters in its &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;bloom&lt;/code&gt; インデックスは、その中に次のパラメータを受け入れ &lt;code&gt;WITH&lt;/code&gt; の句を：</target>
        </trans-unit>
        <trans-unit id="4c2361c26a25ed37192ff6822eb9815e6a1bb350" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;default_expression&lt;/code&gt;, rather than being evaluated immediately when &lt;code&gt;xmltable&lt;/code&gt; is called, is evaluated each time a default is needed for the column. If the expression qualifies as stable or immutable, the repeat evaluation may be skipped. This means that you can usefully use volatile functions like &lt;code&gt;nextval&lt;/code&gt; in &lt;code&gt;default_expression&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default_expression&lt;/code&gt; ではなく、時にすぐに評価されて &lt;code&gt;xmltable&lt;/code&gt; 呼び出されたが、デフォルトが列のために必要とされるたびに評価されます。式が安定または不変として修飾されている場合、繰り返し評価はスキップされます。これは、 &lt;code&gt;default_expression&lt;/code&gt; で &lt;code&gt;nextval&lt;/code&gt; などの揮発性関数を便利に使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="6a8d6c448f4256c5739e1f342a948208b8ac9336" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;dict_xsyn&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; 辞書は以下のオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="4731474e93af48b3b039ee433573b761b490ebba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition.</source>
          <target state="translated">&lt;code&gt;frame_start&lt;/code&gt; の &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; フレームは、パーティションの最初の行から始まり、同様ことを意味 &lt;code&gt;frame_end&lt;/code&gt; の &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; のパーティションの最後の行とフレーム終了することを意味します。</target>
        </trans-unit>
        <trans-unit id="ba67bfc07bc1375b67a77983258edd014dff690f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;money&lt;/code&gt; value can be cast to &lt;code&gt;numeric&lt;/code&gt; without loss of precision. Conversion to other types could potentially lose precision, and must also be done in two stages:</source>
          <target state="translated">&lt;code&gt;money&lt;/code&gt; 価値はにキャストすることができ &lt;code&gt;numeric&lt;/code&gt; 精度の損失なし。他の型への変換は精度が低下する可能性があり、次の2つの段階で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="00e1eada317c8cafe63dee1a39dd2ab5032af82d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_default_acl&lt;/code&gt; entry shows the initial privileges to be assigned to an object belonging to the indicated user. There are currently two types of entry: &amp;ldquo;global&amp;rdquo; entries with &lt;code&gt;defaclnamespace&lt;/code&gt; = 0, and &amp;ldquo;per-schema&amp;rdquo; entries that reference a particular schema. If a global entry is present then it &lt;em&gt;overrides&lt;/em&gt; the normal hard-wired default privileges for the object type. A per-schema entry, if present, represents privileges to be &lt;em&gt;added to&lt;/em&gt; the global or hard-wired default privileges.</source>
          <target state="translated">&lt;code&gt;pg_default_acl&lt;/code&gt; エントリは、指示されたユーザに属するオブジェクトに割り当てられる初期権限を示します。現在2種類のエントリがあります &lt;code&gt;defaclnamespace&lt;/code&gt; = 0の「グローバル」エントリと、特定のスキーマを参照する「スキーマごと」エントリです。グローバルエントリが存在する場合、それはオブジェクトタイプの通常のハードワイヤードデフォルト特権を&lt;em&gt;上書きします&lt;/em&gt;。スキーマごとのエントリは、存在する場合、グローバルまたはハードワイヤードのデフォルト権限に&lt;em&gt;追加される&lt;/em&gt;権限を表します。</target>
        </trans-unit>
        <trans-unit id="1cb2939b4b6d4ddce66b3a2e4882d5e2fd0717d0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_ident.conf&lt;/code&gt; file that could be used in conjunction with the &lt;code&gt;pg_hba.conf&lt;/code&gt; file in &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;Example 20.1&lt;/a&gt; is shown in &lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;Example 20.2&lt;/a&gt;. In this example, anyone logged in to a machine on the 192.168 network that does not have the operating system user name &lt;code&gt;bryanh&lt;/code&gt;, &lt;code&gt;ann&lt;/code&gt;, or &lt;code&gt;robert&lt;/code&gt; would not be granted access. Unix user &lt;code&gt;robert&lt;/code&gt; would only be allowed access when he tries to connect as PostgreSQL user &lt;code&gt;bob&lt;/code&gt;, not as &lt;code&gt;robert&lt;/code&gt; or anyone else. &lt;code&gt;ann&lt;/code&gt; would only be allowed to connect as &lt;code&gt;ann&lt;/code&gt;. User &lt;code&gt;bryanh&lt;/code&gt; would be allowed to connect as either &lt;code&gt;bryanh&lt;/code&gt; or as &lt;code&gt;guest1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ident.conf&lt;/code&gt; と併せて使用することができるファイル &lt;code&gt;pg_hba.conf&lt;/code&gt; 中のファイルを&lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;、実施例20.1に&lt;/a&gt;に示されている&lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;実施例20.2&lt;/a&gt;。この例では、オペレーティングシステムのユーザー名が &lt;code&gt;bryanh&lt;/code&gt; 、 &lt;code&gt;ann&lt;/code&gt; 、または &lt;code&gt;robert&lt;/code&gt; でない192.168ネットワーク上のマシンにログインしたユーザーには、アクセスが許可されません。 Unixユーザー &lt;code&gt;robert&lt;/code&gt; は、 &lt;code&gt;robert&lt;/code&gt; または他のユーザーとしてではなく、PostgreSQLユーザー &lt;code&gt;bob&lt;/code&gt; として接続しようとした場合にのみアクセスを許可されます。 &lt;code&gt;ann&lt;/code&gt; としてのみ接続を許可されるだろう &lt;code&gt;ann&lt;/code&gt; 。ユーザー &lt;code&gt;bryanh&lt;/code&gt; どちらかとの接続を許可されるだろう &lt;code&gt;bryanh&lt;/code&gt; またはとして &lt;code&gt;guest1&lt;/code&gt; が。</target>
        </trans-unit>
        <trans-unit id="421151d14aecca0c09fe097c61a7a69cad0ef7d4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;sort_expression&lt;/code&gt; can also be the column label or number of an output column, as in:</source>
          <target state="translated">&lt;code&gt;sort_expression&lt;/code&gt; また、同様に、出力列の列ラベルまたは番号であり得ます。</target>
        </trans-unit>
        <trans-unit id="2b23f0024d2472dff4bba030a8daa989f120d9ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsquery&lt;/code&gt; value stores lexemes that are to be searched for, and can combine them using the Boolean operators &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR), and &lt;code&gt;!&lt;/code&gt; (NOT), as well as the phrase search operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY). There is also a variant &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; of the FOLLOWED BY operator, where &lt;code&gt;N&lt;/code&gt; is an integer constant that specifies the distance between the two lexemes being searched for. &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 値が検索されることになる、とブール演算子使用して、それらを組み合わせることができます店の語彙素 &lt;code&gt;&amp;amp;&lt;/code&gt; （AND）を、 &lt;code&gt;|&lt;/code&gt; （または）、および &lt;code&gt;!&lt;/code&gt; （NOT）、およびフレーズ検索演算子 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; （FOLLOWED BY）。FOLLOWED BY演算子のバリアント &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; もあります &lt;code&gt;N&lt;/code&gt; は、検索対象の2つの語彙素間の距離を指定する整数定数です。 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; は &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; &amp;gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="1488cfe9583a001f3966c381b957f6eda3c9c49c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; の値は、別個のソートされたリストである&lt;em&gt;語彙素&lt;/em&gt;されている単語で、&lt;em&gt;正規化&lt;/em&gt;と同じワード（参照の異なる変異体をマージする&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章&lt;/a&gt;詳細については）。次の例に示すように、ソートと重複排除は入力時に自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="558bdfda3afcef5f29f3f2e8969b74e0c735aa26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="translated">A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</target>
        </trans-unit>
        <trans-unit id="72b056d2deaf1866d999d56f9aac903ec6223482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;zone_abbreviation&lt;/code&gt; is just the abbreviation being defined. An &lt;code&gt;offset&lt;/code&gt; is an integer giving the equivalent offset in seconds from UTC, positive being east from Greenwich and negative being west. For example, -18000 would be five hours west of Greenwich, or North American east coast standard time. &lt;code&gt;D&lt;/code&gt; indicates that the zone name represents local daylight-savings time rather than standard time.</source>
          <target state="translated">&lt;code&gt;zone_abbreviation&lt;/code&gt; は定義されているだけの略語です。 &lt;code&gt;offset&lt;/code&gt; は、UTCからの秒単位のオフセットを表す整数で、正はグリニッジから東、負は西です。たとえば、-18000はグリニッジの西5時間、つまり北アメリカの東海岸標準時です。 &lt;code&gt;D&lt;/code&gt; は、ゾーン名が標準時間ではなくローカルの夏時間を表すことを示します。</target>
        </trans-unit>
        <trans-unit id="f4943bcbca867f42994cb13fee08c8f711efae46" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.22&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="translated">&lt;em&gt;後方参照&lt;/em&gt;（ &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; は）数で指定された前回の括弧部分式にマッチしたものと同じ文字列と一致する &lt;code&gt;n&lt;/code&gt; 個の（参照&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;表9.22を&lt;/a&gt;）。たとえば、 &lt;code&gt;([bc])\1&lt;/code&gt; &lt;code&gt;bb&lt;/code&gt; または &lt;code&gt;cc&lt;/code&gt; に一致しますが、 &lt;code&gt;bc&lt;/code&gt; または &lt;code&gt;cb&lt;/code&gt; には一致しません。部分式は、RE内の後方参照よりも完全に先行する必要があります。部分式は、先頭の括弧の順に番号が付けられます。非キャプチャ括弧は副次式を定義しません。</target>
        </trans-unit>
        <trans-unit id="0a817aa5725f2f76fa3ba34527c18e8ded1f121f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="translated">A &lt;em&gt;back reference&lt;/em&gt; ( &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt; . The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</target>
        </trans-unit>
        <trans-unit id="6718ca8fb4d919393e897bdec5fb4459615fdc4d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bracket expression&lt;/em&gt; is a list of characters enclosed in &lt;code&gt;[]&lt;/code&gt;. It normally matches any single character from the list (but see below). If the list begins with &lt;code&gt;^&lt;/code&gt;, it matches any single character &lt;em&gt;not&lt;/em&gt; from the rest of the list. If two characters in the list are separated by &lt;code&gt;-&lt;/code&gt;, this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g., &lt;code&gt;[0-9]&lt;/code&gt; in ASCII matches any decimal digit. It is illegal for two ranges to share an endpoint, e.g., &lt;code&gt;a-c-e&lt;/code&gt;. Ranges are very collating-sequence-dependent, so portable programs should avoid relying on them.</source>
          <target state="translated">大&lt;em&gt;括弧式&lt;/em&gt;は、 &lt;code&gt;[]&lt;/code&gt; で囲まれた文字のリストです。通常、リスト内の任意の1文字と一致します（ただし、以下を参照）。リストが始まる場合 &lt;code&gt;^&lt;/code&gt; 、それは任意の1文字と一致し&lt;em&gt;ていない&lt;/em&gt;リストの残りの部分から。リスト内の2つの文字が &lt;code&gt;-&lt;/code&gt; で区切られている場合、これは照合シーケンス内の2つの文字（両端を含む）の間のすべての文字の省略形です。たとえば、ASCIIの &lt;code&gt;[0-9]&lt;/code&gt; は任意の10進数と一致します。 2つの範囲が &lt;code&gt;a-c-e&lt;/code&gt; エンドポイントを共有することは違法です。範囲は照合順序に非常に依存するため、移植可能なプログラムは範囲に依存しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="e492c903d1ba7fa2a18a8ea616f7ebd7783cffa9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;composite type&lt;/em&gt; represents the structure of a row or record; it is essentially just a list of field names and their data types. PostgreSQL allows composite types to be used in many of the same ways that simple types can be used. For example, a column of a table can be declared to be of a composite type.</source>
          <target state="translated">&lt;em&gt;複合タイプは、&lt;/em&gt;行またはレコードの構造を表します。基本的には、フィールド名とそのデータ型のリストにすぎません。PostgreSQLでは、単純型を使用できるのと同じ方法の多くで複合型を使用できます。たとえば、テーブルの列を複合型として宣言できます。</target>
        </trans-unit>
        <trans-unit id="6e860f367bba9069717fd9b941470c654d2b4f8d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;制約エスケープは&lt;/em&gt;エスケープとして書き込まれ、特定の条件が満たされた場合は、空の文字列を、一致する制約です。それらを&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.21に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="1d0f2ee8729573804e315b4c91c82a2c28f8ca2d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="translated">A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="39ce7ea4252d54e37a3de7de04c14f271d76b823" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;; some more constraints are described later.</source>
          <target state="translated">&lt;em&gt;制約は、&lt;/em&gt;空の文字列にマッチしますが、特定の条件が満たされた場合にのみ一致します。制約は、量指定子が後に続かない場合を除いて、アトムを使用できる場所で使用できます。単純な制約を&lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;表9.18に&lt;/a&gt;示します。いくつかの制約については後で説明します。</target>
        </trans-unit>
        <trans-unit id="41327cfa5680423eea0edd7f46f2cf61b64b967b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.19&lt;/a&gt;; some more constraints are described later.</source>
          <target state="translated">A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.19&lt;/a&gt;; some more constraints are described later.</target>
        </trans-unit>
        <trans-unit id="82adef88e441ec735dafa62739629a93a7d0b236" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;document&lt;/em&gt; is the unit of searching in a full text search system; for example, a magazine article or email message. The text search engine must be able to parse documents and store associations of lexemes (key words) with their parent document. Later, these associations are used to search for documents that contain query words.</source>
          <target state="translated">&lt;em&gt;文書は、&lt;/em&gt;全文検索システムで検索の単位です。たとえば、雑誌の記事やメールメッセージなどです。テキスト検索エンジンは、ドキュメントを解析し、語彙素（キーワード）とその親ドキュメントとの関連付けを保存できる必要があります。その後、これらの関連付けを使用して、クエリワードを含むドキュメントを検索します。</target>
        </trans-unit>
        <trans-unit id="d539733e585980e704da973d01ffd68041e9bbe5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;domain&lt;/em&gt; is a user-defined data type that is based on another &lt;em&gt;underlying type&lt;/em&gt;. Optionally, it can have constraints that restrict its valid values to a subset of what the underlying type would allow. Otherwise it behaves like the underlying type &amp;mdash; for example, any operator or function that can be applied to the underlying type will work on the domain type. The underlying type can be any built-in or user-defined base type, enum type, array type, composite type, range type, or another domain.</source>
          <target state="translated">&lt;em&gt;ドメインは&lt;/em&gt;、別に基づいて、ユーザ定義のデータ型である&lt;em&gt;基底型&lt;/em&gt;。必要に応じて、有効な値を、基になる型で許可されるもののサブセットに制限する制約を設定できます。それ以外の場合は、基になる型のように動作します。たとえば、基になる型に適用できる演算子または関数は、ドメイン型で機能します。基本となる型は、組み込みまたはユーザー定義の基本型、列挙型、配列型、複合型、範囲型、または別のドメインです。</target>
        </trans-unit>
        <trans-unit id="c13def52e60f456d21c22d940b5598ad3aba92f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path cannot exceed 65535 labels.</source>
          <target state="translated">A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt; , representing a path from the root of a hierarchical tree to a particular node. The length of a label path cannot exceed 65535 labels.</target>
        </trans-unit>
        <trans-unit id="3e800c3197134211f2433e1a5e7b9939eb18274d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path must be less than 65kB, but keeping it under 2kB is preferable.</source>
          <target state="translated">&lt;em&gt;ラベルパスは、&lt;/em&gt;ゼロ以上のラベルのシーケンスは、例えば、ドットで区切られ &lt;code&gt;L1.L2.L3&lt;/code&gt; 特定のノードに階層ツリーのルートからのパスを表します。ラベルパスの長さは65kB未満である必要がありますが、2kB未満に保つことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b787370839fd1f05141e9721dfa970b29907a8f6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 bytes long.</source>
          <target state="translated">&lt;em&gt;ラベルは、&lt;/em&gt;（例えば、C内の文字ロケール英数字および下線の配列であり、 &lt;code&gt;A-Za-z0-9_&lt;/code&gt; 許可されている）を。ラベルは256バイト未満でなければなりません。</target>
        </trans-unit>
        <trans-unit id="599ffa36e210ea0adb3274124904be22bf966667" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 characters long.</source>
          <target state="translated">A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 characters long.</target>
        </trans-unit>
        <trans-unit id="53ce2d4eb014bcb723a4d1641a42edaac349db30" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;partial index&lt;/em&gt; is an index built over a subset of a table; the subset is defined by a conditional expression (called the &lt;em&gt;predicate&lt;/em&gt; of the partial index). The index contains entries only for those table rows that satisfy the predicate. Partial indexes are a specialized feature, but there are several situations in which they are useful.</source>
          <target state="translated">&lt;em&gt;部分インデックスは、&lt;/em&gt;テーブルの部分集合に構築された指標です。サブセットは条件式（部分インデックスの&lt;em&gt;述語&lt;/em&gt;と呼ばれる）によって定義されます。インデックスには、述語を満たすテーブル行のエントリのみが含まれます。部分インデックスは特殊な機能ですが、役立つ状況がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="17789413b2495753606375a6dc95de535511eb7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;publication&lt;/em&gt; can be defined on any physical replication master. The node where a publication is defined is referred to as &lt;em&gt;publisher&lt;/em&gt;. A publication is a set of changes generated from a table or a group of tables, and might also be described as a change set or replication set. Each publication exists in only one database.</source>
          <target state="translated">&lt;em&gt;出版物は、&lt;/em&gt;任意の物理的なレプリケーションマスタに定義することができます。パブリケーションが定義されているノードは、&lt;em&gt;パブリッシャー&lt;/em&gt;と呼ば&lt;em&gt;れ&lt;/em&gt;ます。パブリケーションは、テーブルまたはテーブルのグループから生成された一連の変更であり、変更セットまたはレプリケーションセットと呼ばれることもあります。各パブリケーションは1つのデータベースにのみ存在します。</target>
        </trans-unit>
        <trans-unit id="bad628aabb95be8473994dba34d6d8a1a5004186" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subscription&lt;/em&gt; is the downstream side of logical replication. The node where a subscription is defined is referred to as the &lt;em&gt;subscriber&lt;/em&gt;. A subscription defines the connection to another database and set of publications (one or more) to which it wants to subscribe.</source>
          <target state="translated">&lt;em&gt;サブスクリプションは、&lt;/em&gt;論理的なレプリケーションの下流側です。サブスクリプションが定義されているノードは、サブ&lt;em&gt;スクライバー&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。サブスクリプションは、サブスクライブする別のデータベースおよびパブリケーションのセット（1つ以上）への接続を定義します。</target>
        </trans-unit>
        <trans-unit id="fa797af3b3f4fb2b2ac87bf17e6b99f0b17a6828" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;table expression&lt;/em&gt; computes a table. The table expression contains a &lt;code&gt;FROM&lt;/code&gt; clause that is optionally followed by &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses. Trivial table expressions simply refer to a table on disk, a so-called base table, but more complex expressions can be used to modify or combine base tables in various ways.</source>
          <target state="translated">&lt;em&gt;テーブル式は、&lt;/em&gt;テーブルを計算します。テーブル式には &lt;code&gt;FROM&lt;/code&gt; 句が含まれ、その後にオプションで &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句が続きます。単純なテーブル式は、ディスク上のテーブル、いわゆるベーステーブルを単に参照しますが、より複雑な式を使用して、ベーステーブルをさまざまな方法で変更または組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="2fefdb2ebab2d34cbdb1f2805b62ff07fe84dbed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function call&lt;/em&gt; represents the application of an aggregate-like function over some portion of the rows selected by a query. Unlike non-window aggregate calls, this is not tied to grouping of the selected rows into a single output row &amp;mdash; each row remains separate in the query output. However the window function has access to all the rows that would be part of the current row's group according to the grouping specification (&lt;code&gt;PARTITION BY&lt;/code&gt; list) of the window function call. The syntax of a window function call is one of the following:</source>
          <target state="translated">&lt;em&gt;ウィンドウ関数呼び出しは、&lt;/em&gt;クエリによって選択された行のいくつかの部分の上に集約ような関数の適用を表します。ウィンドウ以外の集約呼び出しとは異なり、これは、選択された行を単一の出力行にグループ化することとは関係がありません。各行はクエリ出力で別々のままです。ただし、ウィンドウ関数は、ウィンドウ関数呼び出しのグループ化仕様（ &lt;code&gt;PARTITION BY&lt;/code&gt; リスト）に従って、現在の行のグループの一部となるすべての行にアクセスできます。ウィンドウ関数呼び出しの構文は、次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="387625f992bcdbcffbfd0633e6c6c1c4ef1ce98e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function&lt;/em&gt; performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. However, window functions do not cause rows to become grouped into a single output row like non-window aggregate calls would. Instead, the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.</source>
          <target state="translated">&lt;em&gt;窓関数は、&lt;/em&gt;何らかの形で、現在の行に関連するテーブルの行のセットにわたって計算を行います。これは、集約関数を使用して実行できる計算のタイプに相当します。ただし、ウィンドウ関数では、ウィンドウ以外の集約呼び出しのように、行が単一の出力行にグループ化されることはありません。代わりに、行は個別のIDを保持します。背後では、ウィンドウ関数はクエリ結果の現在の行以外にもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1e933097e94c165163135c375f18dec5b954f260" translate="yes" xml:space="preserve">
          <source>A Bloom filter is a space-efficient data structure that is used to test whether an element is a member of a set. In the case of an index access method, it allows fast exclusion of non-matching tuples via signatures whose size is determined at index creation.</source>
          <target state="translated">ブルームフィルタは、ある要素が集合のメンバーであるかどうかをテストするために使用される、空間効率の高いデータ構造である。インデックスアクセス方式の場合、インデックス作成時にサイズが決定されるシグネチャを介して、一致しないタプルを高速に除外することができます。</target>
        </trans-unit>
        <trans-unit id="7133145b9a1efb20311e9b66542c47e33e3b0d76" translate="yes" xml:space="preserve">
          <source>A Boolean expression that determines whether the trigger function will actually be executed. If &lt;code&gt;WHEN&lt;/code&gt; is specified, the function will only be called if the &lt;code&gt;condition&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. In &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers, the &lt;code&gt;WHEN&lt;/code&gt; condition can refer to columns of the old and/or new row values by writing &lt;code&gt;OLD.column_name&lt;/code&gt; or &lt;code&gt;NEW.column_name&lt;/code&gt; respectively. Of course, &lt;code&gt;INSERT&lt;/code&gt; triggers cannot refer to &lt;code&gt;OLD&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; triggers cannot refer to &lt;code&gt;NEW&lt;/code&gt;.</source>
          <target state="translated">トリガー関数が実際に実行されるかどうかを決定するブール式。場合 &lt;code&gt;WHEN&lt;/code&gt; 指定されている場合、機能にのみ呼び出されます &lt;code&gt;condition&lt;/code&gt; 返されます &lt;code&gt;true&lt;/code&gt; 。では &lt;code&gt;FOR EACH ROW&lt;/code&gt; トリガ、 &lt;code&gt;WHEN&lt;/code&gt; 条件を書き込むことにより、古いおよび/または新しい行の値の列を参照することができます &lt;code&gt;OLD.column_name&lt;/code&gt; または &lt;code&gt;NEW.column_name&lt;/code&gt; をそれぞれ。もちろん、 &lt;code&gt;INSERT&lt;/code&gt; トリガーは &lt;code&gt;OLD&lt;/code&gt; を参照できず、 &lt;code&gt;DELETE&lt;/code&gt; トリガーは &lt;code&gt;NEW&lt;/code&gt; を参照できません。</target>
        </trans-unit>
        <trans-unit id="f47409118dd85d31d6d901173cd234a285d215a5" translate="yes" xml:space="preserve">
          <source>A GIN index stores a set of (key, posting list) pairs, where a &lt;em&gt;posting list&lt;/em&gt; is a set of row IDs in which the key occurs. The same row ID can appear in multiple posting lists, since an item can contain more than one key. Each key value is stored only once, so a GIN index is very compact for cases where the same key appears many times.</source>
          <target state="translated">GINインデックスは、（キー、ポスティングリスト）ペアのセットを格納します。&lt;em&gt;ポスティングリスト&lt;/em&gt;は、キーが発生する行IDのセットです。アイテムには複数のキーを含めることができるため、同じ行IDが複数の投稿リストに表示される可能性があります。各キー値は1回だけ格納されるため、GINインデックスは同じキーが何度も出現する場合に非常にコンパクトです。</target>
        </trans-unit>
        <trans-unit id="77d714896b96774f11d4e02f2da31afcf21ba9b4" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e. use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="translated">GiSTインデックスでカバーすることができます。つまり、 &lt;code&gt;INCLUDE&lt;/code&gt; 句を使用します。含まれる列は、GiST演算子クラスなしでデータ型を持つことができます。含まれる属性は圧縮されずに保存されます。</target>
        </trans-unit>
        <trans-unit id="efe49aa51c5c238e7d22d9c414bebd48d8a0f792" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e., use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="translated">A GiST index can be covering, i.e., use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</target>
        </trans-unit>
        <trans-unit id="686f7293e72b8ed4fbfb23d13f584165b259d7cc" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct.</source>
          <target state="translated">GiSTインデックスは&lt;em&gt;非可逆&lt;/em&gt;的です。つまり、インデックスは誤った一致を生成する可能性があり、そのような誤った一致を排除するために実際のテーブル行を確認する必要があります。 （PostgreSQLは必要に応じてこれを自動的に行います。）GiSTインデックスは、各ドキュメントが固定長の署名によってインデックスで表されるため、損失があります。署名は、各ワードをnビット文字列の単一ビットにハッシュすることによって生成され、これらのすべてのビットがORで結合されて、nビットのドキュメント署名が生成されます。 2つの単語が同じビット位置にハッシュすると、誤った一致が発生します。クエリ内のすべての単語に一致（実数または偽）がある場合は、テーブル行を取得して、一致が正しいかどうかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="19939a4fce59080d1c44ab5da5d78d68dd79f01b" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature length in bytes is determined by the value of the optional integer parameter &lt;code&gt;siglen&lt;/code&gt;. The default signature length (when &lt;code&gt;siglen&lt;/code&gt; is not specified) is 124 bytes, the maximum signature length is 2024 bytes. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct. Longer signatures lead to a more precise search (scanning a smaller fraction of the index and fewer heap pages), at the cost of a larger index.</source>
          <target state="translated">A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature length in bytes is determined by the value of the optional integer parameter &lt;code&gt;siglen&lt;/code&gt; . The default signature length (when &lt;code&gt;siglen&lt;/code&gt; is not specified) is 124 bytes, the maximum signature length is 2024 bytes. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct. Longer signatures lead to a more precise search (scanning a smaller fraction of the index and fewer heap pages), at the cost of a larger index.</target>
        </trans-unit>
        <trans-unit id="4859377c56a7f4250fc7928febe82211450cf591" translate="yes" xml:space="preserve">
          <source>A GiST or SP-GiST index can accelerate queries involving these range operators: &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;-|-&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; (see &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;Table 9.53&lt;/a&gt; for more information).</source>
          <target state="translated">GiSTまたはSP-GiSTインデックスを使用すると、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;@&lt;/code&gt; 、 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;-|-&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; の範囲演算子を含むクエリを高速化できます（詳細については、&lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;表9.53&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="5052f6936540d438e9a8f74a835240911affa68e" translate="yes" xml:space="preserve">
          <source>A JIT provider is loaded by dynamically loading the named shared library. The normal library search path is used to locate the library. To provide the required JIT provider callbacks and to indicate that the library is actually a JIT provider, it needs to provide a C function named &lt;code&gt;_PG_jit_provider_init&lt;/code&gt;. This function is passed a struct that needs to be filled with the callback function pointers for individual actions:</source>
          <target state="translated">JITプロバイダーは、名前付き共有ライブラリーを動的にロードすることによってロードされます。ライブラリの検索には、通常のライブラリ検索パスが使用されます。必要なJITプロバイダーのコールバックを提供し、ライブラリが実際にJITプロバイダーであることを示すには、 &lt;code&gt;_PG_jit_provider_init&lt;/code&gt; という名前のC関数を提供する必要があります。この関数には、個々のアクションのコールバック関数ポインターを入力する必要がある構造体が渡されます。</target>
        </trans-unit>
        <trans-unit id="f096d1aabaef04fadfbfc0905d4cc493f3ce419f" translate="yes" xml:space="preserve">
          <source>A JSON null value is converted to a SQL null in all cases.</source>
          <target state="translated">JSONのヌル値は、すべての場合にSQLのヌル値に変換されます。</target>
        </trans-unit>
        <trans-unit id="989ddd2bcb5960954e9e78a9c33e2efbc341a60e" translate="yes" xml:space="preserve">
          <source>A POSIX time zone specification has the form</source>
          <target state="translated">POSIXタイムゾーンの指定は</target>
        </trans-unit>
        <trans-unit id="90da68c2f0311ac40f24046e1fc30e1392f07dc8" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Roles and a few other object types are shared across the entire cluster. A client connection to the server can only access data in a single database, the one specified in the connection request.</source>
          <target state="translated">PostgreSQLデータベースクラスタは、1つまたは複数の名前付きデータベースを含んでいます。ロールと他のいくつかのオブジェクト型はクラスタ全体で共有されています。サーバへのクライアント接続は、接続要求で指定された単一のデータベースのデータのみにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c15132a79db70b0e2b3cdb81cbd574f378944491" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Users and groups of users are shared across the entire cluster, but no other data is shared across databases. Any given client connection to the server can access only the data in a single database, the one specified in the connection request.</source>
          <target state="translated">PostgreSQLデータベースクラスタは、1つまたは複数の名前付きデータベースを含んでいます。ユーザとユーザグループはクラスタ全体で共有されますが、他のデータはデータベース間で共有されません。サーバへの任意のクライアント接続は、接続要求で指定された単一のデータベースのデータのみにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="9d33772a25bf4dd8b6ca0ae7bbd6d891d7102d71" translate="yes" xml:space="preserve">
          <source>A Snowball dictionary recognizes everything, whether or not it is able to simplify the word, so it should be placed at the end of the dictionary list. It is useless to have it before any other dictionary because a token will never pass through it to the next dictionary.</source>
          <target state="translated">雪だるま式辞書は、単語を簡略化できるかどうかは別として、すべてを認識しているので、辞書リストの最後に置くべきです。トークンが次の辞書に通らなくなるので、他の辞書の前に置いても意味がありません。</target>
        </trans-unit>
        <trans-unit id="72bd8340532262887cb9ae14aa89845f88df9078" translate="yes" xml:space="preserve">
          <source>A UUID is written as a sequence of lower-case hexadecimal digits, in several groups separated by hyphens, specifically a group of 8 digits followed by three groups of 4 digits followed by a group of 12 digits, for a total of 32 digits representing the 128 bits. An example of a UUID in this standard form is:</source>
          <target state="translated">UUIDは、ハイフンで区切られたいくつかのグループに分かれた小文字の16進数の数字のシーケンスとして記述され、具体的には8桁のグループと4桁のグループが3つ、12桁のグループが3つ、合計32桁で128ビットを表します。この標準形式のUUIDの例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="99a2ddaed13b4fa5189155f796c23cd0b85b2037" translate="yes" xml:space="preserve">
          <source>A bare &lt;code&gt;VALUES&lt;/code&gt; command:</source>
          <target state="translated">裸の &lt;code&gt;VALUES&lt;/code&gt; コマンド：</target>
        </trans-unit>
        <trans-unit id="d1c75bcd54e5d624eb16ebfaf6893165bef4c000" translate="yes" xml:space="preserve">
          <source>A better approach is to send the server's stderr output to some type of log rotation program. There is a built-in log rotation facility, which you can use by setting the configuration parameter &lt;code&gt;logging_collector&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The control parameters for this program are described in &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;. You can also use this approach to capture the log data in machine readable CSV (comma-separated values) format.</source>
          <target state="translated">より良い方法は、サーバーのstderr出力をある種のログローテーションプログラムに送信することです。組み込みのログローテーション機能があり、 &lt;code&gt;postgresql.conf&lt;/code&gt; で構成パラメーター &lt;code&gt;logging_collector&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定して使用できます。このプログラムの制御パラメータについては、&lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;19.8.1項を参照してください&lt;/a&gt;。このアプローチを使用して、ログデータを機械で読み取り可能なCSV（カンマ区切り値）形式でキャプチャすることもできます。</target>
        </trans-unit>
        <trans-unit id="ebc700417ea8062cbc2133cca40c230572b19efd" translate="yes" xml:space="preserve">
          <source>A better solution is this:</source>
          <target state="translated">より良い解決策はこれです。</target>
        </trans-unit>
        <trans-unit id="6b5297ccac9bf406cd190777b88e363b006c5135" translate="yes" xml:space="preserve">
          <source>A binary string is a sequence of octets (or bytes). Binary strings are distinguished from character strings in two ways. First, binary strings specifically allow storing octets of value zero and other &amp;ldquo;non-printable&amp;rdquo; octets (usually, octets outside the decimal range 32 to 126). Character strings disallow zero octets, and also disallow any other octet values and sequences of octet values that are invalid according to the database's selected character set encoding. Second, operations on binary strings process the actual bytes, whereas the processing of character strings depends on locale settings. In short, binary strings are appropriate for storing data that the programmer thinks of as &amp;ldquo;raw bytes&amp;rdquo;, whereas character strings are appropriate for storing text.</source>
          <target state="translated">バイナリ文字列は、オクテット（またはバイト）のシーケンスです。バイナリ文字列は、2つの方法で文字列と区別されます。第1に、バイナリ文字列では、値がゼロのオクテットと他の「印刷不可能な」オクテット（通常、10進数の範囲32〜126の範囲外のオクテット）を格納できます。文字列はゼロオクテットを許可しません。また、データベースで選択された文字セットエンコーディングに従って無効な他のオクテット値とオクテット値のシーケンスも許可しません。次に、バイナリ文字列の操作は実際のバイトを処理しますが、文字列の処理はロケール設定に依存します。つまり、バイナリ文字列は、プログラマが「生のバイト」と考えるデータを格納するのに適していますが、文字列はテキストを格納するのに適しています。</target>
        </trans-unit>
        <trans-unit id="f9eaea7144ed65ec693bd5b0921667ccf802b3ac" translate="yes" xml:space="preserve">
          <source>A bit string value requires 1 byte for each group of 8 bits, plus 5 or 8 bytes overhead depending on the length of the string (but long values may be compressed or moved out-of-line, as explained in &lt;a href=&quot;datatype-character&quot;&gt;Section 8.3&lt;/a&gt; for character strings).</source>
          <target state="translated">ビット文字列値には、8ビットのグループごとに1バイト、さらに文字列の長さに応じて5バイトまたは8バイトのオーバーヘッドが必要です（ただし、文字列の&lt;a href=&quot;datatype-character&quot;&gt;セクション8.3&lt;/a&gt;で説明されているように、長い値は圧縮または行外に移動する場合があります。 ）。</target>
        </trans-unit>
        <trans-unit id="731f4887b94e6b2c73ac23722091bfbfd646df88" translate="yes" xml:space="preserve">
          <source>A bracket expression &lt;code&gt;[...]&lt;/code&gt; specifies a character class, just as in POSIX regular expressions.</source>
          <target state="translated">ブラケット式 &lt;code&gt;[...]&lt;/code&gt; は、POSIX正規表現と同様に、文字クラスを指定します。</target>
        </trans-unit>
        <trans-unit id="accb592fdd062757612f62053a65bd65ef084e6d" translate="yes" xml:space="preserve">
          <source>A branch &amp;mdash; that is, an RE that has no top-level &lt;code&gt;|&lt;/code&gt; operator &amp;mdash; has the same greediness as the first quantified atom in it that has a greediness attribute.</source>
          <target state="translated">ブランチ&amp;mdash;つまり、トップレベルがないRE &lt;code&gt;|&lt;/code&gt; 演算子&amp;mdash;貪欲属性を持つその中の最初の定量化された原子と同じ貪欲を持っています。</target>
        </trans-unit>
        <trans-unit id="1e93e1b748baa49f966038b6b801bfe31bf0d6a1" translate="yes" xml:space="preserve">
          <source>A branch is zero or more &lt;em&gt;quantified atoms&lt;/em&gt; or &lt;em&gt;constraints&lt;/em&gt;, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string.</source>
          <target state="translated">ブランチは、0個以上の&lt;em&gt;数量化されたアトム&lt;/em&gt;または&lt;em&gt;制約であり&lt;/em&gt;、連結されます。最初の一致に一致し、2番目の一致が続く、など。空のブランチは空の文字列と一致します。</target>
        </trans-unit>
        <trans-unit id="2afc09a0dce3701a8ab0f81442e2374a5fdfb59a" translate="yes" xml:space="preserve">
          <source>A brief description of the parameter</source>
          <target state="translated">パラメータの簡単な説明</target>
        </trans-unit>
        <trans-unit id="531e171813e0ccf35b132f56c05f84b2c29d4251" translate="yes" xml:space="preserve">
          <source>A brief example of using the extension follows.</source>
          <target state="translated">拡張子の使用例を簡単に説明すると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="98ac6e951a01b0cf91beea39451931792f189912" translate="yes" xml:space="preserve">
          <source>A call &lt;code&gt;foo(10)&lt;/code&gt; will fail due to the ambiguity about which function should be called.</source>
          <target state="translated">どの関数を呼び出すかについてのあいまいさが原因で、 &lt;code&gt;foo(10)&lt;/code&gt; の呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="f4fd0d041b9fc5d4d7e64ce01b658bcce1a5ce19" translate="yes" xml:space="preserve">
          <source>A cascading standby sends not only WAL records received from the master but also those restored from the archive. So even if the replication connection in some upstream connection is terminated, streaming replication continues downstream for as long as new WAL records are available.</source>
          <target state="translated">カスケードスタンバイは、マスターから受信したWALレコードだけでなく、アーカイブから復元されたWALレコードも送信します。そのため、どこかのアップストリーム接続のレプリケーション接続が終了しても、新しいWALレコードが利用可能な限り、ストリーミングレプリケーションはダウンストリームで継続されます。</target>
        </trans-unit>
        <trans-unit id="8b122451af392bc569e4090bc6ac8841aa8dd655" translate="yes" xml:space="preserve">
          <source>A case similar to filter conditions occurs with &amp;ldquo;lossy&amp;rdquo; index scans. For example, consider this search for polygons containing a specific point:</source>
          <target state="translated">フィルター条件に似たケースが「不可逆」なインデックススキャンで発生します。たとえば、特定のポイントを含むポリゴンの次の検索について考えます。</target>
        </trans-unit>
        <trans-unit id="1483859001ccf841f9287a26876bc89e5ac64726" translate="yes" xml:space="preserve">
          <source>A cast to or from a domain type currently has no effect. Casting to or from a domain uses the casts associated with its underlying type.</source>
          <target state="translated">ドメインタイプへの、またはドメインタイプからのキャストは、現在のところ何の効果もありません。ドメインへのキャスト、またはドメインからのキャストは、その基礎となるタイプに関連付けられたキャストを使用します。</target>
        </trans-unit>
        <trans-unit id="ee03111f55078d640fb1865535e64f9dbf42c86a" translate="yes" xml:space="preserve">
          <source>A catalog row appearing in the initial data can be given a manually-assigned OID by writing an &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; metadata field. Furthermore, if an OID is assigned, a C macro for that OID can be created by writing an &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; metadata field.</source>
          <target state="translated">初期データに表示されるカタログ行には、 &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; メタデータフィールドを書き込むことにより、手動で割り当てられたOIDを与えることができます。さらに、OIDが割り当てられている場合、 &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; メタデータフィールドを記述することにより、そのOIDのCマクロを作成できます。</target>
        </trans-unit>
        <trans-unit id="322518448cbeae5586806e5aaaa6dbbaaee252c8" translate="yes" xml:space="preserve">
          <source>A change in collation definitions can lead to corrupt indexes and other problems because the database system relies on stored objects having a certain sort order. Generally, this should be avoided, but it can happen in legitimate circumstances, such as when using &lt;code&gt;pg_upgrade&lt;/code&gt; to upgrade to server binaries linked with a newer version of ICU. When this happens, all objects depending on the collation should be rebuilt, for example, using &lt;code&gt;REINDEX&lt;/code&gt;. When that is done, the collation version can be refreshed using the command &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt;. This will update the system catalog to record the current collator version and will make the warning go away. Note that this does not actually check whether all affected objects have been rebuilt correctly.</source>
          <target state="translated">データベースシステムは特定のソート順を持つ格納されたオブジェクトに依存しているため、照合定義の変更はインデックスの破損やその他の問題を引き起こす可能性があります。通常、これは回避する必要がありますが、 &lt;code&gt;pg_upgrade&lt;/code&gt; を使用して新しいバージョンのICUにリンクされたサーバーバイナリにアップグレードする場合など、正当な状況で発生する可能性があります。これが発生した場合、照合に依存するすべてのオブジェクトを、たとえば &lt;code&gt;REINDEX&lt;/code&gt; を使用して再構築する必要があります。これが完了すると、コマンド &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt; を使用して、照合バージョンを更新できます。これにより、システムカタログが更新され、現在の照合バージョンが記録され、警告が表示されなくなります。これは、影響を受けるすべてのオブジェクトが正しく再構築されたかどうかを実際にチェックするわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1f4a0879a18199d5f077ec0ff2e180faddd77063" translate="yes" xml:space="preserve">
          <source>A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price:</source>
          <target state="translated">チェック制約は、複数の列を参照することもできます。通常価格と割引価格を格納し、割引価格が通常価格よりも低いことを確認したいとします。</target>
        </trans-unit>
        <trans-unit id="5fb12afa94e8bc72660d65f619fede9431dd8e90" translate="yes" xml:space="preserve">
          <source>A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:</source>
          <target state="translated">チェック制約は、最も一般的な制約タイプです。これにより、特定の列の値がブール値(真理値)式を満たす必要があることを指定することができます。例えば、正の製品価格を要求するには、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="d9805d0aa6ddc05f9bc01627befe8b2b8532cb45" translate="yes" xml:space="preserve">
          <source>A checkpoint is a point in the write-ahead log sequence at which all data files have been updated to reflect the information in the log. All data files will be flushed to disk. Refer to &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt; for more details about what happens during a checkpoint.</source>
          <target state="translated">チェックポイントは、ログ内の情報を反映するためにすべてのデータファイルが更新された先読みログシーケンスのポイントです。すべてのデータファイルがディスクにフラッシュされます。チェックポイント中に何が起こるかについての詳細は&lt;a href=&quot;wal-configuration&quot;&gt;項29.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1a7d37eff183865f5e0589720c997a7480356b5f" translate="yes" xml:space="preserve">
          <source>A checkpoint is also the act of carrying out all the actions that are necessary to reach a checkpoint as defined above. This process is initiated when predefined conditions are met, such as a specified amount of time has passed, or a certain volume of records has been written; or it can be invoked by the user with the command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">A checkpoint is also the act of carrying out all the actions that are necessary to reach a checkpoint as defined above. This process is initiated when predefined conditions are met, such as a specified amount of time has passed, or a certain volume of records has been written; or it can be invoked by the user with the command &lt;code&gt;CHECKPOINT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e10395ea67c519738bcfedd97fec8b7a98e77981" translate="yes" xml:space="preserve">
          <source>A clause of the form</source>
          <target state="translated">形式の句</target>
        </trans-unit>
        <trans-unit id="d3d17faa1f9b24f81d090c43c22a75e3dfd2f4a5" translate="yes" xml:space="preserve">
          <source>A clause of the form &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; is shorthand for &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt;. Also, &lt;code&gt;USING&lt;/code&gt; implies that only one of each pair of equivalent columns will be included in the join output, not both.</source>
          <target state="translated">フォームの句 &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; の短縮形である &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt; 。また、 &lt;code&gt;USING&lt;/code&gt; は、同等の列の各ペアの両方ではなく、1つだけが結合出力に含まれることを意味します。</target>
        </trans-unit>
        <trans-unit id="2d0bfde758816d57c2adc33132d231587021c551" translate="yes" xml:space="preserve">
          <source>A closely related issue that affects planning time is collapsing of subqueries into their parent query. For example, consider:</source>
          <target state="translated">計画時間に影響を与える密接に関連した問題として、サブクエリの親クエリへの折りたたみがあります。例えば、次のようなことを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ca452f51e79db640e56e4f9925aa0048af9d720d" translate="yes" xml:space="preserve">
          <source>A code defining the specific semantics of this dependency relationship; see text</source>
          <target state="translated">この依存関係の特定のセマンティクスを定義するコード。</target>
        </trans-unit>
        <trans-unit id="2ca8fb5b99b4bb7400bad4589e85235d85b8712a" translate="yes" xml:space="preserve">
          <source>A code defining the type of initial privilege of this object; see text</source>
          <target state="translated">このオブジェクトの初期特権のタイプを定義するコード。</target>
        </trans-unit>
        <trans-unit id="f7f2588e77da5e4feafd01ab8f374851f37bddfd" translate="yes" xml:space="preserve">
          <source>A code number indicating the kind of statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo; of the &lt;code&gt;pg_statistic&lt;/code&gt; row.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 行の &lt;code&gt;N&lt;/code&gt; 番目の「スロット」に格納されている統計の種類を示すコード番号。</target>
        </trans-unit>
        <trans-unit id="f423b7df9b88ecbf124e9ccab75b7d879dc4cca0" translate="yes" xml:space="preserve">
          <source>A collation expression</source>
          <target state="translated">照合式</target>
        </trans-unit>
        <trans-unit id="9c0dd05ad8edff154a8e6c9ab1b14bf3a7460e7c" translate="yes" xml:space="preserve">
          <source>A collation is an SQL schema object that maps an SQL name to locales provided by libraries installed in the operating system. A collation definition has a &lt;em&gt;provider&lt;/em&gt; that specifies which library supplies the locale data. One standard provider name is &lt;code&gt;libc&lt;/code&gt;, which uses the locales provided by the operating system C library. These are the locales that most tools provided by the operating system use. Another provider is &lt;code&gt;icu&lt;/code&gt;, which uses the external ICU library. ICU locales can only be used if support for ICU was configured when PostgreSQL was built.</source>
          <target state="translated">照合は、SQL名をオペレーティングシステムにインストールされたライブラリによって提供されるロケールにマップするSQLスキーマオブジェクトです。照合定義には、ロケールデータを提供するライブラリを指定する&lt;em&gt;プロバイダー&lt;/em&gt;があります。 1つの標準プロバイダー名は &lt;code&gt;libc&lt;/code&gt; で、オペレーティングシステムのCライブラリによって提供されるロケールを使用します。これらは、オペレーティングシステムによって提供されるほとんどのツールが使用するロケールです。別のプロバイダーは &lt;code&gt;icu&lt;/code&gt; で、外部ICUライブラリーを使用します。 ICUロケールは、PostgreSQLのビルド時にICUのサポートが構成されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fd492bf97f6c0e26453468337ad19bf874c44502" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="translated">照合順序は、&lt;em&gt;確定的&lt;/em&gt;または&lt;em&gt;非&lt;/em&gt;&lt;em&gt;確定&lt;/em&gt;&lt;em&gt;的&lt;/em&gt;です。確定的照合では確定的比較が使用されます。つまり、同じバイトシーケンスで構成されている場合にのみ文字列が等しいと見なされます。非決定的比較では、文字列が異なるバイトで構成されている場合でも、文字列が等しいと判断される場合があります。典型的な状況には、大文字と小文字を区別しない比較、アクセントを区別しない比較、およびさまざまなUnicode標準形式の文字列の比較が含まれます。このような区別されない比較を実際に実装するかどうかは、照合プロバイダー次第です。 deterministicフラグは、バイトごとの比較を使用してタイを分割するかどうかのみを決定します。用語の詳細については、&lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="585469a73deac416236caf1e82c0a86b85aed8e2" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://www.unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="translated">A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://www.unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</target>
        </trans-unit>
        <trans-unit id="9ebffe965dbfb2b402733d22f1b65d8768ef66b6" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;icu&lt;/code&gt; maps to a named collator provided by the ICU library. ICU does not support separate &amp;ldquo;collate&amp;rdquo; and &amp;ldquo;ctype&amp;rdquo; settings, so they are always the same. Also, ICU collations are independent of the encoding, so there is always only one ICU collation of a given name in a database.</source>
          <target state="translated">&lt;code&gt;icu&lt;/code&gt; によって提供される照合オブジェクトは、ICUライブラリによって提供される名前付き照合子にマップされます。 ICUは、「collat​​e」と「ctype」の個別の設定をサポートしていないため、常に同じです。また、ICU照合はエンコードとは独立しているため、データベース内の特定の名前のICU照合は常に1つしかありません。</target>
        </trans-unit>
        <trans-unit id="67e66134fe986b5a1161f010ed997e5c29515718" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;libc&lt;/code&gt; maps to a combination of &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings, as accepted by the &lt;code&gt;setlocale()&lt;/code&gt; system library call. (As the name would suggest, the main purpose of a collation is to set &lt;code&gt;LC_COLLATE&lt;/code&gt;, which controls the sort order. But it is rarely necessary in practice to have an &lt;code&gt;LC_CTYPE&lt;/code&gt; setting that is different from &lt;code&gt;LC_COLLATE&lt;/code&gt;, so it is more convenient to collect these under one concept than to create another infrastructure for setting &lt;code&gt;LC_CTYPE&lt;/code&gt; per expression.) Also, a &lt;code&gt;libc&lt;/code&gt; collation is tied to a character set encoding (see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;). The same collation name may exist for different encodings.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; によって提供される照合オブジェクトは、 &lt;code&gt;setlocale()&lt;/code&gt; システムライブラリコールによって受け入れられる &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の設定の組み合わせにマッピングされます。 （名前が示すように、照合順序の主な目的は &lt;code&gt;LC_COLLATE&lt;/code&gt; を設定することです。これはソート順を制御します。しかし、実際には &lt;code&gt;LC_COLLATE&lt;/code&gt; とは異なる &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定が必要になることはほとんどないため、これらを収集する方が便利です。式ごとに &lt;code&gt;LC_CTYPE&lt;/code&gt; を設定するための別のインフラストラクチャを作成するよりも、1つの概念の下で。）また、 &lt;code&gt;libc&lt;/code&gt; 照合は文字セットエンコーディングに関連付けられています（&lt;a href=&quot;multibyte&quot;&gt;セクション23.3&lt;/a&gt;）。同じ照合名が異なるエンコーディングに存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="dbd951bae781e6ca52e1aa0ea05378979fbabbd4" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in a fixed order. That order may be defined by the &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; (or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;) where the tuple is contained, in which case the tuple is often called a &lt;em&gt;row&lt;/em&gt;. It may also be defined by the structure of a result set, in which case it is sometimes called a &lt;em&gt;record&lt;/em&gt;.</source>
          <target state="translated">A collection of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in a fixed order. That order may be defined by the &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; (or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;) where the tuple is contained, in which case the tuple is often called a &lt;em&gt;row&lt;/em&gt;. It may also be defined by the structure of a result set, in which case it is sometimes called a &lt;em&gt;record&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="c1d02a0633df2ef26eee92135725af62089ef8cb" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; which describe the structure of all &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; of the instance. The system catalog resides in the schema &lt;code&gt;pg_catalog&lt;/code&gt;. These tables contain data in internal representation and are not typically considered useful for user examination; a number of user-friendlier &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, also in schema &lt;code&gt;pg_catalog&lt;/code&gt;, offer more convenient access to some of that information, while additional tables and views exist in schema &lt;code&gt;information_schema&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) that expose some of the same and additional information as mandated by the &lt;a href=&quot;glossary#GLOSSARY-SQL-STANDARD&quot;&gt;SQL standard&lt;/a&gt;.</source>
          <target state="translated">A collection of &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; which describe the structure of all &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; of the instance. The system catalog resides in the schema &lt;code&gt;pg_catalog&lt;/code&gt; . These tables contain data in internal representation and are not typically considered useful for user examination; a number of user-friendlier &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, also in schema &lt;code&gt;pg_catalog&lt;/code&gt; , offer more convenient access to some of that information, while additional tables and views exist in schema &lt;code&gt;information_schema&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) that expose some of the same and additional information as mandated by the &lt;a href=&quot;glossary#GLOSSARY-SQL-STANDARD&quot;&gt;SQL standard&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4b63b111cc045d92308ab6bb0ff812b8d4531fcd" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; having a common data structure (the same number of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;, in the same order, having the same name and type per position). A table is the most common form of &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; in PostgreSQL.</source>
          <target state="translated">A collection of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; having a common data structure (the same number of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;, in the same order, having the same name and type per position). A table is the most common form of &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; in PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="85e16773e18c89eb8dbf7379d075c0ed8024236a" translate="yes" xml:space="preserve">
          <source>A collection of access privileges to the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;instance&lt;/a&gt;. Roles are themselves a privilege that can be granted to other roles. This is often done for convenience or to ensure completeness when multiple &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;users&lt;/a&gt; need the same privileges.</source>
          <target state="translated">A collection of access privileges to the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;instance&lt;/a&gt;. Roles are themselves a privilege that can be granted to other roles. This is often done for convenience or to ensure completeness when multiple &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;users&lt;/a&gt; need the same privileges.</target>
        </trans-unit>
        <trans-unit id="81b0b809d9ea56c7639bef5d5e043207a72e42ff" translate="yes" xml:space="preserve">
          <source>A collection of databases and global SQL objects, and their common static and dynamic metadata. Sometimes referred to as a &lt;em&gt;cluster&lt;/em&gt;.</source>
          <target state="translated">A collection of databases and global SQL objects, and their common static and dynamic metadata. Sometimes referred to as a &lt;em&gt;cluster&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="243ac044c18a03ce7230410123ce180ce925ca61" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="translated">列にはデフォルト値を割り当てることができます。新しい行が作成され、一部の列に値が指定されていない場合、それらの列にはそれぞれのデフォルト値が入力されます。データ操作コマンドは、その値が何であるかを知らなくても、列をデフォルト値に設定することを明示的に要求することもできます。（データ操作コマンドの詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;第6章にあり&lt;/a&gt;ます。）</target>
        </trans-unit>
        <trans-unit id="728c6855211584a9477504f501bcae575c68f1dd" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="translated">A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="a303981025d3fba2a49b2d8afa067fd02f82810b" translate="yes" xml:space="preserve">
          <source>A column can be referenced in the form:</source>
          <target state="translated">カラムは、フォームで参照することができます。</target>
        </trans-unit>
        <trans-unit id="5e814702f2c68b1dd74624138092e2f2dac25d61" translate="yes" xml:space="preserve">
          <source>A column marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt; will be populated with row numbers, starting with 1, in the order of nodes retrieved from the &lt;code&gt;row_expression&lt;/code&gt;'s result node-set. At most one column may be marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FOR ORDINALITY&lt;/code&gt; とマークされた列には、 &lt;code&gt;row_expression&lt;/code&gt; の結果ノードセットから取得されたノードの順序で、1から始まる行番号が入力されます。最大1つの列に &lt;code&gt;FOR ORDINALITY&lt;/code&gt; のマークを付けることができます。</target>
        </trans-unit>
        <trans-unit id="12e0d49f86838408b879ad07c7e5231286011142" translate="yes" xml:space="preserve">
          <source>A column of a foreign table created using this wrapper can have the following options:</source>
          <target state="translated">このラッパーを用いて作成された外部テーブルのカラムは、以下のオプションを持つことができます。</target>
        </trans-unit>
        <trans-unit id="cc14af77e732b86dd798941f4129e5ffc051f3d7" translate="yes" xml:space="preserve">
          <source>A column reference</source>
          <target state="translated">列の参照</target>
        </trans-unit>
        <trans-unit id="43fad0f566cbecaf300364b0a3a7343007869d54" translate="yes" xml:space="preserve">
          <source>A column-specific trigger (one defined using the &lt;code&gt;UPDATE OF column_name&lt;/code&gt; syntax) will fire when any of its columns are listed as targets in the &lt;code&gt;UPDATE&lt;/code&gt; command's &lt;code&gt;SET&lt;/code&gt; list. It is possible for a column's value to change even when the trigger is not fired, because changes made to the row's contents by &lt;code&gt;BEFORE UPDATE&lt;/code&gt; triggers are not considered. Conversely, a command such as &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; will fire a trigger on column &lt;code&gt;x&lt;/code&gt;, even though the column's value did not change.</source>
          <target state="translated">列固有のトリガー（ &lt;code&gt;UPDATE OF column_name&lt;/code&gt; 構文を使用して定義されたトリガー）は、その列のいずれかが &lt;code&gt;UPDATE&lt;/code&gt; コマンドの &lt;code&gt;SET&lt;/code&gt; リストにターゲットとしてリストされている場合に起動します。 &lt;code&gt;BEFORE UPDATE&lt;/code&gt; トリガーによって行の内容に加えられた変更は考慮されないため、トリガーが起動されていない場合でも、列の値が変更される可能性があります。逆に、 &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; などのコマンドは、列の値が変更されていなくても、列 &lt;code&gt;x&lt;/code&gt; でトリガーを起動します。</target>
        </trans-unit>
        <trans-unit id="e7ce99ce6bf9fda66b89c10600a10dba3a88bd33" translate="yes" xml:space="preserve">
          <source>A combination of commands that must act as a single &lt;a href=&quot;glossary#GLOSSARY-ATOMIC&quot;&gt;atomic&lt;/a&gt; command: they all succeed or all fail as a single unit, and their effects are not visible to other &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;sessions&lt;/a&gt; until the transaction is complete, and possibly even later, depending on the isolation level.</source>
          <target state="translated">A combination of commands that must act as a single &lt;a href=&quot;glossary#GLOSSARY-ATOMIC&quot;&gt;atomic&lt;/a&gt; command: they all succeed or all fail as a single unit, and their effects are not visible to other &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;sessions&lt;/a&gt; until the transaction is complete, and possibly even later, depending on the isolation level.</target>
        </trans-unit>
        <trans-unit id="f697bbd81557d764888518e1af36278f9c8d3579" translate="yes" xml:space="preserve">
          <source>A combination of dynamic domain transition and trusted procedure enables an interesting use case that fits the typical process life-cycle of connection pooling software. Even if your connection pooling software is not allowed to run most of SQL commands, you can allow it to switch the security label of the client using the &lt;code&gt;sepgsql_setcon()&lt;/code&gt; function from within a trusted procedure; that should take some credential to authorize the request to switch the client label. After that, this session will have the privileges of the target user, rather than the connection pooler. The connection pooler can later revert the security label change by again using &lt;code&gt;sepgsql_setcon()&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; argument, again invoked from within a trusted procedure with appropriate permissions checks. The point here is that only the trusted procedure actually has permission to change the effective security label, and only does so when given proper credentials. Of course, for secure operation, the credential store (table, procedure definition, or whatever) must be protected from unauthorized access.</source>
          <target state="translated">動的ドメイン遷移と信頼できる手順の組み合わせにより、接続プーリングソフトウェアの一般的なプロセスライフサイクルに適合する興味深いユースケースが可能になります。接続プーリングソフトウェアがほとんどのSQLコマンドの実行を許可されていない場合でも、信頼できるプロシージャ内から &lt;code&gt;sepgsql_setcon()&lt;/code&gt; 関数を使用してクライアントのセキュリティラベルを切り替えることを許可できます。これは、クライアントラベルを切り替える要求を承認するための資格を取得する必要があります。その後、このセッションには、接続プーラーではなく、ターゲットユーザーの権限が付与されます。接続プーラーは、後で &lt;code&gt;NULL&lt;/code&gt; で &lt;code&gt;sepgsql_setcon()&lt;/code&gt; を再度使用することにより、セキュリティラベルの変更を元に戻すことができます。引数。適切な権限チェックを使用して、信頼できるプロシージャ内から再度呼び出されます。ここでのポイントは、信頼できる手順のみが実際に有効なセキュリティラベルを変更する権限を持ち、適切な資格情報が与えられた場合にのみそれを行うということです。もちろん、安全な操作のためには、資格情報ストア（テーブル、プロシージャ定義など）を不正アクセスから保護する必要があります。</target>
        </trans-unit>
        <trans-unit id="2911cc608e469494b5712a777002f2e21913d79f" translate="yes" xml:space="preserve">
          <source>A command to execute. In &lt;code&gt;COPY FROM&lt;/code&gt;, the input is read from standard output of the command, and in &lt;code&gt;COPY TO&lt;/code&gt;, the output is written to the standard input of the command.</source>
          <target state="translated">実行するコマンド。では &lt;code&gt;COPY FROM&lt;/code&gt; 、入力はコマンドの標準出力から読み出され、そして中に &lt;code&gt;COPY TO&lt;/code&gt; 、出力はコマンドの標準入力に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="b8b60faef517b04517cdc32cdeaec6d45d821a98" translate="yes" xml:space="preserve">
          <source>A command to prevent access to a named set of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; objects for a named list of &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;.</source>
          <target state="translated">A command to prevent access to a named set of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; objects for a named list of &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="432b06e57f9235552442ece4a5144f1741f08cf9" translate="yes" xml:space="preserve">
          <source>A command to undo all of the operations performed since the beginning of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">A command to undo all of the operations performed since the beginning of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dfeede7bacbce2d25ad1c8afefcc0d73e7394ef6" translate="yes" xml:space="preserve">
          <source>A comment is a sequence of characters beginning with double dashes and extending to the end of the line, e.g.:</source>
          <target state="translated">コメントとは、二重ダッシュで始まり行末まで続く文字列のことです。</target>
        </trans-unit>
        <trans-unit id="3eb6cee486403a5e9f022d4d86b027a6b1d863bd" translate="yes" xml:space="preserve">
          <source>A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace.</source>
          <target state="translated">コメントは、さらなる構文解析の前に入力ストリームから削除され、効果的に空白に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="fd4ff7f9082f219e362f6b80b3a0778be34303a7" translate="yes" xml:space="preserve">
          <source>A completely empty field value (no characters at all between the commas or parentheses) represents a NULL. To write a value that is an empty string rather than NULL, write &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">完全に空のフィールド値（コンマまたは括弧の間に文字がない）は、NULLを表します。NULLではなく空の文字列である値を書き込むには、 &lt;code&gt;&quot;&quot;&lt;/code&gt; と書き込みます。</target>
        </trans-unit>
        <trans-unit id="bc479538bc2519f6be7743a108e2d4369ba071e0" translate="yes" xml:space="preserve">
          <source>A computer on which PostgreSQL &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instances&lt;/a&gt; run. The term &lt;em&gt;server&lt;/em&gt; denotes real hardware, a container, or a &lt;em&gt;virtual machine&lt;/em&gt;.</source>
          <target state="translated">A computer on which PostgreSQL &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instances&lt;/a&gt; run. The term &lt;em&gt;server&lt;/em&gt; denotes real hardware, a container, or a &lt;em&gt;virtual machine&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="712b440e19e5b1db615da5ae01b27ee905115fec" translate="yes" xml:space="preserve">
          <source>A computer that communicates with other computers over a network. This is sometimes used as a synonym for &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt;. It is also used to refer to a computer where &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt; run.</source>
          <target state="translated">A computer that communicates with other computers over a network. This is sometimes used as a synonym for &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt;. It is also used to refer to a computer where &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt; run.</target>
        </trans-unit>
        <trans-unit id="2b2c2b765e8d46a4effd9275029b3ac9ce35557f" translate="yes" xml:space="preserve">
          <source>A concept of non-existence that is a central tenet of relational database theory. It represents the absence of a definite value.</source>
          <target state="translated">リレーショナルデータベース理論の中心的な教義である非存在の概念。確定的な値が存在しないことを表す。</target>
        </trans-unit>
        <trans-unit id="db43da6a754b048f8c15b9fee6431ce49e646a6c" translate="yes" xml:space="preserve">
          <source>A conflict will produce an error and will stop the replication; it must be resolved manually by the user. Details about the conflict can be found in the subscriber's server log.</source>
          <target state="translated">競合が発生するとエラーが発生し、レプリケーションが停止します。コンフリクトの詳細は、サブスクライバのサーバログに記載されています。</target>
        </trans-unit>
        <trans-unit id="6de61942e5889f7081d4c447f2d861f6661580c6" translate="yes" xml:space="preserve">
          <source>A connection from an application program to the PostgreSQL server has to be established. The application program transmits a query to the server and waits to receive the results sent back by the server.</source>
          <target state="translated">アプリケーションプログラムからPostgreSQLサーバへの接続を確立する必要があります。アプリケーションプログラムは、サーバに問い合わせを送信し、サーバから返送されてくる結果を待ちます。</target>
        </trans-unit>
        <trans-unit id="ff27f94049d4acbe17b6492b665c173de57c0e06" translate="yes" xml:space="preserve">
          <source>A constant of an &lt;em&gt;arbitrary&lt;/em&gt; type can be entered using any one of the following notations:</source>
          <target state="translated">&lt;em&gt;任意の&lt;/em&gt;型の定数は、次の表記のいずれかを使用して入力できます。</target>
        </trans-unit>
        <trans-unit id="def2a00f2b728102b713698dbaec6bf7d1b1ba45" translate="yes" xml:space="preserve">
          <source>A constant or expression to compute and insert at the indicated place in the resulting table (set of rows). In a &lt;code&gt;VALUES&lt;/code&gt; list appearing at the top level of an &lt;code&gt;INSERT&lt;/code&gt;, an &lt;code&gt;expression&lt;/code&gt; can be replaced by &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the destination column's default value should be inserted. &lt;code&gt;DEFAULT&lt;/code&gt; cannot be used when &lt;code&gt;VALUES&lt;/code&gt; appears in other contexts.</source>
          <target state="translated">結果のテーブル（行のセット）の指定された場所に計算して挿入する定数または式。 &lt;code&gt;INSERT&lt;/code&gt; の最上位に表示される &lt;code&gt;VALUES&lt;/code&gt; リストでは、 &lt;code&gt;expression&lt;/code&gt; を &lt;code&gt;DEFAULT&lt;/code&gt; で置き換えることにより、宛先列のデフォルト値を挿入する必要があることを示すことができます。 &lt;code&gt;VALUES&lt;/code&gt; が他のコンテキストにある場合、 &lt;code&gt;DEFAULT&lt;/code&gt; は使用できません。</target>
        </trans-unit>
        <trans-unit id="f51660594b80d9306c037e5807f00beb6e91d699" translate="yes" xml:space="preserve">
          <source>A constant or literal value</source>
          <target state="translated">定数またはリテラル値</target>
        </trans-unit>
        <trans-unit id="cf8fda03118cc7add18d0baf25c70ed12492a1c1" translate="yes" xml:space="preserve">
          <source>A constraint marked with &lt;code&gt;NO INHERIT&lt;/code&gt; will not propagate to child tables.</source>
          <target state="translated">&lt;code&gt;NO INHERIT&lt;/code&gt; でマークされた制約は、子テーブルには伝播されません。</target>
        </trans-unit>
        <trans-unit id="8913bbb8fb57baf6761a820445fb91f212ee581b" translate="yes" xml:space="preserve">
          <source>A convention often used is to write key words in upper case and names in lower case, e.g.:</source>
          <target state="translated">よく使われる慣習は、キーワードは大文字で、名前は小文字で書くことです。</target>
        </trans-unit>
        <trans-unit id="270045f32202a02af54823e311103963348c2e0e" translate="yes" xml:space="preserve">
          <source>A conversion of a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt; from its current data type to another data type.</source>
          <target state="translated">A conversion of a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt; from its current data type to another data type.</target>
        </trans-unit>
        <trans-unit id="fee55ddb20eb8d0ea230a86a3979ff4c9211fbe9" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typalign&lt;/code&gt; of this column's type</source>
          <target state="translated">この列のタイプの &lt;code&gt;pg_type.typalign&lt;/code&gt; のコピー</target>
        </trans-unit>
        <trans-unit id="16520694e80b09447c7974353ea21a94aea9b85b" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typbyval&lt;/code&gt; of this column's type</source>
          <target state="translated">この列のタイプの &lt;code&gt;pg_type.typbyval&lt;/code&gt; のコピー</target>
        </trans-unit>
        <trans-unit id="469c374912ca15a938f750a67728c2d10a7ddd2a" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typlen&lt;/code&gt; of this column's type</source>
          <target state="translated">この列のタイプの &lt;code&gt;pg_type.typlen&lt;/code&gt; のコピー</target>
        </trans-unit>
        <trans-unit id="64372429a7f7ff378ebe32047bb948215d6fc9f3" translate="yes" xml:space="preserve">
          <source>A cursor has an associated position, which is used by &lt;code&gt;FETCH&lt;/code&gt;. The cursor position can be before the first row of the query result, on any particular row of the result, or after the last row of the result. When created, a cursor is positioned before the first row. After fetching some rows, the cursor is positioned on the row most recently retrieved. If &lt;code&gt;FETCH&lt;/code&gt; runs off the end of the available rows then the cursor is left positioned after the last row, or before the first row if fetching backward. &lt;code&gt;FETCH ALL&lt;/code&gt; or &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; will always leave the cursor positioned after the last row or before the first row.</source>
          <target state="translated">カーソルには、 &lt;code&gt;FETCH&lt;/code&gt; で使用される関連位置があります。カーソル位置は、クエリ結果の最初の行の前、結果の特定の行、または結果の最後の行の後ろにすることができます。作成されると、カーソルは最初の行の前に配置されます。一部の行をフェッチした後、カーソルは最後に取得された行に配置されます。 &lt;code&gt;FETCH&lt;/code&gt; が使用可能な行の終わりを超えて実行される場合、カーソルは最後の行の後、または後方にフェッチする場合は最初の行の前に置かれたままになります。 &lt;code&gt;FETCH ALL&lt;/code&gt; または &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; を指定すると、カーソルは常に最後の行の後または最初の行の前に置かれます。</target>
        </trans-unit>
        <trans-unit id="ca84330d2df84d2fb3203c9d1abd5c728ed51c45" translate="yes" xml:space="preserve">
          <source>A custom-format dump is not a script for psql, but instead must be restored with pg_restore, for example:</source>
          <target state="translated">カスタムフォーマットのダンプはpsql用のスクリプトではなく、例えばpg_restoreでリストアする必要があります。</target>
        </trans-unit>
        <trans-unit id="ac05a9e40c0d434aa68a1851fc9e7d6d26043953" translate="yes" xml:space="preserve">
          <source>A data type &lt;code&gt;tsvector&lt;/code&gt; is provided for storing preprocessed documents, along with a type &lt;code&gt;tsquery&lt;/code&gt; for representing processed queries (&lt;a href=&quot;datatype-textsearch&quot;&gt;Section 8.11&lt;/a&gt;). There are many functions and operators available for these data types (&lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt;), the most important of which is the match operator &lt;code&gt;@@&lt;/code&gt;, which we introduce in &lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;Section 12.1.2&lt;/a&gt;. Full text searches can be accelerated using indexes (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;).</source>
          <target state="translated">前処理されたドキュメントを格納するためのデータ型 &lt;code&gt;tsvector&lt;/code&gt; が、処理されたクエリを表すための &lt;code&gt;tsquery&lt;/code&gt; 型とともに提供されます（&lt;a href=&quot;datatype-textsearch&quot;&gt;セクション8.11&lt;/a&gt;）。これらのデータ型（&lt;a href=&quot;functions-textsearch&quot;&gt;セクション9.13&lt;/a&gt;）で使用できる関数と演算子は多数ありますが、最も重要なものは、&lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;セクション12.1.2で&lt;/a&gt;紹介する一致演算子 &lt;code&gt;@@&lt;/code&gt; です。全文検索は、インデックスを使用して高速化できます（&lt;a href=&quot;textsearch-indexes&quot;&gt;セクション12.9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1c829ffd204fab8f2c9ec9a14aa40a4d117b945a" translate="yes" xml:space="preserve">
          <source>A data-only dump will still use &lt;code&gt;COPY&lt;/code&gt;, but it does not drop or recreate indexes, and it does not normally touch foreign keys. &lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt; So when loading a data-only dump, it is up to you to drop and recreate indexes and foreign keys if you wish to use those techniques. It's still useful to increase &lt;code&gt;max_wal_size&lt;/code&gt; while loading the data, but don't bother increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt;; rather, you'd do that while manually recreating indexes and foreign keys afterwards. And don't forget to &lt;code&gt;ANALYZE&lt;/code&gt; when you're done; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">データのみのダンプは引き続き &lt;code&gt;COPY&lt;/code&gt; を使用しますが、インデックスの削除や再作成は行わず、通常は外部キーに触れません。&lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt;したがって、データのみのダンプをロードするとき、これらの手法を使用したい場合は、インデックスと外部キーを削除して再作成する必要があります。データのロード中に &lt;code&gt;max_wal_size&lt;/code&gt; を増やすことは依然として役に立ちますが、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; を増やすことを気にしないでください。むしろ、後で手動でインデックスと外部キーを再作成しているときにそれを行います。そして、終わったら &lt;code&gt;ANALYZE&lt;/code&gt; することを忘れないでください。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a7efff5b8bc220045364eeb6371d5a7d0adfbf4d" translate="yes" xml:space="preserve">
          <source>A database contains one or more named &lt;em&gt;schemas&lt;/em&gt;, which in turn contain tables. Schemas also contain other kinds of named objects, including data types, functions, and operators. The same object name can be used in different schemas without conflict; for example, both &lt;code&gt;schema1&lt;/code&gt; and &lt;code&gt;myschema&lt;/code&gt; can contain tables named &lt;code&gt;mytable&lt;/code&gt;. Unlike databases, schemas are not rigidly separated: a user can access objects in any of the schemas in the database they are connected to, if they have privileges to do so.</source>
          <target state="translated">データベースには1つ以上の名前付き&lt;em&gt;スキーマ&lt;/em&gt;が含まれ、&lt;em&gt;スキーマ&lt;/em&gt;にはテーブルが含まれます。スキーマには、データ型、関数、演算子など、他の種類の名前付きオブジェクトも含まれています。同じオブジェクト名を異なるスキーマで競合なしに使用できます。たとえば、 &lt;code&gt;schema1&lt;/code&gt; と &lt;code&gt;myschema&lt;/code&gt; の両方にmytableという名前のテーブルを含めることができ &lt;code&gt;mytable&lt;/code&gt; 。データベースとは異なり、スキーマは厳密に分離されていません。ユーザーは、接続するデータベース内の任意のスキーマ内のオブジェクトにアクセスすることができます（アクセスする権限がある場合）。</target>
        </trans-unit>
        <trans-unit id="3ebb2f86492fa3a77fa0db26d0c30c86dff05744" translate="yes" xml:space="preserve">
          <source>A database is a named collection of SQL objects (&amp;ldquo;database objects&amp;rdquo;). Generally, every database object (tables, functions, etc.) belongs to one and only one database. (However there are a few system catalogs, for example &lt;code&gt;pg_database&lt;/code&gt;, that belong to a whole cluster and are accessible from each database within the cluster.) More accurately, a database is a collection of schemas and the schemas contain the tables, functions, etc. So the full hierarchy is: server, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="translated">データベースは、SQLオブジェクト（「データベースオブジェクト」）の名前付きコレクションです。一般に、すべてのデータベースオブジェクト（テーブル、関数など）は、1つのデータベースにのみ属します。 （ただし、クラスター全体に属し、クラスター内の各データベースからアクセスできる &lt;code&gt;pg_database&lt;/code&gt; などのいくつかのシステムカタログがあります。）より正確には、データベースはスキーマのコレクションであり、スキーマにはテーブル、関数などが含まれます。 。したがって、完全な階層は、サーバー、データベース、スキーマ、テーブル（または関数などの他の種類のオブジェクト）です。</target>
        </trans-unit>
        <trans-unit id="c7d2c9abe130147ea353b9080d406b7f3bf3c1ff" translate="yes" xml:space="preserve">
          <source>A database role can have a number of attributes that define its privileges and interact with the client authentication system.</source>
          <target state="translated">データベースロールは、その権限を定義し、クライアント認証システムと相互作用する多くの属性を持つことができます。</target>
        </trans-unit>
        <trans-unit id="a3022f04bd927ba344f6e517eda753ede33a9966" translate="yes" xml:space="preserve">
          <source>A database superuser bypasses all permission checks, except the right to log in. This is a dangerous privilege and should not be used carelessly; it is best to do most of your work as a role that is not a superuser. To create a new database superuser, use &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt;. You must do this as a role that is already a superuser.</source>
          <target state="translated">データベースのスーパーユーザーは、ログインする権利を除いて、すべての権限チェックをバイパスします。これは危険な特権であり、不注意に使用しないでください。ほとんどの作業は、スーパーユーザーではない役割として実行することをお勧めします。新しいデータベーススーパーユーザーを作成するには、 &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt; を使用します。これは、すでにスーパーユーザーである役割として実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="a652bebb73f376f1df0ca8598fee059cf76fc365" translate="yes" xml:space="preserve">
          <source>A default value can be specified, in case a user wants columns of the data type to default to something other than the null value. Specify the default with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. (Such a default can be overridden by an explicit &lt;code&gt;DEFAULT&lt;/code&gt; clause attached to a particular column.)</source>
          <target state="translated">ユーザーがデータ型の列のデフォルトをnull値以外にしたい場合は、デフォルト値を指定できます。デフォルトを &lt;code&gt;DEFAULT&lt;/code&gt; キーワードで指定します。（このようなデフォルトは、特定の列にアタッチされた明示的な &lt;code&gt;DEFAULT&lt;/code&gt; 句によってオーバーライドできます。）</target>
        </trans-unit>
        <trans-unit id="260245ca0f51394bde912da70513f69a2611aadc" translate="yes" xml:space="preserve">
          <source>A defined set of instructions stored in the database system that can be invoked for execution. A routine can be written in a variety of programming languages. Routines can be &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; (including set-returning functions and &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;trigger functions&lt;/a&gt;), &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-PROCEDURE&quot;&gt;procedures&lt;/a&gt;.</source>
          <target state="translated">A defined set of instructions stored in the database system that can be invoked for execution. A routine can be written in a variety of programming languages. Routines can be &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; (including set-returning functions and &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;trigger functions&lt;/a&gt;), &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-PROCEDURE&quot;&gt;procedures&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5c1f42cac75263776f033d6ed34f1fbc16bad9be" translate="yes" xml:space="preserve">
          <source>A delay of this many seconds occurs when a new server process is started, after it conducts the authentication procedure. This is intended to give an opportunity to attach to the server process with a debugger.</source>
          <target state="translated">この何秒もの遅延は、新しいサーバプロセスが認証手続きを行った後に起動されたときに発生します。これは、デバッガでサーバプロセスにアタッチする機会を与えるためのものです。</target>
        </trans-unit>
        <trans-unit id="cd25a0e450014180419d77ce403bad9e20cb5564" translate="yes" xml:space="preserve">
          <source>A detailed description of bison or the grammar rules given in &lt;code&gt;gram.y&lt;/code&gt; would be beyond the scope of this paper. There are many books and documents dealing with flex and bison. You should be familiar with bison before you start to study the grammar given in &lt;code&gt;gram.y&lt;/code&gt; otherwise you won't understand what happens there.</source>
          <target state="translated">bisonの詳細な説明、または &lt;code&gt;gram.y&lt;/code&gt; で指定された文法規則は、このホワイトペーパーの範囲を超えています。フレックスやバイソンを扱った本やドキュメントはたくさんあります。 &lt;code&gt;gram.y&lt;/code&gt; で指定された文法を学習する前に、bisonについてよく知っておく必要があります。そうしないと、そこで何が起こるか理解できません。</target>
        </trans-unit>
        <trans-unit id="bf3c5419b01f42e467232a91a0454e478bf36293" translate="yes" xml:space="preserve">
          <source>A dictionary is a program that accepts a token as input and returns:</source>
          <target state="translated">辞書は、トークンを入力として受け取り、それを返すプログラムです。</target>
        </trans-unit>
        <trans-unit id="28559b5d13d6b8ce91e33b4017f8d681ab5ce5fe" translate="yes" xml:space="preserve">
          <source>A different approach to redirecting inserts into the appropriate child table is to set up rules, instead of a trigger, on the master table. For example:</source>
          <target state="translated">挿入を適切な子テーブルにリダイレクトするための別のアプローチは、マスターテーブルにトリガーではなくルールを設定することです。例えば、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="92dd343b65d278a179ec5a3ad694901513c02d90" translate="yes" xml:space="preserve">
          <source>A different setting might be appropriate when doing synchronous logical replication. The logical replication workers report the positions of writes and flushes to the publisher, and when using synchronous replication, the publisher will wait for the actual flush. This means that setting &lt;code&gt;synchronous_commit&lt;/code&gt; for the subscriber to &lt;code&gt;off&lt;/code&gt; when the subscription is used for synchronous replication might increase the latency for &lt;code&gt;COMMIT&lt;/code&gt; on the publisher. In this scenario, it can be advantageous to set &lt;code&gt;synchronous_commit&lt;/code&gt; to &lt;code&gt;local&lt;/code&gt; or higher.</source>
          <target state="translated">同期論理レプリケーションを行う場合は、別の設定が適切な場合があります。論理レプリケーションワーカーは書き込みとフラッシュの位置をパブリッシャーに報告し、同期レプリケーションを使用する場合、パブリッシャーは実際のフラッシュを待ちます。つまり、サブスクリプションが同期レプリケーションに使用されているときにサブスクライバーの &lt;code&gt;synchronous_commit&lt;/code&gt; を &lt;code&gt;off&lt;/code&gt; に設定すると、パブリッシャーの &lt;code&gt;COMMIT&lt;/code&gt; の待機時間が長くなる可能性があります。このシナリオでは、 &lt;code&gt;synchronous_commit&lt;/code&gt; を &lt;code&gt;local&lt;/code&gt; 以上に設定すると効果的です。</target>
        </trans-unit>
        <trans-unit id="77b0f5ef06846b6f2b1bf89e5b5dc745a05b482a" translate="yes" xml:space="preserve">
          <source>A disadvantage of the &lt;code&gt;jsonb_path_ops&lt;/code&gt; approach is that it produces no index entries for JSON structures not containing any values, such as &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt;. If a search for documents containing such a structure is requested, it will require a full-index scan, which is quite slow. &lt;code&gt;jsonb_path_ops&lt;/code&gt; is therefore ill-suited for applications that often perform such searches.</source>
          <target state="translated">&lt;code&gt;jsonb_path_ops&lt;/code&gt; アプローチの欠点は、 &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt; などの値を含まないJSON構造のインデックスエントリが生成されないことです。このような構造を含むドキュメントの検索が要求された場合、非常に遅いフルインデックススキャンが必要になります。したがって、 &lt;code&gt;jsonb_path_ops&lt;/code&gt; は、このような検索を頻繁に実行するアプリケーションには不適切です。</target>
        </trans-unit>
        <trans-unit id="436fb2bab58d12b2362059406a336206c3d00306" translate="yes" xml:space="preserve">
          <source>A discrete range is one whose element type has a well-defined &amp;ldquo;step&amp;rdquo;, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;date&lt;/code&gt;. In these types two elements can be said to be adjacent, when there are no valid values between them. This contrasts with continuous ranges, where it's always (or almost always) possible to identify other element values between two given values. For example, a range over the &lt;code&gt;numeric&lt;/code&gt; type is continuous, as is a range over &lt;code&gt;timestamp&lt;/code&gt;. (Even though &lt;code&gt;timestamp&lt;/code&gt; has limited precision, and so could theoretically be treated as discrete, it's better to consider it continuous since the step size is normally not of interest.)</source>
          <target state="translated">離散範囲とは、要素タイプが &lt;code&gt;integer&lt;/code&gt; や &lt;code&gt;date&lt;/code&gt; などの明確に定義された「ステップ」を持つ範囲です。これらのタイプでは、2つの要素の間に有効な値がない場合、2つの要素は隣接していると言えます。これは、2つの指定された値の間で他の要素の値を常に（またはほとんどの場合）識別できる連続範囲とは対照的です。たとえば、 &lt;code&gt;timestamp&lt;/code&gt; 範囲と同様に、 &lt;code&gt;numeric&lt;/code&gt; タイプの範囲は連続しています。 （ &lt;code&gt;timestamp&lt;/code&gt; 精度は限られているため、理論的には離散として扱うこともできますが、ステップサイズは通常は重要ではないため、連続と見なすことをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="a23c5cb9993deaf1311e315f3014f146e372868a" translate="yes" xml:space="preserve">
          <source>A discrete range type should have a &lt;em&gt;canonicalization&lt;/em&gt; function that is aware of the desired step size for the element type. The canonicalization function is charged with converting equivalent values of the range type to have identical representations, in particular consistently inclusive or exclusive bounds. If a canonicalization function is not specified, then ranges with different formatting will always be treated as unequal, even though they might represent the same set of values in reality.</source>
          <target state="translated">離散範囲タイプには、要素タイプに必要なステップサイズを認識する&lt;em&gt;正規化&lt;/em&gt;関数が必要です。正規化関数は、範囲型の同等の値を変換して、同一の表現、特に一貫した包含または排他的な境界を持つようにします。正規化関数が指定されていない場合、実際には同じ値のセットを表す場合でも、異なるフォーマットの範囲は常に等しくないものとして扱われます。</target>
        </trans-unit>
        <trans-unit id="52cd489229e47470dc581e1d13cab54fdd7f5f6e" translate="yes" xml:space="preserve">
          <source>A dollar sign (&lt;code&gt;$&lt;/code&gt;) followed by digits is used to represent a positional parameter in the body of a function definition or a prepared statement. In other contexts the dollar sign can be part of an identifier or a dollar-quoted string constant.</source>
          <target state="translated">数字が続くドル記号（ &lt;code&gt;$&lt;/code&gt; ）は、関数定義または準備されたステートメントの本体で定位置パラメーターを表すために使用されます。他のコンテキストでは、ドル記号は識別子またはドルで引用された文字列定数の一部である場合があります。</target>
        </trans-unit>
        <trans-unit id="85726c6c75380e885546cdf31fee2dad70737f00" translate="yes" xml:space="preserve">
          <source>A dollar-quoted string that follows a keyword or identifier must be separated from it by whitespace; otherwise the dollar quoting delimiter would be taken as part of the preceding identifier.</source>
          <target state="translated">キーワードや識別子の後に続くドル引用符で囲まれた文字列は、空白で区切る必要があります。</target>
        </trans-unit>
        <trans-unit id="483ea815eb464b44ff5ffec5d8ce0005d215accd" translate="yes" xml:space="preserve">
          <source>A duplicate is a leaf page tuple (a tuple that points to a table row) where &lt;em&gt;all&lt;/em&gt; indexed key columns have values that match corresponding column values from at least one other leaf page tuple in the same index. Duplicate tuples are quite common in practice. B-Tree indexes can use a special, space-efficient representation for duplicates when an optional technique is enabled: &lt;em&gt;deduplication&lt;/em&gt;.</source>
          <target state="translated">A duplicate is a leaf page tuple (a tuple that points to a table row) where &lt;em&gt;all&lt;/em&gt; indexed key columns have values that match corresponding column values from at least one other leaf page tuple in the same index. Duplicate tuples are quite common in practice. B-Tree indexes can use a special, space-efficient representation for duplicates when an optional technique is enabled: &lt;em&gt;deduplication&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="cee3f5330478a7b8687aa435c97bcf37602fa11b" translate="yes" xml:space="preserve">
          <source>A failure message indicating inability to bind to a port might indicate that that port is already in use by some non-PostgreSQL process. You might also get this error if you terminate &lt;code&gt;postgres&lt;/code&gt; and immediately restart it using the same port; in this case, you must simply wait a few seconds until the operating system closes the port before trying again. Finally, you might get this error if you specify a port number that your operating system considers to be reserved. For example, many versions of Unix consider port numbers under 1024 to be &amp;ldquo;trusted&amp;rdquo; and only permit the Unix superuser to access them.</source>
          <target state="translated">ポートにバインドできないことを示すエラーメッセージは、そのポートがPostgreSQL以外のプロセスによってすでに使用されていることを示している可能性があります。また、 &lt;code&gt;postgres&lt;/code&gt; を終了してすぐに同じポートを使用して再起動した場合にも、このエラーが発生する可能性があります。この場合、オペレーティングシステムがポートを閉じるまで数秒待ってから、再試行する必要があります。最後に、オペレーティングシステムが予約されていると見なすポート番号を指定すると、このエラーが発生する可能性があります。たとえば、Unixの多くのバージョンでは、1024未満のポート番号を「信頼できる」と見なし、Unixスーパーユーザーにのみアクセスを許可しています。</target>
        </trans-unit>
        <trans-unit id="6c9a12fdfac03387393cfa5d605bafff7741fcf8" translate="yes" xml:space="preserve">
          <source>A failure message mentioning &lt;code&gt;semget&lt;/code&gt; or &lt;code&gt;shmget&lt;/code&gt; probably indicates you need to configure your kernel to provide adequate shared memory and semaphores. For more discussion see &lt;a href=&quot;kernel-resources&quot;&gt;Section 18.4&lt;/a&gt;. You might be able to postpone reconfiguring your kernel by decreasing &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; to reduce the shared memory consumption of PostgreSQL, and/or by reducing &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; to reduce the semaphore consumption.</source>
          <target state="translated">&lt;code&gt;semget&lt;/code&gt; または &lt;code&gt;shmget&lt;/code&gt; に関するエラーメッセージは、おそらく、適切な共有メモリとセマフォを提供するようにカーネルを構成する必要があることを示しています。詳細については、&lt;a href=&quot;kernel-resources&quot;&gt;セクション18.4を&lt;/a&gt;参照してください。PostgreSQLの共有メモリの消費を減らすために&lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;を減らすか、セマフォの消費を減らすために&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;を減らすことにより、カーネルの再構成を延期できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6441f31b6574d318eb87a3d59abc87efb6583505" translate="yes" xml:space="preserve">
          <source>A failure message suggesting that another server is already running should be checked carefully, for example by using the command</source>
          <target state="translated">別のサーバが既に実行されていることを示唆する失敗メッセージは注意深くチェックすべきです。</target>
        </trans-unit>
        <trans-unit id="1d9edc129f87c5a3cfe93256806f12763480e5e4" translate="yes" xml:space="preserve">
          <source>A few of the catalogs are so fundamental that they can't even be created by the BKI &lt;code&gt;create&lt;/code&gt; command that's used for most catalogs, because that command needs to write information into these catalogs to describe the new catalog. These are called &lt;em&gt;bootstrap&lt;/em&gt; catalogs, and defining one takes a lot of extra work: you have to manually prepare appropriate entries for them in the pre-loaded contents of &lt;code&gt;pg_class&lt;/code&gt; and &lt;code&gt;pg_type&lt;/code&gt;, and those entries will need to be updated for subsequent changes to the catalog's structure. (Bootstrap catalogs also need pre-loaded entries in &lt;code&gt;pg_attribute&lt;/code&gt;, but fortunately &lt;code&gt;genbki.pl&lt;/code&gt; handles that chore nowadays.) Avoid making new catalogs be bootstrap catalogs if at all possible.</source>
          <target state="translated">いくつかのカタログは非常に基本的であり、ほとんどのカタログで使用されるBKI &lt;code&gt;create&lt;/code&gt; コマンドでも作成できません。そのコマンドは、新しいカタログを記述するためにこれらのカタログに情報を書き込む必要があるためです。これらが呼び出され&lt;em&gt;、ブートストラップの&lt;/em&gt;カタログ、および1つを定義することは、余分な作業の多くを取る：あなたは、手動での事前ロードされた内容に彼らのために適切なエントリを準備する必要があり &lt;code&gt;pg_class&lt;/code&gt; と &lt;code&gt;pg_type&lt;/code&gt; システムカタログ、およびこれらのエントリは、カタログの以降の変更のために更新する必要があります構造。（ブートストラップカタログも &lt;code&gt;pg_attribute&lt;/code&gt; にプリロードされたエントリが必要ですが、幸いに &lt;code&gt;genbki.pl&lt;/code&gt; 最近の雑用を処理します。）可能であれば、新しいカタログをブートストラップカタログにすることは避けてください。</target>
        </trans-unit>
        <trans-unit id="491372897d998156eaa18d8e18156aea1cce4b05" translate="yes" xml:space="preserve">
          <source>A field selection expression</source>
          <target state="translated">フィールド選択式</target>
        </trans-unit>
        <trans-unit id="7c39dad2086ca141110bdca18a2eda32e161292b" translate="yes" xml:space="preserve">
          <source>A file containing the major version number of PostgreSQL</source>
          <target state="translated">PostgreSQLのメジャーバージョン番号を含むファイル</target>
        </trans-unit>
        <trans-unit id="6d87ef4157174eec7539a1a8a3467ba85faf286d" translate="yes" xml:space="preserve">
          <source>A file recording the command-line options the server was last started with</source>
          <target state="translated">サーバが最後に起動したときのコマンドラインオプションを記録したファイル</target>
        </trans-unit>
        <trans-unit id="329de4f43c6fb34276fdedd0bdd8b0f19adeca12" translate="yes" xml:space="preserve">
          <source>A file used for storing configuration parameters that are set by &lt;code&gt;ALTER SYSTEM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; によって設定される構成パラメーターを保管するために使用されるファイル</target>
        </trans-unit>
        <trans-unit id="d60f29dfa94fb158cf5e58302f68dd9e477b3bca" translate="yes" xml:space="preserve">
          <source>A filtering dictionary can be placed anywhere in the list, except at the end where it'd be useless. Filtering dictionaries are useful to partially normalize words to simplify the task of later dictionaries. For example, a filtering dictionary could be used to remove accents from accented letters, as is done by the &lt;a href=&quot;unaccent&quot;&gt;unaccent&lt;/a&gt; module.</source>
          <target state="translated">フィルタリングディクショナリは、リストの任意の場所に配置できますが、不要になる場合を除きます。フィルタリング辞書は、後の辞書のタスクを簡略化するために単語を部分的に正規化するのに役立ちます。たとえば、フィルタリング辞書を使用して、アクセント記号の&lt;a href=&quot;unaccent&quot;&gt;ない&lt;/a&gt;モジュールで行われるように、アクセント記号付きの文字からアクセント記号を削除できます。</target>
        </trans-unit>
        <trans-unit id="61b8bbc2eb9fadf3683e04ebbb9e129815f5ed02" translate="yes" xml:space="preserve">
          <source>A final identifier type used by the system is &lt;code&gt;tid&lt;/code&gt;, or tuple identifier (row identifier). This is the data type of the system column &lt;code&gt;ctid&lt;/code&gt;. A tuple ID is a pair (block number, tuple index within block) that identifies the physical location of the row within its table.</source>
          <target state="translated">システムで使用される最後の識別子タイプは、 &lt;code&gt;tid&lt;/code&gt; またはタプル識別子（行識別子）です。これは、システム列 &lt;code&gt;ctid&lt;/code&gt; のデータ型です。タプルIDは、テーブル内の行の物理的な場所を識別するペア（ブロック番号、ブロック内のタプルインデックス）です。</target>
        </trans-unit>
        <trans-unit id="9534174e684925e17ef91bf3e3714ca6759242b6" translate="yes" xml:space="preserve">
          <source>A fine point of the above example is that the &lt;code&gt;WITH&lt;/code&gt; clause is attached to the &lt;code&gt;INSERT&lt;/code&gt;, not the sub-&lt;code&gt;SELECT&lt;/code&gt; within the &lt;code&gt;INSERT&lt;/code&gt;. This is necessary because data-modifying statements are only allowed in &lt;code&gt;WITH&lt;/code&gt; clauses that are attached to the top-level statement. However, normal &lt;code&gt;WITH&lt;/code&gt; visibility rules apply, so it is possible to refer to the &lt;code&gt;WITH&lt;/code&gt; statement's output from the sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">上記の例のすばらしい点は、 &lt;code&gt;WITH&lt;/code&gt; 句が &lt;code&gt;INSERT&lt;/code&gt; 内のサブ &lt;code&gt;SELECT&lt;/code&gt; ではなくINSERTにアタッチされていること &lt;code&gt;INSERT&lt;/code&gt; 。これは、データ変更ステートメントがトップレベルのステートメントにアタッチされている &lt;code&gt;WITH&lt;/code&gt; 句でのみ許可されているために必要です。ただし、通常の &lt;code&gt;WITH&lt;/code&gt; 可視性ルールが適用されるため、サブ &lt;code&gt;SELECT&lt;/code&gt; からの &lt;code&gt;WITH&lt;/code&gt; ステートメントの出力を参照することが可能です。</target>
        </trans-unit>
        <trans-unit id="d04dea72f91d057a2ddbc23d00826a2d1a1c915a" translate="yes" xml:space="preserve">
          <source>A first pass to build the index is done for each new index. Once the index is built, its flag &lt;code&gt;pg_index.indisready&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; to make it ready for inserts, making it visible to other sessions once the transaction that performed the build is finished. This step is done in a separate transaction for each index.</source>
          <target state="translated">インデックスを作成する最初のパスは、新しいインデックスごとに行われます。インデックスが構築されると、フラグ &lt;code&gt;pg_index.indisready&lt;/code&gt; が「true」に切り替えられて挿入の準備が整い、構築を実行したトランザクションが完了すると、他のセッションから見えるようになります。この手順は、インデックスごとに個別のトランザクションで実行されます。</target>
        </trans-unit>
        <trans-unit id="a130458680bbe29e1418dce659480b6f78389bae" translate="yes" xml:space="preserve">
          <source>A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example:</source>
          <target state="translated">外部キーは、列のグループを制約して参照することもできます。通常通り、テーブル制約の形式で記述する必要があります。ここでは、工夫された構文の例を示します。</target>
        </trans-unit>
        <trans-unit id="7935e3b9aa49c2d43f16cbf75e1d409bba02665a" translate="yes" xml:space="preserve">
          <source>A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the &lt;em&gt;referential integrity&lt;/em&gt; between two related tables.</source>
          <target state="translated">外部キー制約は、列（または列のグループ）の値が別のテーブルの一部の行に表示される値と一致する必要があることを指定します。これにより、2つの関連するテーブル間の&lt;em&gt;参照整合性&lt;/em&gt;が維持されます。</target>
        </trans-unit>
        <trans-unit id="dec7e4504b0a144e3a3d9b45cbf1480f1f8aba04" translate="yes" xml:space="preserve">
          <source>A foreign key must reference columns that either are a primary key or form a unique constraint. This means that the referenced columns always have an index (the one underlying the primary key or unique constraint); so checks on whether a referencing row has a match will be efficient. Since a &lt;code&gt;DELETE&lt;/code&gt; of a row from the referenced table or an &lt;code&gt;UPDATE&lt;/code&gt; of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, declaration of a foreign key constraint does not automatically create an index on the referencing columns.</source>
          <target state="translated">外部キーは、主キーであるか、一意制約を形成する列を参照する必要があります。つまり、参照される列には常にインデックス（主キーまたは一意制約の基礎となるもの）があります。したがって、参照する行に一致があるかどうかを確認すると効率的です。以来 &lt;code&gt;DELETE&lt;/code&gt; 参照されるテーブルやから行の &lt;code&gt;UPDATE&lt;/code&gt; 参照列の古い値と一致する行の参照テーブルのスキャンが必要になります、それはあまりにも頻繁に参照する列のインデックスには良いアイデアです。これは常に必要なわけではなく、インデックスの作成方法には多くの選択肢があるため、外部キー制約を宣言しても、参照する列にインデックスが自動的に作成されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="8ae80fcdea6bfacfb223ea7833eb93180e9021f3" translate="yes" xml:space="preserve">
          <source>A foreign server typically encapsulates connection information that a foreign-data wrapper uses to access an external data resource. Additional user-specific connection information may be specified by means of user mappings.</source>
          <target state="translated">外部サーバは通常、外部データラッパーが外部データリソースにアクセスするために使用する接続情報をカプセル化します。追加のユーザ固有の接続情報は、ユーザマッピングによって指定することができます。</target>
        </trans-unit>
        <trans-unit id="9a9b5927e002630605d5343a34d0cf4f9f180fe0" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed:</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 外部データラッパーを使用する外部サーバーは、&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;セクション33.1.2&lt;/a&gt;で説明されているように、libpqが接続文字列で受け入れるオプションと同じオプションを持つことができますが、これらのオプションは許可されていません。</target>
        </trans-unit>
        <trans-unit id="badba5a356d62e1cd053d7b73d8fe2b817602f47" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed or have special handling:</source>
          <target state="translated">A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed or have special handling:</target>
        </trans-unit>
        <trans-unit id="1be8aee5fcb016100bb8dc793de4e631744baeb3" translate="yes" xml:space="preserve">
          <source>A foreign table created using this wrapper can have the following options:</source>
          <target state="translated">このラッパーを用いて作成された外部テーブルは、以下のオプションを持つことができます。</target>
        </trans-unit>
        <trans-unit id="53f8f23c4cbab938356aea7eedc9b0a745c3d640" translate="yes" xml:space="preserve">
          <source>A foreign-data wrapper handler is declared to return &lt;code&gt;fdw_handler&lt;/code&gt;.</source>
          <target state="translated">外部データラッパーハンドラーは、 &lt;code&gt;fdw_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="3d69f8188280c90b11c42fae9d5a6f62a34fa828" translate="yes" xml:space="preserve">
          <source>A full list of &lt;code&gt;tsvector&lt;/code&gt;-related functions is available in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;Table 9.42&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 関連の関数の完全なリストは、&lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;表9.42にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="65e83897f69ea1032a4c6125df7aec06ca7e6f69" translate="yes" xml:space="preserve">
          <source>A full time zone name, for example &lt;code&gt;America/New_York&lt;/code&gt;. The recognized time zone names are listed in the &lt;code&gt;pg_timezone_names&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-names&quot;&gt;Section 51.92&lt;/a&gt;). PostgreSQL uses the widely-used IANA time zone data for this purpose, so the same time zone names are also recognized by other software.</source>
          <target state="translated">完全なタイムゾーン名。たとえば、 &lt;code&gt;America/New_York&lt;/code&gt; 。認識されるタイムゾーン名は &lt;code&gt;pg_timezone_names&lt;/code&gt; ビューにリストされます（&lt;a href=&quot;view-pg-timezone-names&quot;&gt;セクション51.92を&lt;/a&gt;参照）。PostgreSQLはこの目的で広く使用されているIANAタイムゾーンデータを使用するため、同じタイムゾーン名は他のソフトウェアでも認識されます。</target>
        </trans-unit>
        <trans-unit id="ca3257c97b3a14d468e354dcf32c96f8c18bebc4" translate="yes" xml:space="preserve">
          <source>A function call</source>
          <target state="translated">関数呼び出し</target>
        </trans-unit>
        <trans-unit id="29b8eafb6b7c2b2b298c30410ef6e0e704d3c56b" translate="yes" xml:space="preserve">
          <source>A function can be represented by its &lt;code&gt;proname&lt;/code&gt;, if that is unique among the &lt;code&gt;pg_proc.dat&lt;/code&gt; entries (this works like regproc input). Otherwise, write it as &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt;, like regprocedure. The argument type names must be spelled exactly as they are in the &lt;code&gt;pg_proc.dat&lt;/code&gt; entry's &lt;code&gt;proargtypes&lt;/code&gt; field. Do not insert any spaces.</source>
          <target state="translated">関数は、 &lt;code&gt;pg_proc.dat&lt;/code&gt; エントリ間で一意である場合、その &lt;code&gt;proname&lt;/code&gt; で表すことができます（これはregproc入力のように機能します）。それ以外の場合は、 &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt; ように、proname（argtypename、argtypename、...）として記述します。引数の型名は、 &lt;code&gt;pg_proc.dat&lt;/code&gt; エントリの &lt;code&gt;proargtypes&lt;/code&gt; フィールドにあるとおりに正確にスペルする必要があります。スペースは挿入しないでください。</target>
        </trans-unit>
        <trans-unit id="665c5d40faa1c27c6639ca8ba23f82787f2ca582" translate="yes" xml:space="preserve">
          <source>A function that takes a single argument of composite type can optionally be called using field-selection syntax, and conversely field selection can be written in functional style. That is, the notations &lt;code&gt;col(table)&lt;/code&gt; and &lt;code&gt;table.col&lt;/code&gt; are interchangeable. This behavior is not SQL-standard but is provided in PostgreSQL because it allows use of functions to emulate &amp;ldquo;computed fields&amp;rdquo;. For more information see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">複合型の単一の引数を取る関数は、オプションでフィールド選択構文を使用して呼び出すことができます。逆に、フィールド選択は関数形式で書くことができます。つまり、表記 &lt;code&gt;col(table)&lt;/code&gt; と &lt;code&gt;table.col&lt;/code&gt; は交換可能です。この動作はSQL標準ではありませんが、関数を使用して「計算フィールド」をエミュレートできるため、PostgreSQLで提供されています。詳細については、&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;セクション8.16.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e7f8fec4e5b8f079531cd32a009d627206c65e10" translate="yes" xml:space="preserve">
          <source>A generated column cannot be part of a partition key.</source>
          <target state="translated">生成された列をパーティションキーの一部にすることはできません。</target>
        </trans-unit>
        <trans-unit id="e0ac9eba09cfa3c9dbd2d45d33c0ab9b56aec7dc" translate="yes" xml:space="preserve">
          <source>A generated column cannot be written to directly. In &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands, a value cannot be specified for a generated column, but the keyword &lt;code&gt;DEFAULT&lt;/code&gt; may be specified.</source>
          <target state="translated">生成された列を直接書き込むことはできません。 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; コマンド、値が生成された列に指定することができないが、キーワード &lt;code&gt;DEFAULT&lt;/code&gt; を指定してもよいです。</target>
        </trans-unit>
        <trans-unit id="a974e7fa8fff8257dce1404630bd9e17704afbe0" translate="yes" xml:space="preserve">
          <source>A generated column cannot have a column default or an identity definition.</source>
          <target state="translated">生成された列は、列のデフォルトや ID 定義を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="1dbf7e263f1354b2b93387f1bfe3cc26e77a333d" translate="yes" xml:space="preserve">
          <source>A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read. Thus, a virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). PostgreSQL currently implements only stored generated columns.</source>
          <target state="translated">生成されたカラムは、常に他のカラムから計算される特別なカラムです。したがって、カラムにとってのビューがテーブルにとってのビューであるようなものです。生成されるカラムには、ストアドカラムとバーチャルカラムの2種類があります。ストアドされた生成カラムは、書き込まれた (挿入された、または更新された)ときに計算され、通常のカラムのようにストレージを占有します。仮想生成カラムは、ストレージを占有せず、読み込まれたときに計算されます。したがって、仮想生成された列はビューに似ており、格納された生成列はマテリアライズされたビューに似ています(常に自動的に更新されることを除いて)。PostgreSQLは現在、格納された生成列のみを実装しています。</target>
        </trans-unit>
        <trans-unit id="be4467cb35124e2c3c1d0bf937b508ea68a8aa1a" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference a system column, except &lt;code&gt;tableoid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tableoid&lt;/code&gt; を除き、生成式はシステム列を参照できません。</target>
        </trans-unit>
        <trans-unit id="4e7a5a9dc2e173ff254950537b52dfc433ffc740" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference another generated column.</source>
          <target state="translated">生成式は、別の生成された列を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="cddf5b488fdbb3769abd336844e34805f857556c" translate="yes" xml:space="preserve">
          <source>A group of backend and auxiliary processes that communicate using a common shared memory area. One &lt;a href=&quot;glossary#GLOSSARY-POSTMASTER&quot;&gt;postmaster process&lt;/a&gt; manages the instance; one instance manages exactly one &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; with all its databases. Many instances can run on the same &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; as long as their TCP ports do not conflict.</source>
          <target state="translated">A group of backend and auxiliary processes that communicate using a common shared memory area. One &lt;a href=&quot;glossary#GLOSSARY-POSTMASTER&quot;&gt;postmaster process&lt;/a&gt; manages the instance; one instance manages exactly one &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; with all its databases. Many instances can run on the same &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; as long as their TCP ports do not conflict.</target>
        </trans-unit>
        <trans-unit id="5204280cf84852f809b22497f5b5b7223747d56b" translate="yes" xml:space="preserve">
          <source>A heap page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; で取得したヒープページ画像を引数として渡す必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="852fc3cf5ee76f5f80b4e90d90cfd5ea3f69f788" translate="yes" xml:space="preserve">
          <source>A helpful trick for testing queries when you are not certain if they might loop is to place a &lt;code&gt;LIMIT&lt;/code&gt; in the parent query. For example, this query would loop forever without the &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">ループの可能性があるかどうか不明な場合にクエリをテストするのに役立つトリックは、親クエリに &lt;code&gt;LIMIT&lt;/code&gt; を配置することです。たとえば、次のクエリは &lt;code&gt;LIMIT&lt;/code&gt; なしでは永久にループします。</target>
        </trans-unit>
        <trans-unit id="83afefe0fbb71aaede7acaeb0c43f98d93c15f12" translate="yes" xml:space="preserve">
          <source>A high schedule lag time is an indication that the system cannot process transactions at the specified rate, with the chosen number of clients and threads. When the average transaction execution time is longer than the scheduled interval between each transaction, each successive transaction will fall further behind, and the schedule lag time will keep increasing the longer the test run is. When that happens, you will have to reduce the specified transaction rate.</source>
          <target state="translated">高いスケジュール・ラグタイムは、システムが指定されたクライアント数とスレッド数のトランザクションを指定されたレートで処理できないことを示しています。平均トランザクション実行時間が各トランザクション間のスケジュールされた間隔よりも長い場合、連続する各トランザクションはさらに遅れてしまい、スケジュールラグタイムはテスト実行が長くなるほど増加し続けます。そうなると、指定したトランザクションレートを下げなければならなくなります。</target>
        </trans-unit>
        <trans-unit id="61cac6a1eeedd7da0737519022c8bf6afc564b8b" translate="yes" xml:space="preserve">
          <source>A histogram of the counts of distinct non-null element values within the values of the column, followed by the average number of distinct non-null elements. (Null for scalar types.)</source>
          <target state="translated">列の値の中にある明確な非ヌル要素の値のカウントをヒストグラムにしたもので、その後に明確な非ヌル要素の平均数が続きます。(スカラ型の場合はNull)</target>
        </trans-unit>
        <trans-unit id="e17cd8aa619245cf1ec3d376e7b36d9afdaa66d4" translate="yes" xml:space="preserve">
          <source>A host name specification that starts with a dot (&lt;code&gt;.&lt;/code&gt;) matches a suffix of the actual host name. So &lt;code&gt;.example.com&lt;/code&gt; would match &lt;code&gt;foo.example.com&lt;/code&gt; (but not just &lt;code&gt;example.com&lt;/code&gt;).</source>
          <target state="translated">ドット（ &lt;code&gt;.&lt;/code&gt; ）で始まるホスト名の指定は、実際のホスト名のサフィックスと一致します。したがって、 &lt;code&gt;.example.com&lt;/code&gt; は &lt;code&gt;foo.example.com&lt;/code&gt; と一致します（ &lt;code&gt;example.com&lt;/code&gt; だけではありません）。</target>
        </trans-unit>
        <trans-unit id="16a83f51a8f292b8e135eff3bc4b49e6a7b0c8c1" translate="yes" xml:space="preserve">
          <source>A joined table is a table derived from two other (real or derived) tables according to the rules of the particular join type. Inner, outer, and cross-joins are available. The general syntax of a joined table is</source>
          <target state="translated">結合されたテーブルは、特定の結合タイプのルールに従って、他の2つのテーブル(実テーブルまたは派生テーブル)から派生したテーブルです。内部結合、外部結合、クロス結合が可能です。結合テーブルの一般的な構文は</target>
        </trans-unit>
        <trans-unit id="c38978f6d39cb114e0bbdd4555f08d4137a6d679" translate="yes" xml:space="preserve">
          <source>A key feature of psql variables is that you can substitute (&amp;ldquo;interpolate&amp;rdquo;) them into regular SQL statements, as well as the arguments of meta-commands. Furthermore, psql provides facilities for ensuring that variable values used as SQL literals and identifiers are properly quoted. The syntax for interpolating a value without any quoting is to prepend the variable name with a colon (&lt;code&gt;:&lt;/code&gt;). For example,</source>
          <target state="translated">psql変数の重要な機能は、メタコマンドの引数だけでなく、それらを通常のSQLステートメントに置換（「補間」）できることです。さらに、psqlは、SQLリテラルおよび識別子として使用される変数値が適切に引用されることを保証する機能を提供します。（任意の引用せずに値を補間するための構文は、コロンと変数名を付加することです &lt;code&gt;:&lt;/code&gt; ）。例えば、</target>
        </trans-unit>
        <trans-unit id="82961127c30e9d99b0606fff4408183ed9cb0961" translate="yes" xml:space="preserve">
          <source>A key property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; クエリの重要な特性は、プライマリクエリが複数回参照する場合でも、通常はプライマリクエリの実行ごとに1回だけ評価されることです。特に、データ変更ステートメントは、プライマリクエリがすべての出力を読み取るか、出力を読み取るかに関係なく、一度だけ実行されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="61ba864342105e7de2a1c4f77ad3ea649ab3dd8e" translate="yes" xml:space="preserve">
          <source>A larger setting would be appropriate if other programs on the machine also need huge pages. Don't forget to add this setting to &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; so that it will be reapplied after reboots.</source>
          <target state="translated">マシン上の他のプログラムでも巨大なページが必要な場合は、より大きな設定が適切です。リブート後に再適用されるように、この設定を &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; に追加することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="740fc98f7710c6fce519cc7ddb08e68b536ff0d4" translate="yes" xml:space="preserve">
          <source>A less-oversimplified example of a &lt;code&gt;subtype_diff&lt;/code&gt; function is:</source>
          <target state="translated">&lt;code&gt;subtype_diff&lt;/code&gt; 関数の簡略化されていない例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="15b979d3d44d76b40d5152f1d019597a03929970" translate="yes" xml:space="preserve">
          <source>A limitation of pgbench is that it can itself become the bottleneck when trying to test a large number of client sessions. This can be alleviated by running pgbench on a different machine from the database server, although low network latency will be essential. It might even be useful to run several pgbench instances concurrently, on several client machines, against the same database server.</source>
          <target state="translated">pgbench の限界は、多数のクライアントセッションをテストしようとしたときに、それ自体がボトルネックになる可能性があることです。これはデータベースサーバとは別のマシンで pgbench を実行することで緩和されますが、低いネットワークレイテンシが不可欠になります。複数のクライアントマシン上で、同じデータベースサーバに対して複数の pgbench インスタンスを同時に実行することも有用かもしれません。</target>
        </trans-unit>
        <trans-unit id="ab2d89a97d20a5efbc73683817ba2ff464b9a103" translate="yes" xml:space="preserve">
          <source>A limitation of these built-in triggers is that they treat all the input columns alike. To process columns differently &amp;mdash; for example, to weight title differently from body &amp;mdash; it is necessary to write a custom trigger. Here is an example using PL/pgSQL as the trigger language:</source>
          <target state="translated">これらの組み込みトリガーの制限は、すべての入力列を同様に処理することです。列を異なる方法で処理するには（たとえば、タイトルを本文とは異なるように重み付けするため）、カスタムトリガーを記述する必要があります。PL / pgSQLをトリガー言語として使用する例を次に示します。</target>
        </trans-unit>
        <trans-unit id="f76857de86cd4afe434d4b21d9313477ab29ebe7" translate="yes" xml:space="preserve">
          <source>A limitation of this feature is that an &lt;code&gt;ORDER BY&lt;/code&gt; clause applying to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; clause can only specify an output column name or number, not an expression.</source>
          <target state="translated">この機能の制限は、 &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; 、または &lt;code&gt;EXCEPT&lt;/code&gt; 句の結果に適用される &lt;code&gt;ORDER BY&lt;/code&gt; 句は、式ではなく出力列の名前または数値のみを指定できることです。</target>
        </trans-unit>
        <trans-unit id="6e332e0f99b25d5ac06d1f211aa0eb2e56e7af5e" translate="yes" xml:space="preserve">
          <source>A list of NULL flags for the most common combinations of values. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">値の最も一般的な組み合わせのNULLフラグのリスト。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="faedcc532ba9e80276afc21b0d135826be8f1422" translate="yes" xml:space="preserve">
          <source>A list of non-null element values most often appearing within values of the column. (Null for scalar types.)</source>
          <target state="translated">カラムの値の中で最も頻繁に現れる非ヌル要素の値のリスト。(スカラ型の場合はNull)。</target>
        </trans-unit>
        <trans-unit id="9222c144bac210ee75eb7f8e023e5b70c063c9b1" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and the update expressions. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement. Note that the target table must not appear in the &lt;code&gt;from_list&lt;/code&gt;, unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_list&lt;/code&gt;).</source>
          <target state="translated">テーブル式のリスト。他のテーブルの列を &lt;code&gt;WHERE&lt;/code&gt; 条件および更新式に表示できます。これは、 &lt;code&gt;SELECT&lt;/code&gt; ステートメントの&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 句&lt;/a&gt;で指定できるテーブルのリストに似ています。自己結合を意図している場合を除いて、ターゲットテーブルは &lt;code&gt;from_list&lt;/code&gt; に表示されないように注意してください（この場合、 &lt;code&gt;from_list&lt;/code&gt; にエイリアスを付けて表示される必要があります）。</target>
        </trans-unit>
        <trans-unit id="a5ec616bf7215f2b568c6fa91ae40cb63c46d2ff" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table in the &lt;code&gt;using_list&lt;/code&gt;, unless you wish to set up a self-join.</source>
          <target state="translated">テーブル式のリスト。他のテーブルの列を &lt;code&gt;WHERE&lt;/code&gt; 条件に表示できます。これは、 &lt;code&gt;SELECT&lt;/code&gt; ステートメントの&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 句&lt;/a&gt;で指定できるテーブルのリストに似ています。たとえば、テーブル名のエイリアスを指定できます。自己結合を設定する場合を除き、 &lt;code&gt;using_list&lt;/code&gt; でターゲットテーブルを繰り返さないでください。</target>
        </trans-unit>
        <trans-unit id="4a9f5b6a7fa98f13d9b0649d9b104ce5e824c915" translate="yes" xml:space="preserve">
          <source>A list of the base frequencies of the most common combinations, i.e., product of per-value frequencies. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な組み合わせの基本周波数のリスト、つまり、値ごとの周波数の積。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="c0a9903e8f4ef251af0eff5fa2455e175a7548a4" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common combinations, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な組み合わせの頻度のリスト、つまり、それぞれの発生数を行の総数で割ったもの。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="527238c1ce219277abbb45386e199364181b4e39" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common element values, i.e., the fraction of rows containing at least one instance of the given value. Two or three additional values follow the per-element frequencies; these are the minimum and maximum of the preceding per-element frequencies, and optionally the frequency of null elements. (Null when &lt;code&gt;most_common_elems&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な要素値の頻度のリスト、つまり、指定された値の少なくとも1つのインスタンスを含む行の割合。2つまたは3つの追加の値が要素ごとの頻度に従います。これらは、前述の要素ごとの頻度の最小値と最大値であり、オプションでnull要素の頻度です。（ &lt;code&gt;most_common_elems&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="6973fe18397e6786beffdd562ca0c447ef38be82" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common values, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">最も一般的な値の頻度のリスト、つまり、それぞれの出現回数を行の総数で割ったもの。（ &lt;code&gt;most_common_vals&lt;/code&gt; がNULLの場合はnull ）</target>
        </trans-unit>
        <trans-unit id="f63bcd58b43a4c5b783b6642ba5709e3ccbcb180" translate="yes" xml:space="preserve">
          <source>A list of the most common combinations of values in the columns. (Null if no combinations seem to be more common than any others.)</source>
          <target state="translated">列内の値の最も一般的な組み合わせのリスト。(他のどの組み合わせよりも一般的な組み合わせがない場合はNULL)。</target>
        </trans-unit>
        <trans-unit id="7e7a21f80a86cbb3d663d9a6c19c5698cb32c935" translate="yes" xml:space="preserve">
          <source>A list of the most common values in the column. (Null if no values seem to be more common than any others.)</source>
          <target state="translated">列の中で最も一般的な値のリスト。(他のどの値よりも一般的な値がない場合はNULL)。</target>
        </trans-unit>
        <trans-unit id="f5ec309be4a2c82919d5db6bbf83466f9afb0124" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g. &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">トリガーが起動する、関連する &lt;code&gt;filter_variable&lt;/code&gt; の値のリスト。以下のために &lt;code&gt;TAG&lt;/code&gt; 、これはコマンドタグのリスト（例えば意味 &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff968df28749e5bcff327cac21b38ab15e60f682" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g., &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt; , this means a list of command tags (e.g., &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e4fe90764276ed140f41c638b69ba17b32d691f" translate="yes" xml:space="preserve">
          <source>A list of values that divide the column's values into groups of approximately equal population. The values in &lt;code&gt;most_common_vals&lt;/code&gt;, if present, are omitted from this histogram calculation. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator or if the &lt;code&gt;most_common_vals&lt;/code&gt; list accounts for the entire population.)</source>
          <target state="translated">列の値をほぼ等しい母集団のグループに分割する値のリスト。 &lt;code&gt;most_common_vals&lt;/code&gt; の値が存在する場合は、このヒストグラム計算から省略されます。（列のデータ型に &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子がない場合、または &lt;code&gt;most_common_vals&lt;/code&gt; リストが母集団全体を占める場合、この列はnullです。）</target>
        </trans-unit>
        <trans-unit id="ed9c3dd9d41fb7cb75cda90adbcd956a0d568298" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (could be empty), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (could be empty), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt; , or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</target>
        </trans-unit>
        <trans-unit id="a40d49086dbccf43760fcf28e8592fb7682d6120" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (empty on Windows), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">現在のポストマスタープロセスID（PID）、クラスターデータディレクトリパス、ポストマスター開始タイムスタンプ、ポート番号、Unixドメインソケットディレクトリパス（Windowsでは空）、最初の有効なlisten_address（IPアドレスまたは &lt;code&gt;*&lt;/code&gt; 、または空でない場合は空）を記録するロックファイルTCPでリッスンする）、および共有メモリセグメントID（このファイルはサーバーのシャットダウン後は存在しません）</target>
        </trans-unit>
        <trans-unit id="66a4816dba1f7f218c3433fca4faabe3c13b10b2" translate="yes" xml:space="preserve">
          <source>A logical replication subscription can be a standby for synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;). The standby name is by default the subscription name. An alternative name can be specified as &lt;code&gt;application_name&lt;/code&gt; in the connection information of the subscription.</source>
          <target state="translated">論理複製サブスクリプションは、同期複製のスタンバイになることができます（&lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;セクション26.2.8を&lt;/a&gt;参照）。スタンバイ名は、デフォルトではサブスクリプション名です。サブスクリプションの接続情報で &lt;code&gt;application_name&lt;/code&gt; として代替名を指定できます。</target>
        </trans-unit>
        <trans-unit id="fcc633543c398580321199fbfe8326677176cedc" translate="yes" xml:space="preserve">
          <source>A logical replication worker will be started to replicate data for the new subscription at the commit of the transaction where this command is run.</source>
          <target state="translated">論理レプリケーションワーカーは、このコマンドが実行されるトランザクションのコミット時に、新しいサブスクリプションのデータをレプリケートするために開始されます。</target>
        </trans-unit>
        <trans-unit id="0ff838ef761258a1112513121456f0155f8255d4" translate="yes" xml:space="preserve">
          <source>A low-level description of an individual data change. It contains sufficient information for the data change to be re-executed (&lt;em&gt;replayed&lt;/em&gt;) in case a system failure causes the change to be lost. WAL records use a non-printable binary format.</source>
          <target state="translated">A low-level description of an individual data change. It contains sufficient information for the data change to be re-executed (&lt;em&gt;replayed&lt;/em&gt;) in case a system failure causes the change to be lost. WAL records use a non-printable binary format.</target>
        </trans-unit>
        <trans-unit id="60aa88a1c8ef8747220ad187c41c4e1174fc8b76" translate="yes" xml:space="preserve">
          <source>A master-standby replication setup sends all data modification queries to the master server. The master server asynchronously sends data changes to the standby server. The standby can answer read-only queries while the master server is running. The standby server is ideal for data warehouse queries.</source>
          <target state="translated">マスターとスタンバイのレプリケーション設定では、すべてのデータ変更クエリをマスターサーバーに送信します。マスターサーバーは、非同期的にデータ変更をスタンバイサーバーに送信します。スタンバイサーバーは、マスターサーバーが実行されている間、読み取り専用のクエリに応答することができます。スタンバイサーバーは、データウェアハウスのクエリに最適です。</target>
        </trans-unit>
        <trans-unit id="bb03b0cc86a8c8af01abf7c3fc42f075822f31ef" translate="yes" xml:space="preserve">
          <source>A means of identifying a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by values contained within one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in that relation.</source>
          <target state="translated">A means of identifying a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by values contained within one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in that relation.</target>
        </trans-unit>
        <trans-unit id="030845a8e99966136eb3e489c254a79843ff0977" translate="yes" xml:space="preserve">
          <source>A means of representing data that is not contained in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; so that it appears as if were in local &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table(s)&lt;/a&gt;. With a foreign data wrapper it is possible to define a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-SERVER&quot;&gt;foreign server&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;.</source>
          <target state="translated">A means of representing data that is not contained in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; so that it appears as if were in local &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table(s)&lt;/a&gt;. With a foreign data wrapper it is possible to define a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-SERVER&quot;&gt;foreign server&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5439dc35c023b011f3a3c74704c816d5906e3290" translate="yes" xml:space="preserve">
          <source>A means of restricting data in one &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-KEY&quot;&gt;foreign key&lt;/a&gt; so that it must have matching data in another &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="translated">A means of restricting data in one &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-KEY&quot;&gt;foreign key&lt;/a&gt; so that it must have matching data in another &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="90a6939174ae7d3834abe5ab38f570dcd2acae81" translate="yes" xml:space="preserve">
          <source>A mechanism by which large attributes of table rows are split and stored in a secondary table, called the &lt;em&gt;TOAST table&lt;/em&gt;. Each relation with large attributes has its own TOAST table.</source>
          <target state="translated">A mechanism by which large attributes of table rows are split and stored in a secondary table, called the &lt;em&gt;TOAST table&lt;/em&gt;. Each relation with large attributes has its own TOAST table.</target>
        </trans-unit>
        <trans-unit id="c0378f878c1722be034fadd027bbbb3d7983fc4d" translate="yes" xml:space="preserve">
          <source>A mechanism designed to allow several &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transactions&lt;/a&gt; to be reading and writing the same rows without one process causing other processes to stall. In PostgreSQL, MVCC is implemented by creating copies (&lt;em&gt;versions&lt;/em&gt;) of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; as they are modified; after transactions that can see the old versions terminate, those old versions need to be removed.</source>
          <target state="translated">A mechanism designed to allow several &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transactions&lt;/a&gt; to be reading and writing the same rows without one process causing other processes to stall. In PostgreSQL, MVCC is implemented by creating copies (&lt;em&gt;versions&lt;/em&gt;) of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; as they are modified; after transactions that can see the old versions terminate, those old versions need to be removed.</target>
        </trans-unit>
        <trans-unit id="19c544cc7b4fa2f30c5d33aa71e0de0990d629df" translate="yes" xml:space="preserve">
          <source>A mechanism that allows a process to limit or prevent simultaneous access to a resource.</source>
          <target state="translated">プロセスがリソースへの同時アクセスを制限したり、阻止したりすることができる仕組み。</target>
        </trans-unit>
        <trans-unit id="df6419859ed47f78b720bf1d7b110d267f1953f4" translate="yes" xml:space="preserve">
          <source>A message like:</source>
          <target state="translated">みたいなメッセージ。</target>
        </trans-unit>
        <trans-unit id="917ffeb96cdfecb3f8736cd3bea86dd56c48ad27" translate="yes" xml:space="preserve">
          <source>A minimal sequence for creating a new procedural language is:</source>
          <target state="translated">新しい手続き型言語を作成するための最低限のシーケンスです。</target>
        </trans-unit>
        <trans-unit id="f0390b8c07f298b04ffb62c09de627ab67ceed13" translate="yes" xml:space="preserve">
          <source>A modified version of shared hardware functionality is file system replication, where all changes to a file system are mirrored to a file system residing on another computer. The only restriction is that the mirroring must be done in a way that ensures the standby server has a consistent copy of the file system &amp;mdash; specifically, writes to the standby must be done in the same order as those on the master. DRBD is a popular file system replication solution for Linux.</source>
          <target state="translated">共有ハードウェア機能の変更されたバージョンはファイルシステムレプリケーションです。ファイルシステムへのすべての変更は、別のコンピューターにあるファイルシステムにミラーリングされます。唯一の制限は、スタンバイサーバーがファイルシステムの一貫したコピーを保持できるようにミラーリングを実行する必要があることです。具体的には、スタンバイへの書き込みはマスター上の書き込みと同じ順序で実行する必要があります。DRBDは、Linux向けの一般的なファイルシステムレプリケーションソリューションです。</target>
        </trans-unit>
        <trans-unit id="eaf74e8b7bd2011db8b23c31e08c4d8c5dc7b496" translate="yes" xml:space="preserve">
          <source>A more complete example, which is directly useful for most European languages, can be found in &lt;code&gt;unaccent.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; when the &lt;code&gt;unaccent&lt;/code&gt; module is installed. This rules file translates characters with accents to the same characters without accents, and it also expands ligatures into the equivalent series of simple characters (for example, &amp;AElig; to AE).</source>
          <target state="translated">ほとんどのヨーロッパ言語の直接役立つ、より完全な例は、で見つけることができ &lt;code&gt;unaccent.rules&lt;/code&gt; にインストールされ、 &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; &lt;code&gt;unaccent&lt;/code&gt; モジュールがインストールされています。このルールファイルは、アクセントのある文字をアクセントのない同じ文字に変換し、合字を同等の一連の単純な文字（&amp;AElig;からAEなど）に拡張します。</target>
        </trans-unit>
        <trans-unit id="e62513d51117a7629a102ebbc4e62bd57c604e14" translate="yes" xml:space="preserve">
          <source>A more complex example is to select the ten most recent documents that contain &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; in the &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt;:</source>
          <target state="translated">より複雑な例は、 &lt;code&gt;title&lt;/code&gt; または &lt;code&gt;body&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; および &lt;code&gt;table&lt;/code&gt; を含む最新の10個のドキュメントを選択することです。</target>
        </trans-unit>
        <trans-unit id="a65faa0d2e1360aa9fc34743f49ee685ce803abe" translate="yes" xml:space="preserve">
          <source>A more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creating &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;. Another possibility is to create rules (see &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;), but in practice triggers are easier to understand and use correctly.</source>
          <target state="translated">これらの条件をすべて満たさないより複雑なビューは、デフォルトでは読み取り専用です。システムは、ビューの挿入、更新、または削除を許可しません。ビューで &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガーを作成することにより、更新可能なビューの効果を得ることができます。これにより、ビューで試行された挿入などを他のテーブルでの適切なアクションに変換する必要があります。詳細については、「&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;」を参照してください。もう1つの可能性はルールを作成することです（&lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULEを&lt;/a&gt;参照）が、実際にはトリガーの方が理解しやすく、正しく使用できます。</target>
        </trans-unit>
        <trans-unit id="21c69ec8617bd0a23e27b4a22f876578e2ac2724" translate="yes" xml:space="preserve">
          <source>A multicharacter operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">名前に次の文字の少なくとも1つが含まれていない限り、複数文字の演算子名の末尾を &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; にすることはできません。</target>
        </trans-unit>
        <trans-unit id="763ddc64feb8cdfed8680a02b945f082cacaa6b2" translate="yes" xml:space="preserve">
          <source>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on &lt;code&gt;(a, b, c)&lt;/code&gt; and a query condition &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt;, the index would have to be scanned from the first entry with &lt;code&gt;a&lt;/code&gt; = 5 and &lt;code&gt;b&lt;/code&gt; = 42 up through the last entry with &lt;code&gt;a&lt;/code&gt; = 5. Index entries with &lt;code&gt;c&lt;/code&gt; &amp;gt;= 77 would be skipped, but they'd still have to be scanned through. This index could in principle be used for queries that have constraints on &lt;code&gt;b&lt;/code&gt; and/or &lt;code&gt;c&lt;/code&gt; with no constraint on &lt;code&gt;a&lt;/code&gt; &amp;mdash; but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</source>
          <target state="translated">複数列のBツリーインデックスは、インデックスの列のサブセットを含むクエリ条件で使用できますが、先頭（左端）の列に制約がある場合に最も効率的です。正確なルールは、先行列の等価制約と、等価制約のない最初の列の不等制約を使用して、スキャンされるインデックスの部分を制限することです。これらの列の右側の列に対する制約はインデックスでチェックされるため、適切なテーブルへのアクセスが保存されますが、スキャンする必要のあるインデックスの部分は削減されません。例えば、上のインデックス指定された &lt;code&gt;(a, b, c)&lt;/code&gt; と検索条件 &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt; 、インデックスが持つ最初のエントリから走査されなければならない &lt;code&gt;a&lt;/code&gt; = 5と &lt;code&gt;b&lt;/code&gt; との最後のエントリを通じて= 42までと= 5インデックスエントリ &lt;code&gt;c&lt;/code&gt; &amp;gt; = 77はスキップされますが、彼らはまだを通じてスキャンする必要があるだろう。このインデックスは、原理的には上の制約が持っているクエリに使用することができ &lt;code&gt;b&lt;/code&gt; および/または &lt;code&gt;c&lt;/code&gt; 上の制約なしで-しかし、インデックス全体をスキャンする必要がありますので、ほとんどの場合、プランナはインデックスを使用しての上に、順次テーブルスキャンを好むだろう。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc5434281e629991ee555ca6201f316515a8d25" translate="yes" xml:space="preserve">
          <source>A multicolumn BRIN index can be used with query conditions that involve any subset of the index's columns. Like GIN and unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use. The only reason to have multiple BRIN indexes instead of one multicolumn BRIN index on a single table is to have a different &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter.</source>
          <target state="translated">マルチカラムBRINインデックスは、インデックスのカラムのサブセットを含むクエリ条件で使用できます。GINと同様に、BツリーやGiSTとは異なり、インデックス検索の有効性は、クエリ条件が使用するインデックス列に関係なく同じです。単一のテーブルで1つのマルチカラムBRINインデックスではなく複数のBRINインデックスを使用する唯一の理由は、異なる &lt;code&gt;pages_per_range&lt;/code&gt; ストレージパラメータを使用することです。</target>
        </trans-unit>
        <trans-unit id="04d3a962116670f39174cfb6d475fa11fdc7b880" translate="yes" xml:space="preserve">
          <source>A multicolumn GIN index can be used with query conditions that involve any subset of the index's columns. Unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use.</source>
          <target state="translated">マルチカラムGINインデックスは、インデックスのカラムの任意のサブセットを含むクエリ条件で使用することができます。B-treeやGiSTとは異なり、クエリ条件がどのインデックス列を使用するかに関わらず、インデックス検索の有効性は同じです。</target>
        </trans-unit>
        <trans-unit id="a40f443a6350a7a3a7b742a42955a0061cf6840b" translate="yes" xml:space="preserve">
          <source>A multicolumn GiST index can be used with query conditions that involve any subset of the index's columns. Conditions on additional columns restrict the entries returned by the index, but the condition on the first column is the most important one for determining how much of the index needs to be scanned. A GiST index will be relatively ineffective if its first column has only a few distinct values, even if there are many distinct values in additional columns.</source>
          <target state="translated">複数列のGiSTインデックスは、インデックスの列の任意のサブセットを含む問い合わせ条件で使用することができます。追加の列に対する条件は、インデックスが返すエントリを制限しますが、最初の列に対する条件は、インデックスのスキャンの必要性を決定する上で最も重要なものです。GiSTインデックスは、追加の列に多くの異なる値があったとしても、最初の列が少数の異なる値しか持っていない場合には、相対的に効果がありません。</target>
        </trans-unit>
        <trans-unit id="61e3a968ac084ffcdbf2ee57ee023225a4c61ed4" translate="yes" xml:space="preserve">
          <source>A multiple-character operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">複数文字の演算子名の最後に &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; を付けることはできません。ただし、名前に次の文字が少なくとも1つ含まれている場合を除きます。</target>
        </trans-unit>
        <trans-unit id="c34267e8f8081ad131049e90185ef07a4a593a2c" translate="yes" xml:space="preserve">
          <source>A name (without schema qualification) must be specified for each &lt;code&gt;WITH&lt;/code&gt; query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; クエリごとに名前（スキーマ修飾なし）を指定する必要があります。オプションで、列名のリストを指定できます。これを省略した場合、列名はサブクエリから推測されます。</target>
        </trans-unit>
        <trans-unit id="6bf463ff31beb31d0372f0b1e73503dfa89eeca4" translate="yes" xml:space="preserve">
          <source>A name to use for a returned column.</source>
          <target state="translated">返されたカラムに使用する名前。</target>
        </trans-unit>
        <trans-unit id="272bf486701f1c7737a7b79a5df1a6cc7e2d076e" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt; which all use the same &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt; and have other configuration values in common.</source>
          <target state="translated">A named collection of &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt; which all use the same &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt; and have other configuration values in common.</target>
        </trans-unit>
        <trans-unit id="39c6fcfc35cb51a17f46343c3f38d154442e2627" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;local SQL objects&lt;/a&gt;.</source>
          <target state="translated">A named collection of &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;local SQL objects&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="14bebfb5283ed66820e63249347863d7698ec1a3" translate="yes" xml:space="preserve">
          <source>A named location on the server file system. All &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; which require storage beyond their definition in the &lt;a href=&quot;glossary#GLOSSARY-SYSTEM-CATALOG&quot;&gt;system catalog&lt;/a&gt; must belong to a single tablespace. Initially, a database cluster contains a single usable tablespace which is used as the default for all SQL objects, called &lt;code&gt;pg_default&lt;/code&gt;.</source>
          <target state="translated">A named location on the server file system. All &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; which require storage beyond their definition in the &lt;a href=&quot;glossary#GLOSSARY-SYSTEM-CATALOG&quot;&gt;system catalog&lt;/a&gt; must belong to a single tablespace. Initially, a database cluster contains a single usable tablespace which is used as the default for all SQL objects, called &lt;code&gt;pg_default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c05611b43715c57dcc82e9a73dc2d7f3d8e3a806" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions. See &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; and its notes for details.</source>
          <target state="translated">名前付き変数。その値は、いくつかのJSON処理関数のパラメーター&lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt;によって設定できます。詳細については、&lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;表9.47&lt;/a&gt;とその注記を参照してください。</target>
        </trans-unit>
        <trans-unit id="74fdd4598f86747d21b59f0ff46b91f71c06f897" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions; see &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; for details.</source>
          <target state="translated">A named variable. Its value can be set by the parameter &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; of several JSON processing functions; see &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="a91a5ad7df4feb45e2e64cef1252fbd5ff25b557" translate="yes" xml:space="preserve">
          <source>A new database object basically inherits the security label of the parent object, except when the security policy has special rules known as type-transition rules, in which case a different label may be applied. For schemas, the parent object is the current database; for tables, sequences, views, and functions, it is the containing schema; for columns, it is the containing table.</source>
          <target state="translated">新しいデータベースオブジェクトは基本的に親オブジェクトのセキュリティラベルを継承しますが、セキュリティポリシーにタイプ遷移ルールとして知られる特別なルールがある場合は別のラベルが適用されることがあります。スキーマの場合、親オブジェクトは現在のデータベースであり、テーブル、シーケンス、ビュー、関数の場合、それは含まれるスキーマであり、カラムの場合、それは含まれるテーブルです。</target>
        </trans-unit>
        <trans-unit id="a69d7af9d66bab695fb9262e5704599a7bd6821d" translate="yes" xml:space="preserve">
          <source>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;.)</source>
          <target state="translated">インデックスエントリを作成する前に、新しいヒープエントリが作成されます。（したがって、同時インデックススキャンではヒープエントリが表示されない可能性があります。インデックスリーダーがコミットされていない行に関係ないため、これは問題ありません。ただし、&lt;a href=&quot;index-unique-checks&quot;&gt;61.5項を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="e9bfb94dcc9a12b2e365d8f54e18e6c8a60beb96" translate="yes" xml:space="preserve">
          <source>A new random session key is generated.</source>
          <target state="translated">新しいランダムセッションキーが生成されます。</target>
        </trans-unit>
        <trans-unit id="cd5509bd2e57840414a4b31d4dcfe1a53cd60297" translate="yes" xml:space="preserve">
          <source>A new temporary index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">新しい一時インデックス定義がカタログ &lt;code&gt;pg_index&lt;/code&gt; に追加されます。この定義は、古いインデックスを置き換えるために使用されます。A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; のセッション・レベルでのロックが処理中に任意のスキーマの変更を防止するだけでなく、としてそれらに関連するテーブルを索引が再作成されたインデックスに取り込まれます。</target>
        </trans-unit>
        <trans-unit id="e67b7984583e1c4ea079d2de00a7015a2704c63b" translate="yes" xml:space="preserve">
          <source>A new transient index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">A new transient index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt; . This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</target>
        </trans-unit>
        <trans-unit id="10ddb11c7f41b9fc173a0daee9b22a0046a88a72" translate="yes" xml:space="preserve">
          <source>A non-XML result assigned to an &lt;code&gt;xml&lt;/code&gt; output column produces content, a single text node with the string value of the result. An XML result assigned to a column of any other type may not have more than one node, or an error is raised. If there is exactly one node, the column will be set as if by assigning the node's string value (as defined for the XPath 1.0 &lt;code&gt;string&lt;/code&gt; function) to the PostgreSQL type.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 出力列に割り当てられた非XML結果は、結果の文字列値を持つ単一のテキストノードであるコンテンツを生成します。他のタイプの列に割り当てられたXML結果は、複数のノードを持つことができないか、エラーが発生します。ノードが1つだけの場合、列は、ノードの文字列値（XPath 1.0 &lt;code&gt;string&lt;/code&gt; 関数で定義されている）をPostgreSQLタイプに割り当てるかのように設定されます。</target>
        </trans-unit>
        <trans-unit id="473219c281a2d874786237c92b0fcf8169682ead" translate="yes" xml:space="preserve">
          <source>A non-exclusive low level backup is one that allows other concurrent backups to be running (both those started using the same backup API and those started using &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;).</source>
          <target state="translated">非排他的な低レベルのバックアップは、他の同時バックアップの実行を許可するものです（同じバックアップAPIを使用して開始されたものと&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;を使用して開始されたものの両方）。</target>
        </trans-unit>
        <trans-unit id="401550561965c2499f16ad6fd4b31c047d5f304a" translate="yes" xml:space="preserve">
          <source>A normal relationship between separately-created objects. The dependent object can be dropped without affecting the referenced object. The referenced object can only be dropped by specifying &lt;code&gt;CASCADE&lt;/code&gt;, in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type.</source>
          <target state="translated">個別に作成されたオブジェクト間の通常の関係。依存オブジェクトは、参照されるオブジェクトに影響を与えることなく削除できます。参照されるオブジェクトは、 &lt;code&gt;CASCADE&lt;/code&gt; を指定することによってのみドロップできます。この場合、依存オブジェクトもドロップされます。例：テーブルの列は、そのデータ型に通常依存しています。</target>
        </trans-unit>
        <trans-unit id="f4e6fa0c13024f923c36983ca255cb802f2a15dc" translate="yes" xml:space="preserve">
          <source>A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt;, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.</source>
          <target state="translated">null以外の制約は、常に列制約として記述されます。非null制約は機能的にはチェック制約 &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt; を作成することと同じですが、PostgreSQLでは明示的な非null制約を作成する方が効率的です。欠点は、この方法で作成されたnull以外の制約に明示的な名前を付けることができないことです。</target>
        </trans-unit>
        <trans-unit id="29e3f0f63dd403df874ec2bd2e2e99cfcbefc40b" translate="yes" xml:space="preserve">
          <source>A not-null constraint simply specifies that a column must not assume the null value. A syntax example:</source>
          <target state="translated">not-null 制約は、列が NULL 値を想定してはならないことを単純に指定します。構文の例。</target>
        </trans-unit>
        <trans-unit id="38f215d8dff9a872adcc025cd248723a7de60a09" translate="yes" xml:space="preserve">
          <source>A number of probes or trace points are already inserted into the source code. These probes are intended to be used by database developers and administrators. By default the probes are not compiled into PostgreSQL; the user needs to explicitly tell the configure script to make the probes available.</source>
          <target state="translated">多くのプローブやトレースポイントがすでにソースコードに挿入されています。これらのプローブは、データベース開発者や管理者が使用することを意図しています。デフォルトでは、プローブはPostgreSQLにコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="62bf9b2e29dd2eab9640de99e0e28efaa651fde7" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.28&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.29&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">&lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;表27.28に&lt;/a&gt;示すように、いくつかの標準プローブがソースコードで提供されています。&lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;表27.29&lt;/a&gt;は、プローブで使用されるタイプを示しています。 PostgreSQLの可観測性を高めるために、さらに多くのプローブを追加することができます。</target>
        </trans-unit>
        <trans-unit id="ae551e6f1a5e0e884b3ccb3cbfaaaffb2764ba8e" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.42&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.43&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.42&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.43&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</target>
        </trans-unit>
        <trans-unit id="83f77be94ef3c8feb2e598e753ef0750ef27c239" translate="yes" xml:space="preserve">
          <source>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</source>
          <target state="translated">これらの変数の多くはpsqlによって特別に扱われます。これらは、実行時に変数の値を変更することで変更できる特定のオプション設定を表しています。規約では、特別に扱われる変数の名前はすべて大文字のASCII文字(場合によっては数字とアンダースコア)で構成されています。将来的に最大限の互換性を確保するために、そのような変数名の使用は避けてください。</target>
        </trans-unit>
        <trans-unit id="9671dc450d1031cf1ea5da7434a9e12abf1e8725" translate="yes" xml:space="preserve">
          <source>A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type &lt;code&gt;integer&lt;/code&gt; if its value fits in type &lt;code&gt;integer&lt;/code&gt; (32 bits); otherwise it is presumed to be type &lt;code&gt;bigint&lt;/code&gt; if its value fits in type &lt;code&gt;bigint&lt;/code&gt; (64 bits); otherwise it is taken to be type &lt;code&gt;numeric&lt;/code&gt;. Constants that contain decimal points and/or exponents are always initially presumed to be type &lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">小数点も指数も含まない数値定数は、その値が &lt;code&gt;integer&lt;/code&gt; 型（32ビット）に収まる場合、最初は &lt;code&gt;integer&lt;/code&gt; 型であると見なされます。そうでない場合は、タイプであると推定される &lt;code&gt;bigint&lt;/code&gt; 型で、その値収まる場合 &lt;code&gt;bigint&lt;/code&gt; （64ビット）。それ以外の場合は、 &lt;code&gt;numeric&lt;/code&gt; 型と見なされます。小数点や指数を含む定数は、常に最初は &lt;code&gt;numeric&lt;/code&gt; 型であると想定されています。</target>
        </trans-unit>
        <trans-unit id="28053ae7864d70a55d085c051398ee367a8ba696" translate="yes" xml:space="preserve">
          <source>A numeric constant that specifies the length in bytes of the new type's internal representation. The default assumption is that it is variable-length.</source>
          <target state="translated">新しい型の内部表現の長さをバイト単位で指定する数値定数。デフォルトでは可変長であることが前提となっています。</target>
        </trans-unit>
        <trans-unit id="458377c420bfcead4a575e16d3cb5a525edf744e" translate="yes" xml:space="preserve">
          <source>A one-dimensional interval starting at &lt;code&gt;x&lt;/code&gt; and ending at &lt;code&gt;y&lt;/code&gt; or vice versa; the order does not matter</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; で始まり、 &lt;code&gt;y&lt;/code&gt; で終わる、またはその逆の1次元の間隔。順序は関係ありません</target>
        </trans-unit>
        <trans-unit id="258b20d113a4ac0002010f6811f02c8de89d74bf" translate="yes" xml:space="preserve">
          <source>A one-dimensional point (or, zero-length one-dimensional interval)</source>
          <target state="translated">一次元点(または、ゼロ長一次元区間</target>
        </trans-unit>
        <trans-unit id="bc1071526f0987dbc584cef038787a5b04285bb1" translate="yes" xml:space="preserve">
          <source>A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; で取得したページ画像を引数として渡す必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="5d8915a6b0933e1f5dc0f9cee0ae40fe953639a8" translate="yes" xml:space="preserve">
          <source>A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the &lt;code&gt;CASCADE&lt;/code&gt; option (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">親テーブルは、子が残っている間は削除できません。親テーブルから継承されている場合、子テーブルの列やチェック制約を削除または変更することもできません。テーブルとそのすべての子孫を削除する場合、簡単な方法の1つは &lt;code&gt;CASCADE&lt;/code&gt; オプションを使用して親テーブルを削除することです（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b87d25eb2f25d2d484b24b9f4a15020854de03d4" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this foreign table.</source>
          <target state="translated">この外部テーブルとの関連付けまたは関連付けを解除する親テーブル。</target>
        </trans-unit>
        <trans-unit id="9038188b4e1e4e207e5656bab49c0b4bbe2840fb" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this table.</source>
          <target state="translated">このテーブルとの関連付けや関連付けを解除する親テーブル。</target>
        </trans-unit>
        <trans-unit id="bef9303e674e1152b39759a3ac4a051765f051a5" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition.</source>
          <target state="translated">パーティションには、それが属するパーティションテーブルと同じ列名と型が必要です。パーティションテーブルの列名またはタイプを変更すると、すべてのパーティションに自動的に反映されます。 &lt;code&gt;CHECK&lt;/code&gt; 制約はすべてのパーティションに自動的に継承されますが、個々のパーティションでは追加の &lt;code&gt;CHECK&lt;/code&gt; 制約を指定できます。親と同じ名前と条件を持つ追加の制約は、親制約とマージされます。デフォルトは、パーティションごとに個別に指定できます。</target>
        </trans-unit>
        <trans-unit id="2b0fee0af770b0e2b7c1779ad6d02cf3f6e73981" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.</source>
          <target state="translated">A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.</target>
        </trans-unit>
        <trans-unit id="753a83c5b7fc1757da85bcf15b0058b4367b5ffe" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached are marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached are marked &lt;code&gt;NO INHERIT&lt;/code&gt; , the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</target>
        </trans-unit>
        <trans-unit id="2265efb683514f071f0b16aed28cd3bcc5853f6a" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached is marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">使用してパーティション &lt;code&gt;FOR VALUES&lt;/code&gt; のために同じ構文を使用します。 &lt;code&gt;partition_bound_spec&lt;/code&gt; を通り&lt;a href=&quot;sql-createtable&quot;&gt;、CREATE TABLE&lt;/a&gt;。パーティションバインド仕様は、ターゲットテーブルのパーティション化戦略とパーティションキーに対応している必要があります。アタッチされるテーブルには、ターゲットテーブルと同じ列がすべて含まれている必要があります。さらに、列タイプも一致する必要があります。また、ターゲットテーブルのすべての &lt;code&gt;NOT NULL&lt;/code&gt; および &lt;code&gt;CHECK&lt;/code&gt; 制約が必要です。現在、 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 制約は考慮されていません。親テーブルの &lt;code&gt;UNIQUE&lt;/code&gt; および &lt;code&gt;PRIMARY KEY&lt;/code&gt; 制約がまだ存在しない場合は、パーティションに作成されます。 &lt;code&gt;CHECK&lt;/code&gt; いずれかアタッチされるテーブルの制約が &lt;code&gt;NO INHERIT&lt;/code&gt; とマークされている場合、コマンドは失敗します。このような制約は、 &lt;code&gt;NO INHERIT&lt;/code&gt; 句なしで再作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="02bfa1f4284b2b7254a60122f0ece5c14ca3baa1" translate="yes" xml:space="preserve">
          <source>A partitioned table is divided into sub-tables (called partitions), which are created using separate &lt;code&gt;CREATE TABLE&lt;/code&gt; commands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.</source>
          <target state="translated">パーティションテーブルはサブテーブル（パーティションと呼ばれます）に分割されます。サブテーブルは、個別の &lt;code&gt;CREATE TABLE&lt;/code&gt; コマンドを使用して作成されます。分割テーブル自体は空です。テーブルに挿入されたデータ行は、パーティションキーの列または式の値に基づいてパーティションにルーティングされます。新しい行の値と一致する既存のパーティションがない場合、エラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="47bfb6365d874606167f5297b7825760e1b94998" translate="yes" xml:space="preserve">
          <source>A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;md5&lt;/code&gt; authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt;.</source>
          <target state="translated">クライアント認証方法でユーザーがデータベースに接続するときにパスワードを入力する必要がある場合にのみ、パスワードは重要です。 &lt;code&gt;password&lt;/code&gt; および &lt;code&gt;md5&lt;/code&gt; 認証方式は、パスワードを使用しています。データベースのパスワードは、オペレーティングシステムのパスワードとは別のものです。 &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt; を使用して、ロールの作成時にパスワードを指定します。</target>
        </trans-unit>
        <trans-unit id="35958631e7f174f767add77cc9815bb09387d918" translate="yes" xml:space="preserve">
          <source>A password that does not follow either of those formats is assumed to be unencrypted.</source>
          <target state="translated">これらの形式のいずれにも従わないパスワードは、暗号化されていないものとみなされます。</target>
        </trans-unit>
        <trans-unit id="ab9b8b43d3aed0e06f19d1971e9a5e5fb76320e8" translate="yes" xml:space="preserve">
          <source>A path expression can be a Boolean predicate, although the SQL/JSON standard allows predicates only in filters. This is necessary for implementation of the &lt;code&gt;@@&lt;/code&gt; operator. For example, the following &lt;code&gt;jsonpath&lt;/code&gt; expression is valid in PostgreSQL:</source>
          <target state="translated">パス式はブール述語にすることができますが、SQL / JSON標準では述語をフィルターでのみ使用できます。これは、 &lt;code&gt;@@&lt;/code&gt; 演算子の実装に必要です。たとえば、次の &lt;code&gt;jsonpath&lt;/code&gt; 式はPostgreSQLで有効です。</target>
        </trans-unit>
        <trans-unit id="630b9b00d6c7d46f1803db83394a9ee4f3b0c93b" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of SQL/JSON items (&lt;em&gt;SQL/JSON sequence&lt;/em&gt;) is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">パス式は、 &lt;code&gt;jsonpath&lt;/code&gt; データ型で許可されている一連の要素で構成されます。パス式は左から右に評価されますが、括弧を使用して操作の順序を変更できます。評価が成功すると、一連のSQL / JSONアイテム（&lt;em&gt;SQL / JSONシーケンス&lt;/em&gt;）が生成され、評価結果が、指定された計算を完了するJSONクエリ関数に返されます。</target>
        </trans-unit>
        <trans-unit id="87f4c54faa8f7479fd0c8926b062c01e3b7b2498" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is normally evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of JSON items is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is normally evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of JSON items is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</target>
        </trans-unit>
        <trans-unit id="419a53a9c84f96a1644ee859a8c3c016a2c745c2" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be any of the following:</source>
          <target state="translated">パス式は、パス要素のシーケンスから構成され、以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="5b906a3261066476a4e478667be529d451288613" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be the following:</source>
          <target state="translated">パス式は、パス要素のシーケンスで構成されており、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="46a75a9a8ee3f1ff5de45744e068475e9be0d81b" translate="yes" xml:space="preserve">
          <source>A pattern that contains a dot (&lt;code&gt;.&lt;/code&gt;) is interpreted as a schema name pattern followed by an object name pattern. For example, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; displays all tables whose table name includes &lt;code&gt;bar&lt;/code&gt; that are in schemas whose schema name starts with &lt;code&gt;foo&lt;/code&gt;. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally.</source>
          <target state="translated">ドット（ &lt;code&gt;.&lt;/code&gt; ）を含むパターンは、スキーマ名パターンとして解釈され、その後にオブジェクト名パターンが続きます。たとえば、 &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; は、スキーマ名が &lt;code&gt;foo&lt;/code&gt; で始まるスキーマにある、テーブル名に &lt;code&gt;bar&lt;/code&gt; を含むすべてのテーブルを表示します。ドットが表示されない場合、パターンは現在のスキーマ検索パスに表示されているオブジェクトのみに一致します。この場合も、二重引用符内のドットは特別な意味を失い、文字通り一致します。</target>
        </trans-unit>
        <trans-unit id="e2fdd324df9af943d98a0446644b1732be556666" translate="yes" xml:space="preserve">
          <source>A physical file which stores data for a given &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. File segments are limited in size by a configuration value (typically 1 gigabyte), so if a relation exceeds that size, it is split into multiple segments.</source>
          <target state="translated">A physical file which stores data for a given &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. File segments are limited in size by a configuration value (typically 1 gigabyte), so if a relation exceeds that size, it is split into multiple segments.</target>
        </trans-unit>
        <trans-unit id="5474357c1efadc094c42e8ca5e1d158c9c8724d2" translate="yes" xml:space="preserve">
          <source>A plain integer denotes a day of the year, counting from zero to 364, or to 365 in leap years.</source>
          <target state="translated">単純な整数は1年の1日を表し、0から364まで、うるう年では365まで数えます。</target>
        </trans-unit>
        <trans-unit id="7897c4bbe5ec9cccaaddf1f6c43de7d3f2aaad08" translate="yes" xml:space="preserve">
          <source>A point in n-dimensional space, represented internally as a zero-volume cube</source>
          <target state="translated">n次元空間の点で、内部的にはゼロ体積の立方体として表されます。</target>
        </trans-unit>
        <trans-unit id="45445178529cbc6647ad679b1b5ca9fd7c3a49b9" translate="yes" xml:space="preserve">
          <source>A point in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; sequence at which it is guaranteed that the heap and index data files have been updated with all information from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; modified before that checkpoint; a &lt;em&gt;checkpoint record&lt;/em&gt; is written and flushed to WAL to mark that point.</source>
          <target state="translated">A point in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; sequence at which it is guaranteed that the heap and index data files have been updated with all information from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; modified before that checkpoint; a &lt;em&gt;checkpoint record&lt;/em&gt; is written and flushed to WAL to mark that point.</target>
        </trans-unit>
        <trans-unit id="b4b7209c416eb8b0cd4ad3c6e895e2f5e59edbd1" translate="yes" xml:space="preserve">
          <source>A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression. Existing table rows are checked against the expression specified in &lt;code&gt;USING&lt;/code&gt;, while new rows that would be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; are checked against the expression specified in &lt;code&gt;WITH CHECK&lt;/code&gt;. When a &lt;code&gt;USING&lt;/code&gt; expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible. When a &lt;code&gt;WITH CHECK&lt;/code&gt; expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs.</source>
          <target state="translated">ポリシーは、関連するポリシー式に一致する行を選択、挿入、更新、または削除する権限を付与します。既存のテーブル行は &lt;code&gt;USING&lt;/code&gt; で指定された式に対してチェックされますが、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; を介して作成される新しい行は &lt;code&gt;WITH CHECK&lt;/code&gt; で指定された式に対してチェックされます。場合 &lt;code&gt;USING&lt;/code&gt; 式は次いで、所与の行に対して真を返し偽またはnullが返された場合、行が表示されていないながら行は、ユーザに表示されること。場合 &lt;code&gt;WITH CHECK&lt;/code&gt; 式が偽またはnullが返された場合、エラーが発生している間、行が挿入または更新されることをその行のために真を返します。</target>
        </trans-unit>
        <trans-unit id="f8e613dc0d26e68918f83658070562d9898412d1" translate="yes" xml:space="preserve">
          <source>A position normally indicates the source word's location in the document. Positional information can be used for &lt;em&gt;proximity ranking&lt;/em&gt;. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.</source>
          <target state="translated">位置は通常、ドキュメント内のソースワードの場所を示します。位置情報は&lt;em&gt;近接ランキングに&lt;/em&gt;使用できます。位置の値の範囲は1〜16383です。大きな数は黙って16383に設定されます。同じ語彙素の重複した位置は破棄されます。</target>
        </trans-unit>
        <trans-unit id="8124e08cb675a3763a841977baebeafd4db084c2" translate="yes" xml:space="preserve">
          <source>A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:</source>
          <target state="translated">位置パラメータ参照は、SQL文に外部から供給される値を示すために使用されます。パラメータはSQL関数の定義や準備されたクエリで使用されます。クライアントライブラリの中には、SQLコマンド文字列とは別にデータ値の指定をサポートしているものもあり、その場合、パラメータは行外のデータ値を参照するために使用されます。パラメータ参照の形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3833bdb7ea9a948094cad484b196a53403718838" translate="yes" xml:space="preserve">
          <source>A positional parameter reference, in the body of a function definition or prepared statement</source>
          <target state="translated">関数定義または準備された文の本文にある位置パラメータの参照</target>
        </trans-unit>
        <trans-unit id="0f115ce95e27f153df6502e75df85ece7a17f10c" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated execution cost for the function, in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;. If the function returns a set, this is the cost per returned row. If the cost is not specified, 1 unit is assumed for C-language and internal functions, and 100 units for functions in all other languages. Larger values cause the planner to try to avoid evaluating the function more often than necessary.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_costの&lt;/a&gt;単位で関数の推定実行コストを示す正の数。関数がセットを返す場合、これは返される行ごとのコストです。コストが指定されていない場合、C言語および内部関数の場合は1ユニット、他のすべての言語の関数の場合は100ユニットが想定されます。値が大きいと、プランナは必要以上に頻繁に関数を評価しないようにします。</target>
        </trans-unit>
        <trans-unit id="30c1a79cbb9484177e363d4544efe87e3e39ffa7" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.</source>
          <target state="translated">プランナがこの関数が返すと予想される行数を表す正の数値.これは、関数が集合を返すと宣言されている場合にのみ許可されます。デフォルトでは1000行を想定しています。</target>
        </trans-unit>
        <trans-unit id="02f79e462db5425b448e96c1072a3f594c31942d" translate="yes" xml:space="preserve">
          <source>A possible query to use this index would be:</source>
          <target state="translated">このインデックスを使用する可能性のあるクエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a46068a086ffe6678122c2b4a804a11dab670aaa" translate="yes" xml:space="preserve">
          <source>A prepared statement can be executed with either a &lt;em&gt;generic plan&lt;/em&gt; or a &lt;em&gt;custom plan&lt;/em&gt;. A generic plan is the same across all executions, while a custom plan is generated for a specific execution using the parameter values given in that call. Use of a generic plan avoids planning overhead, but in some situations a custom plan will be much more efficient to execute because the planner can make use of knowledge of the parameter values. (Of course, if the prepared statement has no parameters, then this is moot and a generic plan is always used.)</source>
          <target state="translated">準備済みステートメントは、&lt;em&gt;汎用プラン&lt;/em&gt;または&lt;em&gt;カスタムプラン&lt;/em&gt;で実行できます。汎用プランはすべての実行で同じですが、カスタムプランは、その呼び出しで指定されたパラメーター値を使用して特定の実行に対して生成されます。一般的な計画を使用すると、計画のオーバーヘッドを回避できますが、状況によっては、プランナがパラメータ値の知識を利用できるため、カスタム計画を実行する方がはるかに効率的です。（もちろん、準備されたステートメントにパラメーターがない場合、これは無意味であり、一般的な計画が常に使用されます。）</target>
        </trans-unit>
        <trans-unit id="13348ea1ec457fbeed4d2620cc50c2e7f85fa0ae" translate="yes" xml:space="preserve">
          <source>A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:</source>
          <target state="translated">主キー制約は、テーブル内の行の一意の識別子として、ある列または列のグループを使用できることを示します。これは、値が一意であり、NULLではないことを要求します。したがって、以下の2つのテーブル定義は、同じデータを受け入れます。</target>
        </trans-unit>
        <trans-unit id="3f893762c520af1aa49b543485b038d4cb74971c" translate="yes" xml:space="preserve">
          <source>A procedural language call handler is declared to return &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">手続き型言語の呼び出しハンドラは、 &lt;code&gt;language_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="85b471a8bbdcb0184dcaf026b542b9d1c7608b3f" translate="yes" xml:space="preserve">
          <source>A process that saves copies of &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt; for the purpose of creating backups or keeping &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replicas&lt;/a&gt; current.</source>
          <target state="translated">A process that saves copies of &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt; for the purpose of creating backups or keeping &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replicas&lt;/a&gt; current.</target>
        </trans-unit>
        <trans-unit id="68348e6f47688291dbdf76ea9ce04384d5ed5818" translate="yes" xml:space="preserve">
          <source>A process that writes &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="translated">A process that writes &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="df87a47e5d11566e3968df708fe83a96d24cbb48" translate="yes" xml:space="preserve">
          <source>A process that writes dirty &lt;a href=&quot;glossary#GLOSSARY-DATA-PAGE&quot;&gt;data pages&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to the file system. It wakes up periodically, but works only for a short period in order to distribute its expensive I/O activity over time to avoid generating larger I/O peaks which could block other processes.</source>
          <target state="translated">A process that writes dirty &lt;a href=&quot;glossary#GLOSSARY-DATA-PAGE&quot;&gt;data pages&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to the file system. It wakes up periodically, but works only for a short period in order to distribute its expensive I/O activity over time to avoid generating larger I/O peaks which could block other processes.</target>
        </trans-unit>
        <trans-unit id="b598946555659e8de8862e7df2ae169d900a0d4a" translate="yes" xml:space="preserve">
          <source>A publication can only be dropped by its owner or a superuser.</source>
          <target state="translated">出版物は、その所有者またはスーパーユーザによってのみ削除することができます。</target>
        </trans-unit>
        <trans-unit id="ba53206c029e2edfae51f727e267685bcdf05085" translate="yes" xml:space="preserve">
          <source>A publication is created using the &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; command and may later be altered or dropped using corresponding commands.</source>
          <target state="translated">&lt;a href=&quot;sql-createpublication&quot;&gt;パブリケーション&lt;/a&gt;はCREATE PUBLICATIONコマンドを使用して作成され、後で対応するコマンドを使用して変更または削除できます。</target>
        </trans-unit>
        <trans-unit id="c9ab2d1b430251390fd77666a59dc72c11f11cfe" translate="yes" xml:space="preserve">
          <source>A publication is essentially a group of tables whose data changes are intended to be replicated through logical replication. See &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt; for details about how publications fit into the logical replication setup.</source>
          <target state="translated">パブリケーションとは、基本的には、データの変更が論理複製によって複製されることを目的としたテーブルのグループです。参照&lt;a href=&quot;logical-replication-publication&quot;&gt;セクション30.1を&lt;/a&gt;出版は、論理レプリケーションのセットアップに収まる方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="e2338433bd110932bcc29150142a24f592f4dfbb" translate="yes" xml:space="preserve">
          <source>A published table must have a &amp;ldquo;replica identity&amp;rdquo; configured in order to be able to replicate &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operations, so that appropriate rows to update or delete can be identified on the subscriber side. By default, this is the primary key, if there is one. Another unique index (with certain additional requirements) can also be set to be the replica identity. If the table does not have any suitable key, then it can be set to replica identity &amp;ldquo;full&amp;rdquo;, which means the entire row becomes the key. This, however, is very inefficient and should only be used as a fallback if no other solution is possible. If a replica identity other than &amp;ldquo;full&amp;rdquo; is set on the publisher side, a replica identity comprising the same or fewer columns must also be set on the subscriber side. See &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;&lt;code&gt;REPLICA IDENTITY&lt;/code&gt;&lt;/a&gt; for details on how to set the replica identity. If a table without a replica identity is added to a publication that replicates &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations then subsequent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations will cause an error on the publisher. &lt;code&gt;INSERT&lt;/code&gt; operations can proceed regardless of any replica identity.</source>
          <target state="translated">サブスクライバー側で更新または削除する適切な行を識別できるように、パブリッシュされたテーブルには、 &lt;code&gt;UPDATE&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; 操作をレプリケートできるように構成された「レプリカID」が必要です。デフォルトでは、これが主キーです（存在する場合）。別の一意のインデックス（特定の追加要件がある）をレプリカIDとして設定することもできます。テーブルに適切なキーがない場合は、レプリカIDを「フル」に設定できます。つまり、行全体がキーになります。ただし、これは非常に非効率的であり、他に解決策がない場合のフォールバックとしてのみ使用してください。 「フル」以外のレプリカIDがパブリッシャー側で設定されている場合は、サブスクライバー側でも同じか少ない列で構成されるレプリカIDを設定する必要があります。見る&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt; &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; &lt;/a&gt;レプリカIDの設定方法の詳細については、 REPLICA IDENTITYを参照してください。レプリカIDのないテーブルが、 &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作をレプリケートするパブリケーションに追加された場合、後続の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作により、パブリッシャーでエラーが発生します。 &lt;code&gt;INSERT&lt;/code&gt; 操作は、レプリカIDに関係なく続行できます。</target>
        </trans-unit>
        <trans-unit id="0fa8cd1ec75091ae1b152072de83438ac13c7ac1" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.16&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;.</source>
          <target state="translated">定量化されたアトムは、単一の&lt;em&gt;量指定子&lt;/em&gt;が後に続く可能性のある&lt;em&gt;アトム&lt;/em&gt;です。数量詞がない場合、アトムの一致と一致します。量指定子を使用すると、アトムのいくつかの一致に一致できます。&lt;em&gt;原子&lt;/em&gt;に示す可能性のいずれかであることができる&lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;表9.16&lt;/a&gt;。可能な量指定子とその意味を&lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;表9.17に&lt;/a&gt;示します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc21709c3a9df27bc9570d7ce18a8b13da68c2a0" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;.</source>
          <target state="translated">A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="14b90372a7f382e1ebe5fbc1067a98d78caf7059" translate="yes" xml:space="preserve">
          <source>A quantified atom with a fixed-repetition quantifier (&lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt;) has the same greediness (possibly none) as the atom itself.</source>
          <target state="translated">固定反復量指定子（ &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; または &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; ）を持つ定量化されたアトムは、アトム自体と同じ貪欲さ（おそらくなし）を持っています。</target>
        </trans-unit>
        <trans-unit id="d2086c7d3f841e613b77902ebf9e5b97e2cde610" translate="yes" xml:space="preserve">
          <source>A quantified atom with a non-greedy quantifier (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is non-greedy (prefers shortest match).</source>
          <target state="translated">非貪欲量子化器を用いて定量原子（含む &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; と &lt;code&gt;m&lt;/code&gt; はに等しい &lt;code&gt;n&lt;/code&gt; ）（最短一致を好む）非貪欲です。</target>
        </trans-unit>
        <trans-unit id="044befe289d741f6adb775e3119a52c47ef4c4c1" translate="yes" xml:space="preserve">
          <source>A quantified atom with other normal quantifiers (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is greedy (prefers longest match).</source>
          <target state="translated">（を含む他の正常な数量で定量原子 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; と &lt;code&gt;m&lt;/code&gt; はに等しい &lt;code&gt;n&lt;/code&gt; が）（最長一致を好む）貪欲です。</target>
        </trans-unit>
        <trans-unit id="b0376c8a695cc9a8414ca39502c5036b915645c0" translate="yes" xml:space="preserve">
          <source>A quantifier cannot immediately follow another quantifier, e.g., &lt;code&gt;**&lt;/code&gt; is invalid. A quantifier cannot begin an expression or subexpression or follow &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">数量詞を別の数量詞の直後に続けることはできません。たとえば、 &lt;code&gt;**&lt;/code&gt; は無効です。量指定子は、式または部分式を開始したり、 &lt;code&gt;^&lt;/code&gt; または &lt;code&gt;|&lt;/code&gt; を続けたりできません。。</target>
        </trans-unit>
        <trans-unit id="c4fb059cdfd53bb422968b17a105f57bd04f411c" translate="yes" xml:space="preserve">
          <source>A query (&lt;code&gt;SELECT&lt;/code&gt; statement) that supplies the rows to be inserted. Refer to the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; statement for a description of the syntax.</source>
          <target state="translated">挿入する行を提供するクエリ（ &lt;code&gt;SELECT&lt;/code&gt; ステートメント）。構文の説明については、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;ステートメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f6cba9f4354114ea501407f47fa13c76eb60151c" translate="yes" xml:space="preserve">
          <source>A query can be &amp;ldquo;qualified&amp;rdquo; by adding a &lt;code&gt;WHERE&lt;/code&gt; clause that specifies which rows are wanted. The &lt;code&gt;WHERE&lt;/code&gt; clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (&lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:</source>
          <target state="translated">必要な行を指定する &lt;code&gt;WHERE&lt;/code&gt; 句を追加することで、クエリを「修飾」できます。 &lt;code&gt;WHERE&lt;/code&gt; 句には、ブール（真理値）の発現を含み、ブール式が真である行のみが返されます。通常のブール演算子（ &lt;code&gt;AND&lt;/code&gt; 、 &lt;code&gt;OR&lt;/code&gt; 、および &lt;code&gt;NOT&lt;/code&gt; ）を修飾で使用できます。たとえば、次の例では、雨の日のサンフランシスコの天気を取得します。</target>
        </trans-unit>
        <trans-unit id="a3f98fa3c0d12a208eadd01d5ce05b0ffde908aa" translate="yes" xml:space="preserve">
          <source>A read-only SQL transaction cannot alter non-temporary tables. This parameter controls the default read-only status of each new transaction. The default is &lt;code&gt;off&lt;/code&gt; (read/write).</source>
          <target state="translated">読み取り専用SQLトランザクションは、非一時テーブルを変更できません。このパラメータは、新しい各トランザクションのデフォルトの読み取り専用ステータスを制御します。デフォルトは &lt;code&gt;off&lt;/code&gt; （読み取り/書き込み）です。</target>
        </trans-unit>
        <trans-unit id="4a7841fe30d1103325f6249de23cba34804bfa4e" translate="yes" xml:space="preserve">
          <source>A reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.</source>
          <target state="translated">フィールドカウントの単語が-1でも、期待される列数でもない場合、読者はエラーを報告しなければなりません。これは、データとの同期が取れなくなっていないかどうかをチェックするための追加チェックです。</target>
        </trans-unit>
        <trans-unit id="fddf89d1b48df3d1a7d816db398c1f9bc279cad0" translate="yes" xml:space="preserve">
          <source>A record can have one of the seven formats</source>
          <target state="translated">レコードは7つのフォーマットのうちの1つを持つことができます。</target>
        </trans-unit>
        <trans-unit id="755da3745b4f352a5f0983d774febfd9dd4f8a2e" translate="yes" xml:space="preserve">
          <source>A record can have several formats:</source>
          <target state="translated">レコードにはいくつかの形式があります。</target>
        </trans-unit>
        <trans-unit id="1b600abb4523a0f2e29ac983d05c8a91aade45f9" translate="yes" xml:space="preserve">
          <source>A recursive &lt;code&gt;DROP COLUMN&lt;/code&gt; operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; (i.e., &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt;) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.</source>
          <target state="translated">再帰的な &lt;code&gt;DROP COLUMN&lt;/code&gt; 操作は、子孫が他の親からその列を継承せず、列の独立した定義を持たなかった場合にのみ、子孫テーブルの列を削除します。非再帰的な &lt;code&gt;DROP COLUMN&lt;/code&gt; （つまり、 &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt; ）は、子孫の列を削除することはなく、継承ではなく独立して定義された列としてマークします。非再帰 &lt;code&gt;DROP COLUMN&lt;/code&gt; コマンドは、パーティション化されたテーブルに対して失敗します。これは、テーブルのすべてのパーティションが、パーティション化ルートと同じ列を持っている必要があるためです。</target>
        </trans-unit>
        <trans-unit id="c8e116c04f64e1769d84da7554d28932fe4d3963" translate="yes" xml:space="preserve">
          <source>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a &lt;em&gt;regular set&lt;/em&gt;). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with &lt;code&gt;LIKE&lt;/code&gt;, pattern characters match string characters exactly unless they are special characters in the regular expression language &amp;mdash; but regular expressions use different special characters than &lt;code&gt;LIKE&lt;/code&gt; does. Unlike &lt;code&gt;LIKE&lt;/code&gt; patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</source>
          <target state="translated">正規表現は、一連の文字列（&lt;em&gt;正規セット&lt;/em&gt;）の省略された定義である文字シーケンスです。文字列は、正規表現で記述された正規セットのメンバーである場合、正規表現と一致すると言われます。 &lt;code&gt;LIKE&lt;/code&gt; と同様に、パターン文字は、正規表現言語の特殊文字でない限り、文字列文字と完全に一致します。ただし、正規表現は &lt;code&gt;LIKE&lt;/code&gt; とは異なる特殊文字を使用します。 &lt;code&gt;LIKE&lt;/code&gt; パターンとは異なり、正規表現は、文字列の先頭または末尾に明示的にアンカーされていない限り、文字列内のどこにでも一致できます。</target>
        </trans-unit>
        <trans-unit id="8bcf2029d3dfa5827a2882665f99b1d027b1662c" translate="yes" xml:space="preserve">
          <source>A regular expression is defined as one or more &lt;em&gt;branches&lt;/em&gt;, separated by &lt;code&gt;|&lt;/code&gt;. It matches anything that matches one of the branches.</source>
          <target state="translated">正規表現は、 &lt;code&gt;|&lt;/code&gt; で区切られた1つ以上の&lt;em&gt;ブランチ&lt;/em&gt;として定義されます。。これは、ブランチの1つに一致するものに一致します。</target>
        </trans-unit>
        <trans-unit id="3ee887f7d2952dfa9f7859c97d7cc185154f3579" translate="yes" xml:space="preserve">
          <source>A request sent by a client to a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt;, usually to return results or to modify data on the database.</source>
          <target state="translated">A request sent by a client to a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt;, usually to return results or to modify data on the database.</target>
        </trans-unit>
        <trans-unit id="55280929ef651951f4ea5727fbd13d553ba423e3" translate="yes" xml:space="preserve">
          <source>A restriction on the values of data allowed within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, or in attributes of a &lt;em&gt;domain&lt;/em&gt;.</source>
          <target state="translated">A restriction on the values of data allowed within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, or in attributes of a &lt;em&gt;domain&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="6f4f1bec4e67db6d8c109c21ce30fc24feb18e6d" translate="yes" xml:space="preserve">
          <source>A rich set of functions and operators is available to perform various geometric operations such as scaling, translation, rotation, and determining intersections. They are explained in &lt;a href=&quot;functions-geometry&quot;&gt;Section 9.11&lt;/a&gt;.</source>
          <target state="translated">豊富な関数と演算子のセットを使用して、スケーリング、変換、回転、交差の決定などのさまざまな幾何学的操作を実行できます。それらは&lt;a href=&quot;functions-geometry&quot;&gt;セクション9.11で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="dd3e55f45b03c0434f66fdb4c772115d77e89a86" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">また、役割には、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章で&lt;/a&gt;説明されている多くの実行時設定の役割固有のデフォルトを設定できます。たとえば、なんらかの理由で接続するたびにインデックススキャンを無効にしたい場合（ヒント：良いアイデアではありません）、次を使用できます。</target>
        </trans-unit>
        <trans-unit id="5f70d4edcc88d0b7db0593c0dc96e77fa856833c" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</target>
        </trans-unit>
        <trans-unit id="1819e27998d44ae23e1be32dd84afd40392e29ad" translate="yes" xml:space="preserve">
          <source>A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; and &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; commands can be useful for this purpose; see &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">クラスターのデータベースで参照されている役割は削除できません。その場合、エラーが発生します。ロールを削除する前に、そのロールが所有するすべてのオブジェクトを削除（またはそれらの所有権を再割り当て）して、ロールが他のオブジェクトに対して付与されている特権を取り消す必要があります。&lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGNはOWNED&lt;/a&gt;および&lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt;コマンドは、この目的のために有用であることができます。詳細については、&lt;a href=&quot;role-removal&quot;&gt;セクション21.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca7ed328c6182a99c2ad02ba1bf771cc523959b3" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt;.</source>
          <target state="translated">ロールには、データベースを作成する権限が明示的に付与されている必要があります（スーパーユーザーはすべての権限チェックをバイパスするため、スーパーユーザーを除く）。そのようなロールを作成するには、 &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d62d4d6cefafa0c4a7b229d226042d5cdbe21812" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt;. A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; &lt;code&gt;CREATEROLE&lt;/code&gt; is insufficient for that.</source>
          <target state="translated">ロールには、追加のロールを作成するための権限が明示的に付与されている必要があります（スーパーユーザーはすべての権限チェックをバイパスするため、スーパーユーザーを除く）。そのようなロールを作成するには、 &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt; を使用します。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、他のロールも変更および削除したり、それらのメンバーシップを付与または取り消すことができます。ただし、スーパーユーザーロールのメンバーシップを作成、変更、削除、または変更するには、スーパーユーザーのステータスが必要です。そのためには &lt;code&gt;CREATEROLE&lt;/code&gt; では不十分です。</target>
        </trans-unit>
        <trans-unit id="17ba5cb05b3fc9de95da7091b339d5cf7b10fc50" translate="yes" xml:space="preserve">
          <source>A role must explicitly be given permission to initiate streaming replication (except for superusers, since those bypass all permission checks). A role used for streaming replication must have &lt;code&gt;LOGIN&lt;/code&gt; permission as well. To create such a role, use &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt;.</source>
          <target state="translated">役割には、ストリーミングレプリケーションを開始する権限が明示的に付与されている必要があります（スーパーユーザーはすべての権限チェックをバイパスするため、スーパーユーザーを除く）。ストリーミングレプリケーションに使用されるロールには、 &lt;code&gt;LOGIN&lt;/code&gt; 権限も必要です。このようなロールを作成するには、 &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="94be28bc6eb3b4ca303ced8b07cef3c876649a6d" translate="yes" xml:space="preserve">
          <source>A role's attributes can be modified after creation with &lt;code&gt;ALTER ROLE&lt;/code&gt;. See the reference pages for the &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; commands for details.</source>
          <target state="translated">ロールの属性は、作成後に &lt;code&gt;ALTER ROLE&lt;/code&gt; で変更できます。詳細は、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE &lt;/a&gt;&lt;a href=&quot;sql-alterrole&quot;&gt;ROLE&lt;/a&gt;コマンドとALTER ROLEコマンドのリファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="081acf24bd36c70b53212a425e34d472f83362f1" translate="yes" xml:space="preserve">
          <source>A row constructor</source>
          <target state="translated">行のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="22f30213b82e4ac8580d06b76fb30db617ce4ae6" translate="yes" xml:space="preserve">
          <source>A row constructor can include the syntax &lt;code&gt;rowvalue&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt;, which will be expanded to a list of the elements of the row value, just as occurs when the &lt;code&gt;.*&lt;/code&gt; syntax is used at the top level of a &lt;code&gt;SELECT&lt;/code&gt; list (see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;). For example, if table &lt;code&gt;t&lt;/code&gt; has columns &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, these are the same:</source>
          <target state="translated">行コンストラクターには、行値の要素のリストに展開される構文 &lt;code&gt;rowvalue&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 含めることができます。これは、 &lt;code&gt;.*&lt;/code&gt; 構文が &lt;code&gt;SELECT&lt;/code&gt; リストのトップレベルで使用される場合と同じです（&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;セクション8.16.5を&lt;/a&gt;参照）。）。たとえば、テーブル &lt;code&gt;t&lt;/code&gt; に列 &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;f2&lt;/code&gt; がある場合、これらは同じです。</target>
        </trans-unit>
        <trans-unit id="f65566297d0cf76754b5ffd2e69f3d748460cda5" translate="yes" xml:space="preserve">
          <source>A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word &lt;code&gt;ROW&lt;/code&gt;, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:</source>
          <target state="translated">行コンストラクターは、メンバーフィールドの値を使用して行の値（複合値とも呼ばれます）を構築する式です。行コンストラクターは、キーワード &lt;code&gt;ROW&lt;/code&gt; 、左括弧、行フィールド値の（コンマで区切られた）0個以上の式、および最後に右括弧で構成されます。例えば：</target>
        </trans-unit>
        <trans-unit id="e083a9bfabe61aa93820ae695a4040f7ab7fb65b" translate="yes" xml:space="preserve">
          <source>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</source>
          <target state="translated">ルールはトリガーよりもかなり多くのオーバーヘッドを持ちますが、オーバーヘッドは行ごとではなくクエリごとに支払われるので、バルク挿入の状況ではこの方法が有利かもしれません。しかし、ほとんどの場合では、トリガ方式の方がより良いパフォーマンスを提供します。</target>
        </trans-unit>
        <trans-unit id="3a8ed465468f0b09e900dc84f22e1ad03222e742" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/members&lt;/code&gt; under the data directory, adding one, and then multiplying by 52352 (0xCC80). The file names are in hexadecimal. There is no simple recipe such as the ones for other options of appending zeroes.</source>
          <target state="translated">安全な値は、データディレクトリの下のディレクトリ &lt;code&gt;pg_multixact/members&lt;/code&gt; で数値的に最大のファイル名を探し、1を追加してから52352（0xCC80）を乗算することで決定できます。ファイル名は16進数です。ゼロを追加する他のオプションのような簡単なレシピはありません。</target>
        </trans-unit>
        <trans-unit id="427cc987ada87144cf5033e51fd5ca57fac98875" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_xact&lt;/code&gt; under the data directory, adding one, and then multiplying by 1048576 (0x100000). Note that the file names are in hexadecimal. It is usually easiest to specify the option value in hexadecimal too. For example, if &lt;code&gt;0011&lt;/code&gt; is the largest entry in &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;-x 0x1200000&lt;/code&gt; will work (five trailing zeroes provide the proper multiplier).</source>
          <target state="translated">安全な値は、データディレクトリの下のディレクトリ &lt;code&gt;pg_xact&lt;/code&gt; で数値的に最大のファイル名を検索し、ファイル名を追加して、1048576（0x100000）を乗算することで決定できます。ファイル名は16進数であることに注意してください。通常、オプション値も16進数で指定するのが最も簡単です。たとえば、 &lt;code&gt;0011&lt;/code&gt; が &lt;code&gt;pg_xact&lt;/code&gt; の最大のエントリである場合、 &lt;code&gt;-x 0x1200000&lt;/code&gt; が機能します（末尾の5つのゼロは適切な乗数を提供します）。</target>
        </trans-unit>
        <trans-unit id="cb05b109b960491956518dbc25a95b68a60bb5b7" translate="yes" xml:space="preserve">
          <source>A safe value for the next multitransaction ID (first part) can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/offsets&lt;/code&gt; under the data directory, adding one, and then multiplying by 65536 (0x10000). Conversely, a safe value for the oldest multitransaction ID (second part of &lt;code&gt;-m&lt;/code&gt;) can be determined by looking for the numerically smallest file name in the same directory and multiplying by 65536. The file names are in hexadecimal, so the easiest way to do this is to specify the option value in hexadecimal and append four zeroes.</source>
          <target state="translated">次のマルチ &lt;code&gt;pg_multixact/offsets&lt;/code&gt; ID（最初の部分）の安全な値は、データディレクトリの下のディレクトリpg_multixact / offsetsで数値的に最大のファイル名を探し、1を追加して、次に65536（0x10000）を掛けることによって決定できます。逆に、最も古いマルチトランザクションID（ &lt;code&gt;-m&lt;/code&gt; の 2番目の部分）の安全な値は、同じディレクトリで数値的に最小のファイル名を探し、65536を掛けることによって決定できます。ファイル名は16進数なので、最も簡単な方法はこれは、オプション値を16進数で指定し、4つのゼロを追加することです。</target>
        </trans-unit>
        <trans-unit id="210bab91fc67894e59300e346dd93bb05146f64b" translate="yes" xml:space="preserve">
          <source>A safe value for the oldest transaction ID for which the commit time can be retrieved (first part) can be determined by looking for the numerically smallest file name in the directory &lt;code&gt;pg_commit_ts&lt;/code&gt; under the data directory. Conversely, a safe value for the newest transaction ID for which the commit time can be retrieved (second part) can be determined by looking for the numerically greatest file name in the same directory. The file names are in hexadecimal.</source>
          <target state="translated">コミット時間を取得できる最も古いトランザクションID（最初の部分）の安全な値は、データディレクトリの下のディレクトリ &lt;code&gt;pg_commit_ts&lt;/code&gt; で数値的に最小のファイル名を探すことによって決定できます。逆に、コミット時間を取得できる最新のトランザクションID（2番目の部分）の安全な値は、同じディレクトリで数値的に最大のファイル名を探すことによって決定できます。ファイル名は16進数です。</target>
        </trans-unit>
        <trans-unit id="8c66ea914339b5b34a8487aab28576ebc5ca45da" translate="yes" xml:space="preserve">
          <source>A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</source>
          <target state="translated">セーブポイントは、それが確立された後に実行されたすべてのコマンドをロールバックして、セーブポイントの時点でのトランザクションの状態に戻すことを可能にする、トランザクション内の特別なマークである。</target>
        </trans-unit>
        <trans-unit id="7568eb3ea7434ae7b0d16a00f453676381b783a8" translate="yes" xml:space="preserve">
          <source>A scalar subquery</source>
          <target state="translated">スカラ副問い合わせ</target>
        </trans-unit>
        <trans-unit id="81af8f2f005c91eb2539d9bedb25765441d8772a" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">スカラーサブクエリは、括弧で囲まれた通常の &lt;code&gt;SELECT&lt;/code&gt; クエリであり、1つの列と1つの行を正確に返します。 （クエリの記述については、&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章を&lt;/a&gt;参照してください。） &lt;code&gt;SELECT&lt;/code&gt; クエリが実行され、単一の戻り値が周囲の値式で使用されます。複数の行または複数の列を返すクエリをスカラーサブクエリとして使用するとエラーになります。 （ただし、特定の実行中にサブクエリが行を返さない場合、エラーは発生しません。スカラー結果はnullであると見なされます。）サブクエリは周囲のクエリからの変数を参照できます。これは、1つの評価中に定数として機能します。サブクエリの。サブクエリを含む他の式については、&lt;a href=&quot;functions-subquery&quot;&gt;9.22&lt;/a&gt;項も参照してください。</target>
        </trans-unit>
        <trans-unit id="e0ba5f6cf2c1fcbf75fbd9fbfb66a812b9004a7f" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt; for other expressions involving subqueries.</target>
        </trans-unit>
        <trans-unit id="22189bcf116df43b441c919d8d32eb0f9603b0c4" translate="yes" xml:space="preserve">
          <source>A scan key is the internal representation of a &lt;code&gt;WHERE&lt;/code&gt; clause of the form &lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed &amp;mdash; the returned tuples are expected to satisfy all the indicated conditions.</source>
          <target state="translated">スキャンキーは、 &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; という形式の &lt;code&gt;WHERE&lt;/code&gt; 句の内部表現です。ここで、インデックスキーはインデックスの列の1つであり、演算子はそのインデックス列に関連付けられた演算子ファミリーのメンバーの1つです。インデックススキャンには0個以上のスキャンキーがあり、これらは暗黙的にAND演算されます&amp;mdash;返されたタプルは、指定されたすべての条件を満たすことが期待されます。</target>
        </trans-unit>
        <trans-unit id="f42378ba798baf455e1545f6ed59407d2afa77b9" translate="yes" xml:space="preserve">
          <source>A schema can only be dropped by its owner or a superuser. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema.</source>
          <target state="translated">スキーマを削除できるのは所有者かスーパーユーザーだけです。所有者は、スキーマ内のオブジェクトの一部を所有していなくても、スキーマ(およびそれによって含まれるすべてのオブジェクト)を削除することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="254b4940dad1d633556557588b281f41f26bbd38" translate="yes" xml:space="preserve">
          <source>A schema is a namespace for &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt;, which all reside in the same &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Each SQL object must reside in exactly one schema.</source>
          <target state="translated">A schema is a namespace for &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt;, which all reside in the same &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Each SQL object must reside in exactly one schema.</target>
        </trans-unit>
        <trans-unit id="d6403de1aa8d8ec1e90672c217c0a1e9ee16c135" translate="yes" xml:space="preserve">
          <source>A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas. Named objects are accessed either by &amp;ldquo;qualifying&amp;rdquo; their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s). A &lt;code&gt;CREATE&lt;/code&gt; command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function &lt;code&gt;current_schema&lt;/code&gt;).</source>
          <target state="translated">スキーマは基本的に名前空間です。名前付きオブジェクト（テーブル、データ型、関数、演算子）が含まれ、その名前は他のスキーマに存在する他のオブジェクトの名前と重複する可能性があります。名前付きオブジェクトにアクセスするには、スキーマ名を接頭辞として使用して名前を「修飾」するか、目的のスキーマを含む検索パスを設定します。 &lt;code&gt;CREATE&lt;/code&gt; 非修飾オブジェクト名を指定するコマンド（関数を用いて決定することができる検索パスの前に1つ、現在のスキーマ内のオブジェクトを作成 &lt;code&gt;current_schema&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="896efd5a8d00dc02d53497ffb75c3ac39fb5a4a6" translate="yes" xml:space="preserve">
          <source>A script file contains one or more SQL commands terminated by semicolons. Empty lines and lines beginning with &lt;code&gt;--&lt;/code&gt; are ignored. Script files can also contain &amp;ldquo;meta commands&amp;rdquo;, which are interpreted by pgbench itself, as described below.</source>
          <target state="translated">スクリプトファイルには、セミコロンで終了する1つ以上のSQLコマンドが含まれています。空行と &lt;code&gt;--&lt;/code&gt; 始まる行は無視されます。スクリプトファイルには、以下に説明するように、pgbench自体によって解釈される「メタコマンド」を含めることもできます。</target>
        </trans-unit>
        <trans-unit id="c4717af9b4226f3b00d724aebfdacf0ab19f7c65" translate="yes" xml:space="preserve">
          <source>A second database, &lt;code&gt;template1&lt;/code&gt;, is also created during database cluster initialization. Whenever a new database is created within the cluster, &lt;code&gt;template1&lt;/code&gt; is essentially cloned. This means that any changes you make in &lt;code&gt;template1&lt;/code&gt; are propagated to all subsequently created databases. Because of this, avoid creating objects in &lt;code&gt;template1&lt;/code&gt; unless you want them propagated to every newly created database. More details appear in &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">2番目のデータベース &lt;code&gt;template1&lt;/code&gt; も、データベースクラスターの初期化中に作成されます。クラスター内に新しいデータベースが作成されると、 &lt;code&gt;template1&lt;/code&gt; は基本的に複製されます。つまり、 &lt;code&gt;template1&lt;/code&gt; で行った変更は、後で作成されるすべてのデータベースに伝達されます。このため、新しく作成されたすべてのデータベースに伝達したくない場合を除き、 &lt;code&gt;template1&lt;/code&gt; でオブジェクトを作成しないでください。詳細については、&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;セクション22.3を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c0553fb63d3a8d00dba1af17146ccb321bca9edc" translate="yes" xml:space="preserve">
          <source>A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</source>
          <target state="translated">A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</target>
        </trans-unit>
        <trans-unit id="11592b154f9e554cd84c7343d4d02f52f502b436" translate="yes" xml:space="preserve">
          <source>A sequential scan over this large table takes a long time:</source>
          <target state="translated">この大きなテーブルの上を順次スキャンすると、長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="79af3c162f9318c384ae01ff487ce072e1768dfe" translate="yes" xml:space="preserve">
          <source>A sequential scan will always necessitate a relation-level predicate lock. This can result in an increased rate of serialization failures. It may be helpful to encourage the use of index scans by reducing &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; and/or increasing &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;. Be sure to weigh any decrease in transaction rollbacks and restarts against any overall change in query execution time.</source>
          <target state="translated">順次スキャンでは、常に関係レベルの述語ロックが必要になります。これにより、シリアル化の失敗率が高くなる可能性があります。減らすことによって、インデックス・スキャンの使用を奨励するために役立つかもしれない&lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_costをし&lt;/a&gt;、および/または増加&lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_costを&lt;/a&gt;。トランザクションのロールバックと再起動の減少と、クエリ実行時間の全体的な変化を比較検討してください。</target>
        </trans-unit>
        <trans-unit id="c996ff6e0403a4fb8e72d039c933ec1c36020db2" translate="yes" xml:space="preserve">
          <source>A series of documents that define the SQL language.</source>
          <target state="translated">SQL言語を定義する一連のドキュメント。</target>
        </trans-unit>
        <trans-unit id="1bfa1c21333697528077114ccbfbc09a0f9f978f" translate="yes" xml:space="preserve">
          <source>A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example:</source>
          <target state="translated">継承機能の深刻な制限は、インデックス(一意制約を含む)と外部キー制約が単一のテーブルにのみ適用され、その継承子には適用されないことです。これは、外部キー制約の参照側と参照される側の両方に当てはまります。したがって、上記の例の用語では</target>
        </trans-unit>
        <trans-unit id="b2bd01559e686b7857df249c11b785bd65be39d9" translate="yes" xml:space="preserve">
          <source>A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">データベースファイルを管理し、クライアントアプリケーションからデータベースへの接続を受け入れ、クライアントに代わってデータベースアクションを実行するサーバープロセス。データベースサーバープログラムは &lt;code&gt;postgres&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="eda9a27048331b66fd1707531a40ce77f3ddd8c9" translate="yes" xml:space="preserve">
          <source>A session can be unregistered for a given notification channel with the &lt;code&gt;UNLISTEN&lt;/code&gt; command. A session's listen registrations are automatically cleared when the session ends.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; コマンドを使用して、特定の通知チャネルのセッションを登録解除できます。セッションのリッスン登録は、セッションが終了すると自動的にクリアされます。</target>
        </trans-unit>
        <trans-unit id="2159dca873e4422248b8b886c40fce3f04eaaa4b" translate="yes" xml:space="preserve">
          <source>A session running a &lt;code id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/code&gt; transaction blocks a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction from acquiring a snapshot until the latter determines that it is safe to avoid taking any predicate locks. See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for more information about serializable and deferrable transactions.</source>
          <target state="translated">A session running a &lt;code id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/code&gt; transaction blocks a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction from acquiring a snapshot until the latter determines that it is safe to avoid taking any predicate locks. See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for more information about serializable and deferrable transactions.</target>
        </trans-unit>
        <trans-unit id="75b584c1806aab227b279342fcda898366eb0bc1" translate="yes" xml:space="preserve">
          <source>A session will allocate temporary buffers as needed up to the limit given by &lt;code&gt;temp_buffers&lt;/code&gt;. The cost of setting a large value in sessions that do not actually need many temporary buffers is only a buffer descriptor, or about 64 bytes, per increment in &lt;code&gt;temp_buffers&lt;/code&gt;. However if a buffer is actually used an additional 8192 bytes will be consumed for it (or in general, &lt;code&gt;BLCKSZ&lt;/code&gt; bytes).</source>
          <target state="translated">セッションは、 &lt;code&gt;temp_buffers&lt;/code&gt; で指定された制限まで、必要に応じて一時バッファーを割り当てます。実際に多くの一時バッファーを必要としないセッションで大きな値を設定するコストは、 &lt;code&gt;temp_buffers&lt;/code&gt; の増分ごとのバッファー記述子、つまり約64バイトのみです。ただし、バッファが実際に使用される場合、追加の8192バイトが消費されます（または一般に、 &lt;code&gt;BLCKSZ&lt;/code&gt; バイト）。</target>
        </trans-unit>
        <trans-unit id="1986f4a7eb9ec7c322dfb6c9c6e1924b057be9e0" translate="yes" xml:space="preserve">
          <source>A set of background processes that routinely perform &lt;a href=&quot;glossary#GLOSSARY-VACUUM&quot;&gt;vacuum&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-ANALYZE&quot;&gt;analyze&lt;/a&gt; operations.</source>
          <target state="translated">A set of background processes that routinely perform &lt;a href=&quot;glossary#GLOSSARY-VACUUM&quot;&gt;vacuum&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-ANALYZE&quot;&gt;analyze&lt;/a&gt; operations.</target>
        </trans-unit>
        <trans-unit id="78d05cbafd4652352f5f70c34a9c2c9722aea37c" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions are available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">SQLデータからXMLコンテンツを生成するための関数と関数に似た式のセットが用意されています。そのため、クエリ結果を XML ドキュメントにフォーマットしてクライアントアプリケーションで処理するのに特に適しています。</target>
        </trans-unit>
        <trans-unit id="db5cffdfcc14ae057b50bf32801b87510be72218" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions is available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">SQLデータからXMLコンテンツを生成するための関数と関数に似た式のセットが用意されています。これらは、クライアントアプリケーションで処理するために、クエリの結果をXMLドキュメントにフォーマットするのに特に適しています。</target>
        </trans-unit>
        <trans-unit id="675287b9d3c5bb2ab0654e84d04004c09628b2e2" translate="yes" xml:space="preserve">
          <source>A shorthand notation is provided for specifying two common types of grouping set. A clause of the form</source>
          <target state="translated">2つの一般的なタイプのグループ化集合を指定するための略記法が提供されています。形式の節</target>
        </trans-unit>
        <trans-unit id="4eb84b728058fd55ea25770f3f034fccfd80efda" translate="yes" xml:space="preserve">
          <source>A shorthand version of &lt;code&gt;get_raw_page&lt;/code&gt;, for reading from the main fork. Equivalent to &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</source>
          <target state="translated">メインフォークから読み取るための &lt;code&gt;get_raw_page&lt;/code&gt; の簡略版。同等 &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf3b68bae267e9ec8dc713868f0cc42a385b1b59" translate="yes" xml:space="preserve">
          <source>A sign formatted using &lt;code&gt;SG&lt;/code&gt;, &lt;code&gt;PL&lt;/code&gt;, or &lt;code&gt;MI&lt;/code&gt; is not anchored to the number; for example, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; produces &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; but &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; produces &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt;. (The Oracle implementation does not allow the use of &lt;code&gt;MI&lt;/code&gt; before &lt;code&gt;9&lt;/code&gt;, but rather requires that &lt;code&gt;9&lt;/code&gt; precede &lt;code&gt;MI&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;SG&lt;/code&gt; 、 &lt;code&gt;PL&lt;/code&gt; 、または &lt;code&gt;MI&lt;/code&gt; を使用してフォーマットされた符号は、番号に固定されていません。例えば、 &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; 生成する &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; が、 &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; 生成する &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt; 。（Oracle実装は、使用を許可しない &lt;code&gt;MI&lt;/code&gt; を前に &lt;code&gt;9&lt;/code&gt; ではなく、その必要が &lt;code&gt;9&lt;/code&gt; に先行 &lt;code&gt;MI&lt;/code&gt; を。）</target>
        </trans-unit>
        <trans-unit id="28f22335db260bb1a77d3874ff5a159c8ea0367a" translate="yes" xml:space="preserve">
          <source>A signature is a lossy representation of the indexed attribute(s), and as such is prone to reporting false positives; that is, it may be reported that an element is in the set, when it is not. So index search results must always be rechecked using the actual attribute values from the heap entry. Larger signatures reduce the odds of a false positive and thus reduce the number of useless heap visits, but of course also make the index larger and hence slower to scan.</source>
          <target state="translated">シグネチャは、インデックス化された属性の非可逆的な表現であり、偽陽性を報告する傾向があります;すなわち、ある要素がセットの中にあると報告されるかもしれないが、そうでない場合があります。そのため、インデックス検索結果は常にヒープエントリからの実際の属性値を使って再確認しなければなりません。シグネチャを大きくすることで誤検出の確率が下がり、無駄なヒープの訪問回数が減りますが、もちろんインデックスが大きくなり、スキャンが遅くなります。</target>
        </trans-unit>
        <trans-unit id="32035573077f021fbb97ad61e501af43e164ab91" translate="yes" xml:space="preserve">
          <source>A similar approach is used in most non-fiction books: terms and concepts that are frequently looked up by readers are collected in an alphabetic index at the end of the book. The interested reader can scan the index relatively quickly and flip to the appropriate page(s), rather than having to read the entire book to find the material of interest. Just as it is the task of the author to anticipate the items that readers are likely to look up, it is the task of the database programmer to foresee which indexes will be useful.</source>
          <target state="translated">ほとんどのノンフィクション本にも同様のアプローチが採用されています。興味のある読者は、興味のある内容を見つけるために本全体を読むのではなく、比較的素早くインデックスをスキャンして、適切なページをめくることができます。読者が調べそうな項目を予測するのが著者の仕事であるように、どのインデックスが役に立つかを予測するのがデータベースプログラマーの仕事です。</target>
        </trans-unit>
        <trans-unit id="0ce67715832ac88218d019874223da06f72da1b1" translate="yes" xml:space="preserve">
          <source>A similar command will be generated for each new file to be archived.</source>
          <target state="translated">アーカイブする新しいファイルごとに同様のコマンドが生成されます。</target>
        </trans-unit>
        <trans-unit id="3786a908833219f288eb01ce7bf3707543bec989" translate="yes" xml:space="preserve">
          <source>A similar problem occurs with estimation of the cardinality of sets of multiple columns, such as the number of groups that would be generated by a &lt;code&gt;GROUP BY&lt;/code&gt; clause. When &lt;code&gt;GROUP BY&lt;/code&gt; lists a single column, the n-distinct estimate (which is visible as the estimated number of rows returned by the HashAggregate node) is very accurate:</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; 句によって生成されるグループの数など、複数の列のセットのカーディナリティの推定でも同様の問題が発生します。 &lt;code&gt;GROUP BY&lt;/code&gt; が単一の列をリストする場合、n-distinct推定（HashAggregateノードによって返される推定行数として表示されます）は非常に正確です。</target>
        </trans-unit>
        <trans-unit id="5d9a6505729509f95a09312b10bc6d90c22cf17c" translate="yes" xml:space="preserve">
          <source>A similar result could be accomplished with a join:</source>
          <target state="translated">同様の結果は、結合でも達成できます。</target>
        </trans-unit>
        <trans-unit id="37fd7a4a35913776332656300b6e6e873ef35bb0" translate="yes" xml:space="preserve">
          <source>A simple GIN index on the &lt;code&gt;jdoc&lt;/code&gt; column can support this query. But note that such an index will store copies of every key and value in the &lt;code&gt;jdoc&lt;/code&gt; column, whereas the expression index of the previous example stores only data found under the &lt;code&gt;tags&lt;/code&gt; key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</source>
          <target state="translated">&lt;code&gt;jdoc&lt;/code&gt; 列の単純なGINインデックスは、このクエリをサポートできます。しかし、このようなインデックスは、内のすべてのキーと値のコピーを格納します。なお、 &lt;code&gt;jdoc&lt;/code&gt; の前の例の店の発現率は、データのみが下にあるのに対し、列を &lt;code&gt;tags&lt;/code&gt; キー。シンプルインデックスアプローチははるかに柔軟性がありますが（任意のキーに関するクエリをサポートするため）、ターゲット式インデックスは、シンプルインデックスよりも小さく、高速に検索できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1dca6bdccd192c38f7d0a54b1d6c641ecfc4dd07" translate="yes" xml:space="preserve">
          <source>A simple aggregate function is made from one or two ordinary functions: a state transition function &lt;code&gt;sfunc&lt;/code&gt;, and an optional final calculation function &lt;code&gt;ffunc&lt;/code&gt;. These are used as follows:</source>
          <target state="translated">単純な集約関数は、1つまたは2つの通常の関数（状態遷移関数 &lt;code&gt;sfunc&lt;/code&gt; 、およびオプションの最終計算関数 &lt;code&gt;ffunc&lt;/code&gt; )から作成されます。これらは次のように使用されます。</target>
        </trans-unit>
        <trans-unit id="92c5b995463bf0dd676bdb47c7d11c8b07e323eb" translate="yes" xml:space="preserve">
          <source>A simple example of configuration is:</source>
          <target state="translated">設定の簡単な例としては</target>
        </trans-unit>
        <trans-unit id="0929a1c1d2dae1cb142a133fc2a8d2f50ec36161" translate="yes" xml:space="preserve">
          <source>A simple example of these rules is</source>
          <target state="translated">これらのルールの簡単な例としては</target>
        </trans-unit>
        <trans-unit id="a7391df0d455f9692788470d09f0d785e12ddd80" translate="yes" xml:space="preserve">
          <source>A simple kind of query has the form:</source>
          <target state="translated">単純な種類のクエリには、次のような形式があります。</target>
        </trans-unit>
        <trans-unit id="e9cf93d0e888ede997ab50815543f2f23545f52a" translate="yes" xml:space="preserve">
          <source>A single index scan can only use query clauses that use the index's columns with operators of its operator class and are joined with &lt;code&gt;AND&lt;/code&gt;. For example, given an index on &lt;code&gt;(a, b)&lt;/code&gt; a query condition like &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; could use the index, but a query like &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; could not directly use the index.</source>
          <target state="translated">単一のインデックススキャンでは、インデックスの列をその演算子クラスの演算子と共に使用し、 &lt;code&gt;AND&lt;/code&gt; で結合されたクエリ句のみを使用できます。たとえば、 &lt;code&gt;(a, b)&lt;/code&gt; インデックスが指定されている場合、 &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; ようなクエリ条件はインデックスを使用できますが、 &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; ようなクエリはインデックスを直接使用できません。</target>
        </trans-unit>
        <trans-unit id="867794d10e104f13c9e8cf27b9206d3b607f31d5" translate="yes" xml:space="preserve">
          <source>A single operator is provided, shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;に示すように、単一のオペレーターが提供されます。</target>
        </trans-unit>
        <trans-unit id="4ecaee1e3e7fc4cc75092b8ce7abdaa9285ac3ce" translate="yes" xml:space="preserve">
          <source>A small number of objects, like role, database, and tablespace names, are defined at the cluster level and stored in the &lt;code&gt;pg_global&lt;/code&gt; tablespace. Inside the cluster are multiple databases, which are isolated from each other but can access cluster-level objects. Inside each database are multiple schemas, which contain objects like tables and functions. So the full hierarchy is: cluster, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="translated">A small number of objects, like role, database, and tablespace names, are defined at the cluster level and stored in the &lt;code&gt;pg_global&lt;/code&gt; tablespace. Inside the cluster are multiple databases, which are isolated from each other but can access cluster-level objects. Inside each database are multiple schemas, which contain objects like tables and functions. So the full hierarchy is: cluster, database, schema, table (or some other kind of object, such as a function).</target>
        </trans-unit>
        <trans-unit id="07b58acc01d25d1802019308ca111c48a0d1dd06" translate="yes" xml:space="preserve">
          <source>A software add-on package that can be installed on an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to get extra features.</source>
          <target state="translated">A software add-on package that can be installed on an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to get extra features.</target>
        </trans-unit>
        <trans-unit id="5d707a25df7385c415429f55133f3338c29d9eb5" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">ソート演算子。詳細については、&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6d3b735b7f3eb84460aea32d14769c9c3214fb68" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</target>
        </trans-unit>
        <trans-unit id="7cf7b59bf27af641775e9434a262775adcfc35c9" translate="yes" xml:space="preserve">
          <source>A special case of a &lt;a href=&quot;glossary#GLOSSARY-UNIQUE-CONSTRAINT&quot;&gt;unique constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that also guarantees that all of the &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; do not have &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null&lt;/a&gt; values. As the name implies, there can be only one primary key per table, though it is possible to have multiple unique constraints that also have no null-capable attributes.</source>
          <target state="translated">A special case of a &lt;a href=&quot;glossary#GLOSSARY-UNIQUE-CONSTRAINT&quot;&gt;unique constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that also guarantees that all of the &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; do not have &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null&lt;/a&gt; values. As the name implies, there can be only one primary key per table, though it is possible to have multiple unique constraints that also have no null-capable attributes.</target>
        </trans-unit>
        <trans-unit id="c36087e3651816803cdd143451424471a45426ba" translate="yes" xml:space="preserve">
          <source>A special case that's sometimes useful is that &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; can be used to require that two patterns match the same word.</source>
          <target state="translated">時には便利だ特別な場合は、ということである &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; 二つのパターンが同じ単語に一致することを要求するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="80f2af404248705306ef790e8642f0ac8c9028d1" translate="yes" xml:space="preserve">
          <source>A special heuristic is applied to determine whether a deduplication pass in a unique index should take place. It can often skip straight to splitting a leaf page, avoiding a performance penalty from wasting cycles on unhelpful deduplication passes. If you're concerned about the overhead of deduplication, consider setting &lt;code&gt;deduplicate_items = off&lt;/code&gt; selectively. Leaving deduplication enabled in unique indexes has little downside.</source>
          <target state="translated">A special heuristic is applied to determine whether a deduplication pass in a unique index should take place. It can often skip straight to splitting a leaf page, avoiding a performance penalty from wasting cycles on unhelpful deduplication passes. If you're concerned about the overhead of deduplication, consider setting &lt;code&gt;deduplicate_items = off&lt;/code&gt; selectively. Leaving deduplication enabled in unique indexes has little downside.</target>
        </trans-unit>
        <trans-unit id="bae37c740b6d35e6443717335fb07bf95869ce22" translate="yes" xml:space="preserve">
          <source>A special mark in the sequence of steps in a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;. Data modifications after this point in time may be reverted to the time of the savepoint.</source>
          <target state="translated">A special mark in the sequence of steps in a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;. Data modifications after this point in time may be reverted to the time of the savepoint.</target>
        </trans-unit>
        <trans-unit id="50e32359cf0b0268eacae302550072c34383af98" translate="yes" xml:space="preserve">
          <source>A specialized process responsible for executing checkpoints.</source>
          <target state="translated">チェックポイントの実行を担当する専門的なプロセス。</target>
        </trans-unit>
        <trans-unit id="3a70bf6435ed23a7c676143743be435f017bc889" translate="yes" xml:space="preserve">
          <source>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</source>
          <target state="translated">受信側と送信側の両方の役割を果たすスタンバイは、カスケード・スタンバイと呼ばれています。マスタに直接接続されているスタンバイはアップストリームサーバと呼ばれ、さらに離れたスタンバイサーバはダウンストリームサーバと呼ばれています。カスケード・レプリケーションでは、ダウンストリーム・サーバの数や配置に制限はありませんが、各スタンバイは、最終的には1つのマスター/プライマリ・サーバにリンクする1つのアップストリーム・サーバにしか接続しません。</target>
        </trans-unit>
        <trans-unit id="94007c63f83c2bc9effa88a81f497e0678595186" translate="yes" xml:space="preserve">
          <source>A standby server can be implemented using file-based log shipping (&lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) or streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;), or a combination of both. For information on hot standby, see &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;.</source>
          <target state="translated">スタンバイサーバーは、ファイルベースのログ配布（&lt;a href=&quot;warm-standby&quot;&gt;セクション26.2&lt;/a&gt;）またはストリーミングレプリケーション（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）、あるいはその両方の組み合わせを使用して実装できます。ホットスタンバイについては、&lt;a href=&quot;hot-standby&quot;&gt;セクション26.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="326a3efd4c9e08bc49a95748f894324f178b3b88" translate="yes" xml:space="preserve">
          <source>A state that allows a client and a backend to interact, communicating over a &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connection&lt;/a&gt;.</source>
          <target state="translated">A state that allows a client and a backend to interact, communicating over a &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connection&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4eb6647573ef74b2ae4f7352625efc1c166ad8a5" translate="yes" xml:space="preserve">
          <source>A statement can only see rows committed before it began. This is the default.</source>
          <target state="translated">ステートメントは開始前にコミットされた行のみを見ることができます。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="4a7d12fc82f3d9f19299237c20a3b225478fd75c" translate="yes" xml:space="preserve">
          <source>A statistics kind to be computed in this statistics object. Currently supported kinds are &lt;code&gt;ndistinct&lt;/code&gt;, which enables n-distinct statistics, &lt;code&gt;dependencies&lt;/code&gt;, which enables functional dependency statistics, and &lt;code&gt;mcv&lt;/code&gt; which enables most-common values lists. If this clause is omitted, all supported statistics kinds are included in the statistics object. For more information, see &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Section 14.2.2&lt;/a&gt; and &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Section 70.2&lt;/a&gt;.</source>
          <target state="translated">この統計オブジェクトで計算される統計の種類。現在サポートされている種類がある &lt;code&gt;ndistinct&lt;/code&gt; 、ndistinct統計を可能にする、 &lt;code&gt;dependencies&lt;/code&gt; 機能依存の統計を可能にする、と &lt;code&gt;mcv&lt;/code&gt; 最も一般的な値のリストを可能にします。この句を省略すると、サポートされているすべての統計の種類が統計オブジェクトに含まれます。詳細については、&lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;セクション14.2.2&lt;/a&gt;および&lt;a href=&quot;multivariate-statistics-examples&quot;&gt;セクション70.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7afb9dfc5301530890be994c8fdaea740d424bc6" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The free space map entry for each page stores the amount of free space that's available for future tuples, and is structured to be efficiently searched for available space for a new tuple of a given size.</source>
          <target state="translated">テーブルのメインフォークの各データページに関するメタデータを保持するストレージ構造。各ページの空き領域マップエントリは、将来のタプルで利用可能な空き領域の量を格納し、与えられたサイズの新しいタプルで利用可能な領域を効率的に検索できるように構成されています。</target>
        </trans-unit>
        <trans-unit id="92d5e9e679ad2ea336688f58c0cc38f17ebb2361" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The visibility map entry for each page stores two bits: the first one (&lt;code&gt;all-visible&lt;/code&gt;) indicates that all tuples in the page are visible to all transactions. The second one (&lt;code&gt;all-frozen&lt;/code&gt;) indicates that all tuples in the page are marked frozen.</source>
          <target state="translated">A storage structure that keeps metadata about each data page of a table's main fork. The visibility map entry for each page stores two bits: the first one ( &lt;code&gt;all-visible&lt;/code&gt; ) indicates that all tuples in the page are visible to all transactions. The second one ( &lt;code&gt;all-frozen&lt;/code&gt; ) indicates that all tuples in the page are marked frozen.</target>
        </trans-unit>
        <trans-unit id="069a72422c3cc6a607349a4e700ca343dee3bf3a" translate="yes" xml:space="preserve">
          <source>A stored array value can be enlarged by assigning to elements not already present. Any positions between those previously present and the newly assigned elements will be filled with nulls. For example, if array &lt;code&gt;myarray&lt;/code&gt; currently has 4 elements, it will have six elements after an update that assigns to &lt;code&gt;myarray[6]&lt;/code&gt;; &lt;code&gt;myarray[5]&lt;/code&gt; will contain null. Currently, enlargement in this fashion is only allowed for one-dimensional arrays, not multidimensional arrays.</source>
          <target state="translated">格納されている配列値は、まだ存在していない要素に割り当てることで拡大できます。以前に存在していたものと新しく割り当てられた要素との間の位置はnullで埋められます。たとえば、配列 &lt;code&gt;myarray&lt;/code&gt; に現在4つの要素がある場合、 &lt;code&gt;myarray[6]&lt;/code&gt; 割り当てられる更新後、6つの要素が含まれます。 &lt;code&gt;myarray[5]&lt;/code&gt; にはnullが含まれます。現在、この方法での拡大は、多次元配列ではなく、1次元配列でのみ許可されています。</target>
        </trans-unit>
        <trans-unit id="dffe36d8e51b4ef2ab1fe0c1b3e201415f713820" translate="yes" xml:space="preserve">
          <source>A string constant defining the function; the meaning depends on the language. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">関数を定義する文字列定数。これは、内部関数名、オブジェクトファイルへのパス、SQLコマンド、手続き言語のテキストのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="dbfdac594b047310ca108ad639b27f52bf3906ca" translate="yes" xml:space="preserve">
          <source>A string constant defining the procedure; the meaning depends on the language. It can be an internal procedure name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">プロシージャを定義する文字列定数。これは、内部プロシージャ名、オブジェクトファイルへのパス、SQLコマンド、 手続き言語のテキストのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="f2a8b822478dd09960c81d58138d7e54120409b2" translate="yes" xml:space="preserve">
          <source>A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (&lt;code&gt;'&lt;/code&gt;), for example &lt;code&gt;'This is a string'&lt;/code&gt;. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., &lt;code&gt;'Dianne''s horse'&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the same as a double-quote character (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">SQLの文字列定数は、 &lt;code&gt;'This is a string'&lt;/code&gt; のように、一重引用符（ &lt;code&gt;'&lt;/code&gt; ）で囲まれた任意の文字シーケンスです。文字列定数に一重引用符を含めるには、隣接する2つの一重引用符を記述します（例： &lt;code&gt;'Dianne''s horse'&lt;/code&gt; 。これは二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）と同じでは&lt;em&gt;ない&lt;/em&gt;ことに注意してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9740675c09c16dac87aea8ba937f0db10ddc9e95" translate="yes" xml:space="preserve">
          <source>A string literal representing the textual label associated with one value of an enum type.</source>
          <target state="translated">列挙型の1つの値に関連付けられたテキストラベルを表す文字列リテラル。</target>
        </trans-unit>
        <trans-unit id="349698cab225818ce6aaeac8a591649416d8d5ab" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; where &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is the index of the argument to print. Index 1 means the first argument after &lt;em&gt;&lt;code&gt;formatstr&lt;/code&gt;&lt;/em&gt;. If the &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">A string of the form &lt;code&gt;&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; where &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; is the index of the argument to print. Index 1 means the first argument after &lt;em&gt; &lt;code&gt;formatstr&lt;/code&gt; &lt;/em&gt;. If the &lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt; is omitted, the default is to use the next argument in sequence.</target>
        </trans-unit>
        <trans-unit id="9b5b7ed5b9f283f907a7fca459d4258127f634e3" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;n$&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the index of the argument to print. Index 1 means the first argument after &lt;code&gt;formatstr&lt;/code&gt;. If the &lt;code&gt;position&lt;/code&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">形式の文字列 &lt;code&gt;n$&lt;/code&gt; ところ &lt;code&gt;n&lt;/code&gt; 印刷する引数のインデックスです。インデックス1は、 &lt;code&gt;formatstr&lt;/code&gt; の後の最初の引数を意味します。場合は &lt;code&gt;position&lt;/code&gt; 省略され、デフォルトでは、シーケンス内の次の引数を使用することです。</target>
        </trans-unit>
        <trans-unit id="ddfb60a35b54b4a543c700ebe6924626aa1923e3" translate="yes" xml:space="preserve">
          <source>A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates.</source>
          <target state="translated">文字列のような構文は、文字列型を扱うため、また複雑な拡張型を扱うために使用されます。型が特定されていない文字列は、演算子の候補と照合されます。</target>
        </trans-unit>
        <trans-unit id="1cc21b370e49b36cc3877fbc8b204fee390f5ba0" translate="yes" xml:space="preserve">
          <source>A sub-&lt;code&gt;SELECT&lt;/code&gt; can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. This acts as though its output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. Note that the sub-&lt;code&gt;SELECT&lt;/code&gt; must be surrounded by parentheses, and an alias &lt;em&gt;must&lt;/em&gt; be provided for it. A &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command can also be used here.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句にサブ &lt;code&gt;SELECT&lt;/code&gt; を含めることができます。これは、出力がこの単一の &lt;code&gt;SELECT&lt;/code&gt; コマンドの実行中に一時テーブルとして作成されたかのように機能します。サブ &lt;code&gt;SELECT&lt;/code&gt; は括弧で囲む必要があり、エイリアスを指定する&lt;em&gt;必要&lt;/em&gt;があることに注意してください。&lt;a href=&quot;sql-values&quot;&gt;VALUESの&lt;/a&gt;コマンドも、ここで使用することができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20d744869b3f288cd0f4b443c304ea51738904ae" translate="yes" xml:space="preserve">
          <source>A subquery can also be a &lt;code&gt;VALUES&lt;/code&gt; list:</source>
          <target state="translated">サブクエリは &lt;code&gt;VALUES&lt;/code&gt; リストにすることもできます。</target>
        </trans-unit>
        <trans-unit id="467730923a1355f01d0ecc067917a4e744b3c1af" translate="yes" xml:space="preserve">
          <source>A subscriber node may have multiple subscriptions if desired. It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don't overlap.</source>
          <target state="translated">必要に応じて、サブスクライバ・ノードは複数のサブスクリプションを持つことができます。1 つのパブリッシャとサブスクライバのペア間で複数のサブスクリプションを定義することも可能ですが、その場合は、サブスクライブされたパブリケーション・オブジェクトが重複しないように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="d3b9d35fca34aebbff75a223845b5323b4b90739" translate="yes" xml:space="preserve">
          <source>A subscripted expression</source>
          <target state="translated">添え字式</target>
        </trans-unit>
        <trans-unit id="e3de42d209ab44c2b82ef6de9aa6e4c065c039e8" translate="yes" xml:space="preserve">
          <source>A subscription can only be dropped by a superuser.</source>
          <target state="translated">サブスクリプションは、スーパーユーザーのみがドロップすることができます。</target>
        </trans-unit>
        <trans-unit id="6aba51cc9b50b3a680d08e5aa1b132f7c7c53586" translate="yes" xml:space="preserve">
          <source>A substitute name for &lt;code&gt;table_name&lt;/code&gt;. When an alias is provided, it completely hides the actual name of the table. This is particularly useful when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; targets a table named &lt;code&gt;excluded&lt;/code&gt;, since that will otherwise be taken as the name of the special table representing rows proposed for insertion.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; の代替名。エイリアスを指定すると、テーブルの実際の名前が完全に非表示になります。これは、 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; が &lt;code&gt;excluded&lt;/code&gt; という名前のテーブルを対象とする場合に特に役立ちます。そうでない場合は、挿入が提案された行を表す特別なテーブルの名前と見なされます。</target>
        </trans-unit>
        <trans-unit id="1a3b95411aa0d3922856aa0c08c5b45d4d583913" translate="yes" xml:space="preserve">
          <source>A substitute name for the &lt;code&gt;FROM&lt;/code&gt; item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given &lt;code&gt;FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;SELECT&lt;/code&gt; must refer to this &lt;code&gt;FROM&lt;/code&gt; item as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</source>
          <target state="translated">エイリアスを含む &lt;code&gt;FROM&lt;/code&gt; アイテムの代替名。エイリアスは、簡潔にするため、または自己結合の曖昧さをなくすために使用されます（同じテーブルが複数回スキャンされる場合）。エイリアスを指定すると、テーブルまたは関数の実際の名前が完全に非表示になります。たとえば、 &lt;code&gt;FROM foo AS f&lt;/code&gt; の場合、 &lt;code&gt;SELECT&lt;/code&gt; の残りの部分では、この &lt;code&gt;FROM&lt;/code&gt; アイテムを &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;f&lt;/code&gt; として参照する必要があります。エイリアスを作成する場合、列エイリアスリストを作成して、テーブルの1つ以上の列の代替名を提供することもできます。</target>
        </trans-unit>
        <trans-unit id="3b6a0087f5676053b92594d5853d2ef232106666" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;DELETE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">ターゲットテーブルの代替名。エイリアスを指定すると、テーブルの実際の名前が完全に非表示になります。たとえば、 &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt; の場合、 &lt;code&gt;DELETE&lt;/code&gt; ステートメントの残りの部分では、このテーブルを &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;f&lt;/code&gt; として参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="4c430b6c82238597e098d25669857d482151c353" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;UPDATE foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;UPDATE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">ターゲットテーブルの代替名。エイリアスを指定すると、テーブルの実際の名前が完全に非表示になります。たとえば、 &lt;code&gt;UPDATE foo AS f&lt;/code&gt; の場合、 &lt;code&gt;UPDATE&lt;/code&gt; ステートメントの残りの部分では、このテーブルを &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;f&lt;/code&gt; として参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="79a0d38239253966494c7a744510fc637f363e29" translate="yes" xml:space="preserve">
          <source>A successful run will exit with status 0. Exit status 1 indicates static problems such as invalid command-line options. Errors during the run such as database errors or problems in the script will result in exit status 2. In the latter case, pgbench will print partial results.</source>
          <target state="translated">実行が成功すると、ステータス0で終了します。 終了ステータス1は、無効なコマンドラインオプションなどの静的な問題を示します。データベースエラーやスクリプト内の問題など、実行中のエラーは終了ステータス2になります。後者の場合、pgbenchは結果の一部を表示します。</target>
        </trans-unit>
        <trans-unit id="81738814316428e9e33dbf3e06dfac5985eb834b" translate="yes" xml:space="preserve">
          <source>A superuser may override this check on a per-user-mapping basis by setting the user mapping option &lt;code&gt;password_required 'false'&lt;/code&gt;, e.g.,</source>
          <target state="translated">A superuser may override this check on a per-user-mapping basis by setting the user mapping option &lt;code&gt;password_required 'false'&lt;/code&gt; , e.g.,</target>
        </trans-unit>
        <trans-unit id="00a652a2bcf1b7844eb4e57bf495f13644006240" translate="yes" xml:space="preserve">
          <source>A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, &lt;em&gt;&lt;code&gt;synchronous_standby_names&lt;/code&gt;&lt;/em&gt; currently is server wide, this means this technique will not work properly if more than one database is actively used.</source>
          <target state="translated">論理デコードを介して変更を受信する同期レプリカは、単一のデータベースのスコープで機能します。これとは対照的に、&lt;em&gt; &lt;code&gt;synchronous_standby_names&lt;/code&gt; は&lt;/em&gt;現在サーバー全体であるため、複数のデータベースがアクティブに使用されている場合、この手法は適切に機能しません。</target>
        </trans-unit>
        <trans-unit id="53732038fc5add15dbcd0175e133d7a901f6ac5b" translate="yes" xml:space="preserve">
          <source>A synchronous standby can be a physical replication standby or a logical replication subscriber. It can also be any other physical or logical WAL replication stream consumer that knows how to send the appropriate feedback messages. Besides the built-in physical and logical replication systems, this includes special programs such as &lt;code&gt;pg_receivewal&lt;/code&gt; and &lt;code&gt;pg_recvlogical&lt;/code&gt; as well as some third-party replication systems and custom programs. Check the respective documentation for details on synchronous replication support.</source>
          <target state="translated">同期スタンバイは、物理レプリケーションスタンバイまたは論理レプリケーションサブスクライバーにすることができます。また、適切なフィードバックメッセージを送信する方法を知っている他の物理的または論理的なWALレプリケーションストリームコンシューマでもかまいません。組み込みの物理および論理レプリケーションシステムに加えて、これには &lt;code&gt;pg_receivewal&lt;/code&gt; や &lt;code&gt;pg_recvlogical&lt;/code&gt; などの特別なプログラム、および一部のサードパーティレプリケーションシステムとカスタムプログラムが含まれます。同期レプリケーションのサポートの詳細については、それぞれのドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="ac835affae95f586b86b74d66f86a082fb9c7b5d" translate="yes" xml:space="preserve">
          <source>A table access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;table_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a pointer to a struct of type &lt;code&gt;TableAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the table access method. The return value needs to be of server lifetime, which is typically achieved by defining it as a &lt;code&gt;static const&lt;/code&gt; variable in global scope. The &lt;code&gt;TableAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, defines the behavior of the access method using callbacks. These callbacks are pointers to plain C functions and are not visible or callable at the SQL level. All the callbacks and their behavior is defined in the &lt;code&gt;TableAmRoutine&lt;/code&gt; structure (with comments inside the struct defining the requirements for callbacks). Most callbacks have wrapper functions, which are documented from the point of view of a user (rather than an implementor) of the table access method. For details, please refer to the &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/access/tableam.h&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">テーブルアクセスメソッドハンドラー関数は、 &lt;code&gt;internal&lt;/code&gt; タイプの単一の引数を受け入れ、疑似タイプ &lt;code&gt;table_am_handler&lt;/code&gt; を返すように宣言する必要があります。引数は、ハンドラー関数がSQLコマンドから直接呼び出されないようにするためのダミー値です。関数の結果は、 &lt;code&gt;TableAmRoutine&lt;/code&gt; 型の構造体へのポインターである必要があります。これには、テーブルアクセスメソッドを使用するためにコアコードが知る必要があるすべてのものが含まれています。戻り値はサーバーの有効期間である必要があります。これは通常、グローバルスコープで &lt;code&gt;static const&lt;/code&gt; 変数として定義することによって実現されます。 &lt;code&gt;TableAmRoutine&lt;/code&gt; の構造体、また、アクセス方法のと呼ばれる&lt;em&gt;APIの構造体&lt;/em&gt;、コールバックを使用してアクセス方法の動作を定義します。これらのコールバックはプレーンなC関数へのポインターであり、SQLレベルでは表示または呼び出しできません。すべてのコールバックとその動作は &lt;code&gt;TableAmRoutine&lt;/code&gt; 構造で定義されます（コールバックの要件を定義する構造体内のコメント付き）。ほとんどのコールバックにはラッパー関数があり、これはテーブルアクセスメソッドのユーザー（実装者ではなく）の観点から文書化されています。詳細については、&lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/access/tableam.h&lt;/code&gt; &lt;/a&gt;ファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="419d15e411a83cc5bd408b7d5b9d3b39c40e3df3" translate="yes" xml:space="preserve">
          <source>A table access method handler is declared to return &lt;code&gt;table_am_handler&lt;/code&gt;.</source>
          <target state="translated">A table access method handler is declared to return &lt;code&gt;table_am_handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ff995032ef85b617d95b6ca1e8cb93045b2fac9" translate="yes" xml:space="preserve">
          <source>A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.</source>
          <target state="translated">テーブルは、最大で1つの主キーを持つことができます。(機能的にはほとんど同じものですが、主キーとして識別できるのは1つだけです)。リレーショナルデータベースの理論では、すべてのテーブルは主キーを持たなければならないと規定されています。この規則はPostgreSQLでは施行されていませんが、通常はこれに従うのが最善です。</target>
        </trans-unit>
        <trans-unit id="a5dd3a29c662f0d5a9fc9f1c03648ba7178abbb4" translate="yes" xml:space="preserve">
          <source>A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:</source>
          <target state="translated">テーブルは複数の外部キー制約を持つことができます。これは、テーブル間の多対多の関係を実装するために使用されます。商品と注文に関するテーブルを持っていますが、1つの注文に多くの商品を含めることができるようにしたいとします(上記の構造ではできません)。このようなテーブル構造を使用することができます。</target>
        </trans-unit>
        <trans-unit id="ea2feaef62849b073ab499dff5691a69fec6f5f4" translate="yes" xml:space="preserve">
          <source>A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are &amp;ldquo;merged&amp;rdquo; so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. Inheritable check constraints and not-null constraints are merged in a similar fashion. Thus, for example, a merged column will be marked not-null if any one of the column definitions it came from is marked not-null. Check constraints are merged if they have the same name, and the merge will fail if their conditions are different.</source>
          <target state="translated">テーブルは複数の親テーブルから継承できます。その場合、親テーブルで定義された列の和集合があります。子テーブルの定義で宣言された列はすべてこれらに追加されます。同じ列名が複数の親テーブル、または親テーブルと子の定義の両方にある場合、これらの列は「マージ」され、子テーブルにそのような列は1つだけ存在します。マージするには、列のデータ型が同じである必要があります。そうでない場合、エラーが発生します。継承可能なチェック制約とnull以外の制約は、同様の方法でマージされます。したがって、たとえば、マージされた列の列定義のいずれかがnull以外としてマークされている場合、マージされた列はnull以外としてマークされます。チェック制約は、同じ名前の場合はマージされ、条件が異なる場合はマージが失敗します。</target>
        </trans-unit>
        <trans-unit id="b60ab6e47e92c777a5fb70888a73042517cd9738" translate="yes" xml:space="preserve">
          <source>A table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)</source>
          <target state="translated">テーブルは1600以上の列を持つことはできません。(実際には、タプル長制約のため、有効な制限値は通常より低くなります)。</target>
        </trans-unit>
        <trans-unit id="d9a20219501c53fe0d9df9736a36bbb3c0e01830" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and update expressions. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="translated">A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and update expressions. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; &lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9427796f4e0c19b3da10d1c29ad2a87a93a84b6f" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you wish to set up a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="translated">A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; &lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you wish to set up a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="40d4dec2662223321ee541222a2fb74e1b35e9b6" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">リレーショナルデータベースのテーブルは、紙のテーブルとよく似ています。行と列で構成されています。列の数と順序は固定されており、各列には名前があります。行数は可変です。これは、特定の瞬間に保存されるデータの量を反映しています。 SQLは、テーブル内の行の順序については保証しません。テーブルが読み取られると、ソートが明示的に要求されない限り、行は不特定の順序で表示されます。これについては、&lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;第7章で説明してい&lt;/a&gt;ます。さらに、SQLは行に一意の識別子を割り当てないため、テーブル内に完全に同一の複数の行を含めることができます。これは、SQLの基礎となる数学モデルの結果ですが、通常は望ましくありません。この章の後半では、この問題に対処する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="d3a09d1c3ee1c32fce111e8e9a61e27e850dce55" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</target>
        </trans-unit>
        <trans-unit id="0b7ed2eab9cf794fb325a1b40465300bd26db30b" translate="yes" xml:space="preserve">
          <source>A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a &lt;code&gt;JOIN&lt;/code&gt; construct, or complex combinations of these. If more than one table reference is listed in the &lt;code&gt;FROM&lt;/code&gt; clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed; see below). The result of the &lt;code&gt;FROM&lt;/code&gt; list is an intermediate virtual table that can then be subject to transformations by the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses and is finally the result of the overall table expression.</source>
          <target state="translated">テーブル参照は、テーブル名（スキーマ修飾されている可能性があります）、またはサブクエリ、 &lt;code&gt;JOIN&lt;/code&gt; 構文、またはこれらの複雑な組み合わせなどの派生テーブルにすることができます。 &lt;code&gt;FROM&lt;/code&gt; 句に複数のテーブル参照がリストされている場合、テーブルは相互結合されます（つまり、行のデカルト積が形成されます。以下を参照してください）。 &lt;code&gt;FROM&lt;/code&gt; リストの結果は中間の仮想テーブルであり、 &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句による変換の対象となり、最終的にはテーブル式全体の結果になります。</target>
        </trans-unit>
        <trans-unit id="8ea15f1133af85b529e072e262c881e0f91d10ea" translate="yes" xml:space="preserve">
          <source>A table that has columns with potentially large entries will have an associated &lt;em&gt;TOAST&lt;/em&gt; table, which is used for out-of-line storage of field values that are too large to keep in the table rows proper. &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; links from a table to its TOAST table, if any. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">エントリが大きくなる可能性のある列を持つテーブルには、関連付けられた&lt;em&gt;TOAST&lt;/em&gt;テーブルがあり、テーブルの行を適切に保持するには大きすぎるフィールド値の行外ストレージに使用されます。 &lt;code&gt;pg_class&lt;/code&gt; 。 &lt;code&gt;reltoastrelid&lt;/code&gt; は、もしあれば、テーブルからそのTOASTテーブルにリンクします。詳細については、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c16bcd4cf40264715bc5e3b5d07ef4d9afb5816" translate="yes" xml:space="preserve">
          <source>A tablesample method handler is declared to return &lt;code&gt;tsm_handler&lt;/code&gt;.</source>
          <target state="translated">tablesampleメソッドハンドラーは、 &lt;code&gt;tsm_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="816a4cd8c0ed513824b7c88b1bb7cf4571478fb1" translate="yes" xml:space="preserve">
          <source>A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside.</source>
          <target state="translated">テーブルスペースは、スーパーユーザーがデータベースオブジェクト(テーブルやインデックスなど)を含むデータファイルが存在するファイルシステム上の別の場所を定義することを可能にします。</target>
        </trans-unit>
        <trans-unit id="820b586a949a1d02483ccf3a6e05f26f2fdbeced" translate="yes" xml:space="preserve">
          <source>A tablespace can only be dropped by its owner or a superuser. The tablespace must be empty of all database objects before it can be dropped. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace. Also, if the tablespace is listed in the &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; setting of any active session, the &lt;code&gt;DROP&lt;/code&gt; might fail due to temporary files residing in the tablespace.</source>
          <target state="translated">表領域を削除できるのは、その所有者またはスーパーユーザーのみです。テーブルスペースを削除する前に、すべてのデータベースオブジェクトを空にする必要があります。現在のデータベースのオブジェクトがテーブルスペースを使用していない場合でも、他のデータベースのオブジェクトがテーブルスペースに残っている可能性があります。また、テーブルスペースがアクティブなセッションの&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;設定にリストされている場合、テーブルスペースにある一時ファイルが原因で &lt;code&gt;DROP&lt;/code&gt; が失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d48bc9df0b7c8031d0790b2f1fc9c85172017b3e" translate="yes" xml:space="preserve">
          <source>A tablespace cannot be used independently of the cluster in which it is defined; see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">テーブルスペースは、それが定義されているクラスターとは独立して使用できません。&lt;a href=&quot;manage-ag-tablespaces&quot;&gt;セクション22.6を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d579dc88e9cdf352d2f344d0841a4b50c6608379" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt; and &lt;code&gt;effective_io_concurrency&lt;/code&gt;. Setting either value for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">設定またはリセットされるテーブルスペースパラメータ。現在、使用可能なパラメーターは &lt;code&gt;seq_page_cost&lt;/code&gt; 、 &lt;code&gt;random_page_cost&lt;/code&gt; 、および &lt;code&gt;effective_io_concurrency&lt;/code&gt; のみです。特定のテーブルスペースにいずれかの値を設定すると、同じ名前の構成パラメーターによって確立された、プランナーのそのテーブルスペース内のテーブルからページを読み取るコストの通常の見積もりが上書きされます（&lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;、&lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;、&lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrencyを&lt;/a&gt;参照）。これは、1つのテーブルスペースが、I / Oサブシステムの他の部分より高速または低速のディスク上にある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4c99f85ae41b2644b7b55fc1d2d2a8d62880eaa2" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt;, &lt;code&gt;effective_io_concurrency&lt;/code&gt; and &lt;code&gt;maintenance_io_concurrency&lt;/code&gt;. Setting these values for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, and the executor's prefetching behavior, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-IO-CONCURRENCY&quot;&gt;maintenance_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt; , &lt;code&gt;random_page_cost&lt;/code&gt; , &lt;code&gt;effective_io_concurrency&lt;/code&gt; and &lt;code&gt;maintenance_io_concurrency&lt;/code&gt; . Setting these values for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, and the executor's prefetching behavior, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-IO-CONCURRENCY&quot;&gt;maintenance_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</target>
        </trans-unit>
        <trans-unit id="9ac97e0fad0b28b51a14115817e32577fe4a0b90" translate="yes" xml:space="preserve">
          <source>A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a &lt;em&gt;table alias&lt;/em&gt;.</source>
          <target state="translated">クエリの残りの部分で派生テーブルへの参照に使用されるテーブルおよび複雑なテーブル参照に一時的な名前を付けることができます。これは、&lt;em&gt;テーブルエイリアス&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="154e0fcec698de6b2015fa25f68088725ba8e1d2" translate="yes" xml:space="preserve">
          <source>A text search configuration binds a parser together with a set of dictionaries to process the parser's output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a non-&lt;code&gt;NULL&lt;/code&gt; output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</source>
          <target state="translated">テキスト検索構成は、パーサーの出力トークンを処理するために、パーサーを一連の辞書とバインドします。パーサーが返すことができるトークンタイプごとに、ディクショナリの個別のリストが構成によって指定されます。パーサーがそのタイプのトークンを見つけると、リスト内の各辞書が順番に調べられ、いくつかの辞書がそれを既知の単語として認識します。ストップワードとして識別された場合、または辞書がトークンを認識しない場合、そのトークンは破棄され、インデックス付けも検索もされません。通常、非 &lt;code&gt;NULL&lt;/code&gt; 出力を返す最初のディクショナリが結果を決定し、残りのディクショナリは参照されません。しかし、フィルタリングディクショナリは、指定された単語を変更された単語に置き換え、それを後続の辞書に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b660e99784a0c9ca392fa9c70b6890953f937efa" translate="yes" xml:space="preserve">
          <source>A text search configuration specifies all options necessary to transform a document into a &lt;code&gt;tsvector&lt;/code&gt;: the parser to use to break text into tokens, and the dictionaries to use to transform each token into a lexeme. Every call of &lt;code&gt;to_tsvector&lt;/code&gt; or &lt;code&gt;to_tsquery&lt;/code&gt; needs a text search configuration to perform its processing. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; specifies the name of the default configuration, which is the one used by text search functions if an explicit configuration parameter is omitted. It can be set in &lt;code&gt;postgresql.conf&lt;/code&gt;, or set for an individual session using the &lt;code&gt;SET&lt;/code&gt; command.</source>
          <target state="translated">テキスト検索構成は、ドキュメントを &lt;code&gt;tsvector&lt;/code&gt; に変換するために必要なすべてのオプションを指定します。テキストをトークンに分解するために使用するパーサーと、各トークンを語彙素に変換するために使用する辞書です。 &lt;code&gt;to_tsvector&lt;/code&gt; または &lt;code&gt;to_tsquery&lt;/code&gt; を呼び出すたびに、その処理を実行するためのテキスト検索構成が必要です。構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;は、デフォルト構成の名前を指定します。これは、明示的な構成パラメーターが省略された場合にテキスト検索機能によって使用されるものです。 &lt;code&gt;postgresql.conf&lt;/code&gt; で設定するか、 &lt;code&gt;SET&lt;/code&gt; コマンドを使用して個々のセッションに設定できます。</target>
        </trans-unit>
        <trans-unit id="bbb87e15ef4cfdfbfbbdeb4da5c6a41f2a086081" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</source>
          <target state="translated">シソーラス辞書(TZと略されることもある)とは、語句の関係、すなわち、広義語(BT)、狭義語(NT)、好ましい語、非好ましい語、関連語などの情報を含む語句集のことである。</target>
        </trans-unit>
        <trans-unit id="657570ff202cabc5e9df7f56f8f1f48bd50b5f6f" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary uses a &lt;em&gt;subdictionary&lt;/em&gt; (which is specified in the dictionary's configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (&lt;code&gt;*&lt;/code&gt;) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words &lt;em&gt;must&lt;/em&gt; be known to the subdictionary.</source>
          <target state="translated">シソーラスディクショナリは、&lt;em&gt;サブディクショナリ&lt;/em&gt;（ディクショナリの設定で指定されている）を使用して、フレーズの一致をチェックする前に入力テキストを正規化します。 1つのサブディクショナリのみを選択できます。副辞書が単語を認識できない場合、エラーが報告されます。その場合は、単語の使用を削除するか、その単語について副辞書に教える必要があります。インデックス付きの単語の先頭にアスタリスク（ &lt;code&gt;*&lt;/code&gt; ）を配置して、サブディクショナリの適用をスキップできますが、サンプルの単語&lt;em&gt;は&lt;/em&gt;すべてサブディクショナリに認識されている&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="555f5a4dff77bb6e52e02e4204a9cef467ac2510" translate="yes" xml:space="preserve">
          <source>A third identifier type used by the system is &lt;code&gt;cid&lt;/code&gt;, or command identifier. This is the data type of the system columns &lt;code&gt;cmin&lt;/code&gt; and &lt;code&gt;cmax&lt;/code&gt;. Command identifiers are also 32-bit quantities.</source>
          <target state="translated">システムが使用する3番目の識別子タイプは &lt;code&gt;cid&lt;/code&gt; （コマンド識別子）です。これは、システム列 &lt;code&gt;cmin&lt;/code&gt; および &lt;code&gt;cmax&lt;/code&gt; のデータ型です。コマンド識別子も32ビットの数量です。</target>
        </trans-unit>
        <trans-unit id="ea6ae6aa8002700db2a8dea433bfc36222024c69" translate="yes" xml:space="preserve">
          <source>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</source>
          <target state="translated">部分インデックスの3番目の使用方法として、クエリでインデックスを使用する必要はまったくありません。ここでのアイデアは、&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;例11.3の&lt;/a&gt;ように、テーブルのサブセットに対して一意のインデックスを作成することです。これにより、インデックス述語を満たさない行を制約することなく、インデックス述語を満たす行間の一意性が強制されます。</target>
        </trans-unit>
        <trans-unit id="47db754740c9f2ded7d303bbef7ae69f38fb4dbf" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt; . Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</target>
        </trans-unit>
        <trans-unit id="fd6336e70f63a890b86a6cdbf6ec2c2a9832cb6d" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">タイムゾーンの省略形（例： &lt;code&gt;PST&lt;/code&gt; )。このような仕様は、一連の夏時間の移行日規則も意味する可能性がある完全なタイムゾーン名とは対照的に、UTCからの特定のオフセットを定義するだけです。認識される略語は &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; ビューにリストされます（&lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;項51.91を&lt;/a&gt;参照）。構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;または&lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt;をタイムゾーンの省略形に設定することはできませんが、日付/時刻の入力値および &lt;code&gt;AT TIME ZONE&lt;/code&gt; 演算子で省略形を使用できます。</target>
        </trans-unit>
        <trans-unit id="1c1c7cede62c34481ae2c11f0263c23892006d69" translate="yes" xml:space="preserve">
          <source>A time zone cannot be specified when processing &lt;code&gt;timestamp without time zone&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt; inputs. These are always taken at face value.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; または &lt;code&gt;interval&lt;/code&gt; 入力なしでタイムスタンプを処理する場合、タイムゾーンを指定することはできません。これらは常に額面どおりに取得されます。</target>
        </trans-unit>
        <trans-unit id="f8aefcc9f6e4a3be95cca7cfd42df6a2625d531c" translate="yes" xml:space="preserve">
          <source>A timezone abbreviation file can contain blank lines and comments beginning with &lt;code&gt;#&lt;/code&gt;. Non-comment lines must have one of these formats:</source>
          <target state="translated">タイムゾーン省略形ファイルには、空白行と &lt;code&gt;#&lt;/code&gt; で始まるコメントを含めることができます。非コメント行には、次のいずれかの形式が必要です。</target>
        </trans-unit>
        <trans-unit id="61f64c13915c0871a3186bb5a87ae1ae25b54733" translate="yes" xml:space="preserve">
          <source>A token can be a &lt;em&gt;key word&lt;/em&gt;, an &lt;em&gt;identifier&lt;/em&gt;, a &lt;em&gt;quoted identifier&lt;/em&gt;, a &lt;em&gt;literal&lt;/em&gt; (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).</source>
          <target state="translated">トークンには、&lt;em&gt;キーワード&lt;/em&gt;、&lt;em&gt;識別子&lt;/em&gt;、&lt;em&gt;引用符付き識別子&lt;/em&gt;、&lt;em&gt;リテラル&lt;/em&gt;（または定数）、または特殊文字記号を使用できます。トークンは通常、空白（スペース、タブ、改行）で区切られますが、あいまいさがない場合は必要ありません（通常、特殊文字が他のトークンタイプに隣接している場合のみです）。</target>
        </trans-unit>
        <trans-unit id="8690158fd0b251c00dae6dfc7ede983456ddc45f" translate="yes" xml:space="preserve">
          <source>A token type emitted by the configuration's parser</source>
          <target state="translated">設定のパーサから出力されるトークン型</target>
        </trans-unit>
        <trans-unit id="c55f58174d7a27cababe64df945ac6699fb690f5" translate="yes" xml:space="preserve">
          <source>A transaction can also see its own statistics (as yet untransmitted to the collector) in the views &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt;, and &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt;. These numbers do not act as stated above; instead they update continuously throughout the transaction.</source>
          <target state="translated">トランザクションは、 &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; 、 &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt; 、 &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt; 、および &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt; のビューで、独自の統計情報（まだコレクターに送信されていない）を表示することもできます。これらの数値は上記のようには機能しません。代わりに、トランザクション全体で継続的に更新されます。</target>
        </trans-unit>
        <trans-unit id="014bab7370933e95d60b2fbeb6b4ddd7ac675ebb" translate="yes" xml:space="preserve">
          <source>A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1d7c34d636397a5326ca01bffe81c685d0466ea6" translate="yes" xml:space="preserve">
          <source>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</source>
          <target state="translated">トランザクションは、検索条件を満たす行のセットを返すクエリを再実行し、最近コミットされた別のトランザクションによって条件を満たす行のセットが変更されたことを発見します。</target>
        </trans-unit>
        <trans-unit id="f8c2fd7479305ce91383c02d70969dd66b2acddb" translate="yes" xml:space="preserve">
          <source>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</source>
          <target state="translated">トランザクションは、以前に読んだデータを再読み込みし、データが別のトランザクション(最初の読み込み以降にコミットされたもの)によって変更されたことを発見します。</target>
        </trans-unit>
        <trans-unit id="c3382e299466bb042feceee6752ca8ef0259c657" translate="yes" xml:space="preserve">
          <source>A transaction reads data written by a concurrent uncommitted transaction.</source>
          <target state="translated">トランザクションは、並行しているコミットされていないトランザクションによって書き込まれたデータを読み込みます。</target>
        </trans-unit>
        <trans-unit id="f339f7f826bbe705459f4d6147b96402061e9382" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;LISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; を実行したトランザクションは、2フェーズコミットの準備ができません。</target>
        </trans-unit>
        <trans-unit id="3d0230fafa23fc125f62b605c5c7adbafb550941" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;NOTIFY&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; を実行したトランザクションは、2フェーズコミットの準備ができません。</target>
        </trans-unit>
        <trans-unit id="6073bbb0958767b4f02cfd2e64c1259376f80a5e" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;UNLISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; を実行したトランザクションは、2フェーズコミットの準備ができません。</target>
        </trans-unit>
        <trans-unit id="fbb0eb006f978734fefdbee822c93e37ab76e793" translate="yes" xml:space="preserve">
          <source>A transform specifies how to adapt a data type to a procedural language. For example, when writing a function in PL/Python using the &lt;code&gt;hstore&lt;/code&gt; type, PL/Python has no prior knowledge how to present &lt;code&gt;hstore&lt;/code&gt; values in the Python environment. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate.</source>
          <target state="translated">変換は、データ型を手続き型言語に適合させる方法を指定します。たとえば、 &lt;code&gt;hstore&lt;/code&gt; タイプを使用してPL / Pythonで関数を作成する場合、PL / Pythonには、Python環境で &lt;code&gt;hstore&lt;/code&gt; 値を表示する方法に関する事前の知識がありません。言語の実装は通常、デフォルトでテキスト表現を使用しますが、たとえば、連想配列やリストの方が適切な場合は不便です。</target>
        </trans-unit>
        <trans-unit id="8c2b373e9fbb9296093271c1db45ed67d33a82b6" translate="yes" xml:space="preserve">
          <source>A transform specifies two functions:</source>
          <target state="translated">トランスフォームは2つの関数を指定します。</target>
        </trans-unit>
        <trans-unit id="0c9fe367d63aa8028ded2402f8662551682fdc1d" translate="yes" xml:space="preserve">
          <source>A trigger function is declared to return &lt;code&gt;trigger.&lt;/code&gt;</source>
          <target state="translated">トリガー関数はトリガーを返すように宣言されてい &lt;code&gt;trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7aece537a33eef527a0311c288ac02d9c4de009" translate="yes" xml:space="preserve">
          <source>A trigger that is marked &lt;code&gt;FOR EACH ROW&lt;/code&gt; is called once for every row that the operation modifies. For example, a &lt;code&gt;DELETE&lt;/code&gt; that affects 10 rows will cause any &lt;code&gt;ON DELETE&lt;/code&gt; triggers on the target relation to be called 10 separate times, once for each deleted row. In contrast, a trigger that is marked &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; triggers).</source>
          <target state="translated">&lt;code&gt;FOR EACH ROW&lt;/code&gt; とマークされたトリガーは、操作が変更する行ごとに1回呼び出されます。たとえば、10行に影響する &lt;code&gt;DELETE&lt;/code&gt; を使用すると、ターゲットリレーションの &lt;code&gt;ON DELETE&lt;/code&gt; トリガーが、削除された行ごとに1回ずつ、10回ずつ呼び出されます。対照的に、 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; とマークされたトリガーは、変更する行の数に関係なく、特定の操作に対して一度だけ実行されます（特に、ゼロ行を変更する操作でも、適用可能な &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; トリガーが実行されます）。 。</target>
        </trans-unit>
        <trans-unit id="7eef7b97e3bd1ce7b7ee3cef5b1119d2228d0033" translate="yes" xml:space="preserve">
          <source>A trigram is a group of three consecutive characters taken from a string. We can measure the similarity of two strings by counting the number of trigrams they share. This simple idea turns out to be very effective for measuring the similarity of words in many natural languages.</source>
          <target state="translated">トリグラムとは、文字列から取り出された3つの連続した文字のグループのことです。2つの文字列の類似度は、2つの文字列が共有しているトリグラムの数を数えることで測定できます。この単純なアイデアは、多くの自然言語の単語の類似度を測定するのに非常に効果的であることがわかりました。</target>
        </trans-unit>
        <trans-unit id="a08b1cdf2b0b095b9d5863bddf7e5d8e3d7c32c3" translate="yes" xml:space="preserve">
          <source>A trivial example of &lt;code&gt;LATERAL&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; の簡単な例は</target>
        </trans-unit>
        <trans-unit id="e8e38ccfb8ee20281247054f727fc62c3822f6eb" translate="yes" xml:space="preserve">
          <source>A type cast</source>
          <target state="translated">タイプキャスト</target>
        </trans-unit>
        <trans-unit id="3a3537ff39dd61d4d97ae8731a9b41e347a01f70" translate="yes" xml:space="preserve">
          <source>A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:</source>
          <target state="translated">型キャストは、あるデータ型から別のデータ型への変換を指定します。PostgreSQLは型キャストに対して2つの同等の構文を受け付けています。</target>
        </trans-unit>
        <trans-unit id="191f8bc0dbd057f5d062293ad47b726e2c4bd97b" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or a combination of columns so that each value or combination of values can only appear once in the relation &amp;mdash; that is, no other row in the relation contains values that are equal to those.</source>
          <target state="translated">A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or a combination of columns so that each value or combination of values can only appear once in the relation &amp;mdash; that is, no other row in the relation contains values that are equal to those.</target>
        </trans-unit>
        <trans-unit id="47769c3fbebe762aaf5ca2f230501fed1e2e6077" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;. The check constraint can make reference to any attribute of the same row in the relation, but cannot reference other rows of the same relation or other relations.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;属性で&lt;/a&gt;許可される値を制限する&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;リレーション&lt;/a&gt;で定義された&lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;制約&lt;/a&gt;のタイプ。チェック制約は、リレーション内の同じ行の任意の属性を参照できますが、同じリレーションまたは他のリレーションの他の行を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="4e0d1fa65cb5707a942beda0ba4cefcb538e80bc" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on one or more &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; which requires the value(s) in those &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; to identify zero or one &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; in another (or, infrequently, the same) &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;内の1つ以上の&lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;列&lt;/a&gt;に定義された&lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;制約&lt;/a&gt;のタイプで、別の（またはまれに同じ）&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;内のゼロまたは1つの&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;行&lt;/a&gt;を識別するためにそれらの&lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;列&lt;/a&gt;の値を必要とします。</target>
        </trans-unit>
        <trans-unit id="d90f0d3baf2cdb5f8ece9a12f549c13ec0fed9a9" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; used in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; that applies to a &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partition&lt;/a&gt; of the query's &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result set&lt;/a&gt;; the function's result is based on values found in &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the same partition or frame.</source>
          <target state="translated">クエリの&lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;結果セット&lt;/a&gt;の&lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;パーティション&lt;/a&gt;に適用される、&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;クエリ&lt;/a&gt;で使用される&lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;関数&lt;/a&gt;のタイプ。関数の結果は、同じパーティションまたはフレームの&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;行&lt;/a&gt;にある値に基づいています。</target>
        </trans-unit>
        <trans-unit id="cf5a2e79c8fc1633f97f91eb24cc9a0675c7c13b" translate="yes" xml:space="preserve">
          <source>A type of relation that is used to generate values. Typically the generated values are sequential non-repeating numbers. They are commonly used to generate surrogate &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; values.</source>
          <target state="translated">値を生成するために使用される関係のタイプ。通常、生成される値は連続した非反復番号です。これらは通常、代理の&lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;主キー&lt;/a&gt;値を生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d6c0d0a70cc72776a389a8d07d0b7fa59473f06b" translate="yes" xml:space="preserve">
          <source>A type of routine that receives zero or more arguments, returns zero or more output values, and is constrained to run within one transaction. Functions are invoked as part of a query, for example via &lt;code&gt;SELECT&lt;/code&gt;. Certain functions can return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;sets&lt;/a&gt;; those are called &lt;em&gt;set-returning functions&lt;/em&gt;.</source>
          <target state="translated">ゼロ個以上の引数を受け取り、ゼロ個以上の出力値を返し、1つのトランザクション内で実行するように制約されているルーチンのタイプ。関数は、クエリの一部として、たとえば &lt;code&gt;SELECT&lt;/code&gt; を介して呼び出されます。特定の関数は&lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;セット&lt;/a&gt;を返すことができます; それらは&lt;em&gt;集合戻り関数&lt;/em&gt;と呼ば&lt;em&gt;れます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="103d10d7e532eccef03717f65e1f2bc653ed5156" translate="yes" xml:space="preserve">
          <source>A type of routine. Their distinctive qualities are that they do not return values, and that they are allowed to make transactional statements such as &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;. They are invoked via the &lt;code&gt;CALL&lt;/code&gt; command.</source>
          <target state="translated">ルーチンの一種。それらの特徴は、値を返さないことと、 &lt;code&gt;COMMIT&lt;/code&gt; や &lt;code&gt;ROLLBACK&lt;/code&gt; などのトランザクションステートメントを作成できることです。これらは、 &lt;code&gt;CALL&lt;/code&gt; コマンドを介して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2685b870f0e5693341cc020b2215b601f4f13b60" translate="yes" xml:space="preserve">
          <source>A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:</source>
          <target state="translated">テーブルエイリアスの典型的なアプリケーションは、長いテーブル名に短い識別子を代入して、結合句を読みやすくすることです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="53e9ce7093c6b3d709e92599c2e63f01a872a533" translate="yes" xml:space="preserve">
          <source>A typical cost estimator will proceed as follows:</source>
          <target state="translated">一般的なコストの見積もりは、以下のように進めていきます。</target>
        </trans-unit>
        <trans-unit id="0dc6b779feedceaca26b9995072395fe22118094" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that shared memory objects used for parallel query execution are removed at apparently random times, leading to errors and warnings while attempting to open and remove them, like</source>
          <target state="translated">この設定がオンの場合に観測される典型的な影響は、並列クエリの実行に使用される共有メモリオブジェクトが明らかにランダムなタイミングで削除され、それらを開いたり削除したりしようとしたときにエラーや警告が発生することです。</target>
        </trans-unit>
        <trans-unit id="c8d74e530024da711c01ee4999c6bbacc75f1477" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that the semaphore objects used by a PostgreSQL server are removed at apparently random times, leading to the server crashing with log messages like</source>
          <target state="translated">この設定をオンにした場合に観測される典型的な効果は、PostgreSQLサーバで使用されるセマフォオブジェクトが明らかにランダムなタイミングで削除され、以下のようなログメッセージでサーバがクラッシュすることです。</target>
        </trans-unit>
        <trans-unit id="3fc9f5b992a80655782589dd8a0df2c7a647d35a" translate="yes" xml:space="preserve">
          <source>A typical query that can use this index would be:</source>
          <target state="translated">このインデックスを使用できる典型的なクエリは、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="0521362e3f43575ffcfbc899da16b98a9800ce48" translate="yes" xml:space="preserve">
          <source>A typical use is in reading the current value of the sequence for an identity or serial column, for example:</source>
          <target state="translated">典型的な使用法は、例えば、ID 列やシリアル列のシーケンスの現在値を読み取ることです。</target>
        </trans-unit>
        <trans-unit id="169a523c2d612c2511933ebb2897995bb069e2f2" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication origin. Should never leave the system.</source>
          <target state="translated">レプリケーション元のクラスタ全体で一意な識別子です。決してシステムから離れるべきではありません。</target>
        </trans-unit>
        <trans-unit id="47f21621fe9103c27d1085b3377ce1e6907d3fec" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication slot</source>
          <target state="translated">レプリケーションスロットのクラスタ全体で一意な識別子</target>
        </trans-unit>
        <trans-unit id="5d4bfd425f4eb16bbefa46dacd068b22bd41528d" translate="yes" xml:space="preserve">
          <source>A useful property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling &lt;code&gt;WITH&lt;/code&gt; queries. Thus, expensive calculations that are needed in multiple places can be placed within a &lt;code&gt;WITH&lt;/code&gt; query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query, since that might affect all uses of the &lt;code&gt;WITH&lt;/code&gt; query's output when it should affect only one. The multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; クエリの有用な特性は、親クエリまたは兄弟 &lt;code&gt;WITH&lt;/code&gt; クエリによって複数回参照されている場合でも、通常は親クエリの実行ごとに1回だけ評価されることです。したがって、複数の場所で必要となる高価な計算を &lt;code&gt;WITH&lt;/code&gt; クエリ内に配置して、冗長な作業を回避できます。別の可能なアプリケーションは、副作用のある関数の不要な複数の評価を防ぐことです。ただし、このコインのもう1つの側面は、オプティマイザが制限を親クエリから多重参照された &lt;code&gt;WITH&lt;/code&gt; クエリにプッシュできないことです。これは、 &lt;code&gt;WITH&lt;/code&gt; クエリの出力のすべての使用に影響する可能性がある場合に影響する可能性があるためです。多重参照 &lt;code&gt;WITH&lt;/code&gt; クエリは、親クエリが後で破棄する可能性がある行を抑制せずに、書き込まれたとおりに評価されます。（ただし、前述のように、クエリへの参照が限られた数の行のみを要求する場合、評価は早期に停止する可能性があります。）</target>
        </trans-unit>
        <trans-unit id="46f8eb17a4dc6792884149cbde1b901dd618e58c" translate="yes" xml:space="preserve">
          <source>A user able to modify the schema of subscriber-side tables can execute arbitrary code as a superuser. Limit ownership and &lt;code&gt;TRIGGER&lt;/code&gt; privilege on such tables to roles that superusers trust. Moreover, if untrusted users can create tables, use only publications that list tables explicitly. That is to say, create a subscription &lt;code&gt;FOR ALL TABLES&lt;/code&gt; only when superusers trust every user permitted to create a non-temp table on the publisher or the subscriber.</source>
          <target state="translated">サブスクライバー側のテーブルのスキーマを変更できるユーザーは、スーパーユーザーとして任意のコードを実行できます。このようなテーブルの所有権と &lt;code&gt;TRIGGER&lt;/code&gt; 特権を、スーパーユーザーが信頼するロールに制限します。さらに、信頼できないユーザーがテーブルを作成できる場合は、テーブルを明示的にリストしているパブリケーションのみを使用してください。つまり、スーパーユーザーがパブリッシャーまたはサブスクライバーで非一時テーブルの作成を許可されたすべてのユーザーを信頼する場合にのみ、 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; テーブルのサブスクリプションを作成します。</target>
        </trans-unit>
        <trans-unit id="624d70f8d00542243273d8f95b839148832783a9" translate="yes" xml:space="preserve">
          <source>A user can also be allowed to create objects in someone else's schema. To allow that, the &lt;code&gt;CREATE&lt;/code&gt; privilege on the schema needs to be granted. Note that by default, everyone has &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt; privileges on the schema &lt;code&gt;public&lt;/code&gt;. This allows all users that are able to connect to a given database to create objects in its &lt;code&gt;public&lt;/code&gt; schema. Some &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;usage patterns&lt;/a&gt; call for revoking that privilege:</source>
          <target state="translated">ユーザーは、他の誰かのスキーマにオブジェクトを作成することも許可されます。これを可能にするには、スキーマに対する &lt;code&gt;CREATE&lt;/code&gt; 特権を付与する必要があります。デフォルトでは、誰もがスキーマ &lt;code&gt;public&lt;/code&gt; に対する &lt;code&gt;CREATE&lt;/code&gt; および &lt;code&gt;USAGE&lt;/code&gt; 特権を持っていることに注意してください。これにより、特定のデータベースに接続できるすべてのユーザーが、その &lt;code&gt;public&lt;/code&gt; スキーマにオブジェクトを作成できます。一部の&lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;使用パターンで&lt;/a&gt;は、その特権を取り消す必要があります。</target>
        </trans-unit>
        <trans-unit id="b9aa765822babac771b767a7977f197f0cfd20dc" translate="yes" xml:space="preserve">
          <source>A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use the &lt;code&gt;CASCADE&lt;/code&gt; option so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.</source>
          <target state="translated">ユーザーは、そのユーザーが直接付与した特権のみを取り消すことができます。たとえば、ユーザーAがユーザーBに付与オプション付きの権限を付与し、ユーザーBがユーザーCに付与した場合、ユーザーAはCから直接権限を取り消すことはできません。代わりに、ユーザーAが付与オプションを取り消すことができます。ユーザーBから &lt;code&gt;CASCADE&lt;/code&gt; オプションを使用して、ユーザーCから特権を取り消します。別の例として、AとBの両方がCに同じ特権を付与した場合、Aは自分の付与を取り消すことができますが、Bの付与は取り消せません。C引き続き特権が有効になります。</target>
        </trans-unit>
        <trans-unit id="9eef0500388438dcdd883438e62adfff2b4c59d7" translate="yes" xml:space="preserve">
          <source>A user mapping, defined with &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, is needed as well to identify the role that will be used on the remote server:</source>
          <target state="translated">リモートサーバーで使用されるロールを識別するには、&lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;で定義されたユーザーマッピングも必要です。</target>
        </trans-unit>
        <trans-unit id="cd811596f6c21fd6820e0962c95748afb5dd8832" translate="yes" xml:space="preserve">
          <source>A user may perform &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.</source>
          <target state="translated">ユーザーは、特定の列またはそのテーブル全体に対する特権を保持している場合、列に対して &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; などを実行できます。テーブルレベルで権限を付与し、それを1つの列に対して取り消しても、期待どおりの結果は得られません。テーブルレベルの付与は、列レベルの操作の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="8d16a3b790258dd6e7bcb147ac82c63396f9dabe" translate="yes" xml:space="preserve">
          <source>A user with appropriate privileges can pass &lt;code&gt;tablespace_name&lt;/code&gt; to &lt;code&gt;CREATE DATABASE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; to have the data files for these objects stored within the specified tablespace.</source>
          <target state="translated">適切な権限を持つユーザーは、 &lt;code&gt;tablespace_name&lt;/code&gt; を &lt;code&gt;CREATE DATABASE&lt;/code&gt; 、 &lt;code&gt;CREATE TABLE&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX&lt;/code&gt; 、または &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; に渡して、これらのオブジェクトのデータファイルを指定されたテーブルスペース内に格納できます。</target>
        </trans-unit>
        <trans-unit id="cb5146129674511426d710b87f38fac56dd128fd" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no argument and returning type &lt;code&gt;event_trigger&lt;/code&gt;.</source>
          <target state="translated">引数をとらず、タイプ &lt;code&gt;event_trigger&lt;/code&gt; を返すと宣言されたユーザー提供の関数。</target>
        </trans-unit>
        <trans-unit id="944b09ef2e50c44bc480f5f428bf817a45e1996f" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no arguments and returning type &lt;code&gt;trigger&lt;/code&gt;, which is executed when the trigger fires.</source>
          <target state="translated">引数をとらず、トリガーが起動したときに実行される &lt;code&gt;trigger&lt;/code&gt; 型を返すように宣言されているユーザー指定の関数。</target>
        </trans-unit>
        <trans-unit id="3c03a8192bb8c460f615ba363c0076eb7beddfc8" translate="yes" xml:space="preserve">
          <source>A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types. To signal an error, the validator function should use the &lt;code&gt;ereport()&lt;/code&gt; function. The return value of the function is ignored.</source>
          <target state="translated">バリデーター関数は通常、構文の正確さについて関数本体を検査しますが、たとえば言語が特定の引数タイプを処理できない場合など、関数の他のプロパティも調べることができます。エラーを通知するには、検証関数は &lt;code&gt;ereport()&lt;/code&gt; 関数を使用する必要があります。関数の戻り値は無視されます。</target>
        </trans-unit>
        <trans-unit id="7bb559a62e1812965348b9dc25a132908d898b4a" translate="yes" xml:space="preserve">
          <source>A value (but not a key) can be an SQL &lt;code&gt;NULL&lt;/code&gt;. For example:</source>
          <target state="translated">キーではなく値をSQL &lt;code&gt;NULL&lt;/code&gt; にすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="f11b15a75cd7fa69b386c1868dbf1a5bd1c71215" translate="yes" xml:space="preserve">
          <source>A value expression is one of the following:</source>
          <target state="translated">値の式は以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="15f463c504877012fea738b4b0d0b079a3d4f123" translate="yes" xml:space="preserve">
          <source>A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: &lt;code&gt;MATCH FULL&lt;/code&gt;, &lt;code&gt;MATCH PARTIAL&lt;/code&gt;, and &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (which is the default). &lt;code&gt;MATCH FULL&lt;/code&gt; will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; is not yet implemented. (Of course, &lt;code&gt;NOT NULL&lt;/code&gt; constraints can be applied to the referencing column(s) to prevent these cases from arising.)</source>
          <target state="translated">参照列に挿入された値は、指定された一致タイプを使用して、参照されるテーブルおよび参照される列の値と照合されます。マッチタイプには、 &lt;code&gt;MATCH FULL&lt;/code&gt; 、 &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 、および &lt;code&gt;MATCH SIMPLE&lt;/code&gt; （デフォルト）の3つがあります。 &lt;code&gt;MATCH FULL&lt;/code&gt; では、すべての外部キー列がnullでない限り、複数列の外部キーの1つの列をnullにすることはできません。それらがすべてnullの場合、参照先のテーブルで一致する必要はありません。 &lt;code&gt;MATCH SIMPLE&lt;/code&gt; では、任意の外部キー列をnullにすることができます。それらのいずれかがnullの場合、その行は参照先のテーブルで一致する必要はありません。 &lt;code&gt;MATCH PARTIAL&lt;/code&gt; はまだ実装されていません。 （もちろん、 &lt;code&gt;NOT NULL&lt;/code&gt; 参照列に制約を適用して、これらのケースが発生しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d3f19f348507a8389d8d149cdf77d56e254062cd" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON text to be queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">照会されるJSONテキストを表す変数（&lt;em&gt;コンテキストアイテム&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ad2426a5221bd13cdbc6ec097f91418bf9cf0787" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON value being queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">クエリされるJSON値を表す変数（&lt;em&gt;コンテキストアイテム&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b7ff43247d2073dd8c93ef6f893b8751eb3e7bd" translate="yes" xml:space="preserve">
          <source>A variable representing the result of path evaluation in filter expressions.</source>
          <target state="translated">フィルタ式におけるパス評価の結果を表す変数。</target>
        </trans-unit>
        <trans-unit id="156f0d479c5cbda4c018211d44db7834d2c5eaed" translate="yes" xml:space="preserve">
          <source>A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier &lt;code&gt;&quot;data&quot;&lt;/code&gt; could be written as</source>
          <target state="translated">引用符で囲まれた識別子のバリアントでは、コードポイントで識別されるエスケープされたUnicode文字を含めることができます。このバリアントは、 &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt; ように、間にスペースを入れずに、開始二重引用符の直前に &lt;code&gt;U&amp;amp;&lt;/code&gt; （大文字または小文字のUの後にアンパサンドが続く）で始まります。 （これにより、演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; で曖昧さが生じることに注意してください。この問題を回避するために、演算子の周りにスペースを使用してください。）引用符内では、バックスラッシュとそれに続く4桁の16進コードポイント番号またはまたは、バックスラッシュとそれに続くプラス記号、それに続く6桁の16進コードポイント番号。たとえば、識別子 &lt;code&gt;&quot;data&quot;&lt;/code&gt; は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="acdae0bdc3109dd35a6d548731ba6bb6d6a12b1e" translate="yes" xml:space="preserve">
          <source>A variant of the above query is</source>
          <target state="translated">上記のクエリの変形例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="86b56417739883cc59cc6c063327a17fce9dbe75" translate="yes" xml:space="preserve">
          <source>A view column name list must be specified for a recursive view.</source>
          <target state="translated">再帰ビューでは、ビューのカラム名リストを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="85b3bfd48768285b52ad306ba0d6292137e9c9f1" translate="yes" xml:space="preserve">
          <source>A view that is simple enough to be automatically updatable (see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;) does not require a user-created rule in order to be updatable. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule.</source>
          <target state="translated">自動的に更新可能であるほど単純なビュー（&lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEWを&lt;/a&gt;参照）では、更新可能にするためにユーザーが作成したルールは必要ありません。とにかく明示的なルールを作成できますが、自動更新変換は通常、明示的なルールよりも優れています。</target>
        </trans-unit>
        <trans-unit id="b5c5c1bad9d2f71be50a1fcf23b697eb7750bb21" translate="yes" xml:space="preserve">
          <source>A window function call</source>
          <target state="translated">ウィンドウ関数の呼び出し</target>
        </trans-unit>
        <trans-unit id="014e860f54b04147bfef99f64476d36d0f965833" translate="yes" xml:space="preserve">
          <source>A window function call always contains an &lt;code&gt;OVER&lt;/code&gt; clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or non-window aggregate. The &lt;code&gt;OVER&lt;/code&gt; clause determines exactly how the rows of the query are split up for processing by the window function. The &lt;code&gt;PARTITION BY&lt;/code&gt; clause within &lt;code&gt;OVER&lt;/code&gt; divides the rows into groups, or partitions, that share the same values of the &lt;code&gt;PARTITION BY&lt;/code&gt; expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</source>
          <target state="translated">ウィンドウ関数呼び出しには、常にウィンドウ関数の名前と引数の直後に &lt;code&gt;OVER&lt;/code&gt; 句が含まれます。これが、通常の関数または非ウィンドウ集約と構文的に区別するものです。 &lt;code&gt;OVER&lt;/code&gt; の句は、クエリの行が窓関数を処理するために分割されている正確にどのように決定されます。 &lt;code&gt;OVER&lt;/code&gt; 内の &lt;code&gt;PARTITION BY&lt;/code&gt; 句は、行を &lt;code&gt;PARTITION BY&lt;/code&gt; 式の同じ値を共有するグループまたはパーティションに分割します。各行について、ウィンドウ関数は、現在の行と同じパーティションに分類される行全体で計算されます。</target>
        </trans-unit>
        <trans-unit id="69ff975e62e5e9881d6e40cfa6394518b64c0b59" translate="yes" xml:space="preserve">
          <source>A word is defined as in the specification of &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; above. Constraint escapes are illegal within bracket expressions.</source>
          <target state="translated">単語は、上記の &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; および &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; の仕様のように定義されます。括弧エスケープ内の制約エスケープは無効です。</target>
        </trans-unit>
        <trans-unit id="e7b5c134c4da8e8da4908f5aacc24a6aa1409eb3" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">待機中の &lt;code&gt;restore_command&lt;/code&gt; の実際の例は、&lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;モジュールで提供されています。上記のロジックを正しく実装する方法のリファレンスとして使用してください。特定の構成と環境をサポートするために、必要に応じて拡張することもできます。</target>
        </trans-unit>
        <trans-unit id="94040fbf2d2ff3dac676f0671c8578ae0488b46e" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">待機中の &lt;code&gt;restore_command&lt;/code&gt; の実用的な例は、&lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;モジュールで提供されています。上記のロジックを正しく実装する方法のリファレンスとして使用する必要があります。特定の構成や環境をサポートするために、必要に応じて拡張することもできます。</target>
        </trans-unit>
        <trans-unit id="4d87e11b3c84c752269b580bca5caeedfc37d702" translate="yes" xml:space="preserve">
          <source>A write transaction has more than 64 subtransactions</source>
          <target state="translated">書き込みトランザクションには64以上のサブトランザクションがあります。</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="7a0ffd6011b0a819cbe07ec59ab6319e323b19e8" translate="yes" xml:space="preserve">
          <source>ABORT &amp;mdash; abort the current transaction</source>
          <target state="translated">ABORT &amp;mdash;現在のトランザクションを中止します</target>
        </trans-unit>
        <trans-unit id="e3a56e2d83c5cd3911209ecd97318531d89949dd" translate="yes" xml:space="preserve">
          <source>ACCESS EXCLUSIVE</source>
          <target state="translated">アクセスエクスクルーシブ</target>
        </trans-unit>
        <trans-unit id="236082e0393025e2b67ccb853e349993a3e685de" translate="yes" xml:space="preserve">
          <source>ACCESS SHARE</source>
          <target state="translated">アクセスシェア</target>
        </trans-unit>
        <trans-unit id="d4c15b3f603d1252b36800551086669559ae86a4" translate="yes" xml:space="preserve">
          <source>ACID</source>
          <target state="translated">ACID</target>
        </trans-unit>
        <trans-unit id="41f215a6d36c7782875bfb5d6d290ebb1e7961df" translate="yes" xml:space="preserve">
          <source>AES</source>
          <target state="translated">AES</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="d3f3cb97007280f4a9b1e690872959eda00344a5" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE</source>
          <target state="translated">アルターアグリゲート</target>
        </trans-unit>
        <trans-unit id="ed3d1c36faecc14690efbf5d3029f3dd4930091a" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE &amp;mdash; change the definition of an aggregate function</source>
          <target state="translated">ALTER AGGREGATE &amp;mdash;集約関数の定義を変更する</target>
        </trans-unit>
        <trans-unit id="a11472b885174cf0a5b8f565bbd9df33d5c63d9f" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION</source>
          <target state="translated">演算子の変更</target>
        </trans-unit>
        <trans-unit id="56c3d4607ffe2e71e2c5f2646969f8ca0df737b4" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION &amp;mdash; change the definition of a collation</source>
          <target state="translated">ALTER COLLATION &amp;mdash;照合の定義を変更する</target>
        </trans-unit>
        <trans-unit id="41b42a1cc1e0f91fde1b7c9e18dfe7b36339b901" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION</source>
          <target state="translated">アルター変換</target>
        </trans-unit>
        <trans-unit id="ccebf78a2dc7b51b4b857717880c57e697294e8c" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION &amp;mdash; change the definition of a conversion</source>
          <target state="translated">ALTER CONVERSION &amp;mdash;変換の定義を変更する</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">データベースを変更する</target>
        </trans-unit>
        <trans-unit id="bea7726d13edb6ca210b4e6c9e61ad1bc910bed8" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE &amp;mdash; change a database</source>
          <target state="translated">ALTER DATABASE &amp;mdash;データベースを変更する</target>
        </trans-unit>
        <trans-unit id="2d6bcd612a3e7b99bb9476838637e9b5438e3634" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES</source>
          <target state="translated">デフォルト特権の変更</target>
        </trans-unit>
        <trans-unit id="d8ff7f2d5af359b01a54f95e0ec2fd521bd7747c" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES &amp;mdash; define default access privileges</source>
          <target state="translated">ALTER DEFAULT PRIVILEGES &amp;mdash;デフォルトのアクセス権限を定義します</target>
        </trans-unit>
        <trans-unit id="3f3cf48aa306a7a17143c18f42b0b45f1ba91588" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN</source>
          <target state="translated">ディレクトリを変更する</target>
        </trans-unit>
        <trans-unit id="535f7dde2f03c36ca7629e33ff7b1217df1764aa" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN &amp;mdash; change the definition of a domain</source>
          <target state="translated">ALTER DOMAIN &amp;mdash;ドメインの定義を変更する</target>
        </trans-unit>
        <trans-unit id="20933ed39426b19f4475367266e6e6f9a626ffa6" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER</source>
          <target state="translated">イベントトリガーを変更する</target>
        </trans-unit>
        <trans-unit id="10dfbf336834913b8615fd608fa879b835569269" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER &amp;mdash; change the definition of an event trigger</source>
          <target state="translated">ALTER EVENT TRIGGER &amp;mdash;イベントトリガーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="0800582e9a19732ccd7ede52083d298eb7e533f7" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION</source>
          <target state="translated">変更拡張</target>
        </trans-unit>
        <trans-unit id="fceab1548e1fa0086ad916c8c58c48d5f822b214" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION &amp;mdash; change the definition of an extension</source>
          <target state="translated">ALTER EXTENSION &amp;mdash;拡張の定義を変更する</target>
        </trans-unit>
        <trans-unit id="1845d1a7f6884f411e6b6fe79fb5470d0541e6de" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER</source>
          <target state="translated">FOREIGN DATA WRAPPERを変更します。</target>
        </trans-unit>
        <trans-unit id="81f39fe099a4b1e8700a250047ab0bd19b916bbd" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER &amp;mdash; change the definition of a foreign-data wrapper</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER &amp;mdash;外部データラッパーの定義を変更する</target>
        </trans-unit>
        <trans-unit id="a09c3d2b46b06da9b27051fbdd7021dbe016aef6" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE</source>
          <target state="translated">ALTER FOREIGN TABLE</target>
        </trans-unit>
        <trans-unit id="8624b9015bf6424468dfa21128e81480cb2172bb" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE &amp;mdash; change the definition of a foreign table</source>
          <target state="translated">ALTER FOREIGN TABLE &amp;mdash;外部テーブルの定義を変更します</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">置換機能</target>
        </trans-unit>
        <trans-unit id="0d8b2dd3aa8516a6e8465a116eb3a3088efc3943" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION &amp;mdash; change the definition of a function</source>
          <target state="translated">ALTER FUNCTION &amp;mdash;関数の定義を変更する</target>
        </trans-unit>
        <trans-unit id="1d015a780bf1ecbd73d8b159554c5fb6595a8014" translate="yes" xml:space="preserve">
          <source>ALTER GROUP</source>
          <target state="translated">アルターグループ</target>
        </trans-unit>
        <trans-unit id="8b6db204989799abd80f3151dc7f1e0c1b92ec62" translate="yes" xml:space="preserve">
          <source>ALTER GROUP &amp;mdash; change role name or membership</source>
          <target state="translated">ALTER GROUP &amp;mdash;ロール名またはメンバーシップを変更します</target>
        </trans-unit>
        <trans-unit id="48c2e5d4cd7c661c29fd2888d9f2286c8fc0c6bf" translate="yes" xml:space="preserve">
          <source>ALTER INDEX</source>
          <target state="translated">アルターインデックス</target>
        </trans-unit>
        <trans-unit id="7af8592c9de99cba72394d1922b6e193f563c137" translate="yes" xml:space="preserve">
          <source>ALTER INDEX &amp;mdash; change the definition of an index</source>
          <target state="translated">ALTER INDEX &amp;mdash;インデックスの定義を変更する</target>
        </trans-unit>
        <trans-unit id="1593f1abf4a97117a0be55f5da7d21f597c8c250" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE</source>
          <target state="translated">言語を変更する</target>
        </trans-unit>
        <trans-unit id="2d47f4538397cbf8b0a1e802f6dfa7cb56556115" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE &amp;mdash; change the definition of a procedural language</source>
          <target state="translated">ALTER LANGUAGE &amp;mdash;手続き型言語の定義を変更する</target>
        </trans-unit>
        <trans-unit id="b8e23037908ab469bed89826c20ecdd2b7ec5245" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT</source>
          <target state="translated">大規模オブジェクトを変更します。</target>
        </trans-unit>
        <trans-unit id="d01f8e01043a2f37f9bf2b4fbe638ce531bf573c" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT &amp;mdash; change the definition of a large object</source>
          <target state="translated">ALTER LARGE OBJECT &amp;mdash;ラージオブジェクトの定義を変更する</target>
        </trans-unit>
        <trans-unit id="acf3facbc79c94e9820cd014a83e0c3bffc8d33e" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW</source>
          <target state="translated">マテリアル表示を変更する</target>
        </trans-unit>
        <trans-unit id="ff19a08e1cc705b85f737d7d03bbe11848829b1c" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW &amp;mdash; change the definition of a materialized view</source>
          <target state="translated">ALTER MATERIALIZED VIEW &amp;mdash;マテリアライズドビューの定義を変更します</target>
        </trans-unit>
        <trans-unit id="dce6c5285005edbbb84e2318b05691c4b30c9b74" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR</source>
          <target state="translated">操作者を変更する</target>
        </trans-unit>
        <trans-unit id="7dafb4a30aeb9191e7113acec86c091ff802f404" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR &amp;mdash; change the definition of an operator</source>
          <target state="translated">ALTER OPERATOR &amp;mdash;オペレーターの定義を変更する</target>
        </trans-unit>
        <trans-unit id="a0e738cb1034a6c7d40880b830a0d0aabd9fe44b" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS</source>
          <target state="translated">オペレータクラスの変更</target>
        </trans-unit>
        <trans-unit id="cb0f6723f3b16452ec4b0d07ef7fe014b4a43893" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS &amp;mdash; change the definition of an operator class</source>
          <target state="translated">ALTER OPERATOR CLASS &amp;mdash;演算子クラスの定義を変更します</target>
        </trans-unit>
        <trans-unit id="0ba7fb1c4beddce29550f5cb8b66990a01471bb0" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY</source>
          <target state="translated">オペレータファミリーの変更</target>
        </trans-unit>
        <trans-unit id="b145c0d850ce88d5e3be9bd1acd90a4f15ebe361" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY &amp;mdash; change the definition of an operator family</source>
          <target state="translated">ALTER OPERATOR FAMILY &amp;mdash;演算子族の定義を変更します</target>
        </trans-unit>
        <trans-unit id="88b3b91499f373dcdd877e9ff64364e5e7e60e0e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY</source>
          <target state="translated">変更ポリシー</target>
        </trans-unit>
        <trans-unit id="833f3039623c0b1cb3fef4e1e4f83cc843bd962e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY &amp;mdash; change the definition of a row level security policy</source>
          <target state="translated">ALTER POLICY &amp;mdash;行レベルのセキュリティポリシーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">プロセスの変更</target>
        </trans-unit>
        <trans-unit id="43575de59088420331627e718ac08acff025d18b" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE &amp;mdash; change the definition of a procedure</source>
          <target state="translated">ALTER PROCEDURE &amp;mdash;プロシージャの定義を変更する</target>
        </trans-unit>
        <trans-unit id="54107fe026e19d4f5a11e4537d44c6b6d22b8b09" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION</source>
          <target state="translated">出版を変更する</target>
        </trans-unit>
        <trans-unit id="9597d926bb8a9acc34d0e5930cb8d7cd0d4f568f" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION &amp;mdash; change the definition of a publication</source>
          <target state="translated">ALTER PUBLICATION &amp;mdash;パブリケーションの定義を変更する</target>
        </trans-unit>
        <trans-unit id="8d50cc704f5e61444d52d138269e970c84c316a9" translate="yes" xml:space="preserve">
          <source>ALTER ROLE</source>
          <target state="translated">演算子役割</target>
        </trans-unit>
        <trans-unit id="12cc26ef42f3af7ca4348ac6467248637f685960" translate="yes" xml:space="preserve">
          <source>ALTER ROLE &amp;mdash; change a database role</source>
          <target state="translated">ALTER ROLE &amp;mdash;データベースの役割を変更する</target>
        </trans-unit>
        <trans-unit id="4dcea8729953c25416c614a8e9dd74665955b163" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE</source>
          <target state="translated">変更ルーチン</target>
        </trans-unit>
        <trans-unit id="41b74c3c2f66a654560a7c52136c27e28aece24f" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE &amp;mdash; change the definition of a routine</source>
          <target state="translated">ALTER ROUTINE &amp;mdash;ルーチンの定義を変更する</target>
        </trans-unit>
        <trans-unit id="a0e0dff76fa934f2bd1deef6694b1932d808504f" translate="yes" xml:space="preserve">
          <source>ALTER RULE</source>
          <target state="translated">アルタールール</target>
        </trans-unit>
        <trans-unit id="2fc7414dfcf68c3ac031a4421e6842e26618ab9c" translate="yes" xml:space="preserve">
          <source>ALTER RULE &amp;mdash; change the definition of a rule</source>
          <target state="translated">ALTER RULE &amp;mdash;ルールの定義を変更する</target>
        </trans-unit>
        <trans-unit id="d6fc95f83521d1f149e5c2d72ccf2e6275ceff58" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA</source>
          <target state="translated">アルタースキーマ</target>
        </trans-unit>
        <trans-unit id="a9c6d7baa1a1fa5c1ea1e4302e14b9b0b1cbc91f" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA &amp;mdash; change the definition of a schema</source>
          <target state="translated">ALTER SCHEMA &amp;mdash;スキーマの定義を変更する</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">アルターシーケンス</target>
        </trans-unit>
        <trans-unit id="75ca9fc88afe8b3a138533f529504e99e65095c7" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE &amp;mdash; change the definition of a sequence generator</source>
          <target state="translated">ALTER SEQUENCE &amp;mdash;シーケンスジェネレーターの定義を変更する</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">アルターサーバー</target>
        </trans-unit>
        <trans-unit id="9097ec6c4fcb5127ed5acb37df744bf114c59cf4" translate="yes" xml:space="preserve">
          <source>ALTER SERVER &amp;mdash; change the definition of a foreign server</source>
          <target state="translated">ALTER SERVER &amp;mdash;外部サーバーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="339516769622a8fe113a08ac4316402cbf0b0186" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS</source>
          <target state="translated">演算子</target>
        </trans-unit>
        <trans-unit id="08e64dea134c405908e303c3bf604acf6999c23f" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS &amp;mdash; change the definition of an extended statistics object</source>
          <target state="translated">ALTER STATISTICS &amp;mdash;拡張統計オブジェクトの定義を変更します</target>
        </trans-unit>
        <trans-unit id="10579de4cfd80edf9752f883f553b098d07c2351" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION</source>
          <target state="translated">サブスクリプションを変更する</target>
        </trans-unit>
        <trans-unit id="3088c38bfc4248dd70925edc22aa9e03938a70b2" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION &amp;mdash; change the definition of a subscription</source>
          <target state="translated">ALTER SUBSCRIPTION &amp;mdash;サブスクリプションの定義を変更します</target>
        </trans-unit>
        <trans-unit id="b751196563736994d3b141da4e3359399f7784c1" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM</source>
          <target state="translated">アルターシステム</target>
        </trans-unit>
        <trans-unit id="43121748c757e8121439597a27c3d6de3f1df5e0" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM &amp;mdash; change a server configuration parameter</source>
          <target state="translated">ALTER SYSTEM &amp;mdash;サーバー構成パラメーターを変更する</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">変更テーブル</target>
        </trans-unit>
        <trans-unit id="afe4c7733f05b900cf17777f836ea5b6c85eae68" translate="yes" xml:space="preserve">
          <source>ALTER TABLE &amp;mdash; change the definition of a table</source>
          <target state="translated">ALTER TABLE &amp;mdash;テーブルの定義を変更する</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">テーブルスペースの変更</target>
        </trans-unit>
        <trans-unit id="e3e82c20f13259759fc74c305fcf89694aa71e4c" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE &amp;mdash; change the definition of a tablespace</source>
          <target state="translated">ALTER TABLESPACE &amp;mdash;テーブルスペースの定義を変更する</target>
        </trans-unit>
        <trans-unit id="ab1241fdf0558dac3416642b6e5e2afa08edd357" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION</source>
          <target state="translated">テキスト検索設定を変更する</target>
        </trans-unit>
        <trans-unit id="2a241bc8e97bcb10c517130c630f0f5969d5e473" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION &amp;mdash; change the definition of a text search configuration</source>
          <target state="translated">ALTER TEXT SEARCH CONFIGURATION &amp;mdash;テキスト検索構成の定義を変更します</target>
        </trans-unit>
        <trans-unit id="a62239565ecd2214c8d0dc9fde76b1033be6c2fc" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY</source>
          <target state="translated">テキスト検索辞書を変更する</target>
        </trans-unit>
        <trans-unit id="13998d90641b194774e8f12cf56ab5eaead8a314" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY &amp;mdash; change the definition of a text search dictionary</source>
          <target state="translated">ALTER TEXT SEARCH DICTIONARY &amp;mdash;テキスト検索辞書の定義を変更する</target>
        </trans-unit>
        <trans-unit id="8179411a0a3b868da4b4880988c7d06f086d844e" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER</source>
          <target state="translated">テキスト検索パーサを変更する</target>
        </trans-unit>
        <trans-unit id="b487f243ff77599a0ebe244a83985f8acf1c14ea" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER &amp;mdash; change the definition of a text search parser</source>
          <target state="translated">ALTER TEXT SEARCH PARSER &amp;mdash;テキスト検索パーサーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="03386acc96b981e6c35c90b75e2cec735105ea3c" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE</source>
          <target state="translated">テキスト検索テンプレートを変更する</target>
        </trans-unit>
        <trans-unit id="285dbc8186deb64394ffb30b6e1363ad0dbe6498" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE &amp;mdash; change the definition of a text search template</source>
          <target state="translated">ALTER TEXT SEARCH TEMPLATE &amp;mdash;テキスト検索テンプレートの定義を変更します</target>
        </trans-unit>
        <trans-unit id="f6742edfb2c8b1a8d27beb1bba87153804373be5" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER</source>
          <target state="translated">変更トリガ</target>
        </trans-unit>
        <trans-unit id="485c6a654f45ba69729bdbf15496fe29a444d1e3" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER &amp;mdash; change the definition of a trigger</source>
          <target state="translated">ALTER TRIGGER &amp;mdash;トリガーの定義を変更します</target>
        </trans-unit>
        <trans-unit id="b8549a9a7b44242713f7d48704380ebba425b154" translate="yes" xml:space="preserve">
          <source>ALTER TYPE</source>
          <target state="translated">アルタータイプ</target>
        </trans-unit>
        <trans-unit id="2921b9477c2e093e0ed29e1dc88121fdd946417d" translate="yes" xml:space="preserve">
          <source>ALTER TYPE &amp;mdash; change the definition of a type</source>
          <target state="translated">ALTER TYPE &amp;mdash;タイプの定義を変更する</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">アルターユーザ</target>
        </trans-unit>
        <trans-unit id="dc349b6f52ce0d7d5bb23382932a5eb2f67eac63" translate="yes" xml:space="preserve">
          <source>ALTER USER &amp;mdash; change a database role</source>
          <target state="translated">ALTER USER &amp;mdash;データベースロールを変更する</target>
        </trans-unit>
        <trans-unit id="a375773515175c08cd7fc8e357c209c60d07f13e" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING</source>
          <target state="translated">ユーザマッピングを変更する</target>
        </trans-unit>
        <trans-unit id="84dbc6c571c120a8defca7e0a6c086e648f98854" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING &amp;mdash; change the definition of a user mapping</source>
          <target state="translated">ALTER USER MAPPING &amp;mdash;ユーザーマッピングの定義を変更する</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">アルタービュー</target>
        </trans-unit>
        <trans-unit id="d3ae485ff52fa79c183c7d3ce9f751addfed0468" translate="yes" xml:space="preserve">
          <source>ALTER VIEW &amp;mdash; change the definition of a view</source>
          <target state="translated">ALTER VIEW &amp;mdash;ビューの定義を変更する</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="21b8417695362cfdc412c95c44c48fa648556dd9" translate="yes" xml:space="preserve">
          <source>ANALYZE &amp;mdash; collect statistics about a database</source>
          <target state="translated">ANALYZE &amp;mdash;データベースに関する統計を収集する</target>
        </trans-unit>
        <trans-unit id="e2f2d6cea163ef0dacf4540366528f7c7edd61f2" translate="yes" xml:space="preserve">
          <source>AND &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">AND &lt;code&gt;tsquery&lt;/code&gt; を一緒に</target>
        </trans-unit>
        <trans-unit id="8824eb37da0438275c17449687050c5930f6be40" translate="yes" xml:space="preserve">
          <source>ANDs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match both input queries.</source>
          <target state="translated">2つの &lt;code&gt;tsquery&lt;/code&gt; をANDして、両方の入力クエリに一致するドキュメントに一致するクエリを生成します。</target>
        </trans-unit>
        <trans-unit id="09b52ce6d8d3ca14c041a1ecfe44ca34c84c93c5" translate="yes" xml:space="preserve">
          <source>ANSI</source>
          <target state="translated">ANSI</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="5fb9ba93128c23898a1b0a61ebd44810a0c6b606" translate="yes" xml:space="preserve">
          <source>ASCII code of the first character of the argument. For UTF8 returns the Unicode code point of the character. For other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">引数の最初の文字のASCIIコード。UTF8 の場合は、その文字の Unicode コードポイントを返します。その他のマルチバイトエンコーディングの場合、引数はASCII文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7647bd700c1c10eb12b5de06bf40a88672e3451d" translate="yes" xml:space="preserve">
          <source>Aaron D. Gifford</source>
          <target state="translated">アーロン・D・ギフォード</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="1bb9eda0dcf4611f958758d0ccd51e13bf341710" translate="yes" xml:space="preserve">
          <source>Abbreviation (for Pacific Standard Time)</source>
          <target state="translated">略称</target>
        </trans-unit>
        <trans-unit id="a90aba13b6feb8ff1a5141d94cb1fc2fe96e9477" translate="yes" xml:space="preserve">
          <source>Abbreviations</source>
          <target state="translated">Abbreviations</target>
        </trans-unit>
        <trans-unit id="c5fd5b17ae3c41e41caede4fa07a5960ba1a5f2d" translate="yes" xml:space="preserve">
          <source>Abort any statement that takes more than the specified amount of time. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">指定した時間より長くかかるステートメントを中止します。 &lt;code&gt;log_min_error_statement&lt;/code&gt; が &lt;code&gt;ERROR&lt;/code&gt; 以下に設定されている場合、タイムアウトしたステートメントもログに記録されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。値ゼロ（デフォルト）はタイムアウトを無効にします。</target>
        </trans-unit>
        <trans-unit id="6c33aee3e89187438edae43ea18855e5962050c2" translate="yes" xml:space="preserve">
          <source>Abort any statement that waits longer than the specified amount of time while attempting to acquire a lock on a table, index, row, or other database object. The time limit applies separately to each lock acquisition attempt. The limit applies both to explicit locking requests (such as &lt;code&gt;LOCK TABLE&lt;/code&gt;, or &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; without &lt;code&gt;NOWAIT&lt;/code&gt;) and to implicitly-acquired locks. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">テーブル、インデックス、行、またはその他のデータベースオブジェクトのロックを取得する際に、指定された時間よりも長く待機するステートメントを中止します。時間制限は、ロック取得の試行ごとに個別に適用されます。この制限は、明示的なロック要求（ &lt;code&gt;LOCK TABLE&lt;/code&gt; 、または &lt;code&gt;NOWAIT&lt;/code&gt; なしの &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; など）と暗黙的に取得されたロックの両方に適用されます。この値が単位なしで指定されている場合、ミリ秒と見なされます。値ゼロ（デフォルト）はタイムアウトを無効にします。</target>
        </trans-unit>
        <trans-unit id="82c17c3ccfec7ab27999f74c3eae394cb4e66713" translate="yes" xml:space="preserve">
          <source>Above, since there is no &lt;code&gt;ORDER BY&lt;/code&gt; in the &lt;code&gt;OVER&lt;/code&gt; clause, the window frame is the same as the partition, which for lack of &lt;code&gt;PARTITION BY&lt;/code&gt; is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an &lt;code&gt;ORDER BY&lt;/code&gt; clause, we get very different results:</source>
          <target state="translated">上記では、 &lt;code&gt;OVER&lt;/code&gt; 句に &lt;code&gt;ORDER BY&lt;/code&gt; がないため、ウィンドウフレームはパーティションと同じであり、 &lt;code&gt;PARTITION BY&lt;/code&gt; がない場合はテーブル全体になります。言い換えると、各合計はテーブル全体で取得されるため、各出力行で同じ結果が得られます。しかし、 &lt;code&gt;ORDER BY&lt;/code&gt; 句を追加すると、非常に異なる結果が得られます。</target>
        </trans-unit>
        <trans-unit id="35e4a1a9ace5e53c1521b13130f3b1fce0bb312b" translate="yes" xml:space="preserve">
          <source>Absolute value</source>
          <target state="translated">絶対値</target>
        </trans-unit>
        <trans-unit id="ecc48669a5f045e0b1c73515a6a06d3751ca7ca3" translate="yes" xml:space="preserve">
          <source>Absolute value of the SQL/JSON number</source>
          <target state="translated">SQL/JSON番号の絶対値</target>
        </trans-unit>
        <trans-unit id="adaf687cef3a864875d03ee7f1764cbc49564164" translate="yes" xml:space="preserve">
          <source>Absolute value of the given number</source>
          <target state="translated">与えられた数の絶対値</target>
        </trans-unit>
        <trans-unit id="95ecf27dff51c67220f14d51d8af97b6912bfba7" translate="yes" xml:space="preserve">
          <source>Access Exclusive locks taken on the primary server, including both explicit &lt;code&gt;LOCK&lt;/code&gt; commands and various DDL actions, conflict with table accesses in standby queries.</source>
          <target state="translated">明示的な &lt;code&gt;LOCK&lt;/code&gt; コマンドとさまざまなDDLアクションの両方を含む、プライマリサーバーで行われたアクセス排他ロックは、スタンバイクエリのテーブルアクセスと競合します。</target>
        </trans-unit>
        <trans-unit id="446d3f34dfbff4e7c337ef9e7b895902f1dba9ef" translate="yes" xml:space="preserve">
          <source>Access methods that always return entries in the natural ordering of their data (such as btree) should set &lt;code&gt;amcanorder&lt;/code&gt; to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</source>
          <target state="translated">データの自然な順序でエントリを常に返すアクセスメソッド（btreeなど）は、 &lt;code&gt;amcanorder&lt;/code&gt; をtrueに設定する必要があります。現在、このようなアクセス方法では、等価演算子と順序付け演算子にbtree互換の戦略番号を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0e23c5a90203bbd16a6b86de50258944a0ed57a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordered scans must support &amp;ldquo;marking&amp;rdquo; a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new &lt;code&gt;ammarkpos&lt;/code&gt; call overrides the previously marked position. An access method that does not support ordered scans need not provide &lt;code&gt;ammarkpos&lt;/code&gt; and &lt;code&gt;amrestrpos&lt;/code&gt; functions in &lt;code&gt;IndexAmRoutine&lt;/code&gt;; set those pointers to NULL instead.</source>
          <target state="translated">順序付けされたスキャンをサポートするアクセスメソッドは、スキャンでの位置の「マーキング」と、後でマークされた位置への復帰をサポートする必要があります。同じ位置が複数回復元される可能性があります。ただし、1回のスキャンで覚える必要がある位置は1つだけです。新しい &lt;code&gt;ammarkpos&lt;/code&gt; 呼び出しは、以前にマークされた位置をオーバーライドします。注文したスキャンが提供する必要はありませんサポートされていないアクセス方法 &lt;code&gt;ammarkpos&lt;/code&gt; と &lt;code&gt;amrestrpos&lt;/code&gt; で機能 &lt;code&gt;IndexAmRoutine&lt;/code&gt; を。代わりに、これらのポインタをNULLに設定してください。</target>
        </trans-unit>
        <trans-unit id="0fdc357a629c5f7047a03e768a0792d5cbb44b9a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should implement &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; property testing, as the core code does not know how to do that and will return NULL. It may also be advantageous to implement &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; testing, if that can be done more cheaply than by opening the index and calling &lt;code&gt;amcanreturn&lt;/code&gt;, which is the core code's default behavior. The default behavior should be satisfactory for all other standard properties.</source>
          <target state="translated">順序付け演算子をサポートするアクセスメソッドは &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; プロパティテストを実装する必要があります。これは、コアコードがその方法を知らず、NULLを返すためです。インデックスを開いてコアコードのデフォルトの動作である &lt;code&gt;amcanreturn&lt;/code&gt; を呼び出すよりも安価に実行できる場合は、 &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; テストを実装することも有利です。他のすべての標準プロパティでは、デフォルトの動作で十分です。</target>
        </trans-unit>
        <trans-unit id="ec93e5f340df1c63a8b7900c8c64d2c56b99c607" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should set &lt;code&gt;amcanorderbyop&lt;/code&gt; to true. This indicates that the index is capable of returning entries in an order satisfying &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Scan modifiers of that form can be passed to &lt;code&gt;amrescan&lt;/code&gt; as described previously.</source>
          <target state="translated">順序付け演算子をサポートするアクセスメソッドは、 &lt;code&gt;amcanorderbyop&lt;/code&gt; をtrueに設定する必要があります。これは、インデックスが &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; を満たす順序でエントリを返すことができることを示しています。前述のように、そのフォームのスキャン修飾子を &lt;code&gt;amrescan&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="9d5da75b46e072ddd4591be60d218524fe1f309e" translate="yes" xml:space="preserve">
          <source>Access privileges for template (not actually used)</source>
          <target state="translated">テンプレートのアクセス権(実際には使用していません</target>
        </trans-unit>
        <trans-unit id="85f3b04d8d02176eeb1578817040415abfa34698" translate="yes" xml:space="preserve">
          <source>Access privileges that this type of object should have on creation</source>
          <target state="translated">このタイプのオブジェクトが作成時に持つべきアクセス権限</target>
        </trans-unit>
        <trans-unit id="3d73c85183e638c3a5d257c026ae2497dddb1f32" translate="yes" xml:space="preserve">
          <source>Access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">アクセス権限。詳細については、&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="02bbd73371e69fa85fa69f734c586e2358313738" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">ビューで参照されるテーブルへのアクセスは、ビュー所有者の権限によって決定されます。場合によっては、これを使用して、基になるテーブルへの安全であるが制限されたアクセスを提供できます。ただし、すべてのビューが改ざんに対して安全であるとは限りません。詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;項40.5&lt;/a&gt;を参照してください。ビューで呼び出された関数は、ビューを使用してクエリから直接呼び出された場合と同じように扱われます。したがって、ビューのユーザーは、ビューで使用されるすべての関数を呼び出す権限を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="c4369eb157086a70b7378313eb6ff8fc4fe92c26" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">ビューで参照されるテーブルへのアクセスは、ビュー所有者の権限によって決定されます。場合によっては、これを使用して、基になるテーブルへの安全であるが制限されたアクセスを提供できます。ただし、すべてのビューが改ざんに対して安全であるとは限りません。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;セクション40.5&lt;/a&gt;を参照してください。ビューで呼び出された関数は、ビューを使用してクエリから直接呼び出された場合と同じように扱われます。したがって、ビューのユーザーには、ビューで使用されるすべての関数を呼び出すためのアクセス許可が必要です。</target>
        </trans-unit>
        <trans-unit id="ea538985d43ba38411a22fc78790edc64739cd94" translate="yes" xml:space="preserve">
          <source>Access to the column &lt;code&gt;subconninfo&lt;/code&gt; is revoked from normal users, because it could contain plain-text passwords.</source>
          <target state="translated">列 &lt;code&gt;subconninfo&lt;/code&gt; へのアクセスは、プレーンテキストのパスワードを含む可能性があるため、通常のユーザーから取り消されます。</target>
        </trans-unit>
        <trans-unit id="709b98ad6555808775120e3c01cba15666c7c18d" translate="yes" xml:space="preserve">
          <source>Access to the table &lt;code&gt;pg_statistic&lt;/code&gt; is restricted to superusers, so that ordinary users cannot learn about the contents of the tables of other users from it. Some selectivity estimation functions will use a user-provided operator (either the operator appearing in the query or a related operator) to analyze the stored statistics. For example, in order to determine whether a stored most common value is applicable, the selectivity estimator will have to run the appropriate &lt;code&gt;=&lt;/code&gt; operator to compare the constant in the query to the stored value. Thus the data in &lt;code&gt;pg_statistic&lt;/code&gt; is potentially passed to user-defined operators. An appropriately crafted operator can intentionally leak the passed operands (for example, by logging them or writing them to a different table), or accidentally leak them by showing their values in error messages, in either case possibly exposing data from &lt;code&gt;pg_statistic&lt;/code&gt; to a user who should not be able to see it.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; テーブルへのアクセスはスーパーユーザーに制限されているため、通常のユーザーは他のユーザーのテーブルの内容を知ることができません。一部の選択性推定関数は、ユーザー提供の演算子（クエリに表示される演算子または関連する演算子）を使用して、格納されている統計を分析します。たとえば、保存されている最も一般的な値が適用可能かどうかを判断するには、選択性推定器は適切な &lt;code&gt;=&lt;/code&gt; 演算子を実行して、クエリ内の定数を保存されている値と比較する必要があります。したがって、 &lt;code&gt;pg_statistic&lt;/code&gt; のデータユーザー定義の演算子に渡される可能性があります。適切に作成されたオペレーターは、渡されたオペランドを意図的にリークする（たとえば、ログに記録したり、別のテーブルに書き込んだりする）か、エラーメッセージに値を表示して誤ってリークする可能性があります。いずれの場合も、 &lt;code&gt;pg_statistic&lt;/code&gt; のデータをそれを見ることができないはずです。</target>
        </trans-unit>
        <trans-unit id="a19557158b233d91213a81525eeee59ee4fa2d0a" translate="yes" xml:space="preserve">
          <source>Access-method-specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としてのアクセス方法固有のオプション</target>
        </trans-unit>
        <trans-unit id="bdebd3af85014736552b079e90a39e39b6b4b3f6" translate="yes" xml:space="preserve">
          <source>Accessing remote data may require authenticating to the external data source. This information can be provided by a &lt;em&gt;user mapping&lt;/em&gt;, which can provide additional data such as user names and passwords based on the current PostgreSQL role.</source>
          <target state="translated">リモートデータにアクセスするには、外部データソースへの認証が必要な場合があります。この情報は、現在のPostgreSQLの役割に基づいてユーザー名やパスワードなどの追加データを提供できる&lt;em&gt;ユーザーマッピング&lt;/em&gt;によって提供できます。</target>
        </trans-unit>
        <trans-unit id="52fe1ef73da9bdc5400467df47e965d263b34732" translate="yes" xml:space="preserve">
          <source>Accessor Operator</source>
          <target state="translated">アクセッサー演算子</target>
        </trans-unit>
        <trans-unit id="af39d0c333f65451fb8a7cecb17f3d648babe73c" translate="yes" xml:space="preserve">
          <source>Accessor operators listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Table 8.25&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;表8.25に&lt;/a&gt;リストされているアクセサ演算子。</target>
        </trans-unit>
        <trans-unit id="a90102b6831b1be9c270ce8e277051052e425746" translate="yes" xml:space="preserve">
          <source>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal &lt;code&gt;'-1 2:03:04'&lt;/code&gt; applies to both the days and hour/minute/second parts. PostgreSQL allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt; then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.</source>
          <target state="translated">SQL標準によれば、時間隔値のすべてのフィールドは同じ符号を持つ必要があるため、先頭の負符号はすべてのフィールドに適用されます。たとえば、間隔リテラル &lt;code&gt;'-1 2:03:04'&lt;/code&gt; の負符号は、日と時間/分/秒の両方の部分に適用されます。 PostgreSQLでは、フィールドに異なる符号を付けることができます。従来、テキスト表現の各フィールドは個別に署名されたものとして扱われるため、この例では時間/分/秒の部分が正と見なされます。場合 &lt;code&gt;IntervalStyle&lt;/code&gt; に設定されている &lt;code&gt;sql_standard&lt;/code&gt; その後、先頭の記号はすべてのフィールドに適用されると見なされます（ただし、追加の記号が表示されない場合のみ）。それ以外の場合は、従来のPostgreSQL解釈が使用されます。あいまいさを避けるために、負のフィールドがある場合は、各フィールドに明示的な符号を付けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3aa4c2f095ab9191962811c65fa85311b6575f00" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, grant options can be granted to &lt;code&gt;PUBLIC&lt;/code&gt;; PostgreSQL only supports granting grant options to roles.</source>
          <target state="translated">SQL標準によれば、付与オプションは &lt;code&gt;PUBLIC&lt;/code&gt; に付与できます。PostgreSQLは、ロールへの付与オプションの付与のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="1ead55767cf3a2e09a221c81670b8f16ce3da10d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, omitting &lt;code&gt;ESCAPE&lt;/code&gt; means there is no escape character (rather than defaulting to a backslash), and a zero-length &lt;code&gt;ESCAPE&lt;/code&gt; value is disallowed. PostgreSQL's behavior in this regard is therefore slightly nonstandard.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;ESCAPE&lt;/code&gt; を省略すると、（デフォルトで円記号を使用するのではなく）エスケープ文字がなくなり、長さがゼロの &lt;code&gt;ESCAPE&lt;/code&gt; 値は使用できなくなります。したがって、この点でのPostgreSQLの動作はわずかに非標準です。</target>
        </trans-unit>
        <trans-unit id="b56b4e7b5de2231618fd8815a2cda445e53356b4" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, specifying either &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required in a &lt;code&gt;DROP&lt;/code&gt; command. No database system actually enforces that rule, but whether the default behavior is &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; varies across systems.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;DROP&lt;/code&gt; コマンドでは &lt;code&gt;RESTRICT&lt;/code&gt; または &lt;code&gt;CASCADE&lt;/code&gt; のいずれかを指定する必要があります。実際にそのルールを適用するデータベースシステムはありませんが、デフォルトの動作が &lt;code&gt;RESTRICT&lt;/code&gt; か &lt;code&gt;CASCADE&lt;/code&gt; かはシステムによって異なります。</target>
        </trans-unit>
        <trans-unit id="2656819b0489db63b95d67c6ca681b0ebbff6d9d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the &lt;code&gt;PRIVILEGES&lt;/code&gt; key word in &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; is required. The SQL standard does not support setting the privileges on more than one object per command.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; の &lt;code&gt;PRIVILEGES&lt;/code&gt; キーワードが必要です。SQL標準では、コマンドごとに複数のオブジェクトに権限を設定することはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="63bbcd2e4bc83757343815f2d0c5cf6131ae122b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the command to set this option is</source>
          <target state="translated">SQL標準によると、このオプションを設定するコマンドは</target>
        </trans-unit>
        <trans-unit id="4b8f45ef50c256265d9c97855d8b0d2a0f3dde8f" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the expressions in the output list should be computed before applying &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, or &lt;code&gt;LIMIT&lt;/code&gt;. This is obviously necessary when using &lt;code&gt;DISTINCT&lt;/code&gt;, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt;; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt;. (As a counterexample, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; clearly must evaluate &lt;code&gt;f(x)&lt;/code&gt; before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that &lt;code&gt;LIMIT&lt;/code&gt; will act to cut off the output from a set-returning function.</source>
          <target state="translated">SQL標準によれば、 &lt;code&gt;DISTINCT&lt;/code&gt; 、 &lt;code&gt;ORDER BY&lt;/code&gt; 、または &lt;code&gt;LIMIT&lt;/code&gt; を適用する前に、出力リストの式を計算する必要があります。 &lt;code&gt;DISTINCT&lt;/code&gt; を使用する場合、これは明らかに必要です。それ以外の場合、どの値が区別されるのかが明確でないためです。ただし、多くの場合、 &lt;code&gt;ORDER BY&lt;/code&gt; および &lt;code&gt;LIMIT&lt;/code&gt; の後に出力式が計算されると便利です。; 特に、出力リストに揮発性または高価な関数が含まれている場合。その動作により、関数評価の順序がより直感的になり、出力に表示されない行に対応する評価はありません。PostgreSQLは、それらの式が &lt;code&gt;DISTINCT&lt;/code&gt; 、 &lt;code&gt;ORDER BY&lt;/code&gt; 、または &lt;code&gt;GROUP BY&lt;/code&gt; で参照されていない限り、ソートおよび制限後に出力式を効果的に評価します。（反例として、 &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; ソート前に &lt;code&gt;f(x)&lt;/code&gt; を明確に評価する必要があります。）セットを返す関数を含む出力式は、ソート後、制限前に効果的に評価されるため、 &lt;code&gt;LIMIT&lt;/code&gt; セットを返す関数からの出力を遮断するように動作します。</target>
        </trans-unit>
        <trans-unit id="6db467e85d8317c698e30a66a7291c8eafa6149b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</source>
          <target state="translated">According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</target>
        </trans-unit>
        <trans-unit id="3b39ba80593aea6c161c39dff62ffc2f0348762e" translate="yes" xml:space="preserve">
          <source>According to the comp.ai.genetic FAQ it cannot be stressed too strongly that a GA is not a pure random search for a solution to a problem. A GA uses stochastic processes, but the result is distinctly non-random (better than random).</source>
          <target state="translated">comp.ai.genetic FAQによると、GAは問題解決のための純粋なランダム探索ではないことを強く強調することはできません。GAは確率過程を使用しますが、その結果は明らかに非ランダム(ランダムよりも優れています)です。</target>
        </trans-unit>
        <trans-unit id="2666b06563be42700b836e6d4059dfb52c4a608d" translate="yes" xml:space="preserve">
          <source>According to the standard, the first two characters of an error code denote a class of errors, while the last three characters indicate a specific condition within that class. Thus, an application that does not recognize the specific error code might still be able to infer what to do from the error class.</source>
          <target state="translated">規格によると、エラーコードの最初の2文字はエラーのクラスを示し、最後の3文字はそのクラス内の特定の状態を示します。したがって、特定のエラーコードを認識しないアプリケーションでも、エラークラスから何をすべきかを推測することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="61abcddacf93fafde9cc0a4bb6f9d2b6e919d03c" translate="yes" xml:space="preserve">
          <source>According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub-&lt;code&gt;SELECT&lt;/code&gt;. An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub- &lt;code&gt;SELECT&lt;/code&gt; . An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub- &lt;code&gt;SELECT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0980056b7787afbd8fbd30571ba2c45b1dbaa749" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE INDEX&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; によって取得されます（ &lt;code&gt;CONCURRENTLY&lt;/code&gt; なし）。</target>
        </trans-unit>
        <trans-unit id="e44eba7914f83fb7f73f8f0a727d44ad52ee7677" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; および一部の形式の &lt;code&gt;ALTER TABLE&lt;/code&gt; によって取得されます（&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c03704a90b839a00364666b3432c1fe877f7cfa4" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt; によって同時に取得されます。</target>
        </trans-unit>
        <trans-unit id="35b293b84736887604a4df3e4f117c1dcc96bdfc" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;), &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, and certain &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; variants (for full details see &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; （ &lt;code&gt;FULL&lt;/code&gt; なし）、 &lt;code&gt;ANALYZE&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 、 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 、 &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 、特定の &lt;code&gt;ALTER INDEX&lt;/code&gt; および &lt;code&gt;ALTER TABLE&lt;/code&gt; バリアントによって取得されます（詳細については、&lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt;および&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="4a64648cce36216f47287c3873ec5299a8307659" translate="yes" xml:space="preserve">
          <source>Acquired by the &lt;code&gt;DROP TABLE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;VACUUM FULL&lt;/code&gt;, and &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;) commands. Many forms of &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; also acquire a lock at this level. This is also the default lock mode for &lt;code&gt;LOCK TABLE&lt;/code&gt; statements that do not specify a mode explicitly.</source>
          <target state="translated">&lt;code&gt;DROP TABLE&lt;/code&gt; 、 &lt;code&gt;TRUNCATE&lt;/code&gt; 、 &lt;code&gt;REINDEX&lt;/code&gt; 、 &lt;code&gt;CLUSTER&lt;/code&gt; 、 &lt;code&gt;VACUUM FULL&lt;/code&gt; 、および &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; （ &lt;code&gt;CONCURRENTLY&lt;/code&gt; なし）コマンドによって取得されます。多くの形式の &lt;code&gt;ALTER INDEX&lt;/code&gt; および &lt;code&gt;ALTER TABLE&lt;/code&gt; も、このレベルでロックを取得します。これは、モードを明示的に指定しない &lt;code&gt;LOCK TABLE&lt;/code&gt; ステートメントのデフォルトのロックモードでもあります。</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="a43a7e7ff4a4d6f955aa729ae7ff758305e7b11f" translate="yes" xml:space="preserve">
          <source>Active txids at the time of the snapshot. The list includes only those active txids between &lt;code&gt;xmin&lt;/code&gt; and &lt;code&gt;xmax&lt;/code&gt;; there might be active txids higher than &lt;code&gt;xmax&lt;/code&gt;. A txid that is &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</source>
          <target state="translated">スナップショットの時点でアクティブなtxid。リストには、 &lt;code&gt;xmin&lt;/code&gt; と &lt;code&gt;xmax&lt;/code&gt; の間のアクティブなtxidのみが含まれます。 &lt;code&gt;xmax&lt;/code&gt; より高いアクティブなtxidが存在する可能性があります。あるTXID &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; なく、このリストには、すでにコミット状態に応じていずれかの可視又は死んだ従って、スナップショットの時点で完了しました。リストにはサブトランザクションのtxidは含まれていません。</target>
        </trans-unit>
        <trans-unit id="409557212ade1f78b39e4494cd71d7a5778b675f" translate="yes" xml:space="preserve">
          <source>Activity status of the WAL receiver process</source>
          <target state="translated">WAL受信プロセスのアクティビティ状況</target>
        </trans-unit>
        <trans-unit id="5074d759e3f5dbe3c6aa005b1369aadfa7087d57" translate="yes" xml:space="preserve">
          <source>Actual data stored in the large object. This will never be more than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes and might be less.</source>
          <target state="translated">ラージオブジェクトに格納されている実際のデータ。これは &lt;code&gt;LOBLKSIZE&lt;/code&gt; バイトを超えることはなく、少なくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5cef4a325f0a5fb8a611f2f24f0d274a093ec734" translate="yes" xml:space="preserve">
          <source>Actually the preceding paragraph is an oversimplification: there are two cases in which a function-call construct will be treated as a cast request without having matched it to an actual function. If a function call &lt;code&gt;name&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;) does not exactly match any existing function, but &lt;code&gt;name&lt;/code&gt; is the name of a data type and &lt;code&gt;pg_cast&lt;/code&gt; provides a binary-coercible cast to this type from the type of &lt;code&gt;x&lt;/code&gt;, then the call will be construed as a binary-coercible cast. This exception is made so that binary-coercible casts can be invoked using functional syntax, even though they lack any function. Likewise, if there is no &lt;code&gt;pg_cast&lt;/code&gt; entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast. This exception allows I/O conversion casts to be invoked using functional syntax.</source>
          <target state="translated">実際、前の段落は過度に単純化されています。関数呼び出し構文が実際の関数と一致せずにキャスト要求として扱われる場合が2つあります。関数呼び出し場合 &lt;code&gt;name&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; は）正確に既存の機能と一致していないが、 &lt;code&gt;name&lt;/code&gt; データ・タイプの名前であり、 &lt;code&gt;pg_cast&lt;/code&gt; のはタイプからこのタイプのバイナリ強制可能キャストを提供し &lt;code&gt;x&lt;/code&gt; 、コールはAと解釈されますバイナリ強制キャスト。この例外は、たとえ関数が不足している場合でも、関数型構文を使用してバイナリ強制型キャストを呼び出すことができるようにするために行われます。同様に、 &lt;code&gt;pg_cast&lt;/code&gt; がない場合エントリですが、キャストは文字列型との間で行われるため、呼び出しはI / O変換キャストとして解釈されます。この例外により、関数構文を使用してI / O変換キャストを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="99bd76b2471dd3de3de3ab7c1c222041031e9e64" translate="yes" xml:space="preserve">
          <source>Actually, each &amp;ldquo;character&amp;rdquo; can be any string not containing whitespace, so &lt;code&gt;unaccent&lt;/code&gt; dictionaries could be used for other sorts of substring substitutions besides diacritic removal.</source>
          <target state="translated">実際、各「文字」は空白を含まない任意の文字列にすることができるので、 &lt;code&gt;unaccent&lt;/code&gt; 記号のない辞書は、発音区別符号の削除以外の種類の部分文字列置換に使用できます。</target>
        </trans-unit>
        <trans-unit id="fb4a150119fee7c38df2ebe67adb1f04cd8a1672" translate="yes" xml:space="preserve">
          <source>Actually, in these example queries, &lt;code&gt;coalesce&lt;/code&gt; should be used to prevent a single &lt;code&gt;NULL&lt;/code&gt; attribute from causing a &lt;code&gt;NULL&lt;/code&gt; result for the whole document.</source>
          <target state="translated">実際、これらのクエリ例では、単一の &lt;code&gt;NULL&lt;/code&gt; 属性がドキュメント全体に &lt;code&gt;NULL&lt;/code&gt; の結果を引き起こすのを防ぐために、 &lt;code&gt;coalesce&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f0894c46fc9b6047265c297cf124917360edc17" translate="yes" xml:space="preserve">
          <source>Actually, the even more general syntax</source>
          <target state="translated">実際には、さらに一般的な構文</target>
        </trans-unit>
        <trans-unit id="9d49dccdc43481d06a4ef58b29107551c088b828" translate="yes" xml:space="preserve">
          <source>Adaptive?</source>
          <target state="translated">Adaptive?</target>
        </trans-unit>
        <trans-unit id="4415296784c0ee879898fb9df132309b61a61a7c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt; or &lt;code&gt;--column-inserts&lt;/code&gt; is also specified.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; コマンドに &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; を追加します。 &lt;code&gt;--inserts&lt;/code&gt; または &lt;code&gt;--column-inserts&lt;/code&gt; も指定されていない限り、このオプションは無効です。</target>
        </trans-unit>
        <trans-unit id="6e9832f60aad6d89585289ea2e0edf7fc9e5b79b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt;, &lt;code&gt;--column-inserts&lt;/code&gt; or &lt;code&gt;--rows-per-insert&lt;/code&gt; is also specified.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; コマンドに &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; を追加します。このオプションは、 &lt;code&gt;--column-inserts&lt;/code&gt; &lt;code&gt;--inserts&lt;/code&gt; 、-- column- &lt;code&gt;--rows-per-insert&lt;/code&gt; または--rows-per-insertも指定されていない限り無効です。</target>
        </trans-unit>
        <trans-unit id="df59723089709ab5e5075047c1ac7d254b3f6b22" translate="yes" xml:space="preserve">
          <source>Add a key, or update an existing key with a new value:</source>
          <target state="translated">キーを追加したり、既存のキーを新しい値で更新したりします。</target>
        </trans-unit>
        <trans-unit id="7a5572f228e469f1c2f4cd272c7b0cda74e7acf6" translate="yes" xml:space="preserve">
          <source>Add a number of days to a date</source>
          <target state="translated">日付に日数を追加する</target>
        </trans-unit>
        <trans-unit id="f0f3c97b278869eab76434c25a08bb2d9b563aa2" translate="yes" xml:space="preserve">
          <source>Add a time-of-day to a date</source>
          <target state="translated">日付に時間帯を追加する</target>
        </trans-unit>
        <trans-unit id="bacadfab25c06160832a539f1c1f1901edb824fd" translate="yes" xml:space="preserve">
          <source>Add a transaction script read from &lt;code&gt;filename&lt;/code&gt; to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the test. See below for details.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; から読み取ったトランザクションスクリプトを実行済みスクリプトのリストに追加します。 &lt;code&gt;@&lt;/code&gt; の後にオプションの整数の重みを付けると、テストを描画する確率を調整できます。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="e386cb056d908799805563d1ba2a71ca187f495b" translate="yes" xml:space="preserve">
          <source>Add an interval to a date</source>
          <target state="translated">日付に間隔を追加する</target>
        </trans-unit>
        <trans-unit id="30629dc5115a69a1747c013e1cc5a69e275df7a1" translate="yes" xml:space="preserve">
          <source>Add an interval to a time</source>
          <target state="translated">時間に間隔を追加する</target>
        </trans-unit>
        <trans-unit id="cc1ce74f84bf95ea154baff4f8c09c2914ce6d50" translate="yes" xml:space="preserve">
          <source>Add an interval to a timestamp</source>
          <target state="translated">タイムスタンプにインターバルを追加する</target>
        </trans-unit>
        <trans-unit id="b612d09d7cda7883ad9f9c1e74b2026a76de08a5" translate="yes" xml:space="preserve">
          <source>Add columns</source>
          <target state="translated">列の追加</target>
        </trans-unit>
        <trans-unit id="fdd20704520d17d4473df8ba637e593e3c1e9d32" translate="yes" xml:space="preserve">
          <source>Add constraints</source>
          <target state="translated">制約の追加</target>
        </trans-unit>
        <trans-unit id="7b67cedcfe4d56f7816bcfdf431ad5afd738eb2a" translate="yes" xml:space="preserve">
          <source>Add intervals</source>
          <target state="translated">インターバルを追加</target>
        </trans-unit>
        <trans-unit id="7ee44cc339a6c285bac845e10d98461ab1145004" translate="yes" xml:space="preserve">
          <source>Add non-overlapping table constraints to the child tables to define the allowed key values in each.</source>
          <target state="translated">重複しないテーブル制約を子テーブルに追加して、それぞれのテーブルで許可されるキー値を定義します。</target>
        </trans-unit>
        <trans-unit id="48999cb16b06daffee5cbba84a68d9e3c43940fe" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the function is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the function-local setting is removed, so that the function executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all function-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">関数が呼び出されたときに構成パラメーターに行われる割り当てを追加または変更します。場合 &lt;code&gt;value&lt;/code&gt; である &lt;code&gt;DEFAULT&lt;/code&gt; または、等価的に、 &lt;code&gt;RESET&lt;/code&gt; が使用され、関数のローカル設定が除去され、その結果、その環境中に存在する値との関数を実行します。すべての機能ローカル設定をクリアするには、 &lt;code&gt;RESET ALL&lt;/code&gt; を使用します。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; は、 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; が実行されたときに現在のパラメーターの値を、関数に入ったときに適用される値として保存します。</target>
        </trans-unit>
        <trans-unit id="741a6eebd9634b6405712ee7bced8a90249de64a" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the procedure is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the procedure-local setting is removed, so that the procedure executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all procedure-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">プロシージャが呼び出されたときに構成パラメータに行われる割り当てを追加または変更します。場合 &lt;code&gt;value&lt;/code&gt; である &lt;code&gt;DEFAULT&lt;/code&gt; または、等価的に、 &lt;code&gt;RESET&lt;/code&gt; が使用され、手順、ローカル設定が除去され、その結果、その環境中に存在する値を有する手順を実行します。すべてのプロシージャローカル設定をクリアするには、 &lt;code&gt;RESET ALL&lt;/code&gt; を使用します。 &lt;code&gt;SET FROM CURRENT&lt;/code&gt; は、 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; の実行時に現在のパラメーターの値を、プロシージャーの入力時に適用される値として保存します。</target>
        </trans-unit>
        <trans-unit id="3e939370f13d4d6648fdf6ebce042de2b0c8b35d" translate="yes" xml:space="preserve">
          <source>Add some tables to the publication:</source>
          <target state="translated">出版物にいくつかの表を追加します。</target>
        </trans-unit>
        <trans-unit id="0adf6644f343dab5da55bc308f3c6ee3087cbd49" translate="yes" xml:space="preserve">
          <source>Add the new column, with a default, to &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">新しい列をデフォルトで &lt;code&gt;pg_proc.h&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="752268a69e3b24883f304a215dae5d50dea7c0b0" translate="yes" xml:space="preserve">
          <source>Add the probe definition to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;:</source>
          <target state="translated">プローブ定義を &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="ce0fb0fdfabd7e1bdcafb562c60398cbe55ebe0d" translate="yes" xml:space="preserve">
          <source>Add the probe definitions to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</source>
          <target state="translated">プローブ定義を &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; に追加します</target>
        </trans-unit>
        <trans-unit id="4acf1110e0d52a03ba3a64c356b491cd2bd51279" translate="yes" xml:space="preserve">
          <source>Add the specified built-in script to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the script. If not specified, it is set to 1. Available built-in scripts are: &lt;code&gt;tpcb-like&lt;/code&gt;, &lt;code&gt;simple-update&lt;/code&gt; and &lt;code&gt;select-only&lt;/code&gt;. Unambiguous prefixes of built-in names are accepted. With special name &lt;code&gt;list&lt;/code&gt;, show the list of built-in scripts and exit immediately.</source>
          <target state="translated">指定した組み込みスクリプトを実行済みスクリプトのリストに追加します。 &lt;code&gt;@&lt;/code&gt; の後にオプションの整数の重みを付けると、スクリプトを描画する確率を調整できます。指定しない場合、1に設定されます。使用可能な組み込みスクリプトは、 &lt;code&gt;tpcb-like&lt;/code&gt; 、 &lt;code&gt;simple-update&lt;/code&gt; 、および &lt;code&gt;select-only&lt;/code&gt; です。組み込み名の明確な接頭辞が受け入れられます。特別な名前 &lt;code&gt;list&lt;/code&gt; を使用して、組み込みスクリプトのリストを表示し、すぐに終了します。</target>
        </trans-unit>
        <trans-unit id="c0ab5a63742ff89241c46899c37233e1df7c86b0" translate="yes" xml:space="preserve">
          <source>Add users to a group:</source>
          <target state="translated">ユーザーをグループに追加します。</target>
        </trans-unit>
        <trans-unit id="8caea2f156f156f661ed21fc3f27f4bbd2fa80f2" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;NOT NULL&lt;/code&gt; constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.</source>
          <target state="translated">&lt;code&gt;CHECK&lt;/code&gt; または &lt;code&gt;NOT NULL&lt;/code&gt; 制約を追加するには、既存の行が制約を満たすことを確認するためにテーブルをスキャンする必要がありますが、テーブルの書き換えは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cffe5a53117b776e99930ab76048f8855b384b5a" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 制約を追加すると、制約で使用される列または列のグループに一意のbtreeインデックスが自動的に作成されます。オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句を使用すると、インデックスの非キー部分に含まれる列のリストを指定できます。含まれる列には一意性は適用されませんが、制約はそれらに依存します。その結果、含まれている列に対するいくつかの操作（例： &lt;code&gt;DROP COLUMN&lt;/code&gt; ）は、カスケードされた制約とインデックスの削除を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="9e3b837b83f00305a477861a47c68fa313f35aa1" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 制約を追加すると、制約で使用される列または列のグループに一意のbtreeインデックスが自動的に作成されます。オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句を使用すると、インデックスの非キー部分に含まれる列のリストを指定できます。含まれる列に一意性は適用されませんが、制約はそれらに依存します。その結果、含まれている列に対する一部の操作（ &lt;code&gt;DROP COLUMN&lt;/code&gt; など）により、カスケード制約とインデックスの削除が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c642f86413e7e0c5d8cf9f40dd1b146f4c06e416" translate="yes" xml:space="preserve">
          <source>Adding a column with a volatile &lt;code&gt;DEFAULT&lt;/code&gt; or changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if the &lt;code&gt;USING&lt;/code&gt; clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.</source>
          <target state="translated">揮発性の &lt;code&gt;DEFAULT&lt;/code&gt; を持つ列を追加するか、既存の列のタイプを変更するには、テーブル全体とそのインデックスを書き換える必要があります。例外として、既存の列のタイプを変更するとき、 &lt;code&gt;USING&lt;/code&gt; 句が列の内容を変更せず、古いタイプが新しいタイプにバイナリ強制可能であるか、または新しいタイプに対する制約のないドメインである場合、テーブルの書き換えは不要です。 ;ただし、影響を受ける列のインデックスは引き続き再構築する必要があります。大規模なテーブルの場合、テーブルやインデックスの再構築にかなりの時間がかかることがあります。一時的に2倍のディスク容量が必要になります。</target>
        </trans-unit>
        <trans-unit id="c58efc1059381c4bf8b362143436cd8c4af55346" translate="yes" xml:space="preserve">
          <source>Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, and then install it as an official constraint using this syntax. See the example below.</source>
          <target state="translated">既存のインデックスを使用して制約を追加すると、テーブルの更新を長時間ブロックせずに新しい制約を追加する必要がある場合に役立ちます。これを行うには、 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; を使用してインデックスを作成し、この構文を使用して公式の制約としてインストールします。以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="c57d929aced463125ab8b2f66f31b21a04522c5d" translate="yes" xml:space="preserve">
          <source>Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">主キーを追加すると、主キーにリストされている列または列のグループに一意のBツリーインデックスが自動的に作成され、列が強制的に &lt;code&gt;NOT NULL&lt;/code&gt; とマークされます。</target>
        </trans-unit>
        <trans-unit id="4ee5dc2437e432908c48ca918b4296acc2f6a028" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique &lt;a href=&quot;indexes-partial&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">一意の制約を追加すると、制約にリストされている列または列のグループに一意のBツリーインデックスが自動的に作成されます。一部の行のみを対象とする一意性制限は、一意性制約として書き込むことはできませんが、一意の&lt;a href=&quot;indexes-partial&quot;&gt;部分インデックスを&lt;/a&gt;作成することにより、このような制限を強制することができます。</target>
        </trans-unit>
        <trans-unit id="1e5ef315a51bb0b0043f1a6d7277abada165d078" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">一意の制約を追加すると、制約で使用される列または列のグループに一意のbtreeインデックスが自動的に作成されます。オプションの &lt;code&gt;INCLUDE&lt;/code&gt; 句は、一意性が適用されない1つ以上の列をそのインデックスに追加します。制約は含まれている列には適用されませんが、それでもそれらに依存することに注意してください。その結果、これらの列に対するいくつかの操作（たとえば、 &lt;code&gt;DROP COLUMN&lt;/code&gt; ）は、カスケードされた制約とインデックス削除を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="fa8235a384df080ad3fe537c45554b56b2b4ea42" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">一意の制約を追加すると、制約で使用される列または列のグループに一意のbtreeインデックスが自動的に作成されます。オプションの句 &lt;code&gt;INCLUDE&lt;/code&gt; は、一意性が強制されない1つ以上の列をそのインデックスに追加します。含まれている列に制約は適用されませんが、それでも列に依存することに注意してください。その結果、これらの列に対する一部の操作（ &lt;code&gt;DROP COLUMN&lt;/code&gt; など）により、カスケードされた制約とインデックスの削除が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8bcad53930a4507d157767aa00d4a8d4f833266c" translate="yes" xml:space="preserve">
          <source>Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.</source>
          <target state="translated">除外制約を追加すると、制約宣言で指定された型のインデックスが自動的に作成されます。</target>
        </trans-unit>
        <trans-unit id="7173dacda23801ef619f4e60a2645585a6fe0048" translate="yes" xml:space="preserve">
          <source>Adding parentheses around an RE does not change its greediness.</source>
          <target state="translated">REの周りに括弧を付けても欲張りさは変わりません。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="65d284b9baecd42d63cb154eecd228122b272bd2" translate="yes" xml:space="preserve">
          <source>Addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table receiving the constraint.</source>
          <target state="translated">外部キー制約を追加するには、制約を受け取るテーブルのロックに加えて、参照されるテーブルの &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; ロックが必要です。</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">追加機能</target>
        </trans-unit>
        <trans-unit id="15680ea5248b05a075106e29ed181bc54958d717" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.12&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.11&lt;/a&gt;.</source>
          <target state="translated">追加のバイナリ文字列操作関数が利用可能であり、&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;表9.12に&lt;/a&gt;リストされています。それらのいくつかは、&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;表9.11に&lt;/a&gt;リストされているSQL標準の文字列関数を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="89c24238b1c616d3f7452d5dd9217a02ce8ecaf1" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;.</source>
          <target state="translated">追加のバイナリ文字列操作関数が利用可能で、&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;表9.13に&lt;/a&gt;リストされています。それらの一部は、&lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;表9.12に&lt;/a&gt;リストされているSQL標準の文字列関数を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="9e5fd4e93e599bcb1fb3d2db4b33749ab6dcc12b" translate="yes" xml:space="preserve">
          <source>Additional considerations apply to the use of generated columns.</source>
          <target state="translated">生成された列の使用には、追加の考慮事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="aa325cbf6ead34348f2e89548944a03a6c03ebc9" translate="yes" xml:space="preserve">
          <source>Additional discussion and practical examples can be found in &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;.</source>
          <target state="translated">追加の議論と実際の例は、&lt;a href=&quot;ddl-rowsecurity&quot;&gt;セクション5.8にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1fbe8c837563c2f0daf28f682cb1a5ab1ec6f6fe" translate="yes" xml:space="preserve">
          <source>Additional enhancements by Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;, United Kingdom</source>
          <target state="translated">Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt; による追加の機能強化、イギリス</target>
        </trans-unit>
        <trans-unit id="0ef08f4faa1371707ef2f6feef718bf54953d0e6" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">PL / PerlおよびPL / Python言語の &lt;code&gt;hstore&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。 PL / Perlの拡張機能は、信頼できるPL / Perlと信頼できないPL / Perlの &lt;code&gt;hstore_plperl&lt;/code&gt; および &lt;code&gt;hstore_plperlu&lt;/code&gt; と呼ばれます。これらの変換をインストールし、関数の作成時にそれらを指定すると、 &lt;code&gt;hstore&lt;/code&gt; 値はPerlハッシュにマップされます。 PL / Pythonの拡張機能は、 &lt;code&gt;hstore_plpythonu&lt;/code&gt; 、 &lt;code&gt;hstore_plpython2u&lt;/code&gt; 、および &lt;code&gt;hstore_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については、&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。それらを使用する場合、 &lt;code&gt;hstore&lt;/code&gt; 値はPython辞書にマップされます。</target>
        </trans-unit>
        <trans-unit id="17bd8a6e2056a675b0fbad2a48d38ec5e91b9a37" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">PL / PerlおよびPL / Python言語の &lt;code&gt;hstore&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。 PL / Perlの拡張機能は、信頼できるPL / Perlと信頼できないPL / Perlを &lt;code&gt;hstore_plperlu&lt;/code&gt; ために、 &lt;code&gt;hstore_plperl&lt;/code&gt; およびhstore_plperluと呼ばれます。これらの変換をインストールして関数の作成時に指定すると、 &lt;code&gt;hstore&lt;/code&gt; 値はPerlハッシュにマップされます。 PL / Pythonの拡張機能は、 &lt;code&gt;hstore_plpythonu&lt;/code&gt; 、 &lt;code&gt;hstore_plpython2u&lt;/code&gt; 、および &lt;code&gt;hstore_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については&lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。それらを使用する場合、 &lt;code&gt;hstore&lt;/code&gt; 値はPython辞書にマップされます。</target>
        </trans-unit>
        <trans-unit id="d6954bc39f2ef60e2e03ec59460cfa1e30432da9" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;jsonb&lt;/code&gt; type for different procedural languages.</source>
          <target state="translated">さまざまな手続き型言語の &lt;code&gt;jsonb&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。</target>
        </trans-unit>
        <trans-unit id="041eecca386b7ca679e006e4c9dbf17a8a23f03a" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">PL / Pythonの &lt;code&gt;ltree&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。拡張機能は、 &lt;code&gt;ltree_plpythonu&lt;/code&gt; 、 &lt;code&gt;ltree_plpython2u&lt;/code&gt; 、および &lt;code&gt;ltree_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については、&lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。これらの変換をインストールし、関数の作成時にそれらを指定すると、 &lt;code&gt;ltree&lt;/code&gt; 値がPythonリストにマップされます。（ただし、その逆は現在サポートされていません。）</target>
        </trans-unit>
        <trans-unit id="5a2588f70de7908623c3d75b4d858ce4b4c9f548" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">PL / Pythonの &lt;code&gt;ltree&lt;/code&gt; タイプの変換を実装する追加の拡張機能が利用可能です。拡張機能は、 &lt;code&gt;ltree_plpythonu&lt;/code&gt; 、 &lt;code&gt;ltree_plpython2u&lt;/code&gt; 、および &lt;code&gt;ltree_plpython3u&lt;/code&gt; と呼ばれます（PL / Pythonの命名規則については&lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;セクション45.1&lt;/a&gt;を参照してください）。これらの変換をインストールして関数の作成時に指定すると、 &lt;code&gt;ltree&lt;/code&gt; 値はPythonリストにマップされます。（ただし、現在、その逆はサポートされていません。）</target>
        </trans-unit>
        <trans-unit id="848e3ef5eb869b4a42890d26de458d77b4145059" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.20&lt;/a&gt;.</source>
          <target state="translated">統計収集に関連する追加の関数を&lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;表27.20に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="efb9efc34358e145f231e909fca0c910acaa66eb" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.30&lt;/a&gt;.</source>
          <target state="translated">統計収集に関連する追加機能を&lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;表27.30に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="77a49395f2c7e958118c2da8e1de4c14e6b60602" translate="yes" xml:space="preserve">
          <source>Additional information about how to invoke the function. Again, the interpretation is language-specific.</source>
          <target state="translated">関数の呼び出し方についての追加情報。繰り返しになりますが、解釈は言語固有のものです。</target>
        </trans-unit>
        <trans-unit id="284dcb5991a8da2d3edb0ed1251edf3e8b725229" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">サブスクリプションおよび論理複製全体に関する追加情報は、&lt;a href=&quot;logical-replication-subscription&quot;&gt;セクション30.2&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;第30章にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="031701e67cc64e29e0f780df4ac7b24959b2258c" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">サブスクリプションおよび論理レプリケーション全体に関する追加情報は、&lt;a href=&quot;logical-replication-subscription&quot;&gt;セクション30.2&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;第30章&lt;/a&gt;で入手できます。</target>
        </trans-unit>
        <trans-unit id="9eacaa0140464ef9b6f84f47defe84ade132e976" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;code&gt;width&lt;/code&gt; field is also specified.</source>
          <target state="translated">フォーマット指定子の出力のフォーマット方法を制御する追加オプション。現在サポートされている唯一のフラグはマイナス記号（ &lt;code&gt;-&lt;/code&gt; ）で、これによりフォーマット指定子の出力が左揃えになります。 &lt;code&gt;width&lt;/code&gt; フィールドも指定しない限り、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="b2569d5e654fdba9e13f3a3587c2c0d71e119a8f" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt; field is also specified.</source>
          <target state="translated">フォーマット指定子の出力のフォーマット方法を制御する追加オプション。現在サポートされているフラグはマイナス記号（ &lt;code&gt;-&lt;/code&gt; ）のみで、これによりフォーマット指定子の出力が左寄せされます。&lt;em&gt; &lt;code&gt;width&lt;/code&gt; &lt;/em&gt;フィールドも指定しない限り、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="2fdddce1ec06b246bce73843e8826c300263ddb0" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique indexes are applied to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">一意のインデックスがパーティション分割されたテーブルに適用される場合、追加の制限が適用されます。&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9379cab208a52cab9a14d1960740e0e9980c40a5" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. Also, foreign key constraints on partitioned tables may not be declared &lt;code&gt;NOT VALID&lt;/code&gt; at present.</source>
          <target state="translated">パーティションテーブルに一意キー制約または主キー制約を追加すると、追加の制限が適用されます。&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLEを&lt;/a&gt;参照してください。また、パーティション化されたテーブルの外部キー制約は、現時点では &lt;code&gt;NOT VALID&lt;/code&gt; と宣言されていない場合があります。</target>
        </trans-unit>
        <trans-unit id="d8765f8e8e885763ce10457dabe0ae485bb31d5b" translate="yes" xml:space="preserve">
          <source>Additional string manipulation functions are available and are listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;.</source>
          <target state="translated">追加の文字列操作関数が利用可能で、&lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;表9.10に&lt;/a&gt;リストされています。それらの一部は、&lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;表9.9&lt;/a&gt;に示す SQL標準の文字列関数を実装するために内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="010f13497a3e5b588a77355b773385544bc33904" translate="yes" xml:space="preserve">
          <source>Additional updates were made by Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; in July 2006. These include &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; and cleaning up the code to use the V1 call protocol instead of the deprecated V0 protocol.</source>
          <target state="translated">追加の更新は、2006年7月にJoshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; によって行われました。これらには、 &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; および非推奨のV0プロトコルの代わりにV1呼び出しプロトコルを使用するコードのクリーンアップが含まれます。</target>
        </trans-unit>
        <trans-unit id="a5f30130c7eb4575fcc776243da7a4179d9cf6f4" translate="yes" xml:space="preserve">
          <source>Additional, more detailed, description of the parameter</source>
          <target state="translated">パラメータの追加、より詳細な説明</target>
        </trans-unit>
        <trans-unit id="f10aed98f8a0fbbcdcab810e37d64419e4b89806" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;em&gt;comments&lt;/em&gt; can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.</source>
          <target state="translated">さらに、SQL入力で&lt;em&gt;コメント&lt;/em&gt;が発生する可能性があります。これらはトークンではなく、空白と実質的に同等です。</target>
        </trans-unit>
        <trans-unit id="3ce7d7c047715fd1454a60e6f8ab9c8a858ce3b2" translate="yes" xml:space="preserve">
          <source>Additionally, an alias is required if the table reference is a subquery (see &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Section 7.2.1.3&lt;/a&gt;).</source>
          <target state="translated">さらに、テーブル参照がサブクエリの場合は、エイリアスが必要です（&lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;セクション7.2.1.3を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2987436262917a5192b10eeed405ee0544038a4c" translate="yes" xml:space="preserve">
          <source>Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function.</source>
          <target state="translated">さらに、クエリが通常関数の暗黙の変換を必要とする場合、ユーザーが正しい引数型を持つ新しい関数を定義した場合、パーサはこの新しい関数を使用し、古い関数を使用するために暗黙の変換を行わないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a6ee1654a9731eebc2384fd193841ff3bb1bd0e" translate="yes" xml:space="preserve">
          <source>Additionally, if you are running PostgreSQL inside a zone, you may need to raise the zone resource usage limits as well. See &quot;Chapter2: Projects and Tasks&quot; in the &lt;em&gt;System Administrator's Guide&lt;/em&gt; for more information on &lt;code&gt;projects&lt;/code&gt; and &lt;code&gt;prctl&lt;/code&gt;.</source>
          <target state="translated">さらに、PostgreSQLをゾーン内で実行している場合は、ゾーンのリソース使用制限も引き上げる必要がある場合があります。 &lt;code&gt;projects&lt;/code&gt; と &lt;code&gt;prctl&lt;/code&gt; の詳細については、 『&lt;em&gt;システム管理者ガイド&lt;/em&gt;』の「第2章：プロジェクトとタスク」を&lt;em&gt;参照&lt;/em&gt;してください。</target>
        </trans-unit>
        <trans-unit id="0aee321f704c4c1848fccdf5704c469a83987cc5" translate="yes" xml:space="preserve">
          <source>Additionally, refresh options as described under &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; may be specified.</source>
          <target state="translated">さらに、 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; で説明されている更新オプションを指定できます。</target>
        </trans-unit>
        <trans-unit id="78567ce71a3b54c604529593f06074abcf105927" translate="yes" xml:space="preserve">
          <source>Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt;. It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</source>
          <target state="translated">Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt; . It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</target>
        </trans-unit>
        <trans-unit id="53f8119d06cd2559361245d09ce9820bdfc91e36" translate="yes" xml:space="preserve">
          <source>Adds an offset to an address.</source>
          <target state="translated">アドレスにオフセットを追加します。</target>
        </trans-unit>
        <trans-unit id="d5aedd449033d6b8107ae365cb24a243a1adca0c" translate="yes" xml:space="preserve">
          <source>Adds collations to the system catalog &lt;code&gt;pg_collation&lt;/code&gt; based on all the locales it finds in the operating system. This is what &lt;code&gt;initdb&lt;/code&gt; uses; see &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;Section 23.2.2&lt;/a&gt; for more details. If additional locales are installed into the operating system later on, this function can be run again to add collations for the new locales. Locales that match existing entries in &lt;code&gt;pg_collation&lt;/code&gt; will be skipped. (But collation objects based on locales that are no longer present in the operating system are not removed by this function.) The &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; parameter would typically be &lt;code&gt;pg_catalog&lt;/code&gt;, but that is not a requirement; the collations could be installed into some other schema as well. The function returns the number of new collation objects it created.</source>
          <target state="translated">オペレーティングシステムで検出されたすべてのロケールに基づいて、システムカタログ &lt;code&gt;pg_collation&lt;/code&gt; 照合順序を追加します。これは &lt;code&gt;initdb&lt;/code&gt; が使用するものです。詳細については、&lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;セクション23.2.2&lt;/a&gt;を参照してください。後で追加のロケールがオペレーティングシステムにインストールされた場合、この関数を再度実行して、新しいロケールの照合を追加できます。 &lt;code&gt;pg_collation&lt;/code&gt; 既存のエントリに一致するロケールはスキップされます。 （ただし、オペレーティングシステムに存在しなくなったロケールに基づく照合オブジェクトは、この関数によって削除されません。）&lt;em&gt; &lt;code&gt;schema&lt;/code&gt; &lt;/em&gt;パラメーターは通常、 &lt;code&gt;pg_catalog&lt;/code&gt; になります。、しかしそれは要件ではありません。照合順序は、他のスキーマにもインストールできます。この関数は、作成した新しい照合オブジェクトの数を返します。</target>
        </trans-unit>
        <trans-unit id="e874368d9d21cc7beffa67760d80cf1b272a6209" translate="yes" xml:space="preserve">
          <source>Adds element to end of array.</source>
          <target state="translated">配列の末尾に要素を追加します。</target>
        </trans-unit>
        <trans-unit id="36522cf2f752a15facac71afeb7f67a4b36db952" translate="yes" xml:space="preserve">
          <source>Adds the coordinates of the second &lt;code&gt;point&lt;/code&gt; to those of each point of the first argument, thus performing translation. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">2番目の &lt;code&gt;point&lt;/code&gt; 座標を最初の引数の各点の座標に追加して、変換を実行します。以下のための利用可能な &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;path&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3c767351a24f76f0563dcac6f0be4bd35c8869c" translate="yes" xml:space="preserve">
          <source>Adjust interval so 24-hour time periods are represented as days</source>
          <target state="translated">24時間の時間帯が日として表現されるように間隔を調整します。</target>
        </trans-unit>
        <trans-unit id="7279c011b0d2f4cdb22e6caf6d21633e1e395dfa" translate="yes" xml:space="preserve">
          <source>Adjust interval so 30-day time periods are represented as months</source>
          <target state="translated">30日の期間が月として表現されるように間隔を調整します。</target>
        </trans-unit>
        <trans-unit id="0d09f290462815bf94d7d19b5220a29471c8dd87" translate="yes" xml:space="preserve">
          <source>Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt;, with additional sign adjustments</source>
          <target state="translated">Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt; , with additional sign adjustments</target>
        </trans-unit>
        <trans-unit id="d5274237f32eaf0cd335b0f45d9e9e406fe2937c" translate="yes" xml:space="preserve">
          <source>Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt;:</source>
          <target state="translated">Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="597cf96132dd221de223e71df7ddc2feda8ca0e0" translate="yes" xml:space="preserve">
          <source>Adjustable printing options are:</source>
          <target state="translated">調整可能な印刷オプションがあります。</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="25a6044596d068aa8f0b03a3756a046b4662f84e" translate="yes" xml:space="preserve">
          <source>Administration Functions</source>
          <target state="translated">管理機能</target>
        </trans-unit>
        <trans-unit id="9ff417ada04d397f658792af845a2743c3df515c" translate="yes" xml:space="preserve">
          <source>Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</source>
          <target state="translated">Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</target>
        </trans-unit>
        <trans-unit id="5748ca9fbce0c666d06fe84d7811e46cfd6b343d" translate="yes" xml:space="preserve">
          <source>Advance sequence and return new value</source>
          <target state="translated">シーケンスを進めて新しい値を返す</target>
        </trans-unit>
        <trans-unit id="4d638e9190ad6b08f1c75c8684e03ac19dde11c0" translate="yes" xml:space="preserve">
          <source>Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</source>
          <target state="translated">Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</target>
        </trans-unit>
        <trans-unit id="05743e363937b509ed8a8c4f9befec86cf089852" translate="yes" xml:space="preserve">
          <source>Advanced Configuration and Power Interface (ACPI) provides a Power Management (PM) Timer, which Linux refers to as the acpi_pm. The clock derived from acpi_pm will at best provide 300 nanosecond resolution.</source>
          <target state="translated">ACPI (Advanced Configuration and Power Interface)は、Linux が acpi_pm と呼ぶパワーマネージメント (PM)タイマーを提供します。acpi_pm から派生したクロックは、最高でも 300 ナノ秒の分解能を提供します。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高度な機能</target>
        </trans-unit>
        <trans-unit id="40fdbd870880a4ac68ea44233cfb9a2306bc99de" translate="yes" xml:space="preserve">
          <source>Advanced users can use regular-expression notations such as character classes, for example &lt;code&gt;[0-9]&lt;/code&gt; to match any digit. All regular expression special characters work as specified in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;, except for &lt;code&gt;.&lt;/code&gt; which is taken as a separator as mentioned above, &lt;code&gt;*&lt;/code&gt; which is translated to the regular-expression notation &lt;code&gt;.*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; which is translated to &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt; which is matched literally. You can emulate these pattern characters at need by writing &lt;code&gt;?&lt;/code&gt; for &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;(R+|)&lt;/code&gt; for &lt;code&gt;R*&lt;/code&gt;, or &lt;code&gt;(R|)&lt;/code&gt; for &lt;code&gt;R?&lt;/code&gt;. &lt;code&gt;$&lt;/code&gt; is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, &lt;code&gt;$&lt;/code&gt; is automatically appended to your pattern). Write &lt;code&gt;*&lt;/code&gt; at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of &lt;code&gt;\do&lt;/code&gt;).</source>
          <target state="translated">上級ユーザーは、 &lt;code&gt;[0-9]&lt;/code&gt; などの文字クラスなどの正規表現表記を使用して、任意の数字を照合できます。を除くすべての正規表現特殊文字は、&lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3項で&lt;/a&gt;指定されているとおりに機能し &lt;code&gt;.&lt;/code&gt; これは、上記のようにセパレータとして使用されます。 &lt;code&gt;*&lt;/code&gt; は、正規表現表記 &lt;code&gt;.*&lt;/code&gt; に変換され &lt;code&gt;?&lt;/code&gt; に翻訳され &lt;code&gt;.&lt;/code&gt; 、および文字通り一致する &lt;code&gt;$&lt;/code&gt; 。これらのパターン文字を必要に応じてエミュレートするには、 &lt;code&gt;?&lt;/code&gt; のために &lt;code&gt;.&lt;/code&gt; 、 &lt;code&gt;(R+|)&lt;/code&gt; のための &lt;code&gt;R*&lt;/code&gt; 、または &lt;code&gt;(R|)&lt;/code&gt; のための &lt;code&gt;R?&lt;/code&gt; 。 &lt;code&gt;$&lt;/code&gt; 正規表現の通常の解釈とは異なり、パターンは名前全体と一致する必要があるため、$は正規表現文字として必要ありません（つまり、 &lt;code&gt;$&lt;/code&gt; はパターンに自動的に追加されます）。書き込みは &lt;code&gt;*&lt;/code&gt; 最初および/または最後に、あなたはパターンが固定されたくない場合。二重引用符内では、すべての正規表現の特殊文字は特別な意味を失い、文字どおりに一致します。また、正規表現の特殊文字は、演算子名パターン（つまり、 &lt;code&gt;\do&lt;/code&gt; 引数）で文字どおり一致します。</target>
        </trans-unit>
        <trans-unit id="ae1d5d5862d5067d5253f55fa2d10173937d4fc6" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns name of the slot and real position to which it was advanced to.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt;という名前の複製スロットの現在確認されている位置を&lt;em&gt;進め&lt;/em&gt;ます。スロットは後方に移動されず、現在の挿入位置を超えて移動されません。スロットの名前と、それが進んだ先の実際の位置を返します。</target>
        </trans-unit>
        <trans-unit id="3d5aab029628974dd5c58605edc8a94526445808" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns the name of the slot and the actual position that it was advanced to. The updated slot position information is written out at the next checkpoint if any advancing is done. So in the event of a crash, the slot may return to an earlier position.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt;という名前のレプリケーションスロットの現在確認されている位置を&lt;em&gt;進め&lt;/em&gt;ます。スロットは後方に移動せず、現在の挿入位置を超えて移動することもありません。スロットの名前と、スロットが進められた実際の位置を返します。更新されたスロット位置情報は、前進が行われた場合、次のチェックポイントで書き出されます。そのため、クラッシュが発生した場合、スロットは以前の位置に戻る可能性があります。</target>
        </trans-unit>
        <trans-unit id="58c81d024a1ba21f51051976ec1e66bb25143e15" translate="yes" xml:space="preserve">
          <source>Advances the sequence object to its next value and returns that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value. If the sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using appropriate parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command.</source>
          <target state="translated">シーケンスオブジェクトを次の値に進め、その値を返します。これはアトミックに行われます。複数のセッションが &lt;code&gt;nextval&lt;/code&gt; を同時に実行する場合でも、それぞれが個別のシーケンス値を安全に受け取ります。シーケンスオブジェクトがデフォルトのパラメータを使用して作成されている場合は、連続 &lt;code&gt;nextval&lt;/code&gt; 呼び出しは、適切なパラメータを使用することによって得ることができる。1.他の行動から始まる連続した値を返します&lt;a href=&quot;sql-createsequence&quot;&gt;SEQUENCEのCREATE&lt;/a&gt;コマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="9d323581d870eb70c61501cdd5933132dd855a86" translate="yes" xml:space="preserve">
          <source>Advisory locks can be acquired on keys consisting of either a single &lt;code&gt;bigint&lt;/code&gt; value or two integer values. A &lt;code&gt;bigint&lt;/code&gt; key is displayed with its high-order half in the &lt;code&gt;classid&lt;/code&gt; column, its low-order half in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 1. The original &lt;code&gt;bigint&lt;/code&gt; value can be reassembled with the expression &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt;. Integer keys are displayed with the first key in the &lt;code&gt;classid&lt;/code&gt; column, the second key in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 2. The actual meaning of the keys is up to the user. Advisory locks are local to each database, so the &lt;code&gt;database&lt;/code&gt; column is meaningful for an advisory lock.</source>
          <target state="translated">アドバイザリロックは、単一の &lt;code&gt;bigint&lt;/code&gt; 値または2つの整数値で構成されるキーで取得できます。 &lt;code&gt;bigint&lt;/code&gt; キーでその上位半分で表示され &lt;code&gt;classid&lt;/code&gt; カラム、その下位に半分 &lt;code&gt;objid&lt;/code&gt; 列、及び &lt;code&gt;objsubid&lt;/code&gt; 1に等しいが、元の &lt;code&gt;bigint&lt;/code&gt; 値を式で再組立てすることができる &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt; 。整数キーは、最初のキーで表示され &lt;code&gt;classid&lt;/code&gt; 列に第2の鍵 &lt;code&gt;objid&lt;/code&gt; 列、及び &lt;code&gt;objsubid&lt;/code&gt; キーの実際の意味はユーザに任されて2に等しいです。アドバイザリロックは各データベースにローカルであるため、 &lt;code&gt;database&lt;/code&gt; 列は、アドバイザリロックにとって意味があります。</target>
        </trans-unit>
        <trans-unit id="f6c29c3eec39081073449cf551f29f5ff2063ec1" translate="yes" xml:space="preserve">
          <source>Advisory locks work normally in recovery, including deadlock detection. Note that advisory locks are never WAL logged, so it is impossible for an advisory lock on either the primary or the standby to conflict with WAL replay. Nor is it possible to acquire an advisory lock on the primary and have it initiate a similar advisory lock on the standby. Advisory locks relate only to the server on which they are acquired.</source>
          <target state="translated">アドバイザリロックは、デッドロックの検出を含め、リカバリ時には正常に動作します。勧告ロックは決して WAL ログに記録されないため、プライマリまたはスタンバイのいずれかで勧告ロックが WAL 再生と競合することはありえないことに注意してください。また、プライマリ上のアドバイザリロックを取得して、それがスタンバイ上で同様のアドバイザリロックを開始させることもできません。アドバイザリロックは、取得したサーバにのみ関係します。</target>
        </trans-unit>
        <trans-unit id="87db6f29dc76387bbaab5ded1909ba41ea3e370f" translate="yes" xml:space="preserve">
          <source>After a checkpoint has been made and the log flushed, the checkpoint's position is saved in the file &lt;code&gt;pg_control&lt;/code&gt;. Therefore, at the start of recovery, the server first reads &lt;code&gt;pg_control&lt;/code&gt; and then the checkpoint record; then it performs the REDO operation by scanning forward from the log location indicated in the checkpoint record. Because the entire content of data pages is saved in the log on the first page modification after a checkpoint (assuming &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is not disabled), all pages changed since the checkpoint will be restored to a consistent state.</source>
          <target state="translated">チェックポイントが作成され、ログがフラッシュされた後、チェックポイントの位置が &lt;code&gt;pg_control&lt;/code&gt; ファイルに保存されます。したがって、リカバリの開始時に、サーバーは最初に &lt;code&gt;pg_control&lt;/code&gt; を読み取り、次にチェックポイントレコードを読み取ります。次に、チェックポイントレコードに示されているログの場所から順方向にスキャンして、REDO操作を実行します。チェックポイント後の最初のページ変更時にデータページのコンテンツ全体がログに保存されるため（&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;が無効になっていないと想定）、チェックポイント以降のすべてのページが変更され、一貫した状態に復元されます。</target>
        </trans-unit>
        <trans-unit id="c70bb87984515ab084a4a6675924bc032765ff87" translate="yes" xml:space="preserve">
          <source>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; is set to zero on the standby. In the case that &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;, the standby sends reply messages when the commit record is replayed, making the transaction visible. If the standby is chosen as a synchronous standby, according to the setting of &lt;code&gt;synchronous_standby_names&lt;/code&gt; on the primary, the reply messages from that standby will be considered along with those from other synchronous standbys to decide when to release transactions waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</source>
          <target state="translated">コミットレコードがプライマリのディスクに書き込まれた後、WALレコードがスタンバイに送信されます。スタンバイで &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; がゼロに設定されていない限り、スタンバイはWALデータの新しいバッチがディスクに書き込まれるたびに応答メッセージを送信します。 &lt;code&gt;synchronous_commit&lt;/code&gt; が &lt;code&gt;remote_apply&lt;/code&gt; に設定されている場合、スタンバイはコミットレコードが再生されるときに応答メッセージを送信し、トランザクションを表示します。スタンバイは、設定に応じて、同期スタンバイとして選択される場合 &lt;code&gt;synchronous_standby_names&lt;/code&gt; プライマリでは、そのスタンバイからの応答メッセージが他の同期スタンバイからの応答メッセージと一緒に考慮され、コミットレコードが受信されたことの確認を待っているトランザクションをいつ解放するかを決定します。これらのパラメータを使用すると、管理者は同期スタンバイにするスタンバイサーバーを指定できます。同期レプリケーションの設定は主にマスターで行われることに注意してください。名前付きスタンバイは、マスターに直接接続する必要があります。マスターは、カスケードレプリケーションを使用するダウンストリームスタンバイサーバーについて何も知りません。</target>
        </trans-unit>
        <trans-unit id="94241391dfbbfde4a951b39750ed3743aeb3267e" translate="yes" xml:space="preserve">
          <source>After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen.</source>
          <target state="translated">クエリが出力テーブルを生成した後(セレクトリストが処理された後)、オプションでソートすることができます。ソートが選択されなかった場合、行は指定されていない順序で返されます。この場合の実際の順序は、スキャンや結合プランのタイプやディスク上の順序に依存しますが、それに依存してはいけません。特定の出力順序は、ソートステップが明示的に選択された場合にのみ保証されます。</target>
        </trans-unit>
        <trans-unit id="3b97640c2ecb0afe6be98ec8bef630298c29b1bf" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">シーケンスが作成された後、関数 &lt;code&gt;nextval&lt;/code&gt; 、 &lt;code&gt;currval&lt;/code&gt; 、および &lt;code&gt;setval&lt;/code&gt; を使用してシーケンスを操作します。これらの関数については、&lt;a href=&quot;functions-sequence&quot;&gt;セクション9.16で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="ff749f2ca9f8a705af6bd96ce00013a3fb590b4b" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;.</source>
          <target state="translated">シーケンスが作成されたら、関数 &lt;code&gt;nextval&lt;/code&gt; 、 &lt;code&gt;currval&lt;/code&gt; 、および &lt;code&gt;setval&lt;/code&gt; を使用してシーケンスを操作します。これらの機能は&lt;a href=&quot;functions-sequence&quot;&gt;セクション9.17に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="cc6fe30bfc047dc5821b58053e75c58c27a7d060" translate="yes" xml:space="preserve">
          <source>After a successful rewind, the state of the target data directory is analogous to a base backup of the source data directory. Unlike taking a new base backup or using a tool like rsync, pg_rewind does not require comparing or copying unchanged relation blocks in the cluster. Only changed blocks from existing relation files are copied; all other files, including new relation files, configuration files, and WAL segments, are copied in full. As such the rewind operation is significantly faster than other approaches when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">巻き戻しに成功した後のターゲットデータディレクトリの状態は、ソースデータディレクトリのベースバックアップに類似しています。新しいベースバックアップを取ったり、rsyncのようなツールを使用したりするのとは異なり、pg_rewindではクラスタ内の変更されていないリレーションブロックを比較したりコピーしたりする必要はありません。既存のリレーションファイルから変更されたブロックのみがコピーされ、新しいリレーションファイル、設定ファイル、WALセグメントを含む他のすべてのファイルが完全にコピーされます。このように、データベースが大規模で、クラスタ間でブロックのごく一部が異なるだけの場合、巻き戻し操作は他のアプローチよりも大幅に高速です。</target>
        </trans-unit>
        <trans-unit id="bc113f99607193995354648154db9d5489f2fd2b" translate="yes" xml:space="preserve">
          <source>After an index is created, the system has to keep it synchronized with the table. This adds overhead to data manipulation operations. Therefore indexes that are seldom or never used in queries should be removed.</source>
          <target state="translated">インデックスが作成された後、システムはそれをテーブルと同期させておく必要があります。これはデータ操作操作のオーバーヘッドを追加します。したがって、クエリで滅多に使用されない、あるいは使用されることのないインデックスは削除されるべきです。</target>
        </trans-unit>
        <trans-unit id="07e3f54a730eab0090b9f9763615353b60509ba8" translate="yes" xml:space="preserve">
          <source>After completing the tests, it's recommended you disable the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter:</source>
          <target state="translated">テストが完了したら、 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; パラメータを無効にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b07e5c0448618c87913bcee1323b05d5b460e37c" translate="yes" xml:space="preserve">
          <source>After creating partitions of &lt;code&gt;measurement_y2006m02&lt;/code&gt;, any data inserted into &lt;code&gt;measurement&lt;/code&gt; that is mapped to &lt;code&gt;measurement_y2006m02&lt;/code&gt; (or data that is directly inserted into &lt;code&gt;measurement_y2006m02&lt;/code&gt;, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the &lt;code&gt;peaktemp&lt;/code&gt; column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</source>
          <target state="translated">パーティションを作成した後 &lt;code&gt;measurement_y2006m02&lt;/code&gt; を、任意のデータが挿入 &lt;code&gt;measurement&lt;/code&gt; にマッピングされ &lt;code&gt;measurement_y2006m02&lt;/code&gt; （または直接に挿入されるデータ &lt;code&gt;measurement_y2006m02&lt;/code&gt; を、それを満たすそのパーティション制約提供）さらに基づいてそのパーティションの1つにリダイレクトする &lt;code&gt;peaktemp&lt;/code&gt; のカラム。指定されたパーティションキーは、親のパーティションキーと重複する場合がありますが、サブパーティションの境界を指定するときは、それが受け入れるデータのセットが、パーティション自体の境界が許可するもののサブセットを構成するように注意する必要があります。システムは、それが本当にそうであるかどうかをチェックしようとしません。</target>
        </trans-unit>
        <trans-unit id="db536621da1a6c52f06af534df944428be135246" translate="yes" xml:space="preserve">
          <source>After creating the function, we create a trigger which calls the trigger function:</source>
          <target state="translated">関数を作成したら、その関数を呼び出すトリガーを作成します。</target>
        </trans-unit>
        <trans-unit id="c393be77ecb9862e06e4a42080ca1b8d309670b1" translate="yes" xml:space="preserve">
          <source>After modifying that file, a reboot is required for the new settings to take effect.</source>
          <target state="translated">そのファイルを変更した後、新しい設定を有効にするには再起動が必要です。</target>
        </trans-unit>
        <trans-unit id="c876187243218ed419e1b156be87fd9454c80ab8" translate="yes" xml:space="preserve">
          <source>After passing the &lt;code&gt;WHERE&lt;/code&gt; filter, the derived input table might be subject to grouping, using the &lt;code&gt;GROUP BY&lt;/code&gt; clause, and elimination of group rows using the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; フィルターを通過した後、派生した入力テーブルは、 &lt;code&gt;GROUP BY&lt;/code&gt; 句を使用してグループ化され、 &lt;code&gt;HAVING&lt;/code&gt; 句を使用してグループ行が削除される場合があります。</target>
        </trans-unit>
        <trans-unit id="476a32ba88141aeb970e81601edc2ee511e8c4b9" translate="yes" xml:space="preserve">
          <source>After reaching the end of valid WAL, keep polling once per second for new WAL to appear.</source>
          <target state="translated">有効なWALの終了に到達した後、新しいWALが表示されるように1秒に1回のポーリングを続けます。</target>
        </trans-unit>
        <trans-unit id="fd721ac53a17faa8b9db323757ed059c923d71fc" translate="yes" xml:space="preserve">
          <source>After recompiling and running the new binary, check that your newly added probe is available by executing the following DTrace command. You should see similar output:</source>
          <target state="translated">新しいバイナリを再コンパイルして実行した後、以下の DTrace コマンドを実行して、新しく追加したプローブが使用可能であることを確認してください。同様の出力が表示されるはずです。</target>
        </trans-unit>
        <trans-unit id="c206de8ceae00b19b0bbd697b5fe278bf3d62023" translate="yes" xml:space="preserve">
          <source>After restoring a backup, it is wise to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on each database so the query optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. For more advice on how to load large amounts of data into PostgreSQL efficiently, refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt;.</source>
          <target state="translated">バックアップを復元した後、各データベースで&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行して、クエリオプティマイザーが有用な統計を取得できるようにすることをお勧めします。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。大量のデータをPostgreSQLに効率的にロードする方法の詳細については、&lt;a href=&quot;populate&quot;&gt;セクション14.4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="417976bf060ad8e20656ba39a451c14e19b1e474" translate="yes" xml:space="preserve">
          <source>After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.</source>
          <target state="translated">セーブポイントにロールバックした後も、そのセーブポイントは定義され続けますので、何度かロールバックすることができます。逆に、特定のセーブポイントに再度ロールバックする必要がないと確信している場合は、そのセーブポイントを解放することで、システムがリソースを解放することができます。セーブポイントを解放するかロールバックするかは、その後に定義されたすべてのセーブポイントを自動的に解放することになることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="39ee00792319dcfa46ab74c067181f9cb4e42b47" translate="yes" xml:space="preserve">
          <source>After running pg_rewind, WAL replay needs to complete for the data directory to be in a consistent state. When the target server is started again it will enter archive recovery and replay all WAL generated in the source server from the last checkpoint before the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and by configuring a suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">pg_rewindを実行した後、データディレクトリを整合性のある状態にするには、WALの再生を完了する必要があります。ターゲットサーバーが再度起動されると、アーカイブリカバリに入り、分岐点の前の最後のチェックポイントからソースサーバーで生成されたすべてのWALが再生されます。pg_rewindの実行時に一部のWALがソースサーバーで使用できなくなったため、pg_rewindセッションでコピーできなかった場合は、ターゲットサーバーの起動時に使用可能にする必要があります。これは、ターゲットデータディレクトリに &lt;code&gt;recovery.signal&lt;/code&gt; ファイルを作成し、 &lt;code&gt;postgresql.conf&lt;/code&gt; で適切な&lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt;を構成することで実行できます。</target>
        </trans-unit>
        <trans-unit id="e2cf5063e2afd451a505eeabbaaa31e6dea2f166" translate="yes" xml:space="preserve">
          <source>After running this command, it should be possible to start the server, but bear in mind that the database might contain inconsistent data due to partially-committed transactions. You should immediately dump your data, run &lt;code&gt;initdb&lt;/code&gt;, and reload. After reload, check for inconsistencies and repair as needed.</source>
          <target state="translated">このコマンドを実行すると、サーバーを起動できるようになりますが、トランザクションが部分的にコミットされているため、データベースに一貫性のないデータが含まれている可能性があることに注意してください。すぐにデータをダンプし、 &lt;code&gt;initdb&lt;/code&gt; を実行してリロードする必要があります。リロード後、矛盾がないか確認し、必要に応じて修復します。</target>
        </trans-unit>
        <trans-unit id="f1751e378d5c61831bc66381dd026a28d4a7604f" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;auth-method&lt;/code&gt; field, there can be field(s) of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; that specify options for the authentication method. Details about which options are available for which authentication methods appear below.</source>
          <target state="translated">&lt;code&gt;auth-method&lt;/code&gt; フィールドの後には、 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; という形式のフィールドがあり、認証方法のオプションを指定できます。どの認証方法でどのオプションを使用できるかについての詳細は、以下に表示されます。</target>
        </trans-unit>
        <trans-unit id="129d74f6272df45af1d745e991e7a73feebafe5a" translate="yes" xml:space="preserve">
          <source>After the processing of the &lt;code&gt;FROM&lt;/code&gt; clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the &lt;code&gt;FROM&lt;/code&gt; clause; this is not required, but otherwise the &lt;code&gt;WHERE&lt;/code&gt; clause will be fairly useless.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 句の処理が完了すると、派生仮想テーブルの各行が検索条件に対してチェックされます。条件の結果がtrueの場合、行は出力テーブルに保持されます。それ以外の場合（つまり、結果がfalseまたはnullの場合）は破棄されます。通常、検索条件は &lt;code&gt;FROM&lt;/code&gt; 句で生成されたテーブルの少なくとも1つの列を参照します。これは必須ではありませんが、それ以外の場合、 &lt;code&gt;WHERE&lt;/code&gt; 句はほとんど役に立ちません。</target>
        </trans-unit>
        <trans-unit id="7afbd68cfd57086d9de66444e71b66bfaedc388a" translate="yes" xml:space="preserve">
          <source>After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The &lt;code&gt;DISTINCT&lt;/code&gt; key word is written directly after &lt;code&gt;SELECT&lt;/code&gt; to specify this:</source>
          <target state="translated">選択リストが処理された後、結果テーブルはオプションで重複行の除去の影響を受ける可能性があります。 &lt;code&gt;DISTINCT&lt;/code&gt; キーワードは直後に書かれている &lt;code&gt;SELECT&lt;/code&gt; これを指定するには：</target>
        </trans-unit>
        <trans-unit id="6f94a805413e3bb85d7fa38665d29205c38f9186" translate="yes" xml:space="preserve">
          <source>After this command is executed, the index is &amp;ldquo;owned&amp;rdquo; by the constraint, in the same way as if the index had been built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command. In particular, dropping the constraint will make the index disappear too.</source>
          <target state="translated">このコマンドを実行すると、通常の &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; または &lt;code&gt;ADD UNIQUE&lt;/code&gt; コマンドによってインデックスが作成された場合と同じように、インデックスは制約によって「所有」されます。特に、制約を削除すると、インデックスも非表示になります。</target>
        </trans-unit>
        <trans-unit id="5a54a1d7a070e112cd3e777d9befed8de7b72e73" translate="yes" xml:space="preserve">
          <source>Again connect to the database as a user with rights to run pg_stop_backup (superuser, or a user who has been granted EXECUTE on the function), and issue the command:</source>
          <target state="translated">pg_stop_backupを実行する権限を持つユーザ(スーパーユーザ、または関数に対してEXECUTEを付与されたユーザ)としてデータベースに接続し、コマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="89c328b5eae1533574b7b6b9cb4641c91474c438" translate="yes" xml:space="preserve">
          <source>Again the planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for &lt;code&gt;=&lt;/code&gt;, which is &lt;code&gt;eqsel&lt;/code&gt;. For equality estimation the histogram is not useful; instead the list of &lt;em&gt;most common values&lt;/em&gt; (MCVs) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later:</source>
          <target state="translated">再び、プランナは &lt;code&gt;WHERE&lt;/code&gt; 句の条件を調べ、 &lt;code&gt;=&lt;/code&gt; の選択性関数を &lt;code&gt;eqsel&lt;/code&gt; ます。これはeqselです。等価推定では、ヒストグラムは役に立ちません。代わりに、&lt;em&gt;最も一般的な値&lt;/em&gt;（MCV）のリストを使用して、選択性を決定します。MCVを見てみましょう。後で役立つ列がいくつか追加されています。</target>
        </trans-unit>
        <trans-unit id="4c27783eb44bcd1d4c219fa9ccfc28e663471099" translate="yes" xml:space="preserve">
          <source>Again, a more realistic example:</source>
          <target state="translated">またしても、より現実的な例です。</target>
        </trans-unit>
        <trans-unit id="6c1eea13275ab96326295feeff11f71292c224b0" translate="yes" xml:space="preserve">
          <source>Again, a table alias is required. Assigning alias names to the columns of the &lt;code&gt;VALUES&lt;/code&gt; list is optional, but is good practice. For more information see &lt;a href=&quot;queries-values&quot;&gt;Section 7.7&lt;/a&gt;.</source>
          <target state="translated">ここでも、テーブルのエイリアスが必要です。 &lt;code&gt;VALUES&lt;/code&gt; リストの列へのエイリアス名の割り当てはオプションですが、適切な方法です。詳細については、&lt;a href=&quot;queries-values&quot;&gt;7.7項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fa2e8717405811a7aefb85de6cf3250083c52ac2" translate="yes" xml:space="preserve">
          <source>Again, note that some of these commands are actually allowed during &quot;read only&quot; mode transactions on the primary.</source>
          <target state="translated">繰り返しになりますが、これらのコマンドの中には、プライマリ上の「読み取り専用」モードのトランザクション中に実際に許可されているものがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d75929b4f5b2f824a7a07da4899bf1820357b131" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">繰り返しますが、詳細は&lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;第12章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8820b9fd552bc40289d6bbf23d466ae2aeb85fb1" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">繰り返しますが、詳細については&lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;第12章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="73c2d4672afb28ef558326e3d56d8e571d70b6fe" translate="yes" xml:space="preserve">
          <source>Again, the argument &lt;code&gt;uppercase&lt;/code&gt; was omitted so it is set to &lt;code&gt;false&lt;/code&gt; implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:</source>
          <target state="translated">この場合も、引数の &lt;code&gt;uppercase&lt;/code&gt; は省略されているため、暗黙的に &lt;code&gt;false&lt;/code&gt; に設定されます。名前付き表記を使用する利点の1つは、引数を次のように任意の順序で指定できることです。</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">集計機能</target>
        </trans-unit>
        <trans-unit id="644f8b99c4c1166b7dd3dea3ff097223a8e3390b" translate="yes" xml:space="preserve">
          <source>Aggregate function (routine)</source>
          <target state="translated">集計機能(ルーチン</target>
        </trans-unit>
        <trans-unit id="78066b1c350419b50af4d9f199ab1be3ff9a7bd9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are an extension.</source>
          <target state="translated">集計機能はその延長線上にある。</target>
        </trans-unit>
        <trans-unit id="871c4bc7e83d3ebb5166fa9fb4f5c7870dcdec31" translate="yes" xml:space="preserve">
          <source>Aggregate functions that support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">&lt;em&gt;部分モード&lt;/em&gt;をサポートする集計関数は、並列集計などのさまざまな最適化に参加する資格があります。</target>
        </trans-unit>
        <trans-unit id="41c2d9b93a1fb3de5a512eb3000462da32b26df8" translate="yes" xml:space="preserve">
          <source>Aggregate functions which support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">&lt;em&gt;パーシャルモード&lt;/em&gt;をサポートする集計関数は、並列集計などのさまざまな最適化に参加する資格があります。</target>
        </trans-unit>
        <trans-unit id="90d68cd3e256fbe87b23e489f9c82e0bca666a22" translate="yes" xml:space="preserve">
          <source>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a &lt;code&gt;FILTER&lt;/code&gt; clause to the aggregate function call; see &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt; for more information. When a &lt;code&gt;FILTER&lt;/code&gt; clause is present, only those rows matching it are included in the input to that aggregate function.</source>
          <target state="translated">使用されている場合、集計関数は、各グループを構成するすべての行にわたって計算され、グループごとに個別の値が生成されます。 （集約関数はあるが &lt;code&gt;GROUP BY&lt;/code&gt; 句がない場合、クエリは、選択されたすべての行で構成される単一のグループを持つものとして扱われます。） &lt;code&gt;FILTER&lt;/code&gt; 句を集約関数にアタッチすることにより、各集約関数に供給される行のセットをさらにフィルターできます。コール;詳細は、&lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;4.2.7項​​を&lt;/a&gt;参照してください。 &lt;code&gt;FILTER&lt;/code&gt; 句が存在する場合、それに一致する行のみがその集計関数への入力に含まれます。</target>
        </trans-unit>
        <trans-unit id="cbff25b6bf81504908e5320d1af957a7ec74d3b6" translate="yes" xml:space="preserve">
          <source>Aggregate kind: &lt;code&gt;n&lt;/code&gt; for &amp;ldquo;normal&amp;rdquo; aggregates, &lt;code&gt;o&lt;/code&gt; for &amp;ldquo;ordered-set&amp;rdquo; aggregates, or &lt;code&gt;h&lt;/code&gt; for &amp;ldquo;hypothetical-set&amp;rdquo; aggregates</source>
          <target state="translated">集合体の種類：「通常の」集合体の場合は &lt;code&gt;n&lt;/code&gt; 、「順序セット」集合体の場合は &lt;code&gt;o&lt;/code&gt; 、「仮想セット」集合体の場合は &lt;code&gt;h&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="113588f464cd4fe7bfbc7d7c65d0648a3eeb21d0" translate="yes" xml:space="preserve">
          <source>Aggregate: *</source>
          <target state="translated">集計します。*</target>
        </trans-unit>
        <trans-unit id="d76c0a0d13e4564f62e4ef32c8d0ac5d3a9bd1e2" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUP BY</source>
          <target state="translated">集計:GROUP BY</target>
        </trans-unit>
        <trans-unit id="67fa6b402dc45ed045bd73c615623304375dc24b" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUPING</source>
          <target state="translated">集計します。グループ化</target>
        </trans-unit>
        <trans-unit id="bf655ffdd9634b84bf30927558cadb22681f9bbb" translate="yes" xml:space="preserve">
          <source>Aggregate: WITHIN GROUP</source>
          <target state="translated">集計:グループ内</target>
        </trans-unit>
        <trans-unit id="e7717151bc6adba0544d963b5ecd779cf9aefbe1" translate="yes" xml:space="preserve">
          <source>Aggregate: array_agg</source>
          <target state="translated">集計:array_agg</target>
        </trans-unit>
        <trans-unit id="7671fe3f4aa646a763a41cd74b0f33b4d9825d22" translate="yes" xml:space="preserve">
          <source>Aggregate: avg</source>
          <target state="translated">平均値:平均値</target>
        </trans-unit>
        <trans-unit id="9464ad790968a8c3f29976c4cecb93cf8cb97818" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_and</source>
          <target state="translated">集計:bit_and</target>
        </trans-unit>
        <trans-unit id="f4ff9c9094ce1f94db13530e24012163b5e11d40" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_or</source>
          <target state="translated">集計:bit_or</target>
        </trans-unit>
        <trans-unit id="b9c262247be1030665a29ac642cf245ebfafdc8c" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_and</source>
          <target state="translated">集計:bool_and</target>
        </trans-unit>
        <trans-unit id="a36b04811f8dfcb04687f062eee53e188ba68218" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_or</source>
          <target state="translated">集計:bool_or</target>
        </trans-unit>
        <trans-unit id="6b938ae10da8a5049736d651f7bdf37fa7dd2ec6" translate="yes" xml:space="preserve">
          <source>Aggregate: corr</source>
          <target state="translated">集計:実行</target>
        </trans-unit>
        <trans-unit id="f67c8e60c07fff9ff21ed59ebe5883cf64966901" translate="yes" xml:space="preserve">
          <source>Aggregate: count</source>
          <target state="translated">集計:カウント</target>
        </trans-unit>
        <trans-unit id="a535e7f27744a217a4b4ebbcc5ce09395054c24d" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_pop</source>
          <target state="translated">集計:covar_pop</target>
        </trans-unit>
        <trans-unit id="e42952cf656ba58f6dfa69af76b03eb6f4865935" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_samp</source>
          <target state="translated">集計:covar_samp</target>
        </trans-unit>
        <trans-unit id="fc5ea10421b5c30ba97731125807dc2645fb9fc1" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist</source>
          <target state="translated">集計:cume_dist</target>
        </trans-unit>
        <trans-unit id="affa989634b7b7f9316e718975ac524915a80100" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist WITHIN GROUP</source>
          <target state="translated">集計:cume_dist WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="5413552564b5ce9858645aad9d11f00224935ffb" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank</source>
          <target state="translated">集計:dense_rank</target>
        </trans-unit>
        <trans-unit id="3ff732a0c7e39824a92acd57f902391a878f3abf" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank WITHIN GROUP</source>
          <target state="translated">集計:dense_rank WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="8dc8d8ebf59b788e17565bab2f4948b36d249316" translate="yes" xml:space="preserve">
          <source>Aggregate: every</source>
          <target state="translated">集計:すべての</target>
        </trans-unit>
        <trans-unit id="cb574ceb369d625e53cf66f30a46474ab01c8d22" translate="yes" xml:space="preserve">
          <source>Aggregate: json_agg</source>
          <target state="translated">集計:json_agg</target>
        </trans-unit>
        <trans-unit id="5daf429a167bfb1204d6816cc327273b7dff3d24" translate="yes" xml:space="preserve">
          <source>Aggregate: json_object_agg</source>
          <target state="translated">集計:json_object_agg</target>
        </trans-unit>
        <trans-unit id="146ad7890c6afaeaa83cf4ce928bc658120656b5" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_agg</source>
          <target state="translated">集計:jsonb_agg</target>
        </trans-unit>
        <trans-unit id="6f7d6e6ca2d445820090cd7f314ec40d5730bd62" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_object_agg</source>
          <target state="translated">集計:jsonb_object_agg</target>
        </trans-unit>
        <trans-unit id="65e31a82796d0cddf371f7a0ba43aa2ede594f67" translate="yes" xml:space="preserve">
          <source>Aggregate: max</source>
          <target state="translated">集計:最大</target>
        </trans-unit>
        <trans-unit id="36d81566b6da93dc64aade9617077054e335a89e" translate="yes" xml:space="preserve">
          <source>Aggregate: min</source>
          <target state="translated">集計:最小</target>
        </trans-unit>
        <trans-unit id="4eb5d44d93ed2f2a9cdcc0ef1679955c52d6f77c" translate="yes" xml:space="preserve">
          <source>Aggregate: mode</source>
          <target state="translated">アグレゲート:ファッション</target>
        </trans-unit>
        <trans-unit id="7c96cf40a4dc1d8d1ea12a0b1f5bcf59364dc827" translate="yes" xml:space="preserve">
          <source>Aggregate: mode WITHIN GROUP</source>
          <target state="translated">集計:モード WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="3827ba089152343be605c81a6829b3adfab7a03f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank</source>
          <target state="translated">集計:percent_rank</target>
        </trans-unit>
        <trans-unit id="34b5e1912aa5215dcec451af73485fcbfd34b50f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank WITHIN GROUP</source>
          <target state="translated">集計:percent_rank WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="4071198c9c5d51f5904da94e25f898d0927a065a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont</source>
          <target state="translated">集計:percentile_cont</target>
        </trans-unit>
        <trans-unit id="1d40010d0c71e89dc5a258e985609a24fad7370a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont WITHIN GROUP</source>
          <target state="translated">集計:percentile_cont WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="221d8437a4694e24ecacfafa477406400d56070a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc</source>
          <target state="translated">集計:パーセンタイルディスク</target>
        </trans-unit>
        <trans-unit id="9c269fdb441e6262d2a37b019da9d266f3b3b083" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc WITHIN GROUP</source>
          <target state="translated">集計:percentile_disc WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="780b4bfa2df2c728976c6499686f1e45a03cae9d" translate="yes" xml:space="preserve">
          <source>Aggregate: rank</source>
          <target state="translated">集計:ランク</target>
        </trans-unit>
        <trans-unit id="66604fc6a8764a0b6d82483c45c9ff5043d563ce" translate="yes" xml:space="preserve">
          <source>Aggregate: rank WITHIN GROUP</source>
          <target state="translated">集計:ランク WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="08db334b9f771618e8d9956b3a35006958baa8aa" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgx</source>
          <target state="translated">集計:regr_avgx</target>
        </trans-unit>
        <trans-unit id="f813e6eb9f1bd8f18122c9d3100e3e1329000930" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgy</source>
          <target state="translated">集計:regr_avgy</target>
        </trans-unit>
        <trans-unit id="db3268966df89189e65fd222205de0442daba3c2" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_count</source>
          <target state="translated">集計:regr_count</target>
        </trans-unit>
        <trans-unit id="4489b8487a16a39dde1e4d8b5fcd20f0950266f5" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_intercept</source>
          <target state="translated">集計:regr_intercept</target>
        </trans-unit>
        <trans-unit id="17dd93536539876bbf56b59964ca4c7379d9ef8f" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_r2</source>
          <target state="translated">集計:regr_r2</target>
        </trans-unit>
        <trans-unit id="bbd0902e24a6b13aeeb42be12d4c6ac689ac39d4" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_slope</source>
          <target state="translated">集計値:regr_slope</target>
        </trans-unit>
        <trans-unit id="83dbb5beff01870dc33ceaa7278e2d80cc920457" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxx</source>
          <target state="translated">集計:regr_sxx</target>
        </trans-unit>
        <trans-unit id="ec7ca11bda1c42f1ba07c7f1bd8a0c3296064181" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxy</source>
          <target state="translated">集計:regr_sxy</target>
        </trans-unit>
        <trans-unit id="f14b071a16428ce5a21dc895086399aaadc762a3" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_syy</source>
          <target state="translated">集計:regr_syy</target>
        </trans-unit>
        <trans-unit id="c004eede3fbd79af583dbd185f768dfae4d466a6" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev</source>
          <target state="translated">集計:stddev</target>
        </trans-unit>
        <trans-unit id="1d5e80f190137dd3cac84ce1a78d10780d5bce34" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_pop</source>
          <target state="translated">集計:stddev_pop</target>
        </trans-unit>
        <trans-unit id="d3b157c6a46f69b3887530f9f9b22d6b9cb4a16e" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_samp</source>
          <target state="translated">集計:stddev_samp</target>
        </trans-unit>
        <trans-unit id="2974203e91cce11e66f9221d5ec28297655cd0a8" translate="yes" xml:space="preserve">
          <source>Aggregate: string_agg</source>
          <target state="translated">集計:string_agg</target>
        </trans-unit>
        <trans-unit id="ee008bd21c90b91f02271735e82b4e05772fdd98" translate="yes" xml:space="preserve">
          <source>Aggregate: sum</source>
          <target state="translated">集計:合計</target>
        </trans-unit>
        <trans-unit id="7f9f090a85b6cef6189e9f1f572af2d4232d4c63" translate="yes" xml:space="preserve">
          <source>Aggregate: sum/N</source>
          <target state="translated">集計:sum/N</target>
        </trans-unit>
        <trans-unit id="42f2801430c2438881499cac7d09362a7b44215e" translate="yes" xml:space="preserve">
          <source>Aggregate: to_json</source>
          <target state="translated">集計:to_json</target>
        </trans-unit>
        <trans-unit id="56a46ffd3d158ae27b092ee54bfe3724f518b2f3" translate="yes" xml:space="preserve">
          <source>Aggregate: var_pop</source>
          <target state="translated">集計:var_pop</target>
        </trans-unit>
        <trans-unit id="3c7dc337d4d493d0b8b497185b09dab2dd6b0e40" translate="yes" xml:space="preserve">
          <source>Aggregate: var_samp</source>
          <target state="translated">集計:var_samp</target>
        </trans-unit>
        <trans-unit id="51e197a4c87920c56f05e65ce1ba4b227834b071" translate="yes" xml:space="preserve">
          <source>Aggregate: variance</source>
          <target state="translated">集計:分散</target>
        </trans-unit>
        <trans-unit id="a2fb0accd998c64e0241184b4242d48e43957e30" translate="yes" xml:space="preserve">
          <source>Aggregate: xmlagg</source>
          <target state="translated">集計:xmlagg</target>
        </trans-unit>
        <trans-unit id="576d72bc3c483daa9c7746a2659f34dd5176aed8" translate="yes" xml:space="preserve">
          <source>Aggregated Argument Type(s)</source>
          <target state="translated">集約された引数タイプ</target>
        </trans-unit>
        <trans-unit id="425a801b77a97dcec7fa5fa5f67892cad03a7787" translate="yes" xml:space="preserve">
          <source>Aggregated Logging</source>
          <target state="translated">集計されたロギング</target>
        </trans-unit>
        <trans-unit id="604697606446ca85390963f1caeb65a8c41712bd" translate="yes" xml:space="preserve">
          <source>Aggregates are also very useful in combination with &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For example, we can get the maximum low temperature observed in each city with:</source>
          <target state="translated">集計は、 &lt;code&gt;GROUP BY&lt;/code&gt; 句と組み合わせて使用​​すると非常に便利です。たとえば、次のようにして、各都市で観測された最高気温を取得できます。</target>
        </trans-unit>
        <trans-unit id="8a83bb8f12f58dc63f8d8450952fc03b0bc1ffde" translate="yes" xml:space="preserve">
          <source>Aggregates that behave like &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt; can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a &lt;em&gt;sort operator&lt;/em&gt;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; または &lt;code&gt;MAX&lt;/code&gt; のように動作する集計は、すべての入力行をスキャンする代わりに、インデックスを調べることによって最適化できる場合があります。この集計を最適化できる場合は、&lt;em&gt;ソート演算子を&lt;/em&gt;指定してそれを示します。基本的な要件は、演算子によって誘導される並べ替え順序の最初の要素を集約が生成する必要があることです。言い換えると：</target>
        </trans-unit>
        <trans-unit id="7ec048891025aea562b86e815620f42ae7adb619" translate="yes" xml:space="preserve">
          <source>Aggressive &lt;code&gt;VACUUM&lt;/code&gt; scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</source>
          <target state="translated">積極的な &lt;code&gt;VACUUM&lt;/code&gt; スキャンは、その原因に関係なく、そのテーブルの値を進めることを可能にします。最終的に、すべてのデータベースのすべてのテーブルがスキャンされ、それらの最も古いmultixact値が拡張されるため、古いmultixactのディスク上のストレージを削除できます。</target>
        </trans-unit>
        <trans-unit id="121abf3940fab2d8dbe9b94bbd289148bc06a85b" translate="yes" xml:space="preserve">
          <source>Aggressively &amp;ldquo;freeze&amp;rdquo; tuples.</source>
          <target state="translated">タプルを積極的に「凍結」します。</target>
        </trans-unit>
        <trans-unit id="bcb017abcff2696033726df1d1faa6140cda30fa" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Postgres Professional, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、モスクワ、Postgres Professional、ロシア</target>
        </trans-unit>
        <trans-unit id="aa44f40c0080e2d8f22aa729bc2aa695de07bb55" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; 、Postgres Professional、モスクワ、ロシア</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="9e3800ae71f3a62322201681fab38592cc7aac5f" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt; can be used as window functions, but window functions can also be used to, for example, give ranks to each of the rows in the partition. Also known as &lt;em&gt;analytic functions&lt;/em&gt;.</source>
          <target state="translated">すべての&lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;集計関数&lt;/a&gt;をウィンドウ関数として使用できますが、ウィンドウ関数を使用して、たとえば、パーティション内の各行にランクを付けることもできます。&lt;em&gt;分析関数と&lt;/em&gt;も呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="1238bd88f43030284835da146c8f594a6e3253c8" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;pgcrypto&lt;/code&gt; functions run inside the database server. That means that all the data and passwords move between &lt;code&gt;pgcrypto&lt;/code&gt; and client applications in clear text. Thus you must:</source>
          <target state="translated">すべての &lt;code&gt;pgcrypto&lt;/code&gt; 関数はデータベースサーバー内で実行されます。つまり、すべてのデータとパスワードが &lt;code&gt;pgcrypto&lt;/code&gt; とクライアントアプリケーションの間をクリアテキストで移動します。したがって、次のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="0b67ddd3a2de73817c7543968b2cc085a1a78542" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; 以外のすべての &lt;code&gt;storage&lt;/code&gt; 値は、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;セクション37.13.1で&lt;/a&gt;説明されているように、データ型の関数が&lt;em&gt;トースト&lt;/em&gt;され&lt;em&gt;た&lt;/em&gt;値を処理できることを意味します。指定された他の特定の値は、単にトースト可能なデータ型の列のデフォルトのTOASTストレージ戦略を決定します。ユーザーは、 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; を使用して、個々の列に対して他の戦略を選択できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8dfd6e92427babe1e9a096720e962dca35e82cb" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; 以外のすべての &lt;code&gt;storage&lt;/code&gt; 値は、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;セクション37.13.1で&lt;/a&gt;説明されているように、データ型の関数が&lt;em&gt;トースト&lt;/em&gt;され&lt;em&gt;た&lt;/em&gt;値を処理できることを意味します。指定された他の特定の値は、トースト可能なデータ型の列のデフォルトのTOASTストレージ戦略を決定するだけです。ユーザーは、 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; を使用して、個々の列に対して他の戦略を選択できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10d6e0687d278d53588734a1b582257aaee1502f" translate="yes" xml:space="preserve">
          <source>All Privileges</source>
          <target state="translated">すべての特権</target>
        </trans-unit>
        <trans-unit id="bf637fbee55bb9d868af3ee61e448c31817bc7e1" translate="yes" xml:space="preserve">
          <source>All UPC, ISBN, ISMN and ISSN numbers can be represented as EAN13 numbers.</source>
          <target state="translated">すべてのUPC、ISBN、ISMN、ISSN番号はEAN13番号で表すことができます。</target>
        </trans-unit>
        <trans-unit id="f057cd68ee57e6fcf443add2a601584e9abb4486" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the master and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">バックアップに必要なすべてのWALレコードには、十分なフルページ書き込みが含まれている必要があります。これには、マスターで &lt;code&gt;full_page_writes&lt;/code&gt; を有効にし、pg_compresslogなどのツールを &lt;code&gt;archive_command&lt;/code&gt; として使用してWALファイルからフルページ書き込みを削除しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="32451a83c5b4d59ae6ed31b28d945b83e60fefc2" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the primary and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">バックアップに必要なすべてのWALレコードが有効にするためにあなたを必要とする、十分なフルページの書き込みが含まれている必要があり &lt;code&gt;full_page_writes&lt;/code&gt; を主にしとしてpg_compresslogのようなツールを使用しないよう &lt;code&gt;archive_command&lt;/code&gt; WALファイルからフルページの書き込みを削除します。</target>
        </trans-unit>
        <trans-unit id="841cc9e5c025174354644ed418b19ab2df80e067" translate="yes" xml:space="preserve">
          <source>All arguments are specified in order. The result is upper case since &lt;code&gt;uppercase&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;. Another example is:</source>
          <target state="translated">すべての引数は順番に指定されます。 &lt;code&gt;uppercase&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に指定されているため、結果は大文字になります。別の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="64cfac4af128aada4a6d6bb5c11a90e45ce7a24e" translate="yes" xml:space="preserve">
          <source>All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with &lt;code&gt;NO INHERIT&lt;/code&gt; clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.</source>
          <target state="translated">&lt;code&gt;NO INHERIT&lt;/code&gt; 句で明示的に指定されていない限り、親テーブルのすべてのチェック制約とnull以外の制約は、その子によって自動的に継承されます。その他のタイプの制約（一意、主キー、および外部キー制約）は継承されません。</target>
        </trans-unit>
        <trans-unit id="337d6bdce5b053fd7a1885beaee3b7d63bb8f598" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values, as if &lt;code&gt;DEFAULT&lt;/code&gt; were explicitly specified for each column. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; が各列に明示的に指定されているかのように、すべての列にデフォルト値が入力されます。（このフォームでは、 &lt;code&gt;OVERRIDING&lt;/code&gt; 句は許可されていません。）</target>
        </trans-unit>
        <trans-unit id="89f96ca727311b0e1e924639300601036b23919a" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">すべての列にデフォルト値が入力されます。（この形式では &lt;code&gt;OVERRIDING&lt;/code&gt; 句は使用できません。）</target>
        </trans-unit>
        <trans-unit id="44d64899ac94e8442ee1baa672497f8a2ca162b4" translate="yes" xml:space="preserve">
          <source>All constraints on all children of the parent table are examined during constraint exclusion, so large numbers of children are likely to increase query planning time considerably. So the legacy inheritance based partitioning will work well with up to perhaps a hundred child tables; don't try to use many thousands of children.</source>
          <target state="translated">親テーブルのすべての子テーブルに対するすべての制約は、制約除外時に検査されるので、子テーブルの数が多いと問い合わせ計画時間が大幅に増加します。そのため、レガシー継承ベースのパーティショニングは、おそらく100個までの子テーブルでもうまく機能しますが、何千個もの子テーブルを使おうとしないでください。</target>
        </trans-unit>
        <trans-unit id="153c80dc5116feea616ba3928be18ab8586f5a93" translate="yes" xml:space="preserve">
          <source>All current listen registrations for this session are cleared.</source>
          <target state="translated">このセッションの現在のリスナー登録はすべてクリアされます。</target>
        </trans-unit>
        <trans-unit id="e559ad46dfb12176f9ab6a5068fbbc335264dacf" translate="yes" xml:space="preserve">
          <source>All currently available prepared transactions are listed in the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">現在使用可能なすべての準備済みトランザクションは、&lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt;システムビューにリストされます。</target>
        </trans-unit>
        <trans-unit id="2778b518fdc9b5356b12e2a79dd08d30844b8366" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; リストのすべての要素が計算されます。（ &lt;code&gt;FROM&lt;/code&gt; リストの各要素は実テーブルまたは仮想テーブルです。） &lt;code&gt;FROM&lt;/code&gt; リストで複数の要素が指定されている場合、それらは相互に結合されます。（下記の&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 節を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="14481956ddccdbae880b961dfaa2429f752c35d7" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;FROM Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; リストのすべての要素が計算されます。（ &lt;code&gt;FROM&lt;/code&gt; リストの各要素は実テーブルまたは仮想テーブルです。） &lt;code&gt;FROM&lt;/code&gt; リストで複数の要素が指定されている場合、それらは相互結合されます。（以下の&lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;FROM句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="3978f2f6a0fc6fd4b0827f0ebd212e7bcc3552c2" translate="yes" xml:space="preserve">
          <source>All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</source>
          <target state="translated">テーブルとインデックスを再構築するためのアップグレード後のスクリプトは自動的に生成されます。多くのクラスタのアップグレードを自動化しようとしている場合、同一のデータベーススキーマを持つクラスタでは、すべてのクラスタアップグレードに同じアップグレード後の手順が必要であることが分かるはずです。</target>
        </trans-unit>
        <trans-unit id="2887bc873471e44a6e402dab0ddec69892effbd0" translate="yes" xml:space="preserve">
          <source>All functions and operators used in an index definition must be &amp;ldquo;immutable&amp;rdquo;, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression or &lt;code&gt;WHERE&lt;/code&gt; clause, remember to mark the function immutable when you create it.</source>
          <target state="translated">インデックス定義で使用されるすべての関数と演算子は「不変」である必要があります。つまり、結果は引数にのみ依存し、外部の影響（別のテーブルの内容や現在の時刻など）に依存してはなりません。この制限により、インデックスの動作が明確に定義されます。インデックス式または &lt;code&gt;WHERE&lt;/code&gt; 句でユーザー定義関数を使用するには、作成時に関数に不変のマークを付けることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="3ef17a42f49f1b90a3d376b9b52494437e996867" translate="yes" xml:space="preserve">
          <source>All indexes in PostgreSQL are &lt;em&gt;secondary&lt;/em&gt; indexes, meaning that each index is stored separately from the table's main data area (which is called the table's &lt;em&gt;heap&lt;/em&gt; in PostgreSQL terminology). This means that in an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. Furthermore, while the index entries that match a given indexable &lt;code&gt;WHERE&lt;/code&gt; condition are usually close together in the index, the table rows they reference might be anywhere in the heap. The heap-access portion of an index scan thus involves a lot of random access into the heap, which can be slow, particularly on traditional rotating media. (As described in &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt;, bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.)</source>
          <target state="translated">PostgreSQLのすべてのインデックスは&lt;em&gt;セカンダリ&lt;/em&gt;インデックスです。つまり、各インデックスはテーブルのメインデータ領域（PostgreSQLの用語ではテーブルの&lt;em&gt;ヒープ&lt;/em&gt;と呼ばれます）とは別に格納されます。つまり、通常のインデックススキャンでは、各行の取得でインデックスとヒープの両方からデータをフェッチする必要があります。さらに、特定のインデックス可能な &lt;code&gt;WHERE&lt;/code&gt; 条件に一致するインデックスエントリは通常、インデックス内で互いに近接していますが、それらが参照するテーブル行はヒープ内のどこかにある場合があります。したがって、インデックススキャンのヒープアクセス部分には、ヒープへのランダムアクセスが多数含まれます。これは、特に従来の回転メディアでは遅くなる可能性があります。 （&lt;a href=&quot;indexes-bitmap-scans&quot;&gt;セクション11.5で&lt;/a&gt;説明、ビットマップスキャンは、ソートされた順序でヒープアクセスを行うことでこのコストを軽減しようとしますが、それはこれまでのところです。</target>
        </trans-unit>
        <trans-unit id="db79cd41caf099a5fc97eb22b9bdb081eeb2153e" translate="yes" xml:space="preserve">
          <source>All it takes to get a BRIN access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, BRIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">BRINアクセス・メソッドを動作させるために必要なのは、インデックスに格納されたサマリー値の動作とスキャン・キーとの相互作用を定義するユーザー定義のメソッドをいくつか実装することだけである。要するに、BRINは拡張性と汎用性、コードの再利用、そしてクリーンなインターフェイスを兼ね備えている。</target>
        </trans-unit>
        <trans-unit id="6e1a7f84a08ba9a0c97ee25a9736132689a50678" translate="yes" xml:space="preserve">
          <source>All it takes to get a GIN access method working is to implement a few user-defined methods, which define the behavior of keys in the tree and the relationships between keys, indexed items, and indexable queries. In short, GIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">GINのアクセスメソッドを動作させるために必要なのは、いくつかのユーザー定義のメソッドを実装することだけです。要するに、GIN は拡張性と汎用性、コードの再利用、そしてクリーンなインターフェイスを兼ね備えています。</target>
        </trans-unit>
        <trans-unit id="932e4d059724c2d4b8d21124cf86633cf4ac8541" translate="yes" xml:space="preserve">
          <source>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</source>
          <target state="translated">GiSTのアクセスメソッドを立ち上げて実行するために必要なのは、ツリー内のキーの動作を定義するユーザ定義のメソッドをいくつか実装することだけです。もちろん、これらのメソッドは、派手なクエリをサポートするためにかなり派手なものでなければなりませんが、すべての標準的なクエリ(B木、R木など)に対しては、比較的簡単に実装できます。要するに、GiSTは拡張性と汎用性、コードの再利用、そしてクリーンなインターフェースを兼ね備えています。</target>
        </trans-unit>
        <trans-unit id="f6f094a1f0d931ca3f860e1e2d7b887c4d3d20bd" translate="yes" xml:space="preserve">
          <source>All messages emitted by the PostgreSQL server are assigned five-character error codes that follow the SQL standard's conventions for &amp;ldquo;SQLSTATE&amp;rdquo; codes. Applications that need to know which error condition has occurred should usually test the error code, rather than looking at the textual error message. The error codes are less likely to change across PostgreSQL releases, and also are not subject to change due to localization of error messages. Note that some, but not all, of the error codes produced by PostgreSQL are defined by the SQL standard; some additional error codes for conditions not defined by the standard have been invented or borrowed from other databases.</source>
          <target state="translated">PostgreSQLサーバーによって発行されるすべてのメッセージには、SQL標準の「SQLSTATE」コードの規則に従う5文字のエラーコードが割り当てられます。どのエラー状態が発生したかを知る必要があるアプリケーションは、通常、テキストのエラーメッセージを調べるのではなく、エラーコードをテストする必要があります。エラーコードはPostgreSQLのリリース間で変更される可能性が低く、エラーメッセージのローカライズにより変更されることもありません。PostgreSQLによって生成されるすべてではなく一部のエラーコードは、SQL標準によって定義されていることに注意してください。標準で定義されていない条件のいくつかの追加のエラーコードは、他のデータベースから発明または借用されています。</target>
        </trans-unit>
        <trans-unit id="5f17dc4d29230530f8f45813d17f855f136a3816" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidMultiXactId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">これより前のすべてのmultixact IDは、このテーブルでトランザクションIDに置き換えられています。これは、multixact IDの折り返しを防止するため、または &lt;code&gt;pg_multixact&lt;/code&gt; を縮小できるようにするために、テーブルをバキュームする必要があるかどうかを追跡するために使用されます。リレーションがテーブルでない場合はゼロ（ &lt;code&gt;InvalidMultiXactId&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dede7220bdd3e91dec2b9b6615dd35bb3933921" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced with a transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; values.</source>
          <target state="translated">これより前のすべてのmultixact IDは、このデータベースでトランザクションIDに置き換えられています。これは、multixact IDの折り返しを防止するために、または &lt;code&gt;pg_multixact&lt;/code&gt; を縮小できるようにするために、データベースをバキュームする必要があるかどうかを追跡するために使用されます。これは、テーブルごとの &lt;code&gt;pg_class&lt;/code&gt; の最小値です。 &lt;code&gt;relminmxid&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="b6a1ec7b62542588df77c091f76d37462abbe3bd" translate="yes" xml:space="preserve">
          <source>All of the OID alias types for objects grouped by namespace accept schema-qualified names, and will display schema-qualified names on output if the object would not be found in the current search path without being qualified. The &lt;code&gt;regproc&lt;/code&gt; and &lt;code&gt;regoper&lt;/code&gt; alias types will only accept input names that are unique (not overloaded), so they are of limited use; for most uses &lt;code&gt;regprocedure&lt;/code&gt; or &lt;code&gt;regoperator&lt;/code&gt; are more appropriate. For &lt;code&gt;regoperator&lt;/code&gt;, unary operators are identified by writing &lt;code&gt;NONE&lt;/code&gt; for the unused operand.</source>
          <target state="translated">名前空間でグループ化されたオブジェクトのすべてのOIDエイリアスタイプは、スキーマ修飾名を受け入れ、オブジェクトが修飾されていない場合に現在の検索パスで見つからない場合、出力にスキーマ修飾名を表示します。 &lt;code&gt;regproc&lt;/code&gt; と &lt;code&gt;regoper&lt;/code&gt; エイリアスの種類は、彼らが制限された使用であるので、（オーバーロードされていない）一意である入力名を受け入れます。ほとんどの用途では、 &lt;code&gt;regprocedure&lt;/code&gt; または &lt;code&gt;regoperator&lt;/code&gt; がより適切です。 &lt;code&gt;regoperator&lt;/code&gt; を、単項演算子は書いていないで識別され &lt;code&gt;NONE&lt;/code&gt; を未使用のオペランドの。</target>
        </trans-unit>
        <trans-unit id="37766175956ba6517dd475210dd4e291c6b94f05" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all peer rows.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60&lt;/a&gt;にリストされているすべての関数は、関連するウィンドウ定義の &lt;code&gt;ORDER BY&lt;/code&gt; 句で指定されたソート順に依存しています。 &lt;code&gt;ORDER BY&lt;/code&gt; 列のみを考慮した場合に区別されない行は、&lt;em&gt;ピア&lt;/em&gt;と呼ばれます。4つのランキング関数（ &lt;code&gt;cume_dist&lt;/code&gt; を含む）は、すべてのピア行に同じ答えを与えるように定義されています。</target>
        </trans-unit>
        <trans-unit id="6b3dc7a98e19d74a1c8b693082bcc2b7322b43f8" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all rows of a peer group.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;表9.60&lt;/a&gt;にリストされているすべての関数は、関連するウィンドウ定義の &lt;code&gt;ORDER BY&lt;/code&gt; 句で指定されたソート順に依存します。 &lt;code&gt;ORDER BY&lt;/code&gt; 列のみを考慮した場合に区別されない行は、&lt;em&gt;ピア&lt;/em&gt;と呼ばれます。 4つのランキング関数（ &lt;code&gt;cume_dist&lt;/code&gt; を含む）は、ピアグループのすべての行に同じ答えを与えるように定義されています。</target>
        </trans-unit>
        <trans-unit id="02fa4b0f473762a8721b052a178d80c186d067cd" translate="yes" xml:space="preserve">
          <source>All of the options except &lt;code&gt;convert-crlf&lt;/code&gt; apply only to encrypt functions. Decrypt functions get the parameters from the PGP data.</source>
          <target state="translated">&lt;code&gt;convert-crlf&lt;/code&gt; を除くすべてのオプションは、暗号化機能にのみ適用されます。復号化関数は、PGPデータからパラメーターを取得します。</target>
        </trans-unit>
        <trans-unit id="592ca33a4522df17e0e57a59e6344510c5d4a80c" translate="yes" xml:space="preserve">
          <source>All of the policies constructed thus far have been permissive policies, meaning that when multiple policies are applied they are combined using the &amp;ldquo;OR&amp;rdquo; Boolean operator. While permissive policies can be constructed to only allow access to rows in the intended cases, it can be simpler to combine permissive policies with restrictive policies (which the records must pass and which are combined using the &amp;ldquo;AND&amp;rdquo; Boolean operator). Building on the example above, we add a restrictive policy to require the administrator to be connected over a local Unix socket to access the records of the &lt;code&gt;passwd&lt;/code&gt; table:</source>
          <target state="translated">これまでに作成されたすべてのポリシーは寛容なポリシーでした。つまり、複数のポリシーが適用される場合、それらは「OR」ブール演算子を使用して結合されます。許可ポリシーは、意図したケースで行へのアクセスのみを許可するように構築できますが、許可ポリシーと制限ポリシー（レコードが通過する必要があり、「AND」ブール演算子を使用して結合される）を組み合わせる方が簡単です。上記の例に基づいて、 &lt;code&gt;passwd&lt;/code&gt; テーブルのレコードにアクセスするために管理者がローカルのUnixソケットを介して接続することを要求する制限的なポリシーを追加します。</target>
        </trans-unit>
        <trans-unit id="068ae9ee084ab21fc5a8a7c0060d57cbf4e3473f" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.23.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">これらの &lt;code&gt;ORDER BY&lt;/code&gt; 句はすべて、行の複合値を指定するため、&lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;9.23.6項で&lt;/a&gt;説明されているルールに従って行がソートされます。ただし、 &lt;code&gt;inventory_item&lt;/code&gt; に &lt;code&gt;c&lt;/code&gt; という名前の列が含まれている場合、最初のケースは他のケースとは異なります。これは、その列のみでソートすることを意味するためです。前に示した列名を考えると、これらのクエリも上記のものと同等です。</target>
        </trans-unit>
        <trans-unit id="c8391ba1355f7ba958065513e77b352946c8ee3d" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.24.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">これらのすべて &lt;code&gt;ORDER BY&lt;/code&gt; 句は、に記載の規則に従って行をソートし、その結果、行の複合値を指定する&lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;セクション9.24.6&lt;/a&gt;。ただし、 &lt;code&gt;inventory_item&lt;/code&gt; に &lt;code&gt;c&lt;/code&gt; という名前の列が含まれている場合、最初のケースは他のケースとは異なり、その列のみで並べ替えることを意味します。前に示した列名を考えると、これらのクエリも上記のクエリと同等です。</target>
        </trans-unit>
        <trans-unit id="abf3c99355ffd14c50c6d5db9b1b5a423f1e1022" translate="yes" xml:space="preserve">
          <source>All of these fields are optional, except &lt;code&gt;commonName&lt;/code&gt;. It depends entirely on your CA's policy which of them would be included and which wouldn't. The meaning of these fields, however, is strictly defined by the X.500 and X.509 standards, so you cannot just assign arbitrary meaning to them.</source>
          <target state="translated">&lt;code&gt;commonName&lt;/code&gt; を除き、これらのフィールドはすべてオプションです。それはCAのポリシーに完全に依存し、それらのうちどれが含まれるか、含まれないかが決まります。ただし、これらのフィールドの意味はX.500およびX.509標準によって厳密に定義されているため、単に任意の意味を割り当てることはできません。</target>
        </trans-unit>
        <trans-unit id="c6deee271f21fa5ab3c6f7bba891d40136e2c021" translate="yes" xml:space="preserve">
          <source>All of these operations will throw an error if a supplied array contains any NULL elements.</source>
          <target state="translated">これらの操作はすべて、指定された配列にNULL要素が含まれている場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="d9b92f66d52bf42e15e05f0a8c5cb26f0298b448" translate="yes" xml:space="preserve">
          <source>All other parameters are described in detail under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">他のすべてのパラメーターについては、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;で詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="a4df9c2d50326edae48634d605dfaf0fbdb01416" translate="yes" xml:space="preserve">
          <source>All parameter names are case-insensitive. Every parameter takes a value of one of five types: boolean, string, integer, floating point, or enumerated (enum). The type determines the syntax for setting the parameter:</source>
          <target state="translated">すべてのパラメータ名は大文字小文字を区別しません。すべてのパラメータは、ブール値、文字列、整数、浮動小数点、列挙型 (enum)の 5 つの型のうちいずれかの値を取ります。型は、パラメータを設定するための構文を決定します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
