<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="1485f3d0af50f7ad2c38bab6ab4b82f7cade74e8" translate="yes" xml:space="preserve">
          <source>The right to modify or destroy an object is always the privilege of the owner only.</source>
          <target state="translated">オブジェクトを修正したり破壊したりする権利は、常に所有者のみの特権です。</target>
        </trans-unit>
        <trans-unit id="a4b02a1fae471a2cfa0b9f0f9afcb866f7eeb267" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all comparisons yield true (including the case where the array has zero elements). The result is &amp;ldquo;false&amp;rdquo; if any false result is found.</source>
          <target state="translated">右側は括弧で囲まれた式で、配列値を生成する必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して配列の各要素と比較されます。演算子はブール型の結果を生成する必要があります。 &lt;code&gt;ALL&lt;/code&gt; の結果は、すべての比較の結果がtrueの場合（配列の要素が0の場合を含む）は「true」です。誤った結果が見つかった場合、結果は「偽」です。</target>
        </trans-unit>
        <trans-unit id="0854056fb124d8ec388aaba4b2f113f43a992144" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized expression, which must yield an array value. The left-hand expression is evaluated and compared to each element of the array using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the array has zero elements).</source>
          <target state="translated">右側は括弧で囲まれた式であり、配列値を生成する必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用して配列の各要素と比較されます。演算子はブール型の結果を生成する必要があります。結果 &lt;code&gt;ANY&lt;/code&gt; は、任意の真の結果が得られた場合、「真」です。真の結果が見つからない場合（配列の要素が0の場合を含む）、結果は「偽」になります。</target>
        </trans-unit>
        <trans-unit id="4cadd4592ac992256e9ca190e2ede2776b0f06bb" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is equal to any of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">右側は、括弧で囲まれたスカラー式のリストです。左側の式の結果がいずれかの右側の式と等しい場合、結果は「true」になります。これは、</target>
        </trans-unit>
        <trans-unit id="9a6bece97382db0f9b6ad5060523f2f32e422503" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized list of scalar expressions. The result is &amp;ldquo;true&amp;rdquo; if the left-hand expression's result is unequal to all of the right-hand expressions. This is a shorthand notation for</source>
          <target state="translated">右側は、括弧で囲まれたスカラー式のリストです。左側の式の結果がすべての右側の式と等しくない場合、結果は「true」になります。これは、</target>
        </trans-unit>
        <trans-unit id="4623e53b09512588ad13e7eaadc6e34f6d36d750" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ALL&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if all rows yield true (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any false result is found. The result is NULL if no comparison with a subquery row returns false, and at least one comparison returns NULL.</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用してサブクエリ結果の各行と比較されます。 &lt;code&gt;ALL&lt;/code&gt; の結果は、すべての行がtrueになる場合（サブクエリが行を返さない場合を含む）は「true」です。誤った結果が見つかった場合、結果は「偽」です。サブクエリ行との比較がfalseを返さず、少なくとも1つの比較がNULLを返す場合、結果はNULLです。</target>
        </trans-unit>
        <trans-unit id="89b47774fd6157f8ca176076b1ed18f995c2daef" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result using the given &lt;code&gt;operator&lt;/code&gt;, which must yield a Boolean result. The result of &lt;code&gt;ANY&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any true result is obtained. The result is &amp;ldquo;false&amp;rdquo; if no true result is found (including the case where the subquery returns no rows).</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、指定された &lt;code&gt;operator&lt;/code&gt; を使用してサブクエリ結果の各行と比較されます。真の結果が得られた場合、 &lt;code&gt;ANY&lt;/code&gt; の結果は「真」になります。真の結果が見つからない場合（サブクエリが行を返さない場合を含む）、結果は「偽」になります。</target>
        </trans-unit>
        <trans-unit id="a7873b5839bfc7065dc6edeb7940049a4cb53216" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if any equal subquery row is found. The result is &amp;ldquo;false&amp;rdquo; if no equal row is found (including the case where the subquery returns no rows).</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、サブクエリ結果の各行と比較されます。等しいサブクエリ行が見つかった場合、 &lt;code&gt;IN&lt;/code&gt; の結果は「true」です。等しい行が見つからない場合（サブクエリが行を返さない場合を含む）、結果は「false」になります。</target>
        </trans-unit>
        <trans-unit id="0ca2d475edb7fe77a4b6be61177af0a4c222988e" translate="yes" xml:space="preserve">
          <source>The right-hand side is a parenthesized subquery, which must return exactly one column. The left-hand expression is evaluated and compared to each row of the subquery result. The result of &lt;code&gt;NOT IN&lt;/code&gt; is &amp;ldquo;true&amp;rdquo; if only unequal subquery rows are found (including the case where the subquery returns no rows). The result is &amp;ldquo;false&amp;rdquo; if any equal row is found.</source>
          <target state="translated">右側は括弧で囲まれたサブクエリで、正確に1つの列を返す必要があります。左側の式が評価され、サブクエリ結果の各行と比較されます。等しくないサブクエリ行のみが見つかった場合（サブクエリが行を返さない場合を含む）、 &lt;code&gt;NOT IN&lt;/code&gt; の結果は「true」になります。等しい行が見つかった場合、結果は「false」です。</target>
        </trans-unit>
        <trans-unit id="60ffe49fd73a1dfeb0ff0a3cd27bc012700f7f66" translate="yes" xml:space="preserve">
          <source>The risk that is taken by using asynchronous commit is of data loss, not data corruption. If the database should crash, it will recover by replaying WAL up to the last record that was flushed. The database will therefore be restored to a self-consistent state, but any transactions that were not yet flushed to disk will not be reflected in that state. The net effect is therefore loss of the last few transactions. Because the transactions are replayed in commit order, no inconsistency can be introduced &amp;mdash; for example, if transaction B made changes relying on the effects of a previous transaction A, it is not possible for A's effects to be lost while B's effects are preserved.</source>
          <target state="translated">非同期コミットを使用することによるリスクは、データの破損ではなく、データの損失です。データベースがクラッシュした場合、フラッシュされた最後のレコードまでWALを再生することで回復します。したがって、データベースは自己矛盾のない状態に復元されますが、まだディスクにフラッシュされていないトランザクションはその状態に反映されません。したがって、最終的な影響は、最後のいくつかのトランザクションの損失です。トランザクションはコミット順で再生されるため、不整合が生じることはありません。たとえば、トランザクションBが前のトランザクションAの影響に依存して変更を加えた場合、Bの影響が保持されている間にAの影響が失われることはありません。</target>
        </trans-unit>
        <trans-unit id="458aee8243a88af8890a3686268fbeeebdc768b4" translate="yes" xml:space="preserve">
          <source>The role attributes &lt;code&gt;LOGIN&lt;/code&gt;, &lt;code&gt;SUPERUSER&lt;/code&gt;, &lt;code&gt;CREATEDB&lt;/code&gt;, and &lt;code&gt;CREATEROLE&lt;/code&gt; can be thought of as special privileges, but they are never inherited as ordinary privileges on database objects are. You must actually &lt;code&gt;SET ROLE&lt;/code&gt; to a specific role having one of these attributes in order to make use of the attribute. Continuing the above example, we might choose to grant &lt;code&gt;CREATEDB&lt;/code&gt; and &lt;code&gt;CREATEROLE&lt;/code&gt; to the &lt;code&gt;admin&lt;/code&gt; role. Then a session connecting as role &lt;code&gt;joe&lt;/code&gt; would not have these privileges immediately, only after doing &lt;code&gt;SET ROLE admin&lt;/code&gt;.</source>
          <target state="translated">ロール属性 &lt;code&gt;LOGIN&lt;/code&gt; 、 &lt;code&gt;SUPERUSER&lt;/code&gt; 、 &lt;code&gt;CREATEDB&lt;/code&gt; 、および &lt;code&gt;CREATEROLE&lt;/code&gt; は特別な特権と考えることができますが、データベースオブジェクトに対する通常の特権のように継承されることはありません。あなたが実際に必要 &lt;code&gt;SET ROLE&lt;/code&gt; 属性を使用するために、これらのいずれかの属性を有する特定の役割に。上記の例を続けると、 &lt;code&gt;CREATEDB&lt;/code&gt; と &lt;code&gt;CREATEROLE&lt;/code&gt; を &lt;code&gt;admin&lt;/code&gt; ロールに付与することを選択できます。そうすると、ロール &lt;code&gt;joe&lt;/code&gt; として接続しているセッションは、 &lt;code&gt;SET ROLE admin&lt;/code&gt; を実行した後でのみ、これらの特権をすぐには得られません。</target>
        </trans-unit>
        <trans-unit id="cc4f14a678d35107865a506875d403f1fabcef04" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new database, or &lt;code&gt;DEFAULT&lt;/code&gt; to use the default (namely, the user executing the command). To create a database owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">新しいデータベースを所有するユーザーのロール名、または &lt;code&gt;DEFAULT&lt;/code&gt; を使用するDEFAULT（つまり、コマンドを実行するユーザー）。別のロールが所有するデータベースを作成するには、そのロールの直接的または間接的なメンバーであるか、スーパーユーザーである必要があります。</target>
        </trans-unit>
        <trans-unit id="e0cd094fcb28a6d1c971a4fe5ea4b6668f0b2297" translate="yes" xml:space="preserve">
          <source>The role name of the user who will own the new schema. If omitted, defaults to the user executing the command. To create a schema owned by another role, you must be a direct or indirect member of that role, or be a superuser.</source>
          <target state="translated">新しいスキーマを所有するユーザーのロール名です。省略した場合は、コマンドを実行しているユーザがデフォルトです。他のロールが所有するスキーマを作成するには、そのロールの直接または間接的なメンバであるか、スーパーユーザでなければなりません。</target>
        </trans-unit>
        <trans-unit id="288659e152f65b17d46027cdd207a204fb13225f" translate="yes" xml:space="preserve">
          <source>The role used for the replication connection must have the &lt;code&gt;REPLICATION&lt;/code&gt; attribute (or be a superuser). Access for the role must be configured in &lt;code&gt;pg_hba.conf&lt;/code&gt; and it must have the &lt;code&gt;LOGIN&lt;/code&gt; attribute.</source>
          <target state="translated">レプリケーション接続に使用されるロールは、 &lt;code&gt;REPLICATION&lt;/code&gt; 属性を持っている（またはスーパーユーザーである）必要があります。ロールへのアクセスは &lt;code&gt;pg_hba.conf&lt;/code&gt; で設定する必要があり、 &lt;code&gt;LOGIN&lt;/code&gt; 属性が必要です。</target>
        </trans-unit>
        <trans-unit id="7270c8298ccd5ab28e0386f721a4bd64642b81f5" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy applies. Multiple roles can be specified at one time. To apply the policy to all roles, use &lt;code&gt;PUBLIC&lt;/code&gt;.</source>
          <target state="translated">ポリシーが適用される役割。一度に複数のロールを指定できます。ポリシーをすべてのロールに適用するには、 &lt;code&gt;PUBLIC&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="672dc56056e4468fca330096a6f7988e99426d64" translate="yes" xml:space="preserve">
          <source>The role(s) to which the policy is to be applied. The default is &lt;code&gt;PUBLIC&lt;/code&gt;, which will apply the policy to all roles.</source>
          <target state="translated">ポリシーが適用される役割。デフォルトは &lt;code&gt;PUBLIC&lt;/code&gt; で、すべてのロールにポリシーが適用されます。</target>
        </trans-unit>
        <trans-unit id="da08283627fb6b277f73d5b0ddf0372ed6cb0f5d" translate="yes" xml:space="preserve">
          <source>The roles to which the policy is applied</source>
          <target state="translated">ポリシーが適用される役割</target>
        </trans-unit>
        <trans-unit id="0b502eae099c8f10d1ed4ef0c354669f63bce361" translate="yes" xml:space="preserve">
          <source>The roles to which this policy applies</source>
          <target state="translated">このポリシーが適用される役割</target>
        </trans-unit>
        <trans-unit id="acd6a9c4a0e56d2f8f09c7b30b75a454cb6c1d08" translate="yes" xml:space="preserve">
          <source>The rows considered by a window function are those of the &amp;ldquo;virtual table&amp;rdquo; produced by the query's &lt;code&gt;FROM&lt;/code&gt; clause as filtered by its &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses if any. For example, a row removed because it does not meet the &lt;code&gt;WHERE&lt;/code&gt; condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways using different &lt;code&gt;OVER&lt;/code&gt; clauses, but they all act on the same collection of rows defined by this virtual table.</source>
          <target state="translated">ウィンドウ関数によって考慮される行は、 &lt;code&gt;WHERE&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、および &lt;code&gt;HAVING&lt;/code&gt; 句（存在する場合）によってフィルターされたクエリの &lt;code&gt;FROM&lt;/code&gt; 句によって生成された「仮想テーブル」の行です。たとえば、 &lt;code&gt;WHERE&lt;/code&gt; 条件を満たさないために削除された行は、どのウィンドウ関数にも表示されません。クエリには、さまざまな &lt;code&gt;OVER&lt;/code&gt; 句を使用してさまざまな方法でデータをスライスする複数のウィンドウ関数を含めることができますが、これらはすべて、この仮想テーブルで定義された行の同じコレクションに作用します。</target>
        </trans-unit>
        <trans-unit id="ac9a42afd27bb82c7fefe7d8456c8e56005d3e20" translate="yes" xml:space="preserve">
          <source>The rows skipped by an &lt;code&gt;OFFSET&lt;/code&gt; clause still have to be computed inside the server; therefore a large &lt;code&gt;OFFSET&lt;/code&gt; might be inefficient.</source>
          <target state="translated">&lt;code&gt;OFFSET&lt;/code&gt; 句によってスキップされた行は、サーバー内で計算する必要があります。したがって、大きな &lt;code&gt;OFFSET&lt;/code&gt; は非効率的です。</target>
        </trans-unit>
        <trans-unit id="9c6595d74dd986e8e704f616ce70f02f89a3b6e5" translate="yes" xml:space="preserve">
          <source>The rule firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;, analogous to triggers as described above.</source>
          <target state="translated">ルール起動メカニズムは、上記のトリガーと同様に、構成変数&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_roleの&lt;/a&gt;影響も受けます。</target>
        </trans-unit>
        <trans-unit id="77cbd29a44e08d42c19c09374140fe6b3a2c7eb5" translate="yes" xml:space="preserve">
          <source>The rules file has the following format:</source>
          <target state="translated">ルールファイルの形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="20f26d0e3be07fc8411c53cf4fec028b4fb7ddc1" translate="yes" xml:space="preserve">
          <source>The rules given in the preceding sections will result in assignment of non-&lt;code&gt;unknown&lt;/code&gt; data types to all expressions in a SQL query, except for unspecified-type literals that appear as simple output columns of a &lt;code&gt;SELECT&lt;/code&gt; command. For example, in</source>
          <target state="translated">前のセクションで示した規則により、SQL コマンドのすべての式に、 &lt;code&gt;unknown&lt;/code&gt; データ型が割り当てられます。ただし、 &lt;code&gt;SELECT&lt;/code&gt; コマンドの単純な出力列として表示される未指定のタイプのリテラルは除きます。たとえば、</target>
        </trans-unit>
        <trans-unit id="a710b4d0128d22b5baa147d345de94a14b25c08a" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;1...2&lt;/code&gt;, or &lt;code&gt;1 .. 2&lt;/code&gt;, or &lt;code&gt;1..2&lt;/code&gt; (spaces around the range operator are ignored)</source>
          <target state="translated">&lt;code&gt;1...2&lt;/code&gt; 、または &lt;code&gt;1 .. 2&lt;/code&gt; 、または &lt;code&gt;1..2&lt;/code&gt; と同じ（範囲演算子の前後のスペースは無視されます）</target>
        </trans-unit>
        <trans-unit id="e6e201d82f084cc5d95195c10944ee93631d8df0" translate="yes" xml:space="preserve">
          <source>The same, and also reset any associated sequence generators:</source>
          <target state="translated">同様に、また、関連するシーケンスジェネレータをリセットします。</target>
        </trans-unit>
        <trans-unit id="241b8d226e8b5f79ed0ec6888a0ce004af81b21c" translate="yes" xml:space="preserve">
          <source>The same, but counting only word occurrences with weight &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">同じですが、重みが &lt;code&gt;A&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; の単語の出現のみをカウントします。</target>
        </trans-unit>
        <trans-unit id="d2d2e57444e30e19980ec9c24adfc53e9305e592" translate="yes" xml:space="preserve">
          <source>The same, but only execute the function if column &lt;code&gt;balance&lt;/code&gt; is specified as a target in the &lt;code&gt;UPDATE&lt;/code&gt; command:</source>
          <target state="translated">同じですが、 &lt;code&gt;UPDATE&lt;/code&gt; コマンドで列 &lt;code&gt;balance&lt;/code&gt; がターゲットとして指定されている場合にのみ関数を実行します。</target>
        </trans-unit>
        <trans-unit id="002437cb1427716a633526fb7913d4100317c440" translate="yes" xml:space="preserve">
          <source>The same, specified as a table constraint:</source>
          <target state="translated">同じく、テーブル制約として指定されています。</target>
        </trans-unit>
        <trans-unit id="788d460ac0c5a82665dae9bd0fa72bfb74260b32" translate="yes" xml:space="preserve">
          <source>The same, using regular expression notation to consolidate the switches:</source>
          <target state="translated">同じく正規表現表記を使ってスイッチを集約している。</target>
        </trans-unit>
        <trans-unit id="bfae0e75e1b6288495d53b506d9a241bf9d03b6d" translate="yes" xml:space="preserve">
          <source>The same, when the column has a default expression that won't automatically cast to the new data type:</source>
          <target state="translated">カラムにデフォルトの式があり、それが自動的に新しいデータ型にキャストされない場合も同様です。</target>
        </trans-unit>
        <trans-unit id="d799562b98253554741c727e0742611d0f2a5b8b" translate="yes" xml:space="preserve">
          <source>The sample results shown on this page assume that the server parameter &lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt;&lt;code&gt;bytea_output&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;escape&lt;/code&gt; (the traditional PostgreSQL format).</source>
          <target state="translated">このページに示されているサンプル結果は、サーバーパラメータ&lt;a href=&quot;runtime-config-client#GUC-BYTEA-OUTPUT&quot;&gt; &lt;code&gt;bytea_output&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;escape&lt;/code&gt; するように設定されていることを前提としています（従来のPostgreSQL形式）。</target>
        </trans-unit>
        <trans-unit id="63cecb1fda6e05d04ffb99e00faba23729910dbf" translate="yes" xml:space="preserve">
          <source>The savepoint to roll back to.</source>
          <target state="translated">ロールバックするセーブポイント。</target>
        </trans-unit>
        <trans-unit id="237920c06713568a0627b8a6cf3c35b4a6fcf5f1" translate="yes" xml:space="preserve">
          <source>The scalar ordering operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, etc) do not make a lot of sense for any practical purpose but sorting. These operators first compare the first coordinates, and if those are equal, compare the second coordinates, etc. They exist mainly to support the b-tree index operator class for &lt;code&gt;cube&lt;/code&gt;, which can be useful for example if you would like a UNIQUE constraint on a &lt;code&gt;cube&lt;/code&gt; column.</source>
          <target state="translated">スカラーの順序付け演算子（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; など）は、ソート以外の実用的な目的にはあまり意味がありません。これらの演算子は最初に最初の座標を比較し、等しい場合は2番目の座標を比較します。これらは主に、 &lt;code&gt;cube&lt;/code&gt; のbツリーインデックス演算子クラスをサポートするために存在します。これは、たとえば、UNIQUE制約が必要な場合に役立ちます。 &lt;code&gt;cube&lt;/code&gt; の列。</target>
        </trans-unit>
        <trans-unit id="c8365d330a7b8ee61b52ae905279178001855d43" translate="yes" xml:space="preserve">
          <source>The schema containing the &lt;code&gt;citext&lt;/code&gt; operators must be in the current &lt;code&gt;search_path&lt;/code&gt; (typically &lt;code&gt;public&lt;/code&gt;); if it is not, the normal case-sensitive &lt;code&gt;text&lt;/code&gt; operators will be invoked instead.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 演算子を含むスキーマは、現在の &lt;code&gt;search_path&lt;/code&gt; （通常は &lt;code&gt;public&lt;/code&gt; ）になければなりません。そうでない場合は、代わりに通常の大文字と小文字を区別する &lt;code&gt;text&lt;/code&gt; 演算子が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a1b72adef26aba98ed5b9a11c3f8d9f992851abe" translate="yes" xml:space="preserve">
          <source>The schema definitions are not replicated, and the published tables must exist on the subscriber. Only regular tables may be the target of replication. For example, you can't replicate to a view.</source>
          <target state="translated">スキーマ定義はレプリケートされず、公開されたテーブルはサブスクライバ上に存在する必要があります。レギュラーテーブルのみがレプリケーションの対象となる場合があります。例えば、ビューにレプリケートすることはできません。</target>
        </trans-unit>
        <trans-unit id="459a237a85ce3b91cf8ef1e52361b976ab47c1f2" translate="yes" xml:space="preserve">
          <source>The schema in which the imported foreign tables will be created.</source>
          <target state="translated">インポートされた外部テーブルが作成されるスキーマ。</target>
        </trans-unit>
        <trans-unit id="01865c073aef636c813a71a650ffa6b695ee5717" translate="yes" xml:space="preserve">
          <source>The schemes shown here assume that the values of a row's key column(s) never change, or at least do not change enough to require it to move to another partition. An &lt;code&gt;UPDATE&lt;/code&gt; that attempts to do that will fail because of the &lt;code&gt;CHECK&lt;/code&gt; constraints. If you need to handle such cases, you can put suitable update triggers on the child tables, but it makes management of the structure much more complicated.</source>
          <target state="translated">ここに示すスキームは、行のキー列の値が決して変更されないか、少なくとも別のパーティションに移動する必要があるほど十分に変更されないことを前提としています。これを実行しようとする &lt;code&gt;UPDATE&lt;/code&gt; は、 &lt;code&gt;CHECK&lt;/code&gt; 制約のために失敗します。このようなケースを処理する必要がある場合は、子テーブルに適切な更新トリガーを配置できますが、構造の管理がはるかに複雑になります。</target>
        </trans-unit>
        <trans-unit id="ec9b55e40d83c1563492fc665bcf7be0f37fb815" translate="yes" xml:space="preserve">
          <source>The scripts can be run in any order and can be deleted once they have been run.</source>
          <target state="translated">スクリプトは任意の順番で実行することができ、一度実行したら削除することができます。</target>
        </trans-unit>
        <trans-unit id="5351b57ec30c67488f197082c674a1ac3697572e" translate="yes" xml:space="preserve">
          <source>The search filter to use when doing search+bind authentication. Occurrences of &lt;code&gt;$username&lt;/code&gt; will be replaced with the user name. This allows for more flexible search filters than &lt;code&gt;ldapsearchattribute&lt;/code&gt;.</source>
          <target state="translated">search + bind認証を行うときに使用する検索フィルター。 &lt;code&gt;$username&lt;/code&gt; 出現箇所はユーザー名に置き換えられます。これにより、 &lt;code&gt;ldapsearchattribute&lt;/code&gt; よりも柔軟な検索フィルターが可能になります。</target>
        </trans-unit>
        <trans-unit id="cc9e6cb9abd2e41c04bc258bc4b8a29867d6da64" translate="yes" xml:space="preserve">
          <source>The search path can be altered at run time. The command is:</source>
          <target state="translated">検索パスは実行時に変更することができます。コマンドは</target>
        </trans-unit>
        <trans-unit id="478354e0ca1e05b1455044d0dbe23d731c182378" translate="yes" xml:space="preserve">
          <source>The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write</source>
          <target state="translated">検索パスは、データ型名、関数名、演算子名についても、テーブル名と同じように動作します。データ型名と関数名は、テーブル名と全く同じ方法で修飾することができます。式の中に修飾された演算子名を記述する必要がある場合、特別な規定があります。</target>
        </trans-unit>
        <trans-unit id="90f585a0c61cda16f1f2f37af64c77ecb164389f" translate="yes" xml:space="preserve">
          <source>The second approach combines any authentication method for &lt;code&gt;hostssl&lt;/code&gt; entries with the verification of client certificates by setting the &lt;code&gt;clientcert&lt;/code&gt; authentication option to &lt;code&gt;verify-ca&lt;/code&gt; or &lt;code&gt;verify-full&lt;/code&gt;. The former option only enforces that the certificate is valid, while the latter also ensures that the &lt;code&gt;cn&lt;/code&gt; (Common Name) in the certificate matches the user name or an applicable mapping.</source>
          <target state="translated">2番目のアプローチでは、 &lt;code&gt;clientcert&lt;/code&gt; 認証オプションを &lt;code&gt;verify-ca&lt;/code&gt; または &lt;code&gt;verify-full&lt;/code&gt; に設定することにより、 &lt;code&gt;hostssl&lt;/code&gt; エントリの認証方法とクライアント証明書の検証を組み合わせます。前者のオプションは、証明書が有効であることのみを強制しますが、後者は、証明書の &lt;code&gt;cn&lt;/code&gt; （共通名）がユーザー名または適用可能なマッピングと一致することも保証します。</target>
        </trans-unit>
        <trans-unit id="4e7e9d77036e0c9575b0fa838e7bb55bd546fa0a" translate="yes" xml:space="preserve">
          <source>The second argument must be a well formed XML document. In particular, it must have a single root node element.</source>
          <target state="translated">第二引数は、よく形成されたXML文書でなければなりません。特に、それは単一のルートノード要素を持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="971af670862eab67d21e45dbeea285001e2a069e" translate="yes" xml:space="preserve">
          <source>The second example will store cities and their associated geographical location:</source>
          <target state="translated">2 番目の例では、都市とそれに関連付けられた地理的な位置を格納します。</target>
        </trans-unit>
        <trans-unit id="a8fdfc2d4d4050aa9351fe7e549967c0e1502821" translate="yes" xml:space="preserve">
          <source>The second form changes the name of the database. Only the database owner or a superuser can rename a database; non-superuser owners must also have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. The current database cannot be renamed. (Connect to a different database if you need to do that.)</source>
          <target state="translated">2番目の形式は、データベースの名前を変更します。データベースの名前を変更できるのは、データベースの所有者またはスーパーユーザーだけです。スーパーユーザー以外の所有者も &lt;code&gt;CREATEDB&lt;/code&gt; 特権を持っている必要があります。現在のデータベースの名前は変更できません。（必要な場合は、別のデータベースに接続してください。）</target>
        </trans-unit>
        <trans-unit id="5f97cd14403d43a28906f958a63aa9be74a831f3" translate="yes" xml:space="preserve">
          <source>The second form is a PostgreSQL extension. It fills the columns from the left with as many values as are given, and the rest will be defaulted.</source>
          <target state="translated">2つ目のフォームはPostgreSQLの拡張です。左から順に与えられた値の数だけ列を埋めていき、残りはデフォルトになります。</target>
        </trans-unit>
        <trans-unit id="001f55ae6b12f7691ee493402996a3cedd18d43d" translate="yes" xml:space="preserve">
          <source>The second form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates an enumerated (enum) type, as described in &lt;a href=&quot;datatype-enum&quot;&gt;Section 8.7&lt;/a&gt;. Enum types take a list of quoted labels, each of which must be less than &lt;code&gt;NAMEDATALEN&lt;/code&gt; bytes long (64 bytes in a standard PostgreSQL build). (It is possible to create an enumerated type with zero labels, but such a type cannot be used to hold values before at least one label is added using &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;datatype-enum&quot;&gt;セクション8.7で&lt;/a&gt;説明されているように、 &lt;code&gt;CREATE TYPE&lt;/code&gt; の2番目の形式は、列挙（enum）タイプを作成します。列挙型は引用符で囲まれたラベルのリストを &lt;code&gt;NAMEDATALEN&lt;/code&gt; ます。それぞれのラベルはNAMEDATALENバイト長（標準のPostgreSQLビルドでは64バイト）未満でなければなりません。（ラベルなしの列挙型を作成することは可能ですが、&lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;を使用して少なくとも1つのラベルが追加されるまで、そのような型を使用して値を保持することはできません。）</target>
        </trans-unit>
        <trans-unit id="9646c72014e3dc0cdbc889805cc625cb2e00d4a4" translate="yes" xml:space="preserve">
          <source>The second implementation of the rule system is a technique called &lt;em&gt;query rewriting&lt;/em&gt;. The &lt;em&gt;rewrite system&lt;/em&gt; is a module that exists between the &lt;em&gt;parser stage&lt;/em&gt; and the &lt;em&gt;planner/optimizer&lt;/em&gt;. This technique is still implemented.</source>
          <target state="translated">ルールシステムの2番目の実装は、&lt;em&gt;クエリ書き換え&lt;/em&gt;と呼ばれる手法です。&lt;em&gt;書き換えシステムは、&lt;/em&gt;間に存在するモジュールである&lt;em&gt;パーサステージ&lt;/em&gt;と&lt;em&gt;プランナ/オプティマイザ&lt;/em&gt;。この手法はまだ実装されています。</target>
        </trans-unit>
        <trans-unit id="b82fe6094f17ae862d5ae179aa9cdfdad11af121" translate="yes" xml:space="preserve">
          <source>The second line is the command that would be invoked in restart mode.</source>
          <target state="translated">2行目は、再起動モードで呼び出されるコマンドです。</target>
        </trans-unit>
        <trans-unit id="5e54d9500bd7199e013e0c26f4d1118e580aabf7" translate="yes" xml:space="preserve">
          <source>The second part of the module relies on representing Earth locations as values of type &lt;code&gt;point&lt;/code&gt;, in which the first component is taken to represent longitude in degrees, and the second component is taken to represent latitude in degrees. Points are taken as (longitude, latitude) and not vice versa because longitude is closer to the intuitive idea of x-axis and latitude to y-axis.</source>
          <target state="translated">モジュールの2番目の部分は、地球の位置を &lt;code&gt;point&lt;/code&gt; 型の値として表すことに依存しています。最初のコンポーネントは経度を度で表し、2番目のコンポーネントは緯度を度で表します。経度はx軸、緯度はy軸の直感的な考え方に近いため、ポイントは（経度、緯度）として解釈され、その逆は解釈されません。</target>
        </trans-unit>
        <trans-unit id="07476921b1bd87798420cb9dffdda71ef3f07ce3" translate="yes" xml:space="preserve">
          <source>The second variant changes the name of the role. Database superusers can rename any role. Roles having &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can rename non-superuser roles. The current session user cannot be renamed. (Connect as a different user if you need to do that.) Because &lt;code&gt;MD5&lt;/code&gt;-encrypted passwords use the role name as cryptographic salt, renaming a role clears its password if the password is &lt;code&gt;MD5&lt;/code&gt;-encrypted.</source>
          <target state="translated">2番目のバリアントは、役割の名前を変更します。データベースのスーパーユーザーは、任意のロールの名前を変更できます。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、スーパーユーザー以外のロールの名前を変更できます。現在のセッションユーザーの名前は変更できません。（接続別のユーザーとして、あなたがそれを行う必要があります。）ので &lt;code&gt;MD5&lt;/code&gt; は、パスワードが暗号化塩としてロール名を使用-encryptedパスワードがある場合は、ロール名を変更するとパスワードはクリア &lt;code&gt;MD5&lt;/code&gt; が -encrypted。</target>
        </trans-unit>
        <trans-unit id="cfe4da30b9c6bff8e95fbde2fcc03500be370613" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts (0 - 59&lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;)</source>
          <target state="translated">小数部を含む秒フィールド（0-59 &lt;a href=&quot;#ftn.id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;&lt;sup id=&quot;id-1.5.8.14.12.5.11.16.2.1.1&quot;&gt;[7]&lt;/sup&gt;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="663b58f51194288bd80b435fbc5e648d8e6f6580" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds</source>
          <target state="translated">秒フィールド(端数部分を含む)に1,000,000を乗じたもの。</target>
        </trans-unit>
        <trans-unit id="2d44e15dba826649cac46abaee1bc5cb23f259a3" translate="yes" xml:space="preserve">
          <source>The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds.</source>
          <target state="translated">秒フィールド(端数部分を含む)に1000を掛けたもの。これには完全な秒数が含まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7bfc04444cf0b5a28dd815138a4bbbe840cd72f0" translate="yes" xml:space="preserve">
          <source>The security label applied to this object.</source>
          <target state="translated">このオブジェクトに適用されるセキュリティラベル。</target>
        </trans-unit>
        <trans-unit id="b47689b397bbce6da7cf131cc329c56ad0b8b0d2" translate="yes" xml:space="preserve">
          <source>The security model of SELinux describes all the access control rules as relationships between a subject entity (typically, a client of the database) and an object entity (such as a database object), each of which is identified by a security label. If access to an unlabeled object is attempted, the object is treated as if it were assigned the label &lt;code&gt;unlabeled_t&lt;/code&gt;.</source>
          <target state="translated">SELinuxのセキュリティモデルは、すべてのアクセス制御ルールをサブジェクトエンティティ（通常はデータベースのクライアント）とオブジェクトエンティティ（データベースオブジェクトなど）の間の関係として記述します。各エンティティはセキュリティラベルによって識別されます。ラベルのないオブジェクトにアクセスしようとすると、オブジェクトはラベル &lt;code&gt;unlabeled_t&lt;/code&gt; が割り当てられているかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="230231accae0954bfa7e47d9f5e404dcd469b2c5" translate="yes" xml:space="preserve">
          <source>The security policy of SELinux also has rules to control whether or not particular accesses are logged. By default, access violations are logged, but allowed accesses are not.</source>
          <target state="translated">SELinux のセキュリティポリシーには、特定のアクセスがログに記録されるかどうかを制御するルールもあります。デフォルトでは、アクセス違反は記録されますが、許可されたアクセスは記録されません。</target>
        </trans-unit>
        <trans-unit id="dbcd4d113ca55d30a1adafc062bb48c13c7f8e98" translate="yes" xml:space="preserve">
          <source>The seed can also be set by invoking the function &lt;code&gt;setseed&lt;/code&gt;:</source>
          <target state="translated">シードは、関数 &lt;code&gt;setseed&lt;/code&gt; を呼び出して設定することもできます。</target>
        </trans-unit>
        <trans-unit id="1c3344ee525a48fbaf283fc79a5b884444be3dcb" translate="yes" xml:space="preserve">
          <source>The segment [a, b] contains the segment [c, d], that is, a &amp;lt;= c and b &amp;gt;= d.</source>
          <target state="translated">セグメント[a、b]には、セグメント[c、d]が含まれています。つまり、a &amp;lt;= cおよびb&amp;gt; = dです。</target>
        </trans-unit>
        <trans-unit id="0167ae8a0ef2744b5f058f32dbb8df42b67bb33e" translate="yes" xml:space="preserve">
          <source>The segment [a, b] is contained in [c, d], that is, a &amp;gt;= c and b &amp;lt;= d.</source>
          <target state="translated">セグメント[a、b]は[c、d]に含まれます。つまり、a&amp;gt; = cおよびb &amp;lt;= dです。</target>
        </trans-unit>
        <trans-unit id="2f9dfe875337796db870c4bb2a262e2bbef3945b" translate="yes" xml:space="preserve">
          <source>The segments [a, b] and [c, d] overlap.</source>
          <target state="translated">セグメント[a,b]と[c,d]が重なっている。</target>
        </trans-unit>
        <trans-unit id="b10711fce98e1c5fe5a4897a9961ed9ae2f37aef" translate="yes" xml:space="preserve">
          <source>The semantics of SQL/JSON path predicates and operators generally follow SQL. At the same time, to provide a most natural way of working with JSON data, SQL/JSON path syntax uses some of the JavaScript conventions:</source>
          <target state="translated">SQL/JSONパス述語と演算子のセマンティクスは一般的にSQLに従います。同時に、JSONデータを最も自然に扱う方法を提供するために、SQL/JSONパス構文はJavaScriptの規約の一部を使用しています。</target>
        </trans-unit>
        <trans-unit id="ca2f632c9b81511535163336539f86f918d83e9e" translate="yes" xml:space="preserve">
          <source>The semicolon (&lt;code&gt;;&lt;/code&gt;) terminates an SQL command. It cannot appear anywhere within a command, except within a string constant or quoted identifier.</source>
          <target state="translated">セミコロン（ &lt;code&gt;;&lt;/code&gt; ）は、SQLコマンドを終了します。文字列定数または引用符で囲まれた識別子内を除き、コマンド内のどこにも表示できません。</target>
        </trans-unit>
        <trans-unit id="7c68a3eca090a3377bf1a78fea499d56ec605109" translate="yes" xml:space="preserve">
          <source>The sequence created for a &lt;code&gt;serial&lt;/code&gt; column is automatically dropped when the owning column is dropped. You can drop the sequence without dropping the column, but this will force removal of the column default expression.</source>
          <target state="translated">&lt;code&gt;serial&lt;/code&gt; 列用に作成されたシーケンスは、所有する列が削除されると自動的に削除されます。列を削除せずにシーケンスを削除できますが、これにより列のデフォルト式が強制的に削除されます。</target>
        </trans-unit>
        <trans-unit id="b5a5d93057bd5edff8daf4648c4c935388f9e10e" translate="yes" xml:space="preserve">
          <source>The sequence name can be schema-qualified if necessary:</source>
          <target state="translated">シーケンス名は必要に応じてスキーマ修飾することができます。</target>
        </trans-unit>
        <trans-unit id="c6a359aa04dbc4531fddf8d09e8fef46d55e14f6" translate="yes" xml:space="preserve">
          <source>The sequence to be operated on by a sequence function is specified by a &lt;code&gt;regclass&lt;/code&gt; argument, which is simply the OID of the sequence in the &lt;code&gt;pg_class&lt;/code&gt; system catalog. You do not have to look up the OID by hand, however, since the &lt;code&gt;regclass&lt;/code&gt; data type's input converter will do the work for you. Just write the sequence name enclosed in single quotes so that it looks like a literal constant. For compatibility with the handling of ordinary SQL names, the string will be converted to lower case unless it contains double quotes around the sequence name. Thus:</source>
          <target state="translated">シーケンス関数によって操作されるシーケンスは、 &lt;code&gt;regclass&lt;/code&gt; 引数によって指定されます。これは、 &lt;code&gt;pg_class&lt;/code&gt; システムカタログ内のシーケンスのOIDです。ただし、 &lt;code&gt;regclass&lt;/code&gt; データ型の入力コンバーターが機能するため、OIDを手動で検索する必要はありません。リテラル定数のように見えるように、単一引用符で囲まれたシーケンス名を記述するだけです。通常のSQL名の処理との互換性のために、シーケンス名の前後に二重引用符が含まれていない限り、文字列は小文字に変換されます。したがって：</target>
        </trans-unit>
        <trans-unit id="ea7d18fda0e93393ee728bac05185520e2d92f5c" translate="yes" xml:space="preserve">
          <source>The server log might contain more information about an authentication failure than is reported to the client. If you are confused about the reason for a failure, check the server log.</source>
          <target state="translated">サーバーログには、認証の失敗に関する情報が、クライアントに報告された情報よりも多く含まれている可能性があります。失敗の理由がわからない場合は、サーバログを確認してください。</target>
        </trans-unit>
        <trans-unit id="4ca1254319f0477050eedb4dcb243dbc28231770" translate="yes" xml:space="preserve">
          <source>The server name must be unique within the database.</source>
          <target state="translated">サーバー名はデータベース内で一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ac56c0453261e732a23fed94e0a24c8f95cc0488" translate="yes" xml:space="preserve">
          <source>The server reads these files at server start and whenever the server configuration is reloaded. On Windows systems, they are also re-read whenever a new backend process is spawned for a new client connection.</source>
          <target state="translated">サーバは、サーバの起動時やサーバ設定のリロード時にこれらのファイルを読み込みます。Windows システムでは、新しいクライアント接続のために新しいバックエンドプロセスが生成されるたびに、これらのファイルが再読まれます。</target>
        </trans-unit>
        <trans-unit id="d0d31219164213fd90b64aadc8577b6089ce02b9" translate="yes" xml:space="preserve">
          <source>The server sends an AuthenticationSASL message. It includes a list of SASL authentication mechanisms that the server can accept. This will be &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; and &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; if the server is built with SSL support, or else just the latter.</source>
          <target state="translated">サーバーはAuthenticationSASLメッセージを送信します。これには、サーバーが受け入れることができるSASL認証メカニズムのリストが含まれています。これは次のようになります &lt;code&gt;SCRAM-SHA-256-PLUS&lt;/code&gt; と &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 、サーバーがSSLサポート、または他のちょうど後者で構築されている場合。</target>
        </trans-unit>
        <trans-unit id="b019b1a1b7d85dded861255aa6e59d8f9921d05a" translate="yes" xml:space="preserve">
          <source>The server will occasionally request the client to perform a flush and report the flush position to the server. This setting is in addition to that, to perform flushes more frequently.</source>
          <target state="translated">サーバーは、時々クライアントにフラッシュの実行を要求し、フラッシュの位置をサーバーに報告します。この設定はそれに加えて、より頻繁にフラッシュを実行するためのものです。</target>
        </trans-unit>
        <trans-unit id="7b8da77a2b390601e3adff073821408d13cdbea6" translate="yes" xml:space="preserve">
          <source>The server's checkpointer process automatically performs a checkpoint every so often. A checkpoint is begun every &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt; seconds, or if &lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_size&lt;/a&gt; is about to be exceeded, whichever comes first. The default settings are 5 minutes and 1 GB, respectively. If no WAL has been written since the previous checkpoint, new checkpoints will be skipped even if &lt;code&gt;checkpoint_timeout&lt;/code&gt; has passed. (If WAL archiving is being used and you want to put a lower limit on how often files are archived in order to bound potential data loss, you should adjust the &lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt; parameter rather than the checkpoint parameters.) It is also possible to force a checkpoint by using the SQL command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">サーバーのチェックポインタープロセスは、チェックポイントを時々自動的に実行します。チェックポイントは、&lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-TIMEOUT&quot;&gt;checkpoint_timeout&lt;/a&gt;秒ごと、または&lt;a href=&quot;runtime-config-wal#GUC-MAX-WAL-SIZE&quot;&gt;max_wal_sizeを超えよう&lt;/a&gt;としている場合のいずれか早い方で開始されます。デフォルト設定は、それぞれ5分と1 GBです。前のチェックポイント以降にWALが書き込まれていない場合、 &lt;code&gt;checkpoint_timeout&lt;/code&gt; が経過しても新しいチェックポイントはスキップされます。 （WALアーカイブが使用されており、潜在的なデータ損失を制限するためにファイルをアーカイブする頻度に下限を設定する場合は、チェックポイントパラメーターではなく、&lt;a href=&quot;runtime-config-wal#GUC-ARCHIVE-TIMEOUT&quot;&gt;archive_timeout&lt;/a&gt;パラメーターを調整する必要があります。）チェックポイントを強制することもできます。 SQLコマンド &lt;code&gt;CHECKPOINT&lt;/code&gt; を使用する。</target>
        </trans-unit>
        <trans-unit id="c205218c3546e4b301b493a03547b46277844636" translate="yes" xml:space="preserve">
          <source>The server's version number as a string, for example &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt; or &lt;code&gt;11beta1&lt;/code&gt;, and in numeric form, for example &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;. These are set every time you connect to a database (including program start-up), but can be changed or unset.</source>
          <target state="translated">例えば、文字列としてサーバのバージョン番号、 &lt;code&gt;9.6.2&lt;/code&gt; 、 &lt;code&gt;10.1&lt;/code&gt; または &lt;code&gt;11beta1&lt;/code&gt; 、および数値形式で、例えば &lt;code&gt;90602&lt;/code&gt; または &lt;code&gt;100001&lt;/code&gt; 。これらは、データベース（プログラムの起動を含む）に接続するたびに設定されますが、変更または設定解除できます。</target>
        </trans-unit>
        <trans-unit id="5a84cc79fdbb16a887f43ceaad26726c6755ffe1" translate="yes" xml:space="preserve">
          <source>The session default transaction modes can also be set by setting the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;, and &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrable&lt;/a&gt;. (In fact &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; is just a verbose equivalent for setting these variables with &lt;code&gt;SET&lt;/code&gt;.) This means the defaults can be set in the configuration file, via &lt;code&gt;ALTER DATABASE&lt;/code&gt;, etc. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information.</source>
          <target state="translated">セッションのデフォルトのトランザクションモードは、構成パラメーター&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-ISOLATION&quot;&gt;default_transaction_isolation&lt;/a&gt;、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-READ-ONLY&quot;&gt;default_transaction_read_only&lt;/a&gt;、および&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TRANSACTION-DEFERRABLE&quot;&gt;default_transaction_deferrableを&lt;/a&gt;設定することによっても設定できます。（実際、 &lt;code&gt;SET SESSION CHARACTERISTICS&lt;/code&gt; は、これらの変数を &lt;code&gt;SET&lt;/code&gt; で設定するのに相当する冗長です。）これは、 &lt;code&gt;ALTER DATABASE&lt;/code&gt; などを使用して、構成ファイルでデフォルトを設定できることを意味します。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6723e0bdad2077d09fd447f64653c3402fb21a9f" translate="yes" xml:space="preserve">
          <source>The session user identifier can be changed only if the initial session user (the &lt;em&gt;authenticated user&lt;/em&gt;) had the superuser privilege. Otherwise, the command is accepted only if it specifies the authenticated user name.</source>
          <target state="translated">セッションユーザー識別子は、最初のセッションユーザー（&lt;em&gt;認証されたユーザー&lt;/em&gt;）がスーパーユーザー特権を持っている場合にのみ変更できます。それ以外の場合、コマンドは、認証されたユーザー名を指定する場合にのみ受け入れられます。</target>
        </trans-unit>
        <trans-unit id="715d310203fd1767744b0e3abc3cbaadfd49947d" translate="yes" xml:space="preserve">
          <source>The session user identifier is initially set to be the (possibly authenticated) user name provided by the client. The current user identifier is normally equal to the session user identifier, but might change temporarily in the context of &lt;code&gt;SECURITY DEFINER&lt;/code&gt; functions and similar mechanisms; it can also be changed by &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;. The current user identifier is relevant for permission checking.</source>
          <target state="translated">セッションユーザー識別子は、最初はクライアントから提供された（認証されている可能性がある）ユーザー名に設定されています。現在のユーザーIDは通常、セッションユーザーID と同じですが、 &lt;code&gt;SECURITY DEFINER&lt;/code&gt; 関数および同様のメカニズムのコンテキストで一時的に変更される可能性があります。&lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt;で変更することもできます。現在のユーザー識別子は、権限チェックに関連しています。</target>
        </trans-unit>
        <trans-unit id="94dcf85932be3ca953bb5dbee89cd4f7713067fb" translate="yes" xml:space="preserve">
          <source>The set of database roles a given client connection can connect as is determined by the client authentication setup, as explained in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;. (Thus, a client is not limited to connect as the role matching its operating system user, just as a person's login name need not match his or her real name.) Since the role identity determines the set of privileges available to a connected client, it is important to carefully configure privileges when setting up a multiuser environment.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章で&lt;/a&gt;説明されているように、特定のクライアント接続が接続できるデータベースロールのセットは、クライアント認証設定によって決定されます。（したがって、ユーザーのログイン名が本名と一致する必要がないのと同じように、クライアントはオペレーティングシステムユーザーと一致するロールとして接続することに限定されません。）ロールIDは接続されたクライアントが利用できる特権のセットを決定するため、マルチユーザー環境をセットアップするときは、特権を慎重に構成することが重要です。</target>
        </trans-unit>
        <trans-unit id="d9e7e3efb30616b981cfefa41268aa6951e3d5f2" translate="yes" xml:space="preserve">
          <source>The setting &lt;code&gt;RemoveIPC&lt;/code&gt; in &lt;code&gt;logind.conf&lt;/code&gt; controls whether IPC objects are removed when a user fully logs out. System users are exempt. This setting defaults to on in stock systemd, but some operating system distributions default it to off.</source>
          <target state="translated">設定 &lt;code&gt;RemoveIPC&lt;/code&gt; で &lt;code&gt;logind.conf&lt;/code&gt; のユーザーが完全にログアウトするIPCオブジェクトが削除されているかどうかを制御します。システムユーザーは免除されます。この設定はデフォルトで在庫ありのsystemdですが、一部のオペレーティングシステムのディストリビューションではデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="64eba0ac674f39ed469aa292d2c2a8445eebc9f9" translate="yes" xml:space="preserve">
          <source>The setting of some parameters on the standby will need reconfiguration if they have been changed on the primary. For these parameters, the value on the standby must be equal to or greater than the value on the primary. Therefore, if you want to increase these values, you should do so on all standby servers first, before applying the changes to the primary server. Conversely, if you want to decrease these values, you should do so on the primary server first, before applying the changes to all standby servers. If these parameters are not set high enough then the standby will refuse to start. Higher values can then be supplied and the server restarted to begin recovery again. These parameters are:</source>
          <target state="translated">待機中の一部のパラメータをプライマリで変更した場合、再設定が必要になります。これらのパラメータについては、待機側の値がプライマリ側の値と同じかそれ以上である必要があります。したがって、これらの値を増加させたい場合は、プライマリサーバに変更を適用する前に、まずすべてのスタンバイサーバで変更を行う必要があります。逆に、これらの値を小さくしたい場合は、すべての待機サーバに変更を適用する前に、まずプライマリ サーバで変更を行う必要があります。これらのパラメータが十分に高く設定されていない場合、待機サーバは起動を拒否します。この場合は、より高い値を指定してサーバを再起動し、復旧を再開することができます。これらのパラメータは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8f66060d984a3d43717aaa1c8e7136685e2e6d1f" translate="yes" xml:space="preserve">
          <source>The shared lock table tracks locks on &lt;code&gt;max_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has historically proven sufficient, but you might need to raise this value if you have queries that touch many different tables in a single transaction, e.g. query of a parent table with many children. This parameter can only be set at server start.</source>
          <target state="translated">共有ロックテーブルは、 &lt;code&gt;max_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）オブジェクト（たとえば、テーブル）のロックを追跡します。したがって、一度にロックできるオブジェクトはこれだけです。このパラメーターは、各トランザクションに割り当てられるオブジェクトロックの平均数を制御します。すべてのトランザクションのロックがロックテーブルに収まる限り、個々のトランザクションはより多くのオブジェクトをロックできます。これは&lt;em&gt;ありません&lt;/em&gt;ロックできる行の数。その値は無制限です。デフォルトの64で十分であることが歴史的に証明されていますが、単一のトランザクションで多くの異なるテーブルにアクセスするクエリ（たとえば、多くの子を持つ親テーブルのクエリ）がある場合は、この値を上げる必要があるかもしれません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ed8d27015cd393d0e4d2ed8b1d7004db3e56b61f" translate="yes" xml:space="preserve">
          <source>The shared memory size settings can be changed via the &lt;code&gt;sysctl&lt;/code&gt; interface. For example, to allow 16 GB:</source>
          <target state="translated">共有メモリサイズの設定は、 &lt;code&gt;sysctl&lt;/code&gt; インターフェースを介して変更できます。たとえば、16 GBを許可するには：</target>
        </trans-unit>
        <trans-unit id="068843c57f60fb86ac3cb60c430b5300612b2f9d" translate="yes" xml:space="preserve">
          <source>The shared predicate lock table tracks locks on &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; * (&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;) objects (e.g., tables); hence, no more than this many distinct objects can be locked at any one time. This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. This is &lt;em&gt;not&lt;/em&gt; the number of rows that can be locked; that value is unlimited. The default, 64, has generally been sufficient in testing, but you might need to raise this value if you have clients that touch many different tables in a single serializable transaction. This parameter can only be set at server start.</source>
          <target state="translated">共有述語ロックテーブルは、 &lt;code&gt;max_pred_locks_per_transaction&lt;/code&gt; *（&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; + &lt;a href=&quot;runtime-config-resource#GUC-MAX-PREPARED-TRANSACTIONS&quot;&gt;max_prepared_transactions&lt;/a&gt;）オブジェクト（テーブルなど）のロックを追跡します。したがって、一度にロックできるオブジェクトはこれだけです。このパラメーターは、各トランザクションに割り当てられるオブジェクトロックの平均数を制御します。すべてのトランザクションのロックがロックテーブルに収まる限り、個々のトランザクションはより多くのオブジェクトをロックできます。これは、ロックできる行数ではあり&lt;em&gt;ません&lt;/em&gt;。その値は無制限です。テストでは通常、デフォルトの64で十分ですが、1つのシリアル化可能なトランザクションで多くの異なるテーブルにアクセスするクライアントがある場合は、この値を上げる必要があるかもしれません。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="ca5a87d53a78cc8149d60b5d1c35e814aa59a259" translate="yes" xml:space="preserve">
          <source>The shared secrets used when talking securely to the RADIUS server. This must have exactly the same value on the PostgreSQL and RADIUS servers. It is recommended that this be a string of at least 16 characters. This parameter is required.</source>
          <target state="translated">RADIUSサーバと安全に通信する際に使用する共有秘密。これはPostgreSQLサーバとRADIUSサーバで全く同じ値を持つ必要があります。これは少なくとも16文字の文字列にすることを推奨します。このパラメータは必須です。</target>
        </trans-unit>
        <trans-unit id="58e38019afd1ad1853e1d01481b88d4b91b8d05a" translate="yes" xml:space="preserve">
          <source>The sharp (&lt;code&gt;#&lt;/code&gt;) sign is a comment delimiter. It may appear at any position in a line. The rest of the line will be skipped.</source>
          <target state="translated">シャープ（ &lt;code&gt;#&lt;/code&gt; ）記号はコメント区切り文字です。行の任意の位置に表示されます。残りの行はスキップされます。</target>
        </trans-unit>
        <trans-unit id="67cfcf8acce2ecc45db3a0f17045ee10928b08a1" translate="yes" xml:space="preserve">
          <source>The short procedure for configuring a standby server using this alternative method is as follows. For full details of each step, refer to previous sections as noted.</source>
          <target state="translated">この代替方法を用いて待機サーバを設定する場合の簡単な手順は以下の通りです。各ステップの詳細については、前述の通り前のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="968f59638db3803d09dafd7e362f7206431f6346" translate="yes" xml:space="preserve">
          <source>The simple comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; compare the lower bounds first, and only if those are equal, compare the upper bounds. These comparisons are not usually very useful for ranges, but are provided to allow B-tree indexes to be constructed on ranges.</source>
          <target state="translated">単純な比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; は、最初に下限を比較し、それらが等しい場合にのみ、上限を比較します。これらの比較は通常、範囲にはあまり役立ちませんが、Bツリーインデックスを範囲に基づいて構築できるようにするために提供されています。</target>
        </trans-unit>
        <trans-unit id="8ea620de73d7bb2e034a3dc8ebd2dd0118f06f72" translate="yes" xml:space="preserve">
          <source>The simplest kind of extended statistics tracks &lt;em&gt;functional dependencies&lt;/em&gt;, a concept used in definitions of database normal forms. We say that column &lt;code&gt;b&lt;/code&gt; is functionally dependent on column &lt;code&gt;a&lt;/code&gt; if knowledge of the value of &lt;code&gt;a&lt;/code&gt; is sufficient to determine the value of &lt;code&gt;b&lt;/code&gt;, that is there are no two rows having the same value of &lt;code&gt;a&lt;/code&gt; but different values of &lt;code&gt;b&lt;/code&gt;. In a fully normalized database, functional dependencies should exist only on primary keys and superkeys. However, in practice many data sets are not fully normalized for various reasons; intentional denormalization for performance reasons is a common example. Even in a fully normalized database, there may be partial correlation between some columns, which can be expressed as partial functional dependency.</source>
          <target state="translated">最も単純な種類の拡張統計は、&lt;em&gt;機能の依存関係を&lt;/em&gt;追跡し&lt;em&gt;ます&lt;/em&gt;。これは、データベースの正規形の定義で使用される概念です。我々は、その列言う &lt;code&gt;b&lt;/code&gt; 列に機能的に依存している &lt;code&gt;a&lt;/code&gt; の値を知っている場合の値を決定するのに十分である &lt;code&gt;b&lt;/code&gt; 同一の値を有するいかなる2つの列が存在しないとすると、の異なる値 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 。完全に正規化されたデータベースでは、機能の依存関係は主キーとスーパーキーにのみ存在する必要があります。ただし、実際には、多くのデータセットがさまざまな理由で完全に正規化されていません。パフォーマンス上の理由による意図的な非正規化が一般的な例です。完全に正規化されたデータベースでも、一部の列間に部分的な相関がある場合があり、部分的な機能依存として表すことができます。</target>
        </trans-unit>
        <trans-unit id="218e0e862d91c332c13bb63fca705baa68ee5396" translate="yes" xml:space="preserve">
          <source>The simplest kind of select list is &lt;code&gt;*&lt;/code&gt; which emits all columns that the table expression produces. Otherwise, a select list is a comma-separated list of value expressions (as defined in &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;). For instance, it could be a list of column names:</source>
          <target state="translated">最も単純な種類の選択リストは &lt;code&gt;*&lt;/code&gt; で、テーブル式が生成するすべての列を出力します。それ以外の場合、選択リストは値式のコンマ区切りのリストです（&lt;a href=&quot;sql-expressions&quot;&gt;セクション4.2で&lt;/a&gt;定義）。たとえば、列名のリストである可能性があります。</target>
        </trans-unit>
        <trans-unit id="95ff410c0d68dcd6b5d1a3a14a5e05f946ef4e40" translate="yes" xml:space="preserve">
          <source>The simplest option for removing old data is to drop the partition that is no longer necessary:</source>
          <target state="translated">古いデータを削除する最も簡単な方法は、不要になったパーティションを落とすことです。</target>
        </trans-unit>
        <trans-unit id="9d938ffa1d7d07edb850b5b705fb8034d9885325" translate="yes" xml:space="preserve">
          <source>The size of the block range is determined at index creation time by the &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for &lt;code&gt;pages_per_range&lt;/code&gt;. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan.</source>
          <target state="translated">ブロック範囲のサイズは、インデックスの作成時に &lt;code&gt;pages_per_range&lt;/code&gt; ストレージパラメータによって決定されます。インデックスエントリの数は、ページ単位のリレーションのサイズを、 &lt;code&gt;pages_per_range&lt;/code&gt; で選択した値で割った値に等しくなります。したがって、数値が小さいほど、インデックスは大きくなります（より多くのインデックスエントリを格納する必要があるため）。同時に、格納されるサマリーデータはより正確になり、インデックススキャン中により多くのデータブロックをスキップできます。</target>
        </trans-unit>
        <trans-unit id="b6017b9e9e841e1ed3391e353ec7b6f77818cd5d" translate="yes" xml:space="preserve">
          <source>The slice syntaxes with omitted &lt;code&gt;lower-bound&lt;/code&gt; and/or &lt;code&gt;upper-bound&lt;/code&gt; can be used too, but only when updating an array value that is not NULL or zero-dimensional (otherwise, there is no existing subscript limit to substitute).</source>
          <target state="translated">&lt;code&gt;lower-bound&lt;/code&gt; または &lt;code&gt;upper-bound&lt;/code&gt; 、あるいはその両方を省略したスライス構文も使用できますが、これは、NULLまたはゼロ次元ではない配列値を更新する場合に限られます（それ以外の場合、既存の添え字の制限はありません）。</target>
        </trans-unit>
        <trans-unit id="b0a06932e4c9d25d4fab3d4aa77750dbf6cafc0f" translate="yes" xml:space="preserve">
          <source>The slot type - &lt;code&gt;physical&lt;/code&gt; or &lt;code&gt;logical&lt;/code&gt;</source>
          <target state="translated">スロットタイプ- &lt;code&gt;physical&lt;/code&gt; または &lt;code&gt;logical&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4042361f65f02965ea45d409682bd67eb2ab934d" translate="yes" xml:space="preserve">
          <source>The sole disadvantage of increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; (and &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; along with it) is that the &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; subdirectories of the database cluster will take more space, because it must store the commit status and (if &lt;code&gt;track_commit_timestamp&lt;/code&gt; is enabled) timestamp of all transactions back to the &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; horizon. The commit status uses two bits per transaction, so if &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; is set to its maximum allowed value of two billion, &lt;code&gt;pg_xact&lt;/code&gt; can be expected to grow to about half a gigabyte and &lt;code&gt;pg_commit_ts&lt;/code&gt; to about 20GB. If this is trivial compared to your total database size, setting &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; to its maximum allowed value is recommended. Otherwise, set it depending on what you are willing to allow for &lt;code&gt;pg_xact&lt;/code&gt; and &lt;code&gt;pg_commit_ts&lt;/code&gt; storage. (The default, 200 million transactions, translates to about 50MB of &lt;code&gt;pg_xact&lt;/code&gt; storage and about 2GB of &lt;code&gt;pg_commit_ts&lt;/code&gt; storage.)</source>
          <target state="translated">&lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; （および &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; に伴うvacuum_freeze_table_age）を増やすことの唯一の欠点は、データベースクラスターの &lt;code&gt;pg_xact&lt;/code&gt; および &lt;code&gt;pg_commit_ts&lt;/code&gt; サブディレクトリは、コミットステータスと（ &lt;code&gt;track_commit_timestamp&lt;/code&gt; が有効な場合）すべてのトランザクションのタイムスタンプを &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 地平線。ステータスがあればそう、トランザクション当たり2ビットを使用してコミット &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 20億のその最大許容値に設定されている、 &lt;code&gt;pg_xact&lt;/code&gt; は半分ギガバイト程度に成長すると予想することができ &lt;code&gt;pg_commit_ts&lt;/code&gt; 約20GBまで。これがデータベースの合計サイズと比較して &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; 場合は、autovacuum_freeze_max_ageを最大許容値に設定することをお勧めします。それ以外の場合は、 &lt;code&gt;pg_xact&lt;/code&gt; と &lt;code&gt;pg_commit_ts&lt;/code&gt; のストレージに許可するものに応じて設定します。（デフォルトの2億トランザクションは、約50MBの &lt;code&gt;pg_xact&lt;/code&gt; ストレージと約2GBの &lt;code&gt;pg_commit_ts&lt;/code&gt; ストレージに変換されます。）</target>
        </trans-unit>
        <trans-unit id="420d354e00f2d98f43f69fb5c85b3c9d2f0a5c6c" translate="yes" xml:space="preserve">
          <source>The sort expression(s) can be any expression that would be valid in the query's select list. An example is:</source>
          <target state="translated">ソート式には、クエリのセレクトリストで有効な式を指定することができます。例は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="af64fa9d73d05dafcf40b04a10bc43a2c675e4b9" translate="yes" xml:space="preserve">
          <source>The sort position of this enum value within its enum type</source>
          <target state="translated">この列挙値の列挙型内でのソート位置</target>
        </trans-unit>
        <trans-unit id="267381ff52d7207cad90e1b1efb3d2ae56d6e149" translate="yes" xml:space="preserve">
          <source>The source directory &lt;code&gt;contrib/intarray/bench&lt;/code&gt; contains a benchmark test suite, which can be run against an installed PostgreSQL server. (It also requires &lt;code&gt;DBD::Pg&lt;/code&gt; to be installed.) To run:</source>
          <target state="translated">ソースディレクトリ &lt;code&gt;contrib/intarray/bench&lt;/code&gt; には、インストールされているPostgreSQLサーバーに対して実行できるベンチマークテストスイートが含まれています。（ &lt;code&gt;DBD::Pg&lt;/code&gt; インストールも必要です。）実行するには：</target>
        </trans-unit>
        <trans-unit id="f4b684dc4cf3d0e7f8017a75669ef677ed19f660" translate="yes" xml:space="preserve">
          <source>The source encoding name.</source>
          <target state="translated">ソースのエンコーディング名。</target>
        </trans-unit>
        <trans-unit id="5b4632e063d85e50c766912ad7e51e33ef8bf318" translate="yes" xml:space="preserve">
          <source>The special &amp;ldquo;role&amp;rdquo; name &lt;code&gt;PUBLIC&lt;/code&gt; can be used to grant a privilege to every role on the system. Also, &amp;ldquo;group&amp;rdquo; roles can be set up to help manage privileges when there are many users of a database &amp;mdash; for details see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt;.</source>
          <target state="translated">特殊な「ロール」名 &lt;code&gt;PUBLIC&lt;/code&gt; を使用して、システム上のすべてのロールに特権を付与できます。また、「グループ」ロールを設定して、データベースのユーザーが多い場合に権限を管理できるようにすることができます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;第21章&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d534e247b3040487a992ce1f01908ab3c5c62964" translate="yes" xml:space="preserve">
          <source>The special entry &lt;code&gt;*&lt;/code&gt; matches any standby name.</source>
          <target state="translated">特別なエントリ &lt;code&gt;*&lt;/code&gt; は、スタンバイ名に一致します。</target>
        </trans-unit>
        <trans-unit id="31bc549a6a2aaa2d8b0391bf2c83e80b6eb59358" translate="yes" xml:space="preserve">
          <source>The special field name &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;all fields&amp;rdquo;, as further explained in &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;セクション8.16.5で&lt;/a&gt;さらに説明するように、特別なフィールド名 &lt;code&gt;*&lt;/code&gt; は「すべてのフィールド」を意味します。</target>
        </trans-unit>
        <trans-unit id="758ed933ac597fbff2a112b5d5781d2521256906" translate="yes" xml:space="preserve">
          <source>The special privileges of the object owner (i.e., the right to do &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, etc.) are always implicit in being the owner, and cannot be granted or revoked. But the object owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others.</source>
          <target state="translated">オブジェクト所有者の特別な特権（つまり、 &lt;code&gt;DROP&lt;/code&gt; 、 &lt;code&gt;GRANT&lt;/code&gt; 、 &lt;code&gt;REVOKE&lt;/code&gt; などを実行する権利）は、常に所有者であることを暗黙的に示しており、付与したり取り消したりすることはできません。ただし、オブジェクトの所有者は、自分自身の通常の権限を取り消すことを選択できます。たとえば、自分だけでなく他のユーザーもテーブルを読み取り専用にできます。</target>
        </trans-unit>
        <trans-unit id="c644ef37e4f8fad5de2f6806820052ad171113ce" translate="yes" xml:space="preserve">
          <source>The special table function &lt;code&gt;UNNEST&lt;/code&gt; may be called with any number of array parameters, and it returns a corresponding number of columns, as if &lt;code&gt;UNNEST&lt;/code&gt; (&lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;) had been called on each parameter separately and combined using the &lt;code&gt;ROWS FROM&lt;/code&gt; construct.</source>
          <target state="translated">特別なテーブル関数 &lt;code&gt;UNNEST&lt;/code&gt; は、任意の数の配列パラメーターで呼び出すことができ、 &lt;code&gt;UNNEST&lt;/code&gt; （&lt;a href=&quot;functions-array&quot;&gt;セクション9.18&lt;/a&gt;）が各パラメーターで個別に呼び出され、 &lt;code&gt;ROWS FROM&lt;/code&gt; 構文を使用して結合されたかのように、対応する数の列を返します。</target>
        </trans-unit>
        <trans-unit id="e3760930d6be21baabcd516fd8aaa6bbd0e31deb" translate="yes" xml:space="preserve">
          <source>The special values &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt; may be used when creating a range partition to indicate that there is no lower or upper bound on the column's value. For example, a partition defined using &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; allows any values less than 10, and a partition defined using &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; allows any values greater than or equal to 10.</source>
          <target state="translated">特別な値 &lt;code&gt;MINVALUE&lt;/code&gt; および &lt;code&gt;MAXVALUE&lt;/code&gt; は、範囲パーティションを作成するときに、列の値に下限または上限がないことを示すために使用できます。たとえば、 &lt;code&gt;FROM (MINVALUE) TO (10)&lt;/code&gt; 使用して定義されたパーティションは10未満の値を許可し、 &lt;code&gt;FROM (10) TO (MAXVALUE)&lt;/code&gt; を使用して定義されたパーティションは10 以上の値を許可します。</target>
        </trans-unit>
        <trans-unit id="7e90fbaeae1d1655b1bb6f95cb13335bf4d3a214" translate="yes" xml:space="preserve">
          <source>The specially treated variables are:</source>
          <target state="translated">特別に扱われる変数は</target>
        </trans-unit>
        <trans-unit id="1b586ed754bd73f7164a8d06b3ccf052091b7071" translate="yes" xml:space="preserve">
          <source>The specific data that a BRIN index will store, as well as the specific queries that the index will be able to satisfy, depend on the operator class selected for each column of the index. Data types having a linear sort order can have operator classes that store the minimum and maximum value within each block range, for instance; geometrical types might store the bounding box for all the objects in the block range.</source>
          <target state="translated">BRINインデックスが格納する特定のデータや、インデックスが満たすことのできる特定のクエリは、インデックスの各列で選択された演算子クラスに依存します。例えば、線形ソート順のデータ型は、各ブロック範囲内の最小値と最大値を格納する演算子クラスを持つことができ、幾何学的な型は、ブロック範囲内のすべてのオブジェクトのバウンディングボックスを格納することができます。</target>
        </trans-unit>
        <trans-unit id="c67370c9102fee266def76d5516bcf8df8f39414" translate="yes" xml:space="preserve">
          <source>The specific function that is referenced by a function call is determined using the following procedure.</source>
          <target state="translated">関数呼び出しで参照される特定の関数は、以下の手順で決定されます。</target>
        </trans-unit>
        <trans-unit id="d4491b1318b4f57536f43e332d74ca6d054454c5" translate="yes" xml:space="preserve">
          <source>The specific operator that is referenced by an operator expression is determined using the following procedure. Note that this procedure is indirectly affected by the precedence of the operators involved, since that will determine which sub-expressions are taken to be the inputs of which operators. See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">演算子式によって参照される特定の演算子は、次の手順を使用して決定されます。この手順は、関係する演算子の優先順位に間接的に影響されることに注意してください。これにより、どの演算子のどの式がどの演算子の入力になるかが決定されます。詳細は、&lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;4.1.6&lt;/a&gt;項を参照してください。</target>
        </trans-unit>
        <trans-unit id="bf52c4d6cf2c8133df1aca73cde50bf658361fd0" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;index&lt;/code&gt; can be an integer, as well as an expression returning a single numeric value, which is automatically cast to integer. Zero index corresponds to the first array element. You can also use the &lt;code&gt;last&lt;/code&gt; keyword to denote the last array element, which is useful for handling arrays of unknown length.</source>
          <target state="translated">指定する &lt;code&gt;index&lt;/code&gt; は、整数と、自動的に整数にキャストされる単一の数値を返す式にすることができます。ゼロのインデックスは、最初の配列要素に対応します。また、 &lt;code&gt;last&lt;/code&gt; キーワードを使用して最後の配列要素を示すこともできます。これは、長さが不明な配列の処理に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8859206cebb9c86d9bc85a5c793d72f97cbfcda7" translate="yes" xml:space="preserve">
          <source>The specified &lt;code&gt;role_name&lt;/code&gt; must be a role that the current session user is a member of. (If the session user is a superuser, any role can be selected.)</source>
          <target state="translated">指定された &lt;code&gt;role_name&lt;/code&gt; は、現在のセッションユーザーがメンバーであるロールである必要があります。（セッションユーザーがスーパーユーザーの場合、任意のロールを選択できます。）</target>
        </trans-unit>
        <trans-unit id="afd818a1af1c31122dbe5ccb86326656bebfdabf" translate="yes" xml:space="preserve">
          <source>The specified locale and encoding settings must match, or an error will be reported.</source>
          <target state="translated">指定したロケールとエンコーディングの設定が一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="0c30502cb792c5bd66e555818ae0268a7466dc40" translate="yes" xml:space="preserve">
          <source>The specified null string is sent by &lt;code&gt;COPY TO&lt;/code&gt; without adding any backslashes; conversely, &lt;code&gt;COPY FROM&lt;/code&gt; matches the input against the null string before removing backslashes. Therefore, a null string such as &lt;code&gt;\N&lt;/code&gt; cannot be confused with the actual data value &lt;code&gt;\N&lt;/code&gt; (which would be represented as &lt;code&gt;\\N&lt;/code&gt;).</source>
          <target state="translated">指定されたnull文字列は、円記号を追加せずに &lt;code&gt;COPY TO&lt;/code&gt; によって送信されます。逆に、 &lt;code&gt;COPY FROM&lt;/code&gt; は、バックスラッシュを削除する前に、入力をnull文字列と照合します。したがって、 &lt;code&gt;\N&lt;/code&gt; などのnull文字列は、実際のデータ値 &lt;code&gt;\N&lt;/code&gt; （ &lt;code&gt;\\N&lt;/code&gt; として表される）と混同できません。</target>
        </trans-unit>
        <trans-unit id="4d4785fdbe411a867de5dc30c6f6e2cd3e8ad8aa" translate="yes" xml:space="preserve">
          <source>The specified replication slot has to exist unless the option &lt;code&gt;-C&lt;/code&gt; is also used.</source>
          <target state="translated">オプション &lt;code&gt;-C&lt;/code&gt; も使用されない限り、指定された複製スロットは存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="fe37bdbcd81870812798f7398d4fa3769b9383b0" translate="yes" xml:space="preserve">
          <source>The speed of the archiving command is unimportant as long as it can keep up with the average rate at which your server generates WAL data. Normal operation continues even if the archiving process falls a little behind. If archiving falls significantly behind, this will increase the amount of data that would be lost in the event of a disaster. It will also mean that the &lt;code&gt;pg_wal/&lt;/code&gt; directory will contain large numbers of not-yet-archived segment files, which could eventually exceed available disk space. You are advised to monitor the archiving process to ensure that it is working as you intend.</source>
          <target state="translated">サーバーがWALデータを生成する平均レートに追いつくことができる限り、アーカイブコマンドの速度は重要ではありません。アーカイブプロセスが少し遅れても、通常の操作は続行されます。アーカイブが大幅に遅れると、災害時に失われるデータ量が増加します。また、 &lt;code&gt;pg_wal/&lt;/code&gt; ディレクトリには、まだアーカイブされていないセグメントファイルが多数含まれ、最終的には使用可能なディスク領域を超える可能性があります。アーカイブプロセスを監視して、意図したとおりに機能していることを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="95c448049b38c97f5a095366eb9a582e60005694" translate="yes" xml:space="preserve">
          <source>The spi module provides several workable examples of using the &lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;Server Programming Interface&lt;/a&gt; (SPI) and triggers. While these functions are of some value in their own right, they are even more useful as examples to modify for your own purposes. The functions are general enough to be used with any table, but you have to specify table and field names (as described below) while creating a trigger.</source>
          <target state="translated">spiモジュールは、&lt;a href=&quot;https://www.postgresql.org/docs/12/spi.html&quot;&gt;サーバープログラミングインターフェース&lt;/a&gt;（SPI）とトリガーの使用に関するいくつかの実用的な例を提供します。これらの関数はそれ自体である程度の価値がありますが、独自の目的のために変更する例としてさらに役立ちます。関数は、どのテーブルでも使用できるほど一般的ですが、トリガーを作成するときに（以下で説明するように）テーブル名とフィールド名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="51d51509dfcf1b638bd0142f5ba7e99e05ff8361" translate="yes" xml:space="preserve">
          <source>The standard B-tree operators are also provided, for example</source>
          <target state="translated">標準的なB-tree演算子も提供されており、例えば</target>
        </trans-unit>
        <trans-unit id="540592c3e626f7c31f8adb5673f9493bff1cdcb6" translate="yes" xml:space="preserve">
          <source>The standard PostgreSQL distribution does not include any Ispell configuration files. Dictionaries for a large number of languages are available from &lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;. Also, some more modern dictionary file formats are supported &amp;mdash; &lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt; (OO &amp;lt; 2.0.1) and &lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt; (OO &amp;gt;= 2.0.2). A large list of dictionaries is available on the &lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;.</source>
          <target state="translated">標準のPostgreSQLディストリビューションには、Ispell構成ファイルは含まれていません。&lt;a href=&quot;https://www.cs.hmc.edu/~geoff/ispell.html&quot;&gt;Ispell&lt;/a&gt;から多数の言語の辞書を入手できます。また、&lt;a href=&quot;https://en.wikipedia.org/wiki/MySpell&quot;&gt;MySpell&lt;/a&gt;（OO &amp;lt;2.0.1）や&lt;a href=&quot;https://sourceforge.net/projects/hunspell/&quot;&gt;Hunspell&lt;/a&gt;（OO&amp;gt; = 2.0.2）など、より新しい辞書ファイル形式もサポートされています。&lt;a href=&quot;https://wiki.openoffice.org/wiki/Dictionaries&quot;&gt;OpenOffice Wiki&lt;/a&gt;には、多数の辞書のリストがあります。</target>
        </trans-unit>
        <trans-unit id="c31d1f8f49b866b6c41ce1d3be305d54cfca10f1" translate="yes" xml:space="preserve">
          <source>The standard allows transition tables to be used with column-specific &lt;code&gt;UPDATE&lt;/code&gt; triggers, but then the set of rows that should be visible in the transition tables depends on the trigger's column list. This is not currently implemented by PostgreSQL.</source>
          <target state="translated">標準では、遷移テーブルを列固有の &lt;code&gt;UPDATE&lt;/code&gt; トリガーで使用できますが、遷移テーブルに表示される必要がある行のセットは、トリガーの列リストによって異なります。これは現在PostgreSQLでは実装されていません。</target>
        </trans-unit>
        <trans-unit id="7abbb06bd2ac89072eb3b19d752092cab8a2a05f" translate="yes" xml:space="preserve">
          <source>The standard and predefined collations are in the schema &lt;code&gt;pg_catalog&lt;/code&gt;, like all predefined objects. User-defined collations should be created in user schemas. This also ensures that they are saved by &lt;code&gt;pg_dump&lt;/code&gt;.</source>
          <target state="translated">標準および事前定義の照合は、すべての事前定義オブジェクトと同様に、スキーマ &lt;code&gt;pg_catalog&lt;/code&gt; にあります。ユーザー定義の照合順序は、ユーザースキーマに作成する必要があります。これにより、 &lt;code&gt;pg_dump&lt;/code&gt; によって確実に保存されます。</target>
        </trans-unit>
        <trans-unit id="7c4d54e7271038b160fc912ff3e59738441ec42e" translate="yes" xml:space="preserve">
          <source>The standard approach to doing case-insensitive matches in PostgreSQL has been to use the &lt;code&gt;lower&lt;/code&gt; function when comparing values, for example</source>
          <target state="translated">PostgreSQLで大文字と小文字を区別しない一致を行うための標準的なアプローチは、値を比較するときに &lt;code&gt;lower&lt;/code&gt; 関数を使用することでした。たとえば、</target>
        </trans-unit>
        <trans-unit id="66a45d5bab8320954db0c2f93584f58e956d983a" translate="yes" xml:space="preserve">
          <source>The standard comparison operators shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt; are available for &lt;code&gt;jsonb&lt;/code&gt;, but not for &lt;code&gt;json&lt;/code&gt;. They follow the ordering rules for B-tree operations outlined at &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示す標準比較演算子は &lt;code&gt;jsonb&lt;/code&gt; では使用できますが、 &lt;code&gt;json&lt;/code&gt; では使用できません。これらは、&lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;セクション8.14.4で&lt;/a&gt;概説されているBツリー操作の順序付け規則に従います。</target>
        </trans-unit>
        <trans-unit id="aecb6846cb8fa061d2893b8cbe3329208b79f989" translate="yes" xml:space="preserve">
          <source>The standard form of &lt;code&gt;VACUUM&lt;/code&gt; removes dead row versions in tables and indexes and marks the space available for future reuse. However, it will not return the space to the operating system, except in the special case where one or more pages at the end of a table become entirely free and an exclusive table lock can be easily obtained. In contrast, &lt;code&gt;VACUUM FULL&lt;/code&gt; actively compacts tables by writing a complete new version of the table file with no dead space. This minimizes the size of the table, but can take a long time. It also requires extra disk space for the new copy of the table, until the operation completes.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; の標準形式は、テーブルとインデックスの不要な行のバージョンを削除し、将来の再利用に利用できるスペースをマークします。ただし、テーブルの最後にある1つ以上のページが完全に解放され、簡単に排他的なテーブルロックを取得できる特別な場合を除いて、オペレーティングシステムに領域は返されません。対照的に、 &lt;code&gt;VACUUM FULL&lt;/code&gt; は、デッドスペースのない完全な新しいバージョンのテーブルファイルを書き込むことにより、テーブルをアクティブに圧縮します。これによりテーブルのサイズが最小化されますが、時間がかかる場合があります。また、操作が完了するまで、テーブルの新しいコピー用に追加のディスク容量が必要です。</target>
        </trans-unit>
        <trans-unit id="64a9df6af803f6fb88db88a2c8492bf422359cc7" translate="yes" xml:space="preserve">
          <source>The standard only allows one function to be dropped per command.</source>
          <target state="translated">標準では1つのコマンドにつき1つの関数しか落とせないようになっています。</target>
        </trans-unit>
        <trans-unit id="f5dc058e6d69517b035378cc0545a3ff6bbf59c9" translate="yes" xml:space="preserve">
          <source>The standard only allows one procedure to be dropped per command.</source>
          <target state="translated">標準では1つのコマンドにつき1つのプロシージャしかドロップできません。</target>
        </trans-unit>
        <trans-unit id="d079640bb3afa14420ec7729af4881846a5851ac" translate="yes" xml:space="preserve">
          <source>The standard only allows one routine to be dropped per command.</source>
          <target state="translated">標準では、コマンドごとに1つのルーチンを削除することしかできません。</target>
        </trans-unit>
        <trans-unit id="d6f30578370e30868e083b5faa5f9ddb49a2e7ea" translate="yes" xml:space="preserve">
          <source>The standard requires parentheses around the subquery clause; in PostgreSQL, these parentheses are optional.</source>
          <target state="translated">PostgreSQLでは、これらの括弧はオプションです。</target>
        </trans-unit>
        <trans-unit id="037c9f0273cfeaa62d235fa64430e2ec604be3e9" translate="yes" xml:space="preserve">
          <source>The standard's definition of the behavior of temporary tables is widely ignored. PostgreSQL's behavior on this point is similar to that of several other SQL databases.</source>
          <target state="translated">テンポラリテーブルの動作に関する標準の定義は広く無視されています。この点に関するPostgreSQLの動作は、他のいくつかのSQLデータベースと似ています。</target>
        </trans-unit>
        <trans-unit id="d958124d33ada3ecaa4ecf5cd2414a7d80adeee5" translate="yes" xml:space="preserve">
          <source>The statement subforms and actions available for &lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; are a subset of those available for &lt;code&gt;ALTER TABLE&lt;/code&gt;, and have the same meaning when used for materialized views. See the descriptions for &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;ALTER MATERIALIZED VIEW&lt;/code&gt; で使用できるステートメントサブフォームとアクションは、 &lt;code&gt;ALTER TABLE&lt;/code&gt; で使用できるもののサブセットであり、マテリアライズドビューで使用した場合と同じ意味を持ちます。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="6a85ce8c175ffd31b8c2d56822ffccc6660fc62f" translate="yes" xml:space="preserve">
          <source>The statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt; usually include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. One or both of these can be omitted if &lt;code&gt;ANALYZE&lt;/code&gt; deems them uninteresting (for example, in a unique-key column, there are no common values) or if the column data type does not support the appropriate operators. There is more information about the statistics in &lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;Chapter 24&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; が収集する統計には、通常、各列の最も一般的な値のリストと、各列のおおよそのデータ分布を示すヒストグラムが含まれます。 &lt;code&gt;ANALYZE&lt;/code&gt; がそれらを興味がないと考える場合（たとえば、一意キー列では、共通の値がない場合）、または列のデータ型が適切な演算子をサポートしていない場合、これらの一方または両方を省略できます。統計についての詳細は、&lt;a href=&quot;https://www.postgresql.org/docs/12/maintenance.html&quot;&gt;第24章にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="238068c46fb76fc5b6da5477e8f4ec22c3889848" translate="yes" xml:space="preserve">
          <source>The statistics collector is active during recovery. All scans, reads, blocks, index usage, etc., will be recorded normally on the standby. Replayed actions will not duplicate their effects on primary, so replaying an insert will not increment the Inserts column of pg_stat_user_tables. The stats file is deleted at the start of recovery, so stats from primary and standby will differ; this is considered a feature, not a bug.</source>
          <target state="translated">リカバリー中は統計情報コレクタがアクティブになります。すべてのスキャン、読み込み、ブロック、インデックスの使用状況などは、待機状態では正常に記録されます。再生されたアクションはプライマリへの影響を複製しませんので、挿入を再生してもpg_stat_user_tablesのInserts列は増加しません。スタッツファイルは復旧の開始時に削除されるため、プライマリとスタンバイのスタッツは異なります。</target>
        </trans-unit>
        <trans-unit id="965711f627243ac89dbb9d9e575eab2acab52658" translate="yes" xml:space="preserve">
          <source>The statistics collector transmits the collected information to other PostgreSQL processes through temporary files. These files are stored in the directory named by the &lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt; parameter, &lt;code&gt;pg_stat_tmp&lt;/code&gt; by default. For better performance, &lt;code&gt;stats_temp_directory&lt;/code&gt; can be pointed at a RAM-based file system, decreasing physical I/O requirements. When the server shuts down cleanly, a permanent copy of the statistics data is stored in the &lt;code&gt;pg_stat&lt;/code&gt; subdirectory, so that statistics can be retained across server restarts. When recovery is performed at server start (e.g. after immediate shutdown, server crash, and point-in-time recovery), all statistics counters are reset.</source>
          <target state="translated">統計収集機能は、収集した情報を一時ファイルを介して他のPostgreSQLプロセスに送信します。これらのファイルは、&lt;a href=&quot;runtime-config-statistics#GUC-STATS-TEMP-DIRECTORY&quot;&gt;stats_temp_directory&lt;/a&gt;パラメータで指定されたディレクトリ、デフォルトでは &lt;code&gt;pg_stat_tmp&lt;/code&gt; に保存されます。パフォーマンスを &lt;code&gt;stats_temp_directory&lt;/code&gt; せるために、stats_temp_directoryをRAMベースのファイルシステムにポイントして、物理I / O要件を減らすことができます。サーバーが &lt;code&gt;pg_stat&lt;/code&gt; シャットダウンすると、統計データの永続的なコピーがpg_statサブディレクトリに保存されるため、サーバーを再起動しても統計を保持できます。サーバーの起動時にリカバリーが実行されると（即時シャットダウン、サーバーのクラッシュ、ポイントインタイムリカバリーなど）、すべての統計カウンターがリセットされます。</target>
        </trans-unit>
        <trans-unit id="3d31102b772c217f86df5c917a56d333df998b96" translate="yes" xml:space="preserve">
          <source>The statistics gathered by the module are made available via a view named &lt;code&gt;pg_stat_statements&lt;/code&gt;. This view contains one row for each distinct database ID, user ID and query ID (up to the maximum number of distinct statements that the module can track). The columns of the view are shown in &lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;Table F.21&lt;/a&gt;.</source>
          <target state="translated">モジュールによって収集された統計は、 &lt;code&gt;pg_stat_statements&lt;/code&gt; という名前のビューを介して利用可能になります。このビューには、個別のデータベースID、ユーザーID、およびクエリIDごとに1つの行が含まれています（モジュールが追跡できる個別のステートメントの最大数まで）。ビューの列を&lt;a href=&quot;pgstatstatements#PGSTATSTATEMENTS-COLUMNS&quot;&gt;表F.21に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="d129f0558b07e424e594be75be7478f28f34b280" translate="yes" xml:space="preserve">
          <source>The stop point must be after the ending time of the base backup, i.e., the end time of &lt;code&gt;pg_stop_backup&lt;/code&gt;. You cannot use a base backup to recover to a time when that backup was in progress. (To recover to such a time, you must go back to your previous base backup and roll forward from there.)</source>
          <target state="translated">停止ポイントは、ベースバックアップの終了時間、つまり &lt;code&gt;pg_stop_backup&lt;/code&gt; の終了時間より後でなければなりません。基本バックアップを使用して、そのバックアップが進行中であった時点に回復することはできません。（このような時間に回復するには、以前のベースバックアップに戻って、そこからロールフォワードする必要があります。）</target>
        </trans-unit>
        <trans-unit id="991a8e15374d6e812a4e43376053e637a59638d9" translate="yes" xml:space="preserve">
          <source>The stopword file format is the same as already explained.</source>
          <target state="translated">ストップワードファイルの形式は、すでに説明したものと同じです。</target>
        </trans-unit>
        <trans-unit id="6a67abf97180ecab3e7785607a17892200ca122a" translate="yes" xml:space="preserve">
          <source>The storage alignment requirement of the data type. If specified, it must be &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;; the default is &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">データ型のストレージアラインメント要件。指定する場合は、 &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;int2&lt;/code&gt; 、 &lt;code&gt;int4&lt;/code&gt; 、または &lt;code&gt;double&lt;/code&gt; にする必要があります。デフォルトは &lt;code&gt;int4&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4fb27d9289cba59d0dbea8d9a256bcf54f4d8f1d" translate="yes" xml:space="preserve">
          <source>The storage requirement for a short string (up to 126 bytes) is 1 byte plus the actual string, which includes the space padding in the case of &lt;code&gt;character&lt;/code&gt;. Longer strings have 4 bytes of overhead instead of 1. Long strings are compressed by the system automatically, so the physical requirement on disk might be less. Very long values are also stored in background tables so that they do not interfere with rapid access to shorter column values. In any case, the longest possible character string that can be stored is about 1 GB. (The maximum value that will be allowed for &lt;code&gt;n&lt;/code&gt; in the data type declaration is less than that. It wouldn't be useful to change this because with multibyte character encodings the number of characters and bytes can be quite different. If you desire to store long strings with no specific upper limit, use &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; without a length specifier, rather than making up an arbitrary length limit.)</source>
          <target state="translated">短い文字列（最大126バイト）のストレージ要件は、1バイトに実際の文字列を加えた &lt;code&gt;character&lt;/code&gt; です。これには、characterの場合のスペースパディングが含まれます。長い文字列のオーバーヘッドは1ではなく4バイトです。長い文字列はシステムによって自動的に圧縮されるため、ディスク上の物理的な要件は少なくなる可能性があります。非常に長い値もバックグラウンドテーブルに格納されるため、短い列値への迅速なアクセスを妨げることはありません。いずれの場合でも、格納できる最長の文字列は約1 GBです。 （ &lt;code&gt;n&lt;/code&gt; に許可される最大値データ型宣言ではそれよりも小さいです。マルチバイト文字エンコーディングでは、文字とバイトの数がかなり異なる可能性があるため、これを変更しても意味がありません。特定の上限なしで長い文字列を保存する場合は、任意の長さ制限を作成するのではなく、長さ指定子なしで &lt;code&gt;character varying&lt;/code&gt; する &lt;code&gt;text&lt;/code&gt; または文字を使用します。</target>
        </trans-unit>
        <trans-unit id="80d6814e5ec0e1d06f3de3ede9d15794bac11987" translate="yes" xml:space="preserve">
          <source>The storage strategy for the data type. If specified, must be &lt;code&gt;plain&lt;/code&gt;, &lt;code&gt;external&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, or &lt;code&gt;main&lt;/code&gt;; the default is &lt;code&gt;plain&lt;/code&gt;.</source>
          <target state="translated">データ型のストレージ戦略。指定する場合は、 &lt;code&gt;plain&lt;/code&gt; 、 &lt;code&gt;external&lt;/code&gt; 、 &lt;code&gt;extended&lt;/code&gt; 、または &lt;code&gt;main&lt;/code&gt; である必要があります。デフォルトは &lt;code&gt;plain&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3b76e63a79625e26440cca8d9a00f3887da24e61" translate="yes" xml:space="preserve">
          <source>The stream format is determined by the output plugin specified when the slot was created.</source>
          <target state="translated">ストリームの形式は、スロットが作成されたときに指定された出力プラグインによって決定されます。</target>
        </trans-unit>
        <trans-unit id="19380cfa586d87fdf911b110ff6bf4d13369bdea" translate="yes" xml:space="preserve">
          <source>The string constant can be written using either regular SQL notation or dollar-quoting.</source>
          <target state="translated">文字列定数は、通常のSQL記法またはドルクォートを使用して記述することができます。</target>
        </trans-unit>
        <trans-unit id="84091e9e070956556635627e5454034e5e1ceadb" translate="yes" xml:space="preserve">
          <source>The string constant's text is passed to the input conversion routine for the type called &lt;code&gt;type&lt;/code&gt;. The result is a constant of the indicated type. The explicit type cast can be omitted if there is no ambiguity as to the type the constant must be (for example, when it is assigned directly to a table column), in which case it is automatically coerced.</source>
          <target state="translated">文字列定数のテキストは、typeと呼ばれる &lt;code&gt;type&lt;/code&gt; 入力変換ルーチンに渡されます。結果は、示されたタイプの定数です。定数の型が明確でなければ（たとえば、テーブルの列に直接割り当てられている場合など）、明示的な型キャストを省略できます。この場合、定数は自動的に強制されます。</target>
        </trans-unit>
        <trans-unit id="c916cd87a0dd50984ecec5d10546dad9c3284d3a" translate="yes" xml:space="preserve">
          <source>The string must start with a &lt;code&gt;P&lt;/code&gt;, and may include a &lt;code&gt;T&lt;/code&gt; that introduces the time-of-day units. The available unit abbreviations are given in &lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;Table 8.16&lt;/a&gt;. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after &lt;code&gt;T&lt;/code&gt;. In particular, the meaning of &lt;code&gt;M&lt;/code&gt; depends on whether it is before or after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">文字列は &lt;code&gt;P&lt;/code&gt; で始まる必要があり、時刻の単位を紹介する &lt;code&gt;T&lt;/code&gt; を含めることができます。使用可能な単位の省略形を&lt;a href=&quot;datatype-datetime#DATATYPE-INTERVAL-ISO8601-UNITS&quot;&gt;表8.16に示し&lt;/a&gt;ます。単位は省略でき、任意の順序で指定できますが、1日よりも小さい単位は &lt;code&gt;T&lt;/code&gt; の後に表示する必要があります。特に、 &lt;code&gt;M&lt;/code&gt; の意味は、それが &lt;code&gt;T&lt;/code&gt; の前か後かによって異なります。</target>
        </trans-unit>
        <trans-unit id="d5ac1d279bca8c92d106e249d73c9450bd51985a" translate="yes" xml:space="preserve">
          <source>The string used as &lt;code&gt;NAS Identifier&lt;/code&gt; in the RADIUS requests. This parameter can be used as a second parameter identifying for example which database user the user is attempting to authenticate as, which can be used for policy matching on the RADIUS server. If no identifier is specified, the default &lt;code&gt;postgresql&lt;/code&gt; will be used.</source>
          <target state="translated">RADIUS要求で &lt;code&gt;NAS Identifier&lt;/code&gt; として使用される文字列。このパラメーターは、たとえば、ユーザーが認証を試みているデータベースユーザーを識別する2番目のパラメーターとして使用できます。これは、RADIUSサーバーでのポリシー照合に使用できます。識別子を指定しない場合、デフォルトの &lt;code&gt;postgresql&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="b3ee7b9f09ddbdb9488305b75db66d9c52bca23d" translate="yes" xml:space="preserve">
          <source>The string value of an XML element is the concatenation, in document order, of all text nodes contained in that element and its descendants. The string value of an element with no descendant text nodes is an empty string (not &lt;code&gt;NULL&lt;/code&gt;). Any &lt;code&gt;xsi:nil&lt;/code&gt; attributes are ignored. Note that the whitespace-only &lt;code&gt;text()&lt;/code&gt; node between two non-text elements is preserved, and that leading whitespace on a &lt;code&gt;text()&lt;/code&gt; node is not flattened. The XPath 1.0 &lt;code&gt;string&lt;/code&gt; function may be consulted for the rules defining the string value of other XML node types and non-XML values.</source>
          <target state="translated">XML要素の文字列値は、その要素とその子孫に含まれるすべてのテキストノードのドキュメント順の連結です。子孫テキストノードのない要素の文字列値は、空の文字列（ &lt;code&gt;NULL&lt;/code&gt; ではない）です。どれでも &lt;code&gt;xsi:nil&lt;/code&gt; 属性は無視されます。2つの非テキスト要素間の空白のみの &lt;code&gt;text()&lt;/code&gt; ノードは保持され、 &lt;code&gt;text()&lt;/code&gt; ノードの先頭の空白はフラット化されないことに注意してください。 XPath 1.0 &lt;code&gt;string&lt;/code&gt; 関数は、他のXMLノードタイプの文字列値と非XML値を定義するルールについて調べられる場合があります。</target>
        </trans-unit>
        <trans-unit id="2fec81f56bf595f634fb57f3910c670ede118c7c" translate="yes" xml:space="preserve">
          <source>The string-literal processor removes one level of backslashes, so that what arrives at the composite-value parser looks like &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt;. In turn, the string fed to the &lt;code&gt;text&lt;/code&gt; data type's input routine becomes &lt;code&gt;&quot;\&lt;/code&gt;. (If we were working with a data type whose input routine also treated backslashes specially, &lt;code&gt;bytea&lt;/code&gt; for example, we might need as many as eight backslashes in the command to get one backslash into the stored composite field.) Dollar quoting (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;Section 4.1.2.4&lt;/a&gt;) can be used to avoid the need to double backslashes.</source>
          <target state="translated">文字列リテラルプロセッサは1レベルのバックスラッシュを削除するため、コンポジット値パーサーに到達するものは &lt;code&gt;(&quot;\&quot;\\&quot;)&lt;/code&gt; ようになります。次に、 &lt;code&gt;text&lt;/code&gt; データタイプの入力ルーチンに渡される文字列は &lt;code&gt;&quot;\&lt;/code&gt; ます。（たとえば、入力ルーチンがバックスラッシュも特別に扱っているデータ型を使用していた場合、1つのバックスラッシュを格納された複合フィールドに入れるには、コマンドに &lt;code&gt;bytea&lt;/code&gt; 8つのバックスラッシュが必要になる場合があります。）ドル引用（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-DOLLAR-QUOTING&quot;&gt;セクション4.1を&lt;/a&gt;参照）。 2.4）を使用すると、バックスラッシュを2つにする必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="8b9c21921311be92ddd5f85cbd74e19f06bfbb6a" translate="yes" xml:space="preserve">
          <source>The structure &lt;code&gt;IndexAmRoutine&lt;/code&gt; is defined thus:</source>
          <target state="translated">構造 &lt;code&gt;IndexAmRoutine&lt;/code&gt; は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="1b7ec1adb20c9f7f9468502c9f11469bc8e03f67" translate="yes" xml:space="preserve">
          <source>The structure of a query plan is a tree of &lt;em&gt;plan nodes&lt;/em&gt;. Nodes at the bottom level of the tree are scan nodes: they return raw rows from a table. There are different types of scan nodes for different table access methods: sequential scans, index scans, and bitmap index scans. There are also non-table row sources, such as &lt;code&gt;VALUES&lt;/code&gt; clauses and set-returning functions in &lt;code&gt;FROM&lt;/code&gt;, which have their own scan node types. If the query requires joining, aggregation, sorting, or other operations on the raw rows, then there will be additional nodes above the scan nodes to perform these operations. Again, there is usually more than one possible way to do these operations, so different node types can appear here too. The output of &lt;code&gt;EXPLAIN&lt;/code&gt; has one line for each node in the plan tree, showing the basic node type plus the cost estimates that the planner made for the execution of that plan node. Additional lines might appear, indented from the node's summary line, to show additional properties of the node. The very first line (the summary line for the topmost node) has the estimated total execution cost for the plan; it is this number that the planner seeks to minimize.</source>
          <target state="translated">クエリプランの構造は、&lt;em&gt;プランノードの&lt;/em&gt;ツリーです。ツリーの最下位レベルのノードはスキャンノードです。テーブルから生の行を返します。さまざまなテーブルアクセス方法には、さまざまな種類のスキャンノードがあります。順次スキャン、インデックススキャン、ビットマップインデックススキャンです。独自のスキャンノードタイプを持つ &lt;code&gt;VALUES&lt;/code&gt; 句や &lt;code&gt;FROM&lt;/code&gt; のセットを返す関数など、テーブル以外の行ソースもあります。クエリで生の行に対する結合、集計、並べ替え、またはその他の操作が必要な場合、これらの操作を実行するための追加のノードがスキャンノードの上にあります。繰り返しますが、通常、これらの操作を実行する方法は複数あるため、ここにも異なるノードタイプが表示される可能性があります。 &lt;code&gt;EXPLAIN&lt;/code&gt; の出力プランツリーの各ノードに1行あり、基本的なノードタイプとプランナがそのプランノードの実行のために作成したコストの見積もりを示します。ノードの追加のプロパティを示すために、ノードの概要行からインデントされた追加の行が表示される場合があります。最初の行（最上位ノードの要約行）には、計画の推定合計実行コストがあります。プランナーが最小化しようとするのはこの数です。</target>
        </trans-unit>
        <trans-unit id="845e7bd65e68101aeef835121687192ee5165c8e" translate="yes" xml:space="preserve">
          <source>The sub-statements in &lt;code&gt;WITH&lt;/code&gt; are executed concurrently with each other and with the main query. Therefore, when using data-modifying statements in &lt;code&gt;WITH&lt;/code&gt;, the order in which the specified updates actually happen is unpredictable. All the statements are executed with the same &lt;em&gt;snapshot&lt;/em&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt;), so they cannot &amp;ldquo;see&amp;rdquo; one another's effects on the target tables. This alleviates the effects of the unpredictability of the actual order of row updates, and means that &lt;code&gt;RETURNING&lt;/code&gt; data is the only way to communicate changes between different &lt;code&gt;WITH&lt;/code&gt; sub-statements and the main query. An example of this is that in</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; のサブステートメントは、互いに、およびメインクエリと同時に実行されます。したがって、 &lt;code&gt;WITH&lt;/code&gt; でデータ変更ステートメントを使用する場合、指定された更新が実際に行われる順序は予測できません。すべてのステートメントは同じ&lt;em&gt;スナップショット&lt;/em&gt;（&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照）で実行されるため、ターゲットテーブルに対する互いの影響を「確認」することはできません。これにより、行の更新の実際の順序が予測できないことによる影響が軽減され、 &lt;code&gt;RETURNING&lt;/code&gt; データが、さまざまな &lt;code&gt;WITH&lt;/code&gt; サブステートメントとメインクエリの間で変更を伝達する唯一の方法になります。この例は、</target>
        </trans-unit>
        <trans-unit id="b11dad81d612edf5fd0a4215e04a5d2694b81901" translate="yes" xml:space="preserve">
          <source>The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery.</source>
          <target state="translated">副問い合わせは周囲の問い合わせから変数を参照することができ、これは副問い合わせの任意の1つの評価の間に定数として動作します。</target>
        </trans-unit>
        <trans-unit id="9047f1ac499137a7641446b4435a2058e7165f8c" translate="yes" xml:space="preserve">
          <source>The subquery must return a single column. If the subquery's output column is of a non-array type, the resulting one-dimensional array will have an element for each row in the subquery result, with an element type matching that of the subquery's output column. If the subquery's output column is of an array type, the result will be an array of the same type but one higher dimension; in this case all the subquery rows must yield arrays of identical dimensionality, else the result would not be rectangular.</source>
          <target state="translated">副問い合わせは単一の列を返す必要があります。サブクエリの出力列が非配列型の場合、結果として得られる1次元配列は、サブクエリの出力列と一致する要素型を持つ、サブクエリ結果の各行に対応する要素を持ちます。サブクエリの出力列が配列型の場合、結果は同じ型の配列ですが、1つ高い次元の配列になります。この場合、すべてのサブクエリの行が同じ次元の配列を生成しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ad9a65e976a88e8f391a32410934cda1367df45d" translate="yes" xml:space="preserve">
          <source>The subquery will generally only be executed long enough to determine whether at least one row is returned, not all the way to completion. It is unwise to write a subquery that has side effects (such as calling sequence functions); whether the side effects occur might be unpredictable.</source>
          <target state="translated">副問い合わせは一般的に、少なくとも1つの行が返されるかどうかを判断するのに十分な長さだけ実行され、すべての行が完了するまで実行されるわけではありません。副次的な効果(シーケンス関数の呼び出しなど)を持つ副問い合わせを書くことは賢明ではありません;副次的な効果が発生するかどうかは予測できません。</target>
        </trans-unit>
        <trans-unit id="68c9d90ab99dc33425ce7d63877e33bcb6f1a254" translate="yes" xml:space="preserve">
          <source>The subscriber also requires the &lt;code&gt;max_replication_slots&lt;/code&gt; to be set. In this case it should be set to at least the number of subscriptions that will be added to the subscriber. &lt;code&gt;max_logical_replication_workers&lt;/code&gt; must be set to at least the number of subscriptions, again plus some reserve for the table synchronization. Additionally the &lt;code&gt;max_worker_processes&lt;/code&gt; may need to be adjusted to accommodate for replication workers, at least (&lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt;). Note that some extensions and parallel queries also take worker slots from &lt;code&gt;max_worker_processes&lt;/code&gt;.</source>
          <target state="translated">サブスクライバーでは、 &lt;code&gt;max_replication_slots&lt;/code&gt; も設定する必要があります。この場合、少なくともサブスクライバーに追加されるサブスクリプションの数に設定する必要があります。 &lt;code&gt;max_logical_replication_workers&lt;/code&gt; は、少なくともサブスクリプションの数に加えて、テーブルの同期のための予約を追加する必要があります。さらに、 &lt;code&gt;max_worker_processes&lt;/code&gt; は、少なくとも（ &lt;code&gt;max_logical_replication_workers&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; ）レプリケーションワーカーに対応するように調整する必要がある場合があります。一部の拡張機能と並列クエリも、 &lt;code&gt;max_worker_processes&lt;/code&gt; からワーカースロットを取得することに注意してください。</target>
        </trans-unit>
        <trans-unit id="5061f785b5ca16b03e284f2d1ce17b7eeda1d830" translate="yes" xml:space="preserve">
          <source>The subscriber database behaves in the same way as any other PostgreSQL instance and can be used as a publisher for other databases by defining its own publications.</source>
          <target state="translated">加入者データベースは他のPostgreSQLインスタンスと同じように動作し、独自のパブリケーションを定義することで、他のデータベースのパブリッシャーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="53e109de41793b3722661641499539600ee95867" translate="yes" xml:space="preserve">
          <source>The subscription apply process will run in the local database with the privileges of a superuser.</source>
          <target state="translated">サブスクリプションの適用プロセスは、スーパーユーザーの権限でローカルデータベースで実行されます。</target>
        </trans-unit>
        <trans-unit id="4cb7abebeb2fd700c8b2ec617037c9667107f4c0" translate="yes" xml:space="preserve">
          <source>The subscription is added using &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt; and can be stopped/resumed at any time using the &lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt; command and removed using &lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;.</source>
          <target state="translated">サブスクリプションは&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;を使用して追加され、&lt;a href=&quot;sql-altersubscription&quot;&gt;ALTER SUBSCRIPTION&lt;/a&gt;コマンドを使用していつでも停止/再開でき、&lt;a href=&quot;sql-dropsubscription&quot;&gt;DROP SUBSCRIPTION&lt;/a&gt;を使用して削除できます。</target>
        </trans-unit>
        <trans-unit id="121044a7fb76fda9e0fbc21177fe11d696a1b02d" translate="yes" xml:space="preserve">
          <source>The subscription represents a replication connection to the publisher. As such this command does not only add definitions in the local catalogs but also creates a replication slot on the publisher.</source>
          <target state="translated">サブスクリプションはパブリッシャーへのレプリケーション接続を表します。そのため、このコマンドはローカルカタログに定義を追加するだけでなく、パブリッシャーにレプリケーションスロットを作成します。</target>
        </trans-unit>
        <trans-unit id="48011fd4928d8a9744bee30b18454a7d53e6f680" translate="yes" xml:space="preserve">
          <source>The subscripts of an array value built with &lt;code&gt;ARRAY&lt;/code&gt; always begin with one. For more information about arrays, see &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; で作成された配列値の添え字は、常に1で始まります。配列の詳細については、&lt;a href=&quot;arrays&quot;&gt;セクション8.15を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2334c3c5a694ddeb266347a848900f44f0cab917" translate="yes" xml:space="preserve">
          <source>The summarizing structure is bound in size by &lt;code&gt;maintenance_work_mem&lt;/code&gt;. In order to ensure that there is no more than a 2% probability of failure to detect an inconsistency for each heap tuple that should be represented in the index, approximately 2 bytes of memory are needed per tuple. As less memory is made available per tuple, the probability of missing an inconsistency slowly increases. This approach limits the overhead of verification significantly, while only slightly reducing the probability of detecting a problem, especially for installations where verification is treated as a routine maintenance task. Any single absent or malformed tuple has a new opportunity to be detected with each new verification attempt.</source>
          <target state="translated">要約構造のサイズは、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; によってバインドされます。インデックスで表現する必要がある各ヒープタプルの不整合を検出できない可能性が2％を超えないようにするには、タプルごとに約2バイトのメモリが必要です。タプルごとに使用できるメモリが少なくなると、不整合を見落とす可能性が徐々に増加します。このアプローチは、検証のオーバーヘッドを大幅に制限しますが、特に検証が日常的なメンテナンスタスクとして扱われるインストールでは、問題を検出する可能性をわずかに減らします。単一の不在または不正なタプルは、新しい検証を試行するたびに検出される新しい機会があります。</target>
        </trans-unit>
        <trans-unit id="aa2efac8a5cca33663d7c228751b90df82bafbc8" translate="yes" xml:space="preserve">
          <source>The switch file &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; is created first, enabling archiving of completed WAL files to occur. After the backup the switch file is removed. Archived WAL files are then added to the backup so that both base backup and all required WAL files are part of the same tar file. Please remember to add error handling to your backup scripts.</source>
          <target state="translated">スイッチファイル &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; が最初に作成され、完了したWALファイルのアーカイブを実行できるようにします。バックアップ後、スイッチファイルは削除されます。次に、アーカイブされたWALファイルがバックアップに追加され、ベースバックアップと必要なすべてのWALファイルの両方が同じtarファイルの一部になります。バックアップスクリプトにエラー処理を追加することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="87700f6e1446d98115cf77b5305bf6c280312a5f" translate="yes" xml:space="preserve">
          <source>The symbol shown in the column &amp;ldquo;Condition Name&amp;rdquo; is the condition name to use in PL/pgSQL. Condition names can be written in either upper or lower case. (Note that PL/pgSQL does not recognize warning, as opposed to error, condition names; those are classes 00, 01, and 02.)</source>
          <target state="translated">「条件名」の列に表示されている記号は、PL / pgSQLで使用する条件名です。条件名は大文字でも小文字でも記述できます。（PL / pgSQLは、エラーではなく、条件名を認識しないことに注意してください。条件名はクラス00、01、02です。）</target>
        </trans-unit>
        <trans-unit id="af2af0e19179d988e1c5bb09182f6b8329bf33d2" translate="yes" xml:space="preserve">
          <source>The synchronization workers are taken from the pool defined by &lt;code&gt;max_logical_replication_workers&lt;/code&gt;.</source>
          <target state="translated">同期ワーカーは、 &lt;code&gt;max_logical_replication_workers&lt;/code&gt; で定義されたプールから取得されます。</target>
        </trans-unit>
        <trans-unit id="9ff2f915045408cc48aad6178d8c49b4353ee6d4" translate="yes" xml:space="preserve">
          <source>The synchronous states of standby servers can be viewed using the &lt;code&gt;pg_stat_replication&lt;/code&gt; view.</source>
          <target state="translated">スタンバイサーバーの同期状態は、 &lt;code&gt;pg_stat_replication&lt;/code&gt; ビューを使用して表示できます。</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">構文は</target>
        </trans-unit>
        <trans-unit id="8f181461d9c844d09a197734c97365af11fec6c2" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;CREATE TABLE&lt;/code&gt; allows the exact size of arrays to be specified, for example:</source>
          <target state="translated">&lt;code&gt;CREATE TABLE&lt;/code&gt; の構文では、配列の正確なサイズを指定できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="966dbee44492fe4c1ad689fb4503c9e542bc2d3e" translate="yes" xml:space="preserve">
          <source>The syntax for a function call is the name of a function (possibly qualified with a schema name), followed by its argument list enclosed in parentheses:</source>
          <target state="translated">関数呼び出しの構文は、関数名 (スキーマ名で修飾されている場合もあります)の後に、括弧で囲まれた引数リストが続きます。</target>
        </trans-unit>
        <trans-unit id="9827946ae401eb6c51ab3afdb1c21f5055ada0b5" translate="yes" xml:space="preserve">
          <source>The syntax for ordered-set aggregates allows &lt;code&gt;VARIADIC&lt;/code&gt; to be specified for both the last direct parameter and the last aggregated (&lt;code&gt;WITHIN GROUP&lt;/code&gt;) parameter. However, the current implementation restricts use of &lt;code&gt;VARIADIC&lt;/code&gt; in two ways. First, ordered-set aggregates can only use &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, not other variadic array types. Second, if the last direct parameter is &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;, then there can be only one aggregated parameter and it must also be &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt;. (In the representation used in the system catalogs, these two parameters are merged into a single &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; item, since &lt;code&gt;pg_proc&lt;/code&gt; cannot represent functions with more than one &lt;code&gt;VARIADIC&lt;/code&gt; parameter.) If the aggregate is a hypothetical-set aggregate, the direct arguments that match the &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameter are the hypothetical ones; any preceding parameters represent additional direct arguments that are not constrained to match the aggregated arguments.</source>
          <target state="translated">順序付き集合の構文では、 &lt;code&gt;VARIADIC&lt;/code&gt; を最後の直接パラメーターと最後の集約（ &lt;code&gt;WITHIN GROUP&lt;/code&gt; ）パラメーターの両方に指定できます。ただし、現在の実装では、 &lt;code&gt;VARIADIC&lt;/code&gt; の使用が2つの方法で制限されています。まず、順序付き集合の集計は &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; のみを使用でき、他の可変配列型は使用できません。最後の直接のパラメータがある場合には、第2は、 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 、1つだけ集約パラメータがあることができ、それはまたにする必要があり &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; 。 （システムカタログで使用される表現では、これらの2つのパラメーターは単一の &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; アイテムにマージされます &lt;code&gt;pg_proc&lt;/code&gt; は、複数の &lt;code&gt;VARIADIC&lt;/code&gt; パラメータを持つ関数を表すことはできません。）集計が架空のセットの集計である場合、 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; パラメータに一致する直接引数は架空のものです。先行するパラメータは、集約された引数と一致するように制約されていない追加の直接引数を表します。</target>
        </trans-unit>
        <trans-unit id="d86a8075f285a9e5f082a7c58f078a97fe87d56b" translate="yes" xml:space="preserve">
          <source>The syntax is comparable to &lt;code&gt;CREATE TABLE&lt;/code&gt;, except that only field names and types can be specified; no constraints (such as &lt;code&gt;NOT NULL&lt;/code&gt;) can presently be included. Note that the &lt;code&gt;AS&lt;/code&gt; keyword is essential; without it, the system will think a different kind of &lt;code&gt;CREATE TYPE&lt;/code&gt; command is meant, and you will get odd syntax errors.</source>
          <target state="translated">構文は &lt;code&gt;CREATE TABLE&lt;/code&gt; に似ていますが、指定できるのはフィールド名とタイプのみです。現在、 &lt;code&gt;NOT NULL&lt;/code&gt; などの制約を含めることはできません。注意 &lt;code&gt;AS&lt;/code&gt; のキーワードが不可欠です。これがないと、システムは別の種類の &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドが意図されていると考え、奇妙な構文エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="42c058b9d6546225c3baf16e3e4b8ff07bce7ea0" translate="yes" xml:space="preserve">
          <source>The syntax of constants for the numeric types is described in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;Section 4.1.2&lt;/a&gt;. The numeric types have a full set of corresponding arithmetic operators and functions. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for more information. The following sections describe the types in detail.</source>
          <target state="translated">数値型の定数の構文は、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS&quot;&gt;セクション4.1.2で&lt;/a&gt;説明されています。数値型には、対応する算術演算子と関数の完全なセットがあります。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章を&lt;/a&gt;参照してください。次のセクションでは、タイプについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="3602bbafe5a0054bbc62eb9c26f3d0a2eca852d1" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt;&lt;code&gt;WHERE&lt;/code&gt; Clause&lt;/a&gt; is</source>
          <target state="translated">&lt;a href=&quot;sql-select#SQL-WHERE&quot;&gt; &lt;code&gt;WHERE&lt;/code&gt; 句&lt;/a&gt;の構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8203a94af84f4e0e580fcba3501f0b24c27a5840" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;CREATE INDEX&lt;/code&gt; command normally requires writing parentheses around index expressions, as shown in the second example. The parentheses can be omitted when the expression is just a function call, as in the first example.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; コマンドの構文では、通常、2番目の例に示すように、インデックス式を括弧で囲む必要があります。最初の例のように、式が単なる関数呼び出しの場合は、括弧を省略できます。</target>
        </trans-unit>
        <trans-unit id="c241abd813b7161dcc7e86ad91e10959de152091" translate="yes" xml:space="preserve">
          <source>The syntax of this command is similar to that of the SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; command. All options other than the data source/destination are as specified for &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;. Because of this, special parsing rules apply to the &lt;code&gt;\copy&lt;/code&gt; meta-command. Unlike most other meta-commands, the entire remainder of the line is always taken to be the arguments of &lt;code&gt;\copy&lt;/code&gt;, and neither variable interpolation nor backquote expansion are performed in the arguments.</source>
          <target state="translated">このコマンドの構文は、SQL &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;コマンドの構文に似ています。データのソース/宛先以外のすべてのオプションは、&lt;a href=&quot;sql-copy&quot;&gt;COPYで&lt;/a&gt;指定したとおりです。このため、 &lt;code&gt;\copy&lt;/code&gt; メタコマンドには特別な解析ルールが適用されます。他のほとんどのメタコマンドとは異なり、行の残り全体は常に &lt;code&gt;\copy&lt;/code&gt; の引数と見なされ、変数の補間もバッククォート展開も引数で実行されません。</target>
        </trans-unit>
        <trans-unit id="cd8d680d5b62b13099c9e19bc923e563b07e6d19" translate="yes" xml:space="preserve">
          <source>The syntax used so far requires you to remember the order of the columns. An alternative syntax allows you to list the columns explicitly:</source>
          <target state="translated">これまでに使用した構文では、カラムの順序を覚えておく必要があります。別の構文では、列を明示的にリストアップすることができます。</target>
        </trans-unit>
        <trans-unit id="033030a62bda22a5de4a5aeea859f2505dc5e730" translate="yes" xml:space="preserve">
          <source>The syntax with &lt;code&gt;ORDER BY&lt;/code&gt; in the parameter list creates a special type of aggregate called an &lt;em&gt;ordered-set aggregate&lt;/em&gt;; or if &lt;code&gt;HYPOTHETICAL&lt;/code&gt; is specified, then a &lt;em&gt;hypothetical-set aggregate&lt;/em&gt; is created. These aggregates operate over groups of sorted values in order-dependent ways, so that specification of an input sort order is an essential part of a call. Also, they can have &lt;em&gt;direct&lt;/em&gt; arguments, which are arguments that are evaluated only once per aggregation rather than once per input row. Hypothetical-set aggregates are a subclass of ordered-set aggregates in which some of the direct arguments are required to match, in number and data types, the aggregated argument columns. This allows the values of those direct arguments to be added to the collection of aggregate-input rows as an additional &amp;ldquo;hypothetical&amp;rdquo; row.</source>
          <target state="translated">パラメータリストで &lt;code&gt;ORDER BY&lt;/code&gt; を使用する構文は、&lt;em&gt;ordered-set集約&lt;/em&gt;と呼ばれる特別なタイプの集約を作成します。または、 &lt;code&gt;HYPOTHETICAL&lt;/code&gt; が指定されている場合は、&lt;em&gt;仮定セット集合&lt;/em&gt;が作成されます。これらの集計は、並べ替えられた値のグループに対して順序依存の方法で動作するため、入力並べ替え順序の指定は呼び出しの重要な部分です。また、彼らは&lt;em&gt;直接&lt;/em&gt;持つことができます&lt;em&gt;&lt;/em&gt;引数。これは、入力行ごとに1回ではなく、集計ごとに1回だけ評価される引数です。仮説集合集合体は、順序付き集合集合体のサブクラスであり、直接引数のいくつかは、数とデータ型において、集約された引数列と一致する必要があります。これにより、それらの直接引数の値を、追加の「仮想」行として集約入力行のコレクションに追加できます。</target>
        </trans-unit>
        <trans-unit id="3670cc6e37bfe2baa6c265184cfb9070b0da0ca9" translate="yes" xml:space="preserve">
          <source>The syntaxes using &lt;code&gt;*&lt;/code&gt; are used for calling parameter-less aggregate functions as window functions, for example &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt;. The asterisk (&lt;code&gt;*&lt;/code&gt;) is customarily not used for window-specific functions. Window-specific functions do not allow &lt;code&gt;DISTINCT&lt;/code&gt; or &lt;code&gt;ORDER BY&lt;/code&gt; to be used within the function argument list.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; を使用する構文は、counter &lt;code&gt;count(*) OVER (PARTITION BY x ORDER BY y)&lt;/code&gt; パラメーターなしの集約関数をウィンドウ関数として呼び出すために使用されます。アスタリスク（ &lt;code&gt;*&lt;/code&gt; ）は、通常、ウィンドウ固有の関数には使用されません。ウィンドウ固有の関数では、 &lt;code&gt;DISTINCT&lt;/code&gt; または &lt;code&gt;ORDER BY&lt;/code&gt; を関数の引数リスト内で使用できません。</target>
        </trans-unit>
        <trans-unit id="5413e5588ef7474b4153013c25aed37daf2b6ac4" translate="yes" xml:space="preserve">
          <source>The system catalog &lt;code&gt;pg_language&lt;/code&gt; (see &lt;a href=&quot;catalog-pg-language&quot;&gt;Section 51.29&lt;/a&gt;) records information about the currently installed languages. Also, the psql command &lt;code&gt;\dL&lt;/code&gt; lists the installed languages.</source>
          <target state="translated">システムカタログ &lt;code&gt;pg_language&lt;/code&gt; （&lt;a href=&quot;catalog-pg-language&quot;&gt;セクション51.29を&lt;/a&gt;参照）は、現在インストールされている言語に関する情報を記録します。また、psqlコマンド &lt;code&gt;\dL&lt;/code&gt; はインストールされている言語をリストします。</target>
        </trans-unit>
        <trans-unit id="2583bf948cb2199416aaa963439f3392af0c4543" translate="yes" xml:space="preserve">
          <source>The system catalog cache code (and most catalog-munging code in general) assumes that the fixed-length portions of all system catalog tuples are in fact present, because it maps this C struct declaration onto them. Thus, all variable-length fields and nullable fields must be placed at the end, and they cannot be accessed as struct fields. For example, if you tried to set &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typrelid&lt;/code&gt; to be NULL, it would fail when some piece of code tried to reference &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; (or worse, &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt;, because that follows &lt;code&gt;typrelid&lt;/code&gt;). This would result in random errors or even segmentation violations.</source>
          <target state="translated">システムカタログキャッシュコード（およびほとんどのカタログ変更コード）は、このC構造体宣言をマップするため、すべてのシステムカタログタプルの固定長部分が実際に存在すると想定しています。したがって、すべての可変長フィールドとNULL可能フィールドは最後に配置する必要があり、それらは構造体フィールドとしてアクセスできません。たとえば、 &lt;code&gt;pg_type&lt;/code&gt; を設定しようとした場合。 &lt;code&gt;typrelid&lt;/code&gt; NULLするコードの一部片が参照しようとしたとき、それは失敗する &lt;code&gt;typetup-&amp;gt;typrelid&lt;/code&gt; （または悪化 &lt;code&gt;typetup-&amp;gt;typelem&lt;/code&gt; すなわち次ので、 &lt;code&gt;typrelid&lt;/code&gt; ）。これにより、ランダムエラーまたはセグメンテーション違反が発生します。</target>
        </trans-unit>
        <trans-unit id="bb485f21372d37054b0b92886fc6889e8d0f2f48" translate="yes" xml:space="preserve">
          <source>The system catalog schema, &lt;code&gt;pg_catalog&lt;/code&gt;, is always searched, whether it is mentioned in the path or not. If it is mentioned in the path then it will be searched in the specified order. If &lt;code&gt;pg_catalog&lt;/code&gt; is not in the path then it will be searched &lt;em&gt;before&lt;/em&gt; searching any of the path items.</source>
          <target state="translated">システムカタログスキーマ &lt;code&gt;pg_catalog&lt;/code&gt; は、パスで指定されているかどうかにかかわらず、常に検索されます。パスに記載されている場合は、指定された順序で検索されます。 &lt;code&gt;pg_catalog&lt;/code&gt; がパスにない場合は、パス項目を検索&lt;em&gt;する前に&lt;/em&gt;検索されます。</target>
        </trans-unit>
        <trans-unit id="dffb9af79cadde8378337d566688f00f092c9630" translate="yes" xml:space="preserve">
          <source>The system catalogs store information about which conversions, or &lt;em&gt;casts&lt;/em&gt;, exist between which data types, and how to perform those conversions. Additional casts can be added by the user with the &lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt; command. (This is usually done in conjunction with defining new data types. The set of casts between built-in types has been carefully crafted and is best not altered.)</source>
          <target state="translated">システムカタログには、どのデータ型の間に存在する変換または&lt;em&gt;キャスト&lt;/em&gt;に関する情報、およびそれらの変換を実行する方法が格納されています。ユーザーは、&lt;a href=&quot;sql-createcast&quot;&gt;CREATE CAST&lt;/a&gt;コマンドを使用して、追加のキャストを追加できます。（これは通常、新しいデータ型の定義と組み合わせて行われます。組み込み型間のキャストのセットは注意深く作成されており、変更しないことをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="94541a873b2d451108de2b46c0592e4902bdbb36" translate="yes" xml:space="preserve">
          <source>The system uses no more than &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, &lt;code&gt;NAMEDATALEN&lt;/code&gt; is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the &lt;code&gt;NAMEDATALEN&lt;/code&gt; constant in &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt;.</source>
          <target state="translated">システムは、 &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1バイト以下の識別子を使用します。長い名前はコマンドで記述できますが、切り捨てられます。デフォルトでは、 &lt;code&gt;NAMEDATALEN&lt;/code&gt; は64なので、識別子の最大長は63バイトです。この制限に問題がある場合は、 &lt;code&gt;src/include/pg_config_manual.h&lt;/code&gt; の &lt;code&gt;NAMEDATALEN&lt;/code&gt; 定数を変更することにより、この制限を引き上げることができます。</target>
        </trans-unit>
        <trans-unit id="18aee9967e71bb22ca6c7ef97d956490785417e5" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-file-settings&quot;&gt;&lt;code&gt;pg_file_settings&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the configuration files, or for diagnosing problems if a SIGHUP signal did not have the desired effects.</source>
          <target state="translated">システムビュー&lt;a href=&quot;view-pg-file-settings&quot;&gt; &lt;code&gt;pg_file_settings&lt;/code&gt; &lt;/a&gt;は、構成ファイルへの変更を事前にテストしたり、SIGHUP信号が目的の効果を発揮しなかった場合に問題を診断したりするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="51af27f0b42d0a59cf04312463422fdaffc06293" translate="yes" xml:space="preserve">
          <source>The system view &lt;a href=&quot;view-pg-hba-file-rules&quot;&gt;&lt;code&gt;pg_hba_file_rules&lt;/code&gt;&lt;/a&gt; can be helpful for pre-testing changes to the &lt;code&gt;pg_hba.conf&lt;/code&gt; file, or for diagnosing problems if loading of the file did not have the desired effects. Rows in the view with non-null &lt;code&gt;error&lt;/code&gt; fields indicate problems in the corresponding lines of the file.</source>
          <target state="translated">システムビュー&lt;a href=&quot;view-pg-hba-file-rules&quot;&gt; &lt;code&gt;pg_hba_file_rules&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;pg_hba.conf&lt;/code&gt; ファイルへの変更を事前にテストするため、またはファイルのロードが望ましい効果をもたらさなかった場合の問題の診断に役立ちます。null以外の &lt;code&gt;error&lt;/code&gt; フィールドがあるビューの行は、ファイルの対応する行に問題があることを示しています。</target>
        </trans-unit>
        <trans-unit id="0d1a0c3c602b5e69816adbc6a5f72656d7deb220" translate="yes" xml:space="preserve">
          <source>The system-wide startup file is named &lt;code&gt;psqlrc&lt;/code&gt; and is sought in the installation's &amp;ldquo;system configuration&amp;rdquo; directory, which is most reliably identified by running &lt;code&gt;pg_config --sysconfdir&lt;/code&gt;. By default this directory will be &lt;code&gt;../etc/&lt;/code&gt; relative to the directory containing the PostgreSQL executables. The name of this directory can be set explicitly via the &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">システム全体の起動ファイルは &lt;code&gt;psqlrc&lt;/code&gt; という名前で、インストールの「システム構成」ディレクトリで &lt;code&gt;pg_config --sysconfdir&lt;/code&gt; されます。これは、pg_config --sysconfdirを実行することで最も確実に識別されます。デフォルトでは、このディレクトリはPostgreSQL実行可能ファイルを含むディレクトリに対して &lt;code&gt;../etc/&lt;/code&gt; になります。このディレクトリの名前は、 &lt;code&gt;PGSYSCONFDIR&lt;/code&gt; 環境変数を使用して明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="d9987d6e81d602450ad224137a711661462f4308" translate="yes" xml:space="preserve">
          <source>The table also shows that PostgreSQL's Repeatable Read implementation does not allow phantom reads. Stricter behavior is permitted by the SQL standard: the four isolation levels only define which phenomena must not happen, not which phenomena &lt;em&gt;must&lt;/em&gt; happen. The behavior of the available isolation levels is detailed in the following subsections.</source>
          <target state="translated">この表は、PostgreSQLの反復可能読み取り実装がファントム読み取りを許可しないことも示しています。厳しい動作は、SQL標準で許可されている：4つの分離レベルは、唯一の現象がどの、現象が発生しない必要がない定義する&lt;em&gt;必要があります&lt;/em&gt;が起こります。使用可能な分離レベルの動作については、次のサブセクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="142b69e02a67de00ba841f641f5ef3fa34a277d2" translate="yes" xml:space="preserve">
          <source>The table definition above includes a primary key specification. This is useful to protect against accidentally importing the same information twice. The &lt;code&gt;COPY&lt;/code&gt; command commits all of the data it imports at one time, so any error will cause the entire import to fail. If you import a partial log file and later import the file again when it is complete, the primary key violation will cause the import to fail. Wait until the log is complete and closed before importing. This procedure will also protect against accidentally importing a partial line that hasn't been completely written, which would also cause &lt;code&gt;COPY&lt;/code&gt; to fail.</source>
          <target state="translated">上記のテーブル定義には、主キー仕様が含まれています。これは、同じ情報を誤って2度インポートしないようにするのに役立ちます。 &lt;code&gt;COPY&lt;/code&gt; のいずれかのエラーが全体のインポートが失敗する原因になりますので、コマンドは、それが一度にインポートしたデータのすべてをコミットします。部分的なログファイルをインポートし、後でそれが完了したときに再度インポートすると、主キー違反によりインポートが失敗します。インポートする前に、ログが完了して閉じるまで待ちます。この手順は、完全に書き込まれていない部分的な行を誤ってインポートすることからも保護します。これにより、 &lt;code&gt;COPY&lt;/code&gt; も失敗します。</target>
        </trans-unit>
        <trans-unit id="8b15dacbb7afc519b6433f93ec4919614f65b399" translate="yes" xml:space="preserve">
          <source>The table is partitioned by explicitly listing which key values appear in each partition.</source>
          <target state="translated">テーブルは、各パーティションに表示されるキー値を明示的にリストアップしてパーティション化されています。</target>
        </trans-unit>
        <trans-unit id="b51488835cbb40ee5da1ee3d9a8f7864d4b57976" translate="yes" xml:space="preserve">
          <source>The table is partitioned by specifying a modulus and a remainder for each partition. Each partition will hold the rows for which the hash value of the partition key divided by the specified modulus will produce the specified remainder.</source>
          <target state="translated">テーブルは、各パーティションにモジュラスと剰余を指定することで分割されます。各パーティションは、パーティションキーのハッシュ値を指定されたモジュラスで割ったものが指定された剰余となる行を保持します。</target>
        </trans-unit>
        <trans-unit id="7c5e839b9bae27b38d6af54b60ca56e0b347f0f2" translate="yes" xml:space="preserve">
          <source>The table is partitioned into &amp;ldquo;ranges&amp;rdquo; defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges, or by ranges of identifiers for particular business objects.</source>
          <target state="translated">テーブルは、キーカラムまたは列のセットで定義された「範囲」に分割され、異なるパーティションに割り当てられた値の範囲が重複することはありません。たとえば、日付範囲または特定のビジネスオブジェクトの識別子の範囲でパーティションを作成できます。</target>
        </trans-unit>
        <trans-unit id="292e8b677c187c4d68b1ebe250d22a32e9af8561" translate="yes" xml:space="preserve">
          <source>The table or index that the described column belongs to</source>
          <target state="translated">記述された列が属するテーブルまたはインデックス</target>
        </trans-unit>
        <trans-unit id="d142b3cf8f5a90793004bbdd69de61322293bd63" translate="yes" xml:space="preserve">
          <source>The table referenced by a referential integrity constraint</source>
          <target state="translated">参照整合性制約によって参照されるテーブル</target>
        </trans-unit>
        <trans-unit id="2a8191ca3a1df3ed6d1e85b59a92238d8c6f7d14" translate="yes" xml:space="preserve">
          <source>The table this column belongs to</source>
          <target state="translated">この列が属するテーブル</target>
        </trans-unit>
        <trans-unit id="75cfe910e753a5d9a7438e22a49cad2342942a50" translate="yes" xml:space="preserve">
          <source>The table this constraint is on; 0 if not a table constraint</source>
          <target state="translated">テーブル制約でない場合は 0</target>
        </trans-unit>
        <trans-unit id="2f088db11eed75527c26721e5e66e62e0678aeb6" translate="yes" xml:space="preserve">
          <source>The table this rule is for</source>
          <target state="translated">このルールが適用されるテーブル</target>
        </trans-unit>
        <trans-unit id="ac24dc8d3f1364ef3223d38811cd0f1cdfc7bc70" translate="yes" xml:space="preserve">
          <source>The table this trigger is on</source>
          <target state="translated">このトリガがあるテーブル</target>
        </trans-unit>
        <trans-unit id="d2d2364aa6d119df4f431f30d6909fa91ae4a412" translate="yes" xml:space="preserve">
          <source>The table to which the policy applies</source>
          <target state="translated">ポリシーが適用されるテーブル</target>
        </trans-unit>
        <trans-unit id="539b9dae513896d5721c3d82785ae25ab4799ccf" translate="yes" xml:space="preserve">
          <source>The tables added to a publication that publishes &lt;code&gt;UPDATE&lt;/code&gt; and/or &lt;code&gt;DELETE&lt;/code&gt; operations must have &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; defined. Otherwise those operations will be disallowed on those tables.</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作、あるいはその両方をパブリッシュするパブリケーションに追加されたテーブルには、 &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; が定義されている必要があります。それ以外の場合、これらの操作はそれらのテーブルでは許可されません。</target>
        </trans-unit>
        <trans-unit id="367460ef7d1ca64d14464409850a0a51a7ab7dc7" translate="yes" xml:space="preserve">
          <source>The tables are matched between the publisher and the subscriber using the fully qualified table name. Replication to differently-named tables on the subscriber is not supported.</source>
          <target state="translated">テーブルは、完全修飾されたテーブル名を使用してパブリッシャーとサブスクライバーの間で照合される。サブスクライバ上の異なる名前のテーブルへのレプリケーションはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f3c0314798fd15f5ed903ef71976f9e615a0bb52" translate="yes" xml:space="preserve">
          <source>The tablespace associated with a database is used to store the system catalogs of that database. Furthermore, it is the default tablespace used for tables, indexes, and temporary files created within the database, if no &lt;code&gt;TABLESPACE&lt;/code&gt; clause is given and no other selection is specified by &lt;code&gt;default_tablespace&lt;/code&gt; or &lt;code&gt;temp_tablespaces&lt;/code&gt; (as appropriate). If a database is created without specifying a tablespace for it, it uses the same tablespace as the template database it is copied from.</source>
          <target state="translated">データベースに関連付けられたテーブルスペースは、そのデータベースのシステムカタログを格納するために使用されます。さらに、 &lt;code&gt;TABLESPACE&lt;/code&gt; 句が指定されておらず、 &lt;code&gt;default_tablespace&lt;/code&gt; または &lt;code&gt;temp_tablespaces&lt;/code&gt; （必要に応じて）によって他の選択が指定されていない場合、データベース内で作成されるテーブル、インデックス、および一時ファイルに使用されるデフォルトのテーブルスペースです。テーブルスペースを指定せずにデータベースを作成すると、コピー元のテンプレートデータベースと同じテーブルスペースが使用されます。</target>
        </trans-unit>
        <trans-unit id="cd0a83e9744372d73f37f6c31fa32edd33e0f557" translate="yes" xml:space="preserve">
          <source>The tablespace in which this relation is stored. If zero, the database's default tablespace is implied. (Not meaningful if the relation has no on-disk file.)</source>
          <target state="translated">このリレーションが格納されているテーブル空間。ゼロの場合、データベースのデフォルトのテーブルスペースが暗示されます。(リレーションがディスク上のファイルを持っていない場合は意味がありません)。</target>
        </trans-unit>
        <trans-unit id="91ace69fa784c06e03e2d35b1b8ec1909d7a7501" translate="yes" xml:space="preserve">
          <source>The tablespace in which to create the index. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; for indexes on temporary tables.</source>
          <target state="translated">インデックスを作成するテーブルスペース。指定されていない場合は、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;、または一時テーブルのインデックスの&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespacesが参照さ&lt;/a&gt;れます。</target>
        </trans-unit>
        <trans-unit id="6945a89a0355036aac3b6ff63ff9fc68b1cb28a4" translate="yes" xml:space="preserve">
          <source>The tablespace to which the index will be moved.</source>
          <target state="translated">インデックスが移動されるテーブル空間。</target>
        </trans-unit>
        <trans-unit id="2fdf7a817dfba5e9f0aef01d7a04fe1bad9896f5" translate="yes" xml:space="preserve">
          <source>The tag, if any, of a dollar-quoted string follows the same rules as an unquoted identifier, except that it cannot contain a dollar sign. Tags are case sensitive, so &lt;code&gt;$tag$String content$tag$&lt;/code&gt; is correct, but &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; is not.</source>
          <target state="translated">ドルで引用された文字列のタグがある場合、タグは、引用符で囲まれていない識別子と同じ規則に従いますが、ドル記号を含めることはできません。タグでは大文字と小文字が区別されるため、 &lt;code&gt;$tag$String content$tag$&lt;/code&gt; は正しいですが、 &lt;code&gt;$TAG$String content$tag$&lt;/code&gt; は正しくありません。</target>
        </trans-unit>
        <trans-unit id="bef8aba7a1bcf650d04e76e3a3595346989e8039" translate="yes" xml:space="preserve">
          <source>The target column names can be listed in any order. If no list of column names is given at all, the default is all the columns of the table in their declared order; or the first &lt;code&gt;N&lt;/code&gt; column names, if there are only &lt;code&gt;N&lt;/code&gt; columns supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt;. The values supplied by the &lt;code&gt;VALUES&lt;/code&gt; clause or &lt;code&gt;query&lt;/code&gt; are associated with the explicit or implicit column list left-to-right.</source>
          <target state="translated">ターゲット列名は任意の順序でリストできます。列名のリストがまったく指定されていない場合、デフォルトはテーブルのすべての列が宣言された順序になります。 &lt;code&gt;VALUES&lt;/code&gt; 句または &lt;code&gt;query&lt;/code&gt; によって &lt;code&gt;N&lt;/code&gt; 列のみが提供されている場合は、最初の &lt;code&gt;N&lt;/code&gt; 列の名前。 &lt;code&gt;VALUES&lt;/code&gt; 句または &lt;code&gt;query&lt;/code&gt; によって提供される値は、明示的または暗黙的な列リストに左から右に関連付けられます。</target>
        </trans-unit>
        <trans-unit id="a52fa4d647d2a0e534fa04140c4a0531834e1437" translate="yes" xml:space="preserve">
          <source>The target function can be specified by name alone, or by name and arguments, for example &lt;code&gt;foo(integer, text)&lt;/code&gt;. The argument types must be given if there is more than one function of the same name.</source>
          <target state="translated">ターゲット関数は、名前のみ、または &lt;code&gt;foo(integer, text)&lt;/code&gt; などの名前と引数で指定できます。同じ名前の関数が複数ある場合は、引数の型を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a83f3ee2747bb5a0ebf49f8f4cc7233f65fe3b6" translate="yes" xml:space="preserve">
          <source>The task of the &lt;em&gt;planner/optimizer&lt;/em&gt; is to create an optimal execution plan. A given SQL query (and hence, a query tree) can be actually executed in a wide variety of different ways, each of which will produce the same set of results. If it is computationally feasible, the query optimizer will examine each of these possible execution plans, ultimately selecting the execution plan that is expected to run the fastest.</source>
          <target state="translated">&lt;em&gt;プランナー/オプティマイザー&lt;/em&gt;のタスクは、最適な実行プランを作成することです。特定のSQLクエリ（つまり、クエリツリー）は、実際にはさまざまな方法で実行でき、それぞれが同じ結果セットを生成します。計算上可能であれば、クエリオプティマイザーはこれらの可能な実行プランをそれぞれ調べ、最終的に最も高速に実行されると予想される実行プランを選択します。</target>
        </trans-unit>
        <trans-unit id="d0cfcd2522974bd11b7e720b66ddba5e0dc99d8f" translate="yes" xml:space="preserve">
          <source>The technical difference between a &lt;code&gt;jsonb_ops&lt;/code&gt; and a &lt;code&gt;jsonb_path_ops&lt;/code&gt; GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data. &lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt; Basically, each &lt;code&gt;jsonb_path_ops&lt;/code&gt; index item is a hash of the value and the key(s) leading to it; for example to index &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt;, a single index item would be created incorporating all three of &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether &lt;code&gt;foo&lt;/code&gt; appears as a key. On the other hand, a &lt;code&gt;jsonb_ops&lt;/code&gt; index would create three index items representing &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt; separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an AND search fairly efficiently, it will still be less specific and slower than the equivalent &lt;code&gt;jsonb_path_ops&lt;/code&gt; search, especially if there are a very large number of rows containing any single one of the three index items.</source>
          <target state="translated">&lt;code&gt;jsonb_ops&lt;/code&gt; と &lt;code&gt;jsonb_path_ops&lt;/code&gt; の GINインデックスの技術的な違いは、前者はデータの各キーと値に対して独立したインデックスアイテムを作成するのに対し、後者はデータの各値に対してのみインデックスアイテムを作成することです。&lt;a href=&quot;#ftn.id-1.5.7.22.18.9.3&quot;&gt;&lt;sup id=&quot;id-1.5.7.22.18.9.3&quot;&gt;[6]&lt;/sup&gt;&lt;/a&gt;基本的に、各 &lt;code&gt;jsonb_path_ops&lt;/code&gt; インデックスアイテムは、値とそれにつながるキーのハッシュです。たとえば、 &lt;code&gt;{&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}&lt;/code&gt; インデックスを作成するには、ハッシュ値に &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;bar&lt;/code&gt; 、および &lt;code&gt;baz&lt;/code&gt; の 3つすべてを組み込んだ単一のインデックスアイテムが作成されます。したがって、この構造を検索する包含クエリは、非常に具体的なインデックス検索になります。かどうかを調べる方法はまったくありません &lt;code&gt;foo&lt;/code&gt; がキーとして表示されます。一方、 &lt;code&gt;jsonb_ops&lt;/code&gt; インデックスは、 &lt;code&gt;foo&lt;/code&gt; 、 &lt;code&gt;bar&lt;/code&gt; 、および &lt;code&gt;baz&lt;/code&gt; を個別に表す3つのインデックス項目を作成します。次に、包含クエリを実行するために、これらの3つのアイテムすべてを含む行を探します。GINインデックスはこのようなAND検索をかなり効率的に実行できますが、特に3つのインデックス項目のいずれか1つを含む行が非常に多い場合は、同等の &lt;code&gt;jsonb_path_ops&lt;/code&gt; 検索よりも具体的でなく低速になります。</target>
        </trans-unit>
        <trans-unit id="1c8f7bc59665b224be12f558ca16a9e07627bb77" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block.</source>
          <target state="translated">テンポラリテーブルは、現在のトランザクションブロックの終了時にドロップされます。</target>
        </trans-unit>
        <trans-unit id="2e88ee252852e295414cf3850a24be66c227bee2" translate="yes" xml:space="preserve">
          <source>The temporary table will be dropped at the end of the current transaction block. When used on a partitioned table, this action drops its partitions and when used on tables with inheritance children, it drops the dependent children.</source>
          <target state="translated">一時テーブルは、現在のトランザクションブロックの終了時に削除されます。パーティショニングされたテーブルで使用された場合、このアクションはそのパーティショニングを削除し、継承子を持つテーブルで使用された場合、従属子を削除します。</target>
        </trans-unit>
        <trans-unit id="544789fd88fe85a89dc95a84868e683fa382498a" translate="yes" xml:space="preserve">
          <source>The term attribute is equivalent to column and is used for historical reasons.</source>
          <target state="translated">用語の属性はカラムに相当し、歴史的な理由から使用されています。</target>
        </trans-unit>
        <trans-unit id="a4a7c2d2771e24236d6f1bdd6761fd668754e8bc" translate="yes" xml:space="preserve">
          <source>The text representation of an &lt;code&gt;hstore&lt;/code&gt;, used for input and output, includes zero or more &lt;code&gt;key&lt;/code&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; pairs separated by commas. Some examples:</source>
          <target state="translated">入力と出力に使用される &lt;code&gt;hstore&lt;/code&gt; のテキスト表現には、コンマで区切られた0個以上の &lt;code&gt;key&lt;/code&gt; &lt;code&gt;=&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; ペアが含まれます。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="98a0a387ebcc73eb1a002f76f9873cf6168a1347" translate="yes" xml:space="preserve">
          <source>The text-search functionality in PostgreSQL can also be used to speed up full-document searches of XML data. The necessary preprocessing support is, however, not yet available in the PostgreSQL distribution.</source>
          <target state="translated">PostgreSQLのテキスト検索機能は、XMLデータの全文検索を高速化するためにも使用できます。しかし、必要な前処理のサポートはPostgreSQLディストリビューションではまだ利用できません。</target>
        </trans-unit>
        <trans-unit id="9535cead63cebae1ff29d54da604a76ade0e73e1" translate="yes" xml:space="preserve">
          <source>The textual label for this enum value</source>
          <target state="translated">この列挙値のテキストラベル</target>
        </trans-unit>
        <trans-unit id="5d79225bbaf1bc36cb45016180fd38042b31a872" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary &lt;code&gt;thesaurus_astro&lt;/code&gt; does know the phrase &lt;code&gt;supernovae stars&lt;/code&gt;, but &lt;code&gt;ts_lexize&lt;/code&gt; fails since it does not parse the input text but treats it as a single token. Use &lt;code&gt;plainto_tsquery&lt;/code&gt; or &lt;code&gt;to_tsvector&lt;/code&gt; to test thesaurus dictionaries, for example:</source>
          <target state="translated">シソーラス辞書 &lt;code&gt;thesaurus_astro&lt;/code&gt; は &lt;code&gt;supernovae stars&lt;/code&gt; というフレーズを知っていますが、 &lt;code&gt;ts_lexize&lt;/code&gt; は入力テキストを解析せず、単一のトークンとして処理するため失敗します。 &lt;code&gt;plainto_tsquery&lt;/code&gt; または &lt;code&gt;to_tsvector&lt;/code&gt; を使用して、シソーラス辞書をテストします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="497ebaef7c7bb30921967269b6dd4bfd06472628" translate="yes" xml:space="preserve">
          <source>The thesaurus dictionary chooses the longest match if there are multiple phrases matching the input, and ties are broken by using the last definition.</source>
          <target state="translated">シソーラス辞書は、入力に一致するフレーズが複数ある場合、最も長くマッチしたものを選択し、最後の定義を使用して同点を解消します。</target>
        </trans-unit>
        <trans-unit id="6384b1615ea61227de680b163bce3c7f613d4849" translate="yes" xml:space="preserve">
          <source>The third form changes the owner of the database. To alter the owner, you must own the database and also be a direct or indirect member of the new owning role, and you must have the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. (Note that superusers have all these privileges automatically.)</source>
          <target state="translated">3番目の形式は、データベースの所有者を変更します。所有者を変更するには、データベースを所有し、新しい所有ロールの直接または間接のメンバーである必要があります。また、 &lt;code&gt;CREATEDB&lt;/code&gt; 特権が必要です。（スーパーユーザーはこれらすべての特権を自動的に持つことに注意してください。）</target>
        </trans-unit>
        <trans-unit id="fb3a4f1cf7c17f675b6c88c65b759e2c18503d10" translate="yes" xml:space="preserve">
          <source>The third form of &lt;code&gt;CREATE TYPE&lt;/code&gt; creates a new range type, as described in &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE TYPE&lt;/code&gt; の3番目の形式は、&lt;a href=&quot;rangetypes&quot;&gt;セクション8.17で&lt;/a&gt;説明されているように、新しい範囲タイプを作成します。</target>
        </trans-unit>
        <trans-unit id="46e5d7ec29a414875ddb7427a1366569e134347d" translate="yes" xml:space="preserve">
          <source>The third parameter being &lt;code&gt;false&lt;/code&gt; tells &lt;code&gt;pg_start_backup&lt;/code&gt; to initiate a non-exclusive base backup.</source>
          <target state="translated">3番目のパラメータが &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;pg_start_backup&lt;/code&gt; は非排他的なベースバックアップを開始するように指示されます。</target>
        </trans-unit>
        <trans-unit id="43c4f141a3275bbc30bab46035e573f420cd4242" translate="yes" xml:space="preserve">
          <source>The third syntax was used before PostgreSQL version 9.6 and is still supported. It's the same as the first syntax with &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;num_sync&lt;/code&gt; equal to 1. For example, &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; and &lt;code&gt;s1, s2&lt;/code&gt; have the same meaning: either &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; is chosen as a synchronous standby.</source>
          <target state="translated">3番目の構文はPostgreSQLバージョン9.6より前に使用され、現在もサポートされています。これは、 &lt;code&gt;FIRST&lt;/code&gt; および &lt;code&gt;num_sync&lt;/code&gt; が1に等しい最初の構文と同じです。たとえば、 &lt;code&gt;FIRST 1 (s1, s2)&lt;/code&gt; と &lt;code&gt;s1, s2&lt;/code&gt; は同じ意味です。同期スタンバイとして &lt;code&gt;s1&lt;/code&gt; または &lt;code&gt;s2&lt;/code&gt; が選択されます。</target>
        </trans-unit>
        <trans-unit id="bce8828bcc021e862db732b17b8f2b754b34f3cc" translate="yes" xml:space="preserve">
          <source>The third variant changes the name of the group. This is exactly equivalent to renaming the role with &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt;.</source>
          <target state="translated">3番目のバリアントは、グループの名前を変更します。これは、&lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLEを使用し&lt;/a&gt;てロールの名前を変更することとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="e2d943d4346301a5cf1de51eecfb3a352a414893" translate="yes" xml:space="preserve">
          <source>The time at which the cursor was declared</source>
          <target state="translated">カーソルが宣言された時刻</target>
        </trans-unit>
        <trans-unit id="ec4185f356c4ef6086071a2e178362bf4f8c1b5e" translate="yes" xml:space="preserve">
          <source>The time at which the prepared statement was created</source>
          <target state="translated">準備書面を作成した時刻</target>
        </trans-unit>
        <trans-unit id="a0e8bb2f344559ea1d916061668ce3e9aa5b7836" translate="yes" xml:space="preserve">
          <source>The time zone 7 hours west from UTC (equivalent to PDT). Positive values are east from UTC.</source>
          <target state="translated">タイムゾーンはUTCから西に7時間(PDTに相当)。正の値はUTCから東になります。</target>
        </trans-unit>
        <trans-unit id="ee80f641d8eab20953a3190cfb6422152c737dea" translate="yes" xml:space="preserve">
          <source>The time zone 8 hours west from UTC (equivalent to PST).</source>
          <target state="translated">時間帯はUTCから西に8時間(PSTに相当)。</target>
        </trans-unit>
        <trans-unit id="3d03995667dbda87e63122260f5c6f6cb9fe649a" translate="yes" xml:space="preserve">
          <source>The time zone for Berkeley, California.</source>
          <target state="translated">カリフォルニア州バークレーのタイムゾーン。</target>
        </trans-unit>
        <trans-unit id="668f3cdec134bede84a934a9af41142895f7b007" translate="yes" xml:space="preserve">
          <source>The time zone for Italy.</source>
          <target state="translated">イタリアのタイムゾーン。</target>
        </trans-unit>
        <trans-unit id="c7ed4ff2c6ce4f9a9cd61b96f6374cf02812e246" translate="yes" xml:space="preserve">
          <source>The time zone offset from UTC, measured in seconds. Positive values correspond to time zones east of UTC, negative values to zones west of UTC. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.)</source>
          <target state="translated">UTCからのタイムゾーンのオフセットを秒単位で表示します。正の値はUTCの東側の時間帯に対応し、負の値はUTCの西側の時間帯に対応します。(技術的には、PostgreSQLはUTCを使用していないので、うるう秒は処理されません)。</target>
        </trans-unit>
        <trans-unit id="0ca5243d8e51420e24c77cdd1c3e577fee34053c" translate="yes" xml:space="preserve">
          <source>The time-of-day types are &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; and &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt;. &lt;code&gt;time&lt;/code&gt; alone is equivalent to &lt;code&gt;time without time zone&lt;/code&gt;.</source>
          <target state="translated">時刻タイプは、 &lt;code&gt;time [ (p) ] without time zone&lt;/code&gt; と &lt;code&gt;time [ (p) ] with time zone&lt;/code&gt; 。 &lt;code&gt;time&lt;/code&gt; のみは &lt;code&gt;time without time zone&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="41de03730261b036dd783f63ba08317d9d3e641d" translate="yes" xml:space="preserve">
          <source>The timeout is measured from the time a command arrives at the server until it is completed by the server. In extended query protocol, the timeout starts running when any query-related message (Parse, Bind, Execute, Describe) arrives, and it is cancelled by completion of an Execute or Sync message.</source>
          <target state="translated">タイムアウトは、コマンドがサーバに到着してからサーバが完了するまでの間に計測されます。拡張クエリプロトコルでは、タイムアウトはクエリ関連のメッセージ(Parse,Bind,Execute,Describe)が到着したときに実行を開始し、ExecuteメッセージまたはSyncメッセージの完了によってキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="d98b14f1fa1ca6a1d2cfd5fbd83b532ce899e731" translate="yes" xml:space="preserve">
          <source>The toast_tuple_target specifies the minimum tuple length required before we try to move long column values into TOAST tables, and is also the target length we try to reduce the length below once toasting begins. This only affects columns marked as either External or Extended and applies only to new tuples - there is no effect on existing rows. By default this parameter is set to allow at least 4 tuples per block, which with the default blocksize will be 2040 bytes. Valid values are between 128 bytes and the (blocksize - header), by default 8160 bytes. Changing this value may not be useful for very short or very long rows. Note that the default setting is often close to optimal, and it is possible that setting this parameter could have negative effects in some cases. This parameter cannot be set for TOAST tables.</source>
          <target state="translated">toast_tuple_targetは、長い列の値をTOASTテーブルに移動させようとする前に必要な最小のタプル長を指定します。これは、ExternalまたはExtendedとマークされた列にのみ影響し、新しいタプルにのみ適用され、既存の行には影響しません。デフォルトでは、このパラメータはブロックごとに少なくとも4つのタプルを許可するように設定されており、デフォルトのブロックサイズは2040バイトになります。有効な値は128バイトと(blockize-header)の間で、デフォルトでは8160バイトです。この値を変更することは、非常に短い行や非常に長い行には有用ではないかもしれません。デフォルトの設定は最適に近いことが多く、このパラメータを設定すると、場合によっては悪影響を及ぼす可能性があることに注意してください。このパラメータはTOASTテーブルでは設定できません。</target>
        </trans-unit>
        <trans-unit id="621d22a0cd204d89633ad09943ee84f1181db01e" translate="yes" xml:space="preserve">
          <source>The total number of columns in the index (duplicates &lt;code&gt;pg_class.relnatts&lt;/code&gt;); this number includes both key and included attributes</source>
          <target state="translated">インデックス内の列の総数（ &lt;code&gt;pg_class.relnatts&lt;/code&gt; を複製）。この数には、キーと含まれる属性の両方が含まれます</target>
        </trans-unit>
        <trans-unit id="f560f36dfc9d943beeddde2257c0e1b305d7ee85" translate="yes" xml:space="preserve">
          <source>The transaction ID epoch is not actually stored anywhere in the database except in the field that is set by &lt;code&gt;pg_resetwal&lt;/code&gt;, so any value will work so far as the database itself is concerned. You might need to adjust this value to ensure that replication systems such as Slony-I and Skytools work correctly &amp;mdash; if so, an appropriate value should be obtainable from the state of the downstream replicated database.</source>
          <target state="translated">トランザクションIDエポックは、実際には &lt;code&gt;pg_resetwal&lt;/code&gt; によって設定されるフィールドを除いてデータベースのどこにも保存されないため、データベース自体に関する限り、どの値でも機能します。Slony-IやSkytoolsなどのレプリケーションシステムが正しく機能するように、この値を調整する必要がある場合があります。そうであれば、ダウンストリームレプリケートデータベースの状態から適切な値を取得できるはずです。</target>
        </trans-unit>
        <trans-unit id="5c3634c8a4a4ce9f542309bb5a4cc86011569d07" translate="yes" xml:space="preserve">
          <source>The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and &lt;code&gt;COPY FROM&lt;/code&gt; if the table they would write to is not a temporary table; all &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;ALTER&lt;/code&gt;, and &lt;code&gt;DROP&lt;/code&gt; commands; &lt;code&gt;COMMENT&lt;/code&gt;, &lt;code&gt;GRANT&lt;/code&gt;, &lt;code&gt;REVOKE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;; and &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; and &lt;code&gt;EXECUTE&lt;/code&gt; if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk.</source>
          <target state="translated">トランザクションアクセスモードは、トランザクションが読み取り/書き込みか読み取り専用かを決定します。読み取り/書き込みがデフォルトです。トランザクションが読み取り専用の場合、次のSQLコマンドは許可されません。それらが書き込むテーブルが一時テーブルでない場合、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、および &lt;code&gt;COPY FROM&lt;/code&gt; 。すべての &lt;code&gt;CREATE&lt;/code&gt; 、 &lt;code&gt;ALTER&lt;/code&gt; 、および &lt;code&gt;DROP&lt;/code&gt; コマンド。 &lt;code&gt;COMMENT&lt;/code&gt; 、 &lt;code&gt;GRANT&lt;/code&gt; 、 &lt;code&gt;REVOKE&lt;/code&gt; 、 &lt;code&gt;TRUNCATE&lt;/code&gt; 。そして &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; と &lt;code&gt;EXECUTE&lt;/code&gt; それらが実行するコマンドがリストされているものの中にある場合。これは、ディスクへのすべての書き込みを妨げない読み取り専用の高レベルの概念です。</target>
        </trans-unit>
        <trans-unit id="75f4c782782aa478238329da73889aa36680137b" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be committed.</source>
          <target state="translated">コミットされるトランザクションのトランザクション識別子。</target>
        </trans-unit>
        <trans-unit id="cf987258f7d6ba8e2728a7ab480e418085360e38" translate="yes" xml:space="preserve">
          <source>The transaction identifier of the transaction that is to be rolled back.</source>
          <target state="translated">ロールバックされるトランザクションのトランザクション識別子。</target>
        </trans-unit>
        <trans-unit id="9eeef0c349968aef779233f9f813d33249bc7a83" translate="yes" xml:space="preserve">
          <source>The transaction isolation level cannot be changed after the first query or data-modification statement (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, or &lt;code&gt;COPY&lt;/code&gt;) of a transaction has been executed. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more information about transaction isolation and concurrency control.</source>
          <target state="translated">トランザクションの最初のクエリまたはデータ変更ステートメント（ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;FETCH&lt;/code&gt; 、または &lt;code&gt;COPY&lt;/code&gt; ）が実行された後は、トランザクション分離レベルを変更できません。トランザクションの分離と同時実行制御の詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ed3fff67b302c5509e4a3c68f6d878b34bcf063e" translate="yes" xml:space="preserve">
          <source>The transactional behavior of &lt;code&gt;RESET&lt;/code&gt; is the same as &lt;code&gt;SET&lt;/code&gt;: its effects will be undone by transaction rollback.</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; のトランザクション動作は &lt;code&gt;SET&lt;/code&gt; と同じです。その影響はトランザクションロールバックによって元に戻されます。</target>
        </trans-unit>
        <trans-unit id="75001c08db137e17c60a1922c998f38549cfd962" translate="yes" xml:space="preserve">
          <source>The translations from internal enum values to textual labels are kept in the system catalog &lt;a href=&quot;catalog-pg-enum&quot;&gt;&lt;code&gt;pg_enum&lt;/code&gt;&lt;/a&gt;. Querying this catalog directly can be useful.</source>
          <target state="translated">内部列挙値からテキストラベルへの変換は、システムカタログ&lt;a href=&quot;catalog-pg-enum&quot;&gt; &lt;code&gt;pg_enum&lt;/code&gt; に&lt;/a&gt;保持されます。このカタログを直接クエリすると便利です。</target>
        </trans-unit>
        <trans-unit id="d50a1ac1c4a79cbe553bfb51786402f941c2b3ba" translate="yes" xml:space="preserve">
          <source>The trigger can be specified to fire before the operation is attempted on a row (before constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; is attempted); or after the operation has completed (after constraints are checked and the &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; has completed); or instead of the operation (in the case of inserts, updates or deletes on a view). If the trigger fires before or instead of the event, the trigger can skip the operation for the current row, or change the row being inserted (for &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; operations only). If the trigger fires after the event, all changes, including the effects of other triggers, are &amp;ldquo;visible&amp;rdquo; to the trigger.</source>
          <target state="translated">トリガーは、操作が行で試行される前（制約がチェックされ、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; が試行される前）に起動するように指定できます。または操作が完了した後（制約がチェックされ、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; が完了した後）。または操作の代わりに（ビューでの挿入、更新、または削除の場合）。トリガーがイベントの前または代わりに起動する場合、トリガーは現在の行の操作をスキップするか、挿入される行を変更できます（ &lt;code&gt;INSERT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; の場合)操作のみ）。イベントの後にトリガーが起動すると、他のトリガーの影響を含むすべての変更がトリガーに「可視」になります。</target>
        </trans-unit>
        <trans-unit id="360ddad9a8de88b17738a1bfb31175dc0ad50509" translate="yes" xml:space="preserve">
          <source>The trigger definition is the same as before. Note that each &lt;code&gt;IF&lt;/code&gt; test must exactly match the &lt;code&gt;CHECK&lt;/code&gt; constraint for its child table.</source>
          <target state="translated">トリガーの定義は以前と同じです。各 &lt;code&gt;IF&lt;/code&gt; テストは、その子テーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約と正確に一致する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a810fcfc0902003d265053e230960c8ff8fc873c" translate="yes" xml:space="preserve">
          <source>The trigger firing mechanism is also affected by the configuration variable &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;. Simply enabled triggers (the default) will fire when the replication role is &amp;ldquo;origin&amp;rdquo; (the default) or &amp;ldquo;local&amp;rdquo;. Triggers configured as &lt;code&gt;ENABLE REPLICA&lt;/code&gt; will only fire if the session is in &amp;ldquo;replica&amp;rdquo; mode, and triggers configured as &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; will fire regardless of the current replication role.</source>
          <target state="translated">トリガー起動メカニズムは、構成変数&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_roleの&lt;/a&gt;影響も受けます。単純に有効化されたトリガー（デフォルト）は、レプリケーションの役割が「origin」（デフォルト）または「local」のときに起動します。 &lt;code&gt;ENABLE REPLICA&lt;/code&gt; として設定されたトリガーは、セッションが「レプリカ」モードの場合にのみ起動し、 &lt;code&gt;ENABLE ALWAYS&lt;/code&gt; として設定されたトリガーは、現在のレプリケーションロールに関係なく起動します。</target>
        </trans-unit>
        <trans-unit id="4f53bb9473c53f31ec2630d134ac2ab3b419880a" translate="yes" xml:space="preserve">
          <source>The trigger will only fire if at least one of the listed columns is mentioned as a target of the &lt;code&gt;UPDATE&lt;/code&gt; command or if one of the listed columns is a generated column that depends on a column that is the target of the &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">トリガーは、列挙された列の少なくとも一つが対象として言及された場合に発火する &lt;code&gt;UPDATE&lt;/code&gt; コマンドまたはリストされた列のいずれかの対象となるカラムに依存する生成列である場合 &lt;code&gt;UPDATE&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="33dc8fc66a104f662e1e1ef39564cf253e0b3d0e" translate="yes" xml:space="preserve">
          <source>The two characters must be separated by whitespace, and any leading or trailing whitespace on a line is ignored.</source>
          <target state="translated">2 つの文字は空白で区切る必要があり、行の先頭または末尾の空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="76e9af5cad39e06c0aff7fc7950d58905fea1d7b" translate="yes" xml:space="preserve">
          <source>The two common uses of the &lt;code&gt;COLLATE&lt;/code&gt; clause are overriding the sort order in an &lt;code&gt;ORDER BY&lt;/code&gt; clause, for example:</source>
          <target state="translated">&lt;code&gt;COLLATE&lt;/code&gt; 句の一般的な2つの使用法は、 &lt;code&gt;ORDER BY&lt;/code&gt; 句のソート順を上書きすることです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="35a38d5de3cd4f9280a434f729b41435ab278e27" translate="yes" xml:space="preserve">
          <source>The two ranking functions currently available are:</source>
          <target state="translated">現在利用できるランキング機能は以下の2つです。</target>
        </trans-unit>
        <trans-unit id="ce8dc1c8a536536645752666f7fffe721ce60a13" translate="yes" xml:space="preserve">
          <source>The two-parameter form of &lt;code&gt;obj_description&lt;/code&gt; returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; would retrieve the comment for the table with OID 123456. The one-parameter form of &lt;code&gt;obj_description&lt;/code&gt; requires only the object OID. It is deprecated since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</source>
          <target state="translated">&lt;code&gt;obj_description&lt;/code&gt; の2つのパラメーター形式は、OIDとそれを含むシステムカタログの名前で指定されたデータベースオブジェクトのコメントを返します。例えば、 &lt;code&gt;obj_description(123456,'pg_class')&lt;/code&gt; のいずれかのパラメータフォームOID 123456を持つテーブルにコメント検索なる &lt;code&gt;obj_description&lt;/code&gt; とは唯一のオブジェクトOIDを必要とします。 OIDが異なるシステムカタログ間で一意である保証がないため、非推奨です。したがって、誤ったコメントが返される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b4f339ae3cabb76936eb748863a60863a4f4f72e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;integer&lt;/code&gt; is the common choice, as it offers the best balance between range, storage size, and performance. The &lt;code&gt;smallint&lt;/code&gt; type is generally only used if disk space is at a premium. The &lt;code&gt;bigint&lt;/code&gt; type is designed to be used when the range of the &lt;code&gt;integer&lt;/code&gt; type is insufficient.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 型は、範囲、ストレージサイズ、およびパフォーマンスの間の最適なバランスを提供するため、一般的な選択です。 &lt;code&gt;smallint&lt;/code&gt; ディスクスペースが限られている場合にはタイプが一般的にのみ使用されます。 &lt;code&gt;bigint&lt;/code&gt; 型は、の範囲ときに使用されるように設計された &lt;code&gt;integer&lt;/code&gt; 型が不十分です。</target>
        </trans-unit>
        <trans-unit id="73f1593ff9d450e1b3a9d9ecf07b14639511ab2d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;numeric&lt;/code&gt; can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with &lt;code&gt;numeric&lt;/code&gt; values yield exact results where possible, e.g. addition, subtraction, multiplication. However, calculations on &lt;code&gt;numeric&lt;/code&gt; values are very slow compared to the integer types, or to the floating-point types described in the next section.</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 型は、非常に大きな桁数の数値を格納できます。正確な金額が必要な場合、金額やその他の数量を保存する場合に特に推奨されます。 &lt;code&gt;numeric&lt;/code&gt; 計算では、加算、減算、乗算など、可能な場合は正確な結果が得られます。ただし、 &lt;code&gt;numeric&lt;/code&gt; 計算は、整数型または次のセクションで説明する浮動小数点型と比較して非常に遅くなります。</target>
        </trans-unit>
        <trans-unit id="793233ae84eec2944804278e0981414a3f21b17d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;time with time zone&lt;/code&gt; is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, and &lt;code&gt;timestamp with time zone&lt;/code&gt; should provide a complete range of date/time functionality required by any application.</source>
          <target state="translated">タイプの &lt;code&gt;time with time zone&lt;/code&gt; SQL標準で定義されていますが、定義は疑問の有用性につながる特性を示します。ほとんどの場合、 &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;timestamp without time zone&lt;/code&gt; 、タイムスタンプと &lt;code&gt;timestamp with time zone&lt;/code&gt; ゾーンの組み合わせにより、アプリケーションで必要とされる完全な範囲の日付/時刻機能が提供されます。</target>
        </trans-unit>
        <trans-unit id="a7b02ae1d94b05c4445fedeab1d5ea2204949c69" translate="yes" xml:space="preserve">
          <source>The type being created is an array; this specifies the type of the array elements.</source>
          <target state="translated">作成される型は配列です;これは配列要素の型を指定します。</target>
        </trans-unit>
        <trans-unit id="dec7ae5dcf41bac97c38ef83c552012b75a666d1" translate="yes" xml:space="preserve">
          <source>The type names &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;serial4&lt;/code&gt; are equivalent: both create &lt;code&gt;integer&lt;/code&gt; columns. The type names &lt;code&gt;bigserial&lt;/code&gt; and &lt;code&gt;serial8&lt;/code&gt; work the same way, except that they create a &lt;code&gt;bigint&lt;/code&gt; column. &lt;code&gt;bigserial&lt;/code&gt; should be used if you anticipate the use of more than 2&lt;sup&gt;31&lt;/sup&gt; identifiers over the lifetime of the table. The type names &lt;code&gt;smallserial&lt;/code&gt; and &lt;code&gt;serial2&lt;/code&gt; also work the same way, except that they create a &lt;code&gt;smallint&lt;/code&gt; column.</source>
          <target state="translated">タイプ名 &lt;code&gt;serial&lt;/code&gt; と &lt;code&gt;serial4&lt;/code&gt; は同等です。どちらも &lt;code&gt;integer&lt;/code&gt; 列を作成します。型名 &lt;code&gt;bigserial&lt;/code&gt; と &lt;code&gt;serial8&lt;/code&gt; 作品同様、彼らが作成したことを除いて &lt;code&gt;bigint&lt;/code&gt; 列を。テーブルの存続期間中に2 &lt;sup&gt;31を&lt;/sup&gt;超える識別子の使用が予想される場合は、 &lt;code&gt;bigserial&lt;/code&gt; を使用する必要があります。タイプ名 &lt;code&gt;smallserial&lt;/code&gt; と &lt;code&gt;serial2&lt;/code&gt; も同じように機能しますが、 &lt;code&gt;smallint&lt;/code&gt; 列を作成する点が異なります。&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fe751081daba63125cfc111c4d7f7c5219b07dce" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;.</source>
          <target state="translated">列のタイプは、 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; と記述することによって参照されます。</target>
        </trans-unit>
        <trans-unit id="c0ea7f76717a65c02b1bddcb00950b7e9f4876d9" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a function independent of changes to the definition of a table.</source>
          <target state="translated">列のタイプは、 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; と記述することによって参照されます。この機能を使用すると、関数をテーブルの定義の変更から独立させることができます。</target>
        </trans-unit>
        <trans-unit id="b1ec982d03e7790491fadba1642490dfd8fdc55a" translate="yes" xml:space="preserve">
          <source>The type of a column is referenced by writing &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt;. Using this feature can sometimes help make a procedure independent of changes to the definition of a table.</source>
          <target state="translated">列のタイプは、 &lt;code&gt;table_name.column_name%TYPE&lt;/code&gt; と記述することによって参照されます。この機能を使用すると、プロシージャをテーブルの定義の変更から独立させることができます。</target>
        </trans-unit>
        <trans-unit id="f1e103307ad05526fdabd013a4e01ed05bfdbdb7" translate="yes" xml:space="preserve">
          <source>The type of event for which the backend is waiting, if any; otherwise NULL. Possible values are:</source>
          <target state="translated">バックエンドが待機しているイベントの種類を指定します。指定可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9f9f096a38b6430fd5ddb4a740ecb24f54b601d1" translate="yes" xml:space="preserve">
          <source>The type of format conversion to use to produce the format specifier's output. The following types are supported:</source>
          <target state="translated">フォーマット指定子の出力を生成するために使用するフォーマット変換のタイプ。以下のタイプがサポートされています。</target>
        </trans-unit>
        <trans-unit id="1ddd9e551f2a05479f6513f5110e44168eae5ec3" translate="yes" xml:space="preserve">
          <source>The type of object to which this label applies, as text.</source>
          <target state="translated">このラベルが適用されるオブジェクトのタイプをテキストとして指定します。</target>
        </trans-unit>
        <trans-unit id="e0efbb84b508511a8c55e93462baf31f477709c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;decimal&lt;/code&gt; and &lt;code&gt;numeric&lt;/code&gt; are equivalent. Both types are part of the SQL standard.</source>
          <target state="translated">&lt;code&gt;decimal&lt;/code&gt; と &lt;code&gt;numeric&lt;/code&gt; のタイプは同等です。どちらのタイプもSQL標準の一部です。</target>
        </trans-unit>
        <trans-unit id="929117e51025410290ad9a3ec11af66ca11a1c9b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt; store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.</source>
          <target state="translated">&lt;code&gt;smallint&lt;/code&gt; 、 &lt;code&gt;integer&lt;/code&gt; 、および &lt;code&gt;bigint&lt;/code&gt; 型は、さまざまな範囲の整数、つまり、小数部分のない数値を格納します。許容範囲外の値を保存しようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f88d1600c2fa8cf210ddde6767edf800fcc4b8ae" translate="yes" xml:space="preserve">
          <source>The unallocated space. New item identifiers are allocated from the start of this area, new items from the end.</source>
          <target state="translated">割り当てられていない領域。この領域の先頭から新しいアイテム識別子が割り当てられ、末尾から新しいアイテムが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="c6ac986319e3f5efca56837ce99d1572cef0217f" translate="yes" xml:space="preserve">
          <source>The underlying data type of the domain. This can include array specifiers.</source>
          <target state="translated">ドメインの基礎となるデータ型。これには配列指定子を含めることができます。</target>
        </trans-unit>
        <trans-unit id="b1d964b1947580871a9afde80dd70168c2a16dc4" translate="yes" xml:space="preserve">
          <source>The union and difference operators will fail if the resulting range would need to contain two disjoint sub-ranges, as such a range cannot be represented.</source>
          <target state="translated">結果として得られる範囲が2つの不連続なサブ範囲を含む必要がある場合,そのような範囲を表現することができないため,和演算子と差分演算子は失敗します.</target>
        </trans-unit>
        <trans-unit id="50b30c7a19cffa1de56e373435e89e8ef50ced95" translate="yes" xml:space="preserve">
          <source>The units kB, MB, GB and TB used by the functions &lt;code&gt;pg_size_pretty&lt;/code&gt; and &lt;code&gt;pg_size_bytes&lt;/code&gt; are defined using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024&lt;sup&gt;2&lt;/sup&gt; = 1048576 bytes, and so on.</source>
          <target state="translated">関数 &lt;code&gt;pg_size_pretty&lt;/code&gt; および &lt;code&gt;pg_size_bytes&lt;/code&gt; で使用される単位kB、MB、GB、およびTB は、10の累乗ではなく2の累乗を使用して定義されるため、1kBは1024バイト、1MBは1024 &lt;sup&gt;2&lt;/sup&gt; = 1048576バイトなどです。</target>
        </trans-unit>
        <trans-unit id="e4ae2c5b2eeaa2e69e79b5cb262b5458e41e3c91" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; as an operator name is deprecated. It may be disallowed altogether in a future release.</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; を演算子名として使用することは非推奨です。今後のリリースでは完全に禁止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="93c091c993d1f380ee067cec46b15b6ee688b73b" translate="yes" xml:space="preserve">
          <source>The use of explicit locking can increase the likelihood of &lt;em&gt;deadlocks&lt;/em&gt;, wherein two (or more) transactions each hold locks that the other wants. For example, if transaction 1 acquires an exclusive lock on table A and then tries to acquire an exclusive lock on table B, while transaction 2 has already exclusive-locked table B and now wants an exclusive lock on table A, then neither one can proceed. PostgreSQL automatically detects deadlock situations and resolves them by aborting one of the transactions involved, allowing the other(s) to complete. (Exactly which transaction will be aborted is difficult to predict and should not be relied upon.)</source>
          <target state="translated">明示的なロックを使用すると、&lt;em&gt;デッドロック&lt;/em&gt;が&lt;em&gt;発生&lt;/em&gt;する可能性が高くなります。この場合、2つ（またはそれ以上）のトランザクションがそれぞれ、他のトランザクションが必要とするロックを保持します。たとえば、トランザクション1がテーブルAの排他ロックを取得してからテーブルBの排他ロックを取得しようとした場合、トランザクション2はすでにテーブルBを排他ロックしていて、テーブルAの排他ロックが必要な場合、どちらも続行できません。 。 PostgreSQLはデッドロック状態を自動的に検出し、関連するトランザクションの1つを中止して解決し、他のトランザクションを完了させます。 （中止されるトランザクションを正確に予測することは困難であり、信頼するべきではありません。）</target>
        </trans-unit>
        <trans-unit id="8f0b3f4b5acb7da25097931a18b8f5ac621923d3" translate="yes" xml:space="preserve">
          <source>The use of huge pages results in smaller page tables and less CPU time spent on memory management, increasing performance. For more details about using huge pages on Linux, see &lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;Section 18.4.5&lt;/a&gt;.</source>
          <target state="translated">巨大なページを使用すると、ページテーブルが小さくなり、メモリ管理に費やされるCPU時間が少なくなり、パフォーマンスが向上します。Linuxでの巨大なページの使用の詳細については、&lt;a href=&quot;kernel-resources#LINUX-HUGE-PAGES&quot;&gt;セクション18.4.5を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3ce63f397bb5d8284bad24ef82b2459f7b090249" translate="yes" xml:space="preserve">
          <source>The use of this option is obsolete; all command-line options for server processes can be specified directly on the &lt;code&gt;postgres&lt;/code&gt; command line.</source>
          <target state="translated">このオプションの使用は廃止されました。サーバープロセスのすべてのコマンドラインオプションは、 &lt;code&gt;postgres&lt;/code&gt; コマンドラインで直接指定できます。</target>
        </trans-unit>
        <trans-unit id="09cf7166a8b226caae95159176b66ea236b91cf0" translate="yes" xml:space="preserve">
          <source>The user can select the commit mode of each transaction, so that it is possible to have both synchronous and asynchronous commit transactions running concurrently. This allows flexible trade-offs between performance and certainty of transaction durability. The commit mode is controlled by the user-settable parameter &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;, which can be changed in any of the ways that a configuration parameter can be set. The mode used for any one transaction depends on the value of &lt;code&gt;synchronous_commit&lt;/code&gt; when transaction commit begins.</source>
          <target state="translated">ユーザーは各トランザクションのコミットモードを選択できるため、同期と非同期の両方のコミットトランザクションを同時に実行できます。これにより、パフォーマンスとトランザクションの持続性の確実性との間の柔軟なトレードオフが可能になります。コミットモードは、ユーザーが設定可能なパラメーターの&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronized_commit&lt;/a&gt;によって制御されます。これは、構成パラメーターを設定する方法のいずれかで変更できます。1つのトランザクションで使用されるモードは、トランザクションのコミットが開始されるときの &lt;code&gt;synchronous_commit&lt;/code&gt; の値によって異なります。</target>
        </trans-unit>
        <trans-unit id="58fdb850f0b7e6f4f12d81d3a2ab809c8e564bba" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;EXECUTE&lt;/code&gt; privilege on the procedure in order to be allowed to invoke it.</source>
          <target state="translated">プロシージャの呼び出しを許可するには、プロシージャの &lt;code&gt;EXECUTE&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="c74ba756422b33951733fa9726163bde6e9f1367" translate="yes" xml:space="preserve">
          <source>The user must have &lt;code&gt;USAGE&lt;/code&gt; privilege for the procedural language, or must be a superuser if the language is untrusted. This is the same privilege requirement as for creating a function in the language.</source>
          <target state="translated">ユーザーは、手続き型言語の &lt;code&gt;USAGE&lt;/code&gt; 権限を持っているか、言語が信頼できない場合はスーパーユーザーである必要があります。これは、言語で関数を作成する場合と同じ特権要件です。</target>
        </trans-unit>
        <trans-unit id="7355b734bfbb693399b1f5be80a21fc683a4208f" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the domain.</source>
          <target state="translated">ドメインの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="5b67af9ba18fb81e51e55c777748aa943b2fa8e5" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the event trigger.</source>
          <target state="translated">イベントトリガーの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="aba5a7708c66551701c5165cf7ba963ffe31406d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign server.</source>
          <target state="translated">外国サーバーの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="e794753392792d29db630aab48374584b0d3cb46" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the foreign-data wrapper.</source>
          <target state="translated">外部データラッパーの新しい所有者のユーザー名です。</target>
        </trans-unit>
        <trans-unit id="9764aeef0fe4bb5d4f2272e77d6962230b353685" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the materialized view.</source>
          <target state="translated">マテリアライズされたビューの新しい所有者のユーザー名です。</target>
        </trans-unit>
        <trans-unit id="2b0e8f2639c9d0e1c0e8fa04963b62d2820b7705" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the publication.</source>
          <target state="translated">出版物の新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="2288b9ac65364d46e00039d4c94aae751493c3c0" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the sequence.</source>
          <target state="translated">シーケンスの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="d54654fb52ccc22d099e9d7662a28009ae6c974d" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the statistics object.</source>
          <target state="translated">統計オブジェクトの新しい所有者のユーザー名です。</target>
        </trans-unit>
        <trans-unit id="c69e3a3d77712ec7eadabb2257570bc879c31fe4" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the subscription.</source>
          <target state="translated">サブスクリプションの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="6566e54be9aa4e4a755e403ba928be2a78bd2f0e" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the table.</source>
          <target state="translated">テーブルの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="5465925abc46b022486e34924312d36ae3fb4555" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the type.</source>
          <target state="translated">タイプの新しい所有者のユーザー名。</target>
        </trans-unit>
        <trans-unit id="a6eb245257eeab851862782e2a923bbc7e47c8d6" translate="yes" xml:space="preserve">
          <source>The user name of the new owner of the view.</source>
          <target state="translated">ビューの新しいオーナーのユーザー名です。</target>
        </trans-unit>
        <trans-unit id="ead32115822b14f6c36ec30a49fc2050b45d7ff6" translate="yes" xml:space="preserve">
          <source>The user name to connect as</source>
          <target state="translated">として接続するユーザー名</target>
        </trans-unit>
        <trans-unit id="e907b500844d993a9893eddde6a23ad8e157309f" translate="yes" xml:space="preserve">
          <source>The user performing the lock on the view must have the corresponding privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the lock does not need any permissions on the underlying base relations.</source>
          <target state="translated">ビューのロックを実行するユーザーは、ビューに対応する権限を持っていなければなりません。さらに、ビューの所有者は、基本となるベースリレーションに関連する権限を持っていなければなりませんが、ロックを実行するユーザーは、基本となるベースリレーションの権限を必要としません。</target>
        </trans-unit>
        <trans-unit id="7bfd48e694dd153c1235989f4fbd645fdacfec80" translate="yes" xml:space="preserve">
          <source>The user that creates the function becomes the owner of the function.</source>
          <target state="translated">関数を作成したユーザーが関数のオーナーになります。</target>
        </trans-unit>
        <trans-unit id="96430e1e5477d00f6c76c64e1c8233d8001617e1" translate="yes" xml:space="preserve">
          <source>The user that creates the procedure becomes the owner of the procedure.</source>
          <target state="translated">プロシージャを作成したユーザーがプロシージャの所有者になります。</target>
        </trans-unit>
        <trans-unit id="fa24870d0f9c850e93790c8855a7b4579bd41481" translate="yes" xml:space="preserve">
          <source>The user who defines a text search configuration becomes its owner.</source>
          <target state="translated">テキスト検索設定を定義したユーザーがオーナーになります。</target>
        </trans-unit>
        <trans-unit id="f6d4088ee84ecfa3f7d22aab37f998c942ea2998" translate="yes" xml:space="preserve">
          <source>The user who defines a text search dictionary becomes its owner.</source>
          <target state="translated">テキスト検索辞書を定義したユーザが所有者となります。</target>
        </trans-unit>
        <trans-unit id="ba174285d0ec0c6de6eab2554bacc234f431f1f5" translate="yes" xml:space="preserve">
          <source>The user who defines an operator class becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator class definition could confuse or even crash the server.)</source>
          <target state="translated">演算子クラスを定義したユーザがその所有者になります。現在のところ、作成するユーザはスーパーユーザでなければなりません。(この制限は、誤った演算子クラスの定義がサーバを混乱させたり、クラッシュさせたりする可能性があるために行われています)。</target>
        </trans-unit>
        <trans-unit id="fbdfed285f07a1cecc02c081ebab06c65c95b2f7" translate="yes" xml:space="preserve">
          <source>The user who defines an operator family becomes its owner. Presently, the creating user must be a superuser. (This restriction is made because an erroneous operator family definition could confuse or even crash the server.)</source>
          <target state="translated">演算子ファミリを定義したユーザがその所有者になります。現在のところ、作成するユーザはスーパーユーザでなければなりません。(この制限は、誤った演算子ファミリの定義がサーバを混乱させたり、クラッシュさせたりする可能性があるために行われています)。</target>
        </trans-unit>
        <trans-unit id="a49e64af112af0fce66c24196c6a87dd37d8a41a" translate="yes" xml:space="preserve">
          <source>The user's client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.</source>
          <target state="translated">データベース操作を実行したいユーザーのクライアント(フロントエンド)アプリケーション。クライアントアプリケーションは非常に多様な性質を持っています。クライアントアプリケーションの中にはPostgreSQLの配布物で提供されているものもありますが、ほとんどはユーザが開発したものです。</target>
        </trans-unit>
        <trans-unit id="4b80e8348cd40d70e9a3578f00476d222916ac1c" translate="yes" xml:space="preserve">
          <source>The user's personal startup file is named &lt;code&gt;.psqlrc&lt;/code&gt; and is sought in the invoking user's home directory. On Windows, which lacks such a concept, the personal startup file is named &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt;. The location of the user's startup file can be set explicitly via the &lt;code&gt;PSQLRC&lt;/code&gt; environment variable.</source>
          <target state="translated">ユーザーの個人用スタートアップファイルの名前は &lt;code&gt;.psqlrc&lt;/code&gt; で、呼び出し元のユーザーのホームディレクトリで検索されます。そのような概念を欠いているWindowsでは、個人用スタートアップファイルの名前は &lt;code&gt;%APPDATA%\postgresql\psqlrc.conf&lt;/code&gt; です。ユーザーのスタートアップファイルの場所は、 &lt;code&gt;PSQLRC&lt;/code&gt; 環境変数を使用して明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="3920cf489a63459b72dde1b92f7b717a8e6b52fd" translate="yes" xml:space="preserve">
          <source>The user, database, and (client) host items remain the same for the life of the client connection, but the activity indicator changes. The activity can be &lt;code&gt;idle&lt;/code&gt; (i.e., waiting for a client command), &lt;code&gt;idle in transaction&lt;/code&gt; (waiting for client inside a &lt;code&gt;BEGIN&lt;/code&gt; block), or a command type name such as &lt;code&gt;SELECT&lt;/code&gt;. Also, &lt;code&gt;waiting&lt;/code&gt; is appended if the server process is presently waiting on a lock held by another session. In the above example we can infer that process 15606 is waiting for process 15610 to complete its transaction and thereby release some lock. (Process 15610 must be the blocker, because there is no other active session. In more complicated cases it would be necessary to look into the &lt;a href=&quot;view-pg-locks&quot;&gt;&lt;code&gt;pg_locks&lt;/code&gt;&lt;/a&gt; system view to determine who is blocking whom.)</source>
          <target state="translated">ユーザー、データベース、および（クライアント）ホスト項目は、クライアント接続の存続期間中は同じままですが、アクティビティインジケーターが変化します。アクティビティは &lt;code&gt;idle&lt;/code&gt; （つまり、クライアントコマンドを待機）、 &lt;code&gt;idle in transaction&lt;/code&gt; でアイドル（ &lt;code&gt;BEGIN&lt;/code&gt; ブロック内でクライアントを待機）、または &lt;code&gt;SELECT&lt;/code&gt; などのコマンドタイプ名にすることができます。また、サーバープロセスが現在別のセッションによって保持されているロックを待機している場合は、 &lt;code&gt;waiting&lt;/code&gt; が追加されます。上記の例では、プロセス15606がプロセス15610がトランザクションを完了してロックを解放するのを待っていると推測できます。 （プロセス15610は、他にアクティブなセッションがないため、ブロッカーである必要があります。より複雑なケースでは、&lt;a href=&quot;view-pg-locks&quot;&gt; &lt;code&gt;pg_locks&lt;/code&gt; &lt;/a&gt;を調べる必要があります。 誰が誰をブロックしているかを判断するためのシステムビュー。）</target>
        </trans-unit>
        <trans-unit id="13392321669f2c3fc39fecf0f89fb41cca2076a4" translate="yes" xml:space="preserve">
          <source>The usual comparison operators are available, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;Table 9.1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-OP-TABLE&quot;&gt;表9.1に&lt;/a&gt;示すように、通常の比較演算子を使用できます。</target>
        </trans-unit>
        <trans-unit id="06a88b4eddcbb8d26f5f678e56a78a9bd14190d1" translate="yes" xml:space="preserve">
          <source>The usual goal of routine vacuuming is to do standard &lt;code&gt;VACUUM&lt;/code&gt;s often enough to avoid needing &lt;code&gt;VACUUM FULL&lt;/code&gt;. The autovacuum daemon attempts to work this way, and in fact will never issue &lt;code&gt;VACUUM FULL&lt;/code&gt;. In this approach, the idea is not to keep tables at their minimum size, but to maintain steady-state usage of disk space: each table occupies space equivalent to its minimum size plus however much space gets used up between vacuumings. Although &lt;code&gt;VACUUM FULL&lt;/code&gt; can be used to shrink a table back to its minimum size and return the disk space to the operating system, there is not much point in this if the table will just grow again in the future. Thus, moderately-frequent standard &lt;code&gt;VACUUM&lt;/code&gt; runs are a better approach than infrequent &lt;code&gt;VACUUM FULL&lt;/code&gt; runs for maintaining heavily-updated tables.</source>
          <target state="translated">ルーチンのバキューム処理の通常の目標は、 &lt;code&gt;VACUUM FULL&lt;/code&gt; の必要を回避するのに十分な頻度で標準の &lt;code&gt;VACUUM&lt;/code&gt; を実行することです。 autovacuumデーモンはこの方法で動作しようとし、実際には &lt;code&gt;VACUUM FULL&lt;/code&gt; を発行しません。このアプローチでは、アイデアはテーブルを最小サイズに維持するのではなく、ディスクスペースの定常状態の使用を維持することです。各テーブルは、最小サイズに相当するスペースに加えて、バキューム処理の間に多くのスペースが使用されます。が、 &lt;code&gt;VACUUM FULL&lt;/code&gt; は、その最小サイズにテーブルの背中を縮小し、オペレーティングシステムにディスク領域を返すために使用することができ、テーブルだけで、将来的に再び成長する場合は、この中に多くのポイントがありません。したがって、適度に頻繁な標準の &lt;code&gt;VACUUM&lt;/code&gt; 頻繁に更新されるテーブルを維持するために、実行はまれな &lt;code&gt;VACUUM FULL&lt;/code&gt; 実行よりも優れたアプローチです。</target>
        </trans-unit>
        <trans-unit id="8705eeb4c73510ec550152d0313d6eeffdb4ff7a" translate="yes" xml:space="preserve">
          <source>The usual interpretation of the &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; fields is that they identify the left and right input types of the operator(s) that a particular support function supports. For some access methods these match the input data type(s) of the support function itself, for others not. There is a notion of &amp;ldquo;default&amp;rdquo; support functions for an index, which are those with &lt;code&gt;amproclefttype&lt;/code&gt; and &lt;code&gt;amprocrighttype&lt;/code&gt; both equal to the index operator class's &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;amproclefttype&lt;/code&gt; および &lt;code&gt;amprocrighttype&lt;/code&gt; フィールドの通常の解釈は、特定のサポート関数がサポートする演算子の左右の入力タイプを識別するというものです。一部のアクセス方式では、これらはサポート関数自体の入力データ型と一致しますが、それ以外の場合は一致しません。インデックスには「デフォルト」のサポート関数という概念があります。これは、 &lt;code&gt;amproclefttype&lt;/code&gt; と &lt;code&gt;amprocrighttype&lt;/code&gt; がどちらもインデックス演算子クラスの &lt;code&gt;opcintype&lt;/code&gt; と等しい関数です。</target>
        </trans-unit>
        <trans-unit id="675415fe7638319c8a05abc3d9aab113c5086abb" translate="yes" xml:space="preserve">
          <source>The usual logical operators are available:</source>
          <target state="translated">通常の論理演算子が利用できます。</target>
        </trans-unit>
        <trans-unit id="410b768bdab1d606d84345d16fb594b86774dec4" translate="yes" xml:space="preserve">
          <source>The utility command &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; can be used to start and shut down the &lt;code&gt;postgres&lt;/code&gt; server safely and comfortably.</source>
          <target state="translated">ユーティリティコマンド&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;を使用して、 &lt;code&gt;postgres&lt;/code&gt; サーバーを安全かつ快適に起動およびシャットダウンできます。</target>
        </trans-unit>
        <trans-unit id="914a00521ee94634aa555f79070e426ade88941f" translate="yes" xml:space="preserve">
          <source>The value can range from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;10000000000&lt;/code&gt;. When &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, index scans are never skipped during &lt;code&gt;VACUUM&lt;/code&gt; cleanup. The default value is &lt;code&gt;0.1&lt;/code&gt;.</source>
          <target state="translated">値の範囲とすることができる &lt;code&gt;0&lt;/code&gt; に &lt;code&gt;10000000000&lt;/code&gt; 。 &lt;code&gt;vacuum_cleanup_index_scale_factor&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; に設定されている場合、 &lt;code&gt;VACUUM&lt;/code&gt; クリーンアップ中にインデックススキャンがスキップされることはありません。デフォルト値は &lt;code&gt;0.1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="82bae1585ba067ff6aabd9ec822fffc256ffef0f" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;dynamic_library_path&lt;/code&gt; must be a list of absolute directory paths separated by colons (or semi-colons on Windows). If a list element starts with the special string &lt;code&gt;$libdir&lt;/code&gt;, the compiled-in PostgreSQL package library directory is substituted for &lt;code&gt;$libdir&lt;/code&gt;; this is where the modules provided by the standard PostgreSQL distribution are installed. (Use &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; to find out the name of this directory.) For example:</source>
          <target state="translated">&lt;code&gt;dynamic_library_path&lt;/code&gt; の値は、コロン（またはWindowsではセミコロン）で区切られた絶対ディレクトリー・パスのリストでなければなりません。リスト要素が特殊な文字列 &lt;code&gt;$libdir&lt;/code&gt; で始まる場合、コンパイルされたPostgreSQLパッケージライブラリディレクトリが &lt;code&gt;$libdir&lt;/code&gt; 置き換えられます。ここには、標準のPostgreSQLディストリビューションによって提供されるモジュールがインストールされます。（このディレクトリの名前を確認するには、 &lt;code&gt;pg_config --pkglibdir&lt;/code&gt; を使用します。）例：</target>
        </trans-unit>
        <trans-unit id="e2ece96ce583cb594781fa18e96e90c23a241cb2" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;search_path&lt;/code&gt; must be a comma-separated list of schema names. Any name that is not an existing schema, or is a schema for which the user does not have &lt;code&gt;USAGE&lt;/code&gt; permission, is silently ignored.</source>
          <target state="translated">&lt;code&gt;search_path&lt;/code&gt; の値は、スキーマ名のコンマ区切りのリストでなければなりません。既存のスキーマではない名前、またはユーザーが &lt;code&gt;USAGE&lt;/code&gt; 権限を持たないスキーマである名前は、警告なしで無視されます。</target>
        </trans-unit>
        <trans-unit id="1885fd3acbde2dfc55224cb44032743ea0749cf2" translate="yes" xml:space="preserve">
          <source>The value is a list of names of tablespaces. When there is more than one name in the list, PostgreSQL chooses a random member of the list each time a temporary object is to be created; except that within a transaction, successively created temporary objects are placed in successive tablespaces from the list. If the selected element of the list is an empty string, PostgreSQL will automatically use the default tablespace of the current database instead.</source>
          <target state="translated">値はテーブル空間の名前のリストです。リストに複数の名前がある場合、PostgreSQLは一時オブジェクトを作成するたびにリストのランダムなメンバを選択します。リストの選択された要素が空の文字列の場合、PostgreSQLは自動的に現在のデータベースのデフォルトのテーブル空間を代わりに使用します。</target>
        </trans-unit>
        <trans-unit id="99c82c62699420580e0ce37ee3df7912c1dd98bf" translate="yes" xml:space="preserve">
          <source>The value is either the name of a tablespace, or an empty string to specify using the default tablespace of the current database. If the value does not match the name of any existing tablespace, PostgreSQL will automatically use the default tablespace of the current database. If a nondefault tablespace is specified, the user must have &lt;code&gt;CREATE&lt;/code&gt; privilege for it, or creation attempts will fail.</source>
          <target state="translated">値は、テーブルスペースの名前、または現在のデータベースのデフォルトのテーブルスペースを使用して指定する空の文字列のいずれかです。値が既存のテーブルスペースの名前と一致しない場合、PostgreSQLは現在のデータベースのデフォルトのテーブルスペースを自動的に使用します。デフォルト以外のテーブルスペースが指定されている場合、ユーザーはそのテーブルスペースに対する &lt;code&gt;CREATE&lt;/code&gt; 権限を持っている必要があります。そうでない場合、作成は失敗します。</target>
        </trans-unit>
        <trans-unit id="35739a3ab0eff8d38722337e2254ec6c774352ae" translate="yes" xml:space="preserve">
          <source>The value might be quoted and schema-qualified. If no collation is derived for the argument expression, then a null value is returned. If the argument is not of a collatable data type, then an error is raised.</source>
          <target state="translated">値は引用符で囲まれ、スキーマ修飾されている場合があります。引数式の照合が行われていない場合、NULL値が返されます。引数が照合可能なデータ型でない場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="39c36934ef87435e122aa28a1e5f5b7fbbf50ca7" translate="yes" xml:space="preserve">
          <source>The value of either of these directories that is appropriate for the installation can be found out using &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;.</source>
          <target state="translated">インストールに適切なこれらのディレクトリのいずれかの値は、&lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt;を使用して見つけることができます。</target>
        </trans-unit>
        <trans-unit id="48b58f404c5ab41a010c449c8600d4f12fc88c78" translate="yes" xml:space="preserve">
          <source>The value of the last affected OID, as returned from an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;\lo_import&lt;/code&gt; command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. PostgreSQL servers since version 12 do not support OID system columns anymore, thus LASTOID will always be 0 following &lt;code&gt;INSERT&lt;/code&gt; when targeting such servers.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;\lo_import&lt;/code&gt; コマンドから返された、最後に影響を受けたOIDの値。この変数は、次のSQLコマンドの結果が表示されるまで有効であることが保証されています。バージョン12以降のPostgreSQLサーバーはOIDシステム列をサポートしなくなったため、そのようなサーバーを対象とする場合、 &lt;code&gt;INSERT&lt;/code&gt; の後のLASTOIDは常に0になります。</target>
        </trans-unit>
        <trans-unit id="c651921fd6703938e12fa970227922443e260428" translate="yes" xml:space="preserve">
          <source>The value of the psql variable &lt;code&gt;name&lt;/code&gt;. See the section &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; for details.</source>
          <target state="translated">psql変数 &lt;code&gt;name&lt;/code&gt; の値。詳細については、&lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;変数&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7cad357760c4befedd7f8fdaa593e68c359c8118" translate="yes" xml:space="preserve">
          <source>The value of the selected prompt variable is printed literally, except where a percent sign (&lt;code&gt;%&lt;/code&gt;) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are:</source>
          <target state="translated">選択したプロンプト変数の値は、パーセント記号（ &lt;code&gt;%&lt;/code&gt; ）が出現する場合を除いて、文字どおりに出力されます。次の文字に応じて、特定の他のテキストが代わりに置換されます。定義されている置換は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="68c0a0ed9f32ba0a19ec5847f3fbe4958f014ea1" translate="yes" xml:space="preserve">
          <source>The value of this parameter overrides the &lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt; setting. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">このパラメーターの値は、&lt;a href=&quot;runtime-config-wal#GUC-SYNCHRONOUS-COMMIT&quot;&gt;synchronous_commit&lt;/a&gt;設定をオーバーライドします。デフォルト値は &lt;code&gt;off&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1a4243c2cf710a88b014f758bc5617eddee2438a" translate="yes" xml:space="preserve">
          <source>The value to use for &lt;code&gt;old_version&lt;/code&gt; is determined by the extension's author, and might vary if there is more than one version of the old-style module that can be upgraded into an extension. For the standard additional modules supplied with pre-9.1 PostgreSQL, use &lt;code&gt;unpackaged&lt;/code&gt; for &lt;code&gt;old_version&lt;/code&gt; when updating a module to extension style.</source>
          <target state="translated">&lt;code&gt;old_version&lt;/code&gt; に使用する値は拡張機能の作成者によって決定され、拡張機能にアップグレードできる旧式のモジュールのバージョンが複数ある場合は異なる場合があります。9.1より前のPostgreSQLでは付属の標準の追加のモジュールについては、使用 &lt;code&gt;unpackaged&lt;/code&gt; ため &lt;code&gt;old_version&lt;/code&gt; 拡張スタイルにモジュールを更新するとき。</target>
        </trans-unit>
        <trans-unit id="29a25a9c8e901cbf1e213381b2fe324bdafd7520" translate="yes" xml:space="preserve">
          <source>The value to use for a template-specific option. If the value is not a simple identifier or number, it must be quoted (but you can always quote it, if you wish).</source>
          <target state="translated">テンプ レー ト 固有のオプシ ョ ンに用いたい値。値が単純な識別子や数値でない場合は、引用符で囲む必要があります (ただし、いつでも引用符で囲むことができます)。</target>
        </trans-unit>
        <trans-unit id="97aba03e4cf10e442611ec122abb257717947453" translate="yes" xml:space="preserve">
          <source>The values in each record are separated by the &lt;code&gt;DELIMITER&lt;/code&gt; character. If the value contains the delimiter character, the &lt;code&gt;QUOTE&lt;/code&gt; character, the &lt;code&gt;NULL&lt;/code&gt; string, a carriage return, or line feed character, then the whole value is prefixed and suffixed by the &lt;code&gt;QUOTE&lt;/code&gt; character, and any occurrence within the value of a &lt;code&gt;QUOTE&lt;/code&gt; character or the &lt;code&gt;ESCAPE&lt;/code&gt; character is preceded by the escape character. You can also use &lt;code&gt;FORCE_QUOTE&lt;/code&gt; to force quotes when outputting non-&lt;code&gt;NULL&lt;/code&gt; values in specific columns.</source>
          <target state="translated">各レコードの値は、 &lt;code&gt;DELIMITER&lt;/code&gt; 文字で区切られます。値に区切り文字、 &lt;code&gt;QUOTE&lt;/code&gt; 文字、 &lt;code&gt;NULL&lt;/code&gt; 文字列、キャリッジリターン、またはラインフィード文字が含まれている場合、 &lt;code&gt;QUOTE&lt;/code&gt; 文字、および &lt;code&gt;QUOTE&lt;/code&gt; 文字または &lt;code&gt;ESCAPE&lt;/code&gt; 文字の前にはエスケープ文字が付いています。 &lt;code&gt;FORCE_QUOTE&lt;/code&gt; を使用して、特定の列に &lt;code&gt;NULL&lt;/code&gt; 以外の値を出力するときに引用符を強制することもできます。</target>
        </trans-unit>
        <trans-unit id="08d03d5b23111b07a76c7aeb9df7ffb0e8eb87a7" translate="yes" xml:space="preserve">
          <source>The values stored in the free space map are not exact. They're rounded to precision of 1/256th of &lt;code&gt;BLCKSZ&lt;/code&gt; (32 bytes with default &lt;code&gt;BLCKSZ&lt;/code&gt;), and they're not kept fully up-to-date as tuples are inserted and updated.</source>
          <target state="translated">空き領域マップに格納されている値は正確ではありません。それらは &lt;code&gt;BLCKSZ&lt;/code&gt; の1/256分の精度（デフォルトは &lt;code&gt;BLCKSZ&lt;/code&gt; で 32バイト）に丸められ、タプルが挿入および更新されるときに完全に最新の状態に保たれません。</target>
        </trans-unit>
        <trans-unit id="b6c08b4507fc75b276335a79d4dd41a78fcf9ac5" translate="yes" xml:space="preserve">
          <source>The variants to add and drop attributes are part of the SQL standard; the other variants are PostgreSQL extensions.</source>
          <target state="translated">属性を追加したり削除したりするバリアントはSQL標準の一部であり、他のバリアントはPostgreSQLの拡張です。</target>
        </trans-unit>
        <trans-unit id="90629b5d606371db9e2f9a38b9c003515b5bf970" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;\d&lt;/code&gt; commands accept a &lt;code&gt;pattern&lt;/code&gt; parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, &lt;code&gt;\dt FOO&lt;/code&gt; will display the table named &lt;code&gt;foo&lt;/code&gt;. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; will display the table named &lt;code&gt;FOO&quot;BAR&lt;/code&gt; (not &lt;code&gt;foo&quot;bar&lt;/code&gt;). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; will display the table named &lt;code&gt;fooFOObar&lt;/code&gt;.</source>
          <target state="translated">さまざまな &lt;code&gt;\d&lt;/code&gt; コマンドは、表示するオブジェクト名を指定する &lt;code&gt;pattern&lt;/code&gt; パラメータを受け入れます。最も単純なケースでは、パターンはオブジェクトの正確な名前です。パターン内の文字は通常、SQL名と同様に小文字に変換されます。たとえば、 &lt;code&gt;\dt FOO&lt;/code&gt; は &lt;code&gt;foo&lt;/code&gt; という名前のテーブルを表示します。 SQL名と同様に、パターンを二重引用符で囲むと、小文字に変換されなくなります。パターンに実際の二重引用符文字を含める必要がある場合は、二重引用符シーケンス内に二重引用符のペアとして記述します。繰り返しになりますが、これはSQLの引用識別子のルールと一致しています。たとえば、 &lt;code&gt;\dt &quot;FOO&quot;&quot;BAR&quot;&lt;/code&gt; は、 &lt;code&gt;FOO&quot;BAR&lt;/code&gt; （ &lt;code&gt;foo&quot;bar&lt;/code&gt; ）。SQL名の通常の規則とは異なり、パターンの一部のみを二重引用符で囲むことができます。たとえば、 &lt;code&gt;\dt FOO&quot;FOO&quot;BAR&lt;/code&gt; は、 &lt;code&gt;fooFOObar&lt;/code&gt; という名前のテーブルを表示します。</target>
        </trans-unit>
        <trans-unit id="7768758b3213c172e932c01f8e8da70daa4ada7f" translate="yes" xml:space="preserve">
          <source>The various containment and existence operators, along with all other JSON operators and functions are documented in &lt;a href=&quot;functions-json&quot;&gt;Section 9.15&lt;/a&gt;.</source>
          <target state="translated">さまざまな包含演算子および存在演算子、およびその他のすべてのJSON演算子と関数については、&lt;a href=&quot;functions-json&quot;&gt;セクション9.15で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="4e179b7076409c4b105a612d7c9bb99b67e607cd" translate="yes" xml:space="preserve">
          <source>The verbatim query string submitted to declare this cursor</source>
          <target state="translated">このカーソルを宣言するために送信された verbatim クエリ文字列</target>
        </trans-unit>
        <trans-unit id="91cb72e2fa3dca24da98249febe148f7555e66ba" translate="yes" xml:space="preserve">
          <source>The version of the extension to install. This can be written as either an identifier or a string literal. The default version is whatever is specified in the extension's control file.</source>
          <target state="translated">インストールする拡張機能のバージョン。これは識別子か文字列リテラルのどちらかで書くことができます。デフォルトのバージョンは、拡張機能のコントロールファイルで指定されたものです。</target>
        </trans-unit>
        <trans-unit id="1f466ef09b06001ef2dbe51d7e047e29feba87d5" translate="yes" xml:space="preserve">
          <source>The vertical header, displayed as the leftmost column, contains the values found in column &lt;code&gt;colV&lt;/code&gt;, in the same order as in the query results, but with duplicates removed.</source>
          <target state="translated">左端の列として表示される垂直ヘッダーには、列 &lt;code&gt;colV&lt;/code&gt; で見つかった値がクエリ結果と同じ順序で含まれていますが、重複は削除されています。</target>
        </trans-unit>
        <trans-unit id="0adcabe9624ff122085bfba5e28081fdc88cd247" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_config&lt;/code&gt; describes the compile-time configuration parameters of the currently installed version of PostgreSQL. It is intended, for example, to be used by software packages that want to interface to PostgreSQL to facilitate finding the required header files and libraries. It provides the same basic information as the &lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQL client application.</source>
          <target state="translated">ビュー &lt;code&gt;pg_config&lt;/code&gt; は、現在インストールされているバージョンのPostgreSQLのコンパイル時の構成パラメーターを示します。たとえば、必要なヘッダーファイルとライブラリの検索を容易にするためにPostgreSQLとのインターフェースを必要とするソフトウェアパッケージで使用することを目的としています。&lt;a href=&quot;app-pgconfig&quot;&gt;pg_config&lt;/a&gt; PostgreSQLクライアントアプリケーションと同じ基本情報を提供します。</target>
        </trans-unit>
        <trans-unit id="08ea6b2cfb240aa2a36ba0270a0c6bfcfe867503" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_file_settings&lt;/code&gt; provides a summary of the contents of the server's configuration file(s). A row appears in this view for each &amp;ldquo;name = value&amp;rdquo; entry appearing in the files, with annotations indicating whether the value could be applied successfully. Additional row(s) may appear for problems not linked to a &amp;ldquo;name = value&amp;rdquo; entry, such as syntax errors in the files.</source>
          <target state="translated">&lt;code&gt;pg_file_settings&lt;/code&gt; ビューはサーバーの設定ファイルの内容の要約を提供します。このビューには、ファイルに表示される「name = value」エントリごとに行が表示され、値が正常に適用されたかどうかを示す注釈が付いています。ファイルの構文エラーなど、「name = value」エントリにリンクされていない問題については、追加の行が表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="63d33a4b341777d328dc2c1f214857e8874dc6d9" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_group&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows the names and members of all roles that are marked as not &lt;code&gt;rolcanlogin&lt;/code&gt;, which is an approximation to the set of roles that are being used as groups.</source>
          <target state="translated">&lt;code&gt;pg_group&lt;/code&gt; ビューは、下位互換性のために存在します。これは、バージョン8.1より前のPostgreSQLに存在していたカタログをエミュレートします。これには、 &lt;code&gt;rolcanlogin&lt;/code&gt; ではないとマークされているすべてのロールの名前とメンバーが表示されます。これは、グループとして使用されている一連のロールの近似値です。</target>
        </trans-unit>
        <trans-unit id="6dadc8f5b62fc6f506c2d65eb8b07e558e7c8b3f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_hba_file_rules&lt;/code&gt; provides a summary of the contents of the client authentication configuration file, &lt;code&gt;pg_hba.conf&lt;/code&gt;. A row appears in this view for each non-empty, non-comment line in the file, with annotations indicating whether the rule could be applied successfully.</source>
          <target state="translated">ビュー &lt;code&gt;pg_hba_file_rules&lt;/code&gt; は、クライアント認証構成ファイル &lt;code&gt;pg_hba.conf&lt;/code&gt; の内容の要約を提供します。このビューでは、ファイル内の空ではない、コメント行ではない行ごとに、ルールが正常に適用されたかどうかを示す注釈とともに行が表示されます。</target>
        </trans-unit>
        <trans-unit id="aac1873f6d2161781d725af8550ac62cddd3ae8a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_indexes&lt;/code&gt; provides access to useful information about each index in the database.</source>
          <target state="translated">ビュー &lt;code&gt;pg_indexes&lt;/code&gt; は、データベース内の各インデックスに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="c4a5f88ab67e15b0fb81ed88eb1f6933ddc8f95f" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_locks&lt;/code&gt; provides access to information about the locks held by active processes within the database server. See &lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;Chapter 13&lt;/a&gt; for more discussion of locking.</source>
          <target state="translated">ビュー &lt;code&gt;pg_locks&lt;/code&gt; データベースサーバ内のアクティブなプロセスが保持しているロックに関する情報へのアクセスを提供します。ロックの詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/mvcc.html&quot;&gt;第13章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="042974f73615dd15fc09c5129e6b33aeeef53099" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_matviews&lt;/code&gt; provides access to useful information about each materialized view in the database.</source>
          <target state="translated">ビュー &lt;code&gt;pg_matviews&lt;/code&gt; データベース内の各マテリアライズド・ビューに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="f35ab0d9ea2df46d55f4f8845455de38e126b0e5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_policies&lt;/code&gt; provides access to useful information about each row-level security policy in the database.</source>
          <target state="translated">ビュー &lt;code&gt;pg_policies&lt;/code&gt; は、データベースの各行レベルのセキュリティポリシーに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="43d0e1b7a1af60f6a8bef0840cbf55e0cd1189ae" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_prepared_xacts&lt;/code&gt; displays information about transactions that are currently prepared for two-phase commit (see &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; for details).</source>
          <target state="translated">ビュー &lt;code&gt;pg_prepared_xacts&lt;/code&gt; は、2フェーズコミットのために現在準備されているトランザクションに関する情報を表示します（詳細は&lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="5890e8d1e9f41b0cd60cd417fec506b423153a1c" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_publication_tables&lt;/code&gt; provides information about the mapping between publications and the tables they contain. Unlike the underlying catalog &lt;code&gt;pg_publication_rel&lt;/code&gt;, this view expands publications defined as &lt;code&gt;FOR ALL TABLES&lt;/code&gt;, so for such publications there will be a row for each eligible table.</source>
          <target state="translated">ビュー &lt;code&gt;pg_publication_tables&lt;/code&gt; は、パブリケーションとそれに含まれるテーブルの間のマッピングに関する情報を提供します。基礎となるカタログ &lt;code&gt;pg_publication_rel&lt;/code&gt; とは異なり、このビューは &lt;code&gt;FOR ALL TABLES&lt;/code&gt; として定義されたパブリケーションを展開するため、そのようなパブリケーションの場合は、適格なテーブルごとに行が存在します。</target>
        </trans-unit>
        <trans-unit id="e6f8a891f9c67ef2b6de308cc7563907a8fbe06b" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_roles&lt;/code&gt; provides access to information about database roles. This is simply a publicly readable view of &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">&lt;code&gt;pg_roles&lt;/code&gt; ビューは、データベースの役割に関する情報へのアクセスを提供します。これは単に&lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; の&lt;/a&gt;一般に読み取り可能なビューであり、パスワードフィールドを空白にしています。</target>
        </trans-unit>
        <trans-unit id="be02d2530abee0307e3d8c75ed7462d6006d37d5" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_rules&lt;/code&gt; provides access to useful information about query rewrite rules.</source>
          <target state="translated">ビュー &lt;code&gt;pg_rules&lt;/code&gt; は、クエリ書き換えルールに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="8abbf138d7583623930f0cc0e4290da9934bc84a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_seclabels&lt;/code&gt; provides information about security labels. It as an easier-to-query version of the &lt;a href=&quot;catalog-pg-seclabel&quot;&gt;&lt;code&gt;pg_seclabel&lt;/code&gt;&lt;/a&gt; catalog.</source>
          <target state="translated">&lt;code&gt;pg_seclabels&lt;/code&gt; ビューはセキュリティラベルに関する情報を提供します。これは&lt;a href=&quot;catalog-pg-seclabel&quot;&gt; &lt;code&gt;pg_seclabel&lt;/code&gt; &lt;/a&gt;カタログのクエリしやすいバージョンです。</target>
        </trans-unit>
        <trans-unit id="9de8f57dd43c6ec5ae63346c8a1f92176c16d0d1" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_sequences&lt;/code&gt; provides access to useful information about each sequence in the database.</source>
          <target state="translated">ビュー &lt;code&gt;pg_sequences&lt;/code&gt; は、データベース内の各シーケンスに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="25e4f3261aeb43d1f5668204f1fb62fa4677a0bd" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_settings&lt;/code&gt; provides access to run-time parameters of the server. It is essentially an alternative interface to the &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; and &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; commands. It also provides access to some facts about each parameter that are not directly available from &lt;code&gt;SHOW&lt;/code&gt;, such as minimum and maximum values.</source>
          <target state="translated">&lt;code&gt;pg_settings&lt;/code&gt; ビューは、サーバーのランタイムパラメーターへのアクセスを提供します。これは基本的に、&lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt;コマンドと&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;コマンドの代替インターフェースです。また、最小値や最大値など、 &lt;code&gt;SHOW&lt;/code&gt; から直接使用できない各パラメーターに関するいくつかの事実へのアクセスも提供します。</target>
        </trans-unit>
        <trans-unit id="7729b5ec7977be5f90c3408f6cef81a593faa4de" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_shadow&lt;/code&gt; exists for backwards compatibility: it emulates a catalog that existed in PostgreSQL before version 8.1. It shows properties of all roles that are marked as &lt;code&gt;rolcanlogin&lt;/code&gt; in &lt;a href=&quot;catalog-pg-authid&quot;&gt;&lt;code&gt;pg_authid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pg_shadow&lt;/code&gt; ビューは、下位互換性のために存在しています。バージョン8.1より前のPostgreSQLに存在していたカタログをエミュレートします。 &lt;code&gt;rolcanlogin&lt;/code&gt; で&lt;a href=&quot;catalog-pg-authid&quot;&gt; &lt;code&gt;pg_authid&lt;/code&gt; &lt;/a&gt;としてマークされているすべてのロールのプロパティが表示されます。</target>
        </trans-unit>
        <trans-unit id="d15bc53a297402a714a0bba8855047689e420c4a" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; catalog. This view allows access only to rows of &lt;code&gt;pg_statistic&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">&lt;code&gt;pg_stats&lt;/code&gt; ビューは、&lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt;カタログに保存されている情報へのアクセスを提供します。このビューは、ユーザーが読み取り権限を持っているテーブルに対応する &lt;code&gt;pg_statistic&lt;/code&gt; の行へのアクセスのみを許可するため、このビューへのパブリック読み取りアクセスを許可しても安全です。</target>
        </trans-unit>
        <trans-unit id="8b10f73e0ee9172a27b8a2e39f5e546984d02189" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_stats_ext&lt;/code&gt; provides access to the information stored in the &lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt;&lt;code&gt;pg_statistic_ext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt;&lt;code&gt;pg_statistic_ext_data&lt;/code&gt;&lt;/a&gt; catalogs. This view allows access only to rows of &lt;code&gt;pg_statistic_ext&lt;/code&gt; and &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; that correspond to tables the user has permission to read, and therefore it is safe to allow public read access to this view.</source>
          <target state="translated">ビュー &lt;code&gt;pg_stats_ext&lt;/code&gt; は、&lt;a href=&quot;catalog-pg-statistic-ext&quot;&gt; &lt;code&gt;pg_statistic_ext&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;catalog-pg-statistic-ext-data&quot;&gt; &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; &lt;/a&gt;カタログに格納されている情報へのアクセスを提供します。このビューは、ユーザーが読み取り権限を持っているテーブルに対応する &lt;code&gt;pg_statistic_ext&lt;/code&gt; と &lt;code&gt;pg_statistic_ext_data&lt;/code&gt; の行にのみアクセスを許可するため、このビューへのパブリック読み取りアクセスを許可しても安全です。</target>
        </trans-unit>
        <trans-unit id="f40e73d682038b4cca53135af313b3e16f3f20f0" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_tables&lt;/code&gt; provides access to useful information about each table in the database.</source>
          <target state="translated">ビュー &lt;code&gt;pg_tables&lt;/code&gt; は、データベース内の各テーブルに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="6619a281d707d2c59aad726e79eb743d37565afc" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; provides a list of time zone abbreviations that are currently recognized by the datetime input routines. The contents of this view change when the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt; run-time parameter is modified.</source>
          <target state="translated">&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; ビューは、日時入力ルーチンによって現在認識されているタイムゾーンの略語のリストを提供します。このビューの内容は、&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE-ABBREVIATIONS&quot;&gt;timezone_abbreviations&lt;/a&gt;ランタイムパラメーターが変更されると変更されます。</target>
        </trans-unit>
        <trans-unit id="779554f59d2b5af071b41b6375ef03ef95013941" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_timezone_names&lt;/code&gt; provides a list of time zone names that are recognized by &lt;code&gt;SET TIMEZONE&lt;/code&gt;, along with their associated abbreviations, UTC offsets, and daylight-savings status. (Technically, PostgreSQL does not use UTC because leap seconds are not handled.) Unlike the abbreviations shown in &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;&lt;code&gt;pg_timezone_abbrevs&lt;/code&gt;&lt;/a&gt;, many of these names imply a set of daylight-savings transition date rules. Therefore, the associated information changes across local DST boundaries. The displayed information is computed based on the current value of &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">ビュー &lt;code&gt;pg_timezone_names&lt;/code&gt; は、 &lt;code&gt;SET TIMEZONE&lt;/code&gt; によって認識されるタイムゾーン名のリストと、それらに関連付けられた略語、UTCオフセット、および夏時間ステータスを提供します。 （技術的には、うるう秒が処理されないため、PostgreSQLはUTCを使用しません。）&lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt; &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; &lt;/a&gt;に示される省略形とは異なり、これらの名前の多くは、一連の夏時間の移行日の規則を意味します。したがって、関連する情報は、ローカルのDST境界を越えて変更されます。表示される情報は、 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; の現在の値に基づいて計算されます。</target>
        </trans-unit>
        <trans-unit id="0accb8d532196eb116802aaa4d92096a1d624fec" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user&lt;/code&gt; provides access to information about database users. This is simply a publicly readable view of &lt;a href=&quot;view-pg-shadow&quot;&gt;&lt;code&gt;pg_shadow&lt;/code&gt;&lt;/a&gt; that blanks out the password field.</source>
          <target state="translated">ビュー &lt;code&gt;pg_user&lt;/code&gt; は、データベースユーザーに関する情報へのアクセスを提供します。これは単に&lt;a href=&quot;view-pg-shadow&quot;&gt; &lt;code&gt;pg_shadow&lt;/code&gt; の&lt;/a&gt;一般に読めるビューであり、パスワードフィールドを空白にしています。</target>
        </trans-unit>
        <trans-unit id="9af556d749b255c75a83063bd94ae2fbcc5e7542" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_user_mappings&lt;/code&gt; provides access to information about user mappings. This is essentially a publicly readable view of &lt;a href=&quot;catalog-pg-user-mapping&quot;&gt;&lt;code&gt;pg_user_mapping&lt;/code&gt;&lt;/a&gt; that leaves out the options field if the user has no rights to use it.</source>
          <target state="translated">&lt;code&gt;pg_user_mappings&lt;/code&gt; ビューは、ユーザーマッピングに関する情報へのアクセスを提供します。これは基本的に&lt;a href=&quot;catalog-pg-user-mapping&quot;&gt; &lt;code&gt;pg_user_mapping&lt;/code&gt; の&lt;/a&gt;公開された読み取り可能なビューであり、ユーザーがそれを使用する権限を持っていない場合にオプションフィールドを省略します。</target>
        </trans-unit>
        <trans-unit id="ebac217e3082208e364c831d2d7b567e319b9c3e" translate="yes" xml:space="preserve">
          <source>The view &lt;code&gt;pg_views&lt;/code&gt; provides access to useful information about each view in the database.</source>
          <target state="translated">ビュー &lt;code&gt;pg_views&lt;/code&gt; ビューはデータベース内のそれぞれのビューに関する有用な情報へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="4817256584c648c50b28a16cee721735c1a52c24" translate="yes" xml:space="preserve">
          <source>The view definition must not contain &lt;code&gt;WITH&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, &lt;code&gt;HAVING&lt;/code&gt;, &lt;code&gt;LIMIT&lt;/code&gt;, or &lt;code&gt;OFFSET&lt;/code&gt; clauses at the top level.</source>
          <target state="translated">ビュー定義には、最上位レベルに &lt;code&gt;WITH&lt;/code&gt; 、 &lt;code&gt;DISTINCT&lt;/code&gt; 、 &lt;code&gt;GROUP BY&lt;/code&gt; 、 &lt;code&gt;HAVING&lt;/code&gt; 、 &lt;code&gt;LIMIT&lt;/code&gt; 、または &lt;code&gt;OFFSET&lt;/code&gt; 句を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="ac73f4040a9b923ccad030c67910098b61fec109" translate="yes" xml:space="preserve">
          <source>The view definition must not contain set operations (&lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt; or &lt;code&gt;EXCEPT&lt;/code&gt;) at the top level.</source>
          <target state="translated">ビュー定義には、トップレベルでのセット演算（ &lt;code&gt;UNION&lt;/code&gt; 、 &lt;code&gt;INTERSECT&lt;/code&gt; または &lt;code&gt;EXCEPT&lt;/code&gt; ）を含めないでください。</target>
        </trans-unit>
        <trans-unit id="c5066d83f9232becf3a59274519313c89ede3a33" translate="yes" xml:space="preserve">
          <source>The view must have exactly one entry in its &lt;code&gt;FROM&lt;/code&gt; list, which must be a table or another updatable view.</source>
          <target state="translated">ビューの &lt;code&gt;FROM&lt;/code&gt; リストにはエントリが1つだけ必要です。これは、テーブルまたは別の更新可能なビューである必要があります。</target>
        </trans-unit>
        <trans-unit id="baf2ef9470f50663334ce73cc7c64a2829052725" translate="yes" xml:space="preserve">
          <source>The view's select list must not contain any aggregates, window functions or set-returning functions.</source>
          <target state="translated">ビューのセレクトリストには、アグリゲート、ウィンドウ関数、セットリターン関数を含んではいけません。</target>
        </trans-unit>
        <trans-unit id="130532d5707af5b172a46c66162c216e956933cf" translate="yes" xml:space="preserve">
          <source>The visibility map stores two bits per heap page. The first bit, if set, indicates that the page is all-visible, or in other words that the page does not contain any tuples that need to be vacuumed. This information can also be used by &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scans&lt;/em&gt;&lt;/a&gt; to answer queries using only the index tuple. The second bit, if set, means that all tuples on the page have been frozen. That means that even an anti-wraparound vacuum need not revisit the page.</source>
          <target state="translated">可視性マップは、ヒープページごとに2ビットを格納します。最初のビットが設定されている場合、ページがすべて表示されていること、つまり、ページにバキューム処理が必要なタプルが含まれていないことを示します。この情報は、&lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;インデックスのみのスキャンで&lt;/em&gt;&lt;/a&gt;も使用でき、インデックスタプルのみを使用してクエリに応答します。2番目のビットが設定されている場合、ページ上のすべてのタプルが凍結されていることを意味します。つまり、回り込み防止の掃除機でさえ、ページを再訪する必要はありません。</target>
        </trans-unit>
        <trans-unit id="07214e8c015e87c0486ca72cfe80d8e537680c27" translate="yes" xml:space="preserve">
          <source>The web site of the Unicode Consortium.</source>
          <target state="translated">ユニコードコンソーシアムのウェブサイト。</target>
        </trans-unit>
        <trans-unit id="ac0772ef278780058ef7ad6f8b7ba38fa2811ad4" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;The&lt;/code&gt; was recognized by the &lt;code&gt;english_ispell&lt;/code&gt; dictionary as a stop word (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;Section 12.6.1&lt;/a&gt;) and will not be indexed. The spaces are discarded too, since the configuration provides no dictionaries at all for them.</source>
          <target state="translated">単語 &lt;code&gt;The&lt;/code&gt; は、 &lt;code&gt;english_ispell&lt;/code&gt; 辞書によってストップワード（&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-STOPWORDS&quot;&gt;セクション12.6.1&lt;/a&gt;）として認識され、索引付けされません。構成では辞書がまったく提供されないため、スペースも破棄されます。</target>
        </trans-unit>
        <trans-unit id="59b558b7e67cfe3d7e609850ba39630cdfabc234" translate="yes" xml:space="preserve">
          <source>The words &lt;code&gt;INNER&lt;/code&gt; and &lt;code&gt;OUTER&lt;/code&gt; are optional in all forms. &lt;code&gt;INNER&lt;/code&gt; is the default; &lt;code&gt;LEFT&lt;/code&gt;, &lt;code&gt;RIGHT&lt;/code&gt;, and &lt;code&gt;FULL&lt;/code&gt; imply an outer join.</source>
          <target state="translated">&lt;code&gt;INNER&lt;/code&gt; および &lt;code&gt;OUTER&lt;/code&gt; という語は、すべての形式でオプションです。 &lt;code&gt;INNER&lt;/code&gt; がデフォルトです。 &lt;code&gt;LEFT&lt;/code&gt; 、 &lt;code&gt;RIGHT&lt;/code&gt; 、および &lt;code&gt;FULL&lt;/code&gt; は、外部結合を意味します。</target>
        </trans-unit>
        <trans-unit id="0b4d99c273391963b8b35583f768d35f9926b320" translate="yes" xml:space="preserve">
          <source>The write-ahead log files are collected at the end of the backup. Therefore, it is necessary for the &lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt; parameter to be set high enough that the log is not removed before the end of the backup. If the log has been rotated when it's time to transfer it, the backup will fail and be unusable.</source>
          <target state="translated">先行書き込みログファイルは、バックアップの最後に収集されます。したがって、バックアップが終了する前にログが削除されないように、&lt;a href=&quot;runtime-config-replication#GUC-WAL-KEEP-SEGMENTS&quot;&gt;wal_keep_segments&lt;/a&gt;パラメーターを十分に高く設定する必要があります。転送するときにログがローテーションされている場合、バックアップは失敗し、使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="ba7564fc67dee171caeeb2fce7f2a0e6bd4739d4" translate="yes" xml:space="preserve">
          <source>The write-ahead log is streamed over a regular PostgreSQL connection and uses the replication protocol. The connection must be made with a superuser or a user having &lt;code&gt;REPLICATION&lt;/code&gt; permissions (see &lt;a href=&quot;role-attributes&quot;&gt;Section 21.2&lt;/a&gt;), and &lt;code&gt;pg_hba.conf&lt;/code&gt; must permit the replication connection. The server must also be configured with &lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt; set high enough to leave at least one session available for the stream.</source>
          <target state="translated">先行書き込みログは、通常のPostgreSQL接続を介してストリーミングされ、レプリケーションプロトコルを使用します。接続は、スーパーユーザーまたは &lt;code&gt;REPLICATION&lt;/code&gt; 権限（&lt;a href=&quot;role-attributes&quot;&gt;セクション21.2を&lt;/a&gt;参照）を持つユーザーを使用して行う必要があり、 &lt;code&gt;pg_hba.conf&lt;/code&gt; はレプリケーション接続を許可する必要があります。また、サーバーは&lt;a href=&quot;runtime-config-replication#GUC-MAX-WAL-SENDERS&quot;&gt;max_wal_senders&lt;/a&gt;がストリームに使用可能なセッションを少なくとも1つ残せるように十分に高く設定して構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="432cd562d6efcb95d5dc25b8cd51ce86806b3431" translate="yes" xml:space="preserve">
          <source>The year field divided by 10</source>
          <target state="translated">年のフィールドを10で割ったもの</target>
        </trans-unit>
        <trans-unit id="e98cba09cda3a8f0612018162bdf75b308d8a647" translate="yes" xml:space="preserve">
          <source>The year field. Keep in mind there is no &lt;code&gt;0 AD&lt;/code&gt;, so subtracting &lt;code&gt;BC&lt;/code&gt; years from &lt;code&gt;AD&lt;/code&gt; years should be done with care.</source>
          <target state="translated">年フィールド。 &lt;code&gt;0 AD&lt;/code&gt; は0でないことに注意してください。したがって、 &lt;code&gt;AD&lt;/code&gt; の年から &lt;code&gt;BC&lt;/code&gt; の年を減算する場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="3552e22363d1468b0aacd8c69df60173fa97d631" translate="yes" xml:space="preserve">
          <source>Then a second pass is performed to add tuples that were added while the first pass was running. This step is also done in a separate transaction for each index.</source>
          <target state="translated">その後、最初のパスが実行されている間に追加されたタプルを追加するために2回目のパスが実行されます。このステップは、各インデックスごとに別のトランザクションでも行われます。</target>
        </trans-unit>
        <trans-unit id="de263736bca031472680a6589ed91b77cebda41e" translate="yes" xml:space="preserve">
          <source>Then create a foreign server using &lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;. In this example we wish to connect to a PostgreSQL server on host &lt;code&gt;192.83.123.89&lt;/code&gt; listening on port &lt;code&gt;5432&lt;/code&gt;. The database to which the connection is made is named &lt;code&gt;foreign_db&lt;/code&gt; on the remote server:</source>
          <target state="translated">次に、&lt;a href=&quot;sql-createserver&quot;&gt;CREATE SERVER&lt;/a&gt;を使用して外部サーバーを作成します。この例では、ポート &lt;code&gt;5432&lt;/code&gt; でリッスンするホスト &lt;code&gt;192.83.123.89&lt;/code&gt; の PostgreSQLサーバーに接続します。接続先のデータベースは、リモートサーバーでは &lt;code&gt;foreign_db&lt;/code&gt; という名前です。</target>
        </trans-unit>
        <trans-unit id="3a9fba163e98528da53932bde9ceaf387982416c" translate="yes" xml:space="preserve">
          <source>Then create a foreign server:</source>
          <target state="translated">続いて、海外サーバーを作成します。</target>
        </trans-unit>
        <trans-unit id="e43083876c3094d12a2389b25dd099144327f495" translate="yes" xml:space="preserve">
          <source>Then create the necessary functions:</source>
          <target state="translated">そして、必要な機能を作成します。</target>
        </trans-unit>
        <trans-unit id="2dddb885a6a2b1519c7054126c37d9c20d84517e" translate="yes" xml:space="preserve">
          <source>Then do:</source>
          <target state="translated">ならば、そうしてください。</target>
        </trans-unit>
        <trans-unit id="4426056bca332e6c166eaec6ccb98cd595443c37" translate="yes" xml:space="preserve">
          <source>Then give the snapshot identifier in a &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; command at the beginning of the newly opened transaction:</source>
          <target state="translated">次に、新しく開いたトランザクションの開始時に、 &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; コマンドでスナップショット識別子を指定します。</target>
        </trans-unit>
        <trans-unit id="099f3b7a79e1e05797463b8b9b3322c6caaa4e61" translate="yes" xml:space="preserve">
          <source>Then in</source>
          <target state="translated">そして</target>
        </trans-unit>
        <trans-unit id="ccb8ef6dada9fbef1512f58ed41d1e67ec739a68" translate="yes" xml:space="preserve">
          <source>Then issue the tablespace creation command inside PostgreSQL:</source>
          <target state="translated">そして、PostgreSQL内部でテーブル空間作成コマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="a0f76343f97548fdfb798c00512768e705a5ee06" translate="yes" xml:space="preserve">
          <source>Then on the publisher database:</source>
          <target state="translated">続いて出版社のデータベースで。</target>
        </trans-unit>
        <trans-unit id="1d6e3db28b5d51e7392c9e84a5178977bac26570" translate="yes" xml:space="preserve">
          <source>Then psql's &lt;code&gt;\dp&lt;/code&gt; command would show:</source>
          <target state="translated">次に、psqlの &lt;code&gt;\dp&lt;/code&gt; コマンドは次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="e40d95af0c8bcea8599638c011ae6dba5195ebe1" translate="yes" xml:space="preserve">
          <source>Then value &lt;code&gt;i&lt;/code&gt; between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; inclusive is drawn with probability: &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;min&lt;/code&gt; 値と &lt;code&gt;max&lt;/code&gt; 値の間の値 &lt;code&gt;i&lt;/code&gt; が確率で描画されます： &lt;code&gt;f(i) - f(i + 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="509703ffcaaed84d033fc9e94ce5a7937bf0da94" translate="yes" xml:space="preserve">
          <source>Then we create a GIN index to speed up the search:</source>
          <target state="translated">そして、検索を高速化するためにGINインデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="c623faac8eaf06e9450b38faf671811be2f6e1f9" translate="yes" xml:space="preserve">
          <source>Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too.</source>
          <target state="translated">そうすると、明示的な資格なしにパブリックスキーマにアクセスすることはできなくなります。パブリックスキーマはデフォルトで存在していること以外に特別なことは何もありません。これを削除することもできます。</target>
        </trans-unit>
        <trans-unit id="0d0e01998d1caf45906467ce09eb6d9f85a24392" translate="yes" xml:space="preserve">
          <source>Then we will get these results:</source>
          <target state="translated">そうすると、このような結果になります。</target>
        </trans-unit>
        <trans-unit id="30348812ea695911ccd6ce73f8cff665d67bd9ad" translate="yes" xml:space="preserve">
          <source>Then you can use it in a &lt;code&gt;SELECT&lt;/code&gt; command, for instance:</source>
          <target state="translated">次に、それを &lt;code&gt;SELECT&lt;/code&gt; コマンドで使用できます。たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="0c956d2a4c1c867a4aa753ae841035f68a38bb7b" translate="yes" xml:space="preserve">
          <source>Then you could name the files in the &lt;code&gt;conf.d&lt;/code&gt; directory like this:</source>
          <target state="translated">次に、 &lt;code&gt;conf.d&lt;/code&gt; ディレクトリのファイルに次のように名前を付けます。</target>
        </trans-unit>
        <trans-unit id="f4c7647dc71f8f47d91ed549387e0af6d05b17ea" translate="yes" xml:space="preserve">
          <source>Then, create a symbolic link to it in &lt;code&gt;/etc/rc3.d&lt;/code&gt; as &lt;code&gt;S99postgresql&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;/etc/rc3.d&lt;/code&gt; として &lt;code&gt;S99postgresql&lt;/code&gt; シンボリックリンクを作成します。</target>
        </trans-unit>
        <trans-unit id="e196180497775135006d17c14fe064e7b2203578" translate="yes" xml:space="preserve">
          <source>Then, sign the request with the key to create a root certificate authority (using the default OpenSSL configuration file location on Linux):</source>
          <target state="translated">次に、ルート証明書の認証局を作成するための鍵を指定してリクエストに署名します(Linux上のデフォルトのOpenSSL設定ファイルの場所を使用します)。</target>
        </trans-unit>
        <trans-unit id="6e6f711b66bbac69a2f23c2445e625c076269156" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on operator names, however:</source>
          <target state="translated">ただし、オペレーター名にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="e06308b22446d8ff8a3bec464184e0db33a1b8e3" translate="yes" xml:space="preserve">
          <source>There are a few restrictions on your choice of name:</source>
          <target state="translated">名前の選択にはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="e38ec4f8f8d1c9acce491ad6d51f28d3688ffbf6" translate="yes" xml:space="preserve">
          <source>There are a few solutions that do not fit into the above categories:</source>
          <target state="translated">上記に当てはまらない解決策はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="f2d4b5a4acbfddfda3fa8af2f47936fbae4e67b7" translate="yes" xml:space="preserve">
          <source>There are a few things to be careful about when adding trace macros to the C code:</source>
          <target state="translated">Cコードにトレースマクロを追加する際には、いくつか注意すべき点があります。</target>
        </trans-unit>
        <trans-unit id="30225d755151e996e06d97ca5afb06ce57185f7a" translate="yes" xml:space="preserve">
          <source>There are a few things you need to do to simplify importing CSV log files:</source>
          <target state="translated">CSVログファイルのインポートを簡単にするために必要なことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="86f7d5ba0c83b5c117ed409216f966f9d7eef72d" translate="yes" xml:space="preserve">
          <source>There are also additional types of conflict that can occur with Hot Standby. These conflicts are &lt;em&gt;hard conflicts&lt;/em&gt; in the sense that queries might need to be canceled and, in some cases, sessions disconnected to resolve them. The user is provided with several ways to handle these conflicts. Conflict cases include:</source>
          <target state="translated">ホットスタンバイで発生する可能性のある追加のタイプの競合もあります。これらの競合は、クエリをキャンセルする必要があり、場合によってはセッションを切断してそれらを解決する必要があるという意味で、&lt;em&gt;ハード競合&lt;/em&gt;です。ユーザーには、これらの競合を処理するいくつかの方法が提供されています。競合のケースは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="080fe8c96ab19e790a2ea0bd30b8130c9a87b676" translate="yes" xml:space="preserve">
          <source>There are also some built-in operator classes besides the default ones:</source>
          <target state="translated">デフォルトの演算子クラス以外にも、いくつかの組み込み演算子クラスがあります。</target>
        </trans-unit>
        <trans-unit id="b8bbd8454471c92fa3e16174c667ec63b3cc9c3f" translate="yes" xml:space="preserve">
          <source>There are also some comparison predicates, as shown in &lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;Table 9.2&lt;/a&gt;. These behave much like operators, but have special syntax mandated by the SQL standard.</source>
          <target state="translated">&lt;a href=&quot;functions-comparison#FUNCTIONS-COMPARISON-PRED-TABLE&quot;&gt;表9.2に&lt;/a&gt;示すように、比較述語もいくつかあります。これらは演算子とほとんど同じように動作しますが、SQL標準で義務付けられている特別な構文があります。</target>
        </trans-unit>
        <trans-unit id="11f3ba822c528ebdfeb9746d393a7742a7d6e349" translate="yes" xml:space="preserve">
          <source>There are cases in which the actual and estimated values won't match up well, but nothing is really wrong. One such case occurs when plan node execution is stopped short by a &lt;code&gt;LIMIT&lt;/code&gt; or similar effect. For example, in the &lt;code&gt;LIMIT&lt;/code&gt; query we used before,</source>
          <target state="translated">実際の値と推定値がうまく一致しない場合がありますが、実際には何も問題はありません。このようなケースの1つは、計画ノードの実行が &lt;code&gt;LIMIT&lt;/code&gt; または同様の効果によって短時間で停止した場合です。たとえば、前に使用した &lt;code&gt;LIMIT&lt;/code&gt; クエリでは、</target>
        </trans-unit>
        <trans-unit id="626c9a7674dab9b044bc50641f2a4b064da217a4" translate="yes" xml:space="preserve">
          <source>There are certain operations that hold critical locks and should therefore complete as quickly as possible. Cost-based vacuum delays do not occur during such operations. Therefore it is possible that the cost accumulates far higher than the specified limit. To avoid uselessly long delays in such cases, the actual delay is calculated as &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; / &lt;code&gt;vacuum_cost_limit&lt;/code&gt; with a maximum of &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4.</source>
          <target state="translated">重要なロックを保持しているため、可能な限り迅速に完了する必要がある特定の操作があります。コストベースのバキューム遅延は、このような操作中には発生しません。したがって、コストが指定された制限をはるかに超えて蓄積する可能性があります。そのような場合に無用に長い遅延を回避するために、実際の遅延は、 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * &lt;code&gt;accumulated_balance&lt;/code&gt; &lt;code&gt;vacuum_cost_limit&lt;/code&gt; / vacuum_cost_limitとして計算され、最大の &lt;code&gt;vacuum_cost_delay&lt;/code&gt; * 4。</target>
        </trans-unit>
        <trans-unit id="49623fffc3b27e386ddb0902bf870bdd64aa14c1" translate="yes" xml:space="preserve">
          <source>There are different kinds of privileges: &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REFERENCES&lt;/code&gt;, &lt;code&gt;TRIGGER&lt;/code&gt;, &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;TEMPORARY&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, and &lt;code&gt;USAGE&lt;/code&gt;. The privileges applicable to a particular object vary depending on the object's type (table, function, etc). More detail about the meanings of these privileges appears below. The following sections and chapters will also show you how these privileges are used.</source>
          <target state="translated">権限には、 &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;TRUNCATE&lt;/code&gt; 、 &lt;code&gt;REFERENCES&lt;/code&gt; 、 &lt;code&gt;TRIGGER&lt;/code&gt; 、 &lt;code&gt;CREATE&lt;/code&gt; 、 &lt;code&gt;CONNECT&lt;/code&gt; 、 &lt;code&gt;TEMPORARY&lt;/code&gt; 、 &lt;code&gt;EXECUTE&lt;/code&gt; 、および &lt;code&gt;USAGE&lt;/code&gt; の種類があります。特定のオブジェクトに適用できる特権は、オブジェクトのタイプ（テーブル、関数など）によって異なります。これらの特権の意味の詳細については、以下をご覧ください。次のセクションと章では、これらの権限の使用方法も示します。</target>
        </trans-unit>
        <trans-unit id="2f4c8f7302f72ae7897c7273dc4e0796366f4575" translate="yes" xml:space="preserve">
          <source>There are examples in &lt;code&gt;refint.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refint.example&lt;/code&gt; に例があります。</target>
        </trans-unit>
        <trans-unit id="e74d4a0a2f4513529b90fbecc5989b2ddcb617e4" translate="yes" xml:space="preserve">
          <source>There are five forms of &lt;code&gt;CREATE TYPE&lt;/code&gt;, as shown in the syntax synopsis above. They respectively create a &lt;em&gt;composite type&lt;/em&gt;, an &lt;em&gt;enum type&lt;/em&gt;, a &lt;em&gt;range type&lt;/em&gt;, a &lt;em&gt;base type&lt;/em&gt;, or a &lt;em&gt;shell type&lt;/em&gt;. The first four of these are discussed in turn below. A shell type is simply a placeholder for a type to be defined later; it is created by issuing &lt;code&gt;CREATE TYPE&lt;/code&gt; with no parameters except for the type name. Shell types are needed as forward references when creating range types and base types, as discussed in those sections.</source>
          <target state="translated">上記の構文の概要に示すように、 &lt;code&gt;CREATE TYPE&lt;/code&gt; には5つの形式があります。これらはそれぞれ、&lt;em&gt;複合型&lt;/em&gt;、&lt;em&gt;列挙型&lt;/em&gt;、&lt;em&gt;範囲型&lt;/em&gt;、&lt;em&gt;基本型&lt;/em&gt;、または&lt;em&gt;シェル型を作成し&lt;/em&gt;ます。これらの最初の4つについて、以下で順に説明します。シェル型は、後で定義される型の単なるプレースホルダーです。これは、タイプ名を除いてパラメーターなしで &lt;code&gt;CREATE TYPE&lt;/code&gt; を発行することによって作成されます。これらのセクションで説明されているように、範囲タイプと基本タイプを作成する場合、前方参照としてシェルタイプが必要です。</target>
        </trans-unit>
        <trans-unit id="c1c0e123011cea9ffa5e9167dd8e734710858d21" translate="yes" xml:space="preserve">
          <source>There are five methods that an index operator class for GiST must provide, and four that are optional. Correctness of the index is ensured by proper implementation of the &lt;code&gt;same&lt;/code&gt;, &lt;code&gt;consistent&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; methods, while efficiency (size and speed) of the index will depend on the &lt;code&gt;penalty&lt;/code&gt; and &lt;code&gt;picksplit&lt;/code&gt; methods. Two optional methods are &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;decompress&lt;/code&gt;, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about &lt;code&gt;varlena&lt;/code&gt; for variable sized data). If the tree's internal data type exists at the SQL level, the &lt;code&gt;STORAGE&lt;/code&gt; option of the &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; command can be used. The optional eighth method is &lt;code&gt;distance&lt;/code&gt;, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method &lt;code&gt;fetch&lt;/code&gt; is needed if the operator class wishes to support index-only scans, except when the &lt;code&gt;compress&lt;/code&gt; method is omitted.</source>
          <target state="translated">GiSTのインデックス演算子クラスが提供する必要のある5つのメソッドと、オプションの4つのメソッドがあります。インデックスの正確性は、 &lt;code&gt;same&lt;/code&gt; 、 &lt;code&gt;consistent&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; メソッドの適切な実装によって保証されますが、インデックスの効率（サイズと速度）は、 &lt;code&gt;penalty&lt;/code&gt; メソッドと &lt;code&gt;picksplit&lt;/code&gt; メソッドに依存します。オプションの2つの方法は、 &lt;code&gt;compress&lt;/code&gt; および &lt;code&gt;decompress&lt;/code&gt; です。これにより、インデックスは、インデックス付けするデータとは異なるタイプの内部ツリーデータを持つことができます。葉はインデックス付きのデータ型にする必要がありますが、他のツリーノードは任意のC構造体にすることができます（ただし、ここでもPostgreSQLのデータ型規則に従う必要があります &lt;code&gt;varlena&lt;/code&gt; について参照してください）可変サイズのデータ​​の場合）。ツリーの内部データ型がSQLレベルで存在する場合は、 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; コマンドの &lt;code&gt;STORAGE&lt;/code&gt; オプションを使用できます。オプションの8番目のメソッドは &lt;code&gt;distance&lt;/code&gt; です。これは、演算子クラスが順序付きスキャン（最近傍検索）をサポートする場合に必要です。オプションの9番目のメソッド &lt;code&gt;fetch&lt;/code&gt; は、 &lt;code&gt;compress&lt;/code&gt; メソッドが省略されている場合を除き、演算子クラスがインデックスのみのスキャンをサポートする場合に必要です。</target>
        </trans-unit>
        <trans-unit id="29e9f9add6de4117c3f41e8f16d45114f4cd168c" translate="yes" xml:space="preserve">
          <source>There are five user-defined methods that an index operator class for SP-GiST must provide, and one is optional. All five mandatory methods follow the convention of accepting two &lt;code&gt;internal&lt;/code&gt; arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return &lt;code&gt;void&lt;/code&gt;, since all their results appear in the output struct; but &lt;code&gt;leaf_consistent&lt;/code&gt; additionally returns a &lt;code&gt;boolean&lt;/code&gt; result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method &lt;code&gt;compress&lt;/code&gt; accepts datum to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple.</source>
          <target state="translated">SP-GiSTのインデックス演算子クラスが提供する必要がある5つのユーザー定義メソッドがあり、1つはオプションです。 5つの必須メソッドはすべて、2つの &lt;code&gt;internal&lt;/code&gt; 引数を受け入れるという慣例に従います。最初の引数は、サポートメソッドの入力値を含むC構造体へのポインターですが、2番目の引数は、出力値を配置する必要があるC構造体へのポインターです。すべての結果は出力構造体に表示されるため、必須メソッドのうちの4つは &lt;code&gt;void&lt;/code&gt; を返します。しかし、 &lt;code&gt;leaf_consistent&lt;/code&gt; はさらに &lt;code&gt;boolean&lt;/code&gt; 結果を返します。メソッドは、入力構造体のフィールドを変更してはなりません。すべての場合において、ユーザー定義メソッドを呼び出す前に、出力構造体はゼロに初期化されます。オプションの6番目の方法 &lt;code&gt;compress&lt;/code&gt; は、インデックス付けされるデータを唯一の引数として受け入れ、リーフタプルの物理ストレージに適した値を返します。</target>
        </trans-unit>
        <trans-unit id="fa03941817da7215f34f7c4059988c3830f85876" translate="yes" xml:space="preserve">
          <source>There are four fundamental SQL constructs requiring distinct type conversion rules in the PostgreSQL parser:</source>
          <target state="translated">PostgreSQLパーサでは、異なる型変換規則を必要とする4つの基本的なSQL構文があります。</target>
        </trans-unit>
        <trans-unit id="af078d5f8f920b3bd3ff699db4f54f596acf2a85" translate="yes" xml:space="preserve">
          <source>There are four methods that an operator class for BRIN must provide:</source>
          <target state="translated">BRIN用の演算子クラスが提供しなければならないメソッドは4つあります。</target>
        </trans-unit>
        <trans-unit id="dc37bd22ec5c580834570b2476e6fe4f24b8403a" translate="yes" xml:space="preserve">
          <source>There are minor differences in the interpretation of regular expression patterns used in &lt;code&gt;like_regex&lt;/code&gt; filters, as described in &lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;Section 9.15.2.2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-json#JSONPATH-REGULAR-EXPRESSIONS&quot;&gt;セクション9.15.2.2で&lt;/a&gt;説明されているように、 &lt;code&gt;like_regex&lt;/code&gt; フィルターで使用される正規表現パターンの解釈には若干の違いがあります。</target>
        </trans-unit>
        <trans-unit id="e2d1e6b157368edb7a34c08bf06a60ee5f8744e9" translate="yes" xml:space="preserve">
          <source>There are not currently any commands that manipulate procedural language templates; to change the built-in information, a superuser must modify the table using ordinary &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;UPDATE&lt;/code&gt; commands.</source>
          <target state="translated">現在、手続き型言語のテンプレートを操作するコマンドはありません。組み込み情報を変更するには、スーパーユーザーが通常の &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;UPDATE&lt;/code&gt; コマンドを使用してテーブルを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="18b7b9a654dddbbbf44432092fdfff639afd65c3" translate="yes" xml:space="preserve">
          <source>There are parallel variants of these operators for both the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;jsonb&lt;/code&gt; types. The field/element/path extraction operators return the same type as their left-hand input (either &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;), except for those specified as returning &lt;code&gt;text&lt;/code&gt;, which coerce the value to text. The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such element exists. The field/element/path extraction operators that accept integer JSON array subscripts all support negative subscripting from the end of arrays.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; と &lt;code&gt;jsonb&lt;/code&gt; の両方のタイプには、これらの演算子の並列バリアントがあります。フィールド/要素/パス抽出演算子は、値をテキストに強制する &lt;code&gt;jsonb&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; として指定されたものを除いて、左側の入力と同じタイプ（ &lt;code&gt;json&lt;/code&gt; またはjsonb）を返します。 JSON入力にリクエストと一致する適切な構造がない場合、フィールド/要素/パス抽出演算子は失敗せずにNULLを返します。たとえば、そのような要素が存在しない場合。整数のJSON配列添え字を受け入れるフィールド/要素/パス抽出演算子はすべて、配列の最後からの負の添え字をサポートしています。</target>
        </trans-unit>
        <trans-unit id="f87d9a17505cfd4cb8b88d986ea842eb4469f8b6" translate="yes" xml:space="preserve">
          <source>There are several &lt;code&gt;substr&lt;/code&gt; functions, one of which takes types &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt;. If called with a string constant of unspecified type, the system chooses the candidate function that accepts an argument of the preferred category &lt;code&gt;string&lt;/code&gt; (namely of type &lt;code&gt;text&lt;/code&gt;).</source>
          <target state="translated">いくつかの &lt;code&gt;substr&lt;/code&gt; 関数があり、そのうちの1つは &lt;code&gt;text&lt;/code&gt; 型と &lt;code&gt;integer&lt;/code&gt; 型を取ります。型が指定されていない文字列定数で呼び出された場合、システムは優先カテゴリ &lt;code&gt;string&lt;/code&gt; （つまり、型が &lt;code&gt;text&lt;/code&gt; ）の引数を受け入れる候補関数を選択します。</target>
        </trans-unit>
        <trans-unit id="4a86c45854efa996c6173d14634a86acbb0fae9b" translate="yes" xml:space="preserve">
          <source>There are several WAL-related configuration parameters that affect database performance. This section explains their use. Consult &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for general information about setting server configuration parameters.</source>
          <target state="translated">データベースのパフォーマンスに影響を与えるWAL関連の構成パラメーターがいくつかあります。このセクションでは、それらの使用法について説明します。相談する&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章を&lt;/a&gt;サーバーの構成パラメータの設定に関する一般的な情報のために。</target>
        </trans-unit>
        <trans-unit id="90a47baf0edabbb7ab4de9adfe99efaea9932730" translate="yes" xml:space="preserve">
          <source>There are several caveats to be aware of when using this option. Only one index name can be specified, and the &lt;code&gt;CASCADE&lt;/code&gt; option is not supported. (Thus, an index that supports a &lt;code&gt;UNIQUE&lt;/code&gt; or &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint cannot be dropped this way.) Also, regular &lt;code&gt;DROP INDEX&lt;/code&gt; commands can be performed within a transaction block, but &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="translated">このオプションを使用する場合は、いくつかの注意点があります。指定できるインデックス名は1つだけで、 &lt;code&gt;CASCADE&lt;/code&gt; オプションはサポートされていません。（したがって、 &lt;code&gt;UNIQUE&lt;/code&gt; または &lt;code&gt;PRIMARY KEY&lt;/code&gt; 制約をサポートするインデックスは、この方法では削除できません。）また、通常の &lt;code&gt;DROP INDEX&lt;/code&gt; コマンドはトランザクションブロック内で実行できますが、 &lt;code&gt;DROP INDEX CONCURRENTLY&lt;/code&gt; は削除できません。</target>
        </trans-unit>
        <trans-unit id="91dcaac9ead3b10f651956a96badf0ae2f79aa1a" translate="yes" xml:space="preserve">
          <source>There are several common reasons the server might fail to start. Check the server's log file, or start it by hand (without redirecting standard output or standard error) and see what error messages appear. Below we explain some of the most common error messages in more detail.</source>
          <target state="translated">サーバーが起動に失敗する原因はいくつかあります。サーバのログファイルをチェックするか、(標準出力や標準エラーをリダイレクトせずに)手で起動して、どのようなエラーメッセージが表示されるかを確認してください。以下では、最も一般的なエラーメッセージのいくつかをより詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="9adbaa62a8322d6f35b205f33d65aadeb73701d5" translate="yes" xml:space="preserve">
          <source>There are several configuration parameters that control the behavior of &lt;code&gt;auto_explain&lt;/code&gt;. Note that the default behavior is to do nothing, so you must set at least &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; if you want any results.</source>
          <target state="translated">&lt;code&gt;auto_explain&lt;/code&gt; の動作を制御するいくつかの構成パラメーターがあります。デフォルトの動作では何もしないことに注意してください。結果が必要な場合は、少なくとも &lt;code&gt;auto_explain.log_min_duration&lt;/code&gt; を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f07db15d474ec8167b00bf77d56e7101e3f26c7" translate="yes" xml:space="preserve">
          <source>There are several distinct types of lockable objects: whole relations (e.g., tables), individual pages of relations, individual tuples of relations, transaction IDs (both virtual and permanent IDs), and general database objects (identified by class OID and object OID, in the same way as in &lt;code&gt;pg_description&lt;/code&gt; or &lt;code&gt;pg_depend&lt;/code&gt;). Also, the right to extend a relation is represented as a separate lockable object. Also, &amp;ldquo;advisory&amp;rdquo; locks can be taken on numbers that have user-defined meanings.</source>
          <target state="translated">ロック可能なオブジェクトにはいくつかの異なるタイプがあります。リレーション全体（テーブルなど）、リレーションの個別のページ、リレーションの個別のタプル、トランザクションID（仮想IDと永続IDの両方）、および一般的なデータベースオブジェクト（クラスOIDとオブジェクトOIDで識別）、 &lt;code&gt;pg_description&lt;/code&gt; または &lt;code&gt;pg_depend&lt;/code&gt; と同じ方法で）。また、関係を拡張する権利は、個別のロック可能なオブジェクトとして表されます。また、「アドバイザリ」ロックは、ユーザー定義の意味を持つ数値に適用できます。</target>
        </trans-unit>
        <trans-unit id="114cb14410efa6f2de15cd3a5be68d31fc1e555a" translate="yes" xml:space="preserve">
          <source>There are several limitations of Hot Standby. These can and probably will be fixed in future releases:</source>
          <target state="translated">ホットスタンバイにはいくつかの制限があります。これらは将来のリリースで修正される可能性があり、おそらく修正されるでしょう。</target>
        </trans-unit>
        <trans-unit id="9e6c3965c75b70506035e1130db0d24734cc5245" translate="yes" xml:space="preserve">
          <source>There are several modifiers that can be put at the end of a non-star label in &lt;code&gt;lquery&lt;/code&gt; to make it match more than just the exact match:</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt; の非スターラベルの最後に配置できる修飾子がいくつかあり、完全に一致するだけではありません。</target>
        </trans-unit>
        <trans-unit id="c65cdf0a50b535370cafd7a5d8814b1949feb7fa" translate="yes" xml:space="preserve">
          <source>There are several password-based authentication methods. These methods operate similarly but differ in how the users' passwords are stored on the server and how the password provided by a client is sent across the connection.</source>
          <target state="translated">パスワードベースの認証方法はいくつかあります。これらの方法は似たような動作をしますが、ユーザのパスワードがサーバに保存される方法と、クライアントから提供されたパスワードが接続を介して送信される方法が異なります。</target>
        </trans-unit>
        <trans-unit id="82697895b0fc3864eed5346e0a502ff9ce90f8b6" translate="yes" xml:space="preserve">
          <source>There are several possible values of &lt;code&gt;context&lt;/code&gt;. In order of decreasing difficulty of changing the setting, they are:</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; にはいくつかの可能な値があります。設定変更の難易度を下げるために、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="412101ab8ec853191b9bda2fa3098ca1192d7103" translate="yes" xml:space="preserve">
          <source>There are several reasons why one might want to use schemas:</source>
          <target state="translated">スキーマを使いたいと思う理由はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="47ec670ad87a5a65f5d73f50b758515c8d78f032" translate="yes" xml:space="preserve">
          <source>There are several settings which can cause the query planner not to generate a parallel query plan under any circumstances. In order for any parallel query plans whatsoever to be generated, the following settings must be configured as indicated.</source>
          <target state="translated">クエリプランナがいかなる状況下でも並列クエリプランを生成しないようにするためには、いくつかの設定があります。並列クエリプランを生成するためには、以下の設定を設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="4a490c0d4b72a8988d006fa28baad623b333c2c3" translate="yes" xml:space="preserve">
          <source>There are several ways around this problem. One simple answer is to use &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; in sub-&lt;code&gt;SELECT&lt;/code&gt;s in row security policies. However, that requires granting &lt;code&gt;UPDATE&lt;/code&gt; privilege on the referenced table (here &lt;code&gt;users&lt;/code&gt;) to the affected users, which might be undesirable. (But another row security policy could be applied to prevent them from actually exercising that privilege; or the sub-&lt;code&gt;SELECT&lt;/code&gt; could be embedded into a security definer function.) Also, heavy concurrent use of row share locks on the referenced table could pose a performance problem, especially if updates of it are frequent. Another solution, practical if updates of the referenced table are infrequent, is to take an exclusive lock on the referenced table when updating it, so that no concurrent transactions could be examining old row values. Or one could just wait for all concurrent transactions to end after committing an update of the referenced table and before making changes that rely on the new security situation.</source>
          <target state="translated">この問題を回避する方法はいくつかあります。簡単な答えの1つは、行セキュリティポリシーのサブ &lt;code&gt;SELECT&lt;/code&gt; で &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; を使用することです。ただし、これには、参照されるテーブル（ここでは &lt;code&gt;users&lt;/code&gt; ）に対する &lt;code&gt;UPDATE&lt;/code&gt; 特権を影響を受けるユーザーに付与する必要があるため、望ましくない場合があります。 （ただし、別の行セキュリティポリシーを適用して、実際にその特権を実行できないようにすることができます。または、サブ &lt;code&gt;SELECT&lt;/code&gt; は、セキュリティ定義機能に組み込むことができます。）また、参照されるテーブルで行共有ロックを大量に同時に使用すると、特に更新が頻繁に行われる場合に、パフォーマンスの問題が発生する可能性があります。参照テーブルの更新が頻繁でない場合の実用的な別の解決策は、更新時に参照テーブルを排他ロックすることです。これにより、並行トランザクションが古い行の値を検査できないようになります。または、参照されるテーブルの更新をコミットした後、新しいセキュリティ状況に依存する変更を行う前に、すべての同時トランザクションが終了するのを待つこともできます。</target>
        </trans-unit>
        <trans-unit id="0a65d46642b8ea0d625c08a9a29af3d8886f49e2" translate="yes" xml:space="preserve">
          <source>There are several ways to shut down the database server. You control the type of shutdown by sending different signals to the master &lt;code&gt;postgres&lt;/code&gt; process.</source>
          <target state="translated">データベースサーバーをシャットダウンするには、いくつかの方法があります。マスター &lt;code&gt;postgres&lt;/code&gt; プロセスに異なる信号を送信することにより、シャットダウンのタイプを制御します。</target>
        </trans-unit>
        <trans-unit id="f2aaff5fcb38efacb1d58514b7509e951bb1187c" translate="yes" xml:space="preserve">
          <source>There are some basic assumptions that a btree operator family must satisfy:</source>
          <target state="translated">btree 演算子ファミリが満たすべき基本的な前提条件がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="0b521cdf532a9a953ad42c30cbfbc097cf6b1b08" translate="yes" xml:space="preserve">
          <source>There are three available prewarming methods. &lt;code&gt;prefetch&lt;/code&gt; issues asynchronous prefetch requests to the operating system, if this is supported, or throws an error otherwise. &lt;code&gt;read&lt;/code&gt; reads the requested range of blocks; unlike &lt;code&gt;prefetch&lt;/code&gt;, this is synchronous and supported on all platforms and builds, but may be slower. &lt;code&gt;buffer&lt;/code&gt; reads the requested range of blocks into the database buffer cache.</source>
          <target state="translated">利用可能な事前加熱方法は3つあります。 &lt;code&gt;prefetch&lt;/code&gt; は、オペレーティングシステムに非同期プリフェッチ要求を発行します（サポートされている場合）、そうでない場合はエラーをスローします。 &lt;code&gt;read&lt;/code&gt; は、要求された範囲のブロックを読み取ります。 &lt;code&gt;prefetch&lt;/code&gt; とは異なり、これは同期的であり、すべてのプラットフォームとビルドでサポートされていますが、遅くなる可能性があります。 &lt;code&gt;buffer&lt;/code&gt; は、要求された範囲のブロックをデータベースバッファーキャッシュに読み込みます。</target>
        </trans-unit>
        <trans-unit id="cb805126a31ff8c55ee475c5fbc01109be8dd511" translate="yes" xml:space="preserve">
          <source>There are three kinds of &lt;em&gt;implicitly-typed constants&lt;/em&gt; in PostgreSQL: strings, bit strings, and numbers. Constants can also be specified with explicit types, which can enable more accurate representation and more efficient handling by the system. These alternatives are discussed in the following subsections.</source>
          <target state="translated">PostgreSQLには、文字列、ビット文字列、数値の3種類の&lt;em&gt;暗黙的に型付けされた定数&lt;/em&gt;があります。定数は明示的なタイプで指定することもできます。これにより、システムによるより正確な表現とより効率的な処理が可能になります。これらの代替案については、次のサブセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="30766d90eb25e2981c2e600b788f88cc0665cda4" translate="yes" xml:space="preserve">
          <source>There are three possible syntaxes for an operator invocation:</source>
          <target state="translated">演算子の呼び出しには、3 つの構文が考えられます。</target>
        </trans-unit>
        <trans-unit id="7ac1c9045fce554fb04868e602b7a9908c87947d" translate="yes" xml:space="preserve">
          <source>There are three separate approaches to pattern matching provided by PostgreSQL: the traditional SQL &lt;code&gt;LIKE&lt;/code&gt; operator, the more recent &lt;code&gt;SIMILAR TO&lt;/code&gt; operator (added in SQL:1999), and POSIX-style regular expressions. Aside from the basic &amp;ldquo;does this string match this pattern?&amp;rdquo; operators, functions are available to extract or replace matching substrings and to split a string at matching locations.</source>
          <target state="translated">PostgreSQLが提供するパターンマッチングには、従来のSQL &lt;code&gt;LIKE&lt;/code&gt; 演算子、最新の &lt;code&gt;SIMILAR TO&lt;/code&gt; 演算子（SQL：1999で追加）、POSIXスタイルの正規表現の3つの方法があります。基本的な「この文字列はこのパターンに一致しますか？」演算子、関数を使用して、一致する部分文字列を抽出または置換したり、一致する場所で文字列を分割したりできます。</target>
        </trans-unit>
        <trans-unit id="c74bdd55156d3b2783c8a6fd237fe0bceb9cfeef" translate="yes" xml:space="preserve">
          <source>There are two approaches to enforce that users provide a certificate during login.</source>
          <target state="translated">ユーザーがログイン時に証明書を提供することを強制するには、2つのアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="03a8c876ced91bb81f55235d3d3af76552bcc675" translate="yes" xml:space="preserve">
          <source>There are two categories of limitation to keep in mind: the restriction from XQuery to XPath for the functions specified in the SQL standard, and the restriction of XPath to version 1.0 for both the standard and the PostgreSQL-specific functions.</source>
          <target state="translated">留意点としては、SQL標準で指定されている機能についてはXQueryからXPathへの制限と、XPathについては標準とPostgreSQL固有の機能についてはバージョン1.0への制限の2つがあります。</target>
        </trans-unit>
        <trans-unit id="45979291689bf78b7c41886076f2033f33bb0dc2" translate="yes" xml:space="preserve">
          <source>There are two columns containing the city name. This is correct because the lists of columns from the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables are concatenated. In practice this is undesirable, though, so you will probably want to list the output columns explicitly rather than using &lt;code&gt;*&lt;/code&gt;:</source>
          <target state="translated">都市名を含む2つの列があります。 &lt;code&gt;weather&lt;/code&gt; と &lt;code&gt;cities&lt;/code&gt; テーブルの列のリストが連結されているため、これは正しいです。ただし、実際にはこれは望ましくないため、 &lt;code&gt;*&lt;/code&gt; を使用するのではなく、出力列を明示的にリストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="65ab8b09fb62c8b1237a292bc36db36c5b33b77b" translate="yes" xml:space="preserve">
          <source>There are two commonly used internal WAL functions: &lt;code&gt;XLogInsertRecord&lt;/code&gt; and &lt;code&gt;XLogFlush&lt;/code&gt;. &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used to place a new record into the WAL buffers in shared memory. If there is no space for the new record, &lt;code&gt;XLogInsertRecord&lt;/code&gt; will have to write (move to kernel cache) a few filled WAL buffers. This is undesirable because &lt;code&gt;XLogInsertRecord&lt;/code&gt; is used on every database low level modification (for example, row insertion) at a time when an exclusive lock is held on affected data pages, so the operation needs to be as fast as possible. What is worse, writing WAL buffers might also force the creation of a new log segment, which takes even more time. Normally, WAL buffers should be written and flushed by an &lt;code&gt;XLogFlush&lt;/code&gt; request, which is made, for the most part, at transaction commit time to ensure that transaction records are flushed to permanent storage. On systems with high log output, &lt;code&gt;XLogFlush&lt;/code&gt; requests might not occur often enough to prevent &lt;code&gt;XLogInsertRecord&lt;/code&gt; from having to do writes. On such systems one should increase the number of WAL buffers by modifying the &lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt; parameter. When &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is set and the system is very busy, setting &lt;code&gt;wal_buffers&lt;/code&gt; higher will help smooth response times during the period immediately following each checkpoint.</source>
          <target state="translated">&lt;code&gt;XLogInsertRecord&lt;/code&gt; と &lt;code&gt;XLogFlush&lt;/code&gt; の 2つの一般的に使用される内部WAL関数があります。 &lt;code&gt;XLogInsertRecord&lt;/code&gt; は、新しいレコードを共有メモリのWALバッファに配置するために使用されます。新しいレコード用のスペースがない場合、 &lt;code&gt;XLogInsertRecord&lt;/code&gt; はいくつかの満たされたWALバッファーを書き込む（カーネルキャッシュに移動する）必要があります。 &lt;code&gt;XLogInsertRecord&lt;/code&gt; は、影響を受けるデータページで排他ロックが保持されているときに、すべてのデータベースの低レベルの変更（たとえば、行の挿入）で使用されるため、望ましくないため、操作は可能な限り高速である必要があります。さらに悪いことに、WALバッファーを書き込むと、新しいログセグメントの作成が強制され、さらに時間がかかります。通常、WALバッファーは、 &lt;code&gt;XLogFlush&lt;/code&gt; リクエスト。トランザクションレコードが永続的なストレージに確実にフラッシュされるように、トランザクションコミット時にほとんどの場合行われます。高いログ出力を持つシステムでは、 &lt;code&gt;XLogFlush&lt;/code&gt; の要求が防ぐために十分な頻度で発生しない可能性があります &lt;code&gt;XLogInsertRecord&lt;/code&gt; を書き込みを行うにはなるから。このようなシステムでは、&lt;a href=&quot;runtime-config-wal#GUC-WAL-BUFFERS&quot;&gt;wal_buffers&lt;/a&gt;パラメータを変更して、WALバッファの数を増やす必要があります。とき&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writesをを&lt;/a&gt;設定し、システムが設定して、非常に忙しいです &lt;code&gt;wal_buffers&lt;/code&gt; をすぐに各チェックポイント以下の期間中にスムーズな応答時間を助ける高いです。</target>
        </trans-unit>
        <trans-unit id="e556036ec4c364c079311c21d04103cf4c7118b6" translate="yes" xml:space="preserve">
          <source>There are two differences in the behavior of &lt;code&gt;string_to_array&lt;/code&gt; from pre-9.1 versions of PostgreSQL. First, it will return an empty (zero-element) array rather than NULL when the input string is of zero length. Second, if the delimiter string is NULL, the function splits the input into individual characters, rather than returning NULL as before.</source>
          <target state="translated">9.1より前のバージョンのPostgreSQL と &lt;code&gt;string_to_array&lt;/code&gt; の動作には2つの違いがあります。まず、入力文字列の長さがゼロの場合、NULLではなく空（ゼロ要素）配列を返します。次に、区切り文字列がNULLの場合、関数は以前のようにNULLを返すのではなく、入力を個々の文字に分割します。</target>
        </trans-unit>
        <trans-unit id="9a38ac647b826e47337bf978dbd260eda2d37e47" translate="yes" xml:space="preserve">
          <source>There are two forms of the &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; command. In the first form, the user supplies just the name of the desired language, and the PostgreSQL server consults the &lt;a href=&quot;catalog-pg-pltemplate&quot;&gt;&lt;code&gt;pg_pltemplate&lt;/code&gt;&lt;/a&gt; system catalog to determine the correct parameters. In the second form, the user supplies the language parameters along with the language name. The second form can be used to create a language that is not defined in &lt;code&gt;pg_pltemplate&lt;/code&gt;, but this approach is considered obsolescent.</source>
          <target state="translated">&lt;code&gt;CREATE LANGUAGE&lt;/code&gt; コマンドには2つの形式があります。最初の形式では、ユーザーは希望する言語の名前のみを指定し、PostgreSQLサーバーは&lt;a href=&quot;catalog-pg-pltemplate&quot;&gt; &lt;code&gt;pg_pltemplate&lt;/code&gt; &lt;/a&gt;システムカタログを調べて正しいパラメーターを決定します。 2番目の形式では、ユーザーは言語名とともに言語パラメーターを指定します。 2番目の形式は &lt;code&gt;pg_pltemplate&lt;/code&gt; で定義されていない言語を作成するために使用できますが、このアプローチは廃止されたと見なされています。</target>
        </trans-unit>
        <trans-unit id="f9cc8590527e484357685c3a4d915bc501e931e5" translate="yes" xml:space="preserve">
          <source>There are two kinds of indexes that can be used to speed up full text searches. Note that indexes are not mandatory for full text searching, but in cases where a column is searched on a regular basis, an index is usually desirable.</source>
          <target state="translated">フルテキスト検索を高速化するために使用できるインデックスには2種類あります。フルテキスト検索ではインデックスは必須ではありませんが、あるカラムが定期的に検索される場合には、通常インデックスが望ましいことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0b78b765f97cf8944029e53f4ab00dc6de355959" translate="yes" xml:space="preserve">
          <source>There are two methods that an operator class for GIN must provide:</source>
          <target state="translated">GIN用の演算子クラスが提供しなければならないメソッドは2つあります。</target>
        </trans-unit>
        <trans-unit id="2ebcfbeecc8c9e28432149890e115326d408ee9d" translate="yes" xml:space="preserve">
          <source>There are two other fixed-length character types in PostgreSQL, shown in &lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;Table 8.5&lt;/a&gt;. The &lt;code&gt;name&lt;/code&gt; type exists &lt;em&gt;only&lt;/em&gt; for the storage of identifiers in the internal system catalogs and is not intended for use by the general user. Its length is currently defined as 64 bytes (63 usable characters plus terminator) but should be referenced using the constant &lt;code&gt;NAMEDATALEN&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; source code. The length is set at compile time (and is therefore adjustable for special uses); the default maximum length might change in a future release. The type &lt;code&gt;&quot;char&quot;&lt;/code&gt; (note the quotes) is different from &lt;code&gt;char(1)&lt;/code&gt; in that it only uses one byte of storage. It is internally used in the system catalogs as a simplistic enumeration type.</source>
          <target state="translated">&lt;a href=&quot;datatype-character#DATATYPE-CHARACTER-SPECIAL-TABLE&quot;&gt;表8.5&lt;/a&gt;に示すように、PostgreSQLには他に2つの固定長文字型があります。 &lt;code&gt;name&lt;/code&gt; タイプが存在する&lt;em&gt;のみで&lt;/em&gt;、内部システム・カタログ内の識別子を記憶するため、および一般ユーザによる使用のために意図されていません。その長さは現在64バイト（63の使用可能な文字とターミネーター）として定義されていますが、 &lt;code&gt;C&lt;/code&gt; ソースコードで定数 &lt;code&gt;NAMEDATALEN&lt;/code&gt; を使用して参照する必要があります。長さはコンパイル時に設定されます（したがって、特別な用途のために調整可能です）。デフォルトの最大長は、将来のリリースで変更される可能性があります。タイプ &lt;code&gt;&quot;char&quot;&lt;/code&gt; （引用符に注意）は &lt;code&gt;char(1)&lt;/code&gt; とは異なりますつまり、1バイトのストレージしか使用しません。これは、単純な列挙型としてシステムカタログで内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="1a65ab8661e9c6e6250372b71f3e4d52aadd8690" translate="yes" xml:space="preserve">
          <source>There are two restrictions, however, which make this method impractical, or at least inferior to the pg_dump method:</source>
          <target state="translated">しかし、この方法には2つの制限があり、この方法は実用的ではないか、少なくともpg_dumpメソッドよりは劣っています。</target>
        </trans-unit>
        <trans-unit id="eb559c725c45849ac1890ba81d8ba70c6affbb84" translate="yes" xml:space="preserve">
          <source>There are two significant ways in which run times measured by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can deviate from normal execution of the same query. First, since no output rows are delivered to the client, network transmission costs and I/O conversion costs are not included. Second, the measurement overhead added by &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; can be significant, especially on machines with slow &lt;code&gt;gettimeofday()&lt;/code&gt; operating-system calls. You can use the &lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt; tool to measure the overhead of timing on your system.</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; によって測定された実行時間が同じクエリの通常の実行から逸脱する可能性がある2つの重要な方法があります。まず、出力行がクライアントに配信されないため、ネットワーク伝送コストとI / O変換コストは含まれません。第2に、 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; によって追加される測定オーバ​​ーヘッドは、特にオペレーティングシステムの &lt;code&gt;gettimeofday()&lt;/code&gt; 呼び出しが遅いマシンでは、かなり大きくなる可能性があります。&lt;a href=&quot;pgtesttiming&quot;&gt;pg_test_timing&lt;/a&gt;ツールを使用して、システムのタイミングのオーバーヘッドを測定できます。</target>
        </trans-unit>
        <trans-unit id="e4b4937b46d88bd048aae10c82ed3779adc47d2b" translate="yes" xml:space="preserve">
          <source>There are two special cases of bracket expressions: the bracket expressions &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an &lt;code&gt;alnum&lt;/code&gt; character (as defined by the POSIX character class described above) or an underscore. This is an extension, compatible with but not specified by POSIX 1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type.</source>
          <target state="translated">ブラケット式には2つの特殊なケースがあります。ブラケット式 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; と &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; は制約であり、単語の先頭と末尾の空の文字列にそれぞれ一致します。単語は、単語文字の前にも後にもない一連の単語文字として定義されます。単語文字は、（上記のPOSIX文字クラスで定義されている） &lt;code&gt;alnum&lt;/code&gt; 文字または下線です。これは拡張機能であり、POSIX 1003.2と互換性がありますが指定されていません。他のシステムへの移植を意図したソフトウェアでは注意して使用する必要があります。以下で説明する制約エスケープは、通常は望ましい方法です。それらはもはや標準ではありませんが、タイプするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="33967632431b8aaf7d1ba8660310b5c4fbf05d2a" translate="yes" xml:space="preserve">
          <source>There are two variants of &lt;code&gt;VACUUM&lt;/code&gt;: standard &lt;code&gt;VACUUM&lt;/code&gt; and &lt;code&gt;VACUUM FULL&lt;/code&gt;. &lt;code&gt;VACUUM FULL&lt;/code&gt; can reclaim more disk space but runs much more slowly. Also, the standard form of &lt;code&gt;VACUUM&lt;/code&gt; can run in parallel with production database operations. (Commands such as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; will continue to function normally, though you will not be able to modify the definition of a table with commands such as &lt;code&gt;ALTER TABLE&lt;/code&gt; while it is being vacuumed.) &lt;code&gt;VACUUM FULL&lt;/code&gt; requires exclusive lock on the table it is working on, and therefore cannot be done in parallel with other use of the table. Generally, therefore, administrators should strive to use standard &lt;code&gt;VACUUM&lt;/code&gt; and avoid &lt;code&gt;VACUUM FULL&lt;/code&gt;.</source>
          <target state="translated">二つの変種があります &lt;code&gt;VACUUM&lt;/code&gt; 標準： &lt;code&gt;VACUUM&lt;/code&gt; と &lt;code&gt;VACUUM FULL&lt;/code&gt; は。 &lt;code&gt;VACUUM FULL&lt;/code&gt; は、より多くのディスク領域を再利用できますが、実行速度ははるかに遅くなります。また、 &lt;code&gt;VACUUM&lt;/code&gt; の標準形式は、本番データベースの操作と並行して実行できます。 （ &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; などのコマンドは引き続き正常に機能しますが、バキュームされている間は &lt;code&gt;ALTER TABLE&lt;/code&gt; などのコマンドを使用してテーブルの定義を変更することはできません。） &lt;code&gt;VACUUM FULL&lt;/code&gt; 作業中のテーブルに排他ロックが必要なため、テーブルの他の使用と並行して実行することはできません。したがって、一般に、管理者は標準の &lt;code&gt;VACUUM&lt;/code&gt; を使用し、 &lt;code&gt;VACUUM FULL&lt;/code&gt; を回避するように努力する必要があります。</target>
        </trans-unit>
        <trans-unit id="082cbad2612b1a539364141256cd8c079fbdd04c" translate="yes" xml:space="preserve">
          <source>There are two ways to acquire an advisory lock in PostgreSQL: at session level or at transaction level. Once acquired at session level, an advisory lock is held until explicitly released or the session ends. Unlike standard lock requests, session-level advisory lock requests do not honor transaction semantics: a lock acquired during a transaction that is later rolled back will still be held following the rollback, and likewise an unlock is effective even if the calling transaction fails later. A lock can be acquired multiple times by its owning process; for each completed lock request there must be a corresponding unlock request before the lock is actually released. Transaction-level lock requests, on the other hand, behave more like regular lock requests: they are automatically released at the end of the transaction, and there is no explicit unlock operation. This behavior is often more convenient than the session-level behavior for short-term usage of an advisory lock. Session-level and transaction-level lock requests for the same advisory lock identifier will block each other in the expected way. If a session already holds a given advisory lock, additional requests by it will always succeed, even if other sessions are awaiting the lock; this statement is true regardless of whether the existing lock hold and new request are at session level or transaction level.</source>
          <target state="translated">PostgreSQLでアドバイザリーロックを取得するには、セッションレベルとトランザクションレベルの2つの方法があります。セッションレベルで取得したアドバイザリーロックは、明示的に解放されるかセッションが終了するまで保持されます。標準的なロック要求とは異なり、セッションレベルのアドバイザリーロック要求はトランザクションのセマンティクスを尊重しません。ロックは、それを所有するプロセスによって複数回取得することができます。完了した各ロック要求に対して、ロックが実際に解放される前に、対応するアンロック要求がなければなりません。一方、トランザクションレベルのロック要求は、通常のロック要求のように振る舞います。この動作は、アドバイザリー・ロックを短期的に使用する場合には、セッションレベルの動作よりも便利であることが多いです。同じアドバイザリロック識別子に対するセッションレベルとトランザクションレベルのロック リクエストは、期待される方法でお互いをブロックし合います。あるセッションが既にあるアドバイザリロックを保持している場合、他のセッションがそのロックを待っていても、そのセッションによる追加のリクエストは常に成功します。</target>
        </trans-unit>
        <trans-unit id="d918b8ea922c6c6ee662eb9ab4cebb7da36eb443" translate="yes" xml:space="preserve">
          <source>There are two ways to define constraints: table constraints and column constraints. A column constraint is defined as part of a column definition. A table constraint definition is not tied to a particular column, and it can encompass more than one column. Every column constraint can also be written as a table constraint; a column constraint is only a notational convenience for use when the constraint only affects one column.</source>
          <target state="translated">制約を定義するには、テーブル制約と列制約の2つの方法があります。列制約は、列の定義の一部として定義されます。テーブル制約の定義は、特定の列に縛られず、複数の列を含むことができます。すべての列制約は、テーブル制約として記述することもできます。列制約は、制約が1つの列にのみ影響を与える場合に使用するための表記上の利便性に過ぎません。</target>
        </trans-unit>
        <trans-unit id="3100ad6baa7faf64044c5fff315dddab6008581f" translate="yes" xml:space="preserve">
          <source>There are two ways to delete rows in a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;USING&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">データベース内の他のテーブルに含まれる情報を使用してテーブル内の行を削除するには、副選択を使用する方法と、 &lt;code&gt;USING&lt;/code&gt; 句で追加のテーブルを指定する方法の2つがあります。どの手法がより適切であるかは、特定の状況によって異なります。</target>
        </trans-unit>
        <trans-unit id="9d2cb602ac946da832fb98a751bc210a74312a33" translate="yes" xml:space="preserve">
          <source>There are two ways to modify a table using information contained in other tables in the database: using sub-selects, or specifying additional tables in the &lt;code&gt;FROM&lt;/code&gt; clause. Which technique is more appropriate depends on the specific circumstances.</source>
          <target state="translated">データベース内の他のテーブルに含まれる情報を使用してテーブルを変更するには、副選択を使用する方法と、 &lt;code&gt;FROM&lt;/code&gt; 句で追加のテーブルを指定する方法の2つがあります。どの手法がより適切であるかは、特定の状況によって異なります。</target>
        </trans-unit>
        <trans-unit id="aa2e4ae09129d50722332a9a349176e58b93478a" translate="yes" xml:space="preserve">
          <source>There are various shortcut commands for &lt;code&gt;\pset&lt;/code&gt;. See &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\C&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\T&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\pset&lt;/code&gt; はさまざまなショートカットコマンドがあります。参照 &lt;code&gt;\a&lt;/code&gt; 、 &lt;code&gt;\C&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\H&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、 &lt;code&gt;\T&lt;/code&gt; 、及び &lt;code&gt;\x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36d44242f8d38cae700147e3f10ad23b2c1671f8" translate="yes" xml:space="preserve">
          <source>There are various special syntax rules and behaviors associated with composite types in queries. These rules provide useful shortcuts, but can be confusing if you don't know the logic behind them.</source>
          <target state="translated">クエリ内の複合型には、さまざまな特殊な構文ルールや動作があります。これらのルールは便利なショートカットを提供しますが、その背後にあるロジックを知らない場合は混乱を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="adeaa568e81b8c22d184926d9648a6a85b174068" translate="yes" xml:space="preserve">
          <source>There can be multiple &lt;code&gt;pg_basebackup&lt;/code&gt;s running at the same time, but it is better from a performance point of view to take only one backup, and copy the result.</source>
          <target state="translated">同時に複数の &lt;code&gt;pg_basebackup&lt;/code&gt; が実行されている可能性がありますが、パフォーマンスの観点からは、バックアップを1つだけ取得して結果をコピーする方が適切です。</target>
        </trans-unit>
        <trans-unit id="241118165bea21fbe830bef68a27cbb0152bef40" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;simple&amp;rdquo; form of &lt;code&gt;CASE&lt;/code&gt; expression that is a variant of the general form above:</source>
          <target state="translated">上記の一般的な形式の変形である &lt;code&gt;CASE&lt;/code&gt; 式の「単純な」形式があります。</target>
        </trans-unit>
        <trans-unit id="0a329b25f5c93a21ac5ea836673c784c6afc768a" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;CREATE COLLATION&lt;/code&gt; statement in the SQL standard, but it is limited to copying an existing collation. The syntax to create a new collation is a PostgreSQL extension.</source>
          <target state="translated">あり &lt;code&gt;CREATE COLLATION&lt;/code&gt; の SQL標準でステートメントが、それは、既存の照合をコピーするに限定されています。新しい照合を作成する構文は、PostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="74c08b98f45942b4395776e7da22b84f7266e5c2" translate="yes" xml:space="preserve">
          <source>There is a catch if you try to use conditional rules for complex view updates: there &lt;em&gt;must&lt;/em&gt; be an unconditional &lt;code&gt;INSTEAD&lt;/code&gt; rule for each action you wish to allow on the view. If the rule is conditional, or is not &lt;code&gt;INSTEAD&lt;/code&gt;, then the system will still reject attempts to perform the update action, because it thinks it might end up trying to perform the action on the dummy table of the view in some cases. If you want to handle all the useful cases in conditional rules, add an unconditional &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; rule to ensure that the system understands it will never be called on to update the dummy table. Then make the conditional rules non-&lt;code&gt;INSTEAD&lt;/code&gt;; in the cases where they are applied, they add to the default &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; action. (This method does not currently work to support &lt;code&gt;RETURNING&lt;/code&gt; queries, however.)</source>
          <target state="translated">複雑なビューの更新に条件付きルールを使用しようとすると、注意点が&lt;em&gt;あり&lt;/em&gt;ます。ビューで許可するアクションごとに、無条件の &lt;code&gt;INSTEAD&lt;/code&gt; ルールが&lt;em&gt;必要&lt;/em&gt;です。ルールが条件付きの場合、または &lt;code&gt;INSTEAD&lt;/code&gt; でない場合でも、システムは、場合によってはビューのダミーテーブルでアクションを実行しようとする可能性があると考えるため、更新アクションの実行試行を拒否します。条件付きルールですべての有用なケースを処理する場合は、無条件の &lt;code&gt;DO INSTEAD NOTHING&lt;/code&gt; ルールを追加して、ダミーテーブルを更新するために呼び出されることはないことをシステムが理解できるようにします。次に、条件ルールを &lt;code&gt;INSTEAD&lt;/code&gt; 以外にします。適用される場合、デフォルトに追加されます &lt;code&gt;INSTEAD NOTHING&lt;/code&gt; アクション。（ただし、現在、このメソッドは &lt;code&gt;RETURNING&lt;/code&gt; クエリをサポートするようには機能していません。）</target>
        </trans-unit>
        <trans-unit id="c21f127ac29ffa6b6d6cad86ad16cb8ebd82f4c7" translate="yes" xml:space="preserve">
          <source>There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design.</source>
          <target state="translated">テーブルに格納できる列の数には制限があります。カラムの種類にもよりますが、250から1600の間です。しかし、これに近い数のカラムを持つテーブルを定義することは非常に珍しいことであり、多くの場合、設計には疑問が残ります。</target>
        </trans-unit>
        <trans-unit id="60f67c0e3cf6c026c3a97cec11f99b88526b93a6" translate="yes" xml:space="preserve">
          <source>There is a more general version of the FOLLOWED BY operator having the form &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer standing for the difference between the positions of the matching lexemes. &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; is the same as &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, while &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; allows exactly one other lexeme to appear between the matches, and so on. The &lt;code&gt;phraseto_tsquery&lt;/code&gt; function makes use of this operator to construct a &lt;code&gt;tsquery&lt;/code&gt; that can match a multi-word phrase when some of the words are stop words. For example:</source>
          <target state="translated">形状のオペレータが続くのより一般的なバージョンがある &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; は、ここで、 &lt;code&gt;N&lt;/code&gt; は、マッチング語彙素の位置の差放置整数です。 &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; と同様である &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 、つつ、 &lt;code&gt;&amp;lt;2&amp;gt;&lt;/code&gt; は、マッチの間に表示される正確に一つの、他の語彙素を可能にする、というように。 &lt;code&gt;phraseto_tsquery&lt;/code&gt; の機能を構築するために、この演算子の使用可能 &lt;code&gt;tsquery&lt;/code&gt; 言葉のいくつかはストップワードのとき、マルチワードフレーズを一致させることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="98845715e9aff2aab5a7e45eba23b610067562bc" translate="yes" xml:space="preserve">
          <source>There is a possibility that a concurrent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; on the row being moved will get a serialization failure error. Suppose session 1 is performing an &lt;code&gt;UPDATE&lt;/code&gt; on a partition key, and meanwhile a concurrent session 2 for which this row is visible performs an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operation on this row. In such case, session 2's &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; will detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out the &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; on this new row version.</source>
          <target state="translated">移動中の行で同時に &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; を実行すると、シリアル化エラーエラーが発生する可能性があります。セッション1がパーティションキーに対して &lt;code&gt;UPDATE&lt;/code&gt; を実行し、その間にこの行が表示されている同時セッション2がこの行に対して &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 操作を実行するとします。そのような場合、セッション2の &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; 行の移動を検出し、シリアル化の失敗エラーを発生させます（常にSQLSTATEコード '40001'で戻ります）。これが発生した場合、アプリケーションはトランザクションを再試行できます。表がパーティション化されていない、または行の移動がない通常の場合、セッション2は新しく更新された行を識別し、この新しい行バージョンで &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="e2fb3023d52c67871f97870f963ae3e2511e1afd" translate="yes" xml:space="preserve">
          <source>There is a queue that holds notifications that have been sent but not yet processed by all listening sessions. If this queue becomes full, transactions calling &lt;code&gt;NOTIFY&lt;/code&gt; will fail at commit. The queue is quite large (8GB in a standard installation) and should be sufficiently sized for almost every use case. However, no cleanup can take place if a session executes &lt;code&gt;LISTEN&lt;/code&gt; and then enters a transaction for a very long time. Once the queue is half full you will see warnings in the log file pointing you to the session that is preventing cleanup. In this case you should make sure that this session ends its current transaction so that cleanup can proceed.</source>
          <target state="translated">送信されたがすべてのリスニングセッションでまだ処理されていない通知を保持するキューがあります。このキューがいっぱいになると、 &lt;code&gt;NOTIFY&lt;/code&gt; を呼び出すトランザクションはコミット時に失敗します。キューは非常に大きく（標準インストールでは8GB）、ほとんどすべてのユースケースで十分なサイズにする必要があります。ただし、セッションが &lt;code&gt;LISTEN&lt;/code&gt; を実行してから非常に長い時間トランザクションに入る場合、クリーンアップは実行できません。キューが半分いっぱいになると、ログファイルに警告が表示され、クリーンアップを妨げているセッションが示されます。この場合、クリーンアップを続行できるように、このセッションが現在のトランザクションを終了することを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="7f864b552f926f474ffeb07a0a68232c7a34815b" translate="yes" xml:space="preserve">
          <source>There is a second kind of identifier: the &lt;em&gt;delimited identifier&lt;/em&gt; or &lt;em&gt;quoted identifier&lt;/em&gt;. It is formed by enclosing an arbitrary sequence of characters in double-quotes (&lt;code&gt;&quot;&lt;/code&gt;). A delimited identifier is always an identifier, never a key word. So &lt;code&gt;&quot;select&quot;&lt;/code&gt; could be used to refer to a column or table named &amp;ldquo;select&amp;rdquo;, whereas an unquoted &lt;code&gt;select&lt;/code&gt; would be taken as a key word and would therefore provoke a parse error when used where a table or column name is expected. The example can be written with quoted identifiers like this:</source>
          <target state="translated">2つ目の種類の識別子があり&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;区切り識別子&lt;/em&gt;または&lt;em&gt;引用識別子&lt;/em&gt;です。文字の任意のシーケンスを二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）で囲むことによって形成されます。区切り識別子は常に識別子であり、キーワードではありません。そのため、「select」は「select」という名前の列またはテーブルを参照するために使用でき &lt;code&gt;&quot;select&quot;&lt;/code&gt; 。一方、引用符で囲まれていない &lt;code&gt;select&lt;/code&gt; はキーワードとして解釈されるため、テーブル名または列名が予想される場所で使用すると、解析エラーが発生します。この例は、次のように引用符で囲まれた識別子で記述できます。</target>
        </trans-unit>
        <trans-unit id="99e2749bbb2f806b8f89c17d420b1dde22c11b68" translate="yes" xml:space="preserve">
          <source>There is a second standard system database named &lt;code&gt;template0&lt;/code&gt;. This database contains the same data as the initial contents of &lt;code&gt;template1&lt;/code&gt;, that is, only the standard objects predefined by your version of PostgreSQL. &lt;code&gt;template0&lt;/code&gt; should never be changed after the database cluster has been initialized. By instructing &lt;code&gt;CREATE DATABASE&lt;/code&gt; to copy &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt;, you can create a &amp;ldquo;virgin&amp;rdquo; user database that contains none of the site-local additions in &lt;code&gt;template1&lt;/code&gt;. This is particularly handy when restoring a &lt;code&gt;pg_dump&lt;/code&gt; dump: the dump script should be restored in a virgin database to ensure that one recreates the correct contents of the dumped database, without conflicting with objects that might have been added to &lt;code&gt;template1&lt;/code&gt; later on.</source>
          <target state="translated">&lt;code&gt;template0&lt;/code&gt; という名前の2番目の標準システムデータベースがあります。このデータベースには、 &lt;code&gt;template1&lt;/code&gt; の初期コンテンツと同じデータ、つまり、ご使用のバージョンのPostgreSQLによって事前定義された標準オブジェクトのみが含まれています。データベースクラスターが初期化された後、 &lt;code&gt;template0&lt;/code&gt; を変更しないでください。指示により &lt;code&gt;CREATE DATABASE&lt;/code&gt; コピーする &lt;code&gt;template0&lt;/code&gt; 代わりに &lt;code&gt;template1&lt;/code&gt; のを、あなたは中にサイトローカルの追加のどれも含まれていない「処女」のユーザデータベースを作成することができ &lt;code&gt;template1&lt;/code&gt; 。これは、 &lt;code&gt;pg_dump&lt;/code&gt; を復元するときに特に便利です。ダンプ：ダンプスクリプトを新しいデータベースに復元して、後で &lt;code&gt;template1&lt;/code&gt; に追加された可能性のあるオブジェクトと競合することなく、ダンプされたデータベースの正しいコンテンツを再作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4adb0689e8eca60cac4109882f9fd73f05b7582" translate="yes" xml:space="preserve">
          <source>There is a separate server process called the &lt;em&gt;background writer&lt;/em&gt;, whose function is to issue writes of &amp;ldquo;dirty&amp;rdquo; (new or modified) shared buffers. It writes shared buffers so server processes handling user queries seldom or never need to wait for a write to occur. However, the background writer does cause a net overall increase in I/O load, because while a repeatedly-dirtied page might otherwise be written only once per checkpoint interval, the background writer might write it several times as it is dirtied in the same interval. The parameters discussed in this subsection can be used to tune the behavior for local needs.</source>
          <target state="translated">&lt;em&gt;バックグラウンドライター&lt;/em&gt;と呼ばれる別のサーバープロセスがあり、その機能は「ダーティ」（新規または変更された）共有バッファーの書き込みを発行することです。共有バッファを書き込むため、ユーザークエリを処理するサーバープロセスは、書き込みが発生するのをほとんどまたはまったく待つ必要がありません。ただし、バックグラウンドライターは、I / O負荷の全体的な増加を引き起こします。なぜなら、繰り返しダーティ化されたページは、チェックポイント間隔ごとに1回だけ書き込まれる可能性がありますが、バックグラウンドライターは、同じ間隔で汚れているため、複数回書き込む可能性があるためです。 。このサブセクションで説明するパラメーターを使用して、ローカルのニーズに合わせて動作を調整できます。</target>
        </trans-unit>
        <trans-unit id="90974f119b06bcf646bf0eec46102bc09a0eac90" translate="yes" xml:space="preserve">
          <source>There is a simple variable-substitution facility for script files. Variable names must consist of letters (including non-Latin letters), digits, and underscores. Variables can be set by the command-line &lt;code&gt;-D&lt;/code&gt; option, explained above, or by the meta commands explained below. In addition to any variables preset by &lt;code&gt;-D&lt;/code&gt; command-line options, there are a few variables that are preset automatically, listed in &lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;Table 257&lt;/a&gt;. A value specified for these variables using &lt;code&gt;-D&lt;/code&gt; takes precedence over the automatic presets. Once set, a variable's value can be inserted into a SQL command by writing &lt;code&gt;:&lt;/code&gt;&lt;code&gt;variablename&lt;/code&gt;. When running more than one client session, each session has its own set of variables. pgbench supports up to 255 variable uses in one statement.</source>
          <target state="translated">スクリプトファイル用の簡単な変数置換機能があります。変数名は、文字（非ラテン文字を含む）、数字、およびアンダースコアで構成する必要があります。変数は、上記で説明したコマンドライン &lt;code&gt;-D&lt;/code&gt; オプション、または以下で説明するメタコマンドで設定できます。 &lt;code&gt;-D&lt;/code&gt; コマンドラインオプションで事前に設定された変数に加えて、自動的に事前設定されるいくつかの変数があります（&lt;a href=&quot;pgbench#PGBENCH-AUTOMATIC-VARIABLES&quot;&gt;表257を参照）&lt;/a&gt;。 &lt;code&gt;-D&lt;/code&gt; を使用してこれらの変数に指定された値は、自動プリセットよりも優先されます。一度設定すると、変数の値を書き込むことで、SQLコマンドに挿入することができます &lt;code&gt;:&lt;/code&gt; &lt;code&gt;variablename&lt;/code&gt; 。複数のクライアントセッションを実行する場合、各セッションには独自の変数のセットがあります。pgbenchは、1つのステートメントで最大255の変数の使用をサポートします。</target>
        </trans-unit>
        <trans-unit id="84b40deac5f431c882b47bcec560aceab88cb2ea" translate="yes" xml:space="preserve">
          <source>There is a strong connection between the XQuery language and XPath versions 2.0 and later: any expression that is syntactically valid and executes successfully in both produces the same result (with a minor exception for expressions containing numeric character references or predefined entity references, which XQuery replaces with the corresponding character while XPath leaves them alone). But there is no such connection between these languages and XPath 1.0; it was an earlier language and differs in many respects.</source>
          <target state="translated">XQuery言語とXPathバージョン2.0以降の間には強い関連性があります。構文的に有効で、両方で正常に実行される式はすべて同じ結果を生成します(ただし、数値文字参照または定義済みのエンティティ参照を含む式については例外があり、XQueryは対応する文字に置き換えますが、XPathはそれらをそのままにします)。しかし、これらの言語と XPath 1.0 の間にはそのような関連性はありません。</target>
        </trans-unit>
        <trans-unit id="c56c39bf47cf0690546e1095f601459a05ce75db" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; parameter, which determines the placement of temporary tables and indexes, as well as temporary files that are used for purposes such as sorting large data sets. This can be a list of tablespace names, rather than only one, so that the load associated with temporary objects can be spread over multiple tablespaces. A random member of the list is picked each time a temporary object is to be created.</source>
          <target state="translated">一時テーブルとインデックスの配置を決定する&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;パラメータ、および大きなデータセットのソートなどの目的で使用される一時ファイルもあります。これは、1つだけではなく、テーブルスペース名のリストにすることもできます。これにより、一時オブジェクトに関連する負荷を複数のテーブルスペースに分散できます。一時オブジェクトが作成されるたびに、リストのランダムなメンバーが選択されます。</target>
        </trans-unit>
        <trans-unit id="58b9a64bc7c6fc9848f60613899f8c2ff0dc12dc" translate="yes" xml:space="preserve">
          <source>There is also a non-default GIN operator class &lt;code&gt;gin__int_ops&lt;/code&gt; supporting the same operators.</source>
          <target state="translated">同じ演算子をサポートするデフォルト以外のGIN演算子クラス &lt;code&gt;gin__int_ops&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="3d6db9a7a400632bced3a61ed8d0f591628a4c78" translate="yes" xml:space="preserve">
          <source>There is also a single-argument &lt;code&gt;to_timestamp&lt;/code&gt; function; see &lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;Table 9.31&lt;/a&gt;.</source>
          <target state="translated">単一引数の &lt;code&gt;to_timestamp&lt;/code&gt; 関数もあります。&lt;a href=&quot;functions-datetime#FUNCTIONS-DATETIME-TABLE&quot;&gt;表9.31を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="41669b255a0d94f06b45d60440ba0720ed574d46" translate="yes" xml:space="preserve">
          <source>There is also a two-parameter version of &lt;code&gt;xslt_process&lt;/code&gt; which does not pass any parameters to the transformation.</source>
          <target state="translated">また、変換にパラメーターを渡さない2パラメーターバージョンの &lt;code&gt;xslt_process&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="1ad78e13b5545fbac4993cd2573ccb0145f0260a" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;include_if_exists&lt;/code&gt; directive, which acts the same as the &lt;code&gt;include&lt;/code&gt; directive, except when the referenced file does not exist or cannot be read. A regular &lt;code&gt;include&lt;/code&gt; will consider this an error condition, but &lt;code&gt;include_if_exists&lt;/code&gt; merely logs a message and continues processing the referencing configuration file.</source>
          <target state="translated">また、 &lt;code&gt;include_if_exists&lt;/code&gt; ディレクティブもあり、参照ファイルが存在しないか、読み取ることができない場合を除いて、 &lt;code&gt;include&lt;/code&gt; ディレクティブと同じように機能します。通常の &lt;code&gt;include&lt;/code&gt; はこれをエラー条件と見なし &lt;code&gt;include_if_exists&lt;/code&gt; が、include_if_existsはメッセージをログに記録し、参照している構成ファイルの処理を続行します。</target>
        </trans-unit>
        <trans-unit id="87e6a166488f605dc208dade3f60cf2f1017cef3" translate="yes" xml:space="preserve">
          <source>There is also an exception to the exception: I/O conversion casts from composite types to string types cannot be invoked using functional syntax, but must be written in explicit cast syntax (either &lt;code&gt;CAST&lt;/code&gt; or &lt;code&gt;::&lt;/code&gt; notation). This exception was added because after the introduction of automatically-provided I/O conversion casts, it was found too easy to accidentally invoke such a cast when a function or column reference was intended.</source>
          <target state="translated">例外には例外もあります。複合型から文字列型へのI / O変換キャストは、関数構文を使用して呼び出すことはできませんが、明示的なキャスト構文（ &lt;code&gt;CAST&lt;/code&gt; または &lt;code&gt;::&lt;/code&gt; 表記）で記述する必要があります。この例外が追加されたのは、自動的に提供されるI / O変換キャストの導入後、関数または列参照が意図されていたときに、そのようなキャストを誤って呼び出すことが非常に簡単であることが判明したためです。</target>
        </trans-unit>
        <trans-unit id="10e49e8f0395261cca6c9bddfde366e5b44bc0fa" translate="yes" xml:space="preserve">
          <source>There is also an option to grant privileges on all objects of the same type within one or more schemas. This functionality is currently supported only for tables, sequences, functions, and procedures. &lt;code&gt;ALL TABLES&lt;/code&gt; also affects views and foreign tables, just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; also affects aggregate and window functions, but not procedures, again just like the specific-object &lt;code&gt;GRANT&lt;/code&gt; command. Use &lt;code&gt;ALL ROUTINES&lt;/code&gt; to include procedures.</source>
          <target state="translated">1つ以上のスキーマ内の同じタイプのすべてのオブジェクトに対する特権を付与するオプションもあります。この機能は現在、テーブル、シーケンス、関数、およびプロシージャでのみサポートされています。 &lt;code&gt;ALL TABLES&lt;/code&gt; は、特定のオブジェクトの &lt;code&gt;GRANT&lt;/code&gt; コマンドと同様に、ビューと外部テーブルにも影響します。 &lt;code&gt;ALL FUNCTIONS&lt;/code&gt; は、特定のオブジェクトの &lt;code&gt;GRANT&lt;/code&gt; コマンドと同じように、集計関数とウィンドウ関数にも影響しますが、プロシージャには影響しません。 &lt;code&gt;ALL ROUTINES&lt;/code&gt; を使用してプロシージャを含めます。</target>
        </trans-unit>
        <trans-unit id="5a702bafff3c7f4c616d64a2b71bb4d856736202" translate="yes" xml:space="preserve">
          <source>There is also the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function which covers cases when only searching by beginning of the string is needed.</source>
          <target state="translated">プレフィックス演算子 &lt;code&gt;^@&lt;/code&gt; と対応する &lt;code&gt;starts_with&lt;/code&gt; 関数もあり、文字列の先頭から検索するだけでよい場合をカバーしています。</target>
        </trans-unit>
        <trans-unit id="012b88356356711e33f301f2bb1596f7e0f835cc" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;autoinc.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoinc.example&lt;/code&gt; に例があります。</target>
        </trans-unit>
        <trans-unit id="93425455a73285f0e21d7315c96b601935f70ba0" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;insert_username.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert_username.example&lt;/code&gt; に例があります。</target>
        </trans-unit>
        <trans-unit id="16b24fdd30442f553bc5891f105491e9f92bd108" translate="yes" xml:space="preserve">
          <source>There is an example in &lt;code&gt;moddatetime.example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;moddatetime.example&lt;/code&gt; に例があります。</target>
        </trans-unit>
        <trans-unit id="d2b9c61965fcc66e74624ddfce72996d337e8786" translate="yes" xml:space="preserve">
          <source>There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal.</source>
          <target state="translated">8進数文字列のエスケープと後方参照の間には固有の曖昧さがありますが、これは上でヒントにしたように、以下のヒューリスティックによって解決されます。先頭のゼロは常に8進数エスケープを示します。ゼロではない単一の桁は、他の桁の後に続くものではなく、常に後方参照として扱われます。ゼロで始まらない複数桁の数字列は、それが適切な代入表現の後に来る場合(つまり、その数字が後方参照のための法的範囲内にある場合)は後方参照とみなされ、それ以外の場合は8進数とみなされます。</target>
        </trans-unit>
        <trans-unit id="2d4f42c096704e40b12586b5cb5d82cbdaf1b311" translate="yes" xml:space="preserve">
          <source>There is an optional second parameter of type &lt;code&gt;boolean&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, it specifies executing &lt;code&gt;pg_start_backup&lt;/code&gt; as quickly as possible. This forces an immediate checkpoint which will cause a spike in I/O operations, slowing any concurrently executing queries.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型のオプションの2番目のパラメーターがあります。場合は &lt;code&gt;true&lt;/code&gt; 、それが実行指定 &lt;code&gt;pg_start_backup&lt;/code&gt; 可能な限り迅速に。これにより、即時のチェックポイントが強制され、I / O操作が急増し、同時に実行されているクエリの速度が低下します。</target>
        </trans-unit>
        <trans-unit id="39681348944621b0cbdb87c4dd79d5e8a6ab1c87" translate="yes" xml:space="preserve">
          <source>There is another important concept associated with window functions: for each row, there is a set of rows within its partition called its &lt;em&gt;window frame&lt;/em&gt;. Some window functions act only on the rows of the window frame, rather than of the whole partition. By default, if &lt;code&gt;ORDER BY&lt;/code&gt; is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the &lt;code&gt;ORDER BY&lt;/code&gt; clause. When &lt;code&gt;ORDER BY&lt;/code&gt; is omitted the default frame consists of all rows in the partition. &lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]&lt;/sup&gt;&lt;/a&gt; Here is an example using &lt;code&gt;sum&lt;/code&gt;:</source>
          <target state="translated">ウィンドウ関数に関連する別の重要な概念があります。各行について、その&lt;em&gt;ウィンドウフレーム&lt;/em&gt;と呼ばれるパーティション内に行のセットがあります。一部のウィンドウ関数は、パーティション全体ではなく、ウィンドウフレームの行にのみ作用します。デフォルトでは、 &lt;code&gt;ORDER BY&lt;/code&gt; が指定されている場合、フレームは、パーティションの先頭から現在の行までのすべての行と、 &lt;code&gt;ORDER BY&lt;/code&gt; 句に従って現在の行に等しい後続の行で構成されます。とき &lt;code&gt;ORDER BY&lt;/code&gt; が省略されているデフォルトのフレームは、パーティション内のすべての行で構成されています。&lt;a href=&quot;#ftn.id-1.4.5.6.9.5&quot;&gt;&lt;sup id=&quot;id-1.4.5.6.9.5&quot;&gt;[4]これ&lt;/sup&gt;&lt;/a&gt;は &lt;code&gt;sum&lt;/code&gt; を使用した例です：</target>
        </trans-unit>
        <trans-unit id="64034dc768225bc4dcced9797dcc3830def63396" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER AGGREGATE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="f28370d7fe3178c0f150cc0dec3299397ce3c2af" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER COLLATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER COLLATION&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="7babd298f2e4c509f069c94f5602aeb995a6b57c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER CONVERSION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER CONVERSION&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="928fd572e35641041e67b18e6e748efce3723a8c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="991bfb585377a575377a77fe428cfaf85a73d860" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER EVENT TRIGGER&lt;/code&gt; ステートメントはありません。</target>
        </trans-unit>
        <trans-unit id="9d77ec038759f5fffa10b0b08001ebb09342372d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER GROUP&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="bb57388d9f735799eb7b9b89ff35e3d5ef151e31" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER LANGUAGE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="1637168216f474c65041857a21d81b0e4a440e97" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER LARGE OBJECT&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="345d872d60a75b2e0f9d89245157411db046f3d0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER OPERATOR CLASS&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="8fcc86f4b1945452fb4d2e3306232b8ba831ba49" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER OPERATOR FAMILY&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="cc28991fbce6444e2838b4c5b330fc7e8b89d499" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER OPERATOR&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="2506d4e215504a7cdfcb1194c2679242cc54a59e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER SCHEMA&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER SCHEMA&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="2964377f745afad2429ec74b207708196b68d312" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER STATISTICS&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="9c3931d89739bf4a90fd967b4f0a43fada449313" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER TABLESPACE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="e24f943c01b48797aaba76a9060c58b771452dd4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER TEXT SEARCH CONFIGURATION&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="eee71505e9ca52479c60dc800cccb5a32c56fe24" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="d50e75d0db9753a5bb17ed4059457e195c3fbe78" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">何もありません &lt;code&gt;ALTER TEXT SEARCH PARSER&lt;/code&gt; SQL標準でステートメントが。</target>
        </trans-unit>
        <trans-unit id="f2e5183222d4bb5c821f92f235643d98359507e9" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ALTER TEXT SEARCH TEMPLATE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="e08ef635bc500a8ffe34e71b4cb60735a3f59c83" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;ANALYZE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;ANALYZE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="2ab267186c8c406bf12491cd64160dcb07b24078" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CLUSTER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CLUSTER&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="b29db8edfc564e2f37aa124a9094dedfa5dc75ca" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COMMENT&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;COMMENT&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="51ffc421257a5e488b200464e2482e6c0cb494cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;COPY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;COPY&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="d1ea525f2af46d628097a5d99e04b04f3dea2225" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE DATABASE&lt;/code&gt; statement in the SQL standard. Databases are equivalent to catalogs, whose creation is implementation-defined.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE DATABASE&lt;/code&gt; 文はありません。データベースは、作成が実装定義であるカタログと同等です。</target>
        </trans-unit>
        <trans-unit id="1892a6f6e1f58d3b4418aa1f7caf04e29a8df179" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE EVENT TRIGGER&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="5bd71c5d0a01b45b44b80fcee88ed4660e223ea1" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL標準には &lt;code&gt;CREATE GROUP&lt;/code&gt; ステートメントはありません。</target>
        </trans-unit>
        <trans-unit id="e39953cfa3881edf0f677e0b9a6a85f9dce8605d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE STATISTICS&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="502eb254142165b2715d9eff63db5d89a608e2d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE TEXT SEARCH CONFIGURATION&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="609c741f2314d56bf655daef547dcb2a0644be82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE TEXT SEARCH DICTIONARY&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="41df83262dc2c3b270bf89a5b823f9c05295e631" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE TEXT SEARCH PARSER&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="ec4376bb5fb0542843f635e97909a4ca5d798c55" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;CREATE TEXT SEARCH TEMPLATE&lt;/code&gt; ステートメントはありません。</target>
        </trans-unit>
        <trans-unit id="adb922403a157a64a60a934905fa24aa07814119" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DO&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DO&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="453ae3f4ad66d52b89a14781b63b1f82ed5a0eba" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP AGGREGATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP AGGREGATE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="fec0e29fd940c929987502b958108c6376839288" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP CONVERSION&lt;/code&gt; statement in the SQL standard, but a &lt;code&gt;DROP TRANSLATION&lt;/code&gt; statement that goes along with the &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; statement that is similar to the &lt;code&gt;CREATE CONVERSION&lt;/code&gt; statement in PostgreSQL.</source>
          <target state="translated">SQL標準には &lt;code&gt;DROP CONVERSION&lt;/code&gt; ステートメントはありませんが、PostgreSQLの &lt;code&gt;CREATE CONVERSION&lt;/code&gt; ステートメントと同様の &lt;code&gt;CREATE TRANSLATION&lt;/code&gt; ステートメントと連動する &lt;code&gt;DROP TRANSLATION&lt;/code&gt; ステートメントがあります。</target>
        </trans-unit>
        <trans-unit id="fb09b1464adf925f06c0292814700fb9b8091f6c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP DATABASE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP DATABASE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="a3c4c010988712d96dd1e79f98080f9432271062" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL標準には &lt;code&gt;DROP EVENT TRIGGER&lt;/code&gt; ステートメントはありません。</target>
        </trans-unit>
        <trans-unit id="75623002e2b624abb982d948db215c1dd60a52cc" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP GROUP&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP GROUP&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="27a5387a3bec15b9e950f163994562d5efac89f3" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP LANGUAGE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP LANGUAGE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="e3d30fcc924219aba17a45fb588c01476a1e9ff6" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP OPERATOR CLASS&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="4a4d8ad142bdd21f8d4bd8875a49f33849bf5d39" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">SQL標準には &lt;code&gt;DROP OPERATOR FAMILY&lt;/code&gt; ステートメントはありません。</target>
        </trans-unit>
        <trans-unit id="20b4d42336169eb36dbc8e0af63669368391995e" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP OPERATOR&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP OPERATOR&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="22ab45de26ec7860503bcd3c1a242a1a6a072838" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP STATISTICS&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL標準には &lt;code&gt;DROP STATISTICS&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="33a3a716e771311567ab1607e35bf61106da647f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP TEXT SEARCH CONFIGURATION&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="3ff33e4bc1ee2eee7f638d4f9ffce00160a3d8ec" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP TEXT SEARCH DICTIONARY&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="22f0a322ac87aa6f316366f64468b6a33b449141" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP TEXT SEARCH PARSER&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="caba21772330bd3e8d6bc5c0114bed4813577256" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;DROP TEXT SEARCH TEMPLATE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="4c6a0d8e969d6d60c24413dee9ec35d4707051d7" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;EXPLAIN&lt;/code&gt; statement defined in the SQL standard.</source>
          <target state="translated">標準SQLでは &lt;code&gt;EXPLAIN&lt;/code&gt; 文は定義されていません。</target>
        </trans-unit>
        <trans-unit id="3188600a38497d7445251ce699c39dbe875e80ee" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LISTEN&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;LISTEN&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="89782cda07082f5c8f4d6514f108dab71bcfa4d2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;LOCK TABLE&lt;/code&gt; in the SQL standard, which instead uses &lt;code&gt;SET TRANSACTION&lt;/code&gt; to specify concurrency levels on transactions. PostgreSQL supports that too; see &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for details.</source>
          <target state="translated">SQL標準には &lt;code&gt;LOCK TABLE&lt;/code&gt; はありません。代わりに &lt;code&gt;SET TRANSACTION&lt;/code&gt; を使用してトランザクションの同時実行レベルを指定します。PostgreSQLもそれをサポートしています。詳細については、&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8f784f25d51430ade6f35b2e081075babec2e0fe" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;MOVE&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;MOVE&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="4a168bea72d9806503f40f80aa12982ca9fd8601" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;NOTIFY&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;NOTIFY&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="6e1257ab0b3946084dffdd621f7db244f79c25f5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;REINDEX&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;REINDEX&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="e9129bb3a754d8cf06ba21c59dfcd6069ee5971c" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;SECURITY LABEL&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">SQL標準には &lt;code&gt;SECURITY LABEL&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="c2c399b535d16a105f07135d4035417088b1dcc4" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;UNLISTEN&lt;/code&gt; command in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;UNLISTEN&lt;/code&gt; コマンドはありません。</target>
        </trans-unit>
        <trans-unit id="6a373be7f6f352e566798cf5a1903b201f8406b2" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;VACUUM&lt;/code&gt; statement in the SQL standard.</source>
          <target state="translated">標準SQLには &lt;code&gt;VACUUM&lt;/code&gt; 文はありません。</target>
        </trans-unit>
        <trans-unit id="eaadde692acdf895866b856cf669a3d745361c1a" translate="yes" xml:space="preserve">
          <source>There is no alignment padding or any other extra data between fields.</source>
          <target state="translated">フィールド間には整列パディングやその他の余分なデータはありません。</target>
        </trans-unit>
        <trans-unit id="9d9b8c9e107ad42ee0fad08dd8f24c67ee8d865a" translate="yes" xml:space="preserve">
          <source>There is no automatic way to verify that all of the &lt;code&gt;CHECK&lt;/code&gt; constraints are mutually exclusive. It is safer to create code that generates child tables and creates and/or modifies associated objects than to write each by hand.</source>
          <target state="translated">すべての &lt;code&gt;CHECK&lt;/code&gt; 制約が相互に排他的であることを確認する自動方法はありません。子テーブルを生成し、関連するオブジェクトを作成または変更するコードを作成する方が、それぞれを手動で作成するよりも安全です。</target>
        </trans-unit>
        <trans-unit id="6a9b18acfad0da6c23024f7c2509d5457d17977e" translate="yes" xml:space="preserve">
          <source>There is no comparably easy way to determine a next OID that's beyond the largest one in the database, but fortunately it is not critical to get the next-OID setting right.</source>
          <target state="translated">データベース内の最大のものを超えた次のOIDを決定するための比較的簡単な方法はありませんが、幸いにも次のOIDの設定を正しく行うことは重要ではありません。</target>
        </trans-unit>
        <trans-unit id="4db36b67fac0c975746b2d641f8b3943a36d8046" translate="yes" xml:space="preserve">
          <source>There is no cross-checking of indexes against their heap relation during normal operation. Symptoms of heap corruption can be subtle.</source>
          <target state="translated">通常の操作では、インデックスとそのヒープ関係とのクロスチェックは行われません。ヒープの破損の症状は微妙です。</target>
        </trans-unit>
        <trans-unit id="e96dd49b9a313a343547338d49ed17c06a38c1a6" translate="yes" xml:space="preserve">
          <source>There is no dependent object; this type of entry is a signal that the system itself depends on the referenced object, and so that object must never be deleted. Entries of this type are created only by &lt;code&gt;initdb&lt;/code&gt;. The columns for the dependent object contain zeroes.</source>
          <target state="translated">依存オブジェクトはありません。このタイプのエントリは、システム自体が参照されるオブジェクトに依存しているため、オブジェクトを削除してはならないというシグナルです。このタイプのエントリは、 &lt;code&gt;initdb&lt;/code&gt; によってのみ作成されます。依存オブジェクトの列にはゼロが含まれます。</target>
        </trans-unit>
        <trans-unit id="70fc6506fe197311ab91bc28b3e88218eb7eab49" translate="yes" xml:space="preserve">
          <source>There is no general method of repairing problems that &lt;code&gt;amcheck&lt;/code&gt; detects. An explanation for the root cause of an invariant violation should be sought. &lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt; may play a useful role in diagnosing corruption that &lt;code&gt;amcheck&lt;/code&gt; detects. A &lt;code&gt;REINDEX&lt;/code&gt; may not be effective in repairing corruption.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; が検出する問題を修復する一般的な方法はありません。不変の違反の根本原因についての説明を求める必要があります。&lt;a href=&quot;pageinspect&quot;&gt;pageinspect&lt;/a&gt;は、 &lt;code&gt;amcheck&lt;/code&gt; が検出する破損の診断に役立つことがあります。A &lt;code&gt;REINDEX&lt;/code&gt; は、破損を修復するのに有効ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="f84235bff819237a1da91e8e95c005f22d0298e2" translate="yes" xml:space="preserve">
          <source>There is no length limit on the input strings.</source>
          <target state="translated">入力文字列の長さに制限はありません。</target>
        </trans-unit>
        <trans-unit id="4dbeb068f00ac522f4db315c80e9ac31689bfd87" translate="yes" xml:space="preserve">
          <source>There is no linguistic support, even for English. Regular expressions are not sufficient because they cannot easily handle derived words, e.g., &lt;code&gt;satisfies&lt;/code&gt; and &lt;code&gt;satisfy&lt;/code&gt;. You might miss documents that contain &lt;code&gt;satisfies&lt;/code&gt;, although you probably would like to find them when searching for &lt;code&gt;satisfy&lt;/code&gt;. It is possible to use &lt;code&gt;OR&lt;/code&gt; to search for multiple derived forms, but this is tedious and error-prone (some words can have several thousand derivatives).</source>
          <target state="translated">英語であっても、言語的なサポートはありません。彼らは容易に導く言葉、例えば、処理できないので、正規表現は十分ではありません &lt;code&gt;satisfies&lt;/code&gt; と &lt;code&gt;satisfy&lt;/code&gt; 。あなたは、含まれているドキュメント見逃す可能性が &lt;code&gt;satisfies&lt;/code&gt; あなたはおそらくを検索するときにそれらを見つけるしたいと思いますけれども、 &lt;code&gt;satisfy&lt;/code&gt; 。 &lt;code&gt;OR&lt;/code&gt; を使用して複数の派生フォームを検索することは可能ですが、これは面倒でエラーが発生しやすくなります（一部の単語は数千の派生物を持つ可能性があります）。</target>
        </trans-unit>
        <trans-unit id="56e118a7d0adfb0e635c9d07f655d84a8ad88c12" translate="yes" xml:space="preserve">
          <source>There is no mechanism to enforce uniqueness of standby names. In case of duplicates one of the matching standbys will be considered as higher priority, though exactly which one is indeterminate.</source>
          <target state="translated">スタンバイ名の一意性を強制するメカニズムはありません。重複している場合は、一致するスタンバイのうちの1つが優先度の高いものとみなされますが、正確にはどちらが優先度の高いものかは不確定です。</target>
        </trans-unit>
        <trans-unit id="ee6e31417005e5059c60745bca02997125074c26" translate="yes" xml:space="preserve">
          <source>There is no need to grant privileges to the owner of an object (usually the user that created it), as the owner has all privileges by default. (The owner could, however, choose to revoke some of their own privileges for safety.)</source>
          <target state="translated">所有者はデフォルトですべての権限を持っているので、オブジェクトの所有者 (通常はそれを作成したユーザ)に権限を与える必要はありません。(しかし、所有者は安全のために自分の権限の一部を取り消すことを選択することができます)。</target>
        </trans-unit>
        <trans-unit id="30ae1505daac493ace3132ae554c6ea20c2ba190" translate="yes" xml:space="preserve">
          <source>There is no performance difference among these three types, apart from increased storage space when using the blank-padded type, and a few extra CPU cycles to check the length when storing into a length-constrained column. While &lt;code&gt;character(n)&lt;/code&gt; has performance advantages in some other database systems, there is no such advantage in PostgreSQL; in fact &lt;code&gt;character(n)&lt;/code&gt; is usually the slowest of the three because of its additional storage costs. In most situations &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;character varying&lt;/code&gt; should be used instead.</source>
          <target state="translated">空白で埋められたタイプを使用した場合のストレージスペースの増加、および長さ制約のある列に格納するときに長さをチェックするためのいくつかの追加のCPUサイクルを除いて、これら3つのタイプの間にパフォーマンスの違いはありません。しながら、 &lt;code&gt;character(n)&lt;/code&gt; いくつかの他のデータベースシステムのパフォーマンス上の利点を有し、PostgreSQLのそのような利点がありません。実際、追加のストレージコストのため、 &lt;code&gt;character(n)&lt;/code&gt; は通常3つの中で最も遅いです。ほとんどの場合、代わりに &lt;code&gt;text&lt;/code&gt; または &lt;code&gt;character varying&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8afc4737cc902a7afc20e4910e033de6ddabdb93" translate="yes" xml:space="preserve">
          <source>There is no restriction regarding how many database users a given operating system user can correspond to, nor vice versa. Thus, entries in a map should be thought of as meaning &amp;ldquo;this operating system user is allowed to connect as this database user&amp;rdquo;, rather than implying that they are equivalent. The connection will be allowed if there is any map entry that pairs the user name obtained from the external authentication system with the database user name that the user has requested to connect as.</source>
          <target state="translated">特定のオペレーティングシステムユーザーが対応できるデータベースユーザーの数、またはその逆に関する制限はありません。したがって、マップ内のエントリは、同等であることを意味するのではなく、「このオペレーティングシステムユーザーがこのデータベースユーザーとして接続することを許可されている」という意味であると考える必要があります。外部認証システムから取得したユーザー名と、ユーザーが接続を要求したデータベースユーザー名をペアにしたマップエントリがある場合、接続は許可されます。</target>
        </trans-unit>
        <trans-unit id="c6d6a72d9fa9097f88cd465d659b996359e6595c" translate="yes" xml:space="preserve">
          <source>There is no result row for the city of Hayward. This is because there is no matching entry in the &lt;code&gt;cities&lt;/code&gt; table for Hayward, so the join ignores the unmatched rows in the &lt;code&gt;weather&lt;/code&gt; table. We will see shortly how this can be fixed.</source>
          <target state="translated">ヘイワード市の結果行はありません。これは、Hayward の &lt;code&gt;cities&lt;/code&gt; テーブルに一致するエントリがないため、ジョインは &lt;code&gt;weather&lt;/code&gt; テーブルの一致しない行を無視するためです。これがどのように修正されるかは、まもなくわかります。</target>
        </trans-unit>
        <trans-unit id="fb859432422d8124605fd6fa0a5ba7fbb347c338" translate="yes" xml:space="preserve">
          <source>There is no way to create an exclusion constraint spanning all partitions; it is only possible to constrain each leaf partition individually.</source>
          <target state="translated">すべてのパーティションにまたがる除外制約を作成する方法はありません。</target>
        </trans-unit>
        <trans-unit id="1b5bd62ec3737bfec14cadfb61679b8166c57b55" translate="yes" xml:space="preserve">
          <source>There is one row for each buffer in the shared cache. Unused buffers are shown with all fields null except &lt;code&gt;bufferid&lt;/code&gt;. Shared system catalogs are shown as belonging to database zero.</source>
          <target state="translated">共有キャッシュのバッファごとに1つの行があります。未使用のバッファは、 &lt;code&gt;bufferid&lt;/code&gt; を除くすべてのフィールドがnullで表示されます。共有システムカタログは、データベース0に属するものとして表示されます。</target>
        </trans-unit>
        <trans-unit id="f45963e6e5833c88c83b3b4b867ec971de5358c8" translate="yes" xml:space="preserve">
          <source>There is only one &lt;code&gt;round&lt;/code&gt; function that takes two arguments; it takes a first argument of type &lt;code&gt;numeric&lt;/code&gt; and a second argument of type &lt;code&gt;integer&lt;/code&gt;. So the following query automatically converts the first argument of type &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;numeric&lt;/code&gt;:</source>
          <target state="translated">2つの引数を取る &lt;code&gt;round&lt;/code&gt; 関数は1つだけです。これは、 &lt;code&gt;numeric&lt;/code&gt; タイプの最初の引数と &lt;code&gt;integer&lt;/code&gt; タイプの2番目の引数を取ります。したがって、次のクエリは、 &lt;code&gt;integer&lt;/code&gt; 型の最初の引数を自動的に &lt;code&gt;numeric&lt;/code&gt; 変換します。</target>
        </trans-unit>
        <trans-unit id="b9159e4fda642d08346e94fb2d3ac2dbc99a478a" translate="yes" xml:space="preserve">
          <source>There is only one factorial operator (postfix &lt;code&gt;!&lt;/code&gt;) defined in the standard catalog, and it takes an argument of type &lt;code&gt;bigint&lt;/code&gt;. The scanner assigns an initial type of &lt;code&gt;integer&lt;/code&gt; to the argument in this query expression:</source>
          <target state="translated">標準カタログには階乗演算子（後置 &lt;code&gt;!&lt;/code&gt; ）が1つだけ定義されており、 &lt;code&gt;bigint&lt;/code&gt; 型の引数を取ります。スキャナーは、次のクエリ式の引数に初期タイプの &lt;code&gt;integer&lt;/code&gt; を割り当てます。</target>
        </trans-unit>
        <trans-unit id="ca0c7153374d6f701aba32a67304ea000734d416" translate="yes" xml:space="preserve">
          <source>There is presently no security mechanism for viewing comments: any user connected to a database can see all the comments for objects in that database. For shared objects such as databases, roles, and tablespaces, comments are stored globally so any user connected to any database in the cluster can see all the comments for shared objects. Therefore, don't put security-critical information in comments.</source>
          <target state="translated">現在のところ、コメントを表示するためのセキュリティ機構はありません。データベースに接続しているユーザは誰でも、そのデータベース内のオブジェクトに対するすべてのコメントを見ることができます。データベース、ロール、テーブルスペースなどの共有オブジェクトの場合、コメントはグローバルに保存されるので、クラスタ内のどのデータベースに接続しているユーザも共有オブジェクトのすべてのコメントを見ることができます。したがって、コメントにはセキュリティ上重要な情報を入れないようにしてください。</target>
        </trans-unit>
        <trans-unit id="e848fe2ab9f9a42478fab56269c47dd1ce42078d" translate="yes" xml:space="preserve">
          <source>There is usually not much point in making more than one tablespace per logical file system, since you cannot control the location of individual files within a logical file system. However, PostgreSQL does not enforce any such limitation, and indeed it is not directly aware of the file system boundaries on your system. It just stores files in the directories you tell it to use.</source>
          <target state="translated">論理ファイルシステム内の個々のファイルの位置を制御することはできないので、論理ファイルシステムごとに複数のテーブルスペースを作成することには通常あまり意味がありません。なぜなら、論理ファイルシステム内の個々のファイルの位置を制御することができないからです。しかし、PostgreSQLはそのような制限を強制しませんし、実際にはシステム上のファイルシステムの境界を直接認識しません。PostgreSQLは、あなたが使用するように指示したディレクトリにファイルを格納するだけです。</target>
        </trans-unit>
        <trans-unit id="d953cfaaf0252b15b02b8c9a112ebe99c8fa7d20" translate="yes" xml:space="preserve">
          <source>There must also be matching child-table constraints for all &lt;code&gt;CHECK&lt;/code&gt; constraints of the parent, except those marked non-inheritable (that is, created with &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt;) in the parent, which are ignored; all child-table constraints matched must not be marked non-inheritable. Currently &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, and &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered, but this might change in the future.</source>
          <target state="translated">また、親で継承不可とマークされた（つまり、 &lt;code&gt;ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT&lt;/code&gt; で作成された）マークが付けられた無視されるものを除いて、親のすべての &lt;code&gt;CHECK&lt;/code&gt; 制約に対して一致する子テーブル制約がなければなりません。一致するすべての子テーブル制約は、非継承可能としてマークしてはなりません。現在、 &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、および &lt;code&gt;FOREIGN KEY&lt;/code&gt; 制約は考慮されていませんが、これは将来変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9d0ef1c54ee5da6f3a9bc0faf2941d2e26078541" translate="yes" xml:space="preserve">
          <source>There should be no extra overhead in the parser or executor if a query does not need implicit type conversion. That is, if a query is well-formed and the types already match, then the query should execute without spending extra time in the parser and without introducing unnecessary implicit conversion calls in the query.</source>
          <target state="translated">クエリが暗黙の型変換を必要としない場合、パーサやエグゼキュータには余分なオーバーヘッドがあってはなりません。つまり、クエリが十分に整形されており、型が既にマッチしている場合、パーサで余分な時間を費やすことなく、クエリ内で不必要な暗黙の変換呼び出しを導入することなく、クエリが実行されるべきです。</target>
        </trans-unit>
        <trans-unit id="934618c1781f2f0a9f6bb79bbcc267c826504412" translate="yes" xml:space="preserve">
          <source>There was formerly an &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; variant, but this is now ignored (with a warning). An index cannot have an owner different from its table's owner. Changing the table's owner automatically changes the index as well.</source>
          <target state="translated">以前は &lt;code&gt;ALTER INDEX OWNER&lt;/code&gt; バリアントがありましたが、これは無視されます（警告付き）。インデックスは、そのテーブルの所有者と異なる所有者を持つことはできません。テーブルの所有者を変更すると、インデックスも自動的に変更されます。</target>
        </trans-unit>
        <trans-unit id="eb82410dec70b2b3321bff0d1e9388c3bd8dfd33" translate="yes" xml:space="preserve">
          <source>There's no need to manually create indexes on unique columns; doing so would just duplicate the automatically-created index.</source>
          <target state="translated">ユニークなカラムに手動でインデックスを作成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="dd1c3102c4930b5f2a44ebfcda5a098872c67837" translate="yes" xml:space="preserve">
          <source>Thesauruses are used during indexing so any change in the thesaurus dictionary's parameters &lt;em&gt;requires&lt;/em&gt; reindexing. For most other dictionary types, small changes such as adding or removing stopwords does not force reindexing.</source>
          <target state="translated">シソーラスはインデックス作成中に使用されるため、シソーラス辞書のパラメーターを変更すると、インデックスの再作成&lt;em&gt;が必要になり&lt;/em&gt;ます。他のほとんどのタイプの辞書では、ストップワードの追加や削除などの小さな変更は、インデックスの再作成を強制しません。</target>
        </trans-unit>
        <trans-unit id="5f1ad8c9ce64bcda09c594082de2a500ef5cce09" translate="yes" xml:space="preserve">
          <source>These are actually just special cases of the general casting notations discussed next.</source>
          <target state="translated">これらは実際には、次に説明する一般的な鋳造記法の特別なケースに過ぎません。</target>
        </trans-unit>
        <trans-unit id="1ede3bb37d9693ab9536c9fcd48ebe3c46555fd8" translate="yes" xml:space="preserve">
          <source>These are good sources to start learning about various kinds of encoding systems.</source>
          <target state="translated">これらは、様々な種類のエンコーディングシステムについての学習を始めるのに良い情報源です。</target>
        </trans-unit>
        <trans-unit id="8a4a0666760118b211b5b7d0b41910720c832114" translate="yes" xml:space="preserve">
          <source>These are less likely to be problematic than &lt;code&gt;search_path&lt;/code&gt;, but can be handled with function &lt;code&gt;SET&lt;/code&gt; options if the need arises.</source>
          <target state="translated">これらは &lt;code&gt;search_path&lt;/code&gt; よりも問題になる可能性は低いですが、必要に応じて関数 &lt;code&gt;SET&lt;/code&gt; オプションで処理できます。</target>
        </trans-unit>
        <trans-unit id="e09b98f630a14c95107bbc1d571768385072e6a7" translate="yes" xml:space="preserve">
          <source>These are some examples of valid numeric constants:</source>
          <target state="translated">これらは有効な数値定数の例です。</target>
        </trans-unit>
        <trans-unit id="2d394fc649569a5eeeb4c5600c0f12014850ba1f" translate="yes" xml:space="preserve">
          <source>These are the steps to perform an upgrade with pg_upgrade:</source>
          <target state="translated">以下はpg_upgradeでアップグレードを実行するための手順です。</target>
        </trans-unit>
        <trans-unit id="f72a6870691351c5c2b87041a8d81f8e78b27456" translate="yes" xml:space="preserve">
          <source>These attributes inform the query optimizer about the behavior of the function. At most one choice can be specified. If none of these appear, &lt;code&gt;VOLATILE&lt;/code&gt; is the default assumption.</source>
          <target state="translated">これらの属性は、関数の動作についてクエリオプティマイザーに通知します。最大で1つの選択肢を指定できます。これらのいずれも表示されない場合、 &lt;code&gt;VOLATILE&lt;/code&gt; がデフォルトの仮定です。</target>
        </trans-unit>
        <trans-unit id="f85846f94f84f78007c888a90fb32598de3ea04f" translate="yes" xml:space="preserve">
          <source>These caches can typically be disabled; however, the method for doing this varies by operating system and drive type:</source>
          <target state="translated">これらのキャッシュは通常は無効にすることができますが、これを行う方法はオペレーティングシステムとドライブの種類によって異なります。</target>
        </trans-unit>
        <trans-unit id="484e4f03dd4a3ca589988330c2b61dd6c51084dd" translate="yes" xml:space="preserve">
          <source>These clauses alter attributes originally set by &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;. For more information, see the &lt;code&gt;CREATE ROLE&lt;/code&gt; reference page.</source>
          <target state="translated">これらの句は、&lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt;によって最初に設定された属性を変更します。詳細については、 &lt;code&gt;CREATE ROLE&lt;/code&gt; のリファレンスページを参照してください。</target>
        </trans-unit>
        <trans-unit id="ae13d4d630a34fa139e9046de2cb8f6bc13b3a42" translate="yes" xml:space="preserve">
          <source>These clauses define a role's ability to create databases. If &lt;code&gt;CREATEDB&lt;/code&gt; is specified, the role being defined will be allowed to create new databases. Specifying &lt;code&gt;NOCREATEDB&lt;/code&gt; will deny a role the ability to create databases. If not specified, &lt;code&gt;NOCREATEDB&lt;/code&gt; is the default.</source>
          <target state="translated">これらの句は、データベースを作成するロールの機能を定義します。 &lt;code&gt;CREATEDB&lt;/code&gt; が指定されている場合、定義されているロールは新しいデータベースの作成を許可されます。 &lt;code&gt;NOCREATEDB&lt;/code&gt; を指定すると、ロールがデータベースを作成する機能を拒否します。指定しない場合、 &lt;code&gt;NOCREATEDB&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="236a4db02b1fa5b8bc065150c9e1f92cd0c2db65" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role &amp;ldquo;inherits&amp;rdquo; the privileges of roles it is a member of. A role with the &lt;code&gt;INHERIT&lt;/code&gt; attribute can automatically use whatever database privileges have been granted to all roles it is directly or indirectly a member of. Without &lt;code&gt;INHERIT&lt;/code&gt;, membership in another role only grants the ability to &lt;code&gt;SET ROLE&lt;/code&gt; to that other role; the privileges of the other role are only available after having done so. If not specified, &lt;code&gt;INHERIT&lt;/code&gt; is the default.</source>
          <target state="translated">これらの句は、役割が所属する役割の特権を「継承」するかどうかを決定します。役割 &lt;code&gt;INHERIT&lt;/code&gt; の属性が自動的にそれが直接的または間接的のメンバーであるすべてのロールに付与されているものは何でもデータベースの権限を使用することができます。 &lt;code&gt;INHERIT&lt;/code&gt; がない場合、別の役割のメンバーシップは、その別の役割に &lt;code&gt;SET ROLE&lt;/code&gt; を設定する機能のみを付与します。他のロールの権限は、そうした後にのみ使用できます。指定しない場合、 &lt;code&gt;INHERIT&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="a8f7e3712b4368e28fc6b45f7eab106b1e33840d" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role bypasses every row-level security (RLS) policy. &lt;code&gt;NOBYPASSRLS&lt;/code&gt; is the default. Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. The superuser and owner of the table being dumped always bypass RLS.</source>
          <target state="translated">これらの句は、ロールがすべての行レベルのセキュリティ（RLS）ポリシーをバイパスするかどうかを決定します。 &lt;code&gt;NOBYPASSRLS&lt;/code&gt; がデフォルトです。 pg_dumpはデフォルトで &lt;code&gt;row_security&lt;/code&gt; を &lt;code&gt;OFF&lt;/code&gt; に設定し、テーブルのすべてのコンテンツが確実にダンプされることに注意してください。 pg_dumpを実行しているユーザーに適切な権限がない場合、エラーが返されます。ダンプされるテーブルのスーパーユーザーと所有者は、常にRLSをバイパスします。</target>
        </trans-unit>
        <trans-unit id="cdfb1f660e91b5c6f6fdf7bb5b01ee2031a6647b" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is a replication role. A role must have this attribute (or be a superuser) in order to be able to connect to the server in replication mode (physical or logical replication) and in order to be able to create or drop replication slots. A role having the &lt;code&gt;REPLICATION&lt;/code&gt; attribute is a very highly privileged role, and should only be used on roles actually used for replication. If not specified, &lt;code&gt;NOREPLICATION&lt;/code&gt; is the default.</source>
          <target state="translated">これらの句は、ロールがレプリケーションロールであるかどうかを決定します。レプリケーションモード（物理レプリケーションまたは論理レプリケーション）でサーバーに接続できるようにしたり、レプリケーションスロットを作成または削除したりできるようにするには、ロールにこの属性（またはスーパーユーザー）が必要です。 &lt;code&gt;REPLICATION&lt;/code&gt; 属性を持つロールは非常に高い特権を持つロールであり、実際にレプリケーションに使用されるロールでのみ使用する必要があります。指定しない場合、 &lt;code&gt;NOREPLICATION&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="93cac2364d542f963f918606f10bb473c25cf54c" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role is allowed to log in; that is, whether the role can be given as the initial session authorization name during client connection. A role having the &lt;code&gt;LOGIN&lt;/code&gt; attribute can be thought of as a user. Roles without this attribute are useful for managing database privileges, but are not users in the usual sense of the word. If not specified, &lt;code&gt;NOLOGIN&lt;/code&gt; is the default, except when &lt;code&gt;CREATE ROLE&lt;/code&gt; is invoked through its alternative spelling &lt;a href=&quot;sql-createuser&quot;&gt;CREATE USER&lt;/a&gt;.</source>
          <target state="translated">これらの句は、ロールにログインを許可するかどうかを決定します。つまり、クライアント接続中にロールを初期セッション許可名として指定できるかどうか。 &lt;code&gt;LOGIN&lt;/code&gt; 属性を持つロールは、ユーザーと考えることができます。この属性のないロールは、データベース特権の管理には役立ちますが、通常の意味でのユーザーではありません。指定されていない場合、代替スペルの&lt;a href=&quot;sql-createuser&quot;&gt;CREATE USERを&lt;/a&gt;介して &lt;code&gt;CREATE ROLE&lt;/code&gt; が呼び出された場合を除き、 &lt;code&gt;NOLOGIN&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="181b83412fd4eddb3ac3029828e16b7a9b6b98ef" translate="yes" xml:space="preserve">
          <source>These clauses determine whether a role will be permitted to create new roles (that is, execute &lt;code&gt;CREATE ROLE&lt;/code&gt;). A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can also alter and drop other roles. If not specified, &lt;code&gt;NOCREATEROLE&lt;/code&gt; is the default.</source>
          <target state="translated">これらの句は、ロールが新しいロールの作成（つまり、 &lt;code&gt;CREATE ROLE&lt;/code&gt; の実行）を許可されるかどうかを決定します。 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、他のロールを変更および削除することもできます。指定しない場合、 &lt;code&gt;NOCREATEROLE&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="2e0e211b5e3eb630f6887dce4107cdd808855949" translate="yes" xml:space="preserve">
          <source>These clauses determine whether the new role is a &amp;ldquo;superuser&amp;rdquo;, who can override all access restrictions within the database. Superuser status is dangerous and should be used only when really needed. You must yourself be a superuser to create a new superuser. If not specified, &lt;code&gt;NOSUPERUSER&lt;/code&gt; is the default.</source>
          <target state="translated">これらの句は、新しいロールがデータベース内のすべてのアクセス制限を上書きできる「スーパーユーザー」であるかどうかを決定します。スーパーユーザーのステータスは危険であり、本当に必要な場合にのみ使用してください。新しいスーパーユーザーを作成するには、自分がスーパーユーザーである必要があります。指定しない場合、 &lt;code&gt;NOSUPERUSER&lt;/code&gt; がデフォルトです。</target>
        </trans-unit>
        <trans-unit id="b6a59cdbb5e799d0fed1a4aa2596214d1849fd5f" translate="yes" xml:space="preserve">
          <source>These clauses specify a foreign key constraint, which requires that a group of one or more columns of the new table must only contain values that match values in the referenced column(s) of some row of the referenced table. If the &lt;code&gt;refcolumn&lt;/code&gt; list is omitted, the primary key of the &lt;code&gt;reftable&lt;/code&gt; is used. The referenced columns must be the columns of a non-deferrable unique or primary key constraint in the referenced table. The user must have &lt;code&gt;REFERENCES&lt;/code&gt; permission on the referenced table (either the whole table, or the specific referenced columns). The addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table. Note that foreign key constraints cannot be defined between temporary tables and permanent tables.</source>
          <target state="translated">これらの句は外部キー制約を指定します。これには、新しいテーブルの1つ以上の列のグループに、参照されるテーブルの一部の行の参照される列の値と一致する値のみが含まれている必要があります。場合 &lt;code&gt;refcolumn&lt;/code&gt; のリストが省略され、の主キー &lt;code&gt;reftable&lt;/code&gt; が使用されています。参照される列は、参照されるテーブルの遅延不可の一意または主キー制約の列である必要があります。ユーザーには、参照されるテーブル（テーブル全体または特定の参照される列）に対する &lt;code&gt;REFERENCES&lt;/code&gt; 権限が必要です。外部キー制約を追加するには、 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; が必要です参照されるテーブルをロックします。外部キー制約は、一時テーブルと永続テーブルの間で定義できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="857c0ae8d220b45b3955f09362ef789a9a3402e5" translate="yes" xml:space="preserve">
          <source>These commands are defined in the SQL standard, except for the &lt;code&gt;DEFERRABLE&lt;/code&gt; transaction mode and the &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; form, which are PostgreSQL extensions.</source>
          <target state="translated">これらのコマンドは、PostgreSQLの拡張機能である &lt;code&gt;DEFERRABLE&lt;/code&gt; トランザクションモードと &lt;code&gt;SET TRANSACTION SNAPSHOT&lt;/code&gt; 形式を除いて、SQL標準で定義されています。</target>
        </trans-unit>
        <trans-unit id="c9a3af7e0da0acbd34de05752f110be6e0e62942" translate="yes" xml:space="preserve">
          <source>These configuration parameters provide a crude method of influencing the query plans chosen by the query optimizer. If the default plan chosen by the optimizer for a particular query is not optimal, a &lt;em&gt;temporary&lt;/em&gt; solution is to use one of these configuration parameters to force the optimizer to choose a different plan. Better ways to improve the quality of the plans chosen by the optimizer include adjusting the planner cost constants (see &lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;Section 19.7.2&lt;/a&gt;), running &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; manually, increasing the value of the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter, and increasing the amount of statistics collected for specific columns using &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;.</source>
          <target state="translated">これらの構成パラメーターは、クエリオプティマイザーによって選択されるクエリプランに影響を与える大まかな方法​​を提供します。特定のクエリに対してオプティマイザが選択したデフォルトのプランが最適でない場合、&lt;em&gt;一時的な&lt;/em&gt;解決策は、これらの構成パラメータの1つを使用して、オプティマイザに別のプランを選択させることです。オプティマイザによって選択された計画の品質を改善するより良い方法には、プランナのコスト定数の調整（&lt;a href=&quot;runtime-config-query#RUNTIME-CONFIG-QUERY-CONSTANTS&quot;&gt;セクション19.7.2を&lt;/a&gt;参照）、&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEの&lt;/a&gt;手動実行、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;構成パラメータの値の増加、および特定の列について収集される統計量の増加が含まれます &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="97b05ff9bc8f45601af490580b1cf57f630e4008" translate="yes" xml:space="preserve">
          <source>These cost-based decisions will be made at plan time, not execution time. This means that when prepared statements are in use, and a generic plan is used (see &lt;a href=&quot;sql-prepare&quot;&gt;PREPARE&lt;/a&gt;), the values of the configuration parameters in effect at prepare time control the decisions, not the settings at execution time.</source>
          <target state="translated">これらのコストベースの決定は、実行時間ではなく計画時に行われます。つまり、準備済みステートメントが使用されていて、汎用プランが使用されている場合（&lt;a href=&quot;sql-prepare&quot;&gt;PREPAREを&lt;/a&gt;参照）、準備時に有効な構成パラメーターの値が、実行時の設定ではなく決定を制御します。</target>
        </trans-unit>
        <trans-unit id="bd102e49cf8b96793cacdde24d32614ffb078540" translate="yes" xml:space="preserve">
          <source>These counts can be particularly valuable for filter conditions applied at join nodes. The &amp;ldquo;Rows Removed&amp;rdquo; line only appears when at least one scanned row, or potential join pair in the case of a join node, is rejected by the filter condition.</source>
          <target state="translated">これらの数は、結合ノードで適用されるフィルター条件に特に役立ちます。「削除された行」行は、少なくとも1つのスキャンされた行、または結合ノードの場合は潜在的な結合ペアがフィルター条件によって拒否された場合にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="d2ee06a454af3afd2603bd1ff07db9463f13f34e" translate="yes" xml:space="preserve">
          <source>These examples show use of &lt;code&gt;position&lt;/code&gt; fields:</source>
          <target state="translated">これらの例は、 &lt;code&gt;position&lt;/code&gt; フィールドの使用を示しています。</target>
        </trans-unit>
        <trans-unit id="e22989ebfc8062e1b7b80c3eb7a3f32777c7de5c" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown.</source>
          <target state="translated">これらの例はすべて同じアドレスを指定します。大文字と小文字、数字のために受け入れられている貫通 &lt;code&gt;f&lt;/code&gt; 。出力は常に、表示されている最初の形式になります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef90197c0c87bcadf3fd64cda40bcfb6928639b3" translate="yes" xml:space="preserve">
          <source>These examples would all specify the same address. Upper and lower case is accepted for the digits &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Output is always in the first of the forms shown. The last six input formats that are mentioned above are not part of any standard. To convert a traditional 48 bit MAC address in EUI-48 format to modified EUI-64 format to be included as the host portion of an IPv6 address, use &lt;code&gt;macaddr8_set7bit&lt;/code&gt; as shown:</source>
          <target state="translated">これらの例はすべて同じアドレスを指定します。大文字と小文字、数字のために受け入れられている貫通 &lt;code&gt;f&lt;/code&gt; 。出力は常に、表示されている最初の形式になります。上記の最後の6つの入力形式は、標準の一部ではありません。EUI-48形式の従来の48ビットMACアドレスをIPv6アドレスのホスト部分として含まれるように変更されたEUI-64形式に変換するには、次のように &lt;code&gt;macaddr8_set7bit&lt;/code&gt; を使用します。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="754aea8d14b67db99a02b25bbf6a65624166cf06" translate="yes" xml:space="preserve">
          <source>These fields only apply to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">これらのフィールドは、 &lt;code&gt;host&lt;/code&gt; 、 &lt;code&gt;hostssl&lt;/code&gt; 、および &lt;code&gt;hostnossl&lt;/code&gt; レコードにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="72eddf11f12dc6025be9e6bc42deb5078bd81869" translate="yes" xml:space="preserve">
          <source>These forms alter the sequence that underlies an existing identity column. &lt;code&gt;sequence_option&lt;/code&gt; is an option supported by &lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCE&lt;/a&gt; such as &lt;code&gt;INCREMENT BY&lt;/code&gt;.</source>
          <target state="translated">これらのフォームは、既存のID列の基礎となるシーケンスを変更します。 &lt;code&gt;sequence_option&lt;/code&gt; は、 &lt;code&gt;INCREMENT BY&lt;/code&gt; などの&lt;a href=&quot;sql-altersequence&quot;&gt;ALTER SEQUENCEで&lt;/a&gt;サポートされるオプションです。</target>
        </trans-unit>
        <trans-unit id="94eb82c63d8a50cb48f48fc67bdfcbfef03ff87e" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is an identity column or change the generation attribute of an existing identity column. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for details.</source>
          <target state="translated">これらのフォームは、列がID列であるかどうか、または既存のID列の生成属性を変更します。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e41d9a5a685b55548689fcb598e8403262b9b305" translate="yes" xml:space="preserve">
          <source>These forms change whether a column is marked to allow null values or to reject null values.</source>
          <target state="translated">これらのフォームは、列がNULL値を許可するようにマークされているか、NULL値を拒否するようにマークされているかを変更します。</target>
        </trans-unit>
        <trans-unit id="93ec998a277e66396552c3ff5dd5565fd0687627" translate="yes" xml:space="preserve">
          <source>These forms change whether a domain is marked to allow NULL values or to reject NULL values. You can only &lt;code&gt;SET NOT NULL&lt;/code&gt; when the columns using the domain contain no null values.</source>
          <target state="translated">これらのフォームは、ドメインがNULL値を許可するようにマークされているか、NULL値を拒否するようにマークされているかを変更します。ドメインを使用する列にnull値が含まれていない場合にのみ、 &lt;code&gt;SET NOT NULL&lt;/code&gt; を設定できます。</target>
        </trans-unit>
        <trans-unit id="e6fb1f760d0b7848e70cd0fa414aa5c5a55c2d88" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of event triggers. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. See also &lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;.</source>
          <target state="translated">これらのフォームは、イベントトリガーの発生を構成します。無効化されたトリガーはシステムに認識されていますが、そのトリガーイベントが発生しても実行されません。&lt;a href=&quot;runtime-config-client#GUC-SESSION-REPLICATION-ROLE&quot;&gt;session_replication_role&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ed16a2682c252a84ef2e6b9d1135068b069708b2" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of rewrite rules belonging to the table. A disabled rule is still known to the system, but is not applied during query rewriting. The semantics are as for disabled/enabled triggers. This configuration is ignored for &lt;code&gt;ON SELECT&lt;/code&gt; rules, which are always applied in order to keep views working even if the current session is in a non-default replication role.</source>
          <target state="translated">これらのフォームは、テーブルに属する書き換えルールの実行を構成します。無効にされたルールはシステムに認識されていますが、クエリの書き換え中には適用されません。セマンティクスは、無効化/有効化されたトリガーと同じです。この構成は &lt;code&gt;ON SELECT&lt;/code&gt; ルールでは無視されます。ONSELECTルールは、現在のセッションがデフォルト以外のレプリケーションロールである場合でも、ビューを引き続き機能させるために適用されます。</target>
        </trans-unit>
        <trans-unit id="78d1881ed192b61ccc8ca5381f7ecf2d5ccbebb4" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the foreign table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">これらのフォームは、外部テーブルに属するトリガーの起動を構成します。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;同様の形式を参照してください。</target>
        </trans-unit>
        <trans-unit id="537c2d5f6bf4afe4d0ece015a719f2c170c94088" translate="yes" xml:space="preserve">
          <source>These forms configure the firing of trigger(s) belonging to the table. A disabled trigger is still known to the system, but is not executed when its triggering event occurs. For a deferred trigger, the enable status is checked when the event occurs, not when the trigger function is actually executed. One can disable or enable a single trigger specified by name, or all triggers on the table, or only user triggers (this option excludes internally generated constraint triggers such as those that are used to implement foreign key constraints or deferrable uniqueness and exclusion constraints). Disabling or enabling internally generated constraint triggers requires superuser privileges; it should be done with caution since of course the integrity of the constraint cannot be guaranteed if the triggers are not executed.</source>
          <target state="translated">これらのフォームは、テーブルに属するトリガの実行を設定します。無効化されたトリガは、システムにはまだ知られていますが、そのトリガイベントが発生したときには実行されません。遅延トリガの場合、トリガ機能が実際に実行されるときではなく、イベントが発生したときに有効化ステータスがチェックされます。名前で指定された単一のトリガ、テーブル上のすべてのトリガ、またはユーザ・トリガのみを無効または有効にすることができます(このオプションは、外部キー制約や遅延可能な一意性および除外制約を実装するために使用されるような内部的に生成された制約トリガを除外します)。内部的に生成された制約トリガーを無効にしたり有効にしたりするには、スーパーユーザ権限が必要です。</target>
        </trans-unit>
        <trans-unit id="e52e37f61e3318ab7cf1d7a034b06767466f19cd" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table when the user is the table owner. If enabled, row level security policies will be applied when the user is the table owner. If disabled (the default) then row level security will not be applied when the user is the table owner. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">これらのフォームは、ユーザーがテーブル所有者である場合に、テーブルに属する行セキュリティポリシーの適用を制御します。有効にすると、ユーザーがテーブルの所有者である場合に行レベルのセキュリティポリシーが適用されます。無効（デフォルト）の場合、ユーザーがテーブルの所有者である場合、行レベルのセキュリティは適用されません。&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="f8b1a193cdfbb05ae9fcb8caf7ab280345bebc71" translate="yes" xml:space="preserve">
          <source>These forms control the application of row security policies belonging to the table. If enabled and no policies exist for the table, then a default-deny policy is applied. Note that policies can exist for a table even if row level security is disabled - in this case, the policies will NOT be applied and the policies will be ignored. See also &lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;.</source>
          <target state="translated">これらのフォームは、テーブルに属する行セキュリティポリシーの適用を制御します。有効になっていて、テーブルにポリシーが存在しない場合、デフォルトの拒否ポリシーが適用されます。行レベルのセキュリティが無効になっている場合でも、ポリシーはテーブルに存在できることに注意してください。この場合、ポリシーは適用されず、ポリシーは無視されます。&lt;a href=&quot;sql-createpolicy&quot;&gt;CREATE POLICY&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="a9ad545d11775ef6194d67bbd91b31263b043327" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. A view column's default value is substituted into any &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command whose target is the view, before applying any rules or triggers for the view. The view's default will therefore take precedence over any default values from underlying relations.</source>
          <target state="translated">これらのフォームは、列のデフォルト値を設定または削除します。ビューのルールまたはトリガーを適用する前に、ビューをターゲットとする &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; コマンドにビュー列のデフォルト値が代入されます。したがって、ビューのデフォルトは、基礎となるリレーションのデフォルト値よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="a2f96c4d1ee03fc069f57f93ee22ce31fb12871d" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a column. Default values only apply in subsequent &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands; they do not cause rows already in the table to change.</source>
          <target state="translated">これらのフォームは、列のデフォルト値を設定または削除します。デフォルト値は、後続の &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; コマンドでのみ適用されます。テーブル内の既存の行が変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="c9f74070b70e1b37c8a8a55a2765bed5bb39ae4b" translate="yes" xml:space="preserve">
          <source>These forms set or remove the default value for a domain. Note that defaults only apply to subsequent &lt;code&gt;INSERT&lt;/code&gt; commands; they do not affect rows already in a table using the domain.</source>
          <target state="translated">これらのフォームは、ドメインのデフォルト値を設定または削除します。デフォルトは後続の &lt;code&gt;INSERT&lt;/code&gt; コマンドにのみ適用されることに注意してください。ドメインを使用しているテーブルに既にある行には影響しません。</target>
        </trans-unit>
        <trans-unit id="1609442aa33410461ce94595a5363c37f09493d1" translate="yes" xml:space="preserve">
          <source>These functions are provided mostly for illustration purposes. You can create your own return types and functions based on the underlying &lt;code&gt;crosstab()&lt;/code&gt; function. There are two ways to do it:</source>
          <target state="translated">これらの関数は、主に説明のために提供されています。基本的な &lt;code&gt;crosstab()&lt;/code&gt; 関数に基づいて、独自の戻り値の型と関数を作成できます。それには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="b71ab786c550ccb22b4bc0a42b2b14940119395f" translate="yes" xml:space="preserve">
          <source>These functions check whether a &lt;code&gt;text&lt;/code&gt; string is well-formed XML, returning a Boolean result. &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; checks for a well-formed document, while &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; checks for well-formed content. &lt;code&gt;xml_is_well_formed&lt;/code&gt; does the former if the &lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xmloption&lt;/a&gt; configuration parameter is set to &lt;code&gt;DOCUMENT&lt;/code&gt;, or the latter if it is set to &lt;code&gt;CONTENT&lt;/code&gt;. This means that &lt;code&gt;xml_is_well_formed&lt;/code&gt; is useful for seeing whether a simple cast to type &lt;code&gt;xml&lt;/code&gt; will succeed, whereas the other two functions are useful for seeing whether the corresponding variants of &lt;code&gt;XMLPARSE&lt;/code&gt; will succeed.</source>
          <target state="translated">これらの関数は、 &lt;code&gt;text&lt;/code&gt; 文字列が整形式のXMLであるかどうかをチェックし、ブール結果を返します。 &lt;code&gt;xml_is_well_formed_document&lt;/code&gt; は整形式のドキュメントをチェックし、 &lt;code&gt;xml_is_well_formed_content&lt;/code&gt; は整形式のコンテンツをチェックします。 &lt;code&gt;xml_is_well_formed&lt;/code&gt; 構成パラメーターが &lt;code&gt;DOCUMENT&lt;/code&gt; に設定されている場合は&lt;a href=&quot;runtime-config-client#GUC-XMLOPTION&quot;&gt;xml_is_well_formed&lt;/a&gt;が前者を実行し、 &lt;code&gt;CONTENT&lt;/code&gt; に設定されている場合は後者を実行します。つまり、 &lt;code&gt;xml_is_well_formed&lt;/code&gt; は、タイプ &lt;code&gt;xml&lt;/code&gt; への単純なキャストが成功するかどうかを確認するのに役立ちますが、他の2つの関数は、 &lt;code&gt;XMLPARSE&lt;/code&gt; の対応するバリアントが成功するかどうかを確認するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c60a18e52593260f76cbca36e7fdad5953d14de4" translate="yes" xml:space="preserve">
          <source>These functions evaluate the XPath query on the supplied document, and cast the result to the specified type.</source>
          <target state="translated">これらの関数は、供給された文書に対して XPath クエリを評価し、その結果を指定された型にキャストします。</target>
        </trans-unit>
        <trans-unit id="f4a3b49c368c625ddd8e1b267d172c4c23e85fb8" translate="yes" xml:space="preserve">
          <source>These functions only run a cipher over data; they don't have any advanced features of PGP encryption. Therefore they have some major problems:</source>
          <target state="translated">これらの機能はデータ上で暗号を実行するだけで、PGP暗号化の高度な機能はありません。したがって、これらの関数にはいくつかの大きな問題があります。</target>
        </trans-unit>
        <trans-unit id="2e87e18038a41ce286dc1540ea6ddc6645f709cb" translate="yes" xml:space="preserve">
          <source>These functions wrap/unwrap binary data into PGP ASCII-armor format, which is basically Base64 with CRC and additional formatting.</source>
          <target state="translated">これらの関数は、バイナリデータをPGPのASCII-armor形式(基本的にはBase64にCRCと追加フォーマットを加えたもの)にラップ/アンラップします。</target>
        </trans-unit>
        <trans-unit id="a69e2cf20fe43ca97cfd2d3152291de2a47cffbd" translate="yes" xml:space="preserve">
          <source>These instructions assume that your existing installation is under the &lt;code&gt;/usr/local/pgsql&lt;/code&gt; directory, and that the data area is in &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;. Substitute your paths appropriately.</source>
          <target state="translated">これらの手順では、既存のインストールが &lt;code&gt;/usr/local/pgsql&lt;/code&gt; ディレクトリの下にあり、データ領域が &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; にあると想定しています。パスを適切に置き換えます。</target>
        </trans-unit>
        <trans-unit id="4c32652f01e68dc2b9e4e1795da20ec44b710efa" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on casts.</source>
          <target state="translated">これらのキーワードはキャストに依存していないので、効果はありません。</target>
        </trans-unit>
        <trans-unit id="bea3c1233d30126b2b7a88c0987f5eda6383c5d4" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on conversions.</source>
          <target state="translated">これらのキーワードは、変換に依存していないので、効果はありません。</target>
        </trans-unit>
        <trans-unit id="0fd011ed971053a775e55c8199ea3272eca8d26f" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on policies.</source>
          <target state="translated">これらのキーワードは、ポリシーに依存していないので、効果はありません。</target>
        </trans-unit>
        <trans-unit id="a6e707f7bc3e009a0e21e941c667a8cfc394f561" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on publications.</source>
          <target state="translated">これらのキーワードは、出版物に依存していないので、何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="32c4da55bd25afdbc9c41ed6381881695d3bb025" translate="yes" xml:space="preserve">
          <source>These key words do not have any effect, since there are no dependencies on subscriptions.</source>
          <target state="translated">これらのキーワードは、サブスクリプションに依存していないので、効果はありません。</target>
        </trans-unit>
        <trans-unit id="2c7609a430b2441baa8c916ed20ac5c190ce5d75" translate="yes" xml:space="preserve">
          <source>These messages are harmless and should be ignored.</source>
          <target state="translated">これらのメッセージは無害なので無視してください。</target>
        </trans-unit>
        <trans-unit id="0c905ac1adcf65ee4d503774195629e18e03ce45" translate="yes" xml:space="preserve">
          <source>These numbers are current as of the last &lt;code&gt;VACUUM&lt;/code&gt; or &lt;code&gt;ANALYZE&lt;/code&gt; on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from &lt;code&gt;relpages&lt;/code&gt; then &lt;code&gt;reltuples&lt;/code&gt; is scaled accordingly to arrive at a current number-of-rows estimate. In the example above, the value of &lt;code&gt;relpages&lt;/code&gt; is up-to-date so the rows estimate is the same as &lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="translated">これらの数値は、テーブルの最後の &lt;code&gt;VACUUM&lt;/code&gt; または &lt;code&gt;ANALYZE&lt;/code&gt; の時点のものです。次に、プランナはテーブル内の実際の現在のページ数をフェッチします（これは安価な操作であり、テーブルスキャンは必要ありません）。それが &lt;code&gt;relpages&lt;/code&gt; と異なる場合、 &lt;code&gt;reltuples&lt;/code&gt; はそれに応じてスケーリングされ、現在の行数の見積もりに到達します。上記の例では、 &lt;code&gt;relpages&lt;/code&gt; の値が最新であるため、行の推定値は &lt;code&gt;reltuples&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="e10d3fa9498e1464949f282d6e93d894677beaed" translate="yes" xml:space="preserve">
          <source>These numbers are derived very straightforwardly. If you do:</source>
          <target state="translated">これらの数字は非常にわかりやすく導き出されています。もし、あなたがそうするならば</target>
        </trans-unit>
        <trans-unit id="3ceb62071b97b9d98e29565b51240d61862b6aa6" translate="yes" xml:space="preserve">
          <source>These operations are also possible using &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;. &lt;code&gt;ALTER INDEX&lt;/code&gt; is in fact just an alias for the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that apply to indexes.</source>
          <target state="translated">これらの操作は、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;を使用して行うこともできます。実際には、 &lt;code&gt;ALTER INDEX&lt;/code&gt; は、インデックスに適用される &lt;code&gt;ALTER TABLE&lt;/code&gt; の形式の単なるエイリアスです。</target>
        </trans-unit>
        <trans-unit id="545a0c8a716c900f9e4c80a9d1bee182bedf1b50" translate="yes" xml:space="preserve">
          <source>These operations are not as efficient as the SQL &lt;code&gt;COPY&lt;/code&gt; command with a file or program data source or destination, because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable.</source>
          <target state="translated">すべてのデータはクライアント/サーバー接続を通過する必要があるため、これらの操作は、ファイルまたはプログラムのデータソースまたは宛先を指定したSQL &lt;code&gt;COPY&lt;/code&gt; コマンドほど効率的ではありません。大量のデータの場合、SQLコマンドの方が適している場合があります。</target>
        </trans-unit>
        <trans-unit id="127d5c1d5ec611dd1c5cea591e059868fdcde0f9" translate="yes" xml:space="preserve">
          <source>These operators do not make a lot of sense for any practical purpose but sorting. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type.</source>
          <target state="translated">これらの演算子は、ソート以外の実用的な目的ではあまり意味がありません。これらの演算子は、まず(a)と(c)を比較し、これらが等しい場合は、(b)と(d)を比較します。これは、ほとんどの場合、合理的に良い並べ替えになり、この型でORDER BYを使用したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="0263a47917171f02351f77d8e8b63fd3b27641de" translate="yes" xml:space="preserve">
          <source>These option names are recognized case-insensitively. Any unspecified options receive these defaults:</source>
          <target state="translated">これらのオプシ ョ ン名は、 大文字小文字を区別せずに認識されます。指定されていないオプションは、これらのデフォルト値を受け取ります。</target>
        </trans-unit>
        <trans-unit id="aae23616e05cfe7a713aa38934f0f1dc39a127ad" translate="yes" xml:space="preserve">
          <source>These options can be used to control the names used in SQL statements sent to the remote PostgreSQL server. These options are needed when a foreign table is created with names different from the underlying remote table's names.</source>
          <target state="translated">これらのオプションを使用して、リモートのPostgreSQLサーバに送信されるSQL文で使用される名前を制御することができます。これらのオプションは、基礎となるリモートテーブルの名前とは異なる名前の外部テーブルが作成される場合に必要となります。</target>
        </trans-unit>
        <trans-unit id="d77fba085883250197e1d576feb3bfa1670ceb86" translate="yes" xml:space="preserve">
          <source>These options can only be specified for a foreign table or its columns, not in the options of the &lt;code&gt;file_fdw&lt;/code&gt; foreign-data wrapper, nor in the options of a server or user mapping using the wrapper.</source>
          <target state="translated">これらのオプションは、外部テーブルまたはその列に対してのみ指定できます &lt;code&gt;file_fdw&lt;/code&gt; 外部データラッパーのオプションや、ラッパーを使用するサーバーまたはユーザーマッピングのオプションでは指定できません。</target>
        </trans-unit>
        <trans-unit id="00c89bc3ee002172b7e73344d78285229be1f391" translate="yes" xml:space="preserve">
          <source>These parameters (except the XPath strings) are just substituted into a plain SQL SELECT statement, so you have some flexibility &amp;mdash; the statement is</source>
          <target state="translated">これらのパラメーター（XPath文字列を除く）は、単純なSQL SELECTステートメントに置き換えられるだけなので、柔軟性があります。ステートメントは</target>
        </trans-unit>
        <trans-unit id="c2aabd8f5a3412d7716945926dce543c9d86d614" translate="yes" xml:space="preserve">
          <source>These parameters can be set on any server that is to send replication data to one or more standby servers. The master is always a sending server, so these parameters must always be set on the master. The role and meaning of these parameters does not change after a standby becomes the master.</source>
          <target state="translated">これらのパラメータは、レプリケーションデータを1つ以上の待機サーバーに送信するサーバーで設定できます。マスターは常に送信サーバーであるため、これらのパラメータは常にマスターに設定する必要があります。スタンバイがマスターになっても、これらのパラメータの役割と意味は変わりません。</target>
        </trans-unit>
        <trans-unit id="0c34294a4db205be8e19649f7f900fbda851ca14" translate="yes" xml:space="preserve">
          <source>These parameters can be set on the master/primary server that is to send replication data to one or more standby servers. Note that in addition to these parameters, &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; must be set appropriately on the master server, and optionally WAL archiving can be enabled as well (see &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;Section 19.5.3&lt;/a&gt;). The values of these parameters on standby servers are irrelevant, although you may wish to set them there in preparation for the possibility of a standby becoming the master.</source>
          <target state="translated">これらのパラメーターは、1つ以上のスタンバイサーバーにレプリケーションデータを送信するマスター/プライマリサーバーで設定できます。これらのパラメーターに加えて、マスターサーバーで&lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_levelを&lt;/a&gt;適切に設定する必要があり、オプションでWALアーカイブも有効にできることに注意してください（&lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-ARCHIVING&quot;&gt;セクション19.5.3を&lt;/a&gt;参照）。スタンバイサーバーがマスターになる可能性に備えて、スタンバイサーバー上のこれらのパラメーターの値は関係ありません。</target>
        </trans-unit>
        <trans-unit id="4d75398d82f486d5c040810e5532c3a355a6c99c" translate="yes" xml:space="preserve">
          <source>These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the &lt;code&gt;pg_stat&lt;/code&gt; and &lt;code&gt;pg_statio&lt;/code&gt; family of system views. Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;Chapter 27&lt;/a&gt; for more information.</source>
          <target state="translated">これらのパラメーターは、サーバー全体の統計収集機能を制御します。統計収集が有効になっている場合、生成されるデータには、システムビューの &lt;code&gt;pg_stat&lt;/code&gt; および &lt;code&gt;pg_statio&lt;/code&gt; ファミリーを介してアクセスできます。詳細については、&lt;a href=&quot;https://www.postgresql.org/docs/12/monitoring.html&quot;&gt;第27章を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d7058fa11283b8e308dc5c38fd60ebf25607e531" translate="yes" xml:space="preserve">
          <source>These parameters enable various debugging output to be emitted. When set, they print the resulting parse tree, the query rewriter output, or the execution plan for each executed query. These messages are emitted at &lt;code&gt;LOG&lt;/code&gt; message level, so by default they will appear in the server log but will not be sent to the client. You can change that by adjusting &lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;client_min_messages&lt;/a&gt; and/or &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messages&lt;/a&gt;. These parameters are off by default.</source>
          <target state="translated">これらのパラメーターにより、さまざまなデバッグ出力を発行できます。設定すると、結果の解析ツリー、クエリリライターの出力、または実行された各クエリの実行プランが出力されます。これらのメッセージは &lt;code&gt;LOG&lt;/code&gt; メッセージレベルで発行されるため、デフォルトではサーバーログに表示されますが、クライアントには送信されません。あなたは調整することによって、それを変更することができます&lt;a href=&quot;runtime-config-client#GUC-CLIENT-MIN-MESSAGES&quot;&gt;かclient_min_messages&lt;/a&gt;および/または&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-MESSAGES&quot;&gt;log_min_messagesを&lt;/a&gt;。これらのパラメーターはデフォルトでオフになっています。</target>
        </trans-unit>
        <trans-unit id="1defee4ea46ba6aaadce70e43d5781b50b0c40a2" translate="yes" xml:space="preserve">
          <source>These parameters must be set in &lt;code&gt;postgresql.conf&lt;/code&gt;. Typical usage might be:</source>
          <target state="translated">これらのパラメータは &lt;code&gt;postgresql.conf&lt;/code&gt; で設定する必要があります。一般的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="51c50b20efcdf41bd58d1a6d4948e28cfd164232" translate="yes" xml:space="preserve">
          <source>These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by SP-GiST is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes.</source>
          <target state="translated">これらの一般的なデータ構造は、元々はインメモリでの使用のために開発されました。メインメモリでは、通常、ポインタでリンクされた動的に割り当てられたノードのセットとして設計されています。これはディスク上に直接格納するのには適していません。なぜなら、これらのポインタのチェーンはかなり長くなり、多くのディスクアクセスを必要とするからです。対照的に、ディスクベースのデータ構造は、I/Oを最小化するために高いファンアウトを持つ必要があります。SP-GiSTの課題は、検索ツリーのノードをディスクページにマッピングすることで、検索が多くのノードを横断しても、わずかなディスクページにしかアクセスできないようにすることです。</target>
        </trans-unit>
        <trans-unit id="929fc5ec9668da12721d514b3f6bf4c331845b00" translate="yes" xml:space="preserve">
          <source>These represent the IEEE 754 special values &amp;ldquo;infinity&amp;rdquo;, &amp;ldquo;negative infinity&amp;rdquo;, and &amp;ldquo;not-a-number&amp;rdquo;, respectively. When writing these values as constants in an SQL command, you must put quotes around them, for example &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt;. On input, these strings are recognized in a case-insensitive manner.</source>
          <target state="translated">これらはそれぞれ、IEEE 754の特別な値「無限」、「負の無限」、および「非数」を表します。SQLコマンドでこれらの値を定数として書き込む場合は、それらを引用符で囲む必要があります（例： &lt;code&gt;UPDATE table SET x = '-Infinity'&lt;/code&gt; 。入力では、これらの文字列は大文字と小文字を区別しない方法で認識されます。</target>
        </trans-unit>
        <trans-unit id="f1107e48978793d7f588abce7216f17e213bc711" translate="yes" xml:space="preserve">
          <source>These rules are very similar to those for writing field values in composite-type literals. See &lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;Section 8.16.6&lt;/a&gt; for additional commentary.</source>
          <target state="translated">これらのルールは、複合型リテラルでフィールド値を書き込む場合のルールとよく似ています。追加の解説については、&lt;a href=&quot;rowtypes#ROWTYPES-IO-SYNTAX&quot;&gt;セクション8.16.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2f4ab75f18b56a1736b944ffdb026f1b2a9cc643" translate="yes" xml:space="preserve">
          <source>These semaphore-related settings are read-only as far as &lt;code&gt;sysctl&lt;/code&gt; is concerned, but can be set in &lt;code&gt;/boot/loader.conf&lt;/code&gt;:</source>
          <target state="translated">これらのセマフォ関連の設定は、 &lt;code&gt;sysctl&lt;/code&gt; に関する限り読み取り専用ですが、 &lt;code&gt;/boot/loader.conf&lt;/code&gt; / loader.confで設定できます。</target>
        </trans-unit>
        <trans-unit id="f0eb1c6b354c2721dc2500c187dae9d22e4b37ec" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command. Any user is allowed to change their session-local value. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">これらの設定は &lt;code&gt;postgresql.conf&lt;/code&gt; から、または &lt;code&gt;SET&lt;/code&gt; コマンドを介してセッション内で設定できます。すべてのユーザーがセッションローカル値を変更できます。 &lt;code&gt;postgresql.conf&lt;/code&gt; の変更は、 &lt;code&gt;SET&lt;/code&gt; でセッションローカル値が設定されていない場合にのみ、既存のセッションに影響します。</target>
        </trans-unit>
        <trans-unit id="0adef7245cebc3b52bd4dfc1694701eadaec06f1" translate="yes" xml:space="preserve">
          <source>These settings can be set from &lt;code&gt;postgresql.conf&lt;/code&gt;, or within a session via the &lt;code&gt;SET&lt;/code&gt; command; but only superusers can change them via &lt;code&gt;SET&lt;/code&gt;. Changes in &lt;code&gt;postgresql.conf&lt;/code&gt; will affect existing sessions only if no session-local value has been established with &lt;code&gt;SET&lt;/code&gt;.</source>
          <target state="translated">これらの設定は &lt;code&gt;postgresql.conf&lt;/code&gt; から、またはセッション内で &lt;code&gt;SET&lt;/code&gt; コマンドを使用して設定できます。ただし、 &lt;code&gt;SET&lt;/code&gt; を使用して変更できるのはスーパーユーザーだけです。 &lt;code&gt;postgresql.conf&lt;/code&gt; の変更は、 &lt;code&gt;SET&lt;/code&gt; でセッションローカル値が設定されていない場合にのみ、既存のセッションに影響します。</target>
        </trans-unit>
        <trans-unit id="7a83e5497c48f3fadb734c9a42de145288252b14" translate="yes" xml:space="preserve">
          <source>These settings can only be applied when the server starts, so any change requires restarting the server. Values for these settings are typically stored in the &lt;code&gt;postgresql.conf&lt;/code&gt; file, or passed on the command line when starting the server. Of course, settings with any of the lower &lt;code&gt;context&lt;/code&gt; types can also be set at server start time.</source>
          <target state="translated">これらの設定はサーバーの起動時にのみ適用できるため、変更を行う場合はサーバーを再起動する必要があります。これらの設定の値は通常、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルに格納されるか、サーバーの起動時にコマンドラインで渡されます。もちろん、下位の &lt;code&gt;context&lt;/code&gt; タイプの設定は、サーバーの起動時にも設定できます。</target>
        </trans-unit>
        <trans-unit id="02aa5756831dee127ec65944b5fa10a7b3de8a8e" translate="yes" xml:space="preserve">
          <source>These settings cannot be changed directly; they reflect internally determined values. Some of them may be adjustable by rebuilding the server with different configuration options, or by changing options supplied to &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">これらの設定を直接変更することはできません。それらは内部で決定された値を反映します。それらのいくつかは、異なる構成オプションを使用してサーバーを再構築するか、 &lt;code&gt;initdb&lt;/code&gt; に提供されたオプションを変更することによって調整できます。</target>
        </trans-unit>
        <trans-unit id="317e80ee1851e3545ba5ed374350ee15698895fc" translate="yes" xml:space="preserve">
          <source>These settings control how process titles of server processes are modified. Process titles are typically viewed using programs like ps or, on Windows, Process Explorer. See &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details.</source>
          <target state="translated">これらの設定は、サーバープロセスのプロセスタイトルの変更方法を制御します。プロセスのタイトルは通常、psなどのプログラム、またはWindowsではProcess Explorerを使用して表示されます。詳細は&lt;a href=&quot;monitoring-ps&quot;&gt;項27.1&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c21f5b22d74359b34a233de933da88c1556b1754" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a logical replication subscriber. Their values on the publisher are irrelevant.</source>
          <target state="translated">これらの設定は、論理レプリケーションサブスクライバーの動作を制御します。パブリッシャー上の値は関係ありません。</target>
        </trans-unit>
        <trans-unit id="51ac309dd49de1c6d6c04c1c54a256fdaeb98b75" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of a standby server that is to receive replication data. Their values on the master server are irrelevant.</source>
          <target state="translated">これらの設定は、レプリケーションデータを受信するスタンバイサーバーの動作を制御します。マスターサーバー上での値は関係ありません。</target>
        </trans-unit>
        <trans-unit id="d40b8d037fb02f22e279e00bffd1ef98f7d8c44d" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the &lt;em&gt;autovacuum&lt;/em&gt; feature. Refer to &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. Note that many of these settings can be overridden on a per-table basis; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt;.</source>
          <target state="translated">これらの設定は、&lt;em&gt;自動バキューム&lt;/em&gt;機能の動作を制御します。詳細は&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;項24.1.6&lt;/a&gt;を参照してください。これらの設定の多くはテーブルごとに上書きできることに注意してください。&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;ストレージパラメータを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1c9c05e7e68e0c9931d3c483fab276d6098720bf" translate="yes" xml:space="preserve">
          <source>These settings control the behavior of the built-in &lt;em&gt;streaming replication&lt;/em&gt; feature (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;). Servers will be either a master or a standby server. Masters can send data, while standbys are always receivers of replicated data. When cascading replication (see &lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;Section 26.2.7&lt;/a&gt;) is used, standby servers can also be senders, as well as receivers. Parameters are mainly for sending and standby servers, though some parameters have meaning only on the master server. Settings may vary across the cluster without problems if that is required.</source>
          <target state="translated">これらの設定は、組み込みの&lt;em&gt;ストリーミング複製&lt;/em&gt;機能の動作を制御します（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;セクション26.2.5を&lt;/a&gt;参照）。サーバーは、マスターサーバーまたはスタンバイサーバーになります。マスターはデータを送信できますが、スタンバイは常に複製されたデータのレシーバーです。カスケード型レプリケーション（&lt;a href=&quot;warm-standby#CASCADING-REPLICATION&quot;&gt;セクション26.2.7を&lt;/a&gt;参照）が使用されている場合、スタンバイサーバーは、受信者だけでなく送信者にもなります。パラメーターは主に送信サーバーとスタンバイサーバー用ですが、一部のパラメーターはマスターサーバーでのみ意味があります。必要に応じて、設定はクラスター全体で問題なく変化する場合があります。</target>
        </trans-unit>
        <trans-unit id="631081e51e8d0c56dfb2edd79daea765216e4764" translate="yes" xml:space="preserve">
          <source>These settings will cause postmaster child processes to run with the normal OOM score adjustment of zero, so that the OOM killer can still target them at need. You could use some other value for &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; if you want the child processes to run with some other OOM score adjustment. (&lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; can also be omitted, in which case it defaults to zero.) If you do not set &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt;, the child processes will run with the same OOM score adjustment as the postmaster, which is unwise since the whole point is to ensure that the postmaster has a preferential setting.</source>
          <target state="translated">これらの設定により、postmaster子プロセスは通常のOOMスコア調整がゼロで実行されるため、OOMキラーは必要に応じてそれらをターゲットにすることができます。子プロセスを他のOOMスコア調整で実行する場合は、 &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; に他の値を使用できます。（ &lt;code&gt;PG_OOM_ADJUST_VALUE&lt;/code&gt; も省略できます。その場合、デフォルトでゼロに設定されます。） &lt;code&gt;PG_OOM_ADJUST_FILE&lt;/code&gt; を設定しない場合、子プロセスはポストマスターと同じOOMスコア調整で実行されます。postmasterには優先設定があります。</target>
        </trans-unit>
        <trans-unit id="8ab15e9b47def86730e35b3c5c50e0dfe3f834aa" translate="yes" xml:space="preserve">
          <source>These specify what the prompts psql issues should look like. See &lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;Prompting&lt;/a&gt; below.</source>
          <target state="translated">これらは、psqlが発行するプロンプトの外観を指定します。以下の&lt;a href=&quot;app-psql#APP-PSQL-PROMPTING&quot;&gt;プロンプトを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6086ed3e7f06eab1a2070198d662f5b66b1e6406" translate="yes" xml:space="preserve">
          <source>These trigger functions automatically compute a &lt;code&gt;tsvector&lt;/code&gt; column from one or more textual columns, under the control of parameters specified in the &lt;code&gt;CREATE TRIGGER&lt;/code&gt; command. An example of their use is:</source>
          <target state="translated">これらのトリガー関数は、 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; コマンドで指定されたパラメーターの制御下で、1つ以上のテキスト列から &lt;code&gt;tsvector&lt;/code&gt; 列を自動的に計算します。それらの使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="26b286f322440c12ea3e3c031f3d293b77ba6582" translate="yes" xml:space="preserve">
          <source>These two fields can be used as an alternative to the &lt;code&gt;IP-address&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;mask-length&lt;/code&gt; notation. Instead of specifying the mask length, the actual mask is specified in a separate column. For example, &lt;code&gt;255.0.0.0&lt;/code&gt; represents an IPv4 CIDR mask length of 8, and &lt;code&gt;255.255.255.255&lt;/code&gt; represents a CIDR mask length of 32.</source>
          <target state="translated">これらの2つのフィールドは、 &lt;code&gt;IP-address&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;mask-length&lt;/code&gt; 表記の代わりに使用できます。マスク長を指定する代わりに、実際のマスクは別の列で指定されます。たとえば、 &lt;code&gt;255.0.0.0&lt;/code&gt; は8のIPv4 CIDRマスク長を表し、 &lt;code&gt;255.255.255.255&lt;/code&gt; は32のCIDRマスク長を表します。</target>
        </trans-unit>
        <trans-unit id="b912ce7211a3c9dfe25f2009d32879c2b4a7718a" translate="yes" xml:space="preserve">
          <source>These variables are set at program start-up to reflect psql's version, respectively as a verbose string, a short string (e.g., &lt;code&gt;9.6.2&lt;/code&gt;, &lt;code&gt;10.1&lt;/code&gt;, or &lt;code&gt;11beta1&lt;/code&gt;), and a number (e.g., &lt;code&gt;90602&lt;/code&gt; or &lt;code&gt;100001&lt;/code&gt;). They can be changed or unset.</source>
          <target state="translated">これらの変数は、それぞれ冗長列、短い文字列（例えば、として、psqlのバージョンを反映するために、プログラムの起動時に設定されている &lt;code&gt;9.6.2&lt;/code&gt; 、 &lt;code&gt;10.1&lt;/code&gt; 、または &lt;code&gt;11beta1&lt;/code&gt; ）、および番号（例えば、 &lt;code&gt;90602&lt;/code&gt; または &lt;code&gt;100001&lt;/code&gt; ）。変更または設定解除できます。</target>
        </trans-unit>
        <trans-unit id="d1888af9231d7dc7892d920d2796a7d30d3c432b" translate="yes" xml:space="preserve">
          <source>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value &amp;ldquo;unknown&amp;rdquo;. Notice that &lt;code&gt;IS UNKNOWN&lt;/code&gt; and &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; are effectively the same as &lt;code&gt;IS NULL&lt;/code&gt; and &lt;code&gt;IS NOT NULL&lt;/code&gt;, respectively, except that the input expression must be of Boolean type.</source>
          <target state="translated">これらは常にtrueまたはfalseを返し、オペランドがnullの場合でもnull値を返しません。null入力は、論理値「不明」として扱われます。 &lt;code&gt;IS UNKNOWN&lt;/code&gt; および &lt;code&gt;IS NOT UNKNOWN&lt;/code&gt; は、入力式がブール型でなければならないことを除いて、それぞれ &lt;code&gt;IS NULL&lt;/code&gt; および &lt;code&gt;IS NOT NULL&lt;/code&gt; と実質的に同じであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="eb77a6f9b66e9a05805238727dad27ac972c149a" translate="yes" xml:space="preserve">
          <source>They are slow. As the amount of data is so small, this is the only way to make brute-forcing passwords hard.</source>
          <target state="translated">遅いのです。データ量が少ないので、パスワードをブルートフォース化するにはこれしかない。</target>
        </trans-unit>
        <trans-unit id="bf2c8c3d26564b271cd3b0f3cc01f4bc594ad56e" translate="yes" xml:space="preserve">
          <source>They don't handle text.</source>
          <target state="translated">彼らはテキストを処理しません。</target>
        </trans-unit>
        <trans-unit id="89bd6007244204d4a23986add99e11b8144bb68e" translate="yes" xml:space="preserve">
          <source>They don't provide any integrity checking, to see if the encrypted data was modified.</source>
          <target state="translated">彼らは暗号化されたデータが変更されたかどうかを確認するための完全性チェックを提供していません。</target>
        </trans-unit>
        <trans-unit id="108af784f0fd778d605e66d5a415819131da0024" translate="yes" xml:space="preserve">
          <source>They expect that users manage all encryption parameters themselves, even IV.</source>
          <target state="translated">彼らは、ユーザーがすべての暗号化パラメータを自分で管理することを期待しています。</target>
        </trans-unit>
        <trans-unit id="0c2039617625e55d628a5303153737be520c2636" translate="yes" xml:space="preserve">
          <source>They include the algorithm type in the result, so passwords hashed with different algorithms can co-exist.</source>
          <target state="translated">結果にアルゴリズムの種類が含まれるので、異なるアルゴリズムでハッシュ化されたパスワードが共存することができます。</target>
        </trans-unit>
        <trans-unit id="c3e7dceb3b44e3013034907236242ebd62f58f0d" translate="yes" xml:space="preserve">
          <source>They provide no ordering (ranking) of search results, which makes them ineffective when thousands of matching documents are found.</source>
          <target state="translated">検索結果の順位付け(ランキング)をしてくれないので、何千ものマッチング文書が出てきても効果がありません。</target>
        </trans-unit>
        <trans-unit id="2c267279c3829425820b5af53bc51b1aea00680d" translate="yes" xml:space="preserve">
          <source>They tend to be slow because there is no index support, so they must process all documents for every search.</source>
          <target state="translated">インデックスのサポートがないため、検索のたびにすべての文書を処理しなければならないため、時間がかかる傾向にあります。</target>
        </trans-unit>
        <trans-unit id="fc6b695f1b5d50d9c60b39def6c93072e73b0c7c" translate="yes" xml:space="preserve">
          <source>They use a random value, called the &lt;em&gt;salt&lt;/em&gt;, so that users having the same password will have different encrypted passwords. This is also an additional defense against reversing the algorithm.</source>
          <target state="translated">それらは&lt;em&gt;salt&lt;/em&gt;と呼ばれるランダムな値を使用するため、同じパスワードを持つユーザーは異なる暗号化されたパスワードを持つことになります。これは、アルゴリズムの逆転に対する追加の防御策でもあります。</target>
        </trans-unit>
        <trans-unit id="e85a3bee9adadb9e25e77dec1600e19104320bfe" translate="yes" xml:space="preserve">
          <source>They use user key directly as cipher key.</source>
          <target state="translated">彼らは、ユーザ鍵を直接暗号鍵として使用しています。</target>
        </trans-unit>
        <trans-unit id="8dbebd5ef75455c0a62f167f8fa030487ae4ceab" translate="yes" xml:space="preserve">
          <source>Things are more difficult if you need to recover from corruption of an index on a system table. In this case it's important for the system to not have used any of the suspect indexes itself. (Indeed, in this sort of scenario you might find that server processes are crashing immediately at start-up, due to reliance on the corrupted indexes.) To recover safely, the server must be started with the &lt;code&gt;-P&lt;/code&gt; option, which prevents it from using indexes for system catalog lookups.</source>
          <target state="translated">システムテーブルのインデックスの破損から回復する必要がある場合、事態はさらに困難になります。この場合、システムが疑わしいインデックス自体を使用していないことが重要です。（実際、この種のシナリオでは、破損したインデックスに依存しているため、起動時にサーバープロセスがすぐにクラッシュすることがあります。）安全に回復するには、サーバーを &lt;code&gt;-P&lt;/code&gt; オプションで起動する必要があります。システムカタログの検索にインデックスを使用する。</target>
        </trans-unit>
        <trans-unit id="96f7dee4533ea61962d64e3ad5a7fcf16ccab0dd" translate="yes" xml:space="preserve">
          <source>Third, turn on &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt;. For security reasons, the rules in &lt;code&gt;sepgsql-regtest&lt;/code&gt; are not enabled by default; the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter enables the rules needed to launch the regression tests. It can be turned on using the &lt;code&gt;setsebool&lt;/code&gt; command:</source>
          <target state="translated">3番目に、 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; をオンにします。セキュリティ上の理由から、 &lt;code&gt;sepgsql-regtest&lt;/code&gt; のルールはデフォルトでは有効になっていません。 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; のパラメータは、回帰テストを起動するために必要なルールを可能にします。これは、 &lt;code&gt;setsebool&lt;/code&gt; コマンドを使用してオンにすることができます。</target>
        </trans-unit>
        <trans-unit id="e8a4d63f55e2492f2cd42b3a9fb86caa1ca5e84c" translate="yes" xml:space="preserve">
          <source>Third-party applications can be put into separate schemas so they do not collide with the names of other objects.</source>
          <target state="translated">サードパーティのアプリケーションは、他のオブジェクトの名前と衝突しないように別のスキーマに入れることができます。</target>
        </trans-unit>
        <trans-unit id="04297a9823a3a2086d546b9d671ec1f8ab29f655" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;WITH&lt;/code&gt; query will be folded, producing the same execution plan as</source>
          <target state="translated">この &lt;code&gt;WITH&lt;/code&gt; クエリは折りたたまれ、次と同じ実行プランが生成されます</target>
        </trans-unit>
        <trans-unit id="14ca478547dc2e8fab1f8f6bfce576b001fe2285" translate="yes" xml:space="preserve">
          <source>This access control mechanism is independent of the one described in &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;.</source>
          <target state="translated">このアクセス制御メカニズムは、&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章で&lt;/a&gt;説明されているものとは独立しています。</target>
        </trans-unit>
        <trans-unit id="4c7fa7bd259660d0cb8e1608dc878af198c41a3a" translate="yes" xml:space="preserve">
          <source>This acquires a row-level lock on the row with the specified account number. Then, the second transaction executes:</source>
          <target state="translated">これは、指定されたアカウント番号を持つ行の行レベルのロックを取得します。その後、2番目のトランザクションが実行されます。</target>
        </trans-unit>
        <trans-unit id="5cf940ef6c18dd4ff1a92a3955dc9c9d23c16666" translate="yes" xml:space="preserve">
          <source>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using &lt;code&gt;COPY&lt;/code&gt;, pg_dump, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports.</source>
          <target state="translated">これにより、データが削除される前に、データに対してさらに操作を実行できます。たとえば、これは多くの場合、 &lt;code&gt;COPY&lt;/code&gt; 、pg_dumpなどのツールを使用してデータをバックアップするのに役立ちます。また、データをより小さなフォーマットに集約したり、他のデータ操作を実行したり、レポートを実行したりするのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="7fb6b13498a74131eab9c57b3090da36c9ec9b3f" translate="yes" xml:space="preserve">
          <source>This allows sequential scans of large tables to synchronize with each other, so that concurrent scans read the same block at about the same time and hence share the I/O workload. When this is enabled, a scan might start in the middle of the table and then &amp;ldquo;wrap around&amp;rdquo; the end to cover all rows, so as to synchronize with the activity of scans already in progress. This can result in unpredictable changes in the row ordering returned by queries that have no &lt;code&gt;ORDER BY&lt;/code&gt; clause. Setting this parameter to &lt;code&gt;off&lt;/code&gt; ensures the pre-8.3 behavior in which a sequential scan always starts from the beginning of the table. The default is &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">これにより、大規模なテーブルの順次スキャンを互いに同期させることができるため、同時スキャンが同じブロックをほぼ同時に読み取り、I / Oワークロードを共有できます。これが有効になっている場合、スキャンはテーブルの中央で開始し、最後に「ラップアラウンド」してすべての行をカバーし、すでに進行中のスキャンのアクティビティと同期する場合があります。これにより、 &lt;code&gt;ORDER BY&lt;/code&gt; 句のないクエリによって返される行の順序が予期せず変更される可能性があります。このパラメーターを &lt;code&gt;off&lt;/code&gt; 設定すると、順次スキャンが常にテーブルの先頭から開始される8.3より前の動作が保証されます。デフォルトは &lt;code&gt;on&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="253b2ab3ed8967081995487ba9ee5b4826393d61" translate="yes" xml:space="preserve">
          <source>This and other array operators are further described in &lt;a href=&quot;functions-array&quot;&gt;Section 9.18&lt;/a&gt;. It can be accelerated by an appropriate index, as described in &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt;.</source>
          <target state="translated">この配列演算子と他の配列演算子については、&lt;a href=&quot;functions-array&quot;&gt;9.18節で&lt;/a&gt;詳しく説明します。&lt;a href=&quot;indexes-types&quot;&gt;セクション11.2で&lt;/a&gt;説明されているように、適切なインデックスによって加速することができます。</target>
        </trans-unit>
        <trans-unit id="22f7125f90456e96d69dc4420ff05c41c76b48ac" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses BSD Authentication to verify the password. BSD Authentication is used only to validate user name/password pairs. Therefore the user's role must already exist in the database before BSD Authentication can be used for authentication. The BSD Authentication framework is currently only available on OpenBSD.</source>
          <target state="translated">この認証方法は、BSD認証を使用してパスワードを検証することを除いて、 &lt;code&gt;password&lt;/code&gt; と同様に機能します。BSD認証は、ユーザー名とパスワードのペアを検証するためにのみ使用されます。したがって、BSD認証を認証に使用する前に、ユーザーの役割がデータベースにすでに存在している必要があります。BSD認証フレームワークは現在、OpenBSDでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="b4a95a1004ec8979c4ed272cc869cffc8b380262" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses LDAP as the password verification method. LDAP is used only to validate the user name/password pairs. Therefore the user must already exist in the database before LDAP can be used for authentication.</source>
          <target state="translated">この認証方法は、パスワード検証方法としてLDAPを使用することを除いて、 &lt;code&gt;password&lt;/code&gt; と同様に機能します。LDAPは、ユーザー名とパスワードのペアを検証するためにのみ使用されます。したがって、LDAPを認証に使用するには、ユーザーがデータベースにすでに存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="14894f744e61a4d997e0bd55d2f4134698e24251" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses PAM (Pluggable Authentication Modules) as the authentication mechanism. The default PAM service name is &lt;code&gt;postgresql&lt;/code&gt;. PAM is used only to validate user name/password pairs and optionally the connected remote host name or IP address. Therefore the user must already exist in the database before PAM can be used for authentication. For more information about PAM, please read the &lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAM Page&lt;/a&gt;.</source>
          <target state="translated">この認証方法は、認証メカニズムとしてPAM（Pluggable Authentication Modules）を使用することを除いて、 &lt;code&gt;password&lt;/code&gt; と同様に機能します。デフォルトのPAMサービス名は &lt;code&gt;postgresql&lt;/code&gt; です。PAMは、ユーザー名とパスワードのペア、およびオプションで接続されているリモートホスト名またはIPアドレスを検証するためにのみ使用されます。したがって、PAMを認証に使用する前に、ユーザーはデータベースに既に存在している必要があります。PAMの詳細については、&lt;a href=&quot;https://www.kernel.org/pub/linux/libs/pam/&quot;&gt;Linux-PAMページを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ebd397f0c1d27e7e6f24266e4663491230029a1f" translate="yes" xml:space="preserve">
          <source>This authentication method operates similarly to &lt;code&gt;password&lt;/code&gt; except that it uses RADIUS as the password verification method. RADIUS is used only to validate the user name/password pairs. Therefore the user must already exist in the database before RADIUS can be used for authentication.</source>
          <target state="translated">この認証方法は、パスワード検証方法としてRADIUSを使用することを除いて、 &lt;code&gt;password&lt;/code&gt; と同様に機能します。 RADIUSは、ユーザー名とパスワードのペアの検証にのみ使用されます。したがって、RADIUSを認証に使用する前に、ユーザーはデータベースに既に存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="699ba79710348057cae6bc38a6f4967f7fef3d56" translate="yes" xml:space="preserve">
          <source>This authentication method uses SSL client certificates to perform authentication. It is therefore only available for SSL connections. When using this authentication method, the server will require that the client provide a valid, trusted certificate. No password prompt will be sent to the client. The &lt;code&gt;cn&lt;/code&gt; (Common Name) attribute of the certificate will be compared to the requested database user name, and if they match the login will be allowed. User name mapping can be used to allow &lt;code&gt;cn&lt;/code&gt; to be different from the database user name.</source>
          <target state="translated">この認証方法は、SSLクライアント証明書を使用して認証を実行します。したがって、SSL接続でのみ使用できます。この認証方法を使用する場合、サーバーはクライアントが有効で信頼できる証明書を提供することを要求します。パスワードプロンプトはクライアントに送信されません。証明書の &lt;code&gt;cn&lt;/code&gt; （共通名）属性は、要求されたデータベースユーザー名と比較され、それらが一致する場合はログインが許可されます。ユーザー名マッピングを使用して、 &lt;code&gt;cn&lt;/code&gt; をデータベースユーザー名とは異なるものにすることができます。</target>
        </trans-unit>
        <trans-unit id="5ac6c0054ced8ebe81d0f1a02772b68633401dc6" translate="yes" xml:space="preserve">
          <source>This behavior is desirable since it allows searches to work for both the whole compound word and for components. Here is another instructive example:</source>
          <target state="translated">この動作は、複合語全体と構成要素の両方を検索できるので、望ましいものです。ここにもう一つの有益な例を示します。</target>
        </trans-unit>
        <trans-unit id="286f6e80e06ffd51f385da7d2a7694b40cc44231" translate="yes" xml:space="preserve">
          <source>This can be convenient to be able to use operating-system-independent collation names in applications.</source>
          <target state="translated">これは、アプリケーションでオペレーティングシステムに依存しない照合名を使用できるようにするのに便利です。</target>
        </trans-unit>
        <trans-unit id="2cb2c31cd20a3afc74e461bc50ba20daffd3b134" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes.</source>
          <target state="translated">これはGiSTインデックスではかなり効率的に実装できますが、GINインデックスでは実装できません。</target>
        </trans-unit>
        <trans-unit id="30c9965536e9eb1807b9625445e1dc9ee486d49c" translate="yes" xml:space="preserve">
          <source>This can be implemented quite efficiently by GiST indexes, but not by GIN indexes. It will usually beat the first formulation when only a small number of the closest matches is wanted.</source>
          <target state="translated">これはGiSTインデックスではかなり効率的に実装できますが、GINインデックスでは実装できません。これは通常,少数の最も近い一致が必要な場合には,最初の定式化よりも優れています.</target>
        </trans-unit>
        <trans-unit id="b19d203036cf7d45dfab0c4ad82ce10183e0940c" translate="yes" xml:space="preserve">
          <source>This can very quickly delete millions of records because it doesn't have to individually delete every record. Note however that the above command requires taking an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on the parent table.</source>
          <target state="translated">すべてのレコードを個別に削除する必要がないため、数百万のレコードを非常に迅速に削除できます。ただし、上記のコマンドでは、親テーブルで &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックを取得する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b3706a06d88bffe054b5b4e9ba07c3a2f69517db" translate="yes" xml:space="preserve">
          <source>This catalog only contains tables known to the subscription after running either &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; or &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt;.</source>
          <target state="translated">このカタログには、 &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; または &lt;code&gt;ALTER SUBSCRIPTION ... REFRESH PUBLICATION&lt;/code&gt; いずれかを実行した後でサブスクリプションが認識しているテーブルのみが含まれています。</target>
        </trans-unit>
        <trans-unit id="c00511a06e3429d3e3c63e91ce19e3a4e9397cad" translate="yes" xml:space="preserve">
          <source>This chapter explains the interface between the core PostgreSQL system and &lt;em&gt;table access methods&lt;/em&gt;, which manage the storage for tables. The core system knows little about these access methods beyond what is specified here, so it is possible to develop entirely new access method types by writing add-on code.</source>
          <target state="translated">この章では、コアPostgreSQLシステムと、&lt;em&gt;テーブル&lt;/em&gt;のストレージを管理する&lt;em&gt;テーブルアクセスメソッド&lt;/em&gt;との間のインターフェースについて説明します。コアシステムは、ここで指定されたものを超えてこれらのアクセス方法についてほとんど知らないため、アドオンコードを記述することにより、まったく新しいアクセス方法タイプを開発することが可能です。</target>
        </trans-unit>
        <trans-unit id="3bbb8116ccc75f5eb2a80776b0a4003df51db1c5" translate="yes" xml:space="preserve">
          <source>This chapter provides an overview of how to use SQL to perform simple operations. This tutorial is only intended to give you an introduction and is in no way a complete tutorial on SQL. Numerous books have been written on SQL, including &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;. You should be aware that some PostgreSQL language features are extensions to the standard.</source>
          <target state="translated">この章では、SQLを使用して簡単な操作を実行する方法の概要を説明します。このチュートリアルは、概要を説明することのみを目的としており、SQLに関する完全なチュートリアルではありません。&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#MELT93&quot;&gt;[melt93]&lt;/a&gt;や&lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#DATE97&quot;&gt;[date97]&lt;/a&gt;など、SQLに関する書籍は数多く書かれています。一部のPostgreSQL言語機能は、標準の拡張機能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d4bef49f81ca7b2b6c1d960ddeae062fa5602386" translate="yes" xml:space="preserve">
          <source>This chapter will on occasion refer to examples found in &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt; to change or improve them, so it will be useful to have read that chapter. Some examples from this chapter can also be found in &lt;code&gt;advanced.sql&lt;/code&gt; in the tutorial directory. This file also contains some sample data to load, which is not repeated here. (Refer to &lt;a href=&quot;tutorial-sql-intro&quot;&gt;Section 2.1&lt;/a&gt; for how to use the file.)</source>
          <target state="translated">この章では、&lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;第2章&lt;/a&gt;にある例を参考にしてそれらを変更または改善するため、その章を読んでおくと役立ちます。この章のいくつかの例は、チュートリアルディレクトリの &lt;code&gt;advanced.sql&lt;/code&gt; にもあります。このファイルには、ロードするサンプルデータも含まれていますが、ここでは繰り返しません。（ファイルの使用方法については、&lt;a href=&quot;tutorial-sql-intro&quot;&gt;セクション2.1&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="b05316eb335b74f7f1d96b694767ed937c7a73d2" translate="yes" xml:space="preserve">
          <source>This clause allows selection of the tablespace in which the index associated with a &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, or &lt;code&gt;EXCLUDE&lt;/code&gt; constraint will be created. If not specified, &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; is consulted, or &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; if the table is temporary.</source>
          <target state="translated">この句を使用すると、 &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、または &lt;code&gt;EXCLUDE&lt;/code&gt; 制約に関連付けられたインデックスが作成されるテーブルスペースを選択できます。指定しない場合、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;、またはテーブルが一時的な場合は&lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt;が参照されます。</target>
        </trans-unit>
        <trans-unit id="9a22b296ec30545018cebf2ee6b84bbc440b4d2a" translate="yes" xml:space="preserve">
          <source>This clause alters parameters originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information. The allowed options are &lt;code&gt;slot_name&lt;/code&gt; and &lt;code&gt;synchronous_commit&lt;/code&gt;</source>
          <target state="translated">この句は、&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;によって最初に設定されたパラメータを変更します。詳細はそちらをご覧ください。使用できるオプションは、 &lt;code&gt;slot_name&lt;/code&gt; と &lt;code&gt;synchronous_commit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dde9dc06154fb93b57360e4813d2af30753235f" translate="yes" xml:space="preserve">
          <source>This clause alters publication parameters originally set by &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">この句は、最初に&lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt;によって設定されたパブリケーションパラメータを変更します。詳細はそちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="3a47a54fa61280e2ffdfce9d2640b5d9bb858deb" translate="yes" xml:space="preserve">
          <source>This clause alters the connection property originally set by &lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;. See there for more information.</source>
          <target state="translated">この句は、最初に&lt;a href=&quot;sql-createsubscription&quot;&gt;CREATE SUBSCRIPTION&lt;/a&gt;によって設定された接続プロパティを変更します。詳細はそちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="5d2fcb8e278e1a72c6a053d69e9530239790d3c7" translate="yes" xml:space="preserve">
          <source>This clause creates the column as a &lt;em&gt;generated column&lt;/em&gt;. The column cannot be written to, and when read the result of the specified expression will be returned.</source>
          <target state="translated">この句は、&lt;em&gt;生成さ&lt;/em&gt;れた列として列を&lt;em&gt;作成します&lt;/em&gt;。列に書き込むことができません。読み取られると、指定された式の結果が返されます。</target>
        </trans-unit>
        <trans-unit id="cd8eb7a6eec884310b19db2fe89fcdaa447cc6e8" translate="yes" xml:space="preserve">
          <source>This clause creates the column as an &lt;em&gt;identity column&lt;/em&gt;. It will have an implicit sequence attached to it and the column in new rows will automatically have values from the sequence assigned to it.</source>
          <target state="translated">この句は、列を&lt;em&gt;ID列&lt;/em&gt;として作成し&lt;em&gt;ます&lt;/em&gt;。暗黙のシーケンスがアタッチされ、新しい行の列には、シーケンスに割り当てられた値が自動的に割り当てられます。</target>
        </trans-unit>
        <trans-unit id="da05955831bd605d103f99ab7132a00a6b982439" translate="yes" xml:space="preserve">
          <source>This clause indicates whether the following relation name is for the before-image transition relation or the after-image transition relation.</source>
          <target state="translated">この句は、以下の関係名が、画像前遷移関係のためのものか、画像後遷移関係のためのものかを示す。</target>
        </trans-unit>
        <trans-unit id="deddf49266216fee17210941a2dbf2f328be5ca2" translate="yes" xml:space="preserve">
          <source>This clause is only intended for compatibility with nonstandard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">この句は、非標準SQLデータベースとの互換性のみを目的としています。新しいアプリケーションでの使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="41393a74e45a6c0a80ff1bb273dd882f889e0a0f" translate="yes" xml:space="preserve">
          <source>This clause is only provided for compatibility with non-standard SQL databases. Its use is discouraged in new applications.</source>
          <target state="translated">この句は、非標準SQLデータベースとの互換性のためだけに提供されています。新しいアプリケーションでの使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="22cd0887432e6ccdc3a45b9fc77bdb8214571dbc" translate="yes" xml:space="preserve">
          <source>This clause is useful for example when copying values between tables. Writing &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; will copy from &lt;code&gt;tbl1&lt;/code&gt; all columns that are not identity columns in &lt;code&gt;tbl2&lt;/code&gt; while values for the identity columns in &lt;code&gt;tbl2&lt;/code&gt; will be generated by the sequences associated with &lt;code&gt;tbl2&lt;/code&gt;.</source>
          <target state="translated">この句は、テーブル間で値をコピーする場合などに役立ちます。ライティング &lt;code&gt;INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1&lt;/code&gt; からコピーされます &lt;code&gt;tbl1&lt;/code&gt; ないでID列にあるすべての列 &lt;code&gt;tbl2&lt;/code&gt; のID列の値ながら &lt;code&gt;tbl2&lt;/code&gt; 関連付けられた配列によって生成されます &lt;code&gt;tbl2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4ccb1be36e739cedb50d44f85c522aa002c906" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a publication. The following parameters are supported:</source>
          <target state="translated">この節では、パブリケーションのオプション・パラメータを指定します。以下のパラメータがサポートされています。</target>
        </trans-unit>
        <trans-unit id="0ab7a0e0c831da17344263c723c33e3ad9e5583a" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a subscription. The following parameters are supported:</source>
          <target state="translated">この節では、サブスクリプションのオプションのパラメータを指定する。以下のパラメータがサポートされています。</target>
        </trans-unit>
        <trans-unit id="501055417d1a99c1021f58bb4344fd42a1fc3dfa" translate="yes" xml:space="preserve">
          <source>This clause specifies optional parameters for a view; the following parameters are supported:</source>
          <target state="translated">この節では、ビューのオプションのパラメータを指定します。</target>
        </trans-unit>
        <trans-unit id="53e5726eff7272a0b43b9a8622a25a1a4b88715e" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for a table or index; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should not contain OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">この句は、テーブルまたはインデックスのオプションのストレージパラメータを指定します。詳細については、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;ストレージパラメータ&lt;/a&gt;を参照してください。下位互換性のために、テーブルの &lt;code&gt;WITH&lt;/code&gt; 句に &lt;code&gt;OIDS=FALSE&lt;/code&gt; を含めて、新しいテーブルの行にOID（オブジェクト識別子）を &lt;code&gt;OIDS=TRUE&lt;/code&gt; ないように指定することもできます。OIDS= TRUEはサポートされなくなりました。</target>
        </trans-unit>
        <trans-unit id="8e37f3a174a386383c959a305d30ae15361d5fa2" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new materialized view; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. All parameters supported for &lt;code&gt;CREATE TABLE&lt;/code&gt; are also supported for &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt;. See &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more information.</source>
          <target state="translated">この句は、新しいマテリアライズドビューのオプションのストレージパラメーターを指定します。詳細については、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;ストレージパラメータ&lt;/a&gt;を参照してください。 &lt;code&gt;CREATE TABLE&lt;/code&gt; でサポートされるすべてのパラメーターは、 &lt;code&gt;CREATE MATERIALIZED VIEW&lt;/code&gt; でもサポートされます。詳細については、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="afd2349edcbad3293d90a1b82afea4e43718f802" translate="yes" xml:space="preserve">
          <source>This clause specifies optional storage parameters for the new table; see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for more information. For backward-compatibility the &lt;code&gt;WITH&lt;/code&gt; clause for a table can also include &lt;code&gt;OIDS=FALSE&lt;/code&gt; to specify that rows of the new table should contain no OIDs (object identifiers), &lt;code&gt;OIDS=TRUE&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">この句は、新しいテーブルのオプションのストレージパラメータを指定します。詳細については、&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;ストレージパラメータ&lt;/a&gt;を参照してください。下位互換性のために、テーブルの &lt;code&gt;WITH&lt;/code&gt; 句に &lt;code&gt;OIDS=FALSE&lt;/code&gt; を含めて、新しいテーブルの行にOID（オブジェクト識別子）を &lt;code&gt;OIDS=TRUE&lt;/code&gt; ないように指定することもできます。OIDS= TRUEはサポートされなくなりました。</target>
        </trans-unit>
        <trans-unit id="3b9cf336be30ceb53b3db8168b3e8c1bdee3f553" translate="yes" xml:space="preserve">
          <source>This clause specifies options for the new foreign-data wrapper. The allowed option names and values are specific to each foreign data wrapper and are validated using the foreign-data wrapper's validator function. Option names must be unique.</source>
          <target state="translated">この節では、新しい外部データラッパーのオプションを指定します。許可されるオプション名と値は、それぞれの外部データラッパーに固有のものであり、 外部データラッパーのバリデータ関数を用いて検証されます。オプション名は一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="3f504297f50fca952ddee9289f583252aaad16be" translate="yes" xml:space="preserve">
          <source>This clause specifies the options for the server. The options typically define the connection details of the server, but the actual names and values are dependent on the server's foreign-data wrapper.</source>
          <target state="translated">この節はサーバのオプションを指定します。オプションは通常サーバの接続の詳細を定義しますが、実際の名前や値はサーバの外部データラッパーに依存します。</target>
        </trans-unit>
        <trans-unit id="553dd348cb64862c6f6c7f8e200b08ad63014f0b" translate="yes" xml:space="preserve">
          <source>This clause specifies the options of the user mapping. The options typically define the actual user name and password of the mapping. Option names must be unique. The allowed option names and values are specific to the server's foreign-data wrapper.</source>
          <target state="translated">この句は、ユーザー マッピングのオプションを指定します。オプションは通常、マッピングの実際のユーザー名とパスワードを定義します。オプション名は一意でなければなりません。許可されるオプション名と値は、サーバの外部データラッパーに固有のものです。</target>
        </trans-unit>
        <trans-unit id="36dc1042b746c18fc663603f39f06075d4e8bad1" translate="yes" xml:space="preserve">
          <source>This clause specifies the type of access method to define. Only &lt;code&gt;TABLE&lt;/code&gt; and &lt;code&gt;INDEX&lt;/code&gt; are supported at present.</source>
          <target state="translated">この句は、定義するアクセス方法のタイプを指定します。現在、 &lt;code&gt;TABLE&lt;/code&gt; と &lt;code&gt;INDEX&lt;/code&gt; のみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="d7c9f34db6e75577cfa3e83dbdc6bf919fff89f9" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the data produced by the query should be copied into the new table. If not, only the table structure is copied. The default is to copy the data.</source>
          <target state="translated">この句は、クエリによって生成されたデータを新しいテーブルにコピーするかどうかを指定します。コピーしない場合は、テーブル構造のみがコピーされます。デフォルトはデータをコピーすることです。</target>
        </trans-unit>
        <trans-unit id="3d31ed888cfee0dc08f120a78ae32fb1759c0983" translate="yes" xml:space="preserve">
          <source>This clause specifies whether or not the materialized view should be populated at creation time. If not, the materialized view will be flagged as unscannable and cannot be queried until &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; is used.</source>
          <target state="translated">この句は、作成時にマテリアライズドビューを生成するかどうかを指定します。そうでない場合、マテリアライズドビューにはスキャン不可のフラグが付けられ、 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; が使用されるまでクエリを実行できません。</target>
        </trans-unit>
        <trans-unit id="2dc6ac474993dbe5358c6881853df7fd2d4d9cd6" translate="yes" xml:space="preserve">
          <source>This column has a default expression or generation expression, in which case there will be a corresponding entry in the &lt;code&gt;pg_attrdef&lt;/code&gt; catalog that actually defines the expression. (Check &lt;code&gt;attgenerated&lt;/code&gt; to determine whether this is a default or a generation expression.)</source>
          <target state="translated">この列にはデフォルトの式または生成式があり、その場合、実際に式を定義する対応するエントリが &lt;code&gt;pg_attrdef&lt;/code&gt; カタログに存在します。（これがデフォルト式か生成式かを判別するには &lt;code&gt;attgenerated&lt;/code&gt; を確認してください。）</target>
        </trans-unit>
        <trans-unit id="c2b7e0b12551b63f994a3beb30fdb6c9912fa294" translate="yes" xml:space="preserve">
          <source>This column has a one element array containing the value used when the column is entirely missing from the row, as happens when the column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The value is only used when &lt;code&gt;atthasmissing&lt;/code&gt; is true. If there is no value the column is null.</source>
          <target state="translated">この列には、列が行から完全に欠落しているときに使用される値を含む1つの要素の配列があります。これは、行の作成後に列に不揮発性の &lt;code&gt;DEFAULT&lt;/code&gt; 値が追加された場合に発生します。この値は &lt;code&gt;atthasmissing&lt;/code&gt; がtrueの場合にのみ使用されます。値がない場合、列はnullです。</target>
        </trans-unit>
        <trans-unit id="35ff62cc51341f34bf3df6fe15f16224e9f0ba2a" translate="yes" xml:space="preserve">
          <source>This column has a value which is used where the column is entirely missing from the row, as happens when a column is added with a non-volatile &lt;code&gt;DEFAULT&lt;/code&gt; value after the row is created. The actual value used is stored in the &lt;code&gt;attmissingval&lt;/code&gt; column.</source>
          <target state="translated">この列には、行が作成された後に列が不揮発性 &lt;code&gt;DEFAULT&lt;/code&gt; 値で追加されたときに発生するように、列が行から完全に欠落している場合に使用される値があります。使用される実際の値は &lt;code&gt;attmissingval&lt;/code&gt; 列に格納されます。</target>
        </trans-unit>
        <trans-unit id="111e19fea7f4514da864aef92d2fd3831ac7425b" translate="yes" xml:space="preserve">
          <source>This column has been dropped and is no longer valid. A dropped column is still physically present in the table, but is ignored by the parser and so cannot be accessed via SQL.</source>
          <target state="translated">この列は削除されており、もはや有効ではありません。ドロップされたカラムはテーブル内に物理的に存在していますが、パーサによって無視されるため、SQLでアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="b598ea81d21dfda8a3cd60afd34a658bae3f5740" translate="yes" xml:space="preserve">
          <source>This column is defined locally in the relation. Note that a column can be locally defined and inherited simultaneously.</source>
          <target state="translated">このカラムは、リレーション内でローカルに定義されます。カラムはローカルに定義され、同時に継承することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="699529a66bde15ad8ad9a32706a761c81f8ea245" translate="yes" xml:space="preserve">
          <source>This command acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; ロックを取得します。</target>
        </trans-unit>
        <trans-unit id="ace2f59fb68bc1a8e1f61640a30167ef3925c24d" translate="yes" xml:space="preserve">
          <source>This command adds the &lt;code&gt;user.postgres&lt;/code&gt; project and sets the shared memory maximum for the &lt;code&gt;postgres&lt;/code&gt; user to 8GB, and takes effect the next time that user logs in, or when you restart PostgreSQL (not reload). The above assumes that PostgreSQL is run by the &lt;code&gt;postgres&lt;/code&gt; user in the &lt;code&gt;postgres&lt;/code&gt; group. No server reboot is required.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;user.postgres&lt;/code&gt; プロジェクトを追加し、 &lt;code&gt;postgres&lt;/code&gt; ユーザーの共有メモリの最大値を8GBに設定し、ユーザーが次回ログインしたとき、またはPostgreSQLを再起動したとき（リロードではない）に有効になります。上記は、PostgreSQLが &lt;code&gt;postgres&lt;/code&gt; グループの &lt;code&gt;postgres&lt;/code&gt; ユーザーによって実行されていることを前提としています。サーバーの再起動は必要ありません。</target>
        </trans-unit>
        <trans-unit id="7d0a3c8a461143dd6e79fdea4b574da1733f08aa" translate="yes" xml:space="preserve">
          <source>This command begins a new transaction block. If the isolation level, read/write mode, or deferrable mode is specified, the new transaction has those characteristics, as if &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; was executed. This is the same as the &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">このコマンドは、新しいトランザクションブロックを開始します。分離レベル、読み取り/書き込みモード、または遅延可能モードが指定されている場合、新しいトランザクションには、&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;が実行された場合と同様の特性があります。これは、&lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt;コマンドと同じです。</target>
        </trans-unit>
        <trans-unit id="62d4740f8d77efc3fe73e95e0f13203063c98ef5" translate="yes" xml:space="preserve">
          <source>This command can't be used to set &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;, nor parameters that are not allowed in &lt;code&gt;postgresql.conf&lt;/code&gt; (e.g., &lt;a href=&quot;runtime-config-preset&quot;&gt;preset options&lt;/a&gt;).</source>
          <target state="translated">このコマンドを使用して&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;を設定したり、 &lt;code&gt;postgresql.conf&lt;/code&gt; で許可されていないパラメーター（たとえば、&lt;a href=&quot;runtime-config-preset&quot;&gt;事前設定されたオプション&lt;/a&gt;）を設定したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="4e40f32b710aa4b5a2f3104aef12c4365c871f09" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is committed immediately.</source>
          <target state="translated">このコマンドは、トランザクション・ブロック内では実行できません。準備されたトランザクションは直ちにコミットされます。</target>
        </trans-unit>
        <trans-unit id="20b731d4b786265bb5e3ab49dc8d1a8760feab6b" translate="yes" xml:space="preserve">
          <source>This command cannot be executed inside a transaction block. The prepared transaction is rolled back immediately.</source>
          <target state="translated">このコマンドは、トランザクションブロック内では実行できません。準備されたトランザクションは直ちにロールバックされます。</target>
        </trans-unit>
        <trans-unit id="3a29d09c1029fd474b45e76bcdb5bbdf65bd3023" translate="yes" xml:space="preserve">
          <source>This command cannot be executed while connected to the target database. Thus, it might be more convenient to use the program &lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt; instead, which is a wrapper around this command.</source>
          <target state="translated">このコマンドは、ターゲットデータベースに接続している間は実行できません。したがって、代わりにこのコマンドのラッパーであるプログラム&lt;a href=&quot;app-dropdb&quot;&gt;dropdb&lt;/a&gt;を使用する方が便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="2e5d7b0191945449cf1438d09ec7519757af4913" translate="yes" xml:space="preserve">
          <source>This command complies with the behavior defined in the SQL standard, except for the limitation that, in PostgreSQL, it does not apply to &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints. Also, PostgreSQL checks non-deferrable uniqueness constraints immediately, not at end of statement as the standard would suggest.</source>
          <target state="translated">このコマンドは、PostgreSQLでは &lt;code&gt;NOT NULL&lt;/code&gt; および &lt;code&gt;CHECK&lt;/code&gt; 制約には適用されないという制限を除いて、SQL標準で定義されている動作に準拠しています。また、PostgreSQLは、標準で提案されているステートメントの最後ではなく、遅延できない一意性制約をすぐにチェックします。</target>
        </trans-unit>
        <trans-unit id="5b34603e56b93d743e26d620fe567201bf5d5d62" translate="yes" xml:space="preserve">
          <source>This command conforms to the ISO/IEC 9075-9 (SQL/MED), except that the standard only allows one foreign table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">このコマンドはISO / IEC 9075-9（SQL / MED）に準拠していますが、標準ではコマンドごとに1つの外部テーブルのみを削除でき、PostgreSQLの拡張である &lt;code&gt;IF EXISTS&lt;/code&gt; オプションは除きます。</target>
        </trans-unit>
        <trans-unit id="8f1f85c735f1b71966f80b17247cbce182c5909a" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except for the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">このコマンドは、PostgreSQLの拡張機能である &lt;code&gt;IF EXISTS&lt;/code&gt; オプションを除いて、SQL標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="468590b4d092b563617998d73f97b2171f1d8742" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;FROM&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">SQL標準に対するこのコマンドは、適合は、ことを除いて、 &lt;code&gt;FROM&lt;/code&gt; および &lt;code&gt;RETURNING&lt;/code&gt; 句はPostgreSQLの拡張です、として使用する機能です &lt;code&gt;WITH&lt;/code&gt; と &lt;code&gt;UPDATE&lt;/code&gt; が。</target>
        </trans-unit>
        <trans-unit id="bf1546d77c97dbe67b0ddd8982d22b8e55974688" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;RETURNING&lt;/code&gt; clauses are PostgreSQL extensions, as is the ability to use &lt;code&gt;WITH&lt;/code&gt; with &lt;code&gt;DELETE&lt;/code&gt;.</source>
          <target state="translated">このコマンドはSQL規格に準拠していますが、 &lt;code&gt;WITH&lt;/code&gt; を &lt;code&gt;DELETE&lt;/code&gt; で使用する機能と同様に、 &lt;code&gt;USING&lt;/code&gt; 句と &lt;code&gt;RETURNING&lt;/code&gt; 句はPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="681caf8270b9ecf7b205e0a60ad45b051b0e81dd" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one table to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">このコマンドは、SQL標準に準拠していますが、PostgreSQLの拡張機能である &lt;code&gt;IF EXISTS&lt;/code&gt; オプションを除き、コマンドごとに1つのテーブルのみを削除できる点が異なります。</target>
        </trans-unit>
        <trans-unit id="93af22491b168f8df3ca39363ea91881304542c1" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, except that the standard only allows one view to be dropped per command, and apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension.</source>
          <target state="translated">このコマンドはSQL標準に準拠していますが、標準ではコマンドごとに1つのビューのみを削除でき、PostgreSQLの拡張機能である &lt;code&gt;IF EXISTS&lt;/code&gt; オプションは除きます。</target>
        </trans-unit>
        <trans-unit id="4b31cc3350023fe9b74a561a1da0159f92b17624" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard, with these PostgreSQL extensions:</source>
          <target state="translated">このコマンドは、これらのPostgreSQL拡張により、SQL標準に準拠しています。</target>
        </trans-unit>
        <trans-unit id="dabcb37ca2e8b2f56629a8b0fd30a7a18fcbfc70" translate="yes" xml:space="preserve">
          <source>This command conforms to the SQL standard. The standard specifies that the key word &lt;code&gt;SAVEPOINT&lt;/code&gt; is mandatory, but PostgreSQL allows it to be omitted.</source>
          <target state="translated">このコマンドは、SQL標準に準拠しています。標準では、キーワード &lt;code&gt;SAVEPOINT&lt;/code&gt; は必須であると規定していますが、PostgreSQLでは省略可能です。</target>
        </trans-unit>
        <trans-unit id="f1c4c1beba4d7959f48fbfa14fde82110587427a" translate="yes" xml:space="preserve">
          <source>This command displays the execution plan that the PostgreSQL planner generates for the supplied statement. The execution plan shows how the table(s) referenced by the statement will be scanned &amp;mdash; by plain sequential scan, index scan, etc. &amp;mdash; and if multiple tables are referenced, what join algorithms will be used to bring together the required rows from each input table.</source>
          <target state="translated">このコマンドは、PostgreSQLプランナーが指定されたステートメントに対して生成する実行プランを表示します。実行プランは、ステートメントによって参照されるテーブルがどのようにスキャンされるか（プレーンシーケンシャルスキャン、インデックススキャンなど）を示します。複数のテーブルが参照されている場合、どの結合アルゴリズムを使用して、それぞれから必要な行をまとめます。入力テーブル。</target>
        </trans-unit>
        <trans-unit id="8488cb1889e76b5a66add5218ab2ee79544199b3" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; コマンドまたは &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; コマンドの形式で、指定された関数またはプロシージャの定義をフェッチして編集します。編集は &lt;code&gt;\edit&lt;/code&gt; と同じ方法で行われます。エディターが終了すると、更新されたコマンドはクエリバッファーで待機します。セミコロンまたは &lt;code&gt;\g&lt;/code&gt; を入力して送信するか、 &lt;code&gt;\r&lt;/code&gt; を入力してキャンセルします。</target>
        </trans-unit>
        <trans-unit id="bf69a2b293c399676b07c902a79f2f6947b772dc" translate="yes" xml:space="preserve">
          <source>This command fetches and edits the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. Editing is done in the same way as for &lt;code&gt;\edit&lt;/code&gt;. After the editor exits, the updated command waits in the query buffer; type semicolon or &lt;code&gt;\g&lt;/code&gt; to send it, or &lt;code&gt;\r&lt;/code&gt; to cancel.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; コマンドの形式で、名前付きビューの定義をフェッチして編集します。編集は &lt;code&gt;\edit&lt;/code&gt; と同じ方法で行われます。エディターが終了すると、更新されたコマンドはクエリバッファーで待機します。セミコロンまたは &lt;code&gt;\g&lt;/code&gt; を入力して送信するか、 &lt;code&gt;\r&lt;/code&gt; を入力してキャンセルします。</target>
        </trans-unit>
        <trans-unit id="de8b3b98128e1d7cfa1ced8632fee4a04f5b0692" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named function or procedure, in the form of a &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; コマンドまたは &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; コマンドの形式で、指定された関数またはプロシージャの定義をフェッチして表示します。定義は、 &lt;code&gt;\o&lt;/code&gt; によって設定された現在のクエリ出力チャネルに出力されます。</target>
        </trans-unit>
        <trans-unit id="0c81c5ecf842f5babd90a21465ed15920d3fbf2d" translate="yes" xml:space="preserve">
          <source>This command fetches and shows the definition of the named view, in the form of a &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; command. The definition is printed to the current query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">このコマンドは、名前付きビューの定義をフェッチして、 &lt;code&gt;CREATE OR REPLACE VIEW&lt;/code&gt; コマンドの形式で表示します。定義は、 &lt;code&gt;\o&lt;/code&gt; によって設定された現在のクエリ出力チャネルに出力されます。</target>
        </trans-unit>
        <trans-unit id="cd85d7e6ea3b73ffb02cb31a536b30a7bacab224" translate="yes" xml:space="preserve">
          <source>This command is a PostgreSQL extension present for historical reasons. &lt;code&gt;ROLLBACK&lt;/code&gt; is the equivalent standard SQL command.</source>
          <target state="translated">このコマンドは、歴史的な理由で存在するPostgreSQLの拡張機能です。 &lt;code&gt;ROLLBACK&lt;/code&gt; は同等の標準SQLコマンドです。</target>
        </trans-unit>
        <trans-unit id="2845ceac7504cffef12e499b57f5339a71e8d823" translate="yes" xml:space="preserve">
          <source>This command is functionally similar to &lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;, but it is preferred since it is less likely to be confused with other uses of the &lt;code&gt;SELECT INTO&lt;/code&gt; syntax. Furthermore, &lt;code&gt;CREATE TABLE AS&lt;/code&gt; offers a superset of the functionality offered by &lt;code&gt;SELECT INTO&lt;/code&gt;.</source>
          <target state="translated">このコマンドは機能的に&lt;a href=&quot;sql-selectinto&quot;&gt;SELECT INTO&lt;/a&gt;に似ていますが、 &lt;code&gt;SELECT INTO&lt;/code&gt; 構文の他の使用法と混同される可能性が低いため、このコマンドが推奨されます。さらに、 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; は &lt;code&gt;SELECT INTO&lt;/code&gt; が提供する機能のスーパーセットを提供します。</target>
        </trans-unit>
        <trans-unit id="1eebc2c2dfbb338f54847defda6bbbbd05da85aa" translate="yes" xml:space="preserve">
          <source>This command is identical to &lt;code&gt;\echo&lt;/code&gt; except that the output will be written to the query output channel, as set by &lt;code&gt;\o&lt;/code&gt;.</source>
          <target state="translated">このコマンドは &lt;code&gt;\echo&lt;/code&gt; と同じですが、出力は &lt;code&gt;\o&lt;/code&gt; によって設定されたクエリ出力チャネルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="c6b1eb8df7cef0a6e41f20fd61cbd76e26932fed" translate="yes" xml:space="preserve">
          <source>This command is similar to the corresponding command in the SQL standard, apart from the &lt;code&gt;IF EXISTS&lt;/code&gt; option, which is a PostgreSQL extension. But note that much of the &lt;code&gt;CREATE TYPE&lt;/code&gt; command and the data type extension mechanisms in PostgreSQL differ from the SQL standard.</source>
          <target state="translated">このコマンドは、PostgreSQLの拡張機能である &lt;code&gt;IF EXISTS&lt;/code&gt; オプションを除いて、SQL標準の対応するコマンドに似ています。ただし、PostgreSQL の &lt;code&gt;CREATE TYPE&lt;/code&gt; コマンドとデータ型拡張メカニズムの多くは、SQL標準とは異なります。</target>
        </trans-unit>
        <trans-unit id="74399205e4f06569f7b7a41f319f8abd6da5004d" translate="yes" xml:space="preserve">
          <source>This command is unrelated to the SQL command &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、SQLコマンド&lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt;とは関係ありません。</target>
        </trans-unit>
        <trans-unit id="017757db6d9507e6b7436f7a9ae4e2248893c3e8" translate="yes" xml:space="preserve">
          <source>This command loads a shared library file into the PostgreSQL server's address space. If the file has been loaded already, the command does nothing. Shared library files that contain C functions are automatically loaded whenever one of their functions is called. Therefore, an explicit &lt;code&gt;LOAD&lt;/code&gt; is usually only needed to load a library that modifies the server's behavior through &amp;ldquo;hooks&amp;rdquo; rather than providing a set of functions.</source>
          <target state="translated">このコマンドは、PostgreSQLサーバーのアドレス空間に共有ライブラリファイルをロードします。ファイルが既にロードされている場合、コマンドは何もしません。C関数を含む共有ライブラリファイルは、それらの関数の1つが呼び出されるたびに自動的にロードされます。したがって、明示的な &lt;code&gt;LOAD&lt;/code&gt; は通常、一連の関数を提供するのではなく、「フック」を介してサーバーの動作を変更するライブラリーをロードするためにのみ必要です。</target>
        </trans-unit>
        <trans-unit id="58fcb6c8246e8a6d76583723b04afe1b09a7d9c3" translate="yes" xml:space="preserve">
          <source>This command may be used to end SQL queries, taking the place of the terminating semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">このコマンドは、終了セミコロン（ &lt;code&gt;;&lt;/code&gt; ）の代わりにSQLクエリを終了するために使用できます。</target>
        </trans-unit>
        <trans-unit id="677d2975d49fcc1351e4405fb4dd24f72ba0639a" translate="yes" xml:space="preserve">
          <source>This command must be used inside a transaction block. Use &lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt; to start one.</source>
          <target state="translated">このコマンドは、トランザクションブロック内で使用する必要があります。&lt;a href=&quot;sql-begin&quot;&gt;BEGIN&lt;/a&gt;を使用して開始します。</target>
        </trans-unit>
        <trans-unit id="6b6b0df46bdea049004d95ff3514fc627c0bf758" translate="yes" xml:space="preserve">
          <source>This command must not be used when the server is running. &lt;code&gt;pg_resetwal&lt;/code&gt; will refuse to start up if it finds a server lock file in the data directory. If the server crashed then a lock file might have been left behind; in that case you can remove the lock file to allow &lt;code&gt;pg_resetwal&lt;/code&gt; to run. But before you do so, make doubly certain that there is no server process still alive.</source>
          <target state="translated">サーバーの実行中は、このコマンドを使用しないでください。 &lt;code&gt;pg_resetwal&lt;/code&gt; は、データディレクトリにサーバーロックファイルが見つかった場合、起動を拒否します。サーバーがクラッシュした場合は、ロックファイルが残っている可能性があります。その場合、 &lt;code&gt;pg_resetwal&lt;/code&gt; の実行を許可するためにロックファイルを削除できます。ただし、その前に、サーバープロセスがまだ生きていないことを二重に確認してください。</target>
        </trans-unit>
        <trans-unit id="71df21dcefbc6a0e13c7dad07c76dab173b26ca8" translate="yes" xml:space="preserve">
          <source>This command only alters the behavior of constraints within the current transaction. Issuing this outside of a transaction block emits a warning and otherwise has no effect.</source>
          <target state="translated">このコマンドは、現在のトランザクション内の制約の動作を変更するだけです。トランザクション・ブロックの外でこのコマンドを発行すると警告が表示され、それ以外の場合は何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="cd16c39418a0167a8c3018978b081238b82407a5" translate="yes" xml:space="preserve">
          <source>This command removes the procedural language &lt;code&gt;plsample&lt;/code&gt;:</source>
          <target state="translated">このコマンドは、手続き型言語 &lt;code&gt;plsample&lt;/code&gt; を削除します。</target>
        </trans-unit>
        <trans-unit id="13a5e5db6761174aa48d67b3836a7c44b067d9bd" translate="yes" xml:space="preserve">
          <source>This command removes the square root function:</source>
          <target state="translated">このコマンドは、平方根関数を削除します。</target>
        </trans-unit>
        <trans-unit id="c8da0e72c154580e68779b6eda81a32e4cdad2c2" translate="yes" xml:space="preserve">
          <source>This command sets options affecting the output of query result tables. &lt;code&gt;option&lt;/code&gt; indicates which option is to be set. The semantics of &lt;code&gt;value&lt;/code&gt; vary depending on the selected option. For some options, omitting &lt;code&gt;value&lt;/code&gt; causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting &lt;code&gt;value&lt;/code&gt; just results in the current setting being displayed.</source>
          <target state="translated">このコマンドは、クエリ結果テーブルの出力に影響を与えるオプションを設定します。 &lt;code&gt;option&lt;/code&gt; は、設定するオプションを示します。 &lt;code&gt;value&lt;/code&gt; の意味は、選択したオプションによって異なります。一部のオプションでは、特定のオプションで説明されているように、 &lt;code&gt;value&lt;/code&gt; を省略するとオプションがトグルまたは設定解除されます。そのような動作が言及されていない場合、 &lt;code&gt;value&lt;/code&gt; を省略すると、現在の設定が表示されます。</target>
        </trans-unit>
        <trans-unit id="55b80b7eaaaf7b41602e63f2f9f3e4efa523bee3" translate="yes" xml:space="preserve">
          <source>This command sets the current user identifier of the current SQL session to be &lt;code&gt;role_name&lt;/code&gt;. The role name can be written as either an identifier or a string literal. After &lt;code&gt;SET ROLE&lt;/code&gt;, permissions checking for SQL commands is carried out as though the named role were the one that had logged in originally.</source>
          <target state="translated">このコマンドは、現在のSQLセッションの現在のユーザー識別子を &lt;code&gt;role_name&lt;/code&gt; に設定します。ロール名は、識別子または文字列リテラルとして記述できます。 &lt;code&gt;SET ROLE&lt;/code&gt; の後、SQLコマンドの権限チェックは、指定されたロールが最初にログインしたロールであるかのように実行されます。</target>
        </trans-unit>
        <trans-unit id="f7712990490e001a7ee650bc9d46804ef39e8a64" translate="yes" xml:space="preserve">
          <source>This command sets the session user identifier and the current user identifier of the current SQL session to be &lt;code&gt;user_name&lt;/code&gt;. The user name can be written as either an identifier or a string literal. Using this command, it is possible, for example, to temporarily become an unprivileged user and later switch back to being a superuser.</source>
          <target state="translated">このコマンドは、現在のSQLセッションのセッションユーザー識別子と現在のユーザー識別子を &lt;code&gt;user_name&lt;/code&gt; に設定します。ユーザー名は、識別子または文字列リテラルとして記述できます。このコマンドを使用すると、たとえば、一時的に非特権ユーザーになり、後でスーパーユーザーに戻ることができます。</target>
        </trans-unit>
        <trans-unit id="7c9ce1414108a89726b8871ae0b54d84b052aa18" translate="yes" xml:space="preserve">
          <source>This command will fail if any of &lt;code&gt;hstore&lt;/code&gt;'s objects are in use in the database, for example if any tables have columns of the &lt;code&gt;hstore&lt;/code&gt; type. Add the &lt;code&gt;CASCADE&lt;/code&gt; option to forcibly remove those dependent objects as well.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;hstore&lt;/code&gt; のオブジェクトのいずれかがデータベースで使用されている場合、たとえば、 &lt;code&gt;hstore&lt;/code&gt; タイプの列を持つテーブルがある場合は失敗します。 &lt;code&gt;CASCADE&lt;/code&gt; オプションを追加して、これらの依存オブジェクトも強制的に削除します。</target>
        </trans-unit>
        <trans-unit id="6b862ff106f276a9375de8c6aab656803f7a4efb" translate="yes" xml:space="preserve">
          <source>This command will free storage associated with the materialized view &lt;code&gt;annual_statistics_basis&lt;/code&gt; and leave it in an unscannable state:</source>
          <target state="translated">このコマンドは、マテリアライズドビュー &lt;code&gt;annual_statistics_basis&lt;/code&gt; 関連付けられたストレージを解放し、スキャン不可能な状態のままにします。</target>
        </trans-unit>
        <trans-unit id="6c9c73632173fe8b7637783ced8159d79d16ea65" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that reference the configuration in &lt;code&gt;to_tsvector&lt;/code&gt; calls. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the text search configuration.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 呼び出しの構成を参照する既存のインデックスがある場合、このコマンドは成功しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加して、そのようなインデックスをテキスト検索構成とともにドロップします。</target>
        </trans-unit>
        <trans-unit id="9b7e8e631e47d7a2498f014c562d775f4aa922d4" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use operator classes within the family. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator family.</source>
          <target state="translated">ファミリ内の演算子クラスを使用する既存のインデックスがある場合、このコマンドは成功しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加して、このようなインデックスを演算子ファミリとともに削除します。</target>
        </trans-unit>
        <trans-unit id="e344bd47bfc7344c009cae8df60f4f2d04ad7fee" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing indexes that use the operator class. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such indexes along with the operator class.</source>
          <target state="translated">演算子クラスを使用する既存のインデックスがある場合、このコマンドは成功しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加して、演算子クラスとともにそのようなインデックスを削除します。</target>
        </trans-unit>
        <trans-unit id="0a073ad25e0df8057b772f9939bb92486f83b429" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the dictionary. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the dictionary.</source>
          <target state="translated">辞書を使用する既存のテキスト検索構成がある場合、このコマンドは成功しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加して、そのような構成を辞書とともにドロップします。</target>
        </trans-unit>
        <trans-unit id="98b8a535bcfac2a0dbcd407ddbfe551b50e04749" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search configurations that use the parser. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such configurations along with the parser.</source>
          <target state="translated">パーサーを使用する既存のテキスト検索構成がある場合、このコマンドは成功しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加して、パーサーとともにそのような構成をドロップします。</target>
        </trans-unit>
        <trans-unit id="9140e2324a0907c1e9782d65b5e3ea71a6d9655e" translate="yes" xml:space="preserve">
          <source>This command will not succeed if there are any existing text search dictionaries that use the template. Add &lt;code&gt;CASCADE&lt;/code&gt; to drop such dictionaries along with the template.</source>
          <target state="translated">テンプレートを使用する既存のテキスト検索辞書がある場合、このコマンドは成功しません。 &lt;code&gt;CASCADE&lt;/code&gt; を追加して、そのような辞書をテンプレートとともにドロップします。</target>
        </trans-unit>
        <trans-unit id="17f6112c2268ba0c9663f367e376afa3756d596b" translate="yes" xml:space="preserve">
          <source>This command will perform archiving when &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; exists, and otherwise silently return zero exit status (allowing PostgreSQL to recycle the unwanted WAL file).</source>
          <target state="translated">このコマンドは &lt;code&gt;/var/lib/pgsql/backup_in_progress&lt;/code&gt; が存在する場合にアーカイブを実行し、それ以外の場合はゼロの終了ステータスをサイレントに返します（PostgreSQLが不要なWALファイルをリサイクルできるようにします）。</target>
        </trans-unit>
        <trans-unit id="08ffbb1ab36d371eef7c290033c779142e12ec33" translate="yes" xml:space="preserve">
          <source>This command will remove the index &lt;code&gt;title_idx&lt;/code&gt;:</source>
          <target state="translated">このコマンドは、インデックス &lt;code&gt;title_idx&lt;/code&gt; を削除します。</target>
        </trans-unit>
        <trans-unit id="2078fd2a1ddd7b0f72d80b8a3d0cc32c019e717f" translate="yes" xml:space="preserve">
          <source>This command will remove the materialized view called &lt;code&gt;order_summary&lt;/code&gt;:</source>
          <target state="translated">このコマンドは、 &lt;code&gt;order_summary&lt;/code&gt; というマテリアライズドビューを削除します。</target>
        </trans-unit>
        <trans-unit id="a242c77a8ccd56ddace9304e1ec3ea12442c9d59" translate="yes" xml:space="preserve">
          <source>This command will remove the view called &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">このコマンドは、 &lt;code&gt;kinds&lt;/code&gt; という名前のビューを削除します。</target>
        </trans-unit>
        <trans-unit id="0d7ac7005486ff5a82c81e39d2a6985dcac07fb2" translate="yes" xml:space="preserve">
          <source>This command will replace the contents of the materialized view called &lt;code&gt;order_summary&lt;/code&gt; using the query from the materialized view's definition, and leave it in a scannable state:</source>
          <target state="translated">このコマンドは、マテリアライズドビューの定義からのクエリを使用して、 &lt;code&gt;order_summary&lt;/code&gt; というマテリアライズドビューのコンテンツを置き換え、スキャン可能な状態のままにします。</target>
        </trans-unit>
        <trans-unit id="21fb41393a4eea96218c35f555df78b95eb06e38" translate="yes" xml:space="preserve">
          <source>This command will return a sample of 100 rows from the table &lt;code&gt;my_table&lt;/code&gt; (unless the table does not have 100 visible rows, in which case all its rows are returned).</source>
          <target state="translated">このコマンドは、テーブル &lt;code&gt;my_table&lt;/code&gt; から100行のサンプルを返します（テーブルに100行の可視行がない場合は、そのすべての行が返されます）。</target>
        </trans-unit>
        <trans-unit id="01ae94e8662537ac6716b276145364c5f4fb1046" translate="yes" xml:space="preserve">
          <source>This command will return as large a sample of &lt;code&gt;my_table&lt;/code&gt; as it can read in 1 second (1000 milliseconds). Of course, if the whole table can be read in under 1 second, all its rows will be returned.</source>
          <target state="translated">このコマンドは、1秒（1000ミリ秒）で読み取ることができる &lt;code&gt;my_table&lt;/code&gt; サンプルを返します。もちろん、テーブル全体が1秒未満で読み取れる場合は、そのすべての行が返されます。</target>
        </trans-unit>
        <trans-unit id="8973f1428f19cf5f51d43ae902ba0ec839e24687" translate="yes" xml:space="preserve">
          <source>This command will work independent of whether &lt;code&gt;foo&lt;/code&gt; is an aggregate, function, or procedure.</source>
          <target state="translated">このコマンドは、 &lt;code&gt;foo&lt;/code&gt; が集合体、関数、またはプロシージャであるかどうかに関係なく機能します。</target>
        </trans-unit>
        <trans-unit id="8ac0fa233aac6a123e11329c2972c3833b6e69d2" translate="yes" xml:space="preserve">
          <source>This confirms there are 100 distinct combinations in the two columns, and all of them are about equally likely (1% frequency for each one). The base frequency is the frequency computed from per-column statistics, as if there were no multi-column statistics. Had there been any null values in either of the columns, this would be identified in the &lt;code&gt;nulls&lt;/code&gt; column.</source>
          <target state="translated">これにより、2つの列に100の異なる組み合わせがあり、それらのすべての可能性がほぼ同じであることがわかります（それぞれ1％の頻度）。基本頻度は、あたかも複数列の統計がないかのように、列ごとの統計から計算された頻度です。いずれかの列にnull値があった場合、これは &lt;code&gt;nulls&lt;/code&gt; 列で識別されます。</target>
        </trans-unit>
        <trans-unit id="a75759d2d2d52e1dc2865efa8cf2fb6090b3f128" translate="yes" xml:space="preserve">
          <source>This constant is a two-dimensional, 3-by-3 array consisting of three subarrays of integers.</source>
          <target state="translated">この定数は、整数の3つのサブアレイからなる2次元の3×3の配列である。</target>
        </trans-unit>
        <trans-unit id="a1d39be831b881f732286b6571d19294d43d84bf" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. It is a non-inheritable constraint.</source>
          <target state="translated">この制約は、関係に対して局所的に定義されます。これは非継承可能な制約です。</target>
        </trans-unit>
        <trans-unit id="ee0fafaed69e2c50c035d4176a4d38521e63e5d6" translate="yes" xml:space="preserve">
          <source>This constraint is defined locally for the relation. Note that a constraint can be locally defined and inherited simultaneously.</source>
          <target state="translated">この制約は、関係に対してローカルに定義されます。制約はローカルに定義され、同時に継承されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="677137c6fdb574fcaee9a2f495faececc7604ba8" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will either be true or false, never null.</source>
          <target state="translated">この構成は &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 行比較に似ていますが、null入力に対してnullを生成しません。代わりに、ヌル値は非ヌル値と等しくない（区別される）と見なされ、2つのヌルは等しい（区別されない）と見なされます。したがって、結果はtrueまたはfalseのいずれかとなり、nullになることはありません。</target>
        </trans-unit>
        <trans-unit id="1020bde7bf73c7df63ce8acf0bfdb90bb93b7fcb" translate="yes" xml:space="preserve">
          <source>This construct is similar to a &lt;code&gt;=&lt;/code&gt; row comparison, but it does not yield null for null inputs. Instead, any null value is considered unequal to (distinct from) any non-null value, and any two nulls are considered equal (not distinct). Thus the result will always be either true or false, never null.</source>
          <target state="translated">この構成は &lt;code&gt;=&lt;/code&gt; 行比較に似ていますが、null入力に対してnullを生成しません。代わりに、ヌル値は非ヌル値と等しくない（区別される）と見なされ、2つのヌルは等しい（区別されない）と見なされます。したがって、結果は常にtrueまたはfalseのいずれかであり、nullになることはありません。</target>
        </trans-unit>
        <trans-unit id="33a306bcfd5b03d8e762816f623417a83fd23a93" translate="yes" xml:space="preserve">
          <source>This controls how many pages or tuples of a single relation can be predicate-locked before the lock is promoted to covering the whole relation. Values greater than or equal to zero mean an absolute limit, while negative values mean &lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transaction&lt;/a&gt; divided by the absolute value of this setting. The default is -2, which keeps the behavior from previous versions of PostgreSQL. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">これは、ロックがリレーション全体をカバーするようにプロモートされる前に、単一のリレーションのページまたはタプルを述語ロックできる数を制御します。ゼロ以上の値は絶対制限を意味し、負の値はこの設定の絶対値で割った&lt;a href=&quot;runtime-config-locks#GUC-MAX-PRED-LOCKS-PER-TRANSACTION&quot;&gt;max_pred_locks_per_transactionを&lt;/a&gt;意味します。デフォルトは-2で、以前のバージョンのPostgreSQLの動作を維持します。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="37486631dcaede39c55161d228505d69d73e3e22" translate="yes" xml:space="preserve">
          <source>This controls how many rows on a single page can be predicate-locked before the lock is promoted to covering the whole page. The default is 2. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">これは、ロックがページ全体をカバーするようにプロモートされる前に、単一ページの述部ロックできる行数を制御します。デフォルトは2です。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="b8a7a6bb04de3147a65fe3e69e114d351a95bdd3" translate="yes" xml:space="preserve">
          <source>This controls whether a quote mark can be represented by &lt;code&gt;\'&lt;/code&gt; in a string literal. The preferred, SQL-standard way to represent a quote mark is by doubling it (&lt;code&gt;''&lt;/code&gt;) but PostgreSQL has historically also accepted &lt;code&gt;\'&lt;/code&gt;. However, use of &lt;code&gt;\'&lt;/code&gt; creates security risks because in some client character set encodings, there are multibyte characters in which the last byte is numerically equivalent to ASCII &lt;code&gt;\&lt;/code&gt;. If client-side code does escaping incorrectly then a SQL-injection attack is possible. This risk can be prevented by making the server reject queries in which a quote mark appears to be escaped by a backslash. The allowed values of &lt;code&gt;backslash_quote&lt;/code&gt; are &lt;code&gt;on&lt;/code&gt; (allow &lt;code&gt;\'&lt;/code&gt; always), &lt;code&gt;off&lt;/code&gt; (reject always), and &lt;code&gt;safe_encoding&lt;/code&gt; (allow only if client encoding does not allow ASCII &lt;code&gt;\&lt;/code&gt; within a multibyte character). &lt;code&gt;safe_encoding&lt;/code&gt; is the default setting.</source>
          <target state="translated">これは、引用符を文字列リテラルの &lt;code&gt;\'&lt;/code&gt; で表すことができるかどうかを制御します。引用符を表すための推奨されるSQL標準の方法は二重引用符（ &lt;code&gt;''&lt;/code&gt; ）ですが、PostgreSQLは歴史的に &lt;code&gt;\'&lt;/code&gt; も受け入れています。ただし、 &lt;code&gt;\'&lt;/code&gt; を使用すると、セキュリティリスクが生じます。これは、一部のクライアント文字セットエンコーディングでは、最後のバイトがASCII &lt;code&gt;\&lt;/code&gt; と数値的に等しいマルチバイト文字があるためです。クライアント側のコードが正しくエスケープしない場合、SQLインジェクション攻撃が可能です。このリスクは、引用符がバックスラッシュでエスケープされているように見えるクエリをサーバーに拒否させることで防ぐことができます。 &lt;code&gt;backslash_quote&lt;/code&gt; の許容値は &lt;code&gt;on&lt;/code&gt; （allow &lt;code&gt;\'&lt;/code&gt; always）、 &lt;code&gt;off&lt;/code&gt; （常に拒否）、および &lt;code&gt;safe_encoding&lt;/code&gt; （クライアントのエンコーディングでマルチバイト文字内のASCII &lt;code&gt;\&lt;/code&gt; が許可されていない場合にのみ許可）。 &lt;code&gt;safe_encoding&lt;/code&gt; がデフォルト設定です。</target>
        </trans-unit>
        <trans-unit id="90ccb11174fcbc5e0dcaecf5ce4057bc44c37e08" translate="yes" xml:space="preserve">
          <source>This controls whether ordinary string literals (&lt;code&gt;'...'&lt;/code&gt;) treat backslashes literally, as specified in the SQL standard. Beginning in PostgreSQL 9.1, the default is &lt;code&gt;on&lt;/code&gt; (prior releases defaulted to &lt;code&gt;off&lt;/code&gt;). Applications can check this parameter to determine how string literals will be processed. The presence of this parameter can also be taken as an indication that the escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;) is supported. Escape string syntax (&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;) should be used if an application desires backslashes to be treated as escape characters.</source>
          <target state="translated">これは、SQL標準で指定されているように、通常の文字列リテラル（ &lt;code&gt;'...'&lt;/code&gt; ）がバックスラッシュを文字どおりに処理するかどうかを制御します。 PostgreSQL 9.1以降、デフォルトは &lt;code&gt;on&lt;/code&gt; です（以前のリリースではデフォルトで &lt;code&gt;off&lt;/code&gt; になっています）。アプリケーションはこのパラメーターをチェックして、文字列リテラルの処理方法を決定できます。このパラメーターの存在は、エスケープ文字列構文（ &lt;code&gt;E'...'&lt;/code&gt; ）がサポートされていることを示すものと見なすこともできます。アプリケーションでバックスラッシュをエスケープ文字として扱う必要がある場合は、エスケープ文字列構文（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;4.1.2.2項&lt;/a&gt;）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="04ce8a3710d0e73d6eb9a44e5b7e7596e3b6ada8" translate="yes" xml:space="preserve">
          <source>This controls whether the array input parser recognizes unquoted &lt;code&gt;NULL&lt;/code&gt; as specifying a null array element. By default, this is &lt;code&gt;on&lt;/code&gt;, allowing array values containing null values to be entered. However, PostgreSQL versions before 8.2 did not support null values in arrays, and therefore would treat &lt;code&gt;NULL&lt;/code&gt; as specifying a normal array element with the string value &amp;ldquo;NULL&amp;rdquo;. For backward compatibility with applications that require the old behavior, this variable can be turned &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">これは、配列入力パーサーが引用符で囲まれていない &lt;code&gt;NULL&lt;/code&gt; をnull配列要素を指定するものとして認識するかどうかを制御します。デフォルトでは、これは &lt;code&gt;on&lt;/code&gt; であり、null値を含む配列値を入力できます。ただし、8.2より前のバージョンのPostgreSQLは配列でnull値をサポートしていなかったため、 &lt;code&gt;NULL&lt;/code&gt; を文字列値「NULL」の通常の配列要素を指定するものとして扱います。以前の動作を必要とするアプリケーションとの下位互換性を保つために、この変数を &lt;code&gt;off&lt;/code&gt; することができます。</target>
        </trans-unit>
        <trans-unit id="a334bdaf5d7adfdeb7bdd6cc764b677eb1d1fc0d" translate="yes" xml:space="preserve">
          <source>This controls whether the constraint can be deferred. A constraint that is not deferrable will be checked immediately after every command. Checking of constraints that are deferrable can be postponed until the end of the transaction (using the &lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt; command). &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; is the default. Currently, only &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;EXCLUDE&lt;/code&gt;, and &lt;code&gt;REFERENCES&lt;/code&gt; (foreign key) constraints accept this clause. &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints are not deferrable. Note that deferrable constraints cannot be used as conflict arbitrators in an &lt;code&gt;INSERT&lt;/code&gt; statement that includes an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause.</source>
          <target state="translated">これは、制約を延期できるかどうかを制御します。延期できない制約は、すべてのコマンドの直後にチェックされます。遅延可能な制約のチェックは、トランザクションが終了するまで延期できます（&lt;a href=&quot;sql-set-constraints&quot;&gt;SET CONSTRAINTS&lt;/a&gt;コマンドを使用）。 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; がデフォルトです。現在、 &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 、 &lt;code&gt;EXCLUDE&lt;/code&gt; 、および &lt;code&gt;REFERENCES&lt;/code&gt; （外部キー）制約のみがこの句を受け入れます。 &lt;code&gt;NOT NULL&lt;/code&gt; および &lt;code&gt;CHECK&lt;/code&gt; 制約は延期できません。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; を含む &lt;code&gt;INSERT&lt;/code&gt; ステートメントでは、遅延可能な制約を競合アービトレーターとして使用できないことに注意してください。 句。</target>
        </trans-unit>
        <trans-unit id="1918927d29af63f959f031de4a1383381d5530a7" translate="yes" xml:space="preserve">
          <source>This creates a security hazard when calling, via qualified name &lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;, a variadic function found in a schema that permits untrusted users to create objects. A malicious user can take control and execute arbitrary SQL functions as though you executed them. Substitute a call bearing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword, which bypasses this hazard. Calls populating &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; parameters often have no equivalent formulation containing the &lt;code&gt;VARIADIC&lt;/code&gt; keyword. To issue those calls safely, the function's schema must permit only trusted users to create objects.</source>
          <target state="translated">これは、信頼されていないユーザーがオブジェクトを作成することを許可するスキーマにある可変関数を修飾名&lt;a href=&quot;#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup id=&quot;FUNC-QUALIFIED-SECURITY&quot;&gt;[10]&lt;/sup&gt;&lt;/a&gt;を介して呼び出すときに、セキュリティ上の危険をもたらします。悪意のあるユーザーが、任意のSQL関数を実行しているかのように制御および実行できます。このハザードを &lt;code&gt;VARIADIC&lt;/code&gt; するVARIADICキーワードを含むコールに置き換えます。多くの場合 &lt;code&gt;VARIADIC &quot;any&quot;&lt;/code&gt; パラメーターを設定する呼び出しには、 &lt;code&gt;VARIADIC&lt;/code&gt; キーワードを含む同等の公式がありません。これらの呼び出しを安全に発行するには、関数のスキーマで、信頼できるユーザーのみがオブジェクトを作成できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="d12540189cdbd640895d38788f65f9fbba1d76fa" translate="yes" xml:space="preserve">
          <source>This creates a table named &lt;code&gt;my_first_table&lt;/code&gt; with two columns. The first column is named &lt;code&gt;first_column&lt;/code&gt; and has a data type of &lt;code&gt;text&lt;/code&gt;; the second column has the name &lt;code&gt;second_column&lt;/code&gt; and the type &lt;code&gt;integer&lt;/code&gt;. The table and column names follow the identifier syntax explained in &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;Section 4.1.1&lt;/a&gt;. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.</source>
          <target state="translated">これにより、2つの列を持つ &lt;code&gt;my_first_table&lt;/code&gt; という名前のテーブルが作成されます。最初の列の名前は &lt;code&gt;first_column&lt;/code&gt; で、データ型は &lt;code&gt;text&lt;/code&gt; です。 2番目の列の名前は &lt;code&gt;second_column&lt;/code&gt; で、型は &lt;code&gt;integer&lt;/code&gt; です。テーブル名と列名は、&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-IDENTIFIERS&quot;&gt;セクション4.1.1で&lt;/a&gt;説明されている識別子構文に従います。タイプ名は通常識別子でもありますが、いくつかの例外があります。列リストはコンマで区切られ、括弧で囲まれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2df112a8a7b40124ef90c403fdef2c5ff1577746" translate="yes" xml:space="preserve">
          <source>This creates an availability hazard when calling, via qualified name&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;, any function found in a schema that permits untrusted users to create objects. A malicious user can create a function with the name of an existing function, replicating that function's parameters and appending novel parameters having default values. This precludes new calls to the original function. To forestall this hazard, place functions in schemas that permit only trusted users to create objects.</source>
          <target state="translated">これは、信頼されていないユーザーがオブジェクトを作成することを許可するスキーマで見つかった関数を、修飾名&lt;a href=&quot;typeconv-func#ftn.FUNC-QUALIFIED-SECURITY&quot;&gt;&lt;sup&gt;[10]&lt;/sup&gt;&lt;/a&gt;を介して呼び出すときに、可用性の危険を引き起こします。悪意のあるユーザーは、既存の関数の名前で関数を作成し、その関数のパラメーターを複製して、デフォルト値を持つ新しいパラメーターを追加することができます。これにより、元の関数を新たに呼び出すことができなくなります。この危険を未然に防ぐには、スキーマに関数を配置して、信頼できるユーザーだけがオブジェクトを作成できるようにします。</target>
        </trans-unit>
        <trans-unit id="5fd08e31876bb0659f97fc74e6e81b5de962b395" translate="yes" xml:space="preserve">
          <source>This creates registry entries used by the event viewer, under the default event source named &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;PostgreSQL&lt;/code&gt; という名前のデフォルトのイベントソースの下に、イベントビューアで使用されるレジストリエントリが作成されます。</target>
        </trans-unit>
        <trans-unit id="a2f685ce47d5796c5b17ed2dc2e9f2a95a1be4cb" translate="yes" xml:space="preserve">
          <source>This creates the scripts and compiles the C files containing user-defined functions and types. Then, to start the tutorial, do the following:</source>
          <target state="translated">これにより、スクリプトが作成され、ユーザー定義の関数と型を含むCファイルがコンパイルされます。次に、チュートリアルを開始するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="d9b31e3f2055cca38cc6b689ae9fad52cab29160" translate="yes" xml:space="preserve">
          <source>This design allows for both backwards-compatible header additions (add header extension chunks, or set low-order flag bits) and non-backwards-compatible changes (set high-order flag bits to signal such changes, and add supporting data to the extension area if needed).</source>
          <target state="translated">この設計では、後方互換性のあるヘッダの追加(ヘッダ拡張チャンクの追加、または低次のフラグビットの設定)と、後方互換性のない変更(そのような変更を知らせるために高次のフラグビットを設定し、必要に応じて拡張領域にサポートデータを追加する)の両方を可能にします。</target>
        </trans-unit>
        <trans-unit id="d1507a2d26ed6cd13d8f06661be29be45050cd21" translate="yes" xml:space="preserve">
          <source>This dictionary template is used to create dictionaries that replace a word with a synonym. Phrases are not supported (use the thesaurus template (&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;Section 12.6.4&lt;/a&gt;) for that). A synonym dictionary can be used to overcome linguistic problems, for example, to prevent an English stemmer dictionary from reducing the word &amp;ldquo;Paris&amp;rdquo; to &amp;ldquo;pari&amp;rdquo;. It is enough to have a &lt;code&gt;Paris paris&lt;/code&gt; line in the synonym dictionary and put it before the &lt;code&gt;english_stem&lt;/code&gt; dictionary. For example:</source>
          <target state="translated">この辞書テンプレートは、単語を類義語に置き換える辞書を作成するために使用されます。フレーズはサポートされていません（そのためには、シソーラステンプレート（&lt;a href=&quot;textsearch-dictionaries#TEXTSEARCH-THESAURUS&quot;&gt;セクション12.6.4&lt;/a&gt;）を使用してください）。同義語辞書は、言語の問題を克服するために使用できます。たとえば、英語のステマー辞書が「パリ」という単語を「パリ」に減らすのを防ぐことができます。同義語辞書に &lt;code&gt;Paris paris&lt;/code&gt; 行を入れて、 &lt;code&gt;english_stem&lt;/code&gt; 辞書の前に置くだけで十分です。例えば：</target>
        </trans-unit>
        <trans-unit id="dfab7a227af58e60167bfee0ac87d5907b3ad3ee" translate="yes" xml:space="preserve">
          <source>This document answers frequently asked questions about SELinux. It focuses primarily on Fedora, but is not limited to Fedora.</source>
          <target state="translated">このドキュメントは SELinux に関するよくある質問に答えています。主に Fedora に焦点を当てていますが、Fedora に限定されるものではありません。</target>
        </trans-unit>
        <trans-unit id="64f99dd7f4a8868a1752a291c897889c1028116d" translate="yes" xml:space="preserve">
          <source>This document provides a wide spectrum of knowledge to administer SELinux on your systems. It focuses primarily on Red Hat operating systems, but is not limited to them.</source>
          <target state="translated">このドキュメントは、システム上で SELinux を管理するための幅広い知識を提供します。主に Red Hat オペレーティングシステムに焦点を当てていますが、これらに限定されるものではありません。</target>
        </trans-unit>
        <trans-unit id="d69a24fba08d14e58aa301ec18364f049dd9f435" translate="yes" xml:space="preserve">
          <source>This does not prevent cleanup of dead rows which have reached the age specified by &lt;code&gt;old_snapshot_threshold&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;old_snapshot_threshold&lt;/code&gt; で指定された経過時間に達したデッド行のクリーンアップを妨げません。</target>
        </trans-unit>
        <trans-unit id="34a33c8e067844a10adc4d1ec87dc8f9bed7f940" translate="yes" xml:space="preserve">
          <source>This does not work because &lt;code&gt;integer&lt;/code&gt; does not have an implicit cast to &lt;code&gt;text&lt;/code&gt;. An explicit cast will work, however:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; は暗黙的に &lt;code&gt;text&lt;/code&gt; にキャストされないため、これは機能しません。ただし、明示的なキャストは機能します。</target>
        </trans-unit>
        <trans-unit id="f8a11325d581fd69da8d48499eb1dc3e0e55ab89" translate="yes" xml:space="preserve">
          <source>This equivalence between functional notation and field notation makes it possible to use functions on composite types to implement &amp;ldquo;computed fields&amp;rdquo;.   An application using the last query above wouldn't need to be directly aware that &lt;code&gt;somefunc&lt;/code&gt; isn't a real column of the table.</source>
          <target state="translated">関数表記とフィールド表記の同等性により、複合型の関数を使用して「計算フィールド」を実装することが可能になります。上記の最後のクエリを使用するアプリケーションは、 &lt;code&gt;somefunc&lt;/code&gt; がテーブルの実際の列ではないことを直接認識する必要はありません。</target>
        </trans-unit>
        <trans-unit id="cf34fbb91a15c4b2d08b406f2026ab198cd22a33" translate="yes" xml:space="preserve">
          <source>This evaluates query on document and wraps the result in XML tags. If the result is multivalued, the output will look like:</source>
          <target state="translated">これは、ドキュメントに対するクエリを評価し、その結果をXMLタグでラップします。結果が多値の場合、出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="15ced5262cfea0d7c224d2d14022b915ded0c9bb" translate="yes" xml:space="preserve">
          <source>This example creates a composite type and uses it in a function definition:</source>
          <target state="translated">この例では、複合型を作成し、関数定義で使用します。</target>
        </trans-unit>
        <trans-unit id="fd20b024051cecf699f47d6601ef377cbbceb783" translate="yes" xml:space="preserve">
          <source>This example creates a large object type and uses it in a table definition:</source>
          <target state="translated">この例では、大きなオブジェクト型を作成し、それをテーブル定義で使用します。</target>
        </trans-unit>
        <trans-unit id="81988155ae08cfd1bb03bda3f7e767cd1d1e7982" translate="yes" xml:space="preserve">
          <source>This example creates a range type:</source>
          <target state="translated">この例では、範囲型を作成します。</target>
        </trans-unit>
        <trans-unit id="29a86563a51e3572dd14a9d9255eda3ebb2201cc" translate="yes" xml:space="preserve">
          <source>This example creates an enumerated type and uses it in a table definition:</source>
          <target state="translated">この例では、列挙型を作成し、それをテーブル定義で使用します。</target>
        </trans-unit>
        <trans-unit id="e15c416b1eb4a6e0ac422253fe9d7c571e4e1d98" translate="yes" xml:space="preserve">
          <source>This example creates the &lt;code&gt;us_postal_code&lt;/code&gt; data type and then uses the type in a table definition. A regular expression test is used to verify that the value looks like a valid US postal code:</source>
          <target state="translated">この例では、 &lt;code&gt;us_postal_code&lt;/code&gt; データ型を作成し、その型をテーブル定義で使用します。正規表現テストを使用して、値が有効な米国の郵便番号のように見えることを確認します。</target>
        </trans-unit>
        <trans-unit id="824e6c2d218cfa4fc262bbf54ecefd33c7e0d65c" translate="yes" xml:space="preserve">
          <source>This example creates the base data type &lt;code&gt;box&lt;/code&gt; and then uses the type in a table definition:</source>
          <target state="translated">この例では、基本データ型 &lt;code&gt;box&lt;/code&gt; を作成し、その型をテーブル定義で使用します。</target>
        </trans-unit>
        <trans-unit id="434cf5265b6621f51d3d3b20b1a695bea28ca57d" translate="yes" xml:space="preserve">
          <source>This example for Unix systems sets the locale to Swedish (&lt;code&gt;sv&lt;/code&gt;) as spoken in Sweden (&lt;code&gt;SE&lt;/code&gt;). Other possibilities might include &lt;code&gt;en_US&lt;/code&gt; (U.S. English) and &lt;code&gt;fr_CA&lt;/code&gt; (French Canadian). If more than one character set can be used for a locale then the specifications can take the form &lt;code&gt;language_territory.codeset&lt;/code&gt;. For example, &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; represents the French language (fr) as spoken in Belgium (BE), with a UTF-8 character set encoding.</source>
          <target state="translated">このUnixシステムの例では、スウェーデン（ &lt;code&gt;SE&lt;/code&gt; ）で話されているようにロケールをスウェーデン（ &lt;code&gt;sv&lt;/code&gt; ）に設定します。その他の可能性としては、 &lt;code&gt;en_US&lt;/code&gt; （米国英語）や &lt;code&gt;fr_CA&lt;/code&gt; （フランス系カナダ人）などがあります。ロケールに複数の文字セットを使用できる場合、仕様は &lt;code&gt;language_territory.codeset&lt;/code&gt; の形式になります。たとえば、 &lt;code&gt;fr_BE.UTF-8&lt;/code&gt; はベルギー（BE）で話されているフランス語（fr）をUTF-8文字セットエンコーディングで表します。</target>
        </trans-unit>
        <trans-unit id="5b2c48d8838d3c1575e17a1f1c1bf4b1c54be443" translate="yes" xml:space="preserve">
          <source>This example inserts into array columns:</source>
          <target state="translated">この例では、配列の列に挿入します。</target>
        </trans-unit>
        <trans-unit id="42fa4c592cce0c22be8f54fb9056c02e69ce0496" translate="yes" xml:space="preserve">
          <source>This example inserts some rows into table &lt;code&gt;films&lt;/code&gt; from a table &lt;code&gt;tmp_films&lt;/code&gt; with the same column layout as &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">この例では、 &lt;code&gt;films&lt;/code&gt; と同じ列レイアウトを持つテーブル &lt;code&gt;tmp_films&lt;/code&gt; からテーブル &lt;code&gt;films&lt;/code&gt; いくつかの行を挿入します。</target>
        </trans-unit>
        <trans-unit id="a463d9dae9db43b670ea9503d31a0e368fa4ee70" translate="yes" xml:space="preserve">
          <source>This example is equivalent to &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt;. More interesting cases, which cannot be reduced to a plain join, arise when the subquery involves grouping or aggregation.</source>
          <target state="translated">この例は、 &lt;code&gt;FROM table1 AS alias_name&lt;/code&gt; と同等です。サブクエリにグループ化または集約が含まれる場合、プレーンな結合に還元できないさらに興味深いケースが発生します。</target>
        </trans-unit>
        <trans-unit id="be1a5f2f3b699d99e46d29b68340b721327b27dd" translate="yes" xml:space="preserve">
          <source>This example is, of course, oversimplified, but there's a lot of control possible in a transaction block through the use of savepoints. Moreover, &lt;code&gt;ROLLBACK TO&lt;/code&gt; is the only way to regain control of a transaction block that was put in aborted state by the system due to an error, short of rolling it back completely and starting again.</source>
          <target state="translated">もちろん、この例は単純化しすぎていますが、セーブポイントを使用することで、トランザクションブロックで多くの制御が可能です。さらに、 &lt;code&gt;ROLLBACK TO&lt;/code&gt; は、エラーが原因でシステムによって中止状態にされたトランザクションブロックの制御を取り戻す唯一の方法であり、完全にロールバックしてから再開することはできません。</target>
        </trans-unit>
        <trans-unit id="a7b74712a2cd7143b58e55978ebc0a1e029aad05" translate="yes" xml:space="preserve">
          <source>This example produces a set something like:</source>
          <target state="translated">この例では、次のようなセットが生成されます。</target>
        </trans-unit>
        <trans-unit id="bd0849ce5d2cb6e49bc1884469c044510632ded5" translate="yes" xml:space="preserve">
          <source>This example shows a session that performs verification of the 10 largest catalog indexes in the database &amp;ldquo;test&amp;rdquo;. Verification of the presence of heap tuples as index tuples is requested for the subset that are unique indexes. Since no error is raised, all indexes tested appear to be logically consistent. Naturally, this query could easily be changed to call &lt;code&gt;bt_index_check&lt;/code&gt; for every index in the database where verification is supported.</source>
          <target state="translated">この例は、データベース「test」内の最大の10個のカタログインデックスの検証を実行するセッションを示しています。一意のインデックスであるサブセットに対して、インデックスタプルとしてのヒープタプルの存在の確認が要求されます。エラーが発生しないため、テストされたすべてのインデックスは論理的に一貫しているように見えます。当然、このクエリは、検証がサポートされているデータベース内のすべてのインデックスに対して &lt;code&gt;bt_index_check&lt;/code&gt; を呼び出すように簡単に変更できます。</target>
        </trans-unit>
        <trans-unit id="52eaa3c393eb8836501cf0b71b2390cbd556c111" translate="yes" xml:space="preserve">
          <source>This example shows how to use a function in the &lt;code&gt;FROM&lt;/code&gt; clause, both with and without a column definition list:</source>
          <target state="translated">次の例は、列定義リストがある場合とない場合の両方で、 &lt;code&gt;FROM&lt;/code&gt; 句で関数を使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="faf001583d1938e7eac65338b42d5145eeba9d29" translate="yes" xml:space="preserve">
          <source>This example shows how to use a simple &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">この例は、単純な &lt;code&gt;WITH&lt;/code&gt; 句の使用方法を示しています。</target>
        </trans-unit>
        <trans-unit id="dd1b1ae7add544b9cdd447e36bf84ceb80a1e127" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;LATERAL&lt;/code&gt; to apply a set-returning function &lt;code&gt;get_product_names()&lt;/code&gt; for each row of the &lt;code&gt;manufacturers&lt;/code&gt; table:</source>
          <target state="translated">この例では、 &lt;code&gt;LATERAL&lt;/code&gt; を使用して、 &lt;code&gt;manufacturers&lt;/code&gt; テーブルの各行にセットを返す関数 &lt;code&gt;get_product_names()&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="0eba8d9892663515b6cc219ad20715d37c9c5396" translate="yes" xml:space="preserve">
          <source>This example uses &lt;code&gt;WITH RECURSIVE&lt;/code&gt; to find all subordinates (direct or indirect) of the employee Mary, and their level of indirectness, from a table that shows only direct subordinates:</source>
          <target state="translated">この例では、 &lt;code&gt;WITH RECURSIVE&lt;/code&gt; を使用して、従業員Maryのすべての従属（直接または間接）とその間接レベルを、直接の従属のみを示すテーブルから検索します。</target>
        </trans-unit>
        <trans-unit id="625799a6daa4d3a32ad43aba61a387f19b4df04e" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;DEFAULT&lt;/code&gt; clause for the date columns rather than specifying a value:</source>
          <target state="translated">この例では、値を指定するのではなく、日付列に &lt;code&gt;DEFAULT&lt;/code&gt; 句を使用します。</target>
        </trans-unit>
        <trans-unit id="33b1cc724cf1f567bbb040ff9e9078c758235297" translate="yes" xml:space="preserve">
          <source>This example uses the following data (also available in file &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; in the source distribution):</source>
          <target state="translated">この例では、次のデータを使用します（ソース配布の &lt;code&gt;contrib/ltree/ltreetest.sql&lt;/code&gt; ファイルでも利用可能）：</target>
        </trans-unit>
        <trans-unit id="4a2eb1d66444608a417cb7a2c5c2fded452498b8" translate="yes" xml:space="preserve">
          <source>This example would remove all rows from tables &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;. The number of affected rows reported to the client would only include rows removed from &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">この例では、テーブル &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;bar&lt;/code&gt; からすべての行が削除されます。クライアントに報告された影響を受ける行の数には、 &lt;code&gt;bar&lt;/code&gt; から削除された行のみが含まれます。</target>
        </trans-unit>
        <trans-unit id="759fd9b05670f2874eee702f3df4de125c19d274" translate="yes" xml:space="preserve">
          <source>This example would use the standard Unicode collation in a nondeterministic way. In particular, this would allow strings in different normal forms to be compared correctly. More interesting examples make use of the ICU customization facilities explained above. For example:</source>
          <target state="translated">この例では、標準 Unicode 照合を非決定論的な方法で使用します。特に、これにより、異なる通常の形式の文字列を正しく比較できるようになります。さらに興味深い例として、上で説明したICUのカスタマイズ機能を利用したものがあります。例えば、以下のような例があります。</target>
        </trans-unit>
        <trans-unit id="a370e5d62e07be8745753fc6bbcb3e1a1d2437da" translate="yes" xml:space="preserve">
          <source>This expanded version of the previous query shows the operator family each operator class belongs to:</source>
          <target state="translated">このクエリの拡張版では、各演算子クラスが属する演算子ファミリーが表示されます。</target>
        </trans-unit>
        <trans-unit id="d891c30f21d694bab5f748d5f0b9dd9f8f629f4a" translate="yes" xml:space="preserve">
          <source>This expression returns the size of the track if it contains any segments with high heart rate values, or an empty sequence otherwise.</source>
          <target state="translated">この式は、心拍数の高い値を持つセグメントが含まれている場合はトラックのサイズを返し、そうでない場合は空のシーケンスを返します。</target>
        </trans-unit>
        <trans-unit id="0d9bda9d80ab3b41fb483157cc1a94532dbac7fb" translate="yes" xml:space="preserve">
          <source>This expression yields true when two time periods (defined by their endpoints) overlap, false when they do not overlap. The endpoints can be specified as pairs of dates, times, or time stamps; or as a date, time, or time stamp followed by an interval. When a pair of values is provided, either the start or the end can be written first; &lt;code&gt;OVERLAPS&lt;/code&gt; automatically takes the earlier value of the pair as the start. Each time period is considered to represent the half-open interval &lt;code&gt;start&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;time&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;end&lt;/code&gt;, unless &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are equal in which case it represents that single time instant. This means for instance that two time periods with only an endpoint in common do not overlap.</source>
          <target state="translated">この式は、2つの期間（エンドポイントで定義）がオーバーラップしている場合はtrue、オーバーラップしていない場合はfalseを返します。エンドポイントは、日付、時刻、またはタイムスタンプのペアとして指定できます。または、日付、時刻、またはタイムスタンプとそれに続く間隔として。値のペアが指定されている場合、開始または終了のいずれかを最初に書き込むことができます。 &lt;code&gt;OVERLAPS&lt;/code&gt; は、ペアの以前の値を自動的に開始として使用します。 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; が等しい場合を除き、各期間は、ハーフオープンインターバル &lt;code&gt;start&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;code&gt;time&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;end&lt;/code&gt; を表すと見なされます。これは、たとえば、エンドポイントのみが共通する2つの期間が重複しないことを意味します。</target>
        </trans-unit>
        <trans-unit id="c11b883111f39a35c0f589a7362884a445b2f9be" translate="yes" xml:space="preserve">
          <source>This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, PostgreSQL supports extensible B-trees and hash indexes. That means that you can use PostgreSQL to build a B-tree or hash over any data type you want. But B-trees only support range predicates (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;), and hash indexes only support equality queries.</source>
          <target state="translated">この拡張性は、処理できるデータに関して他の標準検索ツリーの拡張性と混同しないでください。たとえば、PostgreSQLは拡張可能なBツリーとハッシュインデックスをサポートしています。つまり、PostgreSQLを使用して、任意のデータ型に対してBツリーまたはハッシュを構築できます。ただし、Bツリーは範囲述語（ &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; ）のみをサポートし、ハッシュインデックスは等式クエリのみをサポートします。</target>
        </trans-unit>
        <trans-unit id="25249be2bc655571c6b319a5e05ab9bf57e7f0ce" translate="yes" xml:space="preserve">
          <source>This extension won't build at all unless the installation was configured with &lt;code&gt;--with-openssl&lt;/code&gt;.</source>
          <target state="translated">インストールが &lt;code&gt;--with-openssl&lt;/code&gt; で設定されていない限り、この拡張機能はまったくビルドされません。</target>
        </trans-unit>
        <trans-unit id="985d874d57f888d6b7d33a42c3b39fe6c5d40324" translate="yes" xml:space="preserve">
          <source>This failure occurs because PostgreSQL treats multiple &lt;code&gt;UNION&lt;/code&gt;s as a nest of pairwise operations; that is, this input is the same as</source>
          <target state="translated">この失敗は、PostgreSQLが複数の &lt;code&gt;UNION&lt;/code&gt; をペアワイズ演算のネストとして扱うために発生します。つまり、この入力は次と同じです。</target>
        </trans-unit>
        <trans-unit id="9dea5b639461b36e0d899f8204fb2b765c1a0fb6" translate="yes" xml:space="preserve">
          <source>This feature is disabled by default for manually issued &lt;code&gt;VACUUM&lt;/code&gt; commands. To enable it, set the &lt;code&gt;vacuum_cost_delay&lt;/code&gt; variable to a nonzero value.</source>
          <target state="translated">この機能は、手動で発行された &lt;code&gt;VACUUM&lt;/code&gt; コマンドではデフォルトで無効になっています。これを有効にするには、 &lt;code&gt;vacuum_cost_delay&lt;/code&gt; 変数をゼロ以外の値に設定します。</target>
        </trans-unit>
        <trans-unit id="7554d4b1db763d2db35742e4df9b2b6a631440fa" translate="yes" xml:space="preserve">
          <source>This feature is intended as a temporary measure until a complete solution is found. At that time, this option will be removed.</source>
          <target state="translated">この機能は、完全な解決策が見つかるまでの一時的な措置として意図されています。その時点で、このオプションは削除されます。</target>
        </trans-unit>
        <trans-unit id="37d4c1ac5e0b12c58cdf26713648d8dd1dfac571" translate="yes" xml:space="preserve">
          <source>This feature was designed to allow parameters not normally known to PostgreSQL to be added by add-on modules (such as procedural languages). This allows extension modules to be configured in the standard ways.</source>
          <target state="translated">この機能は、PostgreSQLでは通常知られていないパラメータをアドオンモジュール(手続き言語など)で追加できるように設計されました。これにより、拡張モジュールを標準的な方法で設定することができます。</target>
        </trans-unit>
        <trans-unit id="c6d9b959196517fcbab35a6da62247fb2b91ad04" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from Bash.</source>
          <target state="translated">この機能はBashから恥知らずに盗作したものです。</target>
        </trans-unit>
        <trans-unit id="9dd0c7f9cb881f24c299dc7cd6acc6e93722283f" translate="yes" xml:space="preserve">
          <source>This feature was shamelessly plagiarized from tcsh.</source>
          <target state="translated">この機能はtcshから恥知らずに盗用したものです。</target>
        </trans-unit>
        <trans-unit id="195725685743f0dba93fa9e927faaeac64a5e891" translate="yes" xml:space="preserve">
          <source>This field is not available in PostgreSQL releases prior to 8.3.</source>
          <target state="translated">このフィールドは8.3以前のPostgreSQLリリースでは利用できません。</target>
        </trans-unit>
        <trans-unit id="6136f38c2e93a8910734e7b6cf3ef3cea4cdbf88" translate="yes" xml:space="preserve">
          <source>This field only applies to &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;hostssl&lt;/code&gt;, and &lt;code&gt;hostnossl&lt;/code&gt; records.</source>
          <target state="translated">このフィールドは、 &lt;code&gt;host&lt;/code&gt; 、 &lt;code&gt;hostssl&lt;/code&gt; 、および &lt;code&gt;hostnossl&lt;/code&gt; レコードにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="1bb02774d9e01b5ecb4a1f9ea9a8d0284469c4dd" translate="yes" xml:space="preserve">
          <source>This flag does not behave identically to the &lt;code&gt;-t&lt;/code&gt; flag of pg_dump. There is not currently any provision for wild-card matching in pg_restore, nor can you include a schema name within its &lt;code&gt;-t&lt;/code&gt;. And, while pg_dump's &lt;code&gt;-t&lt;/code&gt; flag will also dump subsidiary objects (such as indexes) of the selected table(s), pg_restore's &lt;code&gt;-t&lt;/code&gt; flag does not include such subsidiary objects.</source>
          <target state="translated">このフラグは、pg_dumpの &lt;code&gt;-t&lt;/code&gt; フラグと同じように動作しません。現在、pg_restoreにはワイルドカード照合の規定がなく、その &lt;code&gt;-t&lt;/code&gt; にスキーマ名を含めることもできません。また、pg_dumpの &lt;code&gt;-t&lt;/code&gt; フラグは選択したテーブルの補助オブジェクト（インデックスなど）もダンプしますが、pg_restoreの &lt;code&gt;-t&lt;/code&gt; フラグはそのような補助オブジェクトを含みません。</target>
        </trans-unit>
        <trans-unit id="238947e6bf1928a48d022f51eceab630f9f9ea68" translate="yes" xml:space="preserve">
          <source>This forces the checkpoint to be done as quickly as possible.</source>
          <target state="translated">これにより、チェックポイントを早急に行わざるを得なくなります。</target>
        </trans-unit>
        <trans-unit id="69aa54921685a649b05a319351142e3198d02907" translate="yes" xml:space="preserve">
          <source>This form adds a new &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE&lt;/code&gt; constraint to a table based on an existing unique index. All the columns of the index will be included in the constraint.</source>
          <target state="translated">このフォームは、既存の一意のインデックスに基づいて、テーブルに新しい &lt;code&gt;PRIMARY KEY&lt;/code&gt; または &lt;code&gt;UNIQUE&lt;/code&gt; 制約を追加します。インデックスのすべての列が制約に含まれます。</target>
        </trans-unit>
        <trans-unit id="3ba31c86d5c7be29caf3e323f522bf84c40b7fcf" translate="yes" xml:space="preserve">
          <source>This form adds a new attribute to a composite type, using the same syntax as &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;.</source>
          <target state="translated">このフォームは、&lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt;と同じ構文を使用して、複合型に新しい属性を追加します。</target>
        </trans-unit>
        <trans-unit id="a0322ba886bea1157dcae5f05c22210a2d27f5b1" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Unlike the case when adding a column to a regular table, nothing happens to the underlying storage: this action simply declares that some new column is now accessible through the foreign table.</source>
          <target state="translated">このフォームは、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;と同じ構文を使用して、外部テーブルに新しい列を追加します。通常のテーブルに列を追加する場合とは異なり、基になるストレージには何も起こりません。このアクションは、いくつかの新しい列が外部テーブルからアクセスできるようになったことを宣言するだけです。</target>
        </trans-unit>
        <trans-unit id="95c0b10fe4a25bd3c814ee981b4c421d53eaf37a" translate="yes" xml:space="preserve">
          <source>This form adds a new column to the table, using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. If &lt;code&gt;IF NOT EXISTS&lt;/code&gt; is specified and a column already exists with this name, no error is thrown.</source>
          <target state="translated">このフォームは、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;と同じ構文を使用して、テーブルに新しい列を追加します。場合 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; が指定され、列は既にこの名前で存在、エラーがスローされません。</target>
        </trans-unit>
        <trans-unit id="b8ee63428230bf79c5e0942a3cc936820a6d5d6f" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a domain using the same syntax as &lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;. When a new constraint is added to a domain, all columns using that domain will be checked against the newly added constraint. These checks can be suppressed by adding the new constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option; the constraint can later be made valid using &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt;. Newly inserted or updated rows are always checked against all constraints, even those marked &lt;code&gt;NOT VALID&lt;/code&gt;. &lt;code&gt;NOT VALID&lt;/code&gt; is only accepted for &lt;code&gt;CHECK&lt;/code&gt; constraints.</source>
          <target state="translated">このフォームは、&lt;a href=&quot;sql-createdomain&quot;&gt;CREATE DOMAIN&lt;/a&gt;と同じ構文を使用して、ドメインに新しい制約を追加します。ドメインに新しい制約が追加されると、そのドメインを使用するすべての列が、新しく追加された制約に対してチェックされます。これらのチェックは、 &lt;code&gt;NOT VALID&lt;/code&gt; オプションを使用して新しい制約を追加することにより抑制できます。制約は後で &lt;code&gt;ALTER DOMAIN ... VALIDATE CONSTRAINT&lt;/code&gt; を使用して有効にすることができます。新しく挿入または更新された行は、 &lt;code&gt;NOT VALID&lt;/code&gt; とマークされたものも含めて、常にすべての制約に対してチェックされます。 &lt;code&gt;NOT VALID&lt;/code&gt; は、 &lt;code&gt;CHECK&lt;/code&gt; 制約に対してのみ受け入れられます。</target>
        </trans-unit>
        <trans-unit id="0f1ef6b759daf52986e80a140fc1e8e6996a0c1e" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a foreign table, using the same syntax as &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. Currently only &lt;code&gt;CHECK&lt;/code&gt; constraints are supported.</source>
          <target state="translated">このフォームは、&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;と同じ構文を使用して、外部テーブルに新しい制約を追加します。現在、 &lt;code&gt;CHECK&lt;/code&gt; 制約のみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="60c743b0f8a6b250501ac85a73828ca722af7185" translate="yes" xml:space="preserve">
          <source>This form adds a new constraint to a table using the same syntax as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, plus the option &lt;code&gt;NOT VALID&lt;/code&gt;, which is currently only allowed for foreign key and CHECK constraints.</source>
          <target state="translated">このフォームは、&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;と同じ構文を使用して、テーブルに新しい制約を追加し、さらにオプション &lt;code&gt;NOT VALID&lt;/code&gt; を追加します。これは現在、外部キーとCHECK制約でのみ許可されています。</target>
        </trans-unit>
        <trans-unit id="4ce19ef3782b6ce0c5b9df7476cc0daa1dd41c54" translate="yes" xml:space="preserve">
          <source>This form adds a new value to an enum type. The new value's place in the enum's ordering can be specified as being &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; one of the existing values. Otherwise, the new item is added at the end of the list of values.</source>
          <target state="translated">このフォームは、列挙型に新しい値を追加します。列挙型の順序で新しい価値の場所があるものとして指定することができ &lt;code&gt;BEFORE&lt;/code&gt; または &lt;code&gt;AFTER&lt;/code&gt; 既存の値のいずれかを。それ以外の場合、新しいアイテムは値の一覧の最後に追加されます。</target>
        </trans-unit>
        <trans-unit id="f6cf59f2735afa1f2d995a149ad05a9eb1b35eb7" translate="yes" xml:space="preserve">
          <source>This form adds an existing object to the extension. This is mainly useful in extension update scripts. The object will subsequently be treated as a member of the extension; notably, it can only be dropped by dropping the extension.</source>
          <target state="translated">このフォームは既存のオブジェクトを拡張機能に追加します。これは主に拡張機能の更新スクリプトで便利です。オブジェクトはその後、拡張モジュールのメンバーとして扱われます。</target>
        </trans-unit>
        <trans-unit id="595f54e5f3b774c232dc30ed51e46c90273688d9" translate="yes" xml:space="preserve">
          <source>This form adds the target foreign table as a new child of the specified parent table. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">このフォームは、ターゲット外部テーブルを指定された親テーブルの新しい子として追加します。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;同様の形式を参照してください。</target>
        </trans-unit>
        <trans-unit id="927ec7cd6b47cc568c9f6a02695b9db39fd050a7" translate="yes" xml:space="preserve">
          <source>This form adds the target table as a new child of the specified parent table. Subsequently, queries against the parent will include records of the target table. To be added as a child, the target table must already contain all the same columns as the parent (it could have additional columns, too). The columns must have matching data types, and if they have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the parent then they must also have &lt;code&gt;NOT NULL&lt;/code&gt; constraints in the child.</source>
          <target state="translated">このフォームは、指定された親テーブルの新しい子としてターゲットテーブルを追加します。その後、親に対するクエリには、ターゲットテーブルのレコードが含まれます。子として追加するには、ターゲットテーブルに親と同じ列がすべて含まれている必要があります（列を追加することもできます）。列は、一致するデータ型を持っている必要がありますし、彼らが持っている場合は &lt;code&gt;NOT NULL&lt;/code&gt; の親に制約が、その後、彼らはまた、持っている必要があります &lt;code&gt;NOT NULL&lt;/code&gt; の子で制約を。</target>
        </trans-unit>
        <trans-unit id="d346519cab151e59ba4d85ab858ae6233fa9d98e" translate="yes" xml:space="preserve">
          <source>This form alters the attributes of a constraint that was previously created. Currently only foreign key constraints may be altered.</source>
          <target state="translated">このフォームは、以前に作成された制約の属性を変更します。現在、変更できるのは外部キー制約のみです。</target>
        </trans-unit>
        <trans-unit id="7c3d28a97b5f73f4ab63b75ff86f6835976075b5" translate="yes" xml:space="preserve">
          <source>This form attaches an existing table (which might itself be partitioned) as a partition of the target table. The table can be attached as a partition for specific values using &lt;code&gt;FOR VALUES&lt;/code&gt; or as a default partition by using &lt;code&gt;DEFAULT&lt;/code&gt;. For each index in the target table, a corresponding one will be created in the attached table; or, if an equivalent index already exists, it will be attached to the target table's index, as if &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; had been executed. Note that if the existing table is a foreign table, it is currently not allowed to attach the table as a partition of the target table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the target table. (See also &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.)</source>
          <target state="translated">このフォームは、既存のテーブル（それ自体がパーティション化されている可能性があります）をターゲットテーブルのパーティションとしてアタッチします。テーブルは、 &lt;code&gt;FOR VALUES&lt;/code&gt; を使用して特定の値のパーティションとして、または &lt;code&gt;DEFAULT&lt;/code&gt; を使用してデフォルトのパーティションとしてアタッチできます。ターゲットテーブルのインデックスごとに、対応するインデックスが添付テーブルに作成されます。または、同等のインデックスがすでに存在する場合は、 &lt;code&gt;ALTER INDEX ATTACH PARTITION&lt;/code&gt; が実行されたかのように、ターゲットテーブルのインデックスにアタッチされます。既存のテーブルが外部テーブルである場合、ターゲットテーブルに &lt;code&gt;UNIQUE&lt;/code&gt; インデックスがある場合、現在、テーブルをターゲットテーブルのパーティションとしてアタッチすることはできません。 （&lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="bc3fb037ad7936c80f6f29d8637098894917452d" translate="yes" xml:space="preserve">
          <source>This form can be used to create the foreign table as partition of the given parent table with specified partition bound values. See the similar form of &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for more details. Note that it is currently not allowed to create the foreign table as a partition of the parent table if there are &lt;code&gt;UNIQUE&lt;/code&gt; indexes on the parent table. (See also &lt;a href=&quot;sql-altertable&quot;&gt;&lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">このフォームを使用して、指定されたパーティションバインド値を持つ特定の親テーブルのパーティションとして外部テーブルを作成できます。詳細については、同様の形式の&lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を参照してください。現在、親テーブルに &lt;code&gt;UNIQUE&lt;/code&gt; インデックスがある場合、親テーブルのパーティションとして外部テーブルを作成することはできません。（&lt;a href=&quot;sql-altertable&quot;&gt; &lt;code&gt;ALTER TABLE ATTACH PARTITION&lt;/code&gt; &lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="17c7c9cbd670ca1e7d92be433f5a08452d27c094" translate="yes" xml:space="preserve">
          <source>This form changes one or more index-method-specific storage parameters for the index. See &lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEX&lt;/a&gt; for details on the available parameters. Note that the index contents will not be modified immediately by this command; depending on the parameter you might need to rebuild the index with &lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt; to get the desired effects.</source>
          <target state="translated">このフォームは、インデックスの1つ以上のインデックスメソッド固有のストレージパラメータを変更します。参照&lt;a href=&quot;sql-createindex&quot;&gt;CREATE INDEXを&lt;/a&gt;使用可能なパラメータの詳細については。このコマンドでは、インデックスの内容はすぐには変更されないことに注意してください。パラメータによっては、&lt;a href=&quot;sql-reindex&quot;&gt;REINDEX&lt;/a&gt;を使用してインデックスを再構築し、目的の効果を得る必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="85e33ac3b4ee94fcc601870b607686da66a411c8" translate="yes" xml:space="preserve">
          <source>This form changes one or more storage parameters for the table. See &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;Storage Parameters&lt;/a&gt; for details on the available parameters. Note that the table contents will not be modified immediately by this command; depending on the parameter you might need to rewrite the table to get the desired effects. That can be done with &lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;, &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; or one of the forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; that forces a table rewrite. For planner related parameters, changes will take effect from the next time the table is locked so currently executing queries will not be affected.</source>
          <target state="translated">このフォームは、テーブルの1つ以上のストレージパラメータを変更します。参照してください。&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-STORAGE-PARAMETERS&quot;&gt;記憶域パラメータを&lt;/a&gt;使用可能なパラメータの詳細については。このコマンドでは、テーブルの内容はすぐには変更されないことに注意してください。パラメータによっては、目的の効果を得るためにテーブルを書き換える必要がある場合があります。これは、&lt;a href=&quot;sql-vacuum&quot;&gt;VACUUM FULL&lt;/a&gt;、&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER、&lt;/a&gt;またはテーブルの書き換えを強制する &lt;code&gt;ALTER TABLE&lt;/code&gt; のいずれかの形式で実行できます。プランナー関連のパラメーターの場合、変更は次回テーブルがロックされたときに有効になるため、現在実行中のクエリには影響しません。</target>
        </trans-unit>
        <trans-unit id="e83d3c0b4c77e2425087c239b0df05fcb0116826" translate="yes" xml:space="preserve">
          <source>This form changes the index's tablespace to the specified tablespace and moves the data file(s) associated with the index to the new tablespace. To change the tablespace of an index, you must own the index and have &lt;code&gt;CREATE&lt;/code&gt; privilege on the new tablespace. All indexes in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all indexes to be moved and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move indexes owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs will not be moved by this command, use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER INDEX&lt;/code&gt; invocations instead if desired. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">このフォームは、インデックスのテーブルスペースを指定されたテーブルスペースに変更し、インデックスに関連付けられたデータファイルを新しいテーブルスペースに移動します。インデックスのテーブルスペースを変更するには、インデックスを所有し、新しいテーブルスペースに対する &lt;code&gt;CREATE&lt;/code&gt; 権限を持っている必要があります。テーブルスペースの現在のデータベース内のすべてのインデックスは、 &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; フォームを使用して移動できます。これにより、移動するすべてのインデックスがロックされ、それぞれが移動します。このフォームは &lt;code&gt;OWNED BY&lt;/code&gt; もサポートしており、指定されたロールが所有するインデックスのみを移動します。 &lt;code&gt;NOWAIT&lt;/code&gt; オプションが指定されている場合、必要なすべてのロックをすぐに取得できないと、コマンドは失敗します。システムカタログには、このコマンドによって移動されないことに注意してください、使用 &lt;code&gt;ALTER DATABASE&lt;/code&gt; または、必要に応じて代わりに明示的な &lt;code&gt;ALTER INDEX&lt;/code&gt; 呼び出し。&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="3c55be56dbc86b6d6779191aa5c394d5588fe660" translate="yes" xml:space="preserve">
          <source>This form changes the information which is written to the write-ahead log to identify rows which are updated or deleted. This option has no effect except when logical replication is in use. &lt;code&gt;DEFAULT&lt;/code&gt; (the default for non-system tables) records the old values of the columns of the primary key, if any. &lt;code&gt;USING INDEX&lt;/code&gt; records the old values of the columns covered by the named index, which must be unique, not partial, not deferrable, and include only columns marked &lt;code&gt;NOT NULL&lt;/code&gt;. &lt;code&gt;FULL&lt;/code&gt; records the old values of all columns in the row. &lt;code&gt;NOTHING&lt;/code&gt; records no information about the old row. (This is the default for system tables.) In all cases, no old values are logged unless at least one of the columns that would be logged differs between the old and new versions of the row.</source>
          <target state="translated">このフォームは、先行書き込みログに書き込まれる情報を変更して、更新または削除された行を識別します。このオプションは、論理複製が使用されている場合を除いて効果がありません。 &lt;code&gt;DEFAULT&lt;/code&gt; （非システムテーブルのデフォルト）は、主キーの列の古い値を記録します（ある場合）。 &lt;code&gt;USING INDEX&lt;/code&gt; は、名前付きインデックスでカバーされる列の古い値を記録します。これは、一意であり、部分的ではなく、延期可能ではなく、 &lt;code&gt;NOT NULL&lt;/code&gt; とマークされた列のみを含む必要があります。 &lt;code&gt;FULL&lt;/code&gt; は、行のすべての列の古い値を記録します。 &lt;code&gt;NOTHING&lt;/code&gt; 古い行に関する情報は記録されません。（これはシステムテーブルのデフォルトです。）ログに記録される列の少なくとも1つが古いバージョンと新しいバージョンの行で異なる場合を除き、すべてのケースで古い値は記録されません。</target>
        </trans-unit>
        <trans-unit id="d5fd7a415ae62d2432d673453426bcca0e434c22" translate="yes" xml:space="preserve">
          <source>This form changes the name of a constraint on a domain.</source>
          <target state="translated">このフォームは、ドメインの制約の名前を変更します。</target>
        </trans-unit>
        <trans-unit id="3a34d134067f8057fdc7eb4bd8e2afb5eac929d2" translate="yes" xml:space="preserve">
          <source>This form changes the name of the domain.</source>
          <target state="translated">このフォームはドメイン名を変更します。</target>
        </trans-unit>
        <trans-unit id="bdaccc9f755620eea9c5a68106023cbc0c07f19d" translate="yes" xml:space="preserve">
          <source>This form changes the name of the type or the name of an individual attribute of a composite type.</source>
          <target state="translated">このフォームは、複合型の型名または個別属性名を変更します。</target>
        </trans-unit>
        <trans-unit id="33709234ccf296c21440f70a857148d5d605167b" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the domain to the specified user.</source>
          <target state="translated">このフォームは、ドメインの所有者を指定したユーザーに変更します。</target>
        </trans-unit>
        <trans-unit id="33c8412b485a6292103c360edb753fe679de7f49" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the foreign table to the specified user.</source>
          <target state="translated">このフォームは、外部テーブルの所有者を指定したユーザに変更します。</target>
        </trans-unit>
        <trans-unit id="bdda20046cb686daa61e8bfb091f3201cdd5da85" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the table, sequence, view, materialized view, or foreign table to the specified user.</source>
          <target state="translated">このフォームは、テーブル、シーケンス、ビュー、マテリアライズされたビュー、または外部テーブルの所有者を指定したユーザに変更します。</target>
        </trans-unit>
        <trans-unit id="367a0875855c27e375e704da43453b6a64108026" translate="yes" xml:space="preserve">
          <source>This form changes the owner of the type.</source>
          <target state="translated">このフォームは、型の所有者を変更します。</target>
        </trans-unit>
        <trans-unit id="6515faf0d6c7bfb31358723522828dadb55476f0" translate="yes" xml:space="preserve">
          <source>This form changes the schema of the domain. Any constraints associated with the domain are moved into the new schema as well.</source>
          <target state="translated">このフォームはドメインのスキーマを変更します。ドメインに関連付けられたすべての制約は、新しいスキーマにも移動されます。</target>
        </trans-unit>
        <trans-unit id="9ceb0679036b94c23ce3c3c3726ad7d1600fd754" translate="yes" xml:space="preserve">
          <source>This form changes the table from unlogged to logged or vice-versa (see &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt;&lt;code&gt;UNLOGGED&lt;/code&gt;&lt;/a&gt;). It cannot be applied to a temporary table.</source>
          <target state="translated">このフォームはテーブルをログなしからログ済みに、またはその逆に変更します（&lt;a href=&quot;sql-createtable#SQL-CREATETABLE-UNLOGGED&quot;&gt; &lt;code&gt;UNLOGGED&lt;/code&gt; を&lt;/a&gt;参照）。一時テーブルには適用できません。</target>
        </trans-unit>
        <trans-unit id="413a825daa3f78a948f21b1ed732bd1afa98d9f3" translate="yes" xml:space="preserve">
          <source>This form changes the table's tablespace to the specified tablespace and moves the data file(s) associated with the table to the new tablespace. Indexes on the table, if any, are not moved; but they can be moved separately with additional &lt;code&gt;SET TABLESPACE&lt;/code&gt; commands. When applied to a partitioned table, nothing is moved, but any partitions created afterwards with &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; will use that tablespace, unless the &lt;code&gt;TABLESPACE&lt;/code&gt; clause is used to override it.</source>
          <target state="translated">このフォームは、テーブルのテーブルスペースを指定されたテーブルスペースに変更し、テーブルに関連付けられたデータファイルを新しいテーブルスペースに移動します。テーブルのインデックスがあっても移動されません。ただし、追加の &lt;code&gt;SET TABLESPACE&lt;/code&gt; コマンドを使用して個別に移動できます。パーティション分割されたテーブルに適用された場合、何も移動されませんが、 &lt;code&gt;CREATE TABLE PARTITION OF&lt;/code&gt; で後で作成されたパーティションは、 &lt;code&gt;TABLESPACE&lt;/code&gt; 句を使用して上書きしない限り、そのテーブルスペースを使用します。</target>
        </trans-unit>
        <trans-unit id="d606494af7f67be03bcb787fb49d4fbd5e3725e9" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a foreign table. Again, this has no effect on any underlying storage: this action simply changes the type that PostgreSQL believes the column to have.</source>
          <target state="translated">このフォームは、外部テーブルのカラムの型を変更します。繰り返しになりますが、これは基礎となるストレージには何の影響もありません。このアクションは単にPostgreSQLがその列が持つと考えている型を変更するだけです。</target>
        </trans-unit>
        <trans-unit id="ef90ca77493d55255faa9c05a6d21e673fa262d6" translate="yes" xml:space="preserve">
          <source>This form changes the type of a column of a table. Indexes and simple table constraints involving the column will be automatically converted to use the new column type by reparsing the originally supplied expression. The optional &lt;code&gt;COLLATE&lt;/code&gt; clause specifies a collation for the new column; if omitted, the collation is the default for the new column type. The optional &lt;code&gt;USING&lt;/code&gt; clause specifies how to compute the new column value from the old; if omitted, the default conversion is the same as an assignment cast from old data type to new. A &lt;code&gt;USING&lt;/code&gt; clause must be provided if there is no implicit or assignment cast from old to new type.</source>
          <target state="translated">このフォームは、テーブルの列のタイプを変更します。列に関連するインデックスと単純なテーブル制約は、最初に提供された式を再解析することにより、新しい列タイプを使用するように自動的に変換されます。オプションの &lt;code&gt;COLLATE&lt;/code&gt; 句は、新しい列の照合を指定します。省略した場合、照合は新しい列タイプのデフォルトになります。オプションの &lt;code&gt;USING&lt;/code&gt; 句は、古い列の値から新しい列の値を計算する方法を指定します。省略した場合、デフォルトの変換は、古いデータ型から新しいデータ型への代入キャストと同じです。 &lt;code&gt;USING&lt;/code&gt; 新しいタイプの古いから暗黙または割り当てキャストがない場合句が提供されなければなりません。</target>
        </trans-unit>
        <trans-unit id="f90f5c12001436438a106ce1bcbc9026c77d9b2f" translate="yes" xml:space="preserve">
          <source>This form changes the type of an attribute of a composite type.</source>
          <target state="translated">このフォームは、複合型の属性の型を変更します。</target>
        </trans-unit>
        <trans-unit id="c4194cb65228a21c483f32a1d7544636b626b6d4" translate="yes" xml:space="preserve">
          <source>This form detaches specified partition of the target table. The detached partition continues to exist as a standalone table, but no longer has any ties to the table from which it was detached. Any indexes that were attached to the target table's indexes are detached.</source>
          <target state="translated">このフォームは、ターゲットテーブルの指定されたパーティションを切り離します。切り離されたパーティションはスタンドアロンのテーブルとして存在し続けますが、切り離されたテーブルとの関係はなくなります。ターゲット・テーブルのインデックスにアタッチされていたインデックスはすべて切り離されます。</target>
        </trans-unit>
        <trans-unit id="6f649e2a380d4d6a7844e29c8bec08b60d14e121" translate="yes" xml:space="preserve">
          <source>This form dissociates a typed table from its type.</source>
          <target state="translated">このフォームは、型付きテーブルをその型から切り離します。</target>
        </trans-unit>
        <trans-unit id="41af815da8671345e4d0830589af85c8c9d1f4f9" translate="yes" xml:space="preserve">
          <source>This form drops a column from a foreign table. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column; for example, views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">このフォームは、外部テーブルから列を削除します。テーブルの外側が列に依存している場合は、 &lt;code&gt;CASCADE&lt;/code&gt; と言う必要があります。たとえば、ビュー。場合 &lt;code&gt;IF EXISTS&lt;/code&gt; が指定され、列が存在しない、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="132c35990a8f9ff6a2087c8c4db6bfe5bc0d3b7f" translate="yes" xml:space="preserve">
          <source>This form drops a column from a table. Indexes and table constraints involving the column will be automatically dropped as well. Multivariate statistics referencing the dropped column will also be removed if the removal of the column would cause the statistics to contain data for only a single column. You will need to say &lt;code&gt;CASCADE&lt;/code&gt; if anything outside the table depends on the column, for example, foreign key references or views. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the column does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">このフォームは、テーブルから列を削除します。列に関連するインデックスとテーブル制約も自動的に削除されます。列を削除すると統計に単一の列のみのデータが含まれる場合は、削除された列を参照する多変量統計も削除されます。外部キー参照やビューなど、テーブルの外側が列に依存している場合は、 &lt;code&gt;CASCADE&lt;/code&gt; と言う必要があります。場合 &lt;code&gt;IF EXISTS&lt;/code&gt; が指定され、列が存在しない、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="630cbfc87f5704d127bcc228848ac6a6604a8fb0" translate="yes" xml:space="preserve">
          <source>This form drops an attribute from a composite type. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the attribute does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">このフォームは、複合型から属性を削除します。場合 &lt;code&gt;IF EXISTS&lt;/code&gt; が指定され、属性が存在しない、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="abbb33e28408b10284213af5010b6f9ed9616abd" translate="yes" xml:space="preserve">
          <source>This form drops constraints on a domain. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">このフォームは、ドメインの制約を削除します。場合 &lt;code&gt;IF EXISTS&lt;/code&gt; が指定され、制約が存在しない場合、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="0562817256cba47f3678521e40341b9bb63428df" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a foreign table. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">このフォームは、外部テーブルの指定された制約を削除します。場合 &lt;code&gt;IF EXISTS&lt;/code&gt; が指定され、制約が存在しない場合、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="ef5c32eb106661dab4fdce48beeb3716d53be331" translate="yes" xml:space="preserve">
          <source>This form drops the specified constraint on a table, along with any index underlying the constraint. If &lt;code&gt;IF EXISTS&lt;/code&gt; is specified and the constraint does not exist, no error is thrown. In this case a notice is issued instead.</source>
          <target state="translated">このフォームは、指定された制約を、制約の基礎となるインデックスとともにテーブルにドロップします。場合 &lt;code&gt;IF EXISTS&lt;/code&gt; が指定され、制約が存在しない場合、エラーがスローされません。この場合、代わりに通知が発行されます。</target>
        </trans-unit>
        <trans-unit id="d6075d1245dd08cd17ae12d300569e914c015d02" translate="yes" xml:space="preserve">
          <source>This form is not currently supported on partitioned tables.</source>
          <target state="translated">この形式は現在、パーティショニングされたテーブルではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="62fef7209d0ef0917314ea35bb80cd3a32ecadf7" translate="yes" xml:space="preserve">
          <source>This form links the table to a composite type as though &lt;code&gt;CREATE TABLE OF&lt;/code&gt; had formed it. The table's list of column names and types must precisely match that of the composite type. The table must not inherit from any other table. These restrictions ensure that &lt;code&gt;CREATE TABLE OF&lt;/code&gt; would permit an equivalent table definition.</source>
          <target state="translated">このフォームは、 &lt;code&gt;CREATE TABLE OF&lt;/code&gt; がテーブルを作成したかのように、テーブルを複合タイプにリンクします。テーブルの列名と型のリストは、複合型のリストと正確に一致している必要があります。テーブルは他のテーブルから継承してはなりません。これらの制限により、 &lt;code&gt;CREATE TABLE OF&lt;/code&gt; は同等のテーブル定義を許可します。</target>
        </trans-unit>
        <trans-unit id="80c03819073116dcc932622328193f2e17ef52d2" translate="yes" xml:space="preserve">
          <source>This form marks as valid a constraint that was previously marked as &lt;code&gt;NOT VALID&lt;/code&gt;. No action is taken to verify the constraint, but future queries will assume that it holds.</source>
          <target state="translated">このフォームは、以前に &lt;code&gt;NOT VALID&lt;/code&gt; としてマークされた制約を有効としてマークします。制約を検証するためのアクションは行われませんが、今後のクエリでは、制約が保持されていると想定されます。</target>
        </trans-unit>
        <trans-unit id="85cec438622a098483a45173b222a4d5cd019672" translate="yes" xml:space="preserve">
          <source>This form marks the index as dependent on the extension, such that if the extension is dropped, the index will automatically be dropped as well.</source>
          <target state="translated">このフォームでは、拡張子が削除された場合、インデックスも自動的に削除されるように、インデックスを拡張子に依存したものとしてマークします。</target>
        </trans-unit>
        <trans-unit id="4faed3e54b7a44c7e7e8c551a8c0326f16df1512" translate="yes" xml:space="preserve">
          <source>This form moves the extension's objects into another schema. The extension has to be &lt;em&gt;relocatable&lt;/em&gt; for this command to succeed.</source>
          <target state="translated">このフォームは、拡張のオブジェクトを別のスキーマに移動します。このコマンドが成功するには、拡張機能が&lt;em&gt;再配置可能&lt;/em&gt;である必要があります。</target>
        </trans-unit>
        <trans-unit id="d44749fe236086787bbeb370c7b120c56a308916" translate="yes" xml:space="preserve">
          <source>This form moves the foreign table into another schema.</source>
          <target state="translated">このフォームは、外部テーブルを別のスキーマに移動します。</target>
        </trans-unit>
        <trans-unit id="343fe32ad6664d950886e22df1f9e56f6f16399d" translate="yes" xml:space="preserve">
          <source>This form moves the table into another schema. Associated indexes, constraints, and sequences owned by table columns are moved as well.</source>
          <target state="translated">このフォームは、テーブルを別のスキーマに移動します。テーブルの列が所有する関連するインデックス、制約、およびシーケンスも移動されます。</target>
        </trans-unit>
        <trans-unit id="4a25f7c9422516454200b0986e93d0f9a7b1cd24" translate="yes" xml:space="preserve">
          <source>This form moves the type into another schema.</source>
          <target state="translated">このフォームは、型を別のスキーマに移動します。</target>
        </trans-unit>
        <trans-unit id="af28f23e1758f00a66bd13166257650c2c6c6e02" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; is a PostgreSQL extension. There is a &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; command in the SQL standard, but it is for adapting data types to client languages. That usage is not supported by PostgreSQL.</source>
          <target state="translated">この形式の &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; は、PostgreSQLの拡張機能です。あり &lt;code&gt;CREATE TRANSFORM&lt;/code&gt; SQL標準でコマンドを、それがクライアントの言語にデータ型を適応させるためです。その使用法はPostgreSQLではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6ab065126927246d3956d5f89c1fdf1ac5a9c01c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;DROP TRANSFORM&lt;/code&gt; is a PostgreSQL extension. See &lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt; for details.</source>
          <target state="translated">この形式の &lt;code&gt;DROP TRANSFORM&lt;/code&gt; は、PostgreSQLの拡張機能です。詳細については、&lt;a href=&quot;sql-createtransform&quot;&gt;CREATE TRANSFORM&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3ff5cb48fe56e9b363be562d91784fed1316defb" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;json_object&lt;/code&gt; takes keys and values pairwise from two separate arrays. In all other respects it is identical to the one-argument form.</source>
          <target state="translated">この形式の &lt;code&gt;json_object&lt;/code&gt; は、2つの別々の配列からペアでキーと値を取得します。他のすべての点で、これは1つの引数の形式と同じです。</target>
        </trans-unit>
        <trans-unit id="e130ed2324ecc47cb96bb25ee04c4b0d13167363" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; accepts a starting &lt;code&gt;query&lt;/code&gt; and a SQL &lt;code&gt;select&lt;/code&gt; command, which is given as a text string. The &lt;code&gt;select&lt;/code&gt; must yield two columns of &lt;code&gt;tsquery&lt;/code&gt; type. For each row of the &lt;code&gt;select&lt;/code&gt; result, occurrences of the first column value (the target) are replaced by the second column value (the substitute) within the current &lt;code&gt;query&lt;/code&gt; value. For example:</source>
          <target state="translated">この形式の &lt;code&gt;ts_rewrite&lt;/code&gt; は、開始 &lt;code&gt;query&lt;/code&gt; と、テキスト文字列として指定されるSQL &lt;code&gt;select&lt;/code&gt; コマンドを受け入れます。 &lt;code&gt;select&lt;/code&gt; 必見収率の2列 &lt;code&gt;tsquery&lt;/code&gt; タイプ。 &lt;code&gt;select&lt;/code&gt; 結果の各行で、現在の &lt;code&gt;query&lt;/code&gt; 値内の最初の列の値（ターゲット）の出現が2番目の列の値（代替）に置き換えられます。例えば：</target>
        </trans-unit>
        <trans-unit id="d013efd17243813d551b63d4312494e00c1c1a6c" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;ts_rewrite&lt;/code&gt; simply applies a single rewrite rule: &lt;code&gt;target&lt;/code&gt; is replaced by &lt;code&gt;substitute&lt;/code&gt; wherever it appears in &lt;code&gt;query&lt;/code&gt;. For example:</source>
          <target state="translated">この形式の &lt;code&gt;ts_rewrite&lt;/code&gt; は、単に単一の書き換えルールを適用します。 &lt;code&gt;target&lt;/code&gt; で置き換えられる &lt;code&gt;substitute&lt;/code&gt; それがに表示されますどこ &lt;code&gt;query&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="eb31fbf716a310edf9d2b4049a82ade012c42087" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language functions when the function name in the C language source code is not the same as the name of the SQL function. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C function, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the function's link symbol, that is, the name of the function in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL function being defined. The C names of all functions must be different, so you must give overloaded C functions different C names (for example, use the argument types as part of the C names).</source>
          <target state="translated">この形式の &lt;code&gt;AS&lt;/code&gt; 節は、C言語のソースコードの関数名がSQL関数の名前と同じでない場合に、動的にロード可能なC言語の関数に使用されます。文字列 &lt;code&gt;obj_file&lt;/code&gt; は、コンパイルされたC関数を含む共有ライブラリファイルの名前で、&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;コマンドと同様に解釈されます。文字列 &lt;code&gt;link_symbol&lt;/code&gt; は、関数のリンクシンボル、つまり、C言語のソースコードでの関数の名前です。リンク記号が省略されている場合は、定義されているSQL関数の名前と同じであると見なされます。すべての関数のC名は異なる必要があるため、多重定義されたC関数に異なるC名を付ける必要があります（例えば、C名の一部として引数型を使用します）。</target>
        </trans-unit>
        <trans-unit id="2a04c3c78f722989a90da205ce8987d3f751510b" translate="yes" xml:space="preserve">
          <source>This form of the &lt;code&gt;AS&lt;/code&gt; clause is used for dynamically loadable C language procedures when the procedure name in the C language source code is not the same as the name of the SQL procedure. The string &lt;code&gt;obj_file&lt;/code&gt; is the name of the shared library file containing the compiled C procedure, and is interpreted as for the &lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt; command. The string &lt;code&gt;link_symbol&lt;/code&gt; is the procedure's link symbol, that is, the name of the procedure in the C language source code. If the link symbol is omitted, it is assumed to be the same as the name of the SQL procedure being defined.</source>
          <target state="translated">この形式の &lt;code&gt;AS&lt;/code&gt; 節は、C言語のソースコードのプロシージャ名がSQLプロシージャの名前と同じでない場合に、動的にロード可能なC言語のプロシージャに使用されます。文字列 &lt;code&gt;obj_file&lt;/code&gt; は、コンパイルされたCプロシージャを含む共有ライブラリファイルの名前で、&lt;a href=&quot;sql-load&quot;&gt;LOAD&lt;/a&gt;コマンドと同様に解釈されます。文字列 &lt;code&gt;link_symbol&lt;/code&gt; は、プロシージャのリンクシンボル、つまり、C言語のソースコードでのプロシージャの名前です。リンク記号が省略されている場合は、定義されているSQLプロシージャーの名前と同じであると見なされます。</target>
        </trans-unit>
        <trans-unit id="9d61def8f9ec3856b91d045805fea7f90a02d4de" translate="yes" xml:space="preserve">
          <source>This form of the command cannot be executed inside a transaction block.</source>
          <target state="translated">この形式のコマンドは、トランザクション・ブロック内では実行できません。</target>
        </trans-unit>
        <trans-unit id="99f50353be2bb5b567c08b62d433e3835ac63124" translate="yes" xml:space="preserve">
          <source>This form only executes the function if column &lt;code&gt;balance&lt;/code&gt; has in fact changed value:</source>
          <target state="translated">このフォームは、列 &lt;code&gt;balance&lt;/code&gt; 値が実際に変更されている場合にのみ関数を実行します。</target>
        </trans-unit>
        <trans-unit id="f4473c42ad05dfd82fc106e9f90398e30bc2ce6b" translate="yes" xml:space="preserve">
          <source>This form removes a member object from the extension. This is mainly useful in extension update scripts. The object is not dropped, only disassociated from the extension.</source>
          <target state="translated">このフォームは、拡張機能からメンバーオブジェクトを削除します。これは主に拡張機能の更新スクリプトで便利です。オブジェクトは削除されず、拡張機能から切り離されるだけです。</target>
        </trans-unit>
        <trans-unit id="eac856d748a6f647a905af09f04314ea23cd83c3" translate="yes" xml:space="preserve">
          <source>This form removes the most recently used &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; index specification from the table. This affects future cluster operations that don't specify an index.</source>
          <target state="translated">このフォームは、最近使用された&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;インデックス指定をテーブルから削除します。これは、インデックスを指定しない将来のクラスター操作に影響します。</target>
        </trans-unit>
        <trans-unit id="b9adc8eb95719164761b79a5084426c7addf0749" translate="yes" xml:space="preserve">
          <source>This form removes the target foreign table from the list of children of the specified parent table.</source>
          <target state="translated">このフォームは、指定された親テーブルの子テーブルのリストから対象の外部テーブルを削除します。</target>
        </trans-unit>
        <trans-unit id="9c78c98e24aa433ee20cbdef33df9ef970bae2bf" translate="yes" xml:space="preserve">
          <source>This form removes the target table from the list of children of the specified parent table. Queries against the parent table will no longer include records drawn from the target table.</source>
          <target state="translated">このフォームは、指定した親テーブルの子テーブルのリストから対象テーブルを削除します。親テーブルに対するクエリには、ターゲット テーブルから引き出されたレコードは含まれなくなります。</target>
        </trans-unit>
        <trans-unit id="3c86659bd33298dbeea55e29cf320d1c3d50f459" translate="yes" xml:space="preserve">
          <source>This form renames a value of an enum type. The value's place in the enum's ordering is not affected. An error will occur if the specified value is not present or the new name is already present.</source>
          <target state="translated">このフォームは、列挙型の値の名前を変更します。列挙型の順序における値の位置は影響を受けません。指定された値が存在しない場合や、新しい名前が既に存在する場合はエラーとなります。</target>
        </trans-unit>
        <trans-unit id="d4bbf5050bebdaa653a528317e3e5511397a3bd9" translate="yes" xml:space="preserve">
          <source>This form resets one or more index-method-specific storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a &lt;code&gt;REINDEX&lt;/code&gt; might be needed to update the index entirely.</source>
          <target state="translated">このフォームは、1つ以上のインデックスメソッド固有のストレージパラメータをデフォルトにリセットします。 &lt;code&gt;SET&lt;/code&gt; と同様に、インデックスを完全に更新するには &lt;code&gt;REINDEX&lt;/code&gt; が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="5e49ca11d0f33e0a64657337a16309c7010218e7" translate="yes" xml:space="preserve">
          <source>This form resets one or more storage parameters to their defaults. As with &lt;code&gt;SET&lt;/code&gt;, a table rewrite might be needed to update the table entirely.</source>
          <target state="translated">このフォームは、1つ以上のストレージパラメータをデフォルトにリセットします。 &lt;code&gt;SET&lt;/code&gt; と同様に、テーブルを完全に更新するには、テーブルの書き換えが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="1d66d6fd49dacdab7eaf9fc3512115d0797c065d" translate="yes" xml:space="preserve">
          <source>This form selects the default index for future &lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt; operations. It does not actually re-cluster the table.</source>
          <target state="translated">このフォームは、将来の&lt;a href=&quot;sql-cluster&quot;&gt;CLUSTER&lt;/a&gt;操作のデフォルトインデックスを選択します。実際にテーブルを再クラスタリングすることはありません。</target>
        </trans-unit>
        <trans-unit id="518ddc9b662de15607142c00b06214f51c6fca69" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. Currently, the only defined per-attribute options are &lt;code&gt;n_distinct&lt;/code&gt; and &lt;code&gt;n_distinct_inherited&lt;/code&gt;, which override the number-of-distinct-values estimates made by subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. &lt;code&gt;n_distinct&lt;/code&gt; affects the statistics for the table itself, while &lt;code&gt;n_distinct_inherited&lt;/code&gt; affects the statistics gathered for the table plus its inheritance children. When set to a positive value, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the column contains exactly the specified number of distinct nonnull values. When set to a negative value, which must be greater than or equal to -1, &lt;code&gt;ANALYZE&lt;/code&gt; will assume that the number of distinct nonnull values in the column is linear in the size of the table; the exact count is to be computed by multiplying the estimated table size by the absolute value of the given number. For example, a value of -1 implies that all values in the column are distinct, while a value of -0.5 implies that each value appears twice on the average. This can be useful when the size of the table changes over time, since the multiplication by the number of rows in the table is not performed until query planning time. Specify a value of 0 to revert to estimating the number of distinct values normally. For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">このフォームは、属性ごとのオプションを設定またはリセットします。現在、定義されている属性ごとのオプションは &lt;code&gt;n_distinct&lt;/code&gt; と &lt;code&gt;n_distinct_inherited&lt;/code&gt; のみです。これらのオプションは、後続の&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作によって行われる個別値の数の見積もりをオーバーライドします。 &lt;code&gt;n_distinct&lt;/code&gt; はテーブル自体の統計に影響を与え、 &lt;code&gt;n_distinct_inherited&lt;/code&gt; はテーブルとその継承の子について収集された統計に影響を与えます。正の値に設定すると、 &lt;code&gt;ANALYZE&lt;/code&gt; は、列に指定された数の異なる非null値が正確に含まれていると想定します。負の値に設定すると、-1以上にする必要があります &lt;code&gt;ANALYZE&lt;/code&gt; 列内の個別の非null値の数は、テーブルのサイズに対して線形であると想定します。正確な数は、推定されたテーブルサイズに、指定された数値の絶対値を掛けて計算されます。たとえば、値-1は列のすべての値が異なることを意味し、値-0.5は各値が平均で2回表示されることを意味します。テーブルの行数による乗算はクエリの計画時まで実行されないため、これはテーブルのサイズが時間とともに変化する場合に役立ちます。値0を指定すると、通常は個別の値の数の推定に戻ります。 PostgreSQLクエリプランナーによる統計の使用の詳細については、&lt;a href=&quot;planner-stats&quot;&gt;セクション14.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="895b894f198c38b8b568f74baad8144867fc06d4" translate="yes" xml:space="preserve">
          <source>This form sets or resets per-attribute options. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">このフォームは、属性ごとのオプションを設定またはリセットします。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;同様の形式を参照してください。</target>
        </trans-unit>
        <trans-unit id="740f7c9cb8ed05218d4d039f1aa9f624d452a1af" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations, though can be used only on index columns that are defined as an expression. Since expressions lack a unique name, we refer to them using the ordinal number of the index column. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">このフォームは、後続の&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作の列ごとの統計収集ターゲットを設定しますが、式として定義されているインデックス列でのみ使用できます。式には一意の名前がないため、インデックス列の序数を使用して式を参照します。ターゲットは0〜10000の範囲で設定できます。または、これを-1に設定すると、システムのデフォルトの統計ターゲット（&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;）の使用に戻ります。PostgreSQLクエリプランナーによる統計の使用の詳細については、&lt;a href=&quot;planner-stats&quot;&gt;セクション14.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="25d5f18188deb36d3de2faca967992d3efc2b40a" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details.</source>
          <target state="translated">このフォームは、後続の&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作の列ごとの統計収集ターゲットを設定します。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;同様の形式を参照してください。</target>
        </trans-unit>
        <trans-unit id="6332f7067a3fb1b7b86c9dc56f927e587c384e78" translate="yes" xml:space="preserve">
          <source>This form sets the per-column statistics-gathering target for subsequent &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; operations. The target can be set in the range 0 to 10000; alternatively, set it to -1 to revert to using the system default statistics target (&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;). For more information on the use of statistics by the PostgreSQL query planner, refer to &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;.</source>
          <target state="translated">このフォームは、後続の&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;操作の列ごとの統計収集ターゲットを設定します。ターゲットは0〜10000の範囲で設定できます。または、これを-1に設定すると、システムのデフォルトの統計ターゲット（&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;）の使用に戻ります。PostgreSQLクエリプランナーによる統計の使用の詳細については、&lt;a href=&quot;planner-stats&quot;&gt;セクション14.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4211581d9cac601dcf30af9c236c2e568347e8dc" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. See the similar form of &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; for more details. Note that the storage mode has no effect unless the table's foreign-data wrapper chooses to pay attention to it.</source>
          <target state="translated">このフォームは、列の格納モードを設定します。詳細については、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;同様の形式を参照してください。ストレージモードは、テーブルの外部データラッパーが注意を払うことを選択しない限り、効果がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="647ec6a7abe325c2f43beddebcddae6af6d3e9e1" translate="yes" xml:space="preserve">
          <source>This form sets the storage mode for a column. This controls whether this column is held inline or in a secondary TOAST table, and whether the data should be compressed or not. &lt;code&gt;PLAIN&lt;/code&gt; must be used for fixed-length values such as &lt;code&gt;integer&lt;/code&gt; and is inline, uncompressed. &lt;code&gt;MAIN&lt;/code&gt; is for inline, compressible data. &lt;code&gt;EXTERNAL&lt;/code&gt; is for external, uncompressed data, and &lt;code&gt;EXTENDED&lt;/code&gt; is for external, compressed data. &lt;code&gt;EXTENDED&lt;/code&gt; is the default for most data types that support non-&lt;code&gt;PLAIN&lt;/code&gt; storage. Use of &lt;code&gt;EXTERNAL&lt;/code&gt; will make substring operations on very large &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;bytea&lt;/code&gt; values run faster, at the penalty of increased storage space. Note that &lt;code&gt;SET STORAGE&lt;/code&gt; doesn't itself change anything in the table, it just sets the strategy to be pursued during future table updates. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">このフォームは、列の格納モードを設定します。これは、この列をインラインで保持するか、セカンダリTOASTテーブルに保持するか、およびデータを圧縮するかどうかを制御します。 &lt;code&gt;PLAIN&lt;/code&gt; は &lt;code&gt;integer&lt;/code&gt; などの固定長の値に使用する必要があり、インラインで圧縮されていません。 &lt;code&gt;MAIN&lt;/code&gt; は、インラインの圧縮可能なデータ用です。 &lt;code&gt;EXTERNAL&lt;/code&gt; は外部の非圧縮データ用で、 &lt;code&gt;EXTENDED&lt;/code&gt; は外部の圧縮データ用です。 &lt;code&gt;EXTENDED&lt;/code&gt; は、非 &lt;code&gt;PLAIN&lt;/code&gt; ストレージをサポートするほとんどのデータ型のデフォルトです。 &lt;code&gt;EXTERNAL&lt;/code&gt; を使用すると、非常に大きな &lt;code&gt;text&lt;/code&gt; と &lt;code&gt;bytea&lt;/code&gt; で部分文字列操作が行われます値は、ストレージスペースの増加というペナルティで、より高速に実行されます。 &lt;code&gt;SET STORAGE&lt;/code&gt; 自体はテーブル内の何も変更しないことに注意してください。それは、将来のテーブル更新時に追跡される戦略を設定するだけです。詳細については、&lt;a href=&quot;storage-toast&quot;&gt;セクション68.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="79e59ee7d655fea5f293a39645cf958df6f59eaa" translate="yes" xml:space="preserve">
          <source>This form updates the extension to a newer version. The extension must supply a suitable update script (or series of scripts) that can modify the currently-installed version into the requested version.</source>
          <target state="translated">このフォームは、拡張機能を新しいバージョンに更新します。拡張機能は、現在インストールされているバージョンを要求されたバージョンに変更できる適切な更新スクリプト (または一連のスクリプト)を提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="54be61b37045a65ad5af5b24265bf2d2fe56613b" translate="yes" xml:space="preserve">
          <source>This form validates a constraint previously added as &lt;code&gt;NOT VALID&lt;/code&gt;, that is, it verifies that all values in table columns of the domain type satisfy the specified constraint.</source>
          <target state="translated">このフォームは、以前に &lt;code&gt;NOT VALID&lt;/code&gt; として追加された制約を検証します。つまり、ドメインタイプのテーブル列のすべての値が指定された制約を満たすことを検証します。</target>
        </trans-unit>
        <trans-unit id="7fae39d4d329b60aa027a709db925fb7a0b45aad" translate="yes" xml:space="preserve">
          <source>This form validates a foreign key or check constraint that was previously created as &lt;code&gt;NOT VALID&lt;/code&gt;, by scanning the table to ensure there are no rows for which the constraint is not satisfied. Nothing happens if the constraint is already marked valid. (See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for an explanation of the usefulness of this command.)</source>
          <target state="translated">このフォームは、テーブルをスキャンして、制約が満たされていない行がないことを確認することにより、以前に &lt;code&gt;NOT VALID&lt;/code&gt; として作成された外部キーまたはチェック制約を検証します。制約がすでに有効としてマークされている場合は、何も起こりません。（このコマンドの有用性については、下の「&lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;注意」を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="6d527b3923e336e8d7e873c75f29f0a2a678c450" translate="yes" xml:space="preserve">
          <source>This format option is used for importing and exporting the Comma Separated Value (&lt;code&gt;CSV&lt;/code&gt;) file format used by many other programs, such as spreadsheets. Instead of the escaping rules used by PostgreSQL's standard text format, it produces and recognizes the common CSV escaping mechanism.</source>
          <target state="translated">このフォーマットオプションは、スプレッドシートなど、他の多くのプログラムで使用されるカンマ区切り値（ &lt;code&gt;CSV&lt;/code&gt; ）ファイルフォーマットのインポートおよびエクスポートに使用されます。PostgreSQLの標準テキスト形式で使用されるエスケープルールの代わりに、一般的なCSVエスケープメカニズムを生成および認識します。</target>
        </trans-unit>
        <trans-unit id="792a63854d692e136337a8efffc52744faba871f" translate="yes" xml:space="preserve">
          <source>This function accepts, but does not require, the VARIADIC keyword. It tolerates both integer and numeric arguments:</source>
          <target state="translated">この関数は、VARIADIC キーワードを受け付けますが、必要ありません。これは、整数と数値の両方の引数を許容します。</target>
        </trans-unit>
        <trans-unit id="384addc1a1dba581b09ffbc6f99227a9381c9da3" translate="yes" xml:space="preserve">
          <source>This function applies the XSL stylesheet to the document and returns the transformed result. The &lt;code&gt;paramlist&lt;/code&gt; is a list of parameter assignments to be used in the transformation, specified in the form &lt;code&gt;a=1,b=2&lt;/code&gt;. Note that the parameter parsing is very simple-minded: parameter values cannot contain commas!</source>
          <target state="translated">この関数は、XSLスタイルシートをドキュメントに適用し、変換された結果を返します。 &lt;code&gt;paramlist&lt;/code&gt; はフォームで指定された変換で使用されるパラメータの割り当てのリストであり、 &lt;code&gt;a=1,b=2&lt;/code&gt; 。パラメータの解析は非常に単純であることに注意してください。パラメータ値にカンマを含めることはできません！</target>
        </trans-unit>
        <trans-unit id="0ee207b4a33861c6094ba8a46213a951afdbd72c" translate="yes" xml:space="preserve">
          <source>This function calculates the Levenshtein distance between two strings:</source>
          <target state="translated">この関数は、2つの文字列間のリーベンシュタイン距離を計算します。</target>
        </trans-unit>
        <trans-unit id="c2569b9ec2f2f240b538364988cd2b660c7bc809" translate="yes" xml:space="preserve">
          <source>This function calculates the metaphone code of an input string:</source>
          <target state="translated">この関数は、入力文字列のメタフォンコードを計算します。</target>
        </trans-unit>
        <trans-unit id="b833dadc47320ce5093b7875a4e223019bb7f287" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;cover density&lt;/em&gt; ranking for the given document vector and query, as described in Clarke, Cormack, and Tudhope's &quot;Relevance Ranking for One to Three Term Queries&quot; in the journal &quot;Information Processing and Management&quot;, 1999. Cover density is similar to &lt;code&gt;ts_rank&lt;/code&gt; ranking except that the proximity of matching lexemes to each other is taken into consideration.</source>
          <target state="translated">この関数は、Clarke、Cormack、およびTudhopeのジャーナル「Information Processing and Management」（1999）の「1〜3項クエリの関連性ランキング」で説明されているように、指定されたドキュメントベクトルとクエリの&lt;em&gt;カバー密度&lt;/em&gt;ランキングを計算します。カバー密度は類似しています &lt;code&gt;ts_rank&lt;/code&gt; 互いに整合語彙素の近傍を考慮することを除いてランキング。</target>
        </trans-unit>
        <trans-unit id="83d7f3c8b4315f521db79931ac5b0419f7f02e44" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID but uses a random multicast MAC address instead of the real MAC address of the computer.</source>
          <target state="translated">この関数はバージョン 1 UUID を生成しますが、コンピュータの実 MAC アドレスの代わりにランダムなマルチキャスト MAC アドレスを使用します。</target>
        </trans-unit>
        <trans-unit id="0d47dfa9e9b8d5b7fbb04b1e480b39cea1dce637" translate="yes" xml:space="preserve">
          <source>This function generates a version 1 UUID. This involves the MAC address of the computer and a time stamp. Note that UUIDs of this kind reveal the identity of the computer that created the identifier and the time at which it did so, which might make it unsuitable for certain security-sensitive applications.</source>
          <target state="translated">この関数は、バージョン1のUUIDを生成します。これには、コンピュータのMACアドレスとタイムスタンプが含まれます。この種の UUUID は、識別子を作成したコンピュータの身元とそれを作成した時刻を明らかにするので、特定のセキュリティに敏感なアプリケーションには不向きである可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0487e417e0c4d9dd43a18530572f4217e42f12de" translate="yes" xml:space="preserve">
          <source>This function generates a version 3 UUID in the given namespace using the specified input name. The namespace should be one of the special constants produced by the &lt;code&gt;uuid_ns_*()&lt;/code&gt; functions shown in &lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;Table F.33&lt;/a&gt;. (It could be any UUID in theory.) The name is an identifier in the selected namespace.</source>
          <target state="translated">この関数は、指定された入力名を使用して、指定された名前空間にバージョン3のUUIDを生成します。名前空間は、&lt;a href=&quot;uuid-ossp#UUID-OSSP-CONSTANTS&quot;&gt;表F.33に&lt;/a&gt;示す &lt;code&gt;uuid_ns_*()&lt;/code&gt; 関数によって生成される特別な定数の1つである必要があります。（理論的には任意のUUIDである可能性があります。）名前は、選択したネームスペースの識別子です。</target>
        </trans-unit>
        <trans-unit id="815458cef4730e8a9276e3ff8e0d57eb7d786adf" translate="yes" xml:space="preserve">
          <source>This function generates a version 4 UUID, which is derived entirely from random numbers.</source>
          <target state="translated">この関数は、バージョン 4 の UUID を生成します。</target>
        </trans-unit>
        <trans-unit id="70e04d40259f3b4e398eaecf4565ce5668726dbd" translate="yes" xml:space="preserve">
          <source>This function generates a version 5 UUID, which works like a version 3 UUID except that SHA-1 is used as a hashing method. Version 5 should be preferred over version 3 because SHA-1 is thought to be more secure than MD5.</source>
          <target state="translated">この関数はバージョン 5 の UUID を生成します。これはバージョン 3 の UUID と同じように動作しますが、SHA-1 がハッシュメソッドとして使用されます。SHA-1 は MD5 よりも安全だと考えられているため、バージョン 3 よりもバージョン 5 の方が望ましいでしょう。</target>
        </trans-unit>
        <trans-unit id="e0a3bf72d056e543baff831854a2b9328ece5e35" translate="yes" xml:space="preserve">
          <source>This function is described in &lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;Table 9.62&lt;/a&gt;.</source>
          <target state="translated">この関数については、&lt;a href=&quot;functions-srf#FUNCTIONS-SRF-SUBSCRIPTS&quot;&gt;表9.62で&lt;/a&gt;説明します。</target>
        </trans-unit>
        <trans-unit id="c9a6e7f01cec14b42f0b87924ed8025472ae1b3d" translate="yes" xml:space="preserve">
          <source>This function is really useful only if you have more than one trusted CA certificate in your server's certificate authority file, or if this CA has issued some intermediate certificate authority certificates.</source>
          <target state="translated">この関数は、サーバの証明書権限ファイルに複数の信頼できる CA 証明書がある場合や、この CA が中間の証明書権限証明書を発行している場合にのみ有用です。</target>
        </trans-unit>
        <trans-unit id="5b1d41d04bdf06be2e37d1f0ae8845458954a418" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">この関数には、シーケンスに対する &lt;code&gt;UPDATE&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="e39f1ca89945df262cf69293c102551266551425" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the last used sequence.</source>
          <target state="translated">この関数には、最後に使用されたシーケンスに対する &lt;code&gt;USAGE&lt;/code&gt; または &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="9f01c920de003b371748d82ceb88ff4c45aff8e2" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;SELECT&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">この関数には、シーケンスに対する &lt;code&gt;USAGE&lt;/code&gt; または &lt;code&gt;SELECT&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="67164ea85a2954ef16cf5fcf220bb12c3b615043" translate="yes" xml:space="preserve">
          <source>This function requires &lt;code&gt;USAGE&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; privilege on the sequence.</source>
          <target state="translated">この関数には、シーケンスに対する &lt;code&gt;USAGE&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; 特権が必要です。</target>
        </trans-unit>
        <trans-unit id="7e54a0efd46907c22c610b8b23cccd57e0bcbc37" translate="yes" xml:space="preserve">
          <source>This function requires lexeme positional information to perform its calculation. Therefore, it ignores any &amp;ldquo;stripped&amp;rdquo; lexemes in the &lt;code&gt;tsvector&lt;/code&gt;. If there are no unstripped lexemes in the input, the result will be zero. (See &lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;Section 12.4.1&lt;/a&gt; for more information about the &lt;code&gt;strip&lt;/code&gt; function and positional information in &lt;code&gt;tsvector&lt;/code&gt;s.)</source>
          <target state="translated">この関数は、計算を実行するために語彙素の位置情報を必要とします。したがって、 &lt;code&gt;tsvector&lt;/code&gt; の「取り除かれた」語彙素は無視されます。入力にストリップされていない語彙素がない場合、結果はゼロになります。（ &lt;code&gt;tsvector&lt;/code&gt; の &lt;code&gt;strip&lt;/code&gt; 関数と位置情報の詳細については、&lt;a href=&quot;textsearch-features#TEXTSEARCH-MANIPULATE-TSVECTOR&quot;&gt;セクション12.4.1&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="c1856db892a00b2e43b297b0dbc4109fce353620" translate="yes" xml:space="preserve">
          <source>This function returns a value that can be approximately understood as the greatest similarity between the first string and any substring of the second string. However, this function does not add padding to the boundaries of the extent. Thus, the number of additional characters present in the second string is not considered, except for the mismatched word boundaries.</source>
          <target state="translated">この関数は、第1の文字列と第2の文字列の任意の部分文字列との間の最大の類似度としておおよそ理解できる値を返します。しかし、この関数は、エクステントの境界にパディングを追加しない。したがって、不一致の単語の境界を除いて、2番目の文字列に存在する追加の文字数は考慮されません。</target>
        </trans-unit>
        <trans-unit id="45aa18780b259bc2744ab8ff0666ff85306321c0" translate="yes" xml:space="preserve">
          <source>This function returns multiple values separated by the specified separator, for example &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; if separator is &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">この関数が返す複数の値は、例えば、指定されたセパレータで分離された &lt;code&gt;Value 1,Value 2,Value 3&lt;/code&gt; セパレータがある場合 &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92a46b380193cb9c54f2eb12d510b84b0bf579e" translate="yes" xml:space="preserve">
          <source>This function returns the value of the specified field in the certificate subject, or NULL if the field is not present. Field names are string constants that are converted into ASN1 object identifiers using the OpenSSL object database. The following values are acceptable:</source>
          <target state="translated">この関数は、証明書のサブジェクトで指定されたフィールドの値を返します。フィールド名は、OpenSSL オブジェクトデータベースを使用して ASN1 オブジェクト識別子に変換される文字列定数です。以下の値を使用することができます。</target>
        </trans-unit>
        <trans-unit id="50cb6130584a2ccc2fd56083455360b1df842976" translate="yes" xml:space="preserve">
          <source>This function should be called with the same arguments as the return attributes of &lt;code&gt;heap_page_items&lt;/code&gt;.</source>
          <target state="translated">この関数は、 &lt;code&gt;heap_page_items&lt;/code&gt; の戻り属性と同じ引数で呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="3bf22c93b0d832b9656f660c278a124c39df4dd9" translate="yes" xml:space="preserve">
          <source>This function terminates backup mode and performs an automatic switch to the next WAL segment. The reason for the switch is to arrange for the last WAL segment written during the backup interval to be ready to archive.</source>
          <target state="translated">この機能はバックアップモードを終了し、次の WAL セグメントへの自動切り替えを行います。切り替えの理由は、バックアップ間隔の間に書き込まれた最後のWALセグメントをアーカイブの準備ができるようにするためです。</target>
        </trans-unit>
        <trans-unit id="2aad428f96b8431576d3176be3a80d4e1c2a4447" translate="yes" xml:space="preserve">
          <source>This function will be called to initialize dynamic shared memory at the beginning of a parallel scan. &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; will point to at least the number of bytes previously returned by &lt;code&gt;amestimateparallelscan&lt;/code&gt;, and this function may use that amount of space to store whatever data it wishes.</source>
          <target state="translated">この関数は、並列スキャンの開始時に動的共有メモリを初期化するために呼び出されます。&lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt;は、少なくとも &lt;code&gt;amestimateparallelscan&lt;/code&gt; によって以前に返されたバイト数を指します。この関数は、その量のスペースを使用して、必要なデータを格納します。</target>
        </trans-unit>
        <trans-unit id="9031a619f108cfe873afc670225222a731f98ca3" translate="yes" xml:space="preserve">
          <source>This function's intention is to access a table &lt;code&gt;admin.pwds&lt;/code&gt;. But without the &lt;code&gt;SET&lt;/code&gt; clause, or with a &lt;code&gt;SET&lt;/code&gt; clause mentioning only &lt;code&gt;admin&lt;/code&gt;, the function could be subverted by creating a temporary table named &lt;code&gt;pwds&lt;/code&gt;.</source>
          <target state="translated">この関数の目的は、テーブル &lt;code&gt;admin.pwds&lt;/code&gt; にアクセスすることです。しかし、 &lt;code&gt;SET&lt;/code&gt; 句がない場合、または &lt;code&gt;SET&lt;/code&gt; 句で &lt;code&gt;admin&lt;/code&gt; のみが言及されている場合、 &lt;code&gt;pwds&lt;/code&gt; という名前の一時テーブルを作成することで関数を破壊できます。</target>
        </trans-unit>
        <trans-unit id="74eda98e312717a7e3761e1be3fed4cfe413013a" translate="yes" xml:space="preserve">
          <source>This function, if implemented, will be called when a parallel index scan must be restarted. It should reset any shared state set up by &lt;code&gt;aminitparallelscan&lt;/code&gt; such that the scan will be restarted from the beginning.</source>
          <target state="translated">この関数が実装されている場合、並列インデックススキャンを再開する必要があるときに呼び出されます。スキャンが最初から再開されるように、 &lt;code&gt;aminitparallelscan&lt;/code&gt; によってセットアップされたすべての共有状態をリセットする必要があります。</target>
        </trans-unit>
        <trans-unit id="ba0d2d4c762ce91e9a46761e7e3115cef1d26dc7" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks, similarly to &lt;code&gt;psql&lt;/code&gt;'s &lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt;&lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt;&lt;/a&gt;. Conditional expressions are identical to those with &lt;code&gt;\set&lt;/code&gt;, with non-zero values interpreted as true.</source>
          <target state="translated">このコマンドグループは、 &lt;code&gt;psql&lt;/code&gt; の&lt;a href=&quot;app-psql#PSQL-METACOMMAND-IF&quot;&gt; &lt;code&gt;\if&lt;/code&gt; &lt;code&gt;expression&lt;/code&gt; &lt;/a&gt;と同様に、ネスト可能な条件付きブロックを実装します。条件式は &lt;code&gt;\set&lt;/code&gt; と同じで、ゼロ以外の値はtrueと解釈されます。</target>
        </trans-unit>
        <trans-unit id="a86a1c85779a67bdb4c07c083dc8d1a736ba45ad" translate="yes" xml:space="preserve">
          <source>This group of commands implements nestable conditional blocks. A conditional block must begin with an &lt;code&gt;\if&lt;/code&gt; and end with an &lt;code&gt;\endif&lt;/code&gt;. In between there may be any number of &lt;code&gt;\elif&lt;/code&gt; clauses, which may optionally be followed by a single &lt;code&gt;\else&lt;/code&gt; clause. Ordinary queries and other types of backslash commands may (and usually do) appear between the commands forming a conditional block.</source>
          <target state="translated">このコマンドのグループは、ネスト可能な条件付きブロックを実装します。条件付きブロックは、 &lt;code&gt;\if&lt;/code&gt; 始まり、 &lt;code&gt;\endif&lt;/code&gt; 終わる必要があります。その間には任意の数の &lt;code&gt;\elif&lt;/code&gt; 句があり、その後にオプションで単一の &lt;code&gt;\else&lt;/code&gt; 句を続けることができます。通常のクエリや他のタイプのバックスラッシュコマンドは、条件付きブロックを形成するコマンドの間に表示される場合があります（通常は表示されます）。</target>
        </trans-unit>
        <trans-unit id="0b11efb2c7cb913b726605094c75fda2e8cad938" translate="yes" xml:space="preserve">
          <source>This happens because the system cannot decide which of the several possible &lt;code&gt;~&lt;/code&gt; operators should be preferred. We can help it out with an explicit cast:</source>
          <target state="translated">これは、システムが複数の &lt;code&gt;~&lt;/code&gt; 演算子のどれを優先するかを決定できないために発生します。明示的なキャストでそれを助けることができます：</target>
        </trans-unit>
        <trans-unit id="1adefa35377cadd1c8a75aec2fb42a29f31a0dd0" translate="yes" xml:space="preserve">
          <source>This has the same effect as casting each expression to the array element type individually. For more on casting, see &lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;Section 4.2.9&lt;/a&gt;.</source>
          <target state="translated">これは、各式を配列要素型に個別にキャストするのと同じ効果があります。キャストの詳細については、&lt;a href=&quot;sql-expressions#SQL-SYNTAX-TYPE-CASTS&quot;&gt;セクション4.2.9を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a60511ea52748a75870fb82ff05a5c564394ceb2" translate="yes" xml:space="preserve">
          <source>This heuristic can be overridden, forcing the server to use either generic or custom plans, by setting &lt;code&gt;plan_cache_mode&lt;/code&gt; to &lt;code&gt;force_generic_plan&lt;/code&gt; or &lt;code&gt;force_custom_plan&lt;/code&gt; respectively. This setting is primarily useful if the generic plan's cost estimate is badly off for some reason, allowing it to be chosen even though its actual cost is much more than that of a custom plan.</source>
          <target state="translated">このヒューリスティックは上書きでき、サーバーに一般プランまたはカスタムプランのいずれかを使用するように強制するには、 &lt;code&gt;plan_cache_mode&lt;/code&gt; を &lt;code&gt;force_generic_plan&lt;/code&gt; または &lt;code&gt;force_custom_plan&lt;/code&gt; にそれぞれ設定します。この設定は主に、何らかの理由でジェネリックプランのコスト見積もりが大幅にオフになっている場合に役立ちます。これにより、実際のコストがカスタムプランのコストよりはるかに高くても選択できます。</target>
        </trans-unit>
        <trans-unit id="3ceb81116f5e1034358e4c68c702f99fa463a7e9" translate="yes" xml:space="preserve">
          <source>This implies that if a table is not otherwise vacuumed, autovacuum will be invoked on it approximately once every &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; minus &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; transactions. For tables that are regularly vacuumed for space reclamation purposes, this is of little importance. However, for static tables (including tables that receive inserts, but no updates or deletes), there is no need to vacuum for space reclamation, so it can be useful to try to maximize the interval between forced autovacuums on very large static tables. Obviously one can do this either by increasing &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; or decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt;.</source>
          <target state="translated">これは、テーブルが他の方法でバキュームされていない場合、 &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; から &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; トランザクションを差し引いたおおよそ1回ごとに、autovacuumが呼び出されることを意味します。スペース再利用の目的で定期的にバキュームされるテーブルの場合、これはほとんど重要ではありません。ただし、静的テーブル（挿入を受け取るが更新や削除は受けないテーブルを含む）の場合、スペースの再利用のためにバキュームを行う必要がないため、非常に大きな静的テーブルで強制自動バキュームの間隔を最大化することを試みると便利です。もちろん1は増加のいずれかによってこれを行うことができます &lt;code&gt;autovacuum_freeze_max_age&lt;/code&gt; または減少 &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; をします。</target>
        </trans-unit>
        <trans-unit id="963c171b1310567729b0c667a3982a8159857c0a" translate="yes" xml:space="preserve">
          <source>This includes issues caused by the comparison rules of operating system collations changing. Comparisons of datums of a collatable type like &lt;code&gt;text&lt;/code&gt; must be immutable (just as all comparisons used for B-Tree index scans must be immutable), which implies that operating system collation rules must never change. Though rare, updates to operating system collation rules can cause these issues. More commonly, an inconsistency in the collation order between a master server and a standby server is implicated, possibly because the &lt;em&gt;major&lt;/em&gt; operating system version in use is inconsistent. Such inconsistencies will generally only arise on standby servers, and so can generally only be detected on standby servers.</source>
          <target state="translated">これには、オペレーティングシステムの照合順序の変更に関する比較ルールによって引き起こされる問題が含まれます。 &lt;code&gt;text&lt;/code&gt; などの照合可能なタイプのデータの比較は不変でなければなりません（Bツリーインデックススキャンに使用されるすべての比較が不変でなければならないのと同じように）。これは、オペレーティングシステムの照合ルールが変更されないことを意味します。まれですが、オペレーティングシステムの照合ルールを更新すると、これらの問題が発生する可能性があります。より一般的には、マスターサーバーとスタンバイサーバー間の照合順序の不整合が関係しています。これは、使用中のオペレーティングシステムの&lt;em&gt;メジャー&lt;/em&gt;バージョンに不整合があるためと考えられます。このような不整合は通常、スタンバイサーバーでのみ発生するため、スタンバイサーバーでのみ検出できます。</target>
        </trans-unit>
        <trans-unit id="a867951badfb08df8a9bb92137e4c1059d9fe31b" translate="yes" xml:space="preserve">
          <source>This indicates that the &lt;code&gt;postgres&lt;/code&gt; process has been terminated due to memory pressure. Although existing database connections will continue to function normally, no new connections will be accepted. To recover, PostgreSQL will need to be restarted.</source>
          <target state="translated">これは、メモリの圧力が原因で &lt;code&gt;postgres&lt;/code&gt; プロセスが終了したことを示しています。既存のデータベース接続は引き続き正常に機能しますが、新しい接続は受け入れられません。回復するには、PostgreSQLを再起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a372cfe5f8eb7d4853999840a603c1c28fd5394" translate="yes" xml:space="preserve">
          <source>This indicates that the most common combination of city and state is Washington in DC, with actual frequency (in the sample) about 0.35%. The base frequency of the combination (as computed from the simple per-column frequencies) is only 0.0027%, resulting in two orders of magnitude under-estimates.</source>
          <target state="translated">これは、都市と州の組み合わせで最も一般的なのは DC のワシントンであり、実際の頻度は(サンプルでは)約 0.35%であることを示しています。この組み合わせのベースとなる頻度(列ごとの単純な頻度から計算された)は0.0027%に過ぎず、結果として2桁の過小評価となっています。</target>
        </trans-unit>
        <trans-unit id="e8fe534ccbaaf548c2b11e2912002e72aef917fa" translate="yes" xml:space="preserve">
          <source>This indicates that there are three combinations of columns that have 33178 distinct values: ZIP code and state; ZIP code and city; and ZIP code, city and state (the fact that they are all equal is expected given that ZIP code alone is unique in this table). On the other hand, the combination of city and state has only 27435 distinct values.</source>
          <target state="translated">これは、33178 個の異なる値を持つ列の組み合わせが 3 つあることを示しています。郵便番号と州、郵便番号と都市、および郵便番号と都市と州です (これらがすべて等しいという事実は、郵便番号だけがこの表の中で一意であることを考えると予想されます)。一方、市と州の組み合わせは、27435 個の明確な値しかありません。</target>
        </trans-unit>
        <trans-unit id="fc1f09ba473095924730f620c845acdb222d24ff" translate="yes" xml:space="preserve">
          <source>This involves changes in the backend function API, which is written in the C programming language. Such changes affect code that references backend functions deep inside the server.</source>
          <target state="translated">これには、C 言語で書かれたバックエンド関数の API の変更が含まれます。このような変更は、サーバの内部でバックエンド関数を参照するコードに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="d9a4686c9a5bfa4e42613a92f3eda7d13c48363f" translate="yes" xml:space="preserve">
          <source>This is OK because the subquery is an independent computation that computes its own aggregate separately from what is happening in the outer query.</source>
          <target state="translated">副問い合わせは外部の問い合わせで起こっていることとは別に独自の集計を計算する独立した計算なので、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="1dcf869a044613b3ca0ecf7baf516a8c7193977f" translate="yes" xml:space="preserve">
          <source>This is a &lt;code&gt;printf&lt;/code&gt;-style string that is output at the beginning of each log line. &lt;code&gt;%&lt;/code&gt; characters begin &amp;ldquo;escape sequences&amp;rdquo; that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes, and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default is &lt;code&gt;'%m [%p] '&lt;/code&gt; which logs a time stamp and the process ID.</source>
          <target state="translated">これは、各ログ行の先頭に出力される &lt;code&gt;printf&lt;/code&gt; スタイルの文字列です。 &lt;code&gt;%&lt;/code&gt; 文字は「エスケープシーケンス」で始まり、以下に概説するようにステータス情報に置き換えられます。認識されないエスケープは無視されます。他の文字はログ行に直接コピーされます。一部のエスケープはセッションプロセスによってのみ認識され、メインサーバープロセスなどのバックグラウンドプロセスによって空として扱われます。ステータス情報は、％の後、オプションの前に数値リテラルを指定することにより、左または右に配置できます。負の値を指定すると、ステータス情報の右側にスペースが埋め込まれ、最小の幅になります。正の値を指定すると、左側に追加されます。パディングは、人間がログファイルを読みやすくするのに役立ちます。このパラメータは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドライン。デフォルトは &lt;code&gt;'%m [%p] '&lt;/code&gt; で、タイムスタンプとプロセスIDが記録されます。</target>
        </trans-unit>
        <trans-unit id="c9227695178f5037e0a0e506aca137b88f68d780" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column should not be matched against the null string (that is, the table-level &lt;code&gt;null&lt;/code&gt; option). This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; option.</source>
          <target state="translated">これはブールオプションです。trueの場合、列の値をnull文字列（つまり、テーブルレベルの &lt;code&gt;null&lt;/code&gt; オプション）と照合しないことを指定します。これは、 &lt;code&gt;COPY&lt;/code&gt; の &lt;code&gt;FORCE_NOT_NULL&lt;/code&gt; オプションに列をリストするのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="bb0f72d78e70cfb965b94342147bb69a1649e537" translate="yes" xml:space="preserve">
          <source>This is a Boolean option. If true, it specifies that values of the column which match the null string are returned as &lt;code&gt;NULL&lt;/code&gt; even if the value is quoted. Without this option, only unquoted values matching the null string are returned as &lt;code&gt;NULL&lt;/code&gt;. This has the same effect as listing the column in &lt;code&gt;COPY&lt;/code&gt;'s &lt;code&gt;FORCE_NULL&lt;/code&gt; option.</source>
          <target state="translated">これはブールオプションです。trueの場合、値が引用されていても、null文字列に一致する列の値が &lt;code&gt;NULL&lt;/code&gt; として返されることを指定します。このオプションを使用しない場合、null文字列に一致する引用符で囲まれていない値のみが &lt;code&gt;NULL&lt;/code&gt; として返されます。これは、 &lt;code&gt;COPY&lt;/code&gt; の &lt;code&gt;FORCE_NULL&lt;/code&gt; オプションに列をリストするのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="952c5f2574e0ab3c7c85d004636983a1260b99d7" translate="yes" xml:space="preserve">
          <source>This is a list of acronyms commonly used in the PostgreSQL documentation and in discussions about PostgreSQL.</source>
          <target state="translated">PostgreSQLのドキュメントやPostgreSQLに関する議論でよく使われる頭字語の一覧です。</target>
        </trans-unit>
        <trans-unit id="64e0bd441cd585968a19e4596d1d9617026fbc74" translate="yes" xml:space="preserve">
          <source>This is a noise word.</source>
          <target state="translated">これはノイズワードです。</target>
        </trans-unit>
        <trans-unit id="022e58efea267ae2631d535b60729a755677e2e4" translate="yes" xml:space="preserve">
          <source>This is a particularly efficient approach when there are few successful tests and many unsuccessful ones.</source>
          <target state="translated">これは、成功したテストが少なく、失敗したテストが多い場合に特に効率的なアプローチです。</target>
        </trans-unit>
        <trans-unit id="b5d2e6129737b2c23b111b25ce903c45a62a32f8" translate="yes" xml:space="preserve">
          <source>This is a sequence of three commands, one per line (although this is not required; more than one command can be on a line, and commands can usefully be split across lines).</source>
          <target state="translated">これは3つのコマンドのシーケンスで、1行に1つです(これは必須ではありませんが、1行に1つ以上のコマンドがあっても構いませんし、コマンドは行をまたいで分割しても構いません)。</target>
        </trans-unit>
        <trans-unit id="450f019da352d6f44183cb5a8fe197731201523e" translate="yes" xml:space="preserve">
          <source>This is a shortcut for setting &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; at once. If you specify this, you cannot specify either of those parameters.</source>
          <target state="translated">これは、 &lt;code&gt;LC_COLLATE&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; を同時に設定するためのショートカットです。指定した場合、どちらのパラメーターも指定できません。</target>
        </trans-unit>
        <trans-unit id="768c3e272a14bb422425810cd204ed41f4ba6629" translate="yes" xml:space="preserve">
          <source>This is a wrapper for the above function that uses &lt;code&gt;,&lt;/code&gt; as the separator.</source>
          <target state="translated">これは、その用途上の関数のラッパーであり &lt;code&gt;,&lt;/code&gt; セパレータとして。</target>
        </trans-unit>
        <trans-unit id="b3c868d4182c583f463c71ff97e781747bf3a03c" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\dp&lt;/code&gt; (&amp;ldquo;display privileges&amp;rdquo;).</source>
          <target state="translated">これは &lt;code&gt;\dp&lt;/code&gt; （「表示権限」）のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="a3bfb72cef070dc11f447b3386a7c2706bac36a5" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;\lo_list&lt;/code&gt;, which shows a list of large objects.</source>
          <target state="translated">これは &lt;code&gt;\lo_list&lt;/code&gt; エイリアスで、ラージオブジェクトのリストを表示します。</target>
        </trans-unit>
        <trans-unit id="78ba8cae4388de88507eba2b7275ccd60b950613" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnatts&lt;/code&gt; values that indicate which table columns this index indexes. For example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the index entries. Key columns come before non-key (included) columns. A zero in this array indicates that the corresponding index attribute is an expression over the table columns, rather than a simple column reference.</source>
          <target state="translated">これは、このインデックスがインデックスを作成するテーブルカラムを示す &lt;code&gt;indnatts&lt;/code&gt; 値の配列です。たとえば、 &lt;code&gt;1 3&lt;/code&gt; の値は、最初と3番目のテーブル列がインデックスエントリを構成することを意味します。キー列は非キー（含まれている）列の前に来ます。この配列のゼロは、対応するインデックス属性が単純な列参照ではなく、テーブル列の式であることを示します。</target>
        </trans-unit>
        <trans-unit id="f5ae302c90a19a0498f7df9c475b24d33cb673e7" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;indnkeyatts&lt;/code&gt; values that store per-column flag bits. The meaning of the bits is defined by the index's access method.</source>
          <target state="translated">これは、列ごとのフラグビットを格納する &lt;code&gt;indnkeyatts&lt;/code&gt; 値の配列です。ビットの意味は、インデックスのアクセス方法によって定義されます。</target>
        </trans-unit>
        <trans-unit id="2fc49bd55fbc5bfa9dea1e28cd18c9a1ca88a7e4" translate="yes" xml:space="preserve">
          <source>This is an array of &lt;code&gt;partnatts&lt;/code&gt; values that indicate which table columns are part of the partition key. For example, a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns make up the partition key. A zero in this array indicates that the corresponding partition key column is an expression, rather than a simple column reference.</source>
          <target state="translated">これは、パーティションキーの一部であるテーブル列を示す &lt;code&gt;partnatts&lt;/code&gt; 値の配列です。たとえば、 &lt;code&gt;1 3&lt;/code&gt; の値は、最初と3番目のテーブル列がパーティションキーを構成することを意味します。この配列のゼロは、対応するパーティションキー列が単純な列参照ではなく式であることを示します。</target>
        </trans-unit>
        <trans-unit id="85cb6ef5ec65368f349e99d1c5b167fcd51b032f" translate="yes" xml:space="preserve">
          <source>This is an example of creating a bloom index:</source>
          <target state="translated">ブルームインデックスの作成例です。</target>
        </trans-unit>
        <trans-unit id="28e7b5364ece8bb74449b25a2f87fdcc6112556a" translate="yes" xml:space="preserve">
          <source>This is backward-compatible syntax for declaring a table &lt;code&gt;WITHOUT OIDS&lt;/code&gt;, creating a table &lt;code&gt;WITH OIDS&lt;/code&gt; is not supported anymore.</source>
          <target state="translated">これは、 &lt;code&gt;WITHOUT OIDS&lt;/code&gt; テーブルを宣言するための下位互換性のある構文であり、 &lt;code&gt;WITH OIDS&lt;/code&gt; テーブルの作成はサポートされなくなりました。</target>
        </trans-unit>
        <trans-unit id="f53c81b1fcb044c5d18d73e6543204df53f672fe" translate="yes" xml:space="preserve">
          <source>This is because a restriction placed in the &lt;code&gt;ON&lt;/code&gt; clause is processed &lt;em&gt;before&lt;/em&gt; the join, while a restriction placed in the &lt;code&gt;WHERE&lt;/code&gt; clause is processed &lt;em&gt;after&lt;/em&gt; the join. That does not matter with inner joins, but it matters a lot with outer joins.</source>
          <target state="translated">これは、 &lt;code&gt;ON&lt;/code&gt; 句に配置された制限は結合の&lt;em&gt;前&lt;/em&gt;に処理され、 &lt;code&gt;WHERE&lt;/code&gt; 句に配置された制限は結合の&lt;em&gt;後&lt;/em&gt;に処理&lt;em&gt;さ&lt;/em&gt;れるためです。これは内部結合では問題になりませんが、外部結合では非常に重要です。</target>
        </trans-unit>
        <trans-unit id="40e68e5962e0de07dffd697e9417724fccc9d63d" translate="yes" xml:space="preserve">
          <source>This is because if A had executed before B, B would have computed the sum 330, not 300, and similarly the other order would have resulted in a different sum computed by A.</source>
          <target state="translated">これは、AがBより先に約定していた場合、Bは300ではなく330の合計を計算していたことになり、同様に他の注文もAが計算した異なる合計になっていたからです。</target>
        </trans-unit>
        <trans-unit id="75b15f8961b465e16b950c107a03d87b532671ad" translate="yes" xml:space="preserve">
          <source>This is commonly used for analysis over hierarchical data; e.g. total salary by department, division, and company-wide total.</source>
          <target state="translated">これは一般的に階層的なデータの分析に使用されます。</target>
        </trans-unit>
        <trans-unit id="c19f8fd7239c9e470394caad32ebd804606ed7b1" translate="yes" xml:space="preserve">
          <source>This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value.</source>
          <target state="translated">これは事実上、デフォルトをnullに設定するのと同じです。結果として、定義されていないデフォルトを削除してもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="5d31603eaa916aca8762159f8bda194ec5b5313c" translate="yes" xml:space="preserve">
          <source>This is equivalent to considering that the lower bound is &amp;ldquo;minus infinity&amp;rdquo;, or the upper bound is &amp;ldquo;plus infinity&amp;rdquo;, respectively. But note that these infinite values are never values of the range's element type, and can never be part of the range. (So there is no such thing as an inclusive infinite bound &amp;mdash; if you try to write one, it will automatically be converted to an exclusive bound.)</source>
          <target state="translated">これは、それぞれ下限が「マイナス無限大」、または上限が「プラス無限大」であると考えるのと同じです。ただし、これらの無限値が範囲の要素タイプの値になることはなく、範囲の一部になることもありません。（したがって、包含的な無限の境界などはありません&amp;mdash;境界を記述しようとすると、自動的に排他的な境界に変換されます。）</target>
        </trans-unit>
        <trans-unit id="32b4366f2bb306ae39f6ae123b6e52ebbaf45e22" translate="yes" xml:space="preserve">
          <source>This is false for internal languages (such as SQL) and true for user-defined languages. Currently, pg_dump still uses this to determine which languages need to be dumped, but this might be replaced by a different mechanism in the future.</source>
          <target state="translated">これは内部言語(SQLなど)ではfalseで、ユーザ定義言語ではtrueです。現在のところ、pg_dumpはどの言語をダンプする必要があるかを決定するためにこれを使用していますが、将来的には別のメカニズムに置き換えられるかもしれません。</target>
        </trans-unit>
        <trans-unit id="909703c85505cd16ac2e43cb68b897cd4647ad6b" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;code&gt;dow&lt;/code&gt; except for Sunday. This matches the ISO 8601 day of the week numbering.</source>
          <target state="translated">これは日曜日を除いて &lt;code&gt;dow&lt;/code&gt; と同じです。これは、ISO 8601の曜日番号と一致します。</target>
        </trans-unit>
        <trans-unit id="774c866f144b866c3887ecc3ab9eba1546c6554f" translate="yes" xml:space="preserve">
          <source>This is more useful if the expressions in the select list return varying results. For example, you could call a function this way:</source>
          <target state="translated">これは、セレクトリスト内の式がさまざまな結果を返す場合に便利です。例えば、このように関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f9f2d8c3b689196c5d8ec8d4f5df566ae69faf2b" translate="yes" xml:space="preserve">
          <source>This is needed to avoid syntactic ambiguity. An example is:</source>
          <target state="translated">これは構文の曖昧さを避けるために必要です。例としては</target>
        </trans-unit>
        <trans-unit id="9c677b482c1d51ad6809dd70f3013fed740bc81c" translate="yes" xml:space="preserve">
          <source>This is not as efficient as a partial index on the &lt;code&gt;amount&lt;/code&gt; column would be, since the system has to scan the entire index. Yet, if there are relatively few unbilled orders, using this partial index just to find the unbilled orders could be a win.</source>
          <target state="translated">これは、システムがインデックス全体をスキャンする必要があるため、 &lt;code&gt;amount&lt;/code&gt; 列の部分的なインデックスほど効率的ではありません。それでも、未請求の注文が比較的少ない場合は、この部分インデックスを使用して未請求の注文を見つけるだけで成功する可能性があります。</target>
        </trans-unit>
        <trans-unit id="30d2d55c459297e19ddd1f07d0c1ebe65fd3794d" translate="yes" xml:space="preserve">
          <source>This is not especially useful since it has exactly the same result as the more conventional</source>
          <target state="translated">と全く同じ結果になるので、これは特に有用ではありません。</target>
        </trans-unit>
        <trans-unit id="0322eac9bb3931b0da02327d4f96591febd87604" translate="yes" xml:space="preserve">
          <source>This is only a conceptual model. The join is usually performed in a more efficient manner than actually comparing each possible pair of rows, but this is invisible to the user.</source>
          <target state="translated">これは概念的なモデルに過ぎません。結合は通常、可能性のある各行のペアを実際に比較するよりも効率的な方法で実行されますが、これはユーザーには見えません。</target>
        </trans-unit>
        <trans-unit id="b8169801d92724560db318d90118c63ada145ffc" translate="yes" xml:space="preserve">
          <source>This is quite a different problem: how to estimate the selectivity when the value is &lt;em&gt;not&lt;/em&gt; in the MCV list. The approach is to use the fact that the value is not in the list, combined with the knowledge of the frequencies for all of the MCVs:</source>
          <target state="translated">これはまったく別の問題です。値がMCVリストに&lt;em&gt;ない&lt;/em&gt;場合に選択性を推定する方法です。アプローチは、値がリストにないという事実を、すべてのMCVの周波数の知識と組み合わせて使用​​することです。</target>
        </trans-unit>
        <trans-unit id="f0d520c606037b870becb6e588d6da7dff0960ba" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;digest()&lt;/code&gt; but the hash can only be recalculated knowing the key. This prevents the scenario of someone altering data and also changing the hash to match.</source>
          <target state="translated">これは &lt;code&gt;digest()&lt;/code&gt; に似ていますが、ハッシュはキーを知っている場合にのみ再計算できます。これにより、誰かがデータを変更したり、一致するようにハッシュを変更したりするシナリオを防ぎます。</target>
        </trans-unit>
        <trans-unit id="53bd3331f309cfd6d8eeacec7a8068398ef70fcf" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Fast Shutdown&lt;/em&gt; mode. The server disallows new connections and sends all existing server processes SIGTERM, which will cause them to abort their current transactions and exit promptly. It then waits for all server processes to exit and finally shuts down. If the server is in online backup mode, backup mode will be terminated, rendering the backup useless.</source>
          <target state="translated">これは&lt;em&gt;高速シャットダウン&lt;/em&gt;モードです。サーバーは新しい接続を拒否し、既存のすべてのサーバープロセスにSIGTERMを送信します。これにより、現在のトランザクションが中止され、即座に終了します。次に、すべてのサーバープロセスが終了するまで待機し、最後にシャットダウンします。サーバーがオンラインバックアップモードの場合、バックアップモードは終了し、バックアップは使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="9519f8334dda9bed264446e6f4818cc6899e6c5a" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Immediate Shutdown&lt;/em&gt; mode. The server will send SIGQUIT to all child processes and wait for them to terminate. If any do not terminate within 5 seconds, they will be sent SIGKILL. The master server process exits as soon as all child processes have exited, without doing normal database shutdown processing. This will lead to recovery (by replaying the WAL log) upon next start-up. This is recommended only in emergencies.</source>
          <target state="translated">これは&lt;em&gt;即時シャットダウン&lt;/em&gt;モードです。サーバーは、すべての子プロセスにSIGQUITを送信し、それらが終了するのを待ちます。 5秒以内に終了しない場合は、SIGKILLが送信されます。マスターサーバープロセスは、通常のデータベースシャットダウン処理を行わずに、すべての子プロセスが終了するとすぐに終了します。これにより、次回の起動時に（WALログを再生することにより）回復します。これは緊急時にのみ推奨されます。</target>
        </trans-unit>
        <trans-unit id="64dec29096a90e2ac7b66bae5da2edc5f6e90310" translate="yes" xml:space="preserve">
          <source>This is the &lt;em&gt;Smart Shutdown&lt;/em&gt; mode. After receiving SIGTERM, the server disallows new connections, but lets existing sessions end their work normally. It shuts down only after all of the sessions terminate. If the server is in online backup mode, it additionally waits until online backup mode is no longer active. While backup mode is active, new connections will still be allowed, but only to superusers (this exception allows a superuser to connect to terminate online backup mode). If the server is in recovery when a smart shutdown is requested, recovery and streaming replication will be stopped only after all regular sessions have terminated.</source>
          <target state="translated">これは&lt;em&gt;スマートシャットダウン&lt;/em&gt;モードです。 SIGTERMを受信した後、サーバーは新しい接続を許可しませんが、既存のセッションは正常に作業を終了できます。すべてのセッションが終了した後でのみシャットダウンします。サーバーがオンラインバックアップモードの場合、さらにオンラインバックアップモードがアクティブでなくなるまで待機します。バックアップモードがアクティブでも新しい接続は許可されますが、スーパーユーザーのみが許可されます（この例外により、スーパーユーザーはオンラインバックアップモードを終了するために接続できます）。スマートシャットダウンが要求されたときにサーバーが回復中の場合、すべての通常のセッションが終了した後にのみ、回復とストリーミングレプリケーションが停止します。</target>
        </trans-unit>
        <trans-unit id="92dd6728f5fbf932d72131603602b0280b7afbb6" translate="yes" xml:space="preserve">
          <source>This is the amount of time to wait on a lock before checking to see if there is a deadlock condition. The check for deadlock is relatively expensive, so the server doesn't run it every time it waits for a lock. We optimistically assume that deadlocks are not common in production applications and just wait on the lock for a while before checking for a deadlock. Increasing this value reduces the amount of time wasted in needless deadlock checks, but slows down reporting of real deadlock errors. If this value is specified without units, it is taken as milliseconds. The default is one second (&lt;code&gt;1s&lt;/code&gt;), which is probably about the smallest value you would want in practice. On a heavily loaded server you might want to raise it. Ideally the setting should exceed your typical transaction time, so as to improve the odds that a lock will be released before the waiter decides to check for deadlock. Only superusers can change this setting.</source>
          <target state="translated">これは、デッドロック状態があるかどうかを確認する前に、ロックを待機する時間です。デッドロックのチェックは比較的コストがかかるため、サーバーはロックを待機するたびにそれを実行するわけではありません。実動アプリケーションではデッドロックは一般的ではないと楽観的に想定しており、デッドロックをチェックする前にしばらくロックを待機します。この値を増やすと、不必要なデッドロックチェックに費やされる時間は短縮されますが、実際のデッドロックエラーの報告は遅くなります。この値が単位なしで指定されている場合、ミリ秒と見なされます。デフォルトは1秒（ &lt;code&gt;1s&lt;/code&gt; ）、これはおそらく実際に必要な最小値です。負荷の高いサーバーでは、サーバーを引き上げることができます。理想的には、設定が通常のトランザクション時間を超えて、ウェイターがデッドロックのチェックを決定する前にロックが解放される可能性を高める必要があります。この設定を変更できるのはスーパーユーザーだけです。</target>
        </trans-unit>
        <trans-unit id="66c8088759f9087b738e1b70d1cf37c8a1aae852" translate="yes" xml:space="preserve">
          <source>This is the default format.</source>
          <target state="translated">これがデフォルトのフォーマットです。</target>
        </trans-unit>
        <trans-unit id="3ce226ef1a13e0c7b419788ac5e73819bf180bcb" translate="yes" xml:space="preserve">
          <source>This is the generic &amp;ldquo;I couldn't find a server to talk to&amp;rdquo; failure. It looks like the above when TCP/IP communication is attempted. A common mistake is to forget to configure the server to allow TCP/IP connections.</source>
          <target state="translated">これは、「対話するサーバーが見つからなかった」という一般的なエラーです。TCP / IP通信を試みると上記のようになります。よくある間違いは、TCP / IP接続を許可するようにサーバーを構成するのを忘れることです。</target>
        </trans-unit>
        <trans-unit id="7a73a092e455b0519a284ead127b2916ee3a2346" translate="yes" xml:space="preserve">
          <source>This is the interval between updates to &lt;code&gt;autoprewarm.blocks&lt;/code&gt;. The default is 300 seconds. If set to 0, the file will not be dumped at regular intervals, but only when the server is shut down.</source>
          <target state="translated">これは &lt;code&gt;autoprewarm.blocks&lt;/code&gt; の更新間隔です。デフォルトは300秒です。0に設定すると、ファイルは定期的にダンプされず、サーバーがシャットダウンされたときにのみダンプされます。</target>
        </trans-unit>
        <trans-unit id="7a967763949218bdd201f81e3734208d5693135c" translate="yes" xml:space="preserve">
          <source>This is the most secure of the currently provided methods, but it is not supported by older client libraries.</source>
          <target state="translated">これは現在提供されているメソッドの中で最も安全ですが、古いクライアントライブラリではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="281ee2a6d6b295f0c605c272cbd3a317a0476533" translate="yes" xml:space="preserve">
          <source>This is the price one pays for extensibility.</source>
          <target state="translated">これは、拡張性のために1つが支払う価格です。</target>
        </trans-unit>
        <trans-unit id="e49d24e044b41980e036610f5fc7a5e4be7955e6" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pg_relpages(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">これは &lt;code&gt;pg_relpages(regclass)&lt;/code&gt; と同じですが、ターゲットリレーションがTEXTとして指定されている点が異なります。この関数は、これまでの下位互換性のために残されており、将来のリリースで廃止される予定です。</target>
        </trans-unit>
        <trans-unit id="64132a4b93c0dbcab91f77d1ac58e1693be7385b" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstatindex(regclass)&lt;/code&gt;, except that the target index is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">これは &lt;code&gt;pgstatindex(regclass)&lt;/code&gt; と同じですが、ターゲットインデックスがTEXTとして指定されている点が異なります。この関数は、これまでの下位互換性のために残されており、将来のリリースで廃止される予定です。</target>
        </trans-unit>
        <trans-unit id="54441c2148265c644b6e2c6b5762a5242346cb3d" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;pgstattuple(regclass)&lt;/code&gt;, except that the target relation is specified as TEXT. This function is kept because of backward-compatibility so far, and will be deprecated in some future release.</source>
          <target state="translated">これは &lt;code&gt;pgstattuple(regclass)&lt;/code&gt; と同じですが、ターゲットリレーションがTEXTとして指定されている点が異なります。この関数は、これまでの下位互換性のために残されており、将来のリリースで廃止される予定です。</target>
        </trans-unit>
        <trans-unit id="ece1f9875ce6ffc21558f8024d23103c3c5eb710" translate="yes" xml:space="preserve">
          <source>This is the same example using normalized ranking:</source>
          <target state="translated">これは、正規化されたランキングを使用した例と同じです。</target>
        </trans-unit>
        <trans-unit id="b095631465e3260d63a74afe0d97ae2d96edf684" translate="yes" xml:space="preserve">
          <source>This is the same query as above, but we added a &lt;code&gt;LIMIT&lt;/code&gt; so that not all the rows need be retrieved, and the planner changed its mind about what to do. Notice that the total cost and row count of the Index Scan node are shown as if it were run to completion. However, the Limit node is expected to stop after retrieving only a fifth of those rows, so its total cost is only a fifth as much, and that's the actual estimated cost of the query. This plan is preferred over adding a Limit node to the previous plan because the Limit could not avoid paying the startup cost of the bitmap scan, so the total cost would be something over 25 units with that approach.</source>
          <target state="translated">これは上記と同じクエリですが、すべての行を取得する必要がないように &lt;code&gt;LIMIT&lt;/code&gt; を追加し、プランナは何をすべきかについて考えを変えました。インデックススキャンノードの合計コストと行数が、実行が完了したかのように表示されていることに注意してください。ただし、Limitノードはそれらの行の5分の1のみを取得した後に停止すると予想されるため、その合計コストは5分の1にすぎず、これがクエリの実際の推定コストです。この計画は、以前の計画に制限ノードを追加するよりも優先されます。制限ではビットマップスキャンの開始コストの支払いを回避できなかったため、そのアプローチでは合計コストが25ユニットを超えるためです。</target>
        </trans-unit>
        <trans-unit id="94cb90e2972cc12877867d7980fc980b09691ec3" translate="yes" xml:space="preserve">
          <source>This is transformed by the parser to effectively become:</source>
          <target state="translated">これをパーサーで変換して事実上のものになります。</target>
        </trans-unit>
        <trans-unit id="a05aa8321906cf1c74f9a81ad06926d222bf1181" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a handler function.</source>
          <target state="translated">これは、外部データラッパーがもはやハンドラ関数を持たないことを指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d0dd5b48b4b716a9453020ad47edd41a0fc5866a" translate="yes" xml:space="preserve">
          <source>This is used to specify that the foreign-data wrapper should no longer have a validator function.</source>
          <target state="translated">これは、外部データラッパーがバリデータ機能を持たなくなることを指定するために使われます。</target>
        </trans-unit>
        <trans-unit id="d30d7211e06d7778bc4cd17adf8c8ca724a370e3" translate="yes" xml:space="preserve">
          <source>This is what you are most likely to get if you succeed in contacting the server, but it does not want to talk to you. As the message suggests, the server refused the connection request because it found no matching entry in its &lt;code&gt;pg_hba.conf&lt;/code&gt; configuration file.</source>
          <target state="translated">これは、サーバーへの接続に成功した場合に得られる可能性が最も高いものですが、サーバーとの通信は望んでいません。メッセージが示すように、サーバーは &lt;code&gt;pg_hba.conf&lt;/code&gt; 構成ファイルに一致するエントリが見つからなかったため、接続要求を拒否しました。</target>
        </trans-unit>
        <trans-unit id="fa56032fee9f040556b310dd23691f09946834cc" translate="yes" xml:space="preserve">
          <source>This is wrong since it is not clear which child table the key value 200 belongs in.</source>
          <target state="translated">キー値200がどの子テーブルに属しているかが明確ではないので、これは間違っています。</target>
        </trans-unit>
        <trans-unit id="0515e31998ba6bb73d0ddae64599b98492334cc8" translate="yes" xml:space="preserve">
          <source>This is, subtract the null fraction from one for each of the relations, and divide by the maximum of the numbers of distinct values. The number of rows that the join is likely to emit is calculated as the cardinality of the Cartesian product of the two inputs, multiplied by the selectivity:</source>
          <target state="translated">これは、関係のそれぞれについて1からヌル分数を引き、異なる値の最大数で割ったものです。結合が発生しそうな行の数は、2つの入力の直交積のカーディナリティに選択性を掛けたものとして計算されます。</target>
        </trans-unit>
        <trans-unit id="88f72ee86e21efe6631404a3bf422fe90ce0b7b5" translate="yes" xml:space="preserve">
          <source>This key word is ignored.</source>
          <target state="translated">このキーワードは無視されます。</target>
        </trans-unit>
        <trans-unit id="ccf5892ae182b1129c89233a93f9d2dff22e3a50" translate="yes" xml:space="preserve">
          <source>This keyword immediately precedes the declaration of one or two relation names that provide access to the transition relations of the triggering statement.</source>
          <target state="translated">このキーワードは、トリガ文の遷移関係へのアクセスを提供する 1 つまたは 2 つの関係名の宣言の直前にあります。</target>
        </trans-unit>
        <trans-unit id="e080950e112255fe2f612123624be96d15f65967" translate="yes" xml:space="preserve">
          <source>This latter equivalence does not hold exactly when more than two tables appear, because &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than comma. For example &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; is not the same as &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; because the &lt;code&gt;condition&lt;/code&gt; can reference &lt;code&gt;T1&lt;/code&gt; in the first case but not the second.</source>
          <target state="translated">&lt;code&gt;JOIN&lt;/code&gt; はコンマよりも緊密にバインドするため、この後者の等価性は、3つ以上のテーブルが表示される場合は正確に保持されません。例えば &lt;code&gt;FROM T1 CROSS JOIN T2 INNER JOIN T3 ON condition&lt;/code&gt; と同じではない &lt;code&gt;FROM T1, T2 INNER JOIN T3 ON condition&lt;/code&gt; ため &lt;code&gt;condition&lt;/code&gt; 参照できる &lt;code&gt;T1&lt;/code&gt; を第1、第2の場合ではないが。</target>
        </trans-unit>
        <trans-unit id="4445598676898e3b5c713e7c5758010ce357bcd1" translate="yes" xml:space="preserve">
          <source>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of the first non-transaction-control statement in the &lt;em&gt;transaction&lt;/em&gt;, not as of the start of the current statement within the transaction. Thus, successive &lt;code&gt;SELECT&lt;/code&gt; commands within a &lt;em&gt;single&lt;/em&gt; transaction see the same data, i.e., they do not see changes made by other transactions that committed after their own transaction started.</source>
          <target state="translated">このレベルはRead Committedとは異なり、反復可能な読み取りトランザクションのクエリは、トランザクション内の現在のステートメントの開始時ではなく、&lt;em&gt;トランザクション&lt;/em&gt;の最初の非トランザクション制御ステートメントの開始時のスナップショットを参照します。したがって、&lt;em&gt;単一の&lt;/em&gt;トランザクション内の連続する &lt;code&gt;SELECT&lt;/code&gt; コマンドは同じデータを参照します。つまり、独自のトランザクションの開始後にコミットされた他のトランザクションによって行われた変更は参照しません。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b43064679af2be0d9a41eca78e98514d704b879" translate="yes" xml:space="preserve">
          <source>This level of integrity protection using Serializable transactions does not yet extend to hot standby mode (&lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;). Because of that, those using hot standby may want to use Repeatable Read and explicit locking on the master.</source>
          <target state="translated">シリアライズ可能トランザクションを使用したこのレベルの整合性保護は、まだホットスタンバイモード（&lt;a href=&quot;hot-standby&quot;&gt;26.5節&lt;/a&gt;）まで拡張されていません。そのため、ホットスタンバイを使用するユーザーは、マスターで反復可能読み取りと明示的なロックを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="81dc2dc08c39c5d2f9e3dd37d41f417f52e2a9fc" translate="yes" xml:space="preserve">
          <source>This limits the usefulness of the &lt;code&gt;passwordcheck&lt;/code&gt; module, because in that case it can only try to guess the password. For this reason, &lt;code&gt;passwordcheck&lt;/code&gt; is not recommended if your security requirements are high. It is more secure to use an external authentication method such as GSSAPI (see &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt;) than to rely on passwords within the database.</source>
          <target state="translated">この場合、パスワードの推測のみを試行できるため、 &lt;code&gt;passwordcheck&lt;/code&gt; モジュールの有用性が制限されます。このため、セキュリティ要件が高い場合、 &lt;code&gt;passwordcheck&lt;/code&gt; は推奨されません。データベース内のパスワードに依存するよりも、GSSAPI（&lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;第20章を&lt;/a&gt;参照）などの外部認証方法を使用する方が安全です。</target>
        </trans-unit>
        <trans-unit id="1a5e3d694aabd0836b4470958df1839ef5142811" translate="yes" xml:space="preserve">
          <source>This may be more intuitive if you are using &lt;code&gt;pg_ctl&lt;/code&gt; for starting and stopping the server (see &lt;a href=&quot;server-start&quot;&gt;Section 18.3&lt;/a&gt;), so that &lt;code&gt;pg_ctl&lt;/code&gt; would be the sole command you use for managing the database server instance.</source>
          <target state="translated">使用している場合、これは、より直感的かもしれ &lt;code&gt;pg_ctl&lt;/code&gt; （参照サーバーの起動と停止のための&lt;a href=&quot;server-start&quot;&gt;セクション18.3を&lt;/a&gt;）、そのため &lt;code&gt;pg_ctl&lt;/code&gt; データベース・サーバー・インスタンスを管理するために使用する唯一のコマンドとなります。</target>
        </trans-unit>
        <trans-unit id="dfa0eac4f1545a9ddc55a9ceb07c6c1edc0186f1" translate="yes" xml:space="preserve">
          <source>This means that the server was not started, or it was not started where &lt;code&gt;createdb&lt;/code&gt; expected it. Again, check the installation instructions or consult the administrator.</source>
          <target state="translated">これは、サーバーが開始されなかったか、 &lt;code&gt;createdb&lt;/code&gt; が予期した場所でサーバーが開始されなかったことを意味します。再度、インストール手順を確認するか、管理者に相談してください。</target>
        </trans-unit>
        <trans-unit id="ded18d2e27ab98a47b51417474a9c5eeb41e0e40" translate="yes" xml:space="preserve">
          <source>This mechanism prevents unencrypted data from being read from the drives if the drives or the entire computer is stolen. This does not protect against attacks while the file system is mounted, because when mounted, the operating system provides an unencrypted view of the data. However, to mount the file system, you need some way for the encryption key to be passed to the operating system, and sometimes the key is stored somewhere on the host that mounts the disk.</source>
          <target state="translated">このメカニズムは、ドライブやコンピュータ全体が盗まれた場合に、暗号化されていないデータがドライブから読み取られるのを防ぎます。これは、ファイルシステムがマウントされている間は攻撃からは保護されませんが、マウントされるとオペレーティング システムはデータの暗号化されていないビューを提供するためです。しかし、ファイルシステムをマウントするには、暗号化キーをオペレーティングシステムに渡す何らかの方法が必要で、キーはディスクをマウントするホストのどこかに保存されていることもあります。</target>
        </trans-unit>
        <trans-unit id="4541818976374d79642c0f93c22dbb7a713f72ad" translate="yes" xml:space="preserve">
          <source>This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries.</source>
          <target state="translated">このメソッドは、ツリー内の情報を統合します。エントリの集合が与えられると、この関数は、与えられたすべてのエントリを表す新しいインデックスエントリを生成します。</target>
        </trans-unit>
        <trans-unit id="bc385497c58aec7319cf4002de1bf0ca8c1d4cff" translate="yes" xml:space="preserve">
          <source>This method of upgrading can be performed using the built-in logical replication facilities as well as using external logical replication systems such as pglogical, Slony, Londiste, and Bucardo.</source>
          <target state="translated">このアップグレード方法は、pglogical、Slony、Londiste、Bucardoなどの外部論理レプリケーションシステムを使用するだけでなく、組み込みの論理レプリケーション機能を使用して実行することができます。</target>
        </trans-unit>
        <trans-unit id="82b2800cab107f6d05df0ae989ccbd67016a0ee1" translate="yes" xml:space="preserve">
          <source>This might cause zero, one, or many rows to be updated. It is not an error to attempt an update that does not match any rows.</source>
          <target state="translated">これにより、0行、1行、または多数の行が更新される可能性があります。どの行にも一致しない更新を試みてもエラーではありません。</target>
        </trans-unit>
        <trans-unit id="264f830b811a6d6b8c58c36cb7fd806990f75f99" translate="yes" xml:space="preserve">
          <source>This might produce log output such as:</source>
          <target state="translated">これは、次のようなログ出力を生成するかもしれません。</target>
        </trans-unit>
        <trans-unit id="b493978753faced6c574bfe3060740f6644ad55e" translate="yes" xml:space="preserve">
          <source>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user.</source>
          <target state="translated">このモードはどうしても使いたい人のために用意されていますが、必ずしも使うことが推奨されているわけではありません。特に、SQLとメタコマンドを一行に混ぜて実行した場合、経験の浅いユーザには実行順序が必ずしも明確ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="3d9301bd35d933ed8044c02b82956382914754a7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;cube&lt;/code&gt; for representing multidimensional cubes.</source>
          <target state="translated">このモジュールは、多次元 &lt;code&gt;cube&lt;/code&gt; を表すためのデータ型キューブを実装します。</target>
        </trans-unit>
        <trans-unit id="f8e33606e025a4455156d4072de6e226ed4b94f7" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;ltree&lt;/code&gt; for representing labels of data stored in a hierarchical tree-like structure. Extensive facilities for searching through label trees are provided.</source>
          <target state="translated">このモジュールは、階層ツリーのような構造に格納されたデータのラベルを表すためのデータ型 &lt;code&gt;ltree&lt;/code&gt; を実装します。ラベルツリーを検索するための広範な機能が提供されます。</target>
        </trans-unit>
        <trans-unit id="e72760dc721284c431bb3ba272b6dca3b540e0f1" translate="yes" xml:space="preserve">
          <source>This module implements a data type &lt;code&gt;seg&lt;/code&gt; for representing line segments, or floating point intervals. &lt;code&gt;seg&lt;/code&gt; can represent uncertainty in the interval endpoints, making it especially useful for representing laboratory measurements.</source>
          <target state="translated">このモジュールは、データ型の実装 &lt;code&gt;seg&lt;/code&gt; 点間隔を線分を表す、またはフローティングのために。 &lt;code&gt;seg&lt;/code&gt; は区間のエンドポイントの不確実性を表すことができるため、実験室での測定を表すのに特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="2dd33542f64474fba94a46e6b605e9b2299f1bab" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;hstore&lt;/code&gt; data type for storing sets of key/value pairs within a single PostgreSQL value. This can be useful in various scenarios, such as rows with many attributes that are rarely examined, or semi-structured data. Keys and values are simply text strings.</source>
          <target state="translated">このモジュールは、単一のPostgreSQL値内にキー/値ペアのセットを格納するための &lt;code&gt;hstore&lt;/code&gt; データ型を実装します。これは、ほとんど検査されない多くの属性を持つ行や半構造化データなど、さまざまなシナリオで役立ちます。キーと値は単なるテキスト文字列です。</target>
        </trans-unit>
        <trans-unit id="de0a2c458306a9179b18df224706a81701d0af82" translate="yes" xml:space="preserve">
          <source>This module integrates with SELinux to provide an additional layer of security checking above and beyond what is normally provided by PostgreSQL. From the perspective of SELinux, this module allows PostgreSQL to function as a user-space object manager. Each table or function access initiated by a DML query will be checked against the system security policy. This check is in addition to the usual SQL permissions checking performed by PostgreSQL.</source>
          <target state="translated">このモジュールはSELinuxと統合して、PostgreSQLが通常提供している以上のセキュリティ検査の追加レイヤを提供します。SELinuxの観点からは、このモジュールはPostgreSQLをユーザ空間オブジェクトマネージャとして機能させることを可能にします。DML問い合わせによって開始された各テーブルや関数のアクセスは、システムのセキュリティポリシーに照らしてチェックされます。このチェックは、PostgreSQLが行う通常のSQL権限チェックに加えて行われます。</target>
        </trans-unit>
        <trans-unit id="269393947826c6d71fccaff13c4be9c80ca40682" translate="yes" xml:space="preserve">
          <source>This module is sponsored by Delta-Soft Ltd., Moscow, Russia.</source>
          <target state="translated">このモジュールは、ロシアのモスクワにあるDelta-Soft Ltd.がスポンサーとなっています。</target>
        </trans-unit>
        <trans-unit id="4056f705daa3e3fdd49196fac6596ba7b2aa2807" translate="yes" xml:space="preserve">
          <source>This module was inspired by Garrett A. Wollman's &lt;code&gt;isbn_issn&lt;/code&gt; code.</source>
          <target state="translated">このモジュールはGarrett A. &lt;code&gt;isbn_issn&lt;/code&gt; のisbn_issnコードに触発されました。</target>
        </trans-unit>
        <trans-unit id="141bf6865546870a10c076189dfdbdeb9f73407a" translate="yes" xml:space="preserve">
          <source>This naming convention establishes a clear order in which these files will be loaded. This is important because only the last setting encountered for a particular parameter while the server is reading configuration files will be used. In this example, something set in &lt;code&gt;conf.d/02server.conf&lt;/code&gt; would override a value set in &lt;code&gt;conf.d/01memory.conf&lt;/code&gt;.</source>
          <target state="translated">この命名規則は、これらのファイルがロードされる明確な順序を確立します。サーバーが構成ファイルを読み取っている間に特定のパラメーターで発生した最後の設定のみが使用されるため、これは重要です。この例では、中に何かのセット &lt;code&gt;conf.d/02server.conf&lt;/code&gt; は中値セットオーバーライドします &lt;code&gt;conf.d/01memory.conf&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="833c4d41d72807ff8bff00dc171b711add76bff2" translate="yes" xml:space="preserve">
          <source>This node's LSN at which &lt;code&gt;remote_lsn&lt;/code&gt; has been replicated. Used to flush commit records before persisting data to disk when using asynchronous commits.</source>
          <target state="translated">&lt;code&gt;remote_lsn&lt;/code&gt; が複製されたこのノードのLSN 。非同期コミットの使用時に、データをディスクに永続化する前にコミットレコードをフラッシュするために使用されます。</target>
        </trans-unit>
        <trans-unit id="388063f0d1bc8c68724a848b5427707b09f5e0a2" translate="yes" xml:space="preserve">
          <source>This notation behaves differently depending on context; see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt; for details.</source>
          <target state="translated">この表記法は、コンテキストによって動作が異なります。詳細については、&lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;8.16.5項&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ff98e9774f8c6e6fad6dce4d14a177af4ff71408" translate="yes" xml:space="preserve">
          <source>This operator supports hash joins</source>
          <target state="translated">この演算子はハッシュ結合をサポートします。</target>
        </trans-unit>
        <trans-unit id="2c90e947b03275ac339cbaa9aa960fdd656aa3ae" translate="yes" xml:space="preserve">
          <source>This operator supports merge joins</source>
          <target state="translated">この演算子はマージ結合をサポートします。</target>
        </trans-unit>
        <trans-unit id="033a065728054a33c7f38b0e616194e5c2c3aaa5" translate="yes" xml:space="preserve">
          <source>This option allows running &lt;code&gt;pg_dump -j&lt;/code&gt; against a pre-9.2 server, see the documentation of the &lt;code&gt;-j&lt;/code&gt; parameter for more details.</source>
          <target state="translated">このオプションを使用すると、9.2より前のサーバーに対して &lt;code&gt;pg_dump -j&lt;/code&gt; を実行できます。詳細については、 &lt;code&gt;-j&lt;/code&gt; パラメータのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="67692a76bdedd175ae4ea2832082e8bfa1d20815" translate="yes" xml:space="preserve">
          <source>This option always affects transfer of the data directory. Transfer of WAL files is only affected if the collection method is &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">このオプションは常にデータディレクトリの転送に影響します。WALファイルの転送は、収集方法が &lt;code&gt;fetch&lt;/code&gt; の場合にのみ影響を受けます。</target>
        </trans-unit>
        <trans-unit id="66b9c3dfa7b75f649757901e5e89c1862e7c3ada" translate="yes" xml:space="preserve">
          <source>This option can be set by any user. Because of that, the libraries that can be loaded are restricted to those appearing in the &lt;code&gt;plugins&lt;/code&gt; subdirectory of the installation's standard library directory. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.) Entries in &lt;code&gt;local_preload_libraries&lt;/code&gt; can specify this directory explicitly, for example &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;, or just specify the library name &amp;mdash; &lt;code&gt;mylib&lt;/code&gt; would have the same effect as &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt;.</source>
          <target state="translated">このオプションは、すべてのユーザーが設定できます。そのため、ロードできるライブラリは、インストールの標準ライブラリディレクトリの &lt;code&gt;plugins&lt;/code&gt; サブディレクトリにあるライブラリに制限されています。 （「安全な」ライブラリのみがそこにインストールされるようにするのは、データベース管理者の責任です。） &lt;code&gt;local_preload_libraries&lt;/code&gt; のエントリは、このディレクトリを明示的に指定できます（例： &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt; 、または単にライブラリ名を指定）&amp;mdash; &lt;code&gt;mylib&lt;/code&gt; は同じです &lt;code&gt;$libdir/plugins/mylib&lt;/code&gt; として効果。</target>
        </trans-unit>
        <trans-unit id="2a0fc1ca8b2fbb1af9a9d77b22b8df428dc16da8" translate="yes" xml:space="preserve">
          <source>This option can only be used in combination with one or more &lt;code&gt;-c&lt;/code&gt; and/or &lt;code&gt;-f&lt;/code&gt; options. It causes psql to issue a &lt;code&gt;BEGIN&lt;/code&gt; command before the first such option and a &lt;code&gt;COMMIT&lt;/code&gt; command after the last one, thereby wrapping all the commands into a single transaction. This ensures that either all the commands complete successfully, or no changes are applied.</source>
          <target state="translated">このオプションは、1つ以上の &lt;code&gt;-c&lt;/code&gt; または &lt;code&gt;-f&lt;/code&gt; オプションと組み合わせてのみ使用できます。これにより、psql は最初のオプションの前に &lt;code&gt;BEGIN&lt;/code&gt; コマンドを発行し、最後のオプションの後に &lt;code&gt;COMMIT&lt;/code&gt; コマンドを発行するため、すべてのコマンドが単一のトランザクションにラップされます。これにより、すべてのコマンドが正常に完了するか、変更が適用されなくなります。</target>
        </trans-unit>
        <trans-unit id="4af26bb42d56efbdd77ea30d507197b50c1c0a6e" translate="yes" xml:space="preserve">
          <source>This option can only be used together with &lt;code&gt;-X stream&lt;/code&gt;. It causes the WAL streaming to use the specified replication slot. If the base backup is intended to be used as a streaming replication standby using replication slots, it should then use the same replication slot name in &lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_name&lt;/a&gt;. That way, it is ensured that the server does not remove any necessary WAL data in the time between the end of the base backup and the start of streaming replication.</source>
          <target state="translated">このオプションは &lt;code&gt;-X stream&lt;/code&gt; と一緒にしか使用できません。これにより、WALストリーミングは指定された複製スロットを使用します。ベースバックアップがレプリケーションスロットを使用するストリーミングレプリケーションスタンバイとして使用されることを意図している場合は、&lt;a href=&quot;runtime-config-replication#GUC-PRIMARY-SLOT-NAME&quot;&gt;primary_slot_nameで&lt;/a&gt;同じレプリケーションスロット名を使用する必要があります。これにより、ベースバックアップの終了からストリーミングレプリケーションの開始までの間に、サーバーが必要なWALデータを削除しないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="6dcf604d43dc6007ea78136bf7b33be7b4e62ae3" translate="yes" xml:space="preserve">
          <source>This option cannot be used to remove the support function altogether, since it must name a new support function. Use &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; if you need to do that.</source>
          <target state="translated">このオプションは、新しいサポート関数を指定する必要があるため、サポート関数を完全に削除するために使用することはできません。必要な場合は、 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="bd8d44929298a4cbf2c87cec1c31093bc64b155b" translate="yes" xml:space="preserve">
          <source>This option causes &lt;code&gt;pg_receivewal&lt;/code&gt; to not force WAL data to be flushed to disk. This is faster, but means that a subsequent operating system crash can leave the WAL segments corrupt. Generally, this option is useful for testing but should not be used when doing WAL archiving on a production deployment.</source>
          <target state="translated">このオプションにより、 &lt;code&gt;pg_receivewal&lt;/code&gt; はWALデータを強制的にディスクにフラッシュさせません。これはより高速ですが、その後のオペレーティングシステムのクラッシュによりWALセグメントが破損したままになる可能性があることを意味します。一般に、このオプションはテストには役立ちますが、運用環境でWALアーカイブを行う場合は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="0a83f03d78ff431f987c79d1993890ac0162fd03" translate="yes" xml:space="preserve">
          <source>This option causes creation of a replication slot named by the &lt;code&gt;--slot&lt;/code&gt; option before starting the backup. An error is raised if the slot already exists.</source>
          <target state="translated">このオプションにより、バックアップを開始する前に &lt;code&gt;--slot&lt;/code&gt; オプションで指定された複製スロットが作成されます。スロットがすでに存在する場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="019a3bff9bc43aecc3893ea645652e695f875fd1" translate="yes" xml:space="preserve">
          <source>This option controls the behavior of automatically updatable views. When this option is specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view will be checked to ensure that new rows satisfy the view-defining condition (that is, the new rows are checked to ensure that they are visible through the view). If they are not, the update will be rejected. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is not specified, &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; commands on the view are allowed to create rows that are not visible through the view. The following check options are supported:</source>
          <target state="translated">このオプションは、自動的に更新可能なビューの動作を制御します。このオプションを指定すると、ビューの &lt;code&gt;INSERT&lt;/code&gt; コマンドと &lt;code&gt;UPDATE&lt;/code&gt; コマンドがチェックされ、新しい行がビュー定義条件を満たしていることを確認します（つまり、新しい行がチェックされ、ビューから見えることを確認します）。そうでない場合、更新は拒否されます。 &lt;code&gt;CHECK OPTION&lt;/code&gt; が指定されていない場合、ビューに対する &lt;code&gt;INSERT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; コマンドは、ビューからは見えない行を作成できます。次のチェックオプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="2fa12085b7bbeed5763de22cebaafe8cc79d4acb" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;postgres_fdw&lt;/code&gt; allows foreign tables to be modified using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; commands. It can be specified for a foreign table or a foreign server. A table-level option overrides a server-level option. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このオプションは、 &lt;code&gt;postgres_fdw&lt;/code&gt; が &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; コマンドを使用して外部テーブルを変更できるようにするかどうかを制御します。外部テーブルまたは外部サーバーに対して指定できます。テーブルレベルのオプションは、サーバーレベルのオプションをオーバーライドします。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c306234b370cc56fe65c31871921559cfe86c86e" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;COLLATE&lt;/code&gt; options are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;. You might need to turn this off if the remote server has a different set of collation names than the local server does, which is likely to be the case if it's running on a different operating system.</source>
          <target state="translated">このオプションは、列の &lt;code&gt;COLLATE&lt;/code&gt; オプションが外部サーバーからインポートされた外部テーブルの定義に含まれるかどうかを制御します。デフォルトは &lt;code&gt;true&lt;/code&gt; です。リモートサーバーがローカルサーバーとは異なる照合名のセットを持っている場合、これをオフにする必要がある場合があります。これは、別のオペレーティングシステムで実行されている場合に当てはまる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9a2c7892fe0f505a8ed2a71e7d9d8917529e89f4" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;DEFAULT&lt;/code&gt; expressions are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;false&lt;/code&gt;. If you enable this option, be wary of defaults that might get computed differently on the local server than they would be on the remote server; &lt;code&gt;nextval()&lt;/code&gt; is a common source of problems. The &lt;code&gt;IMPORT&lt;/code&gt; will fail altogether if an imported default expression uses a function or operator that does not exist locally.</source>
          <target state="translated">このオプションは、列の &lt;code&gt;DEFAULT&lt;/code&gt; 式が外部サーバーからインポートされた外部テーブルの定義に含まれるかどうかを制御します。デフォルトは &lt;code&gt;false&lt;/code&gt; です。このオプションを有効にする場合は、ローカルサーバーでの計算とリモートサーバーでの計算が異なる可能性があるデフォルトに注意してください。 &lt;code&gt;nextval()&lt;/code&gt; は問題の一般的な原因です。 &lt;code&gt;IMPORT&lt;/code&gt; は、インポートされたデフォルト式がローカルに存在しない関数や演算子を使用している場合は完全に失敗します。</target>
        </trans-unit>
        <trans-unit id="c777fcd8f37f1faf36e546a259bf3994c8ebf0b0" translate="yes" xml:space="preserve">
          <source>This option controls whether column &lt;code&gt;NOT NULL&lt;/code&gt; constraints are included in the definitions of foreign tables imported from a foreign server. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">このオプションは、列の &lt;code&gt;NOT NULL&lt;/code&gt; 制約を外部サーバーからインポートされた外部テーブルの定義に含めるかどうかを制御します。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a4534428c01b535724cfe3334dea2585c43336e1" translate="yes" xml:space="preserve">
          <source>This option disables the use of dollar quoting for function bodies, and forces them to be quoted using SQL standard string syntax.</source>
          <target state="translated">このオプションは、関数本体でのドル引用符の使用を無効にし、SQL標準文字列構文を使用して引用符で囲むように強制します。</target>
        </trans-unit>
        <trans-unit id="1e5b8577c4f91feed1cbbbf28c3713fcd0567f3a" translate="yes" xml:space="preserve">
          <source>This option dumps out the server's internal configuration variables, descriptions, and defaults in tab-delimited &lt;code&gt;COPY&lt;/code&gt; format. It is designed primarily for use by administration tools.</source>
          <target state="translated">このオプションは、サーバーの内部構成変数、説明、およびデフォルトをタブ区切りの &lt;code&gt;COPY&lt;/code&gt; 形式でダンプします。主に管理ツールで使用するために設計されています。</target>
        </trans-unit>
        <trans-unit id="39d1d4f9b39a2419e5e71963676b76de7092eb75" translate="yes" xml:space="preserve">
          <source>This option has no effect on &lt;code&gt;-N&lt;/code&gt;/&lt;code&gt;--exclude-schema&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;/&lt;code&gt;--exclude-table&lt;/code&gt;, or &lt;code&gt;--exclude-table-data&lt;/code&gt;. An exclude pattern failing to match any objects is not considered an error.</source>
          <target state="translated">このオプションは、 &lt;code&gt;-N&lt;/code&gt; / &lt;code&gt;--exclude-schema&lt;/code&gt; 、 &lt;code&gt;-T&lt;/code&gt; / &lt;code&gt;--exclude-table&lt;/code&gt; 、または &lt;code&gt;--exclude-table-data&lt;/code&gt; には影響しません。オブジェクトに一致しない除外パターンはエラーとは見なされません。</target>
        </trans-unit>
        <trans-unit id="44b5c0279373253dcf944caef48c35c814e3748e" translate="yes" xml:space="preserve">
          <source>This option has the same effect as the option of the same name in &lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewal&lt;/a&gt;. See the description there.</source>
          <target state="translated">このオプションは&lt;a href=&quot;app-pgreceivewal&quot;&gt;pg_receivewalの&lt;/a&gt;同じ名前のオプションと同じ効果があります。そこの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="e156f33e8e3c423b7dd6e39f40b8d2b97fdc7406" translate="yes" xml:space="preserve">
          <source>This option is a comma-separated list of names of PostgreSQL extensions that are installed, in compatible versions, on both the local and remote servers. Functions and operators that are immutable and belong to a listed extension will be considered shippable to the remote server. This option can only be specified for foreign servers, not per-table.</source>
          <target state="translated">このオプションは、互換性のあるバージョンでローカルサーバとリモートサーバの両方にインストールされているPostgreSQL拡張機能の名前をカンマ区切りでリスト化したものです。不変であり、リストされた拡張機能に属する関数や演算子は、リモートサーバに出荷可能であるとみなされます。このオプションは、テーブル単位ではなく、海外のサーバに対してのみ指定することができます。</target>
        </trans-unit>
        <trans-unit id="dd3ca03402c96b67aa550ad0869d48010fb66dab" translate="yes" xml:space="preserve">
          <source>This option is deprecated since it does not allow access to the full functionality of &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt;. It's usually better to set &lt;code&gt;listen_addresses&lt;/code&gt; directly.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addressesの&lt;/a&gt;すべての機能へのアクセスを許可しないため、推奨されません。通常は、 &lt;code&gt;listen_addresses&lt;/code&gt; を直接設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2b68d58ae84a3ecac214be2012e7c336871134f8" translate="yes" xml:space="preserve">
          <source>This option is effective only when restoring directly into a database, not when producing SQL script output.</source>
          <target state="translated">このオプションは、データベースに直接リストアする場合にのみ有効であり、SQLスクリプト出力を生成する場合には有効ではありません。</target>
        </trans-unit>
        <trans-unit id="968dc4a560c532375e657416e7cf0bbd50ef3170" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will not reinitialize shared data structures. A knowledgeable system programmer can then use a debugger to examine shared memory and semaphore state.</source>
          <target state="translated">このオプションは、サーバープロセスが異常終了する原因となる問題をデバッグするためのものです。この状況での通常の戦略は、他のすべてのサーバープロセスに終了を通知してから、共有メモリとセマフォを再初期化することです。これは、エラーのあるサーバープロセスが、終了する前に一部の共有状態を破壊した可能性があるためです。このオプションは、 &lt;code&gt;postgres&lt;/code&gt; が共有データ構造を再初期化しないことを指定します。知識の豊富なシステムプログラマは、デバッガを使用して共有メモリとセマフォの状態を調べることができます。</target>
        </trans-unit>
        <trans-unit id="42927906afa65b972047e92608a8fe2f81b95297" translate="yes" xml:space="preserve">
          <source>This option is for debugging problems that cause a server process to die abnormally. The ordinary strategy in this situation is to notify all other server processes that they must terminate and then reinitialize the shared memory and semaphores. This is because an errant server process could have corrupted some shared state before terminating. This option specifies that &lt;code&gt;postgres&lt;/code&gt; will stop all other server processes by sending the signal &lt;code&gt;SIGSTOP&lt;/code&gt;, but will not cause them to terminate. This permits system programmers to collect core dumps from all server processes by hand.</source>
          <target state="translated">このオプションは、サーバープロセスが異常終了する原因となる問題をデバッグするためのものです。この状況での通常の戦略は、他のすべてのサーバープロセスに終了を通知してから、共有メモリとセマフォを再初期化することです。これは、エラーのあるサーバープロセスが、終了する前に一部の共有状態を破壊した可能性があるためです。このオプションは、 &lt;code&gt;postgres&lt;/code&gt; がシグナル &lt;code&gt;SIGSTOP&lt;/code&gt; を送信して他のすべてのサーバープロセスを停止するが、プロセスを終了させないことを指定します。これにより、システムプログラマはすべてのサーバープロセスから手動でコアダンプを収集できます。</target>
        </trans-unit>
        <trans-unit id="a2fa6b1b1272f22fc7098675bb1c64f065394241" translate="yes" xml:space="preserve">
          <source>This option is for use by in-place upgrade utilities. Its use for other purposes is not recommended or supported. The behavior of the option may change in future releases without notice.</source>
          <target state="translated">このオプションは、インプレースアップグレードユーティリティで使用するためのものです。それ以外の目的での使用は推奨されておらず、サポートされていません。このオプションの動作は、今後のリリースで予告なく変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="efc4bf4d899439505edd24a5ec7b6f3018597535" translate="yes" xml:space="preserve">
          <source>This option is incompatible with &lt;code&gt;--synchronous&lt;/code&gt;.</source>
          <target state="translated">このオプションは &lt;code&gt;--synchronous&lt;/code&gt; と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="1e4f9dc483d33770bfc633e073d626e91a285814" translate="yes" xml:space="preserve">
          <source>This option is like &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt;, but it describes the behavior of the moving-aggregate final function.</source>
          <target state="translated">このオプションは &lt;code&gt;FINALFUNC_MODIFY&lt;/code&gt; に似ていますが、移動集計の最終関数の動作を示します。</target>
        </trans-unit>
        <trans-unit id="ae64748d4bfb71bb191824f72616015218279c62" translate="yes" xml:space="preserve">
          <source>This option is meant for other programs that interact with a server instance, such as &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;, to query configuration parameter values. User-facing applications should instead use &lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt; or the &lt;code&gt;pg_settings&lt;/code&gt; view.</source>
          <target state="translated">このオプションは、&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;などのサーバーインスタンスと対話して構成パラメーター値を照会する他のプログラム用です。ユーザー向けのアプリケーションは、代わりに&lt;a href=&quot;sql-show&quot;&gt;SHOW&lt;/a&gt;または &lt;code&gt;pg_settings&lt;/code&gt; ビューを使用する必要があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
