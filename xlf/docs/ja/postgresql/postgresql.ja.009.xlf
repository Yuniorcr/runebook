<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="2fd647ad9469bb58fc1688a31c856ba421945ca2" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;&lt;code&gt;WITH&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; リスト内のすべてのクエリが計算されます。これらは、 &lt;code&gt;FROM&lt;/code&gt; リストで参照できる一時テーブルとして効果的に機能します。A &lt;code&gt;WITH&lt;/code&gt; 以上で何度も参照されているクエリ &lt;code&gt;FROM&lt;/code&gt; はで特に指定のない限り、一度だけ計算され &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 。（下記の&lt;a href=&quot;sql-select#SQL-WITH&quot;&gt; &lt;code&gt;WITH&lt;/code&gt; 節を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="d5d88441c9f02c86f8bfc47e2413965c87d4afdf" translate="yes" xml:space="preserve">
          <source>All queries in the &lt;code&gt;WITH&lt;/code&gt; list are computed. These effectively serve as temporary tables that can be referenced in the &lt;code&gt;FROM&lt;/code&gt; list. A &lt;code&gt;WITH&lt;/code&gt; query that is referenced more than once in &lt;code&gt;FROM&lt;/code&gt; is computed only once, unless specified otherwise with &lt;code&gt;NOT MATERIALIZED&lt;/code&gt;. (See &lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;WITH Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; リスト内のすべてのクエリが計算されます。これらは、 &lt;code&gt;FROM&lt;/code&gt; リストで参照できる一時テーブルとして効果的に機能します。 A &lt;code&gt;WITH&lt;/code&gt; 以上で何度も参照されているクエリ &lt;code&gt;FROM&lt;/code&gt; はで特に指定のない限り、一度だけ計算され &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; 。 （以下の&lt;a href=&quot;sql-select#SQL-WITH&quot;&gt;WITH句を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="f087ce49a12f5467c1e1d2b10a821f36bb151962" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit.</source>
          <target state="translated">一時テーブルのすべての行は、各トランザクションブロックの最後に削除されます。基本的に、自動&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;はコミットごとに行われます。</target>
        </trans-unit>
        <trans-unit id="2033a72b30b992b55fdec7e008bb0316322a754e" translate="yes" xml:space="preserve">
          <source>All rows in the temporary table will be deleted at the end of each transaction block. Essentially, an automatic &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; is done at each commit. When used on a partitioned table, this is not cascaded to its partitions.</source>
          <target state="translated">一時テーブルのすべての行は、各トランザクションブロックの最後に削除されます。基本的に、自動&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;はコミットごとに行われます。パーティションテーブルで使用した場合、これはパーティションにカスケードされません。</target>
        </trans-unit>
        <trans-unit id="6dcf0dcfbfdd9c5f88b82f71ae9c913b23c0891e" translate="yes" xml:space="preserve">
          <source>All rows inserted into a partitioned table will be routed to one of the &lt;em&gt;partitions&lt;/em&gt; based on the value of the partition key. Each partition has a subset of the data defined by its &lt;em&gt;partition bounds&lt;/em&gt;. The currently supported partitioning methods are range, list, and hash.</source>
          <target state="translated">パーティションテーブルに挿入されたすべての行は、パーティションキーの値に基づいて&lt;em&gt;パーティションの&lt;/em&gt; 1つにルーティングされます。各パーティションには、&lt;em&gt;パーティションの境界&lt;/em&gt;によって定義されたデータのサブセットがあります。現在サポートされているパーティション分割方法は、範囲、リスト、およびハッシュです。</target>
        </trans-unit>
        <trans-unit id="4513787ec30b4d30ebbb9895538f30d98e3df810" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</target>
        </trans-unit>
        <trans-unit id="25b4cbd01fbf767d95283abe0881812c05362a17" translate="yes" xml:space="preserve">
          <source>All standard and predefined collations are deterministic, all user-defined collations are deterministic by default. While nondeterministic collations give a more &amp;ldquo;correct&amp;rdquo; behavior, especially when considering the full power of Unicode and its many special cases, they also have some drawbacks. Foremost, their use leads to a performance penalty. Note, in particular, that B-tree cannot use deduplication with indexes that use a nondeterministic collation. Also, certain operations are not possible with nondeterministic collations, such as pattern matching operations. Therefore, they should be used only in cases where they are specifically wanted.</source>
          <target state="translated">すべての標準および事前定義の照合順序は決定論的であり、すべてのユーザー定義の照合順序はデフォルトで決定論的です。非決定論的照合は、特にUnicodeの全機能とその多くの特殊なケースを考慮すると、より「正しい」動作を提供しますが、いくつかの欠点もあります。何よりも、それらの使用はパフォーマンスの低下につながります。特に、Bツリーは非決定性照合を使用するインデックスで重複排除を使用できないことに注意してください。また、パターンマッチング操作など、非決定論的照合では特定の操作が不可能です。したがって、特に必要な場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="33701db90942013a1dfc5834530a8ecffe185cf9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction.</source>
          <target state="translated">現在のトランザクションのすべてのステートメントは、このトランザクションで最初のクエリまたはデータ修正ステートメントが実行される前にコミットされた行のみを見ることができます。</target>
        </trans-unit>
        <trans-unit id="2e14dc15c0e8ebe018dfe9b3ade39c8f85c910d9" translate="yes" xml:space="preserve">
          <source>All statements of the current transaction can only see rows committed before the first query or data-modification statement was executed in this transaction. If a pattern of reads and writes among concurrent serializable transactions would create a situation which could not have occurred for any serial (one-at-a-time) execution of those transactions, one of them will be rolled back with a &lt;code&gt;serialization_failure&lt;/code&gt; error.</source>
          <target state="translated">現在のトランザクションのすべてのステートメントは、このトランザクションで最初のクエリまたはデータ変更ステートメントが実行される前にコミットされた行のみを表示できます。並行シリアライズ可能なトランザクション間での読み取りと書き込みのパターンにより、それらのトランザクションのシリアル（一度に1つずつ）の実行では発生し得なかった状況が発生した場合、そのうちの1つが &lt;code&gt;serialization_failure&lt;/code&gt; エラーでロールバックされます。</target>
        </trans-unit>
        <trans-unit id="333b8b7d294d7e593e47c576e136baad90efa83c" translate="yes" xml:space="preserve">
          <source>All system-defined SQL objects reside in schema &lt;code&gt;pg_catalog&lt;/code&gt;.</source>
          <target state="translated">システム定義のSQLオブジェクトはすべて、スキーマ &lt;code&gt;pg_catalog&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="fd69152cf9c28ea6bdb8489a69a762ca6be86225" translate="yes" xml:space="preserve">
          <source>All systems would have the same &lt;code&gt;shared.conf&lt;/code&gt;. Each server with a particular amount of memory could share the same &lt;code&gt;memory.conf&lt;/code&gt;; you might have one for all servers with 8GB of RAM, another for those having 16GB. And finally &lt;code&gt;server.conf&lt;/code&gt; could have truly server-specific configuration information in it.</source>
          <target state="translated">すべてのシステムで同じ &lt;code&gt;shared.conf&lt;/code&gt; が使用されます。特定のメモリ容量を持つ各サーバーは、同じ &lt;code&gt;memory.conf&lt;/code&gt; を共有できます。8 GBのRAMを搭載したすべてのサーバー用に1つ、16 GBのサーバー用にもう1つあります。そして最後に、 &lt;code&gt;server.conf&lt;/code&gt; には、本当にサーバー固有の構成情報を含めることができます。</target>
        </trans-unit>
        <trans-unit id="fdb84efbad86954ba5aa82c861c3c65c57c671dd" translate="yes" xml:space="preserve">
          <source>All table rows are structured in the same way. There is a fixed-size header (occupying 23 bytes on most machines), followed by an optional null bitmap, an optional object ID field, and the user data. The header is detailed in &lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;Table 68.4&lt;/a&gt;. The actual user data (columns of the row) begins at the offset indicated by &lt;code&gt;t_hoff&lt;/code&gt;, which must always be a multiple of the MAXALIGN distance for the platform. The null bitmap is only present if the &lt;em&gt;HEAP_HASNULL&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If it is present it begins just after the fixed header and occupies enough bytes to have one bit per data column (that is, the number of bits that equals the attribute count in &lt;code&gt;t_infomask2&lt;/code&gt;). In this list of bits, a 1 bit indicates not-null, a 0 bit is a null. When the bitmap is not present, all columns are assumed not-null. The object ID is only present if the &lt;em&gt;HEAP_HASOID_OLD&lt;/em&gt; bit is set in &lt;code&gt;t_infomask&lt;/code&gt;. If present, it appears just before the &lt;code&gt;t_hoff&lt;/code&gt; boundary. Any padding needed to make &lt;code&gt;t_hoff&lt;/code&gt; a MAXALIGN multiple will appear between the null bitmap and the object ID. (This in turn ensures that the object ID is suitably aligned.)</source>
          <target state="translated">すべてのテーブル行は同じ方法で構造化されています。固定サイズのヘッダー（ほとんどのマシンで23バイトを占める）があり、その後にオプションのnullビットマップ、オプションのオブジェクトIDフィールド、およびユーザーデータが続きます。ヘッダーの詳細を&lt;a href=&quot;storage-page-layout#HEAPTUPLEHEADERDATA-TABLE&quot;&gt;表68.4に示し&lt;/a&gt;ます。実際のユーザーデータ（行の列）は、 &lt;code&gt;t_hoff&lt;/code&gt; で示されるオフセットから始まります。これは、プラットフォームのMAXALIGN距離の倍数である必要があります。 nullビットマップは、&lt;em&gt;t_infomaskでHEAP_HASNULL&lt;/em&gt;ビットが設定されている場合にのみ存在し &lt;code&gt;t_infomask&lt;/code&gt; 。存在する場合は、固定ヘッダーの直後から始まり、データ列ごとに1ビット（つまり、 &lt;code&gt;t_infomask2&lt;/code&gt; の属性カウントに等しいビット数）を確保するのに十分なバイトを占有します。）。このビットのリストでは、1ビットはnull以外を示し、0ビットはnullを示します。ビットマップが存在しない場合、すべての列はnullでないと見なされます。オブジェクトIDは、&lt;em&gt;t_infomaskでHEAP_HASOID_OLD&lt;/em&gt;ビットが設定されている場合にのみ存在し &lt;code&gt;t_infomask&lt;/code&gt; 。存在する場合は、 &lt;code&gt;t_hoff&lt;/code&gt; 境界の直前に表示されます。 &lt;code&gt;t_hoff&lt;/code&gt; をMAXALIGNの倍数にするために必要なパディングは、nullビットマップとオブジェクトIDの間に表示されます。 （これにより、オブジェクトIDが適切に調整されます。）</target>
        </trans-unit>
        <trans-unit id="07e8311d5ee709346fa3f96903022cdc35bc8edc" translate="yes" xml:space="preserve">
          <source>All tables in the current database in a tablespace can be moved by using the &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; form, which will lock all tables to be moved first and then move each one. This form also supports &lt;code&gt;OWNED BY&lt;/code&gt;, which will only move tables owned by the roles specified. If the &lt;code&gt;NOWAIT&lt;/code&gt; option is specified then the command will fail if it is unable to acquire all of the locks required immediately. Note that system catalogs are not moved by this command; use &lt;code&gt;ALTER DATABASE&lt;/code&gt; or explicit &lt;code&gt;ALTER TABLE&lt;/code&gt; invocations instead if desired. The &lt;code&gt;information_schema&lt;/code&gt; relations are not considered part of the system catalogs and will be moved. See also &lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;.</source>
          <target state="translated">テーブルスペースの現在のデータベース内のすべてのテーブルは、 &lt;code&gt;ALL IN TABLESPACE&lt;/code&gt; フォームを使用して移動できます。これにより、最初に移動するすべてのテーブルがロックされ、次にそれぞれが移動します。このフォームは &lt;code&gt;OWNED BY&lt;/code&gt; もサポートしており、指定されたロールが所有するテーブルのみを移動します。 &lt;code&gt;NOWAIT&lt;/code&gt; オプションが指定されている場合、必要なすべてのロックをすぐに取得できないと、コマンドは失敗します。システムカタログはこのコマンドでは移動されないことに注意してください。使用 &lt;code&gt;ALTER DATABASE&lt;/code&gt; または明示的な &lt;code&gt;ALTER TABLE&lt;/code&gt; の必要に応じて、代わりに呼び出しを。 &lt;code&gt;information_schema&lt;/code&gt; 関係は、システムカタログの一部とは見なされず、移動されます。&lt;a href=&quot;sql-createtablespace&quot;&gt;CREATE TABLESPACE&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fba1b0761d495deac6051791b1b8f0b77af030f7" translate="yes" xml:space="preserve">
          <source>All the GiST support methods are normally called in short-lived memory contexts; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt;, and keep a pointer to it in &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt;. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a &lt;code&gt;fn_extra&lt;/code&gt; value, or the leak will accumulate for the duration of the operation.</source>
          <target state="translated">すべてのGiSTサポートメソッドは、通常、存続期間の短いメモリコンテキストで呼び出されます。つまり、各タプルが処理された後に &lt;code&gt;CurrentMemoryContext&lt;/code&gt; がリセットされます。したがって、pallocしたすべてのものをpfreeすることを心配することはあまり重要ではありません。ただし、場合によっては、サポートメソッドが繰り返し呼び出しにまたがってデータをキャッシュすることが役立つことがあります。これを行うには、より長い寿命のデータを &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_mcxt&lt;/code&gt; に割り当て、そのデータへのポインターを &lt;code&gt;fcinfo-&amp;gt;flinfo-&amp;gt;fn_extra&lt;/code&gt; に保持します。そのようなデータは、インデックス操作（たとえば、単一のGiSTインデックススキャン、インデックスビルド、またはインデックスタプルの挿入）の存続期間中存続します。 &lt;code&gt;fn_extra&lt;/code&gt; 値を置き換えるときは、以前の値を解放するように注意してください。そうしないと、操作中にリークが蓄積します。</target>
        </trans-unit>
        <trans-unit id="1775f572f652b9b020df7dce36fbde055a9f9549" translate="yes" xml:space="preserve">
          <source>All the SP-GiST support methods are normally called in a short-lived memory context; that is, &lt;code&gt;CurrentMemoryContext&lt;/code&gt; will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The &lt;code&gt;config&lt;/code&gt; method is an exception: it should try to avoid leaking memory. But usually the &lt;code&gt;config&lt;/code&gt; method need do nothing but assign constants into the passed parameter struct.)</source>
          <target state="translated">すべてのSP-GiSTサポートメソッドは、通常、一時的なメモリコンテキストで呼び出されます。つまり、 &lt;code&gt;CurrentMemoryContext&lt;/code&gt; は各タプルの処理後にリセットされます。したがって、pallocしたすべてのものをpfreeすることを心配することはあまり重要ではありません。（ &lt;code&gt;config&lt;/code&gt; メソッドは例外です：メモリのリークを回避する必要があります。しかし、通常、 &lt;code&gt;config&lt;/code&gt; メソッドは渡されたパラメーター構造体に定数を割り当てるだけで十分です。）</target>
        </trans-unit>
        <trans-unit id="45bde084b879a44097ffbb7f22a89ae3a6f15f28" translate="yes" xml:space="preserve">
          <source>All the actions except &lt;code&gt;RENAME&lt;/code&gt; and &lt;code&gt;SET SCHEMA&lt;/code&gt; can be combined into a list of multiple alterations to apply in parallel. For example, it is possible to add several columns and/or alter the type of several columns in a single command.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; と &lt;code&gt;SET SCHEMA&lt;/code&gt; を除くすべてのアクションは、複数の変更のリストに組み合わせて、並行して適用できます。たとえば、1つのコマンドで複数の列を追加したり、複数の列のタイプを変更したりすることができます。</target>
        </trans-unit>
        <trans-unit id="510081c46bee5d125d10e16db44ba6aa06aa8209" translate="yes" xml:space="preserve">
          <source>All the aggregates listed in &lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;Table 9.57&lt;/a&gt; ignore null values in their sorted input. For those that take a &lt;code&gt;fraction&lt;/code&gt; parameter, the fraction value must be between 0 and 1; an error is thrown if not. However, a null fraction value simply produces a null result.</source>
          <target state="translated">&lt;a href=&quot;functions-aggregate#FUNCTIONS-ORDEREDSET-TABLE&quot;&gt;表9.57に&lt;/a&gt;リストされているすべての集約は、ソートされた入力のnull値を無視します。 &lt;code&gt;fraction&lt;/code&gt; パラメーターを取るものの場合、分数の値は0から1の間でなければなりません。そうでない場合はエラーがスローされます。ただし、NULL分数値はNULL結果を生成するだけです。</target>
        </trans-unit>
        <trans-unit id="51ab62b62647a9e48b750694e717b8b41fe65f92" translate="yes" xml:space="preserve">
          <source>All the backslash commands of a given conditional block must appear in the same source file. If EOF is reached on the main input file or an &lt;code&gt;\include&lt;/code&gt;-ed file before all local &lt;code&gt;\if&lt;/code&gt;-blocks have been closed, then psql will raise an error.</source>
          <target state="translated">特定の条件付きブロックのすべてのバックスラッシュコマンドは、同じソースファイルに存在する必要があります。すべてのローカルの &lt;code&gt;\if&lt;/code&gt; -blocksが閉じられる前にメイン入力ファイルまたは &lt;code&gt;\include&lt;/code&gt; -edファイルでEOFに到達すると、psqlはエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="c3df3ceb9c111c6a03e79138ef843c3f5502324f" translate="yes" xml:space="preserve">
          <source>All the constraints that refer to the index are changed to refer to the new index definition, and the names of the indexes are changed. At this point, &lt;code&gt;pg_index.indisvalid&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; for the new index and to &amp;ldquo;false&amp;rdquo; for the old, and a cache invalidation is done causing all sessions that referenced the old index to be invalidated.</source>
          <target state="translated">インデックスを参照するすべての制約が新しいインデックス定義を参照するように変更され、インデックスの名前が変更されます。この時点で、 &lt;code&gt;pg_index.indisvalid&lt;/code&gt; は新しいインデックスでは「true」に、古いインデックスでは「false」に切り替えられ、キャッシュの無効化が行われて、古いインデックスを参照していたすべてのセッションが無効になります。</target>
        </trans-unit>
        <trans-unit id="58e9eb20e27c19e1e0424c58bd8a9c7b575ba760" translate="yes" xml:space="preserve">
          <source>All the date/time data types also accept the special literal value &lt;code&gt;now&lt;/code&gt; to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result:</source>
          <target state="translated">すべての日付/時刻データ型も特別なリテラル値を受け入れ &lt;code&gt;now&lt;/code&gt; （再び、トランザクションの開始時刻と解釈される）現在の日付と時刻を指定します。したがって、次の3つはすべて同じ結果を返します。</target>
        </trans-unit>
        <trans-unit id="04a9db0f3580dacac057df2d96a2b53bd9011eea" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt;.</source>
          <target state="translated">すべての詳細は、 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="7055165401c8e4a16f7e52ca1e39b100c0c219f9" translate="yes" xml:space="preserve">
          <source>All the details can be found in &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt;.</source>
          <target state="translated">詳細はすべて &lt;code&gt;src/include/storage/bufpage.h&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="11f6c8098d40647f8499682bcc9a9b6ba89c0f7d" translate="yes" xml:space="preserve">
          <source>All the forms of ALTER TABLE that act on a single table, except &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;SET SCHEMA&lt;/code&gt;, &lt;code&gt;ATTACH PARTITION&lt;/code&gt;, and &lt;code&gt;DETACH PARTITION&lt;/code&gt; can be combined into a list of multiple alterations to be applied together. For example, it is possible to add several columns and/or alter the type of several columns in a single command. This is particularly useful with large tables, since only one pass over the table need be made.</source>
          <target state="translated">&lt;code&gt;RENAME&lt;/code&gt; 、 &lt;code&gt;SET SCHEMA&lt;/code&gt; 、 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; 、および &lt;code&gt;DETACH PARTITION&lt;/code&gt; を除き、単一のテーブルに作用するすべての形式のALTER TABLEを組み合わせて、一緒に適用される複数の変更のリストにすることができます。たとえば、1つのコマンドで複数の列を追加したり、複数の列のタイプを変更したりすることができます。これは、テーブルを1回パスするだけでよいため、大きなテーブルで特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f31e857d83f608bd0b8b4018bcb4f55f12705482" translate="yes" xml:space="preserve">
          <source>All the functions and operators described below that take &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;timestamp&lt;/code&gt; inputs actually come in two variants: one that takes &lt;code&gt;time with time zone&lt;/code&gt; or &lt;code&gt;timestamp with time zone&lt;/code&gt;, and one that takes &lt;code&gt;time without time zone&lt;/code&gt; or &lt;code&gt;timestamp without time zone&lt;/code&gt;. For brevity, these variants are not shown separately. Also, the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair.</source>
          <target state="translated">そのテイクの下に記載されているすべての関数と演算子 &lt;code&gt;time&lt;/code&gt; または &lt;code&gt;timestamp&lt;/code&gt; かかる1：入力は、実際には2つの種類が来る &lt;code&gt;time with time zone&lt;/code&gt; か、 &lt;code&gt;timestamp with time zone&lt;/code&gt; 、およびかかる1 &lt;code&gt;time without time zone&lt;/code&gt; か、 &lt;code&gt;timestamp without time zone&lt;/code&gt; 。簡潔にするため、これらのバリアントは個別に表示されていません。また、 &lt;code&gt;+&lt;/code&gt; 演算子と &lt;code&gt;*&lt;/code&gt; 演算子は可換ペアになります（たとえば、日付+整数と整数+日付の両方）。そのような各ペアの1つだけを示します。</target>
        </trans-unit>
        <trans-unit id="782a3c585f1fd27c2deebeab5aeef9142292fec9" translate="yes" xml:space="preserve">
          <source>All the items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; as well as &lt;code&gt;jsonb_insert&lt;/code&gt; except the last item must be present in the &lt;code&gt;target&lt;/code&gt;. If &lt;code&gt;create_missing&lt;/code&gt; is false, all items of the &lt;code&gt;path&lt;/code&gt; parameter of &lt;code&gt;jsonb_set&lt;/code&gt; must be present. If these conditions are not met the &lt;code&gt;target&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">最後の項目を除いて、 &lt;code&gt;jsonb_insert&lt;/code&gt; および &lt;code&gt;jsonb_set&lt;/code&gt; の &lt;code&gt;path&lt;/code&gt; パラメータのすべての項目が &lt;code&gt;target&lt;/code&gt; 存在する必要があります。場合 &lt;code&gt;create_missing&lt;/code&gt; は falseで、すべての項目 &lt;code&gt;path&lt;/code&gt; のパラメータ &lt;code&gt;jsonb_set&lt;/code&gt; が存在している必要があります。これらの条件が満たされない場合、 &lt;code&gt;target&lt;/code&gt; は変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="16b021d730b6ad62e07cfcc798d60a9ae4e55f2d" translate="yes" xml:space="preserve">
          <source>All the other details are the same as explained in the previous item.</source>
          <target state="translated">その他の詳細は前項目で説明した通りです。</target>
        </trans-unit>
        <trans-unit id="58d1929aa1a1a6a3046413da0a4c92627889c5ff" translate="yes" xml:space="preserve">
          <source>All the text search functions that accept an optional &lt;code&gt;regconfig&lt;/code&gt; argument will use the configuration specified by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; when that argument is omitted.</source>
          <target state="translated">オプションの &lt;code&gt;regconfig&lt;/code&gt; 引数を受け入れるすべてのテキスト検索関数は、その引数が省略されている場合、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_configで&lt;/a&gt;指定された構成を使用します。</target>
        </trans-unit>
        <trans-unit id="5fd8eaf630761d65327b4b1a07fcbae46e8425a5" translate="yes" xml:space="preserve">
          <source>All these actions are performed using the &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command, whose reference page contains details beyond those given here.</source>
          <target state="translated">これらのアクションはすべて、&lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドを使用して実行されます。そのリファレンスページには、ここに記載されている以上の詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="b94dc0adfca08e05341c41a7517a1ba1c57ee9cc" translate="yes" xml:space="preserve">
          <source>All these functions are intended to be used to lock application-defined resources, which can be identified either by a single 64-bit key value or two 32-bit key values (note that these two key spaces do not overlap). If another session already holds a conflicting lock on the same resource identifier, the functions will either wait until the resource becomes available, or return a &lt;code&gt;false&lt;/code&gt; result, as appropriate for the function. Locks can be either shared or exclusive: a shared lock does not conflict with other shared locks on the same resource, only with exclusive locks. Locks can be taken at session level (so that they are held until released or the session ends) or at transaction level (so that they are held until the current transaction ends; there is no provision for manual release). Multiple session-level lock requests stack, so that if the same resource identifier is locked three times there must then be three unlock requests to release the resource in advance of session end.</source>
          <target state="translated">これらの関数はすべて、アプリケーション定義のリソースをロックするために使用することを目的としています。これらのリソースは、単一の64ビットキー値または2つの32ビットキー値のいずれかで識別できます（これら2つのキースペースは重複しないことに注意してください）。別のセッションがすでに同じリソース識別子に対して競合するロックを保持している場合、関数はリソースが使用可能になるまで待機するか、 &lt;code&gt;false&lt;/code&gt; を返します結果、関数に応じて。ロックは共有または排他的のいずれかです。共有ロックは、同じリソース上の他の共有ロックと競合せず、排他ロックのみと競合します。ロックは、セッションレベル（解放されるかセッションが終了するまで保持されるように）またはトランザクションレベル（現在のトランザクションが終了するまで保持されるように、手動解放の規定はありません）で取得できます。複数のセッションレベルのロック要求がスタックするため、同じリソース識別子が3回ロックされた場合、セッションが終了する前にリソースを解放するために3つのロック解除要求が必要です。</target>
        </trans-unit>
        <trans-unit id="fddab2dff735a90badf611e7a98983fea7c65273" translate="yes" xml:space="preserve">
          <source>All these functions require object OIDs to identify the object to be checked. If you want to test an object by name, it is convenient to use the OID alias types (&lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, or &lt;code&gt;regdictionary&lt;/code&gt;), for example:</source>
          <target state="translated">これらすべての関数には、チェックするオブジェクトを識別するためのオブジェクトOIDが必要です。オブジェクトを名前でテストする場合は、OIDエイリアスタイプ（ &lt;code&gt;regclass&lt;/code&gt; 、 &lt;code&gt;regtype&lt;/code&gt; 、 &lt;code&gt;regprocedure&lt;/code&gt; 、 &lt;code&gt;regoperator&lt;/code&gt; 、 &lt;code&gt;regconfig&lt;/code&gt; 、または &lt;code&gt;regdictionary&lt;/code&gt; ）を使用すると便利です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="5eb86c80e753870bd74e864dca4813e41a9bf81c" translate="yes" xml:space="preserve">
          <source>All this is encrypted with the session key and placed in the data packet.</source>
          <target state="translated">これらはすべてセッションキーで暗号化され、データパケットに入れられます。</target>
        </trans-unit>
        <trans-unit id="79ae9218d6216a25f546357f769737d4eb8e6a9b" translate="yes" xml:space="preserve">
          <source>All this is happening within the transaction block, so none of it is visible to other database sessions. When and if you commit the transaction block, the committed actions become visible as a unit to other sessions, while the rolled-back actions never become visible at all.</source>
          <target state="translated">これらはすべてトランザクションブロック内で起こっているので、他のデータベースセッションからは何も見えません。トランザクションブロックをコミットすると、コミットされたアクションは他のセッションからユニットとして見えるようになりますが、ロールバックされたアクションは全く見えなくなります。</target>
        </trans-unit>
        <trans-unit id="f5fad09671c41f98ab40f3e4d5ed6015e3ae8fcb" translate="yes" xml:space="preserve">
          <source>All timezone-aware dates and times are stored internally in UTC. They are converted to local time in the zone specified by the &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; configuration parameter before being displayed to the client.</source>
          <target state="translated">すべてのタイムゾーン対応の日付と時刻は、内部でUTCに格納されます。これらは、クライアントに表示される前に、&lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt;構成パラメーターで指定されたゾーンの現地時間に変換されます。</target>
        </trans-unit>
        <trans-unit id="d5322b3927e2a3af2ef8b19f81ff10045b29cd91" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfrozenxid&lt;/code&gt; values.</source>
          <target state="translated">これより前のすべてのトランザクションIDは、このデータベースで永続的な（「凍結された」）トランザクションIDに置き換えられています。これは、トランザクションIDの折り返しを防止したり、 &lt;code&gt;pg_xact&lt;/code&gt; を縮小したりするために、データベースをバキュームする必要があるかどうかを追跡するために使用されます。これは、テーブルごとの &lt;code&gt;pg_class&lt;/code&gt; の最小値です。 &lt;code&gt;relfrozenxid&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="086e1ad2933d663306e6cec529b31029a01389df" translate="yes" xml:space="preserve">
          <source>All transaction IDs before this one have been replaced with a permanent (&amp;ldquo;frozen&amp;rdquo;) transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent transaction ID wraparound or to allow &lt;code&gt;pg_xact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidTransactionId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">この表の前のすべてのトランザクションIDは、永続的な（「凍結された」）トランザクションIDに置き換えられています。これは、トランザクションIDの折り返しを防止したり、 &lt;code&gt;pg_xact&lt;/code&gt; を縮小したりするために、テーブルをバキュームする必要があるかどうかを追跡するために使用されます。リレーションがテーブルでない場合はゼロ（ &lt;code&gt;InvalidTransactionId&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f420391c504d54ccc175474041008eed502760b8" translate="yes" xml:space="preserve">
          <source>All type conversion rules are designed with several principles in mind:</source>
          <target state="translated">すべてのタイプ変換ルールは、いくつかの原則を念頭に置いて設計されています。</target>
        </trans-unit>
        <trans-unit id="109d3489123ca72cb87beebd6d4f929a800626a1" translate="yes" xml:space="preserve">
          <source>All values must be single-quoted. Escape single quotes used within a value with a backslash. Backslashes meant as data can, but need not, be doubled; this follows Perl's rules for simple quoted literals. Note that backslashes appearing as data will be treated as escapes by the bootstrap scanner, according to the same rules as for escape string constants (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;Section 4.1.2.2&lt;/a&gt;); for example &lt;code&gt;\t&lt;/code&gt; converts to a tab character. If you actually want a backslash in the final value, you will need to write four of them: Perl strips two, leaving &lt;code&gt;\\&lt;/code&gt; for the bootstrap scanner to see.</source>
          <target state="translated">すべての値は単一引用符で囲む必要があります。値内で使用されている単一引用符をバックスラッシュでエスケープします。データとしてのバックスラッシュは2倍にすることができますが、2倍にする必要はありません。これは、単純な引用符付きリテラルに関するPerlの規則に従います。データとして表示されるバックスラッシュは、エスケープ文字列定数の場合と同じルールに従って（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS-ESCAPE&quot;&gt;セクション4.1.2.2を&lt;/a&gt;参照）、ブートストラップスキャナーによってエスケープとして扱われることに注意してください。たとえば、 &lt;code&gt;\t&lt;/code&gt; はタブ文字に変換されます。最終値に実際にバックスラッシュが必要な場合は、4つを記述する必要があります。Perlは2つを &lt;code&gt;\\&lt;/code&gt; し、ブートストラップスキャナーが表示できるように\\を残します。</target>
        </trans-unit>
        <trans-unit id="b86517f687c2cdb1c2c9f1b4d883ebc3f627ec3f" translate="yes" xml:space="preserve">
          <source>All weather records belonging to Hayward are removed.</source>
          <target state="translated">ヘイワードに属する気象記録はすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="ad7019350bb4e8cf04fe867a5271fe82db68f450" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Andrey Oktyabrski did a great work on adding new functions and operations.</source>
          <target state="translated">すべての作業はTeodor Sigaev（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@sigaev.ru&quot;&gt;teodor@sigaev.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; ）とOleg Bartunov（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ）によって行われました。詳細については、&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http：//www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;を参照してください。Andrey Oktyabrskiは、新しい機能と操作を追加するのに素晴らしい仕事をしました。</target>
        </trans-unit>
        <trans-unit id="4288707b0efed23059331a4d938505610024687d" translate="yes" xml:space="preserve">
          <source>All work was done by Teodor Sigaev (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt;) and Oleg Bartunov (&lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;). See &lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http://www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt; for additional information. Authors would like to thank Eugeny Rodichev for helpful discussions. Comments and bug reports are welcome.</source>
          <target state="translated">すべての作業はTeodor Sigaev（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:teodor@stack.net&quot;&gt;teodor@stack.net&lt;/a&gt;&amp;gt;&lt;/code&gt; ）とOleg Bartunov（ &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; ）が行いました。詳細については、&lt;a href=&quot;http://www.sai.msu.su/~megera/postgres/gist/&quot;&gt;http：//www.sai.msu.su/~megera/postgres/gist/&lt;/a&gt;を参照してください。著者は、有益な議論をしてくれたEugeny Rodichevに感謝します。コメントやバグレポートは大歓迎です。</target>
        </trans-unit>
        <trans-unit id="f34719d5f269658e4173abae81da05904e2f90b4" translate="yes" xml:space="preserve">
          <source>Allow executing programs on the database server as the user the database runs as with COPY and other functions which allow executing a server-side program.</source>
          <target state="translated">データベースサーバ上のプログラムを、COPYなどのサーバサイドプログラムの実行を許可する機能で、データベースが実行するユーザとして実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="cb7c466538ce28419fa5a720e552c9faf281f480" translate="yes" xml:space="preserve">
          <source>Allow question mark as placeholder for compatibility reasons. This used to be the default long ago.</source>
          <target state="translated">互換性の理由からプレースホルダとしてクエスチョンマークを許可します。これはずっと前まではデフォルトでした。</target>
        </trans-unit>
        <trans-unit id="45c4206b6f2ee2080c8508868577dbea292b358b" translate="yes" xml:space="preserve">
          <source>Allow reading files from any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">データベースがサーバ上でアクセスできる任意の場所から、COPYや他のファイルアクセス機能を使ってファイルを読み込めるようにします。</target>
        </trans-unit>
        <trans-unit id="4f03ae30c79df36f9c350de6f69bb0b74ebd9a17" translate="yes" xml:space="preserve">
          <source>Allow the connection unconditionally. This method allows anyone that can connect to the PostgreSQL database server to login as any PostgreSQL user they wish, without the need for a password or any other authentication. See &lt;a href=&quot;auth-trust&quot;&gt;Section 20.4&lt;/a&gt; for details.</source>
          <target state="translated">無条件に接続を許可します。この方法では、PostgreSQLデータベースサーバーに接続できるすべてのユーザーが、パスワードやその他の認証を必要とせずに、希望するPostgreSQLユーザーとしてログインできます。詳細は&lt;a href=&quot;auth-trust&quot;&gt;項20.4&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="015b98532a3fe432082ea0986c77ac2b5c3dbd03" translate="yes" xml:space="preserve">
          <source>Allow writing to files in any location the database can access on the server with COPY and other file-access functions.</source>
          <target state="translated">データベースがサーバ上でアクセスできる任意の場所にあるファイルへの書き込みを、COPYや他のファイルアクセス機能を使って許可します。</target>
        </trans-unit>
        <trans-unit id="f8d71f61a1ee50e974ca597aaf1819fc96625f9e" translate="yes" xml:space="preserve">
          <source>Allowed Access</source>
          <target state="translated">許可されたアクセス</target>
        </trans-unit>
        <trans-unit id="76b9c247fd0d4d88ff31bffe6ae1c77fef7baa54" translate="yes" xml:space="preserve">
          <source>Allowed values of an enum parameter (null for non-enum values)</source>
          <target state="translated">enum パラメータの許容値 (enum 以外の値の場合は null)</target>
        </trans-unit>
        <trans-unit id="52773c9887de8a80602d4df5e04153e486ddd9ba" translate="yes" xml:space="preserve">
          <source>Allowed, but not in PG</source>
          <target state="translated">許可されていますが、PGでは許可されていません。</target>
        </trans-unit>
        <trans-unit id="70154177253445e1612a606653b6fcdbcd216626" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; of a row from a table, view, etc. (In practice, any nontrivial &lt;code&gt;DELETE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to delete.)</source>
          <target state="translated">テーブルやビューなどからの行の&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;を許可します（実際には、重要な &lt;code&gt;DELETE&lt;/code&gt; コマンドは、削除する行を決定するためにテーブル列を参照する必要があるため、 &lt;code&gt;SELECT&lt;/code&gt; 特権も必要になります。）</target>
        </trans-unit>
        <trans-unit id="892a331d54a97c6a90c5cbe15f359d1d4e9d66bd" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; of a new row into a table, view, etc. Can be granted on specific column(s), in which case only those columns may be assigned to in the &lt;code&gt;INSERT&lt;/code&gt; command (other columns will therefore receive default values). Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROM.</source>
          <target state="translated">テーブルやビューなどへの新しい行の&lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;を許可します。特定の列に付与できます。その場合、 &lt;code&gt;INSERT&lt;/code&gt; コマンドでそれらの列のみを割り当てることができます（他の列はデフォルト値を受け取ります）。&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; FROMの使用も許可します。</target>
        </trans-unit>
        <trans-unit id="91a5de46959e59448d7fbb7e22418ff9bdc9f1e0" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; from any column, or specific column(s), of a table, view, materialized view, or other table-like object. Also allows use of &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TO. This privilege is also needed to reference existing column values in &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;. For sequences, this privilege also allows use of the &lt;code&gt;currval&lt;/code&gt; function. For large objects, this privilege allows the object to be read.</source>
          <target state="translated">テーブル、ビュー、マテリアライズドビュー、またはその他のテーブルのようなオブジェクトの任意の列または特定の列からの&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;を許可します。&lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt; TOの使用も許可します。この特権は、&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt;で既存の列値を参照するためにも必要です。シーケンスの場合、この特権は &lt;code&gt;currval&lt;/code&gt; 関数の使用も許可します。大きなオブジェクトの場合、この権限により、オブジェクトを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="504fe161b61ac15d1f6a3f6705ae69c3e419baf8" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt; on a table, view, etc.</source>
          <target state="translated">テーブル、ビューなどで&lt;a href=&quot;sql-truncate&quot;&gt;TRUNCATE&lt;/a&gt;を許可します。</target>
        </trans-unit>
        <trans-unit id="82bfc74ea2d5fe544ab86144ec140977da660bfb" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; of any column, or specific column(s), of a table, view, etc. (In practice, any nontrivial &lt;code&gt;UPDATE&lt;/code&gt; command will require &lt;code&gt;SELECT&lt;/code&gt; privilege as well, since it must reference table columns to determine which rows to update, and/or to compute new values for columns.) &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; and &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; also require this privilege on at least one column, in addition to the &lt;code&gt;SELECT&lt;/code&gt; privilege. For sequences, this privilege allows use of the &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; functions. For large objects, this privilege allows writing or truncating the object.</source>
          <target state="translated">テーブル、ビューなどの任意の列、または特定の列の&lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt;を許可します（実際には、重要な &lt;code&gt;UPDATE&lt;/code&gt; コマンドでも、更新する行を決定するためにテーブル列を参照する必要があるため、 &lt;code&gt;SELECT&lt;/code&gt; 特権が必要になります。 /または列の新しい値を計算するには。） &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; および &lt;code&gt;SELECT ... FOR SHARE&lt;/code&gt; には、 &lt;code&gt;SELECT&lt;/code&gt; 特権に加えて、少なくとも1つの列に対するこの特権も必要です。シーケンスの場合、この特権により、 &lt;code&gt;nextval&lt;/code&gt; および &lt;code&gt;setval&lt;/code&gt; 関数を使用できます。大きなオブジェクトの場合、この権限により、オブジェクトの書き込みまたは切り捨てが許可されます。</target>
        </trans-unit>
        <trans-unit id="8b7544659291101bf531ad89a7c0f68e28dd25e9" translate="yes" xml:space="preserve">
          <source>Allows calling a function or procedure, including use of any operators that are implemented on top of the function. This is the only type of privilege that is applicable to functions and procedures.</source>
          <target state="translated">関数またはプロシージャの呼び出しを許可し、その関数の上に実装されている演算子の使用を含めて、関数またはプロシージャの呼び出しを許可します。これは、関数やプロシージャに適用される特権の唯一のタイプです。</target>
        </trans-unit>
        <trans-unit id="572f9c4ee818f964a8f341a7ab3b49d87de0de38" translate="yes" xml:space="preserve">
          <source>Allows creation of a foreign key constraint referencing a table, or specific column(s) of a table.</source>
          <target state="translated">テーブル、またはテーブルの特定の列を参照する外部キー制約の作成を許可します。</target>
        </trans-unit>
        <trans-unit id="3f1fc4350d1383af032d326e29b30797181bb0ee" translate="yes" xml:space="preserve">
          <source>Allows creation of a trigger on a table, view, etc.</source>
          <target state="translated">テーブルやビューなどにトリガーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="d221a1c104e0d63607ae68533525fac6cb3d90ab" translate="yes" xml:space="preserve">
          <source>Allows definition of user-visible parameters that control operator class behavior.</source>
          <target state="translated">演算子クラスの動作を制御する、ユーザーから見えるパラメータの定義を許可します。</target>
        </trans-unit>
        <trans-unit id="3cd1d90a2a8e348dc3397a5abdad6812b9706afc" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details.</source>
          <target state="translated">システムとデータベースのユーザー名の間のマッピングを可能にします。詳細は&lt;a href=&quot;auth-username-maps&quot;&gt;項20.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="62730a57186fa6b4b57c86a98eed1f6819a0f0da" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a GSSAPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">システムとデータベースのユーザー名の間のマッピングを可能にします。詳細は&lt;a href=&quot;auth-username-maps&quot;&gt;項20.2&lt;/a&gt;を参照してください。 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または、あまり一般的ではないが、 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; /hostbased@EXAMPLE.COM）などのGSSAPI / Kerberosプリンシパルの場合、マッピングに使用されるユーザー名は、 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )です。）、 &lt;code&gt;include_realm&lt;/code&gt; が0に設定されていない限り、マッピングの際に &lt;code&gt;username&lt;/code&gt; （または &lt;code&gt;username/hostbased&lt;/code&gt; ）はシステムユーザー名として表示されます。</target>
        </trans-unit>
        <trans-unit id="3a8e3ba433eb210e869a35f227d0944a825933f7" translate="yes" xml:space="preserve">
          <source>Allows for mapping between system and database user names. See &lt;a href=&quot;auth-username-maps&quot;&gt;Section 20.2&lt;/a&gt; for details. For a SSPI/Kerberos principal, such as &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or, less commonly, &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;), the user name used for mapping is &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; (or &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt;, respectively), unless &lt;code&gt;include_realm&lt;/code&gt; has been set to 0, in which case &lt;code&gt;username&lt;/code&gt; (or &lt;code&gt;username/hostbased&lt;/code&gt;) is what is seen as the system user name when mapping.</source>
          <target state="translated">システムとデータベースのユーザー名の間のマッピングを可能にします。詳細は&lt;a href=&quot;auth-username-maps&quot;&gt;項20.2&lt;/a&gt;を参照してください。 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または、あまり一般的ではないが、 &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; /hostbased@EXAMPLE.COM）などのSSPI / Kerberosプリンシパルの場合、マッピングに使用されるユーザー名は、 &lt;code&gt;username@EXAMPLE.COM&lt;/code&gt; （または &lt;code&gt;username/hostbased@EXAMPLE.COM&lt;/code&gt; )です。それぞれ））、 &lt;code&gt;include_realm&lt;/code&gt; が0に設定されていない限り、その場合、 &lt;code&gt;username&lt;/code&gt; （または &lt;code&gt;username/hostbased&lt;/code&gt; ）は、マッピング時にシステムユーザー名と見なされます。</target>
        </trans-unit>
        <trans-unit id="20552df65c50fc0052b6d2499b3762b86d6eff44" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables as well as certain other risky actions on system tables. This is otherwise not allowed even for superusers. Ill-advised use of this setting can cause irretrievable data loss or seriously corrupt the database system. Only superusers can change this setting.</source>
          <target state="translated">システムテーブルの構造の変更や、システムテーブル上での他の特定の危険なアクションを許可します。この設定は、スーパーユーザであっても許可されていません。この設定を誤って使用すると、取り返しのつかないデータの損失やデータベースシステムの深刻な破損を引き起こす可能性があります。この設定を変更できるのはスーパーユーザだけです。</target>
        </trans-unit>
        <trans-unit id="b64278e6ff1ecca0c4404ebfb33c1f4ece933ea1" translate="yes" xml:space="preserve">
          <source>Allows modification of the structure of system tables. This is used by &lt;code&gt;initdb&lt;/code&gt;. This parameter can only be set at server start.</source>
          <target state="translated">システムテーブルの構造を変更できます。これは &lt;code&gt;initdb&lt;/code&gt; によって使用されます。このパラメータは、サーバーの起動時にのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="f71053472aff6714ed79ad6bf71416990ec41156" translate="yes" xml:space="preserve">
          <source>Allows multiple master servers</source>
          <target state="translated">複数のマスターサーバーを使用可能</target>
        </trans-unit>
        <trans-unit id="7e9d5d5ab57892df439ee070a4596c150e6f73e7" translate="yes" xml:space="preserve">
          <source>Allows remote clients to connect via TCP/IP (Internet domain) connections. Without this option, only local connections are accepted. This option is equivalent to setting &lt;code&gt;listen_addresses&lt;/code&gt; to &lt;code&gt;*&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt; or via &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">リモートクライアントがTCP / IP（インターネットドメイン）接続を介して接続できるようにします。このオプションがない場合、ローカル接続のみが受け入れられます。このオプションは、 &lt;code&gt;postgresql.conf&lt;/code&gt; または &lt;code&gt;-h&lt;/code&gt; で &lt;code&gt;listen_addresses&lt;/code&gt; を &lt;code&gt;*&lt;/code&gt; に設定することと同等です。</target>
        </trans-unit>
        <trans-unit id="003e89305b8189195bfe70e6a4f7ecd0e58a566e" translate="yes" xml:space="preserve">
          <source>Allows sampling the duration of completed statements that ran for at least the specified amount of time. This produces the same kind of log entries as &lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt;, but only for a subset of the executed statements, with sample rate controlled by &lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT-SAMPLE-RATE&quot;&gt;log_statement_sample_rate&lt;/a&gt;. For example, if you set it to &lt;code&gt;100ms&lt;/code&gt; then all SQL statements that run 100ms or longer will be considered for sampling. Enabling this parameter can be helpful when the traffic is too high to log all queries. If this value is specified without units, it is taken as milliseconds. Setting this to zero samples all statement durations. &lt;code&gt;-1&lt;/code&gt; (the default) disables sampling statement durations. Only superusers can change this setting.</source>
          <target state="translated">少なくとも指定された時間実行された完了したステートメントの期間をサンプリングできます。これにより、&lt;a href=&quot;runtime-config-logging#GUC-LOG-MIN-DURATION-STATEMENT&quot;&gt;log_min_duration_statement&lt;/a&gt;と同じ種類のログエントリが生成されますが、実行されたステートメントのサブセットに対してのみ、サンプルレートは&lt;a href=&quot;runtime-config-logging#GUC-LOG-STATEMENT-SAMPLE-RATE&quot;&gt;log_statement_sample_rate&lt;/a&gt;によって制御されます。たとえば、 &lt;code&gt;100ms&lt;/code&gt; 設定すると、100ミリ秒以上実行されるすべてのSQLステートメントがサンプリングの対象と見なされます。このパラメータを有効にすると、トラフィックが多すぎてすべてのクエリをログに記録できない場合に役立ちます。この値が単位なしで指定されている場合、ミリ秒と見なされます。これをゼロに設定すると、すべてのステートメント期間がサンプリングされます。 &lt;code&gt;-1&lt;/code&gt; （デフォルト）は、サンプリングステートメントの期間を無効にします。この設定を変更できるのはスーパーユーザーのみです。</target>
        </trans-unit>
        <trans-unit id="63eeac10a55f83f249e5c5462559d1f7da0f93f8" translate="yes" xml:space="preserve">
          <source>Allows temporary tables to be created while using the database.</source>
          <target state="translated">データベースを使用している間に一時的なテーブルを作成できるようにします。</target>
        </trans-unit>
        <trans-unit id="08e9a64b986b6e59ae70cdec6ed43f46a0d1ac74" translate="yes" xml:space="preserve">
          <source>Allows the grantee to connect to the database. This privilege is checked at connection startup (in addition to checking any restrictions imposed by &lt;code&gt;pg_hba.conf&lt;/code&gt;).</source>
          <target state="translated">被付与者がデータベースに接続できるようにします。この権限は、接続の起動時にチェックされます（ &lt;code&gt;pg_hba.conf&lt;/code&gt; によって課された制限のチェックに加えて）。</target>
        </trans-unit>
        <trans-unit id="755cae42faeb86185341cbd11d37dba18dac7fda" translate="yes" xml:space="preserve">
          <source>Allows the leader process to execute the query plan under &lt;code&gt;Gather&lt;/code&gt; and &lt;code&gt;Gather Merge&lt;/code&gt; nodes instead of waiting for worker processes. The default is &lt;code&gt;on&lt;/code&gt;. Setting this value to &lt;code&gt;off&lt;/code&gt; reduces the likelihood that workers will become blocked because the leader is not reading tuples fast enough, but requires the leader process to wait for worker processes to start up before the first tuples can be produced. The degree to which the leader can help or hinder performance depends on the plan type, number of workers and query duration.</source>
          <target state="translated">リーダープロセスが、ワーカープロセスを待つ代わりに、 &lt;code&gt;Gather&lt;/code&gt; および &lt;code&gt;Gather Merge&lt;/code&gt; ノードの下でクエリプランを実行できるようにします。デフォルトは &lt;code&gt;on&lt;/code&gt; です。この値を &lt;code&gt;off&lt;/code&gt; 設定すると、リーダーがタプルを十分に速く読み取らないためにワーカーがブロックされる可能性が低くなりますが、最初のタプルが生成される前にリーダープロセスがワーカープロセスの起動を待機する必要があります。リーダーがパフォーマンスを支援または阻害できる程度は、プランのタイプ、ワーカーの数、クエリの期間によって異なります。</target>
        </trans-unit>
        <trans-unit id="65de6c1d93f488d023688afb5ecd9e64a2816fb2" translate="yes" xml:space="preserve">
          <source>Allows the structure of system tables to be modified. This is used by &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">システムテーブルの構造を変更できます。これは &lt;code&gt;initdb&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="eb3d21c22361245b017a84ef20398543e1812a86" translate="yes" xml:space="preserve">
          <source>Allows the use of parallel queries for testing purposes even in cases where no performance benefit is expected. The allowed values of &lt;code&gt;force_parallel_mode&lt;/code&gt; are &lt;code&gt;off&lt;/code&gt; (use parallel mode only when it is expected to improve performance), &lt;code&gt;on&lt;/code&gt; (force parallel query for all queries for which it is thought to be safe), and &lt;code&gt;regress&lt;/code&gt; (like &lt;code&gt;on&lt;/code&gt;, but with additional behavior changes as explained below).</source>
          <target state="translated">パフォーマンスの向上が期待できない場合でも、テストのために並列クエリを使用できます。 &lt;code&gt;force_parallel_mode&lt;/code&gt; の許容値は、 &lt;code&gt;off&lt;/code&gt; （パフォーマンスの向上が期待される場合にのみ並列モードを使用）、 &lt;code&gt;on&lt;/code&gt; （安全であると考えられるすべてのクエリに対して並列クエリを強制）、および &lt;code&gt;regress&lt;/code&gt; （ &lt;code&gt;on&lt;/code&gt; と同様ですが、動作の変更が追加されています）以下で説明します）。</target>
        </trans-unit>
        <trans-unit id="8f83e0d9b7de16d5d69bb100f20671e8c51dd641" translate="yes" xml:space="preserve">
          <source>Allows users in the same group as the cluster owner to read all cluster files created by &lt;code&gt;initdb&lt;/code&gt;. This option is ignored on Windows as it does not support POSIX-style group permissions.</source>
          <target state="translated">クラスター所有者と同じグループのユーザーは、 &lt;code&gt;initdb&lt;/code&gt; によって作成されたすべてのクラスターファイルを読み取ることができます。このオプションはPOSIXスタイルのグループ権限をサポートしていないため、Windowsでは無視されます。</target>
        </trans-unit>
        <trans-unit id="4cc45bc94d25b1e0d694fb6d8a93df9410ca68c9" translate="yes" xml:space="preserve">
          <source>Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt;. Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</source>
          <target state="translated">Almost all &lt;code&gt;DROP&lt;/code&gt; commands in PostgreSQL support specifying &lt;code&gt;CASCADE&lt;/code&gt; . Of course, the nature of the possible dependencies varies with the type of the object. You can also write &lt;code&gt;RESTRICT&lt;/code&gt; instead of &lt;code&gt;CASCADE&lt;/code&gt; to get the default behavior, which is to prevent dropping objects that any other objects depend on.</target>
        </trans-unit>
        <trans-unit id="328cfccc1cde2a65060e2ec7ece0e64b0b2e4b32" translate="yes" xml:space="preserve">
          <source>Also be careful when making up test data, which is often unavoidable when the application is not yet in production. Values that are very similar, completely random, or inserted in sorted order will skew the statistics away from the distribution that real data would have.</source>
          <target state="translated">また、テストデータを作成する際には、アプリケーションがまだ本番になっていない場合には避けられないことが多いので注意してください。値が非常に似ていたり、完全にランダムだったり、ソートされた順序で挿入されていたりすると、実際のデータが持つであろう分布から統計量が歪んでしまいます。</target>
        </trans-unit>
        <trans-unit id="1e6eb3c256a63ce7e1a4b490a67bfd7124a09fa5" translate="yes" xml:space="preserve">
          <source>Also calculate statistics for use by the optimizer.</source>
          <target state="translated">また、オプティマイザが使用するための統計を計算します。</target>
        </trans-unit>
        <trans-unit id="1310f648148c138c431f0390dd1598c9ea4cf18b" translate="yes" xml:space="preserve">
          <source>Also known as &lt;em&gt;WAL segment&lt;/em&gt; or &lt;em&gt;WAL segment file&lt;/em&gt;. Each of the sequentially-numbered files that provide storage space for &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. The files are all of the same predefined size and are written in sequential order, interspersing changes as they occur in multiple simultaneous sessions. If the system crashes, the files are read in order, and each of the changes is replayed to restore the system to the state it was in before the crash.</source>
          <target state="translated">&lt;em&gt;WALセグメント&lt;/em&gt;または&lt;em&gt;WALセグメントファイルと&lt;/em&gt;も呼ばれ&lt;em&gt;ます&lt;/em&gt;。&lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WALの&lt;/a&gt;ストレージスペースを提供する連番の各ファイル。ファイルはすべて同じ事前定義されたサイズであり、複数の同時セッションで発生する変更を散在させて、順番に書き込まれます。システムがクラッシュした場合、ファイルが順番に読み取られ、各変更が再生されて、システムがクラッシュ前の状態に復元されます。</target>
        </trans-unit>
        <trans-unit id="7f5b262e2738c5ae943ae295de4ef09eb42b98a8" translate="yes" xml:space="preserve">
          <source>Also note that some element types, such as &lt;code&gt;timestamp&lt;/code&gt;, have a notion of &quot;infinity&quot;, which is just another value that can be stored. This is different from &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;, which are not real values that can be stored, but rather they are ways of saying that the value is unbounded. &lt;code&gt;MAXVALUE&lt;/code&gt; can be thought of as being greater than any other value, including &quot;infinity&quot; and &lt;code&gt;MINVALUE&lt;/code&gt; as being less than any other value, including &quot;minus infinity&quot;. Thus the range &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; is not an empty range; it allows precisely one value to be stored &amp;mdash; &quot;infinity&quot;.</source>
          <target state="translated">また、 &lt;code&gt;timestamp&lt;/code&gt; などの一部の要素タイプには、「無限」という概念があることに注意してください。これは、格納できるもう1つの値です。これは異なっている &lt;code&gt;MINVALUE&lt;/code&gt; と &lt;code&gt;MAXVALUE&lt;/code&gt; 保存することができ、実際の値ではない、のではなく、彼らは値が無制限であることを言うの方法があります。 &lt;code&gt;MAXVALUE&lt;/code&gt; は「無限大」を含む他のどの値よりも大きいと考えることができ、 &lt;code&gt;MINVALUE&lt;/code&gt; は「マイナス無限大」を含む他のどの値よりも小さいと考えることができます。したがって、範囲 &lt;code&gt;FROM ('infinity') TO (MAXVALUE)&lt;/code&gt; は空の範囲ではありません。正確に1つの値を格納できます&amp;mdash;「無限」。</target>
        </trans-unit>
        <trans-unit id="7722ff63b95d490d6107aefdee57299789fdc839" translate="yes" xml:space="preserve">
          <source>Also of note to those converting from other environments is the fact that &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; does not ensure that a concurrent transaction will not update or delete a selected row. To do that in PostgreSQL you must actually update the row, even if no values need to be changed. &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;&lt;em&gt;temporarily blocks&lt;/em&gt; other transactions from acquiring the same lock or executing an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; which would affect the locked row, but once the transaction holding this lock commits or rolls back, a blocked transaction will proceed with the conflicting operation unless an actual &lt;code&gt;UPDATE&lt;/code&gt; of the row was performed while the lock was held.</source>
          <target state="translated">他の環境から変換する場合の注意点として、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; では、並行トランザクションが選択された行を更新または削除しないことが保証されないという事実があります。 PostgreSQLでこれを行うには、値を変更する必要がない場合でも、実際に行を更新する必要があります。 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; は、&lt;em&gt;一時的にブロック&lt;/em&gt;同じロックを取得または実行から他のトランザクションを &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; ロックされた行に影響を与えるだろうが、トランザクション一旦バックこのロックコミットまたはロールを保持し、ブロックされたトランザクションは、実際のない限り、競合する操作を進める &lt;code&gt;UPDATE&lt;/code&gt; 行がロックされている間に実行されました。</target>
        </trans-unit>
        <trans-unit id="89140b7833f6956c6f82e686c2158ff1b251e443" translate="yes" xml:space="preserve">
          <source>Also see the prefix operator &lt;code&gt;^@&lt;/code&gt; and corresponding &lt;code&gt;starts_with&lt;/code&gt; function, which are useful in cases where simply matching the beginning of a string is needed.</source>
          <target state="translated">プレフィックス演算子 &lt;code&gt;^@&lt;/code&gt; および対応する &lt;code&gt;starts_with&lt;/code&gt; 関数も参照してください。これらは、文字列の先頭を単純に一致させる必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="43ae5053feb0121ca9119b68bf8c270c3a3bfe40" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;INHERITS&lt;/code&gt;, columns and constraints copied by &lt;code&gt;LIKE&lt;/code&gt; are not merged with similarly named columns and constraints. If the same name is specified explicitly or in another &lt;code&gt;LIKE&lt;/code&gt; clause, an error is signaled.</source>
          <target state="translated">また、 &lt;code&gt;INHERITS&lt;/code&gt; とは異なり、 &lt;code&gt;LIKE&lt;/code&gt; によってコピーされた列と制約は、同様の名前の列と制約とマージされません。同じ名前が明示的にまたは別の &lt;code&gt;LIKE&lt;/code&gt; 句で指定されている場合、エラーが通知されます。</target>
        </trans-unit>
        <trans-unit id="4bd7db918c0ec048fb1da60e94aef9f53bffd77b" translate="yes" xml:space="preserve">
          <source>Also you can use an index on the &lt;code&gt;t&lt;/code&gt; column for word similarity or strict word similarity. Typical queries are:</source>
          <target state="translated">また、単語の類似性または厳密な単語の類似性のために &lt;code&gt;t&lt;/code&gt; 列のインデックスを使用できます。一般的なクエリは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d4ce61ad95c8576f718ac10e1c2327127884475a" translate="yes" xml:space="preserve">
          <source>Also you can use the standard SQL syntax &lt;code&gt;SET NAMES&lt;/code&gt; for this purpose:</source>
          <target state="translated">また、この目的で標準SQL構文 &lt;code&gt;SET NAMES&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="a6c555a30398b57943351e6fa4960aad56c86fc4" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;*&lt;/code&gt; can be attached to a lexeme to specify prefix matching:</source>
          <target state="translated">また、 &lt;code&gt;*&lt;/code&gt; を語彙素に付加して、プレフィックスの一致を指定できます。</target>
        </trans-unit>
        <trans-unit id="9a92606f5ea158e9240f422542ed2e1cf20e61fc" translate="yes" xml:space="preserve">
          <source>Also, GIN index supports &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, which perform &lt;code&gt;jsonpath&lt;/code&gt; matching.</source>
          <target state="translated">また、GINインデックスは &lt;code&gt;@@&lt;/code&gt; と &lt;code&gt;@?&lt;/code&gt; をサポートしています。 &lt;code&gt;jsonpath&lt;/code&gt; マッチングを実行する演算子。</target>
        </trans-unit>
        <trans-unit id="33ec741b0c71e2493174674607bdd7cee851a3f4" translate="yes" xml:space="preserve">
          <source>Also, a reverse lookup is necessary to implement the suffix matching feature, because the actual client host name needs to be known in order to match it against the pattern.</source>
          <target state="translated">また、サフィックスマッチング機能を実装するためには、実際のクライアントホスト名を知っておく必要があるため、逆引きが必要です。</target>
        </trans-unit>
        <trans-unit id="dbee7ce8bd2c9aaff2ced252585c86f91ebda134" translate="yes" xml:space="preserve">
          <source>Also, a trigger definition can specify a Boolean &lt;code&gt;WHEN&lt;/code&gt; condition, which will be tested to see whether the trigger should be fired. In row-level triggers the &lt;code&gt;WHEN&lt;/code&gt; condition can examine the old and/or new values of columns of the row. Statement-level triggers can also have &lt;code&gt;WHEN&lt;/code&gt; conditions, although the feature is not so useful for them since the condition cannot refer to any values in the table.</source>
          <target state="translated">また、トリガー定義はブール &lt;code&gt;WHEN&lt;/code&gt; 条件を指定できます。これは、トリガーを起動する必要があるかどうかを確認するためにテストされます。行レベルのトリガーでは、 &lt;code&gt;WHEN&lt;/code&gt; 条件は行の列の古い値または新しい値、あるいはその両方を調べることができます。ステートメントレベルのトリガーには &lt;code&gt;WHEN&lt;/code&gt; 条件を設定することもできますが、条件はテーブル内の値を参照できないため、この機能はあまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="51c091c0aef22b8b4cc2fa3614299c508ab0362c" translate="yes" xml:space="preserve">
          <source>Also, by default there is limited information available about the selectivity of functions. However, if you create an expression index that uses a function call, useful statistics will be gathered about the function, which can greatly improve query plans that use the expression index.</source>
          <target state="translated">また、デフォルトでは関数の選択性について利用できる情報は限られています。しかし、関数呼び出しを使用する式インデックスを作成した場合、関数について有用な統計情報が収集され、式インデックスを使用するクエリプランを大幅に改善することができます。</target>
        </trans-unit>
        <trans-unit id="918098440d0526280449d26ec531d4e4ea959670" translate="yes" xml:space="preserve">
          <source>Also, for B-tree indexes, a freshly-constructed index is slightly faster to access than one that has been updated many times because logically adjacent pages are usually also physically adjacent in a newly built index. (This consideration does not apply to non-B-tree indexes.) It might be worthwhile to reindex periodically just to improve access speed.</source>
          <target state="translated">また、B-treeインデックスの場合、何度も更新されたインデックスよりも、新しく構築されたばかりのインデックスの方がアクセス速度が若干速くなります(この考慮はB-tree以外のインデックスには適用されません)。(この考慮事項は非B-treeインデックスには適用されません。)アクセス速度を向上させるためだけに定期的にインデックスを更新することは価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="be3a3382ab5cfef83a6b9ee1e118c05d47eb696d" translate="yes" xml:space="preserve">
          <source>Also, for data types for which there is a natural distance metric, &lt;code&gt;btree_gist&lt;/code&gt; defines a distance operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;, and provides GiST index support for nearest-neighbor searches using this operator. Distance operators are provided for &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float4&lt;/code&gt;, &lt;code&gt;float8&lt;/code&gt;, &lt;code&gt;timestamp with time zone&lt;/code&gt;, &lt;code&gt;timestamp without time zone&lt;/code&gt;, &lt;code&gt;time without time zone&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;interval&lt;/code&gt;, &lt;code&gt;oid&lt;/code&gt;, and &lt;code&gt;money&lt;/code&gt;.</source>
          <target state="translated">また、自然距離メトリックが存在するデータ型の場合、 &lt;code&gt;btree_gist&lt;/code&gt; は距離演算子 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; を定義し、この演算子を使用した最近傍検索のGiSTインデックスサポートを提供します。距離演算子のために提供されている &lt;code&gt;int2&lt;/code&gt; 、 &lt;code&gt;int4&lt;/code&gt; 、 &lt;code&gt;int8&lt;/code&gt; 、 &lt;code&gt;float4&lt;/code&gt; 、 &lt;code&gt;float8&lt;/code&gt; 型、 &lt;code&gt;timestamp with time zone&lt;/code&gt; 、 &lt;code&gt;timestamp without time zone&lt;/code&gt; 、 &lt;code&gt;time without time zone&lt;/code&gt; 、 &lt;code&gt;date&lt;/code&gt; 、 &lt;code&gt;interval&lt;/code&gt; 、 &lt;code&gt;oid&lt;/code&gt; 、および &lt;code&gt;money&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0cd04ab9ab1bc3d1ec06d42e614cb3d497974a" translate="yes" xml:space="preserve">
          <source>Also, if you are using prepared transactions, the &lt;code&gt;virtualtransaction&lt;/code&gt; column can be joined to the &lt;code&gt;transaction&lt;/code&gt; column of the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; view to get more information on prepared transactions that hold locks. (A prepared transaction can never be waiting for a lock, but it continues to hold the locks it acquired while running.) For example:</source>
          <target state="translated">また、準備済みトランザクションを使用している場合は、 &lt;code&gt;virtualtransaction&lt;/code&gt; 列を&lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt;ビューの &lt;code&gt;transaction&lt;/code&gt; 列に結合して、ロックを保持する準備済みトランザクションの詳細を取得できます。（準備されたトランザクションはロックを待機することはできませんが、実行中に取得したロックを保持し続けます。）例：</target>
        </trans-unit>
        <trans-unit id="2258b90b04fd050fcb19ba25fa34dc828faad6f7" translate="yes" xml:space="preserve">
          <source>Also, lexemes in a &lt;code&gt;tsquery&lt;/code&gt; can be labeled with &lt;code&gt;*&lt;/code&gt; to specify prefix matching:</source>
          <target state="translated">また、 &lt;code&gt;tsquery&lt;/code&gt; 内の語彙素は &lt;code&gt;*&lt;/code&gt; でラベル付けして、プレフィックスの一致を指定できます。</target>
        </trans-unit>
        <trans-unit id="d1e5125c3a43842c6c788a2be18af72f0169e16b" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;myschema&lt;/code&gt; is the first element in the path, new objects would by default be created in it.</source>
          <target state="translated">また、 &lt;code&gt;myschema&lt;/code&gt; はパスの最初の要素であるため、新しいオブジェクトはデフォルトでその中に作成されます。</target>
        </trans-unit>
        <trans-unit id="706af9f63feb30c802747e00ad8bdfe7aa3a186c" translate="yes" xml:space="preserve">
          <source>Also, some element types have a notion of &amp;ldquo;infinity&amp;rdquo;, but that is just another value so far as the range type mechanisms are concerned. For example, in timestamp ranges, &lt;code&gt;[today,]&lt;/code&gt; means the same thing as &lt;code&gt;[today,)&lt;/code&gt;. But &lt;code&gt;[today,infinity]&lt;/code&gt; means something different from &lt;code&gt;[today,infinity)&lt;/code&gt; &amp;mdash; the latter excludes the special &lt;code&gt;timestamp&lt;/code&gt; value &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">また、一部の要素タイプには「無限」という概念がありますが、範囲タイプのメカニズムに関する限り、これは単なる別の値です。たとえば、タイムスタンプ範囲では、 &lt;code&gt;[today,]&lt;/code&gt; は &lt;code&gt;[today,)&lt;/code&gt; と同じことを意味します。ただし、 &lt;code&gt;[today,infinity]&lt;/code&gt; は &lt;code&gt;[today,infinity)&lt;/code&gt; とは異なる意味を持ち &lt;code&gt;infinity&lt;/code&gt; 。後者は特別な &lt;code&gt;timestamp&lt;/code&gt; 値infinityを除外しています。</target>
        </trans-unit>
        <trans-unit id="00fb5de01709ab2f402939d3439d7bfb11e30b51" translate="yes" xml:space="preserve">
          <source>Also, system catalogs may contain rows with &lt;code&gt;xmin&lt;/code&gt; equal to &lt;code&gt;BootstrapTransactionId&lt;/code&gt; (1), indicating that they were inserted during the first phase of initdb. Like &lt;code&gt;FrozenTransactionId&lt;/code&gt;, this special XID is treated as older than every normal XID.</source>
          <target state="translated">また、システムカタログには、 &lt;code&gt;xmin&lt;/code&gt; が &lt;code&gt;BootstrapTransactionId&lt;/code&gt; （1）と等しい行が含まれている場合があります。これは、それらがinitdbの最初のフェーズで挿入されたことを示します。 &lt;code&gt;FrozenTransactionId&lt;/code&gt; と同様に、この特別なXIDはすべての通常のXIDよりも古いものとして扱われます。</target>
        </trans-unit>
        <trans-unit id="93ed94df22ab24f81f04b111c95a216ff81d38c0" translate="yes" xml:space="preserve">
          <source>Also, the Unicode escape syntax for string constants only works when the configuration parameter &lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt; is turned on. This is because otherwise this syntax could confuse clients that parse the SQL statements to the point that it could lead to SQL injections and similar security issues. If the parameter is set to off, this syntax will be rejected with an error message.</source>
          <target state="translated">また、文字列定数のUnicodeエスケープ構文は、構成パラメーター&lt;a href=&quot;runtime-config-compatible#GUC-STANDARD-CONFORMING-STRINGS&quot;&gt;standard_conforming_strings&lt;/a&gt;がオンになっている場合にのみ機能します。これは、この構文を使用しないと、SQL文を解析するクライアントがSQLインジェクションや同様のセキュリティ問題を引き起こす可能性があるまで、クライアントを混乱させる可能性があるためです。パラメータがオフに設定されている場合、この構文はエラーメッセージで拒否されます。</target>
        </trans-unit>
        <trans-unit id="58147b7f84be2ece7907815ce52ec7ae85d6c7bf" translate="yes" xml:space="preserve">
          <source>Also, there is no concept of a &lt;code&gt;public&lt;/code&gt; schema in the SQL standard. For maximum conformance to the standard, you should not use the &lt;code&gt;public&lt;/code&gt; schema.</source>
          <target state="translated">また、SQL標準には &lt;code&gt;public&lt;/code&gt; スキーマの概念はありません。標準に最大限準拠するには、 &lt;code&gt;public&lt;/code&gt; スキーマを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="e584a70e0fd9b688e02349b1f5470dd3aa568b45" translate="yes" xml:space="preserve">
          <source>Also, these output format options can be set for just one query by using &lt;code&gt;\g&lt;/code&gt;:</source>
          <target state="translated">また、これらの出力形式オプションは、 &lt;code&gt;\g&lt;/code&gt; ：を使用して1つのクエリに対してのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="cae58275d441413bb378869b203fcfca0525ccf0" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can be only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">また、並列プラン内で使用した場合に部分的な子しか持つことができない通常の &lt;code&gt;Append&lt;/code&gt; ノードとは異なり、 &lt;code&gt;Parallel Append&lt;/code&gt; ノードは、部分的な子プランと非部分的な子プランの両方を持つことができます。部分的でない子は、複数回スキャンすると結果が重複するため、単一のプロセスのみでスキャンされます。したがって、複数の結果セットの追加を伴うプランでは、効率的な部分プランが利用できない場合でも、大まかな並列処理を実現できます。たとえば、並列スキャンをサポートしないインデックスを使用することによってのみ効率的に実装できるパーティションテーブルに対するクエリを考えてみます。計画担当者は、通常の &lt;code&gt;Index Scan&lt;/code&gt; &lt;code&gt;Parallel Append&lt;/code&gt; を選択する場合があります。予定; 個々のインデックススキャンはそれぞれ、単一のプロセスで完了するまで実行する必要がありますが、異なるプロセスで異なるスキャンを同時に実行することもできます。</target>
        </trans-unit>
        <trans-unit id="b84c371dd525a0259c19e76190985b0466e52c07" translate="yes" xml:space="preserve">
          <source>Also, unlike a regular &lt;code&gt;Append&lt;/code&gt; node, which can only have partial children when used within a parallel plan, a &lt;code&gt;Parallel Append&lt;/code&gt; node can have both partial and non-partial child plans. Non-partial children will be scanned by only a single process, since scanning them more than once would produce duplicate results. Plans that involve appending multiple results sets can therefore achieve coarse-grained parallelism even when efficient partial plans are not available. For example, consider a query against a partitioned table which can only be implemented efficiently by using an index that does not support parallel scans. The planner might choose a &lt;code&gt;Parallel Append&lt;/code&gt; of regular &lt;code&gt;Index Scan&lt;/code&gt; plans; each individual index scan would have to be executed to completion by a single process, but different scans could be performed at the same time by different processes.</source>
          <target state="translated">また、並列プラン内で使用された場合に部分的な子のみを持つことができる通常の &lt;code&gt;Append&lt;/code&gt; ノードとは異なり、 &lt;code&gt;Parallel Append&lt;/code&gt; ノードは部分的な子プランと部分的でない子プランの両方を持つことができます。部分的でない子は、複数回スキャンすると重複した結果が生成されるため、単一のプロセスでのみスキャンされます。したがって、複数の結果セットを追加することを含む計画は、効率的な部分計画が利用できない場合でも、大まかな並列処理を実現できます。たとえば、並列スキャンをサポートしないインデックスを使用することによってのみ効率的に実装できるパーティションテーブルに対するクエリについて考えてみます。計画担当者は、通常の &lt;code&gt;Index Scan&lt;/code&gt; &lt;code&gt;Parallel Append&lt;/code&gt; を選択する場合があります予定; 個々のインデックススキャンは、単一のプロセスで完了するまで実行する必要がありますが、異なるスキャンを異なるプロセスで同時に実行することもできます。</target>
        </trans-unit>
        <trans-unit id="e805152c6a1ae1d9757b9c8152236b48ab4b4867" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt;.</source>
          <target state="translated">また、終了したばかりのトランザクションをできるだけ早くアーカイブしたい場合は、 &lt;code&gt;pg_switch_wal&lt;/code&gt; を使用して手動でセグメント切り替えを強制できます。WAL管理に関連するその他のユーティリティ関数を&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="68eb2f93808c112d45a946f93f2d0964eca95823" translate="yes" xml:space="preserve">
          <source>Also, you can force a segment switch manually with &lt;code&gt;pg_switch_wal&lt;/code&gt; if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt;.</source>
          <target state="translated">また、完了したばかりのトランザクションができるだけ早くアーカイブされるようにしたい場合は、 &lt;code&gt;pg_switch_wal&lt;/code&gt; を使用して手動でセグメントスイッチを強制することができます。WAL管理に関連するその他のユーティリティ機能を&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.85に示し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bfbace446db7c85291e8910dc869f82f6687c559" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified labels separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those labels, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start to match any label that doesn't match any of the alternatives.</source>
          <target state="translated">また、 &lt;code&gt;|&lt;/code&gt; で区切られた、変更される可能性のある複数のラベルを書き込むことができます。（または）これらのラベルのいずれかに一致させると、 &lt;code&gt;!&lt;/code&gt; （NOT）最初は、どの代替案とも一致しないラベルに一致します。</target>
        </trans-unit>
        <trans-unit id="71f210fdceeda15fb7f9067d7b92e4afb40e583b" translate="yes" xml:space="preserve">
          <source>Also, you can write several possibly-modified non-star items separated with &lt;code&gt;|&lt;/code&gt; (OR) to match any of those items, and you can put &lt;code&gt;!&lt;/code&gt; (NOT) at the start of a non-star group to match any label that doesn't match any of the alternatives. A quantifier, if any, goes at the end of the group; it means some number of matches for the group as a whole (that is, some number of labels matching or not matching any of the alternatives).</source>
          <target state="translated">また、 &lt;code&gt;|&lt;/code&gt; で区切って、変更される可能性のあるいくつかのスター以外のアイテムを書き込むことができます。（または）それらのアイテムのいずれかに一致するように、そしてあなたは置くことができます &lt;code&gt;!&lt;/code&gt; （NOT）スター以外のグループの開始時に、どの選択肢にも一致しないラベルに一致します。数量詞がある場合は、グループの最後に配置されます。これは、グループ全体の一致の数を意味します（つまり、選択肢のいずれかと一致する、または一致しないラベルの数）。</target>
        </trans-unit>
        <trans-unit id="8b36099e7952ab489f13b56454238da5e639dbc6" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, add connection options:</source>
          <target state="translated">サーバー &lt;code&gt;foo&lt;/code&gt; を変更し、接続オプションを追加します。</target>
        </trans-unit>
        <trans-unit id="a729ebcf94a23a3c93f6e08f02b494c47b57ffb8" translate="yes" xml:space="preserve">
          <source>Alter server &lt;code&gt;foo&lt;/code&gt;, change version, change &lt;code&gt;host&lt;/code&gt; option:</source>
          <target state="translated">サーバー &lt;code&gt;foo&lt;/code&gt; の変更、バージョンの変更、 &lt;code&gt;host&lt;/code&gt; オプションの変更：</target>
        </trans-unit>
        <trans-unit id="530e5f9a6ec30da1a641c6dc46a96ff1039a1901" translate="yes" xml:space="preserve">
          <source>Alter the current session user instead of an explicitly identified role.</source>
          <target state="translated">明示的に指定されたロールの代わりに、現在のセッションユーザを変更します。</target>
        </trans-unit>
        <trans-unit id="7d634d2fd0bd3ab5f5b0921201011f77ef8d5f96" translate="yes" xml:space="preserve">
          <source>Alter the current user instead of an explicitly identified role.</source>
          <target state="translated">明示的に指定されたロールの代わりに、現在のユーザを変更します。</target>
        </trans-unit>
        <trans-unit id="2e8aee10a5d127f616d1a417fe30c8e06fd3852f" translate="yes" xml:space="preserve">
          <source>Alternative Method for Log Shipping</source>
          <target state="translated">ログ出荷のための代替方法</target>
        </trans-unit>
        <trans-unit id="8cd965c3bba9ba8b09a134d95e9a1fe544bc4537" translate="yes" xml:space="preserve">
          <source>Alternative location for the command history file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">コマンド履歴ファイルの代替の場所。チルダ（ &lt;code&gt;~&lt;/code&gt; ）展開が実行されます。</target>
        </trans-unit>
        <trans-unit id="0c3a5aa0af507c3b23d9de2d04bd2190286c2e39" translate="yes" xml:space="preserve">
          <source>Alternative location of the user's &lt;code&gt;.psqlrc&lt;/code&gt; file. Tilde (&lt;code&gt;~&lt;/code&gt;) expansion is performed.</source>
          <target state="translated">ユーザーの &lt;code&gt;.psqlrc&lt;/code&gt; ファイルの代替の場所。チルダ（ &lt;code&gt;~&lt;/code&gt; ）展開が実行されます。</target>
        </trans-unit>
        <trans-unit id="2541ab725e8ecd177759c1c8be6f800623e60558" translate="yes" xml:space="preserve">
          <source>Alternative spelling for &lt;code&gt;TEMPORARY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TEMPORARY&lt;/code&gt; の代替スペル。</target>
        </trans-unit>
        <trans-unit id="af1d73d4699e1562f8a1d0921440facf6a0e5f14" translate="yes" xml:space="preserve">
          <source>Alternative syntaxes for referencing ordered-set aggregates are described under &lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATE&lt;/a&gt;.</source>
          <target state="translated">順序セット集計を参照するための代替構文については、&lt;a href=&quot;sql-alteraggregate&quot;&gt;ALTER AGGREGATEで&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="23e53579bffe248a96cd7c7da0e62e9be194d4f8" translate="yes" xml:space="preserve">
          <source>Alternatively, C-style block comments can be used:</source>
          <target state="translated">あるいは、Cスタイルのブロックコメントを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7ff9d2f8aa56be6c9fb839910a0ca959de998790" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;time_zone_name&lt;/code&gt; can be given, referencing a zone name defined in the IANA timezone database. The zone's definition is consulted to see whether the abbreviation is or has been in use in that zone, and if so, the appropriate meaning is used &amp;mdash; that is, the meaning that was currently in use at the timestamp whose value is being determined, or the meaning in use immediately before that if it wasn't current at that time, or the oldest meaning if it was used only after that time. This behavior is essential for dealing with abbreviations whose meaning has historically varied. It is also allowed to define an abbreviation in terms of a zone name in which that abbreviation does not appear; then using the abbreviation is just equivalent to writing out the zone name.</source>
          <target state="translated">または、 &lt;code&gt;time_zone_name&lt;/code&gt; を指定して、IANAタイムゾーンデータベースで定義されたゾーン名を参照することもできます。ゾーンの定義が参照され、そのゾーンで略語が使用されているかどうかが確認されます。使用されている場合は、適切な意味が使用されます。つまり、値が決定されるタイムスタンプで現在使用されていた意味、またはその時点で最新ではなかった場合はその直前に使用されていた意味、それ以降に使用された場合は最も古い意味。この振る舞いは、歴史的に変化した意味を持つ略語を処理するために不可欠です。また、省略形が現れないゾーン名に関して省略形を定義することもできます。省略形を使用することは、ゾーン名を書き出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="15a06f8c724e47a1d8815847200662f59207ad21" translate="yes" xml:space="preserve">
          <source>Alternatively, a regular server session can be started with &lt;code&gt;-P&lt;/code&gt; included in its command line options. The method for doing this varies across clients, but in all libpq-based clients, it is possible to set the &lt;code&gt;PGOPTIONS&lt;/code&gt; environment variable to &lt;code&gt;-P&lt;/code&gt; before starting the client. Note that while this method does not require locking out other clients, it might still be wise to prevent other users from connecting to the damaged database until repairs have been completed.</source>
          <target state="translated">または、コマンドラインオプションに &lt;code&gt;-P&lt;/code&gt; を含めて通常のサーバーセッションを開始することもできます。これを行う方法はクライアントによって異なりますが、すべてのlibpqベースのクライアントでは、クライアントを起動する前に &lt;code&gt;PGOPTIONS&lt;/code&gt; 環境変数を &lt;code&gt;-P&lt;/code&gt; に設定することが可能です。この方法では他のクライアントをロックアウトする必要はありませんが、修復が完了するまで他のユーザーが破損したデータベースに接続できないようにするのが賢明な場合があります。</target>
        </trans-unit>
        <trans-unit id="d114129fd255b4feb38503a136823f1a3243ffae" translate="yes" xml:space="preserve">
          <source>Alternatively, an arbitrary expression can determine what rows are to be considered distinct:</source>
          <target state="translated">あるいは、任意の式で、どの行を別個のものとみなすかを決定することもできます。</target>
        </trans-unit>
        <trans-unit id="a31da7f4a4f7c70e9c7e0520f23700364a2f38f8" translate="yes" xml:space="preserve">
          <source>Alternatively, any of the following forms can be used for input:</source>
          <target state="translated">あるいは、以下のいずれかのフォームを入力に使用することもできます。</target>
        </trans-unit>
        <trans-unit id="33e9e4beffd0551e6388808105bbbc2dfb18bd73" translate="yes" xml:space="preserve">
          <source>Alternatively, bit-string constants can be specified in hexadecimal notation, using a leading &lt;code&gt;X&lt;/code&gt; (upper or lower case), e.g., &lt;code&gt;X'1FF'&lt;/code&gt;. This notation is equivalent to a bit-string constant with four binary digits for each hexadecimal digit.</source>
          <target state="translated">または、ビット文字列定数は、先頭に &lt;code&gt;X&lt;/code&gt; （大文字または小文字）を使用して16進表記で指定できます（例： &lt;code&gt;X'1FF'&lt;/code&gt; 。この表記は、各16進数字に4つの2進数字を持つビット文字列定数と同等です。</target>
        </trans-unit>
        <trans-unit id="251d43a6c1d9b6a2f5aefc3ac8e6be39b17e09eb" translate="yes" xml:space="preserve">
          <source>Alternatively, if only one character is given on a line, instances of that character are deleted; this is useful in languages where accents are represented by separate characters.</source>
          <target state="translated">あるいは、行に 1 文字だけが与えられた場合は、その文字のインスタンスが削除されます;これは、アクセントが別々の文字で表される言語で有用です。</target>
        </trans-unit>
        <trans-unit id="d591ed10c7ebb943dc2bac83e217250069a02625" translate="yes" xml:space="preserve">
          <source>Alternatively, if the operator class does not provide a &lt;code&gt;compare&lt;/code&gt; method, GIN will look up the default btree operator class for the index key data type, and use its comparison function. It is recommended to specify the comparison function in a GIN operator class that is meant for just one data type, as looking up the btree operator class costs a few cycles. However, polymorphic GIN operator classes (such as &lt;code&gt;array_ops&lt;/code&gt;) typically cannot specify a single comparison function.</source>
          <target state="translated">あるいは、演算子クラスが &lt;code&gt;compare&lt;/code&gt; メソッドを提供しない場合、GINはインデックスキーデータ型のデフォルトのbtree演算子クラスを検索し、その比較関数を使用します。 btree演算子クラスの検索には数サイクルかかるため、比較関数は1つのデータ型のみを対象とするGIN演算子クラスで指定することをお勧めします。ただし、通常、ポリモーフィックGIN演算子クラス（ &lt;code&gt;array_ops&lt;/code&gt; など）では、単一の比較関数を指定できません。</target>
        </trans-unit>
        <trans-unit id="72ceaece99de5916dec6956aa5625927bc2fa200" translate="yes" xml:space="preserve">
          <source>Alternatively, if the user account was created incorrectly or cannot be changed, it is recommended to set</source>
          <target state="translated">あるいは、ユーザーアカウントが間違って作成されたか、変更できない場合は</target>
        </trans-unit>
        <trans-unit id="60d8933bc73d549d63a859713e0214c4534a9558" translate="yes" xml:space="preserve">
          <source>Alternatively, one may want to create and populate the new child table before adding it to the table hierarchy. This could allow data to be loaded, checked, and transformed before being made visible to queries on the parent table.</source>
          <target state="translated">あるいは、テーブル階層に追加する前に、新しい子テーブルを作成して入力することもできます。これにより、親テーブルのクエリに表示される前にデータをロード、チェック、変換することができます。</target>
        </trans-unit>
        <trans-unit id="3ff1004e1f07326010cba19c9e266164c058052f" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; command can be used to reassign ownership of all objects owned by the role-to-be-dropped to a single other role. Because &lt;code&gt;REASSIGN OWNED&lt;/code&gt; cannot access objects in other databases, it is necessary to run it in each database that contains objects owned by the role. (Note that the first such &lt;code&gt;REASSIGN OWNED&lt;/code&gt; will change the ownership of any shared-across-databases objects, that is databases or tablespaces, that are owned by the role-to-be-dropped.)</source>
          <target state="translated">あるいは、&lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt;コマンドを使用して、ドロップされる役割が所有するすべてのオブジェクトの所有権を他の1つの役割に再割り当てすることができます。 &lt;code&gt;REASSIGN OWNED&lt;/code&gt; は他のデータベースのオブジェクトにアクセスできないため、ロールが所有するオブジェクトを含む各データベースでそれを実行する必要があります。（最初のそのような &lt;code&gt;REASSIGN OWNED&lt;/code&gt; は、ドロップされる役割が所有するデータベース間共有オブジェクト、つまりデータベースまたはテーブルスペースの所有権を変更することに注意してください。）</target>
        </trans-unit>
        <trans-unit id="0e1e66b725216c8606cc4bf9032cf0c74ece07f1" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;generate_subscripts&lt;/code&gt; function can be used. For example:</source>
          <target state="translated">あるいは、 &lt;code&gt;generate_subscripts&lt;/code&gt; 関数を使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="15fba016cd90434c268101e2e3dcfba0bf0a2532" translate="yes" xml:space="preserve">
          <source>Alternatively, use the &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; parameter:</source>
          <target state="translated">または、&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;パラメータを使用します。</target>
        </trans-unit>
        <trans-unit id="0f4a86811d0aa22382b5cf9bd26c67192af09d76" translate="yes" xml:space="preserve">
          <source>Alternatively, use the short commands:</source>
          <target state="translated">または、短いコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="65a8f599c00acf998716acc089534f17921d2aa4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can run &lt;code&gt;initdb&lt;/code&gt; via the &lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt; program like so:</source>
          <target state="translated">あるいは、次のように&lt;a href=&quot;app-pg-ctl&quot;&gt;pg_ctl&lt;/a&gt;プログラムを介して &lt;code&gt;initdb&lt;/code&gt; を実行できます。</target>
        </trans-unit>
        <trans-unit id="98a5c461c82a79025a521674df6f9b47d5588e09" translate="yes" xml:space="preserve">
          <source>Alternatively, you could modify &lt;code&gt;passwordcheck&lt;/code&gt; to reject pre-encrypted passwords, but forcing users to set their passwords in clear text carries its own security risks.</source>
          <target state="translated">または、事前に暗号化された &lt;code&gt;passwordcheck&lt;/code&gt; を拒否するようにpasswordcheckを変更できますが、ユーザーにパスワードをクリアテキストで設定するように強制すると、独自のセキュリティリスクが生じます。</target>
        </trans-unit>
        <trans-unit id="5a5bc9685c86de23aa2f7e6abe79e2df58ea2f24" translate="yes" xml:space="preserve">
          <source>Alternatively, you might prefer to use an external log rotation program if you have one that you are already using with other server software. For example, the rotatelogs tool included in the Apache distribution can be used with PostgreSQL. One way to do this is to pipe the server's stderr output to the desired program. If you start the server with &lt;code&gt;pg_ctl&lt;/code&gt;, then stderr is already redirected to stdout, so you just need a pipe command, for example:</source>
          <target state="translated">または、他のサーバーソフトウェアで既に使用しているプログラムがある場合は、外部ログローテーションプログラムを使用することもできます。たとえば、Apacheディストリビューションに含まれているrotatelogsツールは、PostgreSQLで使用できます。これを行う1つの方法は、サーバーのstderr出力を目的のプログラムにパイプすることです。 &lt;code&gt;pg_ctl&lt;/code&gt; を使用してサーバーを起動した場合、stderrはすでにstdoutにリダイレクトされているため、次のようにパイプコマンドが必要です。</target>
        </trans-unit>
        <trans-unit id="a4473ced05716c4f54d00426c2fe62cbfc81eb98" translate="yes" xml:space="preserve">
          <source>Alternatively, you'll get this when attempting Unix-domain socket communication to a local server:</source>
          <target state="translated">あるいは、ローカルサーバにUnixドメインのソケット通信を試みると、このようなメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="3070b53c6b7161861f801a0276cbe1623e985387" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; attempts to verify that existing stored data satisfies the new constraint, this check is not bulletproof, because the command cannot &amp;ldquo;see&amp;rdquo; table rows that are newly inserted or updated and not yet committed. If there is a hazard that concurrent operations might insert bad data, the way to proceed is to add the constraint using the &lt;code&gt;NOT VALID&lt;/code&gt; option, commit that command, wait until all transactions started before that commit have finished, and then issue &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; to search for data violating the constraint. This method is reliable because once the constraint is committed, all new transactions are guaranteed to enforce it against new values of the domain type.</source>
          <target state="translated">が &lt;code&gt;ALTER DOMAIN ADD CONSTRAINT&lt;/code&gt; 格納されたデータを満足する新しい制約を既存のことを確認するための試みのコマンドは、新たに挿入または更新し、まだコミットされていないテーブルの行を「見る」ことができないので、このチェックは、防弾ではありません。並行操作によって不良データが挿入される危険がある場合、続行する方法は、 &lt;code&gt;NOT VALID&lt;/code&gt; オプションを使用して制約を追加し、そのコマンドをコミットし、そのコミットが完了する前にすべてのトランザクションが開始するまで待ってから、 &lt;code&gt;ALTER DOMAIN VALIDATE CONSTRAINT&lt;/code&gt; を発行することです。制約に違反するデータを検索します。制約がコミットされると、すべての新しいトランザクションがドメインタイプの新しい値に対して制約を強制することが保証されるため、この方法は信頼できます。</target>
        </trans-unit>
        <trans-unit id="6e4d5c62b36bd1bff5096ffffc66d8713544d380" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;COALESCE&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt;, and &lt;code&gt;LEAST&lt;/code&gt; are syntactically similar to functions, they are not ordinary functions, and thus cannot be used with explicit &lt;code&gt;VARIADIC&lt;/code&gt; array arguments.</source>
          <target state="translated">が &lt;code&gt;COALESCE&lt;/code&gt; は、 &lt;code&gt;GREATEST&lt;/code&gt; 、および &lt;code&gt;LEAST&lt;/code&gt; 構文的機能に類似している、彼らは普通の関数ではないので、明示的に使用することはできません &lt;code&gt;VARIADIC&lt;/code&gt; 配列引数。</target>
        </trans-unit>
        <trans-unit id="757c32acfdc3edc5e4ae1b7ef733e95e7cd6d851" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;FOR UPDATE&lt;/code&gt; appears in the SQL standard, the standard allows it only as an option of &lt;code&gt;DECLARE CURSOR&lt;/code&gt;. PostgreSQL allows it in any &lt;code&gt;SELECT&lt;/code&gt; query as well as in sub-&lt;code&gt;SELECT&lt;/code&gt;s, but this is an extension. The &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;FOR SHARE&lt;/code&gt; and &lt;code&gt;FOR KEY SHARE&lt;/code&gt; variants, as well as the &lt;code&gt;NOWAIT&lt;/code&gt; and &lt;code&gt;SKIP LOCKED&lt;/code&gt; options, do not appear in the standard.</source>
          <target state="translated">が &lt;code&gt;FOR UPDATE&lt;/code&gt; が SQL標準で表示され、標準では唯一のオプションとして、それを可能にする &lt;code&gt;DECLARE CURSOR&lt;/code&gt; 。 PostgreSQLでは、すべての &lt;code&gt;SELECT&lt;/code&gt; クエリとサブ &lt;code&gt;SELECT&lt;/code&gt; でこれを使用できますが、これは拡張機能です。 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; は、 &lt;code&gt;FOR SHARE&lt;/code&gt; および &lt;code&gt;FOR KEY SHARE&lt;/code&gt; と同様に、変異体、 &lt;code&gt;NOWAIT&lt;/code&gt; および &lt;code&gt;SKIP LOCKED&lt;/code&gt; オプションを、標準では表示されません。</target>
        </trans-unit>
        <trans-unit id="53588eb1af9a260bf16537d83fb7f9095237ab92" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;initdb&lt;/code&gt; will attempt to create the specified data directory, it might not have permission if the parent directory of the desired data directory is root-owned. To initialize in such a setup, create an empty data directory as root, then use &lt;code&gt;chown&lt;/code&gt; to assign ownership of that directory to the database user account, then &lt;code&gt;su&lt;/code&gt; to become the database user to run &lt;code&gt;initdb&lt;/code&gt;.</source>
          <target state="translated">が、 &lt;code&gt;initdb&lt;/code&gt; を実行中に指定されたデータディレクトリを作成しようとする所望のデータディレクトリの親ディレクトリがroot所有のであれば、それは権限を持っていない可能性があります。このような設定で初期化するには、rootとして空のデータディレクトリを作成し、 &lt;code&gt;chown&lt;/code&gt; を使用してそのディレクトリの所有権をデータベースユーザーアカウントに割り当て、次に &lt;code&gt;su&lt;/code&gt; を使用して &lt;code&gt;initdb&lt;/code&gt; を実行するデータベースユーザーになります。</target>
        </trans-unit>
        <trans-unit id="2c9e9e73d67adcca66915f7f142192b4fd5640e0" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL does not attempt to enforce constraints on foreign tables, it does assume that they are correct for purposes of query optimization. If there are rows visible in the foreign table that do not satisfy a declared constraint, queries on the table might produce incorrect answers. It is the user's responsibility to ensure that the constraint definition matches reality.</source>
          <target state="translated">PostgreSQLは外部テーブルに制約を強制しようとはしませんが、問い合わせの最適化のために、制約が正しいことを前提としています。宣言された制約を満たさない行が外部テーブルに表示されている場合、そのテーブルに対する問い合わせは誤った答えを生成する可能性があります。制約の定義が現実と一致していることを確認するのはユーザの責任です。</target>
        </trans-unit>
        <trans-unit id="d1a0d48f05bfdc6cec6860f8c1c04ca18ef39017" translate="yes" xml:space="preserve">
          <source>Although PostgreSQL supports Julian Date notation for input and output of dates (and also uses Julian dates for some internal datetime calculations), it does not observe the nicety of having dates run from noon to noon. PostgreSQL treats a Julian Date as running from midnight to midnight.</source>
          <target state="translated">PostgreSQLは日付の入出力にジュリアン日付表記をサポートしていますが(内部の日付時刻計算にもジュリアン日付を使用しています)、正午から正午までの日付を実行することの良さを理解していません。PostgreSQLは、ユリウス語の日付を真夜中から真夜中までの間に実行されているものとして扱います。</target>
        </trans-unit>
        <trans-unit id="aa5958132d1510aabee9c8eff036ee687a13c3b5" translate="yes" xml:space="preserve">
          <source>Although all built-in WAL-logged modules have their own types of WAL records, there is also a generic WAL record type, which describes changes to pages in a generic way. This is useful for extensions that provide custom access methods, because they cannot register their own WAL redo routines.</source>
          <target state="translated">組み込みの WAL-logged モジュールはすべて独自のタイプの WAL レコードを持っていますが、ページへの変更を一般的な方法で記述するジェネリックな WAL レコードタイプもあります。これは、カスタムアクセスメソッドを提供する拡張機能では、独自のWALのやり直しルーチンを登録することができないので便利です。</target>
        </trans-unit>
        <trans-unit id="d6ab224f94330d8699a9bed333303bd23f1e0345" translate="yes" xml:space="preserve">
          <source>Although enum types are primarily intended for static sets of values, there is support for adding new values to an existing enum type, and for renaming values (see &lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPE&lt;/a&gt;). Existing values cannot be removed from an enum type, nor can the sort ordering of such values be changed, short of dropping and re-creating the enum type.</source>
          <target state="translated">列挙型は主に静的な値のセットを対象としていますが、既存の列挙型に新しい値を追加したり、値の名前を変更したりすることもできます（&lt;a href=&quot;sql-altertype&quot;&gt;ALTER TYPEを&lt;/a&gt;参照）。列挙型から既存の値を削除したり、列挙型を削除して再作成したりしない限り、そのような値の並べ替え順序を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="94ec3fef4f0a92e5c738b8e891b93184d80ce08d" translate="yes" xml:space="preserve">
          <source>Although indexes in PostgreSQL do not need maintenance or tuning, it is still important to check which indexes are actually used by the real-life query workload. Examining index usage for an individual query is done with the &lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt; command; its application for this purpose is illustrated in &lt;a href=&quot;using-explain&quot;&gt;Section 14.1&lt;/a&gt;. It is also possible to gather overall statistics about index usage in a running server, as described in &lt;a href=&quot;monitoring-stats&quot;&gt;Section 27.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLのインデックスにはメンテナンスや調整は必要ありませんが、実際のクエリワークロードで実際に使用されているインデックスを確認することが重要です。個々のクエリのインデックスの使用状況を調べるには、&lt;a href=&quot;sql-explain&quot;&gt;EXPLAIN&lt;/a&gt;コマンドを使用します。この目的への適用は&lt;a href=&quot;using-explain&quot;&gt;セクション14.1に&lt;/a&gt;示されています。&lt;a href=&quot;monitoring-stats&quot;&gt;セクション27.2で&lt;/a&gt;説明されているように、実行中のサーバーでのインデックスの使用に関する全体的な統計を収集することもできます。</target>
        </trans-unit>
        <trans-unit id="b565c24300a11b353aca42f1a3c2fd6f15be280e" translate="yes" xml:space="preserve">
          <source>Although inheritance is frequently useful, it has not been integrated with unique constraints or foreign keys, which limits its usefulness. See &lt;a href=&quot;ddl-inherit&quot;&gt;Section 5.10&lt;/a&gt; for more detail.</source>
          <target state="translated">継承はしばしば有用ですが、固有の制約や外部キーと統合されていないため、その有用性は制限されています。詳細については、&lt;a href=&quot;ddl-inherit&quot;&gt;セクション5.10&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d3850ba882b09b2bdad99e045dd0ac52d33bb527" translate="yes" xml:space="preserve">
          <source>Although it is possible to copy a database other than &lt;code&gt;template1&lt;/code&gt; by specifying its name as the template, this is not (yet) intended as a general-purpose &amp;ldquo;&lt;code&gt;COPY DATABASE&lt;/code&gt;&amp;rdquo; facility. The principal limitation is that no other sessions can be connected to the template database while it is being copied. &lt;code&gt;CREATE DATABASE&lt;/code&gt; will fail if any other connection exists when it starts; otherwise, new connections to the template database are locked out until &lt;code&gt;CREATE DATABASE&lt;/code&gt; completes. See &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;template1&lt;/code&gt; として名前を指定して、template1 以外のデータベースをコピーすることは可能ですが、これは（まだ）汎用の「 &lt;code&gt;COPY DATABASE&lt;/code&gt; 」機能としては意図されていません。主な制限は、コピー中は他のセッションをテンプレートデータベースに接続できないことです。開始時に他の接続が存在する場合、 &lt;code&gt;CREATE DATABASE&lt;/code&gt; は失敗します。それ以外の場合、テンプレートデータベースへの新しい接続は、 &lt;code&gt;CREATE DATABASE&lt;/code&gt; が完了するまでロックアウトされます。詳細は&lt;a href=&quot;manage-ag-templatedbs&quot;&gt;項22.3&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9f2cb95ff60fc4e9f012557faa268bb5d908ed75" translate="yes" xml:space="preserve">
          <source>Although most forms of &lt;code&gt;ADD table_constraint&lt;/code&gt; require an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock, &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; requires only a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock. Note that &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; also acquires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table on which the constraint is declared.</source>
          <target state="translated">ほとんどの形態が、 &lt;code&gt;ADD table_constraint&lt;/code&gt; 必要 &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; のロックを、 &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; のみ必要です &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; のロックを。 &lt;code&gt;ADD FOREIGN KEY&lt;/code&gt; は、制約が宣言されているテーブルのロックに加えて、参照されているテーブルの &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; ロックも取得することに注意してください。</target>
        </trans-unit>
        <trans-unit id="1f7a4620dd953ee89678c8af93ba6b1281ecf21b" translate="yes" xml:space="preserve">
          <source>Although per-column tweaking of &lt;code&gt;ANALYZE&lt;/code&gt; frequency might not be very productive, you might find it worthwhile to do per-column adjustment of the level of detail of the statistics collected by &lt;code&gt;ANALYZE&lt;/code&gt;. Columns that are heavily used in &lt;code&gt;WHERE&lt;/code&gt; clauses and have highly irregular data distributions might require a finer-grain data histogram than other columns. See &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt;, or change the database-wide default using the &lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt; configuration parameter.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; の頻度を列ごとに調整することはあまり生産的ではないかもしれませんが、 &lt;code&gt;ANALYZE&lt;/code&gt; によって収集された統計の詳細レベルを列ごとに調整することは価値があるかもしれません。 &lt;code&gt;WHERE&lt;/code&gt; 句で頻繁に使用され、データの分布が非常に不規則な列は、他の列よりも細かいデータヒストグラムが必要になる場合があります。 &lt;code&gt;ALTER TABLE SET STATISTICS&lt;/code&gt; を参照するか、&lt;a href=&quot;runtime-config-query#GUC-DEFAULT-STATISTICS-TARGET&quot;&gt;default_statistics_target&lt;/a&gt;構成パラメーターを使用してデータベース全体のデフォルトを変更してください。</target>
        </trans-unit>
        <trans-unit id="072197dff3ba1069a6848a4f3fc276518f8dd8e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;date&lt;/code&gt; type cannot have an associated time zone, the &lt;code&gt;time&lt;/code&gt; type can. Time zones in the real world have little meaning unless associated with a date as well as a time, since the offset can vary through the year with daylight-saving time boundaries.</source>
          <target state="translated">けれども &lt;code&gt;date&lt;/code&gt; タイプが関連付けられているタイムゾーンを持つことができない、 &lt;code&gt;time&lt;/code&gt; タイプができます。オフセットは1年を通して夏時間の境界で変化する可能性があるため、日付と時刻に関連付けられていない限り、現実世界のタイムゾーンはほとんど意味がありません。</target>
        </trans-unit>
        <trans-unit id="28fdae260b7b429ca2fc81de6c0ad8518d3a56e2" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;jsonb_path_ops&lt;/code&gt; operator class supports only queries with the &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;@@&lt;/code&gt; and &lt;code&gt;@?&lt;/code&gt; operators, it has notable performance advantages over the default operator class &lt;code&gt;jsonb_ops&lt;/code&gt;. A &lt;code&gt;jsonb_path_ops&lt;/code&gt; index is usually much smaller than a &lt;code&gt;jsonb_ops&lt;/code&gt; index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class.</source>
          <target state="translated">が &lt;code&gt;jsonb_path_ops&lt;/code&gt; の演算子クラスのサポートだけで照会 &lt;code&gt;@&amp;gt;&lt;/code&gt; 、 &lt;code&gt;@@&lt;/code&gt; および &lt;code&gt;@?&lt;/code&gt; 演算子を使用すると、デフォルトの演算子クラス &lt;code&gt;jsonb_ops&lt;/code&gt; よりもパフォーマンスが著しく向上します。 &lt;code&gt;jsonb_path_ops&lt;/code&gt; のインデックスは、通常よりもはるかに小さい &lt;code&gt;jsonb_ops&lt;/code&gt; の同じデータに対する索引、および検索の特異性は、クエリがデータに頻繁に表示されるキーを含む場合は特に、良いです。したがって、検索操作は通常、デフォルトの演算子クラスよりもパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="b3909c49c0f3069cf4fdb831ccd03572195110f1" translate="yes" xml:space="preserve">
          <source>Although the error conditions possible on the client side are quite varied and application-dependent, a few of them might be directly related to how the server was started. Conditions other than those shown below should be documented with the respective client application.</source>
          <target state="translated">クライアント側で考えられるエラー条件は非常に多様で、アプリケーションに依存しますが、そのうちのいくつかはサーバの起動方法に直接関係しているかもしれません。以下に示す条件以外は、それぞれのクライアントアプリケーションで文書化する必要があります。</target>
        </trans-unit>
        <trans-unit id="707d4aa12dd0762aad5c962d956cb0615faa21aa" translate="yes" xml:space="preserve">
          <source>Although the main point of a prepared statement is to avoid repeated parse analysis and planning of the statement, PostgreSQL will force re-analysis and re-planning of the statement before using it whenever database objects used in the statement have undergone definitional (DDL) changes since the previous use of the prepared statement. Also, if the value of &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; changes from one use to the next, the statement will be re-parsed using the new &lt;code&gt;search_path&lt;/code&gt;. (This latter behavior is new as of PostgreSQL 9.3.) These rules make use of a prepared statement semantically almost equivalent to re-submitting the same query text over and over, but with a performance benefit if no object definitions are changed, especially if the best plan remains the same across uses. An example of a case where the semantic equivalence is not perfect is that if the statement refers to a table by an unqualified name, and then a new table of the same name is created in a schema appearing earlier in the &lt;code&gt;search_path&lt;/code&gt;, no automatic re-parse will occur since no object used in the statement changed. However, if some other change forces a re-parse, the new table will be referenced in subsequent uses.</source>
          <target state="translated">準備済みステートメントの主なポイントは、ステートメントの解析と計画の繰り返しを避けることですが、PostgreSQLは、ステートメントで使用されるデータベースオブジェクトが定義（DDL）の変更を受けた場合は常に、ステートメントの再分析と再計画を強制してから使用します。準備されたステートメントの前回の使用以来。また、&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;の値が1つの用途から次の用途に変更された場合、ステートメントは新しい &lt;code&gt;search_path&lt;/code&gt; を使用して再解析されます。。 （この後者の動作はPostgreSQL 9.3で新しく追加されました。）これらのルールは、意味的にほぼ同じクエリテキストを再送信することとほぼ同等の準備済みステートメントを使用しますが、オブジェクト定義が変更されない場合、特に最良の計画は、どの用途でも同じです。セマンティックの同等性が完全でない場合の例は、ステートメントが修飾されていない名前でテーブルを参照し、同じ名前の新しいテーブルが &lt;code&gt;search_path&lt;/code&gt; の前にあるスキーマに作成された場合、自動再ステートメントで使用されているオブジェクトが変更されていないため、解析が発生します。ただし、他の変更によって強制的に再解析される場合、新しいテーブルは以降の使用で参照されます。</target>
        </trans-unit>
        <trans-unit id="7b64c47c816d918ee8eceb31b5a14f4992da7fb7" translate="yes" xml:space="preserve">
          <source>Although the syntax of &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; resembles that of the SQL standard, the effect is not the same. In the standard, temporary tables are defined just once and automatically exist (starting with empty contents) in every session that needs them. PostgreSQL instead requires each session to issue its own &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; command for each temporary table to be used. This allows different sessions to use the same temporary table name for different purposes, whereas the standard's approach constrains all instances of a given temporary table name to have the same table structure.</source>
          <target state="translated">&lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; の構文はSQL標準の構文に似ていますが、効果は同じではありません。標準では、一時テーブルは一度だけ定義され、それらを必要とするすべてのセッションで自動的に（空のコンテンツから開始して）存在します。 PostgreSQLでは、代わりに、使用する各一時テーブルに対して、各セッションで独自の &lt;code&gt;CREATE TEMPORARY TABLE&lt;/code&gt; コマンドを発行する必要があります。これにより、異なるセッションが異なる目的で同じ一時テーブル名を使用できるようになりますが、標準のアプローチでは、特定の一時テーブル名のすべてのインスタンスが同じテーブル構造を持つように制限されます。</target>
        </trans-unit>
        <trans-unit id="9eb832cbf2f7969f569f8af2de92f22dbf429240" translate="yes" xml:space="preserve">
          <source>Although the system will let you set &lt;code&gt;random_page_cost&lt;/code&gt; to less than &lt;code&gt;seq_page_cost&lt;/code&gt;, it is not physically sensible to do so. However, setting them equal makes sense if the database is entirely cached in RAM, since in that case there is no penalty for touching pages out of sequence. Also, in a heavily-cached database you should lower both values relative to the CPU parameters, since the cost of fetching a page already in RAM is much smaller than it would normally be.</source>
          <target state="translated">システムはあなたが設定できますが &lt;code&gt;random_page_cost&lt;/code&gt; を以下に &lt;code&gt;seq_page_cost&lt;/code&gt; 、物理的にそうすることが賢明ではありません。ただし、データベースが完全にRAMにキャッシュされている場合は、これらの値を等しく設定することは理にかなっています。その場合、ページを順番どおりに操作しないことによるペナルティがないためです。また、キャッシュが非常に多いデータベースでは、RAMに既にあるページをフェッチするコストが通常よりもはるかに小さいため、CPUパラメータに対して両方の値を低くする必要があります。</target>
        </trans-unit>
        <trans-unit id="f375eb3005a104e4e3133bc9460b959aca6d956c" translate="yes" xml:space="preserve">
          <source>Although these queries will work without an index, most applications will find this approach too slow, except perhaps for occasional ad-hoc searches. Practical use of text searching usually requires creating an index.</source>
          <target state="translated">これらのクエリはインデックスがなくても動作しますが、ほとんどのアプリケーションでは、たまにアドホックな検索を行う場合を除いて、この方法では時間がかかりすぎると感じるでしょう。テキスト検索を実用的に使用するには、通常インデックスを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="d6a53bc14c2fd9a760550de48fb80767bf99cae5" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a large penalty in index size. Each of the single-column btree indexes occupies 214 MB, so the total space needed is over 1.2GB, more than 8 times the space used by the bloom index.</source>
          <target state="translated">このクエリはシングルインデックスよりもはるかに高速に実行されますが、インデックスサイズに大きなペナルティが発生します。シングルカラムのbtreeインデックスはそれぞれ214 MBを占有するので、必要とされる総容量は1.2GB以上になり、bloomインデックスの8倍以上の容量になります。</target>
        </trans-unit>
        <trans-unit id="a490262673b6e67e6cc0b4de26fba601b493618f" translate="yes" xml:space="preserve">
          <source>Although this query runs much faster than with either of the single indexes, we pay a penalty in index size. Each of the single-column btree indexes occupies 2 MB, so the total space needed is 12 MB, eight times the space used by the bloom index.</source>
          <target state="translated">このクエリはシングルインデックスを使用した場合よりもはるかに高速に実行されますが、インデックスサイズにペナルティが発生します。シングルカラムのbtreeインデックスはそれぞれ2MBを占有するので、必要とされる総容量は12MBとなり、これはbloomインデックスの8倍になります。</target>
        </trans-unit>
        <trans-unit id="1200f8928e7bfeba98e8bc2cff21bdd8b6159a1f" translate="yes" xml:space="preserve">
          <source>Although this query's restrictions are superficially similar to the previous example, the semantics are different because a row must be emitted for each row of A that has no matching row in the join of B and C. Therefore the planner has no choice of join order here: it must join B to C and then join A to that result. Accordingly, this query takes less time to plan than the previous query. In other cases, the planner might be able to determine that more than one join order is safe. For example, given:</source>
          <target state="translated">この問い合わせの制約は、表面的には前の例と似ていますが、セマンティクスが異なります。それは、BとCの結合で一致する行がないAの各行について、行を放出しなければならないからです。したがって、この問い合わせは前の問い合わせよりも計画にかかる時間が短くなります。他のケースでは、プランナは2つ以上の結合順序が安全であると判断できるかもしれません。例えば、以下のような場合です。</target>
        </trans-unit>
        <trans-unit id="7ef8d68c90c214bb77efeec7b9a407cfbeffef4b" translate="yes" xml:space="preserve">
          <source>Although tuples are a lockable type of object, information about row-level locks is stored on disk, not in memory, and therefore row-level locks normally do not appear in this view. If a process is waiting for a row-level lock, it will usually appear in the view as waiting for the permanent transaction ID of the current holder of that row lock.</source>
          <target state="translated">タプルはロック可能なタイプのオブジェクトですが、行レベルのロックに関する情報はメモリではなくディスクに格納されているため、行レベルのロックは通常このビューには表示されません。プロセスが行レベル・ロックを待っている場合、通常、その行ロックの現在の保持者の永続的なトランザクションIDを待っているとしてビューに表示されます。</target>
        </trans-unit>
        <trans-unit id="72059384cd793d17d014692386f1a5b268fab6d4" translate="yes" xml:space="preserve">
          <source>Although you can use any output format with this feature, the default &lt;code&gt;aligned&lt;/code&gt; format tends to look bad because each group of &lt;code&gt;FETCH_COUNT&lt;/code&gt; rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better.</source>
          <target state="translated">この機能では任意の出力フォーマットを使用できますが、 &lt;code&gt;FETCH_COUNT&lt;/code&gt; 行の各グループが個別にフォーマットされ、行グループ全体で列幅が変化するため、デフォルトの &lt;code&gt;aligned&lt;/code&gt; 形式は見栄えが悪くなる傾向があります。他の出力フォーマットはよりよく機能します。</target>
        </trans-unit>
        <trans-unit id="29489a7d34435843e1ff1804b48da3fef28fc6ed" translate="yes" xml:space="preserve">
          <source>Although you cannot update a sequence directly, you can use a query like:</source>
          <target state="translated">シーケンスを直接更新することはできませんが、次のようなクエリを使用することができます。</target>
        </trans-unit>
        <trans-unit id="d408d29d181fe5f178e0df0934db0a473f3e4b2d" translate="yes" xml:space="preserve">
          <source>Always -1 in storage, but when loaded into a row descriptor in memory this might be updated to cache the offset of the attribute within the row</source>
          <target state="translated">ストレージ内では常に-1ですが、メモリ内の行ディスクリプタにロードされると、行内の属性のオフセットをキャッシュするために更新されることがあります。</target>
        </trans-unit>
        <trans-unit id="6dadde15ce0973a00fe9eb264f6b51766c085e93" translate="yes" xml:space="preserve">
          <source>Always run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; first. This command collects statistics about the distribution of the values in the table. This information is required to estimate the number of rows returned by a query, which is needed by the planner to assign realistic costs to each possible query plan. In absence of any real statistics, some default values are assumed, which are almost certain to be inaccurate. Examining an application's index usage without having run &lt;code&gt;ANALYZE&lt;/code&gt; is therefore a lost cause. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">常に最初に&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZEを&lt;/a&gt;実行します。このコマンドは、テーブル内の値の分布に関する統計を収集します。この情報は、クエリによって返される行数を推定するために必要です。これは、プランナが各クエリプランに現実的なコストを割り当てるために必要です。実際の統計がない場合、いくつかのデフォルト値が想定されますが、これは不正確であることがほぼ確実です。したがって、 &lt;code&gt;ANALYZE&lt;/code&gt; を実行せずにアプリケーションのインデックスの使用状況を調べることは、失われた原因です。詳細は、&lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;セクション24.1.3&lt;/a&gt;および&lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;セクション24.1.6&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fee90b9468a8f0a4929baba6bf4b3942f402f50f" translate="yes" xml:space="preserve">
          <source>Always run the pg_upgrade binary of the new server, not the old one. pg_upgrade requires the specification of the old and new cluster's data and executable (&lt;code&gt;bin&lt;/code&gt;) directories. You can also specify user and port values, and whether you want the data files linked or cloned instead of the default copy behavior.</source>
          <target state="translated">古いサーバーではなく、常に新しいサーバーのpg_upgradeバイナリを実行します。 pg_upgradeには、新旧のクラスターのデータと実行可能（ &lt;code&gt;bin&lt;/code&gt; ）ディレクトリーの指定が必要です。ユーザーとポートの値、およびデフォルトのコピー動作の代わりにデータファイルをリンクするかクローンするかを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="ed314eaaeb4f7d7933efa77539bb6dd24179fb4e" translate="yes" xml:space="preserve">
          <source>American National Standards Institute</source>
          <target state="translated">べいこくきかくきょうかい</target>
        </trans-unit>
        <trans-unit id="9b0f6aa450d937f102baa99a591a10b175502ace" translate="yes" xml:space="preserve">
          <source>American Standard Code for Information Interchange</source>
          <target state="translated">情報交換のためのアメリカの標準コード</target>
        </trans-unit>
        <trans-unit id="f772502aac0c6acdc4a93caa9a6a863fee25bd39" translate="yes" xml:space="preserve">
          <source>Among all relational operators the most difficult one to process and optimize is the &lt;em&gt;join&lt;/em&gt;. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of &lt;em&gt;join methods&lt;/em&gt; (e.g., nested loop, hash join, merge join in PostgreSQL) to process individual joins and a diversity of &lt;em&gt;indexes&lt;/em&gt; (e.g., B-tree, hash, GiST and GIN in PostgreSQL) as access paths for relations.</source>
          <target state="translated">すべての関係演算子の中で、処理と最適化が最も難しいのは&lt;em&gt;結合&lt;/em&gt;です。可能なクエリプランの数は、クエリ内の結合の数とともに指数関数的に増加します。個々の結合とさまざまな&lt;em&gt;インデックス&lt;/em&gt;（Bツリー、ハッシュ、GiST、GINなど）を処理&lt;em&gt;する&lt;/em&gt;ためのさまざまな&lt;em&gt;結合方法&lt;/em&gt;（たとえば、PostgreSQLのネストループ、ハッシュ結合、マージ結合）のサポートにより、さらに最適化が行われ&lt;em&gt;ます&lt;/em&gt;。 PostgreSQL）リレーションのアクセスパスとして。</target>
        </trans-unit>
        <trans-unit id="a06f60f435b117a486b4b9306faa4f936e74dfd4" translate="yes" xml:space="preserve">
          <source>Amount of data streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt; or &lt;code&gt;transferring wal files&lt;/code&gt;.</source>
          <target state="translated">ストリーミングされたデータの量。このカウンターは、フェーズが &lt;code&gt;streaming database files&lt;/code&gt; または &lt;code&gt;transferring wal files&lt;/code&gt; 場合にのみ進みます。</target>
        </trans-unit>
        <trans-unit id="cb98c34253bd6741e222de32790839f4b0bbf938" translate="yes" xml:space="preserve">
          <source>An &amp;ldquo;ordering&amp;rdquo; operator entry indicates that an index of this operator family can be scanned to return rows in the order represented by &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Such an operator could return any sortable data type, though again its left-hand input type must match the index's column data type. The exact semantics of the &lt;code&gt;ORDER BY&lt;/code&gt; are specified by the &lt;code&gt;amopsortfamily&lt;/code&gt; column, which must reference a B-tree operator family for the operator's result type.</source>
          <target state="translated">「順序付け」演算子のエントリは、この演算子ファミリのインデックスをスキャンして、 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 表される順序で行を返すことができることを示しています。このような演算子は、ソート可能なデータ型を返す可能性がありますが、左側の入力型はインデックスの列のデータ型と一致する必要があります。 &lt;code&gt;ORDER BY&lt;/code&gt; の正確なセマンティクスは &lt;code&gt;amopsortfamily&lt;/code&gt; 列で指定されます。これは、演算子の結果タイプのBツリー演算子ファミリを参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="6d377056771f89a3a21b9faebc41fe3335e17744" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attribute&lt;/a&gt; found in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;または&lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;ビューで&lt;/a&gt;見つかった&lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef1279b86476578e5585aff75989181f73dcffd4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=&lt;/code&gt; operator must be an equivalence relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; of the data type:</source>
          <target state="translated">AN &lt;code&gt;=&lt;/code&gt; 演算子は同値関係でなければなりません。つまり、データ型のすべての非null値 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="c4237e342da22e5fcef0feed597ee14805fa3aa4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;equalimage&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;equalimage&lt;/code&gt; の機能は、署名を持っている必要があります</target>
        </trans-unit>
        <trans-unit id="009a293231558c68203740163c433bc30d08defc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;in_range&lt;/code&gt; function must have the signature</source>
          <target state="translated">&lt;code&gt;in_range&lt;/code&gt; 機能は、署名を持っている必要があります</target>
        </trans-unit>
        <trans-unit id="89039523af081d32fe0dcce5afd61336bd5c01d2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;options&lt;/code&gt; support function must have the signature</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; サポート機能は、署名を持っている必要があります</target>
        </trans-unit>
        <trans-unit id="857fc13a44d4059f0989bb54c261a11965498b57" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;unaccent&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;unaccent&lt;/code&gt; 辞書は以下のオプションを受け付けます。</target>
        </trans-unit>
        <trans-unit id="044945d1a76181f7c4bcb8b32669d47c02d34474" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;aggregate expression&lt;/em&gt; represents the application of an aggregate function across the rows selected by a query. An aggregate function reduces multiple inputs to a single output value, such as the sum or average of the inputs. The syntax of an aggregate expression is one of the following:</source>
          <target state="translated">&lt;em&gt;集約式は、&lt;/em&gt;問い合わせによって選択された行を横切って集約関数の適用を表します。集約関数は、複数の入力を、入力の合計や平均などの単一の出力値に削減します。集計式の構文は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="9cf57ce9f4c43bfd5a2501334071928e81cfc082" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;演算子クラスは、&lt;/em&gt;インデックスの各列に指定することができます。演算子クラスは、その列のインデックスで使用される演算子を識別します。たとえば、4バイト整数のBツリーインデックスは &lt;code&gt;int4_ops&lt;/code&gt; クラスを使用します。この演算子クラスには、4バイト整数の比較関数が含まれています。実際には、列のデータ型のデフォルトの演算子クラスで通常は十分です。演算子クラスを持つことの主なポイントは、一部のデータ型では、意味のある順序が複数存在する可能性があることです。たとえば、絶対値または実部のいずれかで複素数データ型を並べ替えることができます。これを行うには、データ型に2つの演算子クラスを定義し、インデックスを作成するときに適切なクラスを選択します。演算子クラスの詳細については、&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;セクション37.16&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1cd3ddc4485e8a07b58b1b313130fa7a0d1e8729" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;operator class&lt;/em&gt; with optional parameters can be specified for each column of an index. The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on four-byte integers would use the &lt;code&gt;int4_ops&lt;/code&gt; class; this operator class includes comparison functions for four-byte integers. In practice the default operator class for the column's data type is usually sufficient. The main point of having operator classes is that for some data types, there could be more than one meaningful ordering. For example, we might want to sort a complex-number data type either by absolute value or by real part. We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index. More information about operator classes is in &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; and in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;演算子クラス&lt;/em&gt;オプションのパラメータでは、インデックスの各列に指定することができます。演算子クラスは、その列のインデックスで使用される演算子を識別します。たとえば、4バイト整数のBツリーインデックスは &lt;code&gt;int4_ops&lt;/code&gt; を使用しますクラス;この演算子クラスには、4バイト整数の比較関数が含まれています。実際には、通常、列のデータ型のデフォルトの演算子クラスで十分です。演算子クラスを持つことの主なポイントは、一部のデータ型では、複数の意味のある順序が存在する可能性があることです。たとえば、複素数のデータ型を絶対値または実数部で並べ替えることができます。これを行うには、データ型に2つの演算子クラスを定義し、インデックスを作成するときに適切なクラスを選択します。演算子クラスの詳細については、&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10&lt;/a&gt;および&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;セクション37.16を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48d61fa80ff015b13be4db7ffab694d479aec5c7" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.23&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">AREは&lt;em&gt;埋め込みオプションで&lt;/em&gt;開始でき&lt;em&gt;ます&lt;/em&gt;。シーケンス &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; （ &lt;code&gt;xyz&lt;/code&gt; は1つ以上のアルファベット文字）は、残りのREに影響するオプションを指定します。これらのオプションは、以前に決定されたオプションをオーバーライドします。特に、正規表現演算子によって暗黙に指定された大文字と小文字を区別する動作、または正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメーターをオーバーライドできます。使用可能なオプション文字を&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.23に&lt;/a&gt;示します。これらと同じオプション文字が正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメータで使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="451a7edefd1d33d9d12316f5963ee8b77dc6c002" translate="yes" xml:space="preserve">
          <source>An ARE can begin with &lt;em&gt;embedded options&lt;/em&gt;: a sequence &lt;code&gt;(?&lt;/code&gt;&lt;code&gt;xyz&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; (where &lt;code&gt;xyz&lt;/code&gt; is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options &amp;mdash; in particular, they can override the case-sensitivity behavior implied by a regex operator, or the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function. The available option letters are shown in &lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;Table 9.24&lt;/a&gt;. Note that these same option letters are used in the &lt;code&gt;flags&lt;/code&gt; parameters of regex functions.</source>
          <target state="translated">AREは、&lt;em&gt;埋め込まれたオプションで&lt;/em&gt;始めることができ&lt;em&gt;ます&lt;/em&gt;。シーケンス &lt;code&gt;(?&lt;/code&gt; &lt;code&gt;xyz&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; （ &lt;code&gt;xyz&lt;/code&gt; は1つ以上のアルファベット文字）は、REの残りの部分に影響を与えるオプションを指定します。これらのオプションは、以前に決定されたオプションをオーバーライドします。特に、正規表現演算子または正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメーターによって示される大文字と小文字を区別する動作をオーバーライドできます。使用可能なオプション文字を&lt;a href=&quot;functions-matching#POSIX-EMBEDDED-OPTIONS-TABLE&quot;&gt;表9.24に&lt;/a&gt;示します。これらの同じオプション文字が正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメータで使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8303919571de789ee40617113cb585782a02b887" translate="yes" xml:space="preserve">
          <source>An IP address range is specified using standard numeric notation for the range's starting address, then a slash (&lt;code&gt;/&lt;/code&gt;) and a CIDR mask length. The mask length indicates the number of high-order bits of the client IP address that must match. Bits to the right of this should be zero in the given IP address. There must not be any white space between the IP address, the &lt;code&gt;/&lt;/code&gt;, and the CIDR mask length.</source>
          <target state="translated">IPアドレス範囲は、範囲の開始アドレスに標準の数値表記を使用して指定され、次にスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）とCIDRマスク長が使用されます。マスク長は、一致する必要があるクライアントIPアドレスの高位ビットの数を示します。この右側のビットは、指定されたIPアドレスでゼロでなければなりません。 IPアドレス、 &lt;code&gt;/&lt;/code&gt; 、およびCIDRマスク長の間に空白があってはなりません。</target>
        </trans-unit>
        <trans-unit id="4d44878e850b43c3405e5eb1f7f363ec736fdcdb" translate="yes" xml:space="preserve">
          <source>An RE can begin with one of two special &lt;em&gt;director&lt;/em&gt; prefixes. If an RE begins with &lt;code&gt;***:&lt;/code&gt;, the rest of the RE is taken as an ARE. (This normally has no effect in PostgreSQL, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the &lt;code&gt;flags&lt;/code&gt; parameter to a regex function.) If an RE begins with &lt;code&gt;***=&lt;/code&gt;, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters.</source>
          <target state="translated">REは、2つの特別な&lt;em&gt;ディレクター&lt;/em&gt;プレフィックスのいずれかで開始できます。REが &lt;code&gt;***:&lt;/code&gt; で始まる場合、RE の残りはAREとして扱われます。（これは、REがAREであると見なされるため、通常、PostgreSQLでは効果がありません。ただし、正規表現関数の &lt;code&gt;flags&lt;/code&gt; パラメータでEREまたはBREモードが指定されている場合は効果があります。）REが &lt;code&gt;***=&lt;/code&gt; で始まる場合、REの残りの部分はリテラル文字列と見なされ、すべての文字が通常の文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="f92f9e66ed8af2bcc3cdde26f5c0bbb45e8250e2" translate="yes" xml:space="preserve">
          <source>An RE cannot end with a backslash (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">REをバックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）で終了することはできません。</target>
        </trans-unit>
        <trans-unit id="081369b9016058fa6fc78b0eda53f1fad864ebdf" translate="yes" xml:space="preserve">
          <source>An RE consisting of two or more branches connected by the &lt;code&gt;|&lt;/code&gt; operator is always greedy.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; で接続された2つ以上のブランチで構成されるRE 演算子は常に貪欲です。</target>
        </trans-unit>
        <trans-unit id="d49fecf670a244dc0b1f819b231bb69a34573ff1" translate="yes" xml:space="preserve">
          <source>An RFC 4516 LDAP URL. This is an alternative way to write some of the other LDAP options in a more compact and standard form. The format is</source>
          <target state="translated">RFC 4516 LDAP URL。これは、他のLDAPオプションのいくつかをよりコンパクトで標準的な形式で記述するための代替方法です。形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f7312c64a5fb73a6994e92da5b12fd76cc61e03e" translate="yes" xml:space="preserve">
          <source>An SHA1 hash of the random prefix and data is appended.</source>
          <target state="translated">ランダムな接頭辞とデータの SHA1 ハッシュが付加されます。</target>
        </trans-unit>
        <trans-unit id="c3a965fc350f5f7dc5c4c1f8d246e2c0ef7db3f8" translate="yes" xml:space="preserve">
          <source>An SQL command that is used to allow a &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;user&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; to access specific objects within the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;ユーザー&lt;/a&gt;または&lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;ロール&lt;/a&gt;が&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;内の特定のオブジェクトにアクセスできるようにするために使用されるSQLコマンド。</target>
        </trans-unit>
        <trans-unit id="b6dc35165836f5ddf8c81146786e84d00be18739" translate="yes" xml:space="preserve">
          <source>An SQL command used to add new data into a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="translated">新しいデータを&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;に追加するために使用されるSQLコマンド。</target>
        </trans-unit>
        <trans-unit id="8802fb5ebf1fb183b8afc9517e0fb8a334aaa1ec" translate="yes" xml:space="preserve">
          <source>An SQL command used to modify &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; that may already exist in a specified &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;. It cannot create or remove rows.</source>
          <target state="translated">指定された&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブルに&lt;/a&gt;すでに存在する可能性のある&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;行&lt;/a&gt;を変更するために使用されるSQLコマンド。行を作成または削除することはできません。</target>
        </trans-unit>
        <trans-unit id="c2cced83fa51a6d9077bcc4256624ffa5277885e" translate="yes" xml:space="preserve">
          <source>An SQL command which removes &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; from a given &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;テーブル&lt;/a&gt;または&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;リレーション&lt;/a&gt;から&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;行&lt;/a&gt;を削除するSQLコマンド。</target>
        </trans-unit>
        <trans-unit id="f0fe55953856dbcea542a9b75d2a05e987bd7029" translate="yes" xml:space="preserve">
          <source>An SQL statement defining an object to be created within the schema. Currently, only &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE VIEW&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt;, &lt;code&gt;CREATE SEQUENCE&lt;/code&gt;, &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and &lt;code&gt;GRANT&lt;/code&gt; are accepted as clauses within &lt;code&gt;CREATE SCHEMA&lt;/code&gt;. Other kinds of objects may be created in separate commands after the schema is created.</source>
          <target state="translated">スキーマ内に作成されるオブジェクトを定義するSQLステートメント。現在、 &lt;code&gt;CREATE SCHEMA&lt;/code&gt; 内の句として受け入れられるのは、 &lt;code&gt;CREATE TABLE&lt;/code&gt; 、 &lt;code&gt;CREATE VIEW&lt;/code&gt; 、 &lt;code&gt;CREATE INDEX&lt;/code&gt; 、 &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; 、 &lt;code&gt;CREATE TRIGGER&lt;/code&gt; および &lt;code&gt;GRANT&lt;/code&gt; のみです。他の種類のオブジェクトは、スキーマの作成後に別のコマンドで作成できます。</target>
        </trans-unit>
        <trans-unit id="48fae02660a1ba4984826c61b82cac7e0aec9ce9" translate="yes" xml:space="preserve">
          <source>An SQL/JSON path expression is typically written in an SQL query as an SQL character string literal, so it must be enclosed in single quotes, and any single quotes desired within the value must be doubled (see &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt;). Some forms of path expressions require string literals within them. These embedded string literals follow JavaScript/ECMAScript conventions: they must be surrounded by double quotes, and backslash escapes may be used within them to represent otherwise-hard-to-type characters. In particular, the way to write a double quote within an embedded string literal is &lt;code&gt;\&quot;&lt;/code&gt;, and to write a backslash itself, you must write &lt;code&gt;\\&lt;/code&gt;. Other special backslash sequences include those recognized in JSON strings: &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt; for various ASCII control characters, and &lt;code&gt;\uNNNN&lt;/code&gt; for a Unicode character identified by its 4-hex-digit code point. The backslash syntax also includes two cases not allowed by JSON: &lt;code&gt;\xNN&lt;/code&gt; for a character code written with only two hex digits, and &lt;code&gt;\u{N...}&lt;/code&gt; for a character code written with 1 to 6 hex digits.</source>
          <target state="translated">SQL / JSONパス式は通常、SQLクエリでSQL文字列リテラルとして記述されるため、一重引用符で囲む必要があり、値内で必要な一重引用符はすべて二重にする必要があります（&lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;セクション4.1.2.1を&lt;/a&gt;参照）。パス式の一部の形式では、その中に文字列リテラルが必要です。これらの埋め込み文字列リテラルは、JavaScript / ECMAScriptの規則に従います。二重引用符で囲む必要があり、バックスラッシュエスケープを使用して、入力が難しい文字を表すことができます。特に、埋め込み文字列リテラル内に二重引用符を記述する方法は &lt;code&gt;\&quot;&lt;/code&gt; で、バックスラッシュ自体を書き込む方法は &lt;code&gt;\\&lt;/code&gt; を記述する必要があります。その他の特殊なバックスラッシュシーケンスには、JSON文字列で認識されるものがあります： &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、 &lt;code&gt;\v&lt;/code&gt; はさまざまなASCII制御文字用、 &lt;code&gt;\uNNNN&lt;/code&gt; は4桁の16進数のコードポイントで識別されるUnicode文字用です。バックスラッシュ構文には、JSONで許可されない2つのケースも含まれます &lt;code&gt;\xNN&lt;/code&gt; 桁の16進数で書かれた文字コードの\ xNNと、1〜6桁の16進数で書かれた文字コードの &lt;code&gt;\u{N...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47144dcc7f07df67a82e2f341e637ce0d341143" translate="yes" xml:space="preserve">
          <source>An additional caveat, if the goal is to avoid recalculating &lt;code&gt;f(x)&lt;/code&gt;, is that the planner won't necessarily match uses of &lt;code&gt;f(x)&lt;/code&gt; that aren't in indexable &lt;code&gt;WHERE&lt;/code&gt; clauses to the index column. It will usually get this right in simple queries such as shown above, but not in queries that involve joins. These deficiencies may be remedied in future versions of PostgreSQL.</source>
          <target state="translated">目標が &lt;code&gt;f(x)&lt;/code&gt; の再計算を回避することである場合、追加の警告は、プランナが必ずしもインデックス可能な &lt;code&gt;WHERE&lt;/code&gt; 句にない &lt;code&gt;f(x)&lt;/code&gt; の使用とインデックス列を一致させることではないということです。通常、上記のような単純なクエリではこれが正しく行われますが、結合を含むクエリでは正しく行われません。これらの欠陥は、PostgreSQLの将来のバージョンで修正される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7407a4adf6d27ef60782fee33abc21dda639d1bb" translate="yes" xml:space="preserve">
          <source>An additional expectation is that &lt;code&gt;in_range&lt;/code&gt; functions should, if practical, avoid throwing an error if &lt;code&gt;base&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;base&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;offset&lt;/code&gt; would overflow. The correct comparison result can be determined even if that value would be out of the data type's range. Note that if the data type includes concepts such as &amp;ldquo;infinity&amp;rdquo; or &amp;ldquo;NaN&amp;rdquo;, extra care may be needed to ensure that &lt;code&gt;in_range&lt;/code&gt;'s results agree with the normal sort order of the operator family.</source>
          <target state="translated">さらに予想されるのは、 &lt;code&gt;base&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; または &lt;code&gt;base&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;offset&lt;/code&gt; がオーバーフローする場合に、実際には、 &lt;code&gt;in_range&lt;/code&gt; 関数がエラーをスローしないようにすることです。その値がデータ型の範囲外であっても、正しい比較結果を判断できます。データ型に「無限大」や「NaN」などの概念が含まれている場合は、 &lt;code&gt;in_range&lt;/code&gt; の結果が演算子族の通常の並べ替え順序と一致するように、さらに注意が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="eb253cb4aa708d5943b4ee75823919dac326e149" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.63&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">パーサーによって提供される追加のヒューリスティックにより、暗黙的なキャストを持つタイプのグループ間での適切なキャスト動作の決定を改善できます。データ型は、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;bitstring&lt;/code&gt; 文字列、 &lt;code&gt;datetime&lt;/code&gt; 、 &lt;code&gt;timespan&lt;/code&gt; 、 &lt;code&gt;geometric&lt;/code&gt; 、 &lt;code&gt;network&lt;/code&gt; 、ユーザー定義など、いくつかの基本的な&lt;em&gt;型カテゴリに分類&lt;/em&gt;されます。 （リストについては、&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.63を&lt;/a&gt;参照してください。ただし、カスタムタイプのカテゴリを作成することもできます。）各カテゴリ内には、1つ以上の&lt;em&gt;優先タイプがあります。&lt;/em&gt;&lt;em&gt;&lt;/em&gt;、可能なタイプの選択肢がある場合に推奨されます。優先タイプと使用可能な暗黙のキャストを注意深く選択することで、あいまいな式（複数の候補解析ソリューションを持つ式）を便利な方法で解決できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="534defd7e745925ed14ebff65872ea3017b9134a" translate="yes" xml:space="preserve">
          <source>An additional heuristic provided by the parser allows improved determination of the proper casting behavior among groups of types that have implicit casts. Data types are divided into several basic &lt;em&gt;type categories&lt;/em&gt;, including &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;timespan&lt;/code&gt;, &lt;code&gt;geometric&lt;/code&gt;, &lt;code&gt;network&lt;/code&gt;, and user-defined. (For a list see &lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;Table 51.64&lt;/a&gt;; but note it is also possible to create custom type categories.) Within each category there can be one or more &lt;em&gt;preferred types&lt;/em&gt;, which are preferred when there is a choice of possible types. With careful selection of preferred types and available implicit casts, it is possible to ensure that ambiguous expressions (those with multiple candidate parsing solutions) can be resolved in a useful way.</source>
          <target state="translated">パーサーによって提供される追加のヒューリスティックにより、暗黙的なキャストを持つタイプのグループ間での適切なキャスト動作の決定が改善されます。データ型は、 &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;numeric&lt;/code&gt; 、 &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;bitstring&lt;/code&gt; 、 &lt;code&gt;datetime&lt;/code&gt; 、 &lt;code&gt;timespan&lt;/code&gt; 、 &lt;code&gt;geometric&lt;/code&gt; 、 &lt;code&gt;network&lt;/code&gt; 、およびuser-defined など、いくつかの基本的な&lt;em&gt;型のカテゴリに分類&lt;/em&gt;されます。 （リストについては&lt;a href=&quot;catalog-pg-type#CATALOG-TYPCATEGORY-TABLE&quot;&gt;表51.64を&lt;/a&gt;参照してください。ただし、カスタムタイプのカテゴリを作成することも可能であることに注意してください。）各カテゴリ内には、1つ以上の&lt;em&gt;優先タイプがあります。&lt;/em&gt;&lt;em&gt;&lt;/em&gt;、可能なタイプの選択肢がある場合に推奨されます。優先する型と利用可能な暗黙のキャストを注意深く選択すると、あいまいな式（解析ソリューションの候補が複数あるもの）を便利な方法で解決できるようになります。</target>
        </trans-unit>
        <trans-unit id="7fc0f4d6b418b13b44c7318de707eba4cc69a20d" translate="yes" xml:space="preserve">
          <source>An additional property of most of the OID alias types is the creation of dependencies. If a constant of one of these types appears in a stored expression (such as a column default expression or view), it creates a dependency on the referenced object. For example, if a column has a default expression &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt;, PostgreSQL understands that the default expression depends on the sequence &lt;code&gt;my_seq&lt;/code&gt;; the system will not let the sequence be dropped without first removing the default expression. &lt;code&gt;regrole&lt;/code&gt; is the only exception for the property. Constants of this type are not allowed in such expressions.</source>
          <target state="translated">ほとんどのOIDエイリアスタイプの追加のプロパティは、依存関係の作成です。これらのタイプのいずれかの定数が、格納された式（列のデフォルト式やビューなど）に現れる場合、参照されるオブジェクトへの依存関係を作成します。たとえば、列にデフォルト式 &lt;code&gt;nextval('my_seq'::regclass)&lt;/code&gt; 場合、PostgreSQLはデフォルト式がシーケンス &lt;code&gt;my_seq&lt;/code&gt; に依存することを理解します。システムは、最初にデフォルトの式を削除せずにシーケンスをドロップさせません。 &lt;code&gt;regrole&lt;/code&gt; は、プロパティの唯一の例外です。このタイプの定数は、このような式では使用できません。</target>
        </trans-unit>
        <trans-unit id="458e50f0c0fe0a599acde7428114320c8fb97644" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;セクション37.12.1で&lt;/a&gt;説明されているように、集約はオプションで&lt;em&gt;移動集約モードを&lt;/em&gt;サポートできます。これには、 &lt;code&gt;MSFUNC&lt;/code&gt; 、 &lt;code&gt;MINVFUNC&lt;/code&gt; 、および &lt;code&gt;MSTYPE&lt;/code&gt; パラメータを指定する必要があり、オプションで &lt;code&gt;MSSPACE&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 、および &lt;code&gt;MINITCOND&lt;/code&gt; パラメータを指定する必要があります。 &lt;code&gt;MINVFUNC&lt;/code&gt; を除いて、これらのパラメーターは &lt;code&gt;M&lt;/code&gt; なしの対応する単純集計パラメーターのように機能します。これらは、逆遷移関数を含む集約の個別の実装を定義します。</target>
        </trans-unit>
        <trans-unit id="29fb09a88b1e0b362734b37fcd73ac91f7b1c450" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;moving-aggregate mode&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;Section 37.12.1&lt;/a&gt;. This requires specifying the &lt;code&gt;MSFUNC&lt;/code&gt;, &lt;code&gt;MINVFUNC&lt;/code&gt;, and &lt;code&gt;MSTYPE&lt;/code&gt; parameters, and optionally the &lt;code&gt;MSSPACE&lt;/code&gt;, &lt;code&gt;MFINALFUNC&lt;/code&gt;, &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt;, &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt;, and &lt;code&gt;MINITCOND&lt;/code&gt; parameters. Except for &lt;code&gt;MINVFUNC&lt;/code&gt;, these parameters work like the corresponding simple-aggregate parameters without &lt;code&gt;M&lt;/code&gt;; they define a separate implementation of the aggregate that includes an inverse transition function.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-MOVING-AGGREGATES&quot;&gt;セクション37.12.1で&lt;/a&gt;説明されているように、アグリゲートはオプションで&lt;em&gt;移動アグリゲートモードを&lt;/em&gt;サポートできます。これには、 &lt;code&gt;MSFUNC&lt;/code&gt; 、 &lt;code&gt;MINVFUNC&lt;/code&gt; 、および &lt;code&gt;MSTYPE&lt;/code&gt; パラメーター、およびオプションで &lt;code&gt;MSSPACE&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC_EXTRA&lt;/code&gt; 、 &lt;code&gt;MFINALFUNC_MODIFY&lt;/code&gt; 、および &lt;code&gt;MINITCOND&lt;/code&gt; パラメーターを指定する必要があります。 &lt;code&gt;MINVFUNC&lt;/code&gt; を除いて、これらのパラメーターは、 &lt;code&gt;M&lt;/code&gt; のない対応する単純集計パラメーターのように機能します。それらは、逆遷移関数を含む集計の個別の実装を定義します。</target>
        </trans-unit>
        <trans-unit id="4d679ad2d9aaa3f73ccadb1adf16347c9d1df070" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;セクション37.12.4で&lt;/a&gt;説明されているように、集約はオプションで&lt;em&gt;部分集約を&lt;/em&gt;サポートできます。これには、 &lt;code&gt;COMBINEFUNC&lt;/code&gt; パラメータを指定する必要があります。場合 &lt;code&gt;state_data_type&lt;/code&gt; ある &lt;code&gt;internal&lt;/code&gt; 、それは提供するために、適切なも普通だ &lt;code&gt;SERIALFUNC&lt;/code&gt; と &lt;code&gt;DESERIALFUNC&lt;/code&gt; 並列集約が可能になるようにパラメータを。並列集約を有効にするには、集約にも &lt;code&gt;PARALLEL SAFE&lt;/code&gt; のマークを付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f7e84609c5356ef9572b92f634b5a8669d5cf54b" translate="yes" xml:space="preserve">
          <source>An aggregate can optionally support &lt;em&gt;partial aggregation&lt;/em&gt;, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;Section 37.12.4&lt;/a&gt;. This requires specifying the &lt;code&gt;COMBINEFUNC&lt;/code&gt; parameter. If the &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt;, it's usually also appropriate to provide the &lt;code&gt;SERIALFUNC&lt;/code&gt; and &lt;code&gt;DESERIALFUNC&lt;/code&gt; parameters so that parallel aggregation is possible. Note that the aggregate must also be marked &lt;code&gt;PARALLEL SAFE&lt;/code&gt; to enable parallel aggregation.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html#XAGGR-PARTIAL-AGGREGATES&quot;&gt;セクション37.12.4で&lt;/a&gt;説明されているように、アグリゲートはオプションで&lt;em&gt;部分アグリゲーションを&lt;/em&gt;サポートできます。これには、 &lt;code&gt;COMBINEFUNC&lt;/code&gt; パラメーターを指定する必要があります。場合 &lt;code&gt;state_data_type&lt;/code&gt; ある &lt;code&gt;internal&lt;/code&gt; 、それは提供するために、適切なも普通だ &lt;code&gt;SERIALFUNC&lt;/code&gt; と &lt;code&gt;DESERIALFUNC&lt;/code&gt; 並列集約が可能になるようにパラメータを。並列アグリゲーションを有効にするには、アグリゲートにも &lt;code&gt;PARALLEL SAFE&lt;/code&gt; マークを付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2dfc7ac5613e772bc99452f1945c3b220614eb51" translate="yes" xml:space="preserve">
          <source>An aggregate expression</source>
          <target state="translated">集約式</target>
        </trans-unit>
        <trans-unit id="e0807075b6b78aa07561f78a847dd6293e2860ad" translate="yes" xml:space="preserve">
          <source>An aggregate expression can only appear in the result list or &lt;code&gt;HAVING&lt;/code&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; command. It is forbidden in other clauses, such as &lt;code&gt;WHERE&lt;/code&gt;, because those clauses are logically evaluated before the results of aggregates are formed.</source>
          <target state="translated">集計式は、 &lt;code&gt;SELECT&lt;/code&gt; コマンドの結果リストまたは &lt;code&gt;HAVING&lt;/code&gt; 句にのみ表示できます。これらの句は集計の結果が形成される前に論理的に評価されるため、 &lt;code&gt;WHERE&lt;/code&gt; などの他の句では禁止されています。</target>
        </trans-unit>
        <trans-unit id="d5cc6417758e002213e0379735846ccb8b7a9410" translate="yes" xml:space="preserve">
          <source>An aggregate function can provide an initial condition, that is, an initial value for the internal state value. This is specified and stored in the database as a value of type &lt;code&gt;text&lt;/code&gt;, but it must be a valid external representation of a constant of the state value data type. If it is not supplied then the state value starts out null.</source>
          <target state="translated">集約関数は、初期状態、つまり内部状態値の初期値を提供できます。これは &lt;code&gt;text&lt;/code&gt; 型の値として指定され、データベースに格納されますが、状態値データ型の定数の有効な外部表現である必要があります。指定しない場合、状態値はnullから始まります。</target>
        </trans-unit>
        <trans-unit id="4c0a9d3ddcc76a8af6ce90bf3fe2aed9cae7fe77" translate="yes" xml:space="preserve">
          <source>An aggregate function is identified by its name and input data type(s). Two aggregates in the same schema can have the same name if they operate on different input types. The name and input data type(s) of an aggregate must also be distinct from the name and input data type(s) of every ordinary function in the same schema. This behavior is identical to overloading of ordinary function names (see &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;).</source>
          <target state="translated">集約関数は、その名前と入力データ型によって識別されます。同じスキーマ内の2つのアグリゲートは、異なる入力タイプを操作する場合、同じ名前を持つことができます。集合体の名前と入力データ型は、同じスキーマ内のすべての通常の関数の名前と入力データ型とも異なる必要があります。この動作は、通常の関数名のオーバーロードと同じです（&lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTIONを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2b3e0e3a20d60ad454bd8cd7d186466b528e1274" translate="yes" xml:space="preserve">
          <source>An aggregate function whose &lt;code&gt;state_data_type&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; can participate in parallel aggregation only if it has a &lt;code&gt;serialfunc&lt;/code&gt; function, which must serialize the aggregate state into a &lt;code&gt;bytea&lt;/code&gt; value for transmission to another process. This function must take a single argument of type &lt;code&gt;internal&lt;/code&gt; and return type &lt;code&gt;bytea&lt;/code&gt;. A corresponding &lt;code&gt;deserialfunc&lt;/code&gt; is also required.</source>
          <target state="translated">&lt;code&gt;state_data_type&lt;/code&gt; が &lt;code&gt;internal&lt;/code&gt; である集約関数は、別のプロセスに送信するために集約状態を &lt;code&gt;bytea&lt;/code&gt; 値にシリアル化する必要がある &lt;code&gt;serialfunc&lt;/code&gt; 関数がある場合にのみ、並列集約に参加できます。この関数は、 &lt;code&gt;internal&lt;/code&gt; 型の引数を1つ取り、 &lt;code&gt;bytea&lt;/code&gt; 型を返す必要があります。対応する &lt;code&gt;deserialfunc&lt;/code&gt; も必要です。</target>
        </trans-unit>
        <trans-unit id="df00344c6606cf49c7be60428adf4c46220a9708" translate="yes" xml:space="preserve">
          <source>An alias can be provided in the same way as for a table. If an alias is written, a column alias list can also be written to provide substitute names for one or more attributes of the function's composite return type, including the column added by &lt;code&gt;ORDINALITY&lt;/code&gt; if present.</source>
          <target state="translated">エイリアスは、テーブルの場合と同じ方法で提供できます。エイリアスが記述されている場合、列エイリアスリストを記述して、関数の複合戻り値型の1つ以上の属性の代替名を提供することもできます（ &lt;code&gt;ORDINALITY&lt;/code&gt; によって追加された列がある場合）。</target>
        </trans-unit>
        <trans-unit id="a0250a12b43f45cb324a618ef9cdbd68812da4e5" translate="yes" xml:space="preserve">
          <source>An alternative backup strategy is to directly copy the files that PostgreSQL uses to store the data in the database; &lt;a href=&quot;creating-cluster&quot;&gt;Section 18.2&lt;/a&gt; explains where these files are located. You can use whatever method you prefer for doing file system backups; for example:</source>
          <target state="translated">別のバックアップ戦略は、PostgreSQLがデータベースにデータを格納するために使用するファイルを直接コピーすることです。&lt;a href=&quot;creating-cluster&quot;&gt;セクション18.2&lt;/a&gt;では、これらのファイルの場所について説明しています。ファイルシステムのバックアップには、任意の方法を使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="b61de693c26d02887a03f9b9c2b1cd2f4c796982" translate="yes" xml:space="preserve">
          <source>An alternative file-system backup approach is to make a &amp;ldquo;consistent snapshot&amp;rdquo; of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a &amp;ldquo;frozen snapshot&amp;rdquo; of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a &lt;code&gt;CHECKPOINT&lt;/code&gt; before taking the snapshot to reduce recovery time.</source>
          <target state="translated">別のファイルシステムバックアップアプローチは、データシステムの「一貫性のあるスナップショット」を作成することです。ただし、ファイルシステムがその機能をサポートしている場合（および、ファイルシステムが正しく実装されていると信頼してもかまいません）。典型的な手順は、データベースを含むボリュームの「凍結スナップショット」を作成してから、スナップショットからバックアップデバイスにデータディレクトリ全体（上記の一部だけではない）をコピーし、凍結スナップショットを解放することです。これは、データベースサーバーの実行中でも機能します。ただし、この方法で作成されたバックアップは、データベースサーバーが適切にシャットダウンされなかったかのようにデータベースファイルを保存します。したがって、バックアップデータでデータベースサーバーを起動すると、以前のサーバーインスタンスがクラッシュしたと見なされ、WALログが再生されます。これは問題ではありません。これに注意してください（バックアップにWALファイルを含めるようにしてください）。あなたは &lt;code&gt;CHECKPOINT&lt;/code&gt; スナップショットを作成する前にチェックポイントを設定して、復旧時間を短縮します。</target>
        </trans-unit>
        <trans-unit id="c3c3283b5d81a417bf78d55aa00de334b32f532e" translate="yes" xml:space="preserve">
          <source>An alternative syntax, which conforms to the SQL standard by using the keyword &lt;code&gt;ARRAY&lt;/code&gt;, can be used for one-dimensional arrays. &lt;code&gt;pay_by_quarter&lt;/code&gt; could have been defined as:</source>
          <target state="translated">キーワード &lt;code&gt;ARRAY&lt;/code&gt; を使用してSQL標準に準拠する代替構文を1次元配列に使用できます。 &lt;code&gt;pay_by_quarter&lt;/code&gt; は次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="638c7c832e5e9b62d5fb5f6d733b2905e931d645" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">前のセクションで説明した組み込みのスタンバイモードの代わりに、アーカイブの場所をポーリングする &lt;code&gt;restore_command&lt;/code&gt; を使用することができます。これは、バージョン8.4以前で使用可能な唯一のオプションでした。このリファレンス実装については、&lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="a8b7165adb636504ac5f79579ceffb000f734741" translate="yes" xml:space="preserve">
          <source>An alternative to the built-in standby mode described in the previous sections is to use a &lt;code&gt;restore_command&lt;/code&gt; that polls the archive location. This was the only option available in versions 8.4 and below. See the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module for a reference implementation of this.</source>
          <target state="translated">前のセクションで説明した組み込みのスタンバイモードの代わりに、アーカイブの場所をポーリングする &lt;code&gt;restore_command&lt;/code&gt; を使用することもできます。これは、バージョン8.4以下で使用可能な唯一のオプションでした。これのリファレンス実装については、&lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="fa59772716d4044140c10df2d8b7a5924c081417" translate="yes" xml:space="preserve">
          <source>An alternative way to specify connection parameters is in a &lt;em&gt;&lt;code&gt;conninfo&lt;/code&gt;&lt;/em&gt; string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example:</source>
          <target state="translated">接続パラメータを指定する別の方法は、データベース名の代わりに使用される&lt;em&gt; &lt;code&gt;conninfo&lt;/code&gt; &lt;/em&gt;文字列またはURIです。このメカニズムにより、接続を非常に幅広く制御できます。例えば：</target>
        </trans-unit>
        <trans-unit id="8ec33e5bc23fcb877ba4c42aa95a3a9f21f59a6d" translate="yes" xml:space="preserve">
          <source>An arbitrary identifier that later identifies this transaction for &lt;code&gt;COMMIT PREPARED&lt;/code&gt; or &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt;. The identifier must be written as a string literal, and must be less than 200 bytes long. It must not be the same as the identifier used for any currently prepared transaction.</source>
          <target state="translated">&lt;code&gt;COMMIT PREPARED&lt;/code&gt; または &lt;code&gt;ROLLBACK PREPARED&lt;/code&gt; についてこのトランザクションを後で識別する任意の識別子。識別子は文字列リテラルとして記述する必要があり、長さは200バイト未満でなければなりません。現在準備されているトランザクションに使用されている識別子と同じであってはなりません。</target>
        </trans-unit>
        <trans-unit id="154d8a4c4e542e35a1befe68e1484bcdb9bfce9b" translate="yes" xml:space="preserve">
          <source>An arbitrary name given to this particular prepared statement. It must be unique within a single session and is subsequently used to execute or deallocate a previously prepared statement.</source>
          <target state="translated">この特定の準備されたステートメントに与えられる任意の名前。この名前は単一のセッション内で一意でなければならず、その後、以前に準備されたステートメントを実行したり解放したりするために使用されます。</target>
        </trans-unit>
        <trans-unit id="8cfd518cee734d4e6e12ef304061cfa2c5efcc5d" translate="yes" xml:space="preserve">
          <source>An array can also be constructed by using the functions &lt;code&gt;array_prepend&lt;/code&gt;, &lt;code&gt;array_append&lt;/code&gt;, or &lt;code&gt;array_cat&lt;/code&gt;. The first two only support one-dimensional arrays, but &lt;code&gt;array_cat&lt;/code&gt; supports multidimensional arrays. Some examples:</source>
          <target state="translated">配列は、関数 &lt;code&gt;array_prepend&lt;/code&gt; 、 &lt;code&gt;array_append&lt;/code&gt; 、または &lt;code&gt;array_cat&lt;/code&gt; を使用して構築することもできます。最初の2つは1次元配列のみをサポートしますが、 &lt;code&gt;array_cat&lt;/code&gt; は多次元配列をサポートします。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="b9253fad046b597c92ebf100d62457d49600956f" translate="yes" xml:space="preserve">
          <source>An array can also be updated at a single element:</source>
          <target state="translated">配列は1つの要素で更新することもできます。</target>
        </trans-unit>
        <trans-unit id="207ba5c2689d9a2decbdf9a201e85765c620f79a" translate="yes" xml:space="preserve">
          <source>An array constructor</source>
          <target state="translated">配列のコンストラクタ</target>
        </trans-unit>
        <trans-unit id="22dde08afcbb8b9d32ea23d688400ce811c7d712" translate="yes" xml:space="preserve">
          <source>An array constructor is an expression that builds an array value using values for its member elements. A simple array constructor consists of the key word &lt;code&gt;ARRAY&lt;/code&gt;, a left square bracket &lt;code&gt;[&lt;/code&gt;, a list of expressions (separated by commas) for the array element values, and finally a right square bracket &lt;code&gt;]&lt;/code&gt;. For example:</source>
          <target state="translated">配列コンストラクターは、メンバー要素の値を使用して配列値を作成する式です。単純な配列コンストラクターは、キーワード &lt;code&gt;ARRAY&lt;/code&gt; 、左大括弧 &lt;code&gt;[&lt;/code&gt; 、配列要素値の式のリスト（コンマで区切られた）、最後に右大括弧 &lt;code&gt;]&lt;/code&gt; で構成されます。例えば：</target>
        </trans-unit>
        <trans-unit id="7dbcd90a7826ddce4d84f03c4037551f65cc619b" translate="yes" xml:space="preserve">
          <source>An array containing codes for the enabled statistic kinds; valid values are: &lt;code&gt;d&lt;/code&gt; for n-distinct statistics, &lt;code&gt;f&lt;/code&gt; for functional dependency statistics, and &lt;code&gt;m&lt;/code&gt; for most common values (MCV) list statistics</source>
          <target state="translated">有効な統計の種類のコードを含む配列。有効な値は、n-distinct統計の場合は &lt;code&gt;d&lt;/code&gt; 、機能依存関係統計の場合は &lt;code&gt;f&lt;/code&gt; 、最も一般的な値（MCV）リスト統計の場合は &lt;code&gt;m&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="27ac7c03cbb87eb7b9fd6d5d5942fb204a13357b" translate="yes" xml:space="preserve">
          <source>An array containing the IDs of the roles in this group</source>
          <target state="translated">このグループのロールのIDを含む配列</target>
        </trans-unit>
        <trans-unit id="96036220e810514b07282609308d02f0cce74ab2" translate="yes" xml:space="preserve">
          <source>An array of attribute numbers, indicating which table columns are covered by this statistics object; for example a value of &lt;code&gt;1 3&lt;/code&gt; would mean that the first and the third table columns are covered</source>
          <target state="translated">この統計オブジェクトによってカバーされるテーブル列を示す属性番号の配列。たとえば、 &lt;code&gt;1 3&lt;/code&gt; の値は、最初と3番目のテーブル列がカバーされることを意味します</target>
        </trans-unit>
        <trans-unit id="b19c35ad447cc03eaa08f8712bc2b7258decc833" translate="yes" xml:space="preserve">
          <source>An array slice expression likewise yields null if the array itself or any of the subscript expressions are null. However, in other cases such as selecting an array slice that is completely outside the current array bounds, a slice expression yields an empty (zero-dimensional) array instead of null. (This does not match non-slice behavior and is done for historical reasons.) If the requested slice partially overlaps the array bounds, then it is silently reduced to just the overlapping region instead of returning null.</source>
          <target state="translated">配列スライス式も同様に、配列自体または添え字式のいずれかが null の場合は null を返します。ただし、現在の配列の境界から完全に外れた配列スライスを選択するなど、その他のケースでは、スライス式は NULL の代わりに空の (ゼロ次元の)配列を返します (これは、スライス以外の動作とは一致せず、歴史的な理由から行われています)。(これは、スライス以外の動作とは一致せず、歴史的な理由から行われています。)要求されたスライスが配列の境界と部分的に重なっている場合は、NULL を返す代わりに、重なっている領域だけに縮小されます。</target>
        </trans-unit>
        <trans-unit id="1acc2bad9c714dff64f3a38358f5e30f839c8b6c" translate="yes" xml:space="preserve">
          <source>An array subscript expression will return null if either the array itself or any of the subscript expressions are null. Also, null is returned if a subscript is outside the array bounds (this case does not raise an error). For example, if &lt;code&gt;schedule&lt;/code&gt; currently has the dimensions &lt;code&gt;[1:3][1:2]&lt;/code&gt; then referencing &lt;code&gt;schedule[3][3]&lt;/code&gt; yields NULL. Similarly, an array reference with the wrong number of subscripts yields a null rather than an error.</source>
          <target state="translated">配列の添え字式は、配列自体または添え字式のいずれかがnullの場合、nullを返します。また、添え字が配列の境界の外にある場合はnullが返されます（この場合、エラーは発生しません）。たとえば、 &lt;code&gt;schedule&lt;/code&gt; のディメンションが &lt;code&gt;[1:3][1:2]&lt;/code&gt; の場合、 &lt;code&gt;schedule[3][3]&lt;/code&gt; するとNULLになります。同様に、添え字の数が間違っている配列参照は、エラーではなくnullになります。</target>
        </trans-unit>
        <trans-unit id="0832096d10a386e248df7b28cfa12adfe25aab94" translate="yes" xml:space="preserve">
          <source>An array value can be replaced completely:</source>
          <target state="translated">配列の値を完全に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="af4fc25fcb8b1fcdab019c9c24576221478e42a1" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes all arguments (including &lt;code&gt;OUT&lt;/code&gt; and &lt;code&gt;INOUT&lt;/code&gt; arguments); however, if all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripting is 1-based, whereas for historical reasons &lt;code&gt;proargtypes&lt;/code&gt; is subscripted from 0.</source>
          <target state="translated">関数の引数のデータ型を含む配列。これには、すべての引数（ &lt;code&gt;OUT&lt;/code&gt; および &lt;code&gt;INOUT&lt;/code&gt; 引数を含む）が含まれます。ただし、すべての引数が &lt;code&gt;IN&lt;/code&gt; 引数の場合、このフィールドはnullになります。添え字は1ベースですが、歴史的な理由から &lt;code&gt;proargtypes&lt;/code&gt; は0から添え字が付けられていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b1056fb2643af14679cc3ecd97ee8851fd6939a7" translate="yes" xml:space="preserve">
          <source>An array with the data types of the function arguments. This includes only input arguments (including &lt;code&gt;INOUT&lt;/code&gt; and &lt;code&gt;VARIADIC&lt;/code&gt; arguments), and thus represents the call signature of the function.</source>
          <target state="translated">関数の引数のデータ型を含む配列。これには入力引数（ &lt;code&gt;INOUT&lt;/code&gt; および &lt;code&gt;VARIADIC&lt;/code&gt; 引数を含む）のみが含まれるため、関数の呼び出しシグネチャを表します。</target>
        </trans-unit>
        <trans-unit id="56e64d796da368f4732fec1eac245d18f34b8c2b" translate="yes" xml:space="preserve">
          <source>An array with the modes of the function arguments, encoded as &lt;code&gt;i&lt;/code&gt; for &lt;code&gt;IN&lt;/code&gt; arguments, &lt;code&gt;o&lt;/code&gt; for &lt;code&gt;OUT&lt;/code&gt; arguments, &lt;code&gt;b&lt;/code&gt; for &lt;code&gt;INOUT&lt;/code&gt; arguments, &lt;code&gt;v&lt;/code&gt; for &lt;code&gt;VARIADIC&lt;/code&gt; arguments, &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;TABLE&lt;/code&gt; arguments. If all the arguments are &lt;code&gt;IN&lt;/code&gt; arguments, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">符号化関数の引数のモードを有する配列、 &lt;code&gt;i&lt;/code&gt; のために &lt;code&gt;IN&lt;/code&gt; の引数、 &lt;code&gt;o&lt;/code&gt; 用 &lt;code&gt;OUT&lt;/code&gt; 引数、 &lt;code&gt;b&lt;/code&gt; 用 &lt;code&gt;INOUT&lt;/code&gt; の引数、 &lt;code&gt;v&lt;/code&gt; 用 &lt;code&gt;VARIADIC&lt;/code&gt; の引数、 &lt;code&gt;t&lt;/code&gt; のための &lt;code&gt;TABLE&lt;/code&gt; 引数。すべての引数が &lt;code&gt;IN&lt;/code&gt; 引数の場合、このフィールドはnullになります。添え字は &lt;code&gt;proallargtypes&lt;/code&gt; なく &lt;code&gt;proargtypes&lt;/code&gt; 位置に対応することに注意してください。</target>
        </trans-unit>
        <trans-unit id="19750404179dcfe4198dc9453208db71584c69d3" translate="yes" xml:space="preserve">
          <source>An array with the names of the function arguments. Arguments without a name are set to empty strings in the array. If none of the arguments have a name, this field will be null. Note that subscripts correspond to positions of &lt;code&gt;proallargtypes&lt;/code&gt; not &lt;code&gt;proargtypes&lt;/code&gt;.</source>
          <target state="translated">関数の引数の名前を含む配列。名前のない引数は、配列内の空の文字列に設定されます。引数に名前がない場合、このフィールドはnullになります。添え字は &lt;code&gt;proallargtypes&lt;/code&gt; なく &lt;code&gt;proargtypes&lt;/code&gt; 位置に対応することに注意してください。</target>
        </trans-unit>
        <trans-unit id="f01a907c7341c3e9fdd4bc077438737e13efc650" translate="yes" xml:space="preserve">
          <source>An asterisk (&lt;code&gt;*&lt;/code&gt;) can be placed at the end of a synonym in the configuration file. This indicates that the synonym is a prefix. The asterisk is ignored when the entry is used in &lt;code&gt;to_tsvector()&lt;/code&gt;, but when it is used in &lt;code&gt;to_tsquery()&lt;/code&gt;, the result will be a query item with the prefix match marker (see &lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;Section 12.3.2&lt;/a&gt;). For example, suppose we have these entries in &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt;:</source>
          <target state="translated">アスタリスク（ &lt;code&gt;*&lt;/code&gt; ）は、構成ファイルの同義語の終わりに置くことができます。これは、シノニムがプレフィックスであることを示しています。アスタリスクは、エントリがで使用されている場合は無視され &lt;code&gt;to_tsvector()&lt;/code&gt; が、それはで使用されている場合 &lt;code&gt;to_tsquery()&lt;/code&gt; 、結果は前方一致マーカー（参照とクエリ項目となります&lt;a href=&quot;textsearch-controls#TEXTSEARCH-PARSING-QUERIES&quot;&gt;12.3.2項を&lt;/a&gt;）。たとえば、 &lt;code&gt;$SHAREDIR/tsearch_data/synonym_sample.syn&lt;/code&gt; 次のエントリがあるとします。</target>
        </trans-unit>
        <trans-unit id="c86af8f966441072cea93666c92eea93103579c8" translate="yes" xml:space="preserve">
          <source>An automatically updatable view may contain a mix of updatable and non-updatable columns. A column is updatable if it is a simple reference to an updatable column of the underlying base relation; otherwise the column is read-only, and an error will be raised if an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; statement attempts to assign a value to it.</source>
          <target state="translated">自動的に更新可能なビューには、更新可能な列と更新不可能な列が混在する場合があります。基になる基本リレーションの更新可能な列への単純な参照である場合、列は更新可能です。そうでない場合、列は読み取り専用であり、 &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; ステートメントが値を割り当てようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e72cb7e6b41938a2b612c62d6738c18d8f8e1034" translate="yes" xml:space="preserve">
          <source>An element with a certain name and data type found within a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuple&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;タプル&lt;/a&gt;内で見つかった特定の名前とデータ型の要素。</target>
        </trans-unit>
        <trans-unit id="13229daa72676e5cc65b4f01d9a20d25d5a2a7d0" translate="yes" xml:space="preserve">
          <source>An encrypted PGP message consists of 2 parts, or &lt;em&gt;packets&lt;/em&gt;:</source>
          <target state="translated">暗号化されたPGPメッセージは2つの部分、つまり&lt;em&gt;パケットで&lt;/em&gt;構成され&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="09f724c84938e490e8dc9343f32211856b8b0d2e" translate="yes" xml:space="preserve">
          <source>An entry given in IPv4 format will match only IPv4 connections, and an entry given in IPv6 format will match only IPv6 connections, even if the represented address is in the IPv4-in-IPv6 range. Note that entries in IPv6 format will be rejected if the system's C library does not have support for IPv6 addresses.</source>
          <target state="translated">IPv4形式で指定されたエントリは、IPv4接続のみにマッチし、IPv6形式で指定されたエントリは、表現されたアドレスがIPv4-in-IPv6の範囲内であっても、IPv6接続のみにマッチします。システムのCライブラリがIPv6アドレスをサポートしていない場合、IPv6形式のエントリは拒否されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="938494e5885c658c095719a63c4ba845fac9421d" translate="yes" xml:space="preserve">
          <source>An entry's &lt;code&gt;amopmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family (including &lt;code&gt;amopmethod&lt;/code&gt; here is an intentional denormalization of the catalog structure for performance reasons). Also, &lt;code&gt;amoplefttype&lt;/code&gt; and &lt;code&gt;amoprighttype&lt;/code&gt; must match the &lt;code&gt;oprleft&lt;/code&gt; and &lt;code&gt;oprright&lt;/code&gt; fields of the referenced &lt;code&gt;pg_operator&lt;/code&gt; entry.</source>
          <target state="translated">エントリの &lt;code&gt;amopmethod&lt;/code&gt; は、それを含む演算子ファミリの &lt;code&gt;opfmethod&lt;/code&gt; と一致する必要があります（ここでの &lt;code&gt;amopmethod&lt;/code&gt; は、パフォーマンス上の理由から、カタログ構造の意図的な非正規化です）。また、 &lt;code&gt;amoplefttype&lt;/code&gt; と &lt;code&gt;amoprighttype&lt;/code&gt; は、参照される &lt;code&gt;pg_operator&lt;/code&gt; エントリの &lt;code&gt;oprleft&lt;/code&gt; および &lt;code&gt;oprright&lt;/code&gt; フィールドと一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="d1d1086ba8d92dc57d5ff412fcf067dd0fa10959" translate="yes" xml:space="preserve">
          <source>An enum value occupies four bytes on disk. The length of an enum value's textual label is limited by the &lt;code&gt;NAMEDATALEN&lt;/code&gt; setting compiled into PostgreSQL; in standard builds this means at most 63 bytes.</source>
          <target state="translated">列挙値はディスク上で4バイトを占有します。列挙値のテキストラベルの長さは、PostgreSQLにコンパイルされた &lt;code&gt;NAMEDATALEN&lt;/code&gt; 設定によって制限されます。標準ビルドでは、これは最大63バイトを意味します。</target>
        </trans-unit>
        <trans-unit id="7d926b20cea28dde9ab53148cbd01bb72e3b71c1" translate="yes" xml:space="preserve">
          <source>An error like:</source>
          <target state="translated">のようなエラー。</target>
        </trans-unit>
        <trans-unit id="1642e5d8f757211902e7fce377a379427b2967a5" translate="yes" xml:space="preserve">
          <source>An established line of communication between a client process and a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt; process, usually over a network, supporting a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt;. This term is sometimes used as a synonym for session.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;セッションを&lt;/a&gt;サポートする、通常はネットワークを介した、クライアントプロセスと&lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;バックエンド&lt;/a&gt;プロセス間の確立された通信回線。この用語は、セッションの同義語として使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="73f7ed75cabe931d593b5e23922ed970c7f9a2c6" translate="yes" xml:space="preserve">
          <source>An event trigger function is declared to return &lt;code&gt;event_trigger.&lt;/code&gt;</source>
          <target state="translated">イベントトリガー関数は、 &lt;code&gt;event_trigger.&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="e5d03b1b3e9330df5ef72cedfa521226e3904563" translate="yes" xml:space="preserve">
          <source>An example command to insert a row would be:</source>
          <target state="translated">行を挿入するコマンドの例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d3e47d13cc2aa85cb2cac79171bd5ba58c06a033" translate="yes" xml:space="preserve">
          <source>An example implementation of my_options() and parameters use from other support functions are given below:</source>
          <target state="translated">my_options()の実装例と、他のサポート関数からのパラメータの使用例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="77db1d337bb2340f6b1a45dac50171d5552245cf" translate="yes" xml:space="preserve">
          <source>An example is:</source>
          <target state="translated">例を挙げると</target>
        </trans-unit>
        <trans-unit id="ab2ae23169c6ecf2d8724ae3dd48f5aec7d41be5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a priority-based multiple synchronous standbys is:</source>
          <target state="translated">優先順位ベースの複数の同期スタンバイの &lt;code&gt;synchronous_standby_names&lt;/code&gt; の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a98fc82d0f241f92e10ef779f12a66f98cdb0af5" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;synchronous_standby_names&lt;/code&gt; for a quorum-based multiple synchronous standbys is:</source>
          <target state="translated">クォーラムベースの複数の同期スタンバイの &lt;code&gt;synchronous_standby_names&lt;/code&gt; の例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dd7d7ba1d423d1278de206e487f072bf081d0594" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are rows in the table that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER TABLE&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against all table rows.</source>
          <target state="translated">この仮定を破る一般的な方法の例は、 &lt;code&gt;CHECK&lt;/code&gt; 式でユーザー定義関数を参照してから、その関数の動作を変更することです。 PostgreSQLはこれを許可しませんが、テーブルに行が &lt;code&gt;CHECK&lt;/code&gt; 制約に違反しているかどうかはわかりません。これにより、後続のデータベースのダンプとリロードが失敗します。このような変更を処理するための推奨される方法は、（ &lt;code&gt;ALTER TABLE&lt;/code&gt; を使用して）制約を削除し、関数定義を調整し、制約を再度追加して、すべてのテーブル行に対して制約を再チェックすることです。</target>
        </trans-unit>
        <trans-unit id="0fc2dcac68631535509b1c9851983c8f16591ded" translate="yes" xml:space="preserve">
          <source>An example of a common way to break this assumption is to reference a user-defined function in a &lt;code&gt;CHECK&lt;/code&gt; expression, and then change the behavior of that function. PostgreSQL does not disallow that, but it will not notice if there are stored values of the domain type that now violate the &lt;code&gt;CHECK&lt;/code&gt; constraint. That would cause a subsequent database dump and reload to fail. The recommended way to handle such a change is to drop the constraint (using &lt;code&gt;ALTER DOMAIN&lt;/code&gt;), adjust the function definition, and re-add the constraint, thereby rechecking it against stored data.</source>
          <target state="translated">この仮定を破る一般的な方法の例は、 &lt;code&gt;CHECK&lt;/code&gt; 式でユーザー定義関数を参照してから、その関数の動作を変更することです。 PostgreSQLはこれを禁止していませんが、 &lt;code&gt;CHECK&lt;/code&gt; 制約に違反しているドメインタイプの格納された値があるかどうかは通知しません。これにより、後続のデータベースのダンプとリロードが失敗します。このような変更を処理するための推奨される方法は、（ &lt;code&gt;ALTER DOMAIN&lt;/code&gt; を使用して）制約を削除し、関数定義を調整し、制約を再度追加して、格納されたデータに対して制約を再チェックすることです。</target>
        </trans-unit>
        <trans-unit id="f4d8042a8aacf4dd946a6de3a479fedbae68b9bb" translate="yes" xml:space="preserve">
          <source>An example of an ordered-set aggregate call is:</source>
          <target state="translated">順序付き集合集合の呼び出しの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9b9fd9076643bacdf456e68d66e8b722bd4cc414" translate="yes" xml:space="preserve">
          <source>An example of the problem situation is an administrator on the primary server running &lt;code&gt;DROP TABLE&lt;/code&gt; on a table that is currently being queried on the standby server. Clearly the standby query cannot continue if the &lt;code&gt;DROP TABLE&lt;/code&gt; is applied on the standby. If this situation occurred on the primary, the &lt;code&gt;DROP TABLE&lt;/code&gt; would wait until the other query had finished. But when &lt;code&gt;DROP TABLE&lt;/code&gt; is run on the primary, the primary doesn't have information about what queries are running on the standby, so it will not wait for any such standby queries. The WAL change records come through to the standby while the standby query is still running, causing a conflict. The standby server must either delay application of the WAL records (and everything after them, too) or else cancel the conflicting query so that the &lt;code&gt;DROP TABLE&lt;/code&gt; can be applied.</source>
          <target state="translated">問題の状況の例は、スタンバイサーバーで現在照会されているテーブルで &lt;code&gt;DROP TABLE&lt;/code&gt; を実行しているプラ​​イマリサーバーの管理者です。 &lt;code&gt;DROP TABLE&lt;/code&gt; がスタンバイに適用されている場合、明らかにスタンバイクエリを続行できません。この状況がプライマリで発生した場合、 &lt;code&gt;DROP TABLE&lt;/code&gt; は他のクエリが完了するまで待機します。しかし、 &lt;code&gt;DROP TABLE&lt;/code&gt; プライマリで実行されている場合、プライマリにはスタンバイで実行されているクエリに関する情報がないため、そのようなスタンバイクエリを待機しません。スタンバイクエリの実行中にWAL変更レコードがスタンバイに到達し、競合が発生します。スタンバイサーバーは、WALレコード（およびその後のすべて）の適用を遅らせるか、 &lt;code&gt;DROP TABLE&lt;/code&gt; を適用できるように競合するクエリをキャンセルする必要があります。</target>
        </trans-unit>
        <trans-unit id="c0584ea6554a34671913f19351974da1f1774aa3" translate="yes" xml:space="preserve">
          <source>An example of what this means:</source>
          <target state="translated">これが何を意味するかの一例。</target>
        </trans-unit>
        <trans-unit id="24ac5f040ccbfd7714847e1bf2aa5f6494899ae9" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;NOT MATERIALIZED&lt;/code&gt; could be undesirable is</source>
          <target state="translated">&lt;code&gt;NOT MATERIALIZED&lt;/code&gt; が望ましくない可能性がある例</target>
        </trans-unit>
        <trans-unit id="17447c2100c81f31ba62252077dc9a9361cd71f9" translate="yes" xml:space="preserve">
          <source>An example with one unspecified argument:</source>
          <target state="translated">不特定多数の引数を持つ例。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="79f0ca45e1236a1cb1c9feb4290eadf0487b4ef6" translate="yes" xml:space="preserve">
          <source>An exception is that if the command was terminated by a signal (other than SIGTERM, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up.</source>
          <target state="translated">例外として、シグナル(データベースサーバのシャットダウンの一部として使用されるSIGTERM以外のコマンド)やシェルによるエラー(コマンドが見つからないなど)によってコマンドが終了した場合、リカバリーが中止され、サーバは起動しません。</target>
        </trans-unit>
        <trans-unit id="fcd7932740e5471bcd0a087d5b26ec1edd628fbb" translate="yes" xml:space="preserve">
          <source>An explicit attribute name need not be specified if the attribute value is a column reference, in which case the column's name will be used as the attribute name by default. In other cases, the attribute must be given an explicit name. So this example is valid:</source>
          <target state="translated">属性値が列の参照である場合には、明示的な属性名を指定する必要はありません。それ以外の場合は、属性に明示的な名前を指定しなければなりません。したがって、この例は有効です。</target>
        </trans-unit>
        <trans-unit id="a0537d02ca5df21a5cff0228c3c1f8c6cfa4f59b" translate="yes" xml:space="preserve">
          <source>An explicit type cast can usually be omitted if there is no ambiguity as to the type that a value expression must produce (for example, when it is assigned to a table column); the system will automatically apply a type cast in such cases. However, automatic casting is only done for casts that are marked &amp;ldquo;OK to apply implicitly&amp;rdquo; in the system catalogs. Other casts must be invoked with explicit casting syntax. This restriction is intended to prevent surprising conversions from being applied silently.</source>
          <target state="translated">値式が生成しなければならない型についてあいまいさがなければ（たとえば、それがテーブル列に割り当てられている場合）、明示的な型キャストは通常​​省略できます。このような場合、システムは自動的に型キャストを適用します。ただし、自動キャストは、システムカタログで「暗黙的に適用してよい」とマークされているキャストに対してのみ実行されます。その他のキャストは、明示的なキャスト構文で呼び出す必要があります。この制限は、意外な変換がサイレントに適用されるのを防ぐためのものです。</target>
        </trans-unit>
        <trans-unit id="8eb162f28e2597cd06bef15cc6b421aa23ae9738" translate="yes" xml:space="preserve">
          <source>An expression based on one or more columns of the table. The expression usually must be written with surrounding parentheses, as shown in the syntax. However, the parentheses can be omitted if the expression has the form of a function call.</source>
          <target state="translated">テーブルの1つ以上の列に基づく式。式は通常、構文に示されているように、周囲の括弧で書かれなければなりません。しかし、式が関数呼び出しの形をしている場合は、括弧を省略することができます。</target>
        </trans-unit>
        <trans-unit id="dfb3ba678ed8043b837cdccde74a8dfa30c47a0d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">結果の行をソートする方法を示す式または整数定数。この式は、 &lt;code&gt;VALUES&lt;/code&gt; 結果の列を &lt;code&gt;column1&lt;/code&gt; 、 &lt;code&gt;column2&lt;/code&gt; などとして参照できます。詳細については、&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b2f105d127b4d4c78a65c31c4341d9a688ca047d" translate="yes" xml:space="preserve">
          <source>An expression or integer constant indicating how to sort the result rows. This expression can refer to the columns of the &lt;code&gt;VALUES&lt;/code&gt; result as &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc. For more details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">結果の行をソートする方法を示す式または整数定数。この式は、 &lt;code&gt;VALUES&lt;/code&gt; 結果の列を &lt;code&gt;column1&lt;/code&gt; 、 &lt;code&gt;column2&lt;/code&gt; などとして参照できます。詳細については、&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;ドキュメントの&lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDERBY句を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bf2a060cd8aff34f17e0e2630c016f3f2cecf035" translate="yes" xml:space="preserve">
          <source>An expression or value to assign to the corresponding column.</source>
          <target state="translated">対応する列に割り当てる式または値。</target>
        </trans-unit>
        <trans-unit id="346258a0cd22cd6472088d2210ee4c5f296cc7a7" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be deleted.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型の値を返す式。この式が &lt;code&gt;true&lt;/code&gt; を返す行のみが削除されます。</target>
        </trans-unit>
        <trans-unit id="3b5a1cfe641c92cec7cffaf0f485f58266a8e8c9" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated, although all rows will be locked when the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; action is taken. Note that &lt;code&gt;condition&lt;/code&gt; is evaluated last, after a conflict has been identified as a candidate to update.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型の値を返す式。 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; アクションが実行されるとすべての行がロックされますが、この式が &lt;code&gt;true&lt;/code&gt; を返す行のみが更新されます。更新の候補として競合が特定された後、 &lt;code&gt;condition&lt;/code&gt; が最後に評価されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="51d351d5b4985c09126cf102d05f81d64ae9d961" translate="yes" xml:space="preserve">
          <source>An expression that returns a value of type &lt;code&gt;boolean&lt;/code&gt;. Only rows for which this expression returns &lt;code&gt;true&lt;/code&gt; will be updated.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; 型の値を返す式。この式が &lt;code&gt;true&lt;/code&gt; を返す行のみが更新されます。</target>
        </trans-unit>
        <trans-unit id="6469ea06c0d7a0f1185226a5a8416487a9a270db" translate="yes" xml:space="preserve">
          <source>An expression to assign to the column. The expression can use the old values of this and other columns in the table.</source>
          <target state="translated">カラムに代入する式。この式は、テーブル内のこのカラムと他のカラムの古い値を使用することができます。</target>
        </trans-unit>
        <trans-unit id="8157c1c94fdd707dcc3e7f541c66bda5c99059b6" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;DELETE&lt;/code&gt; command after each row is deleted. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;USING&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">各行が削除された後に &lt;code&gt;DELETE&lt;/code&gt; コマンドによって計算および返される式。式では、 &lt;code&gt;table_name&lt;/code&gt; または &lt;code&gt;USING&lt;/code&gt; にリストされたテーブルで指定されたテーブルの任意の列名を使用できます。 &lt;code&gt;*&lt;/code&gt; を書き込むと、すべての列が返されます。</target>
        </trans-unit>
        <trans-unit id="05948f44935d2d1795c3b150edf4c95d54d4a6f0" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;INSERT&lt;/code&gt; command after each row is inserted or updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns of the inserted or updated row(s).</source>
          <target state="translated">各行が挿入または更新された後に &lt;code&gt;INSERT&lt;/code&gt; コマンドによって計算および返される式。式では、 &lt;code&gt;table_name&lt;/code&gt; で指定されたテーブルの任意の列名を使用できます。挿入または更新された行のすべての列を返すには、 &lt;code&gt;*&lt;/code&gt; を書き込みます。</target>
        </trans-unit>
        <trans-unit id="711a38c8f40969b059c836aa598a46d28bd6408a" translate="yes" xml:space="preserve">
          <source>An expression to be computed and returned by the &lt;code&gt;UPDATE&lt;/code&gt; command after each row is updated. The expression can use any column names of the table named by &lt;code&gt;table_name&lt;/code&gt; or table(s) listed in &lt;code&gt;FROM&lt;/code&gt;. Write &lt;code&gt;*&lt;/code&gt; to return all columns.</source>
          <target state="translated">各行が更新された後に &lt;code&gt;UPDATE&lt;/code&gt; コマンドによって計算および返される式。式では、 &lt;code&gt;table_name&lt;/code&gt; または &lt;code&gt;FROM&lt;/code&gt; にリストされたテーブルで指定されたテーブルの任意の列名を使用できます。 &lt;code&gt;*&lt;/code&gt; を書き込むと、すべての列が返されます。</target>
        </trans-unit>
        <trans-unit id="1a2196f96cc62fad9b61f7b17e09f3003661a8d1" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">パラメータが指定されていない場合にデフォルト値として使用される式。この式は、パラメータの引数タイプに対応していなければなりません。デフォルト値を持つパラメータに続くすべての入力パラメータは、同様にデフォルト値を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="33129ed19c1151cbd1e641d74c28498304306825" translate="yes" xml:space="preserve">
          <source>An expression to be used as default value if the parameter is not specified. The expression has to be coercible to the argument type of the parameter. Only input (including &lt;code&gt;INOUT&lt;/code&gt;) parameters can have a default value. All input parameters following a parameter with a default value must have default values as well.</source>
          <target state="translated">パラメータが指定されていない場合にデフォルト値として使用される式。式は、パラメーターの引数の型に強制変換できる必要があります。入力（ &lt;code&gt;INOUT&lt;/code&gt; を含む）パラメータのみがデフォルト値を持つことができます。デフォルト値を持つパラメーターに続くすべての入力パラメーターには、デフォルト値も必要です。</target>
        </trans-unit>
        <trans-unit id="e3cc897e9290dc3056730f190eeba85a57f89dca" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.26&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">外部プログラムは &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 関数（&lt;a href=&quot;functions-admin&quot;&gt;セクション9.26を&lt;/a&gt;参照）を呼び出して、WALの現在の終わりのファイル名とその中の正確なバイトオフセットを見つけることができます。次に、WALファイルに直接アクセスし、WALの最後の既知の端から現在の端を経由してスタンバイサーバーにデータをコピーできます。このアプローチでは、データ損失のウィンドウはコピープログラムのポーリングサイクルタイムであり、非常に小さくなり、部分的に使用されているセグメントファイルを強制的にアーカイブすることによる帯域幅の浪費がありません。スタンバイサーバーの &lt;code&gt;restore_command&lt;/code&gt; スクリプトはWALファイル全体のみを処理できるため、通常、増分コピーされたデータはスタンバイサーバーで利用できません。これは、プライマリが停止したときにのみ使用できます。最後の部分的なWALファイルは、起動する前にスタンバイに送られます。このプロセスを正しく実装するには、 &lt;code&gt;restore_command&lt;/code&gt; スクリプトとデータコピープログラムの連携が必要です。</target>
        </trans-unit>
        <trans-unit id="e349b01fb7be05aa32f87d20348ac32cf9165b0a" translate="yes" xml:space="preserve">
          <source>An external program can call the &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; function (see &lt;a href=&quot;functions-admin&quot;&gt;Section 9.27&lt;/a&gt;) to find out the file name and the exact byte offset within it of the current end of WAL. It can then access the WAL file directly and copy the data from the last known end of WAL through the current end over to the standby servers. With this approach, the window for data loss is the polling cycle time of the copying program, which can be very small, and there is no wasted bandwidth from forcing partially-used segment files to be archived. Note that the standby servers' &lt;code&gt;restore_command&lt;/code&gt; scripts can only deal with whole WAL files, so the incrementally copied data is not ordinarily made available to the standby servers. It is of use only when the primary dies &amp;mdash; then the last partial WAL file is fed to the standby before allowing it to come up. The correct implementation of this process requires cooperation of the &lt;code&gt;restore_command&lt;/code&gt; script with the data copying program.</source>
          <target state="translated">外部プログラムは、 &lt;code&gt;pg_walfile_name_offset()&lt;/code&gt; 関数（&lt;a href=&quot;functions-admin&quot;&gt;セクション9.27を&lt;/a&gt;参照）を呼び出して、WALの現在の終わりのファイル名とその中の正確なバイトオフセットを見つけることができます。次に、WALファイルに直接アクセスし、WALの最後の既知の端から現在の端を介してスタンバイサーバーにデータをコピーできます。このアプローチでは、データ損失のウィンドウはコピープログラムのポーリングサイクルタイムであり、これは非常に小さい可能性があり、部分的に使用されたセグメントファイルをアーカイブすることによる無駄な帯域幅はありません。スタンバイサーバーの &lt;code&gt;restore_command&lt;/code&gt; に注意してくださいスクリプトはWALファイル全体のみを処理できるため、通常、増分コピーされたデータはスタンバイサーバーで使用できません。これは、プライマリが停止した場合にのみ使用されます。その後、最後の部分的なWALファイルがスタンバイに送られ、その後起動します。このプロセスを正しく実装するには、 &lt;code&gt;restore_command&lt;/code&gt; スクリプトとデータコピープログラムの協力が必要です。</target>
        </trans-unit>
        <trans-unit id="94b6e6917365cf5b071c6d2030b18320b138edde" translate="yes" xml:space="preserve">
          <source>An immediate-mode shutdown is equivalent to a server crash, and will therefore cause loss of any unflushed asynchronous commits.</source>
          <target state="translated">即時モードでのシャットダウンはサーバのクラッシュと同等であり、そのため、アンフラッシュされていない非同期コミットはすべて失われます。</target>
        </trans-unit>
        <trans-unit id="40eea77fc7125e69a1e10d852d75c5913c0b8a4f" translate="yes" xml:space="preserve">
          <source>An important advantage of pg_dump over the other backup methods described later is that pg_dump's output can generally be re-loaded into newer versions of PostgreSQL, whereas file-level backups and continuous archiving are both extremely server-version-specific. pg_dump is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server.</source>
          <target state="translated">pg_dumpが後述する他のバックアップ方法と比較して重要な利点は、pg_dumpの出力が一般的にPostgreSQLの新しいバージョンに再ロードできることです。</target>
        </trans-unit>
        <trans-unit id="779e5fbc91351efe2bbe3fc71a519dfce1b2cb29" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.84&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.85&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">ストリーミングレプリケーションの重要なヘルスインジケータは、プライマリで生成されたがスタンバイではまだ適用されていないWALレコードの量です。このラグを計算するには、プライマリの現在のWAL書き込み位置を、スタンバイが受信した最後のWAL位置と比較します。これらの場所は、それぞれプライマリの &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; とスタンバイの &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; を使用して取得できます（詳細については、&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.84&lt;/a&gt;と&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.85&lt;/a&gt;を参照してください）。スタンバイの最後のWAL受信場所は、 &lt;code&gt;ps&lt;/code&gt; コマンドを使用して表示されるWALレシーバープロセスのプロセスステータスにも表示されます（詳細については、&lt;a href=&quot;monitoring-ps&quot;&gt;セクション27.1&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="5e354ee44c574fe1a74c62c071de207a2e99bd9d" translate="yes" xml:space="preserve">
          <source>An important health indicator of streaming replication is the amount of WAL records generated in the primary, but not yet applied in the standby. You can calculate this lag by comparing the current WAL write location on the primary with the last WAL location received by the standby. These locations can be retrieved using &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; on the primary and &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; on the standby, respectively (see &lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;Table 9.85&lt;/a&gt; and &lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;Table 9.86&lt;/a&gt; for details). The last WAL receive location in the standby is also displayed in the process status of the WAL receiver process, displayed using the &lt;code&gt;ps&lt;/code&gt; command (see &lt;a href=&quot;monitoring-ps&quot;&gt;Section 27.1&lt;/a&gt; for details).</source>
          <target state="translated">ストリーミングレプリケーションの重要なヘルスインジケータは、プライマリで生成されたが、スタンバイではまだ適用されていないWALレコードの量です。このラグは、プライマリの現在のWAL書き込み場所を、スタンバイが受信した最後のWAL場所と比較することで計算できます。これらの場所は、プライマリで &lt;code&gt;pg_current_wal_lsn&lt;/code&gt; を使用し、スタンバイで &lt;code&gt;pg_last_wal_receive_lsn&lt;/code&gt; を使用してそれぞれ取得できます（詳細については、&lt;a href=&quot;functions-admin#FUNCTIONS-ADMIN-BACKUP-TABLE&quot;&gt;表9.85&lt;/a&gt;および&lt;a href=&quot;functions-admin#FUNCTIONS-RECOVERY-INFO-TABLE&quot;&gt;表9.86&lt;/a&gt;を参照してください）。スタンバイ内の最後のWAL受信場所は、 &lt;code&gt;ps&lt;/code&gt; コマンドを使用して表示されるWAL受信プロセスのプロセスステータスにも表示されます（詳細については、&lt;a href=&quot;monitoring-ps&quot;&gt;セクション27.1&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="8738ccf906ae7704aa616ed666eef87dd66384c2" translate="yes" xml:space="preserve">
          <source>An important restriction, however, is that each database's character set must be compatible with the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; (character classification) and &lt;code&gt;LC_COLLATE&lt;/code&gt; (string sort order) locale settings. For &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;POSIX&lt;/code&gt; locale, any character set is allowed, but for other libc-provided locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.) If you have ICU support configured, ICU-provided locales can be used with most but not all server-side encodings.</source>
          <target state="translated">ただし、重要な制限は、各データベースの文字セットがデータベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; （文字分類）および &lt;code&gt;LC_COLLATE&lt;/code&gt; （文字列のソート順）ロケール設定と互換性がある必要があることです。以下のために &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;POSIX&lt;/code&gt; ロケール、任意の文字セットが許可されていますが、他のlibcが提供するロケールで正常に動作する唯一の文字セットがあります。 （ただし、Windowsでは、UTF-8エンコーディングを任意のロケールで使用できます。）ICUサポートが構成されている場合、ICU提供のロケールを、すべてではなくほとんどのサーバー側エンコーディングで使用できます。</target>
        </trans-unit>
        <trans-unit id="0f5ae435c6587408d50bbebe9d66abc0ceb67394" translate="yes" xml:space="preserve">
          <source>An index access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;index_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a palloc'd struct of type &lt;code&gt;IndexAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the index access method. The &lt;code&gt;IndexAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, includes fields specifying assorted fixed properties of the access method, such as whether it can support multicolumn indexes. More importantly, it contains pointers to support functions for the access method, which do all of the real work to access indexes. These support functions are plain C functions and are not visible or callable at the SQL level. The support functions are described in &lt;a href=&quot;index-functions&quot;&gt;Section 61.2&lt;/a&gt;.</source>
          <target state="translated">インデックスアクセスメソッドハンドラー関数は、 &lt;code&gt;internal&lt;/code&gt; タイプの単一の引数を受け入れ、疑似タイプ &lt;code&gt;index_am_handler&lt;/code&gt; を返すように宣言する必要があります。引数は、ハンドラー関数がSQLコマンドから直接呼び出されないようにするためのダミー値です。関数の結果は、タイプのpallocさ、構造体でなければなりません &lt;code&gt;IndexAmRoutine&lt;/code&gt; コアコードのニーズはインデックスアクセスメソッドを利用するために知っていることすべてが含まれ、。 &lt;code&gt;IndexAmRoutine&lt;/code&gt; の構造体、また、アクセス方法のと呼ばれる&lt;em&gt;APIの構造体&lt;/em&gt;には、複数列のインデックスをサポートできるかどうかなど、アクセス方法のさまざまな固定プロパティを指定するフィールドが含まれています。さらに重要なことに、インデックスにアクセスするための実際の作業をすべて実行する、アクセスメソッドのサポート関数へのポインターが含まれています。これらのサポート関数はプレーンなC関数であり、SQLレベルでは表示または呼び出しできません。サポート関数については、&lt;a href=&quot;index-functions&quot;&gt;セクション61.2で&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="bb532d7978fa5df32b453f561220dfbe06086e40" translate="yes" xml:space="preserve">
          <source>An index access method handler is declared to return &lt;code&gt;index_am_handler&lt;/code&gt;.</source>
          <target state="translated">インデックスアクセスメソッドハンドラーは、 &lt;code&gt;index_am_handler&lt;/code&gt; を返すように宣言されています。</target>
        </trans-unit>
        <trans-unit id="7b07d3910aeda52b29f538101381247d79d370d4" translate="yes" xml:space="preserve">
          <source>An index can be defined on more than one column of a table. For example, if you have a table of this form:</source>
          <target state="translated">インデックスは、テーブルの複数の列に定義することができます。例えば、このような形式のテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="c6cedebd8f5962a85979ac8b01f76ed8117fa855" translate="yes" xml:space="preserve">
          <source>An index can support only one collation per index column. If multiple collations are of interest, multiple indexes may be needed.</source>
          <target state="translated">1つのインデックスは、インデックス列ごとに1つの照合順序しかサポートできません。複数の照合が注目される場合は、複数のインデックスが必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="af32b6cb0c87ebb15770ca088fe87a22f82c7725" translate="yes" xml:space="preserve">
          <source>An index column need not be just a column of the underlying table, but can be a function or scalar expression computed from one or more columns of the table. This feature is useful to obtain fast access to tables based on the results of computations.</source>
          <target state="translated">インデックス列は、基になるテーブルの列だけである必要はなく、テーブルの1つ以上の列から計算された関数やスカラー式であっても構いません。この機能は、計算結果に基づいてテーブルへの高速なアクセスを得るのに便利です。</target>
        </trans-unit>
        <trans-unit id="38f15f32a54b60a4d97bf16f8c60ceef26c5914e" translate="yes" xml:space="preserve">
          <source>An index definition can specify an &lt;em&gt;operator class&lt;/em&gt; for each column of an index.</source>
          <target state="translated">インデックス定義では、インデックスの列ごとに&lt;em&gt;演算子クラス&lt;/em&gt;を指定できます。</target>
        </trans-unit>
        <trans-unit id="0ef2323f17ff30aac9494d8039a3c3612271c42a" translate="yes" xml:space="preserve">
          <source>An index field can be an expression computed from the values of one or more columns of the table row. This feature can be used to obtain fast access to data based on some transformation of the basic data. For example, an index computed on &lt;code&gt;upper(col)&lt;/code&gt; would allow the clause &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; to use an index.</source>
          <target state="translated">インデックスフィールドは、テーブル行の1つ以上の列の値から計算された式にすることができます。この機能を使用すると、基本データの変換に基づいて、データに高速にアクセスできます。たとえば、 &lt;code&gt;upper(col)&lt;/code&gt; で計算されたインデックスでは、 &lt;code&gt;WHERE upper(col) = 'JIM'&lt;/code&gt; 句でインデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="3aeae44b3c790fd037b93e2535adf3aedad79c0a" translate="yes" xml:space="preserve">
          <source>An index has become &amp;ldquo;bloated&amp;rdquo;, that is it contains many empty or nearly-empty pages. This can occur with B-tree indexes in PostgreSQL under certain uncommon access patterns. &lt;code&gt;REINDEX&lt;/code&gt; provides a way to reduce the space consumption of the index by writing a new version of the index without the dead pages. See &lt;a href=&quot;routine-reindex&quot;&gt;Section 24.2&lt;/a&gt; for more information.</source>
          <target state="translated">インデックスが「肥大化」している、つまり、空のページまたは空に近いページが多数含まれている。これは、特定の一般的でないアクセスパターンの下で、PostgreSQLのBツリーインデックスで発生する可能性があります。 &lt;code&gt;REINDEX&lt;/code&gt; は、デッドページのない新しいバージョンのインデックスを書き込むことにより、インデックスのスペース消費を削減する方法を提供します。詳細は&lt;a href=&quot;routine-reindex&quot;&gt;項24.2&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="121b8423d6baa50b53be4c3d49a8a3b7e064ae7d" translate="yes" xml:space="preserve">
          <source>An index has become corrupted, and no longer contains valid data. Although in theory this should never happen, in practice indexes can become corrupted due to software bugs or hardware failures. &lt;code&gt;REINDEX&lt;/code&gt; provides a recovery method.</source>
          <target state="translated">インデックスが破損し、有効なデータが含まれなくなりました。理論的にはこれが発生することはありませんが、実際には、ソフトウェアのバグやハードウェアの障害によりインデックスが破損する可能性があります。 &lt;code&gt;REINDEX&lt;/code&gt; は回復方法を提供します。</target>
        </trans-unit>
        <trans-unit id="fd114c1d6538ba92c251db5881779687c2ba09a7" translate="yes" xml:space="preserve">
          <source>An index scan must maintain a pin on the index page holding the item last returned by &lt;code&gt;amgettuple&lt;/code&gt;, and &lt;code&gt;ambulkdelete&lt;/code&gt; cannot delete entries from pages that are pinned by other backends. The need for this rule is explained below.</source>
          <target state="translated">インデックス・スキャンは、最後から返されたアイテム保持インデックスページ上のピンを維持しなければならない &lt;code&gt;amgettuple&lt;/code&gt; 、と &lt;code&gt;ambulkdelete&lt;/code&gt; 他のバックエンドで固定されているページから缶削除しないエントリー。このルールの必要性については、以下で説明します。</target>
        </trans-unit>
        <trans-unit id="091f10c301d94d87ecd9a27b3366c6d6b064df7e" translate="yes" xml:space="preserve">
          <source>An index stored in ascending order with nulls first can satisfy either &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; or &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; depending on which direction it is scanned in.</source>
          <target state="translated">最初にnullの昇順で格納されたインデックスは、スキャンされる方向に応じて、 &lt;code&gt;ORDER BY x ASC NULLS FIRST&lt;/code&gt; または &lt;code&gt;ORDER BY x DESC NULLS LAST&lt;/code&gt; のいずれかを満たすことができます。</target>
        </trans-unit>
        <trans-unit id="4b9a05a65dbb6edc07d784a35f9d93afabbd7c69" translate="yes" xml:space="preserve">
          <source>An individual index is defined by a &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt; entry that describes it as a physical relation, plus a &lt;a href=&quot;catalog-pg-index&quot;&gt;&lt;code&gt;pg_index&lt;/code&gt;&lt;/a&gt; entry that shows the logical content of the index &amp;mdash; that is, the set of index columns it has and the semantics of those columns, as captured by the associated operator classes. The index columns (key values) can be either simple columns of the underlying table or expressions over the table rows. The index access method normally has no interest in where the index key values come from (it is always handed precomputed key values) but it will be very interested in the operator class information in &lt;code&gt;pg_index&lt;/code&gt;. Both of these catalog entries can be accessed as part of the &lt;code&gt;Relation&lt;/code&gt; data structure that is passed to all operations on the index.</source>
          <target state="translated">個々のインデックスは、それを物理的な関係として説明する&lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt;エントリと、インデックスの論理的な内容を示す&lt;a href=&quot;catalog-pg-index&quot;&gt; &lt;code&gt;pg_index&lt;/code&gt; &lt;/a&gt;エントリによって定義されます。つまり、インデックスが持つ一連のインデックス列と、関連する演算子クラス。インデックス列（キー値）は、基になるテーブルの単純な列、またはテーブル行の式のいずれかです。インデックスアクセスメソッドは通常、インデックスキー値がどこから来るか（常に事前計算されたキー値が渡されます）には関係ありませんが、 &lt;code&gt;pg_index&lt;/code&gt; の演算子クラス情報に非常に興味があります。これらのカタログエントリの両方に、 &lt;code&gt;Relation&lt;/code&gt; 一部としてアクセスできます。 インデックスのすべての操作に渡されるデータ構造。</target>
        </trans-unit>
        <trans-unit id="c51c50438ea0481d3519a43885b20aa32e128cb3" translate="yes" xml:space="preserve">
          <source>An input argument for the procedure call. See &lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;Section 4.3&lt;/a&gt; for the full details on function and procedure call syntax, including use of named parameters.</source>
          <target state="translated">プロシージャコールの入力引数。参照&lt;a href=&quot;sql-syntax-calling-funcs&quot;&gt;セクション4.3を&lt;/a&gt;名前付きパラメータの使用を含む関数とプロシージャの呼び出し構文、上の完全な詳細については。</target>
        </trans-unit>
        <trans-unit id="73ddb8fe436cada6d2cfbe35b934979d06f7b361" translate="yes" xml:space="preserve">
          <source>An input data type on which the aggregate function operates. To reference a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. To reference an ordered-set aggregate function, write &lt;code&gt;ORDER BY&lt;/code&gt; between the direct and aggregated argument specifications.</source>
          <target state="translated">集計関数が動作する入力データ型。引数なしの集約関数を参照するには、引数指定のリストの代わりに &lt;code&gt;*&lt;/code&gt; を記述します。順序付き集合関数を参照するには、直接引数と集約引数の指定の間に &lt;code&gt;ORDER BY&lt;/code&gt; を記述します。</target>
        </trans-unit>
        <trans-unit id="8a9fa698ac8ae654cf211647b74f7c8723ee0347" translate="yes" xml:space="preserve">
          <source>An input data type on which this aggregate function operates. To create a zero-argument aggregate function, write &lt;code&gt;*&lt;/code&gt; in place of the list of argument specifications. (An example of such an aggregate is &lt;code&gt;count(*)&lt;/code&gt;.)</source>
          <target state="translated">この集約関数が動作する入力データ型。引数なしの集約関数を作成するには、引数指定のリストの代わりに &lt;code&gt;*&lt;/code&gt; を記述します。（そのような集計の例は &lt;code&gt;count(*)&lt;/code&gt; です。）</target>
        </trans-unit>
        <trans-unit id="2c437a292efa6b573c836047b51a1cf9f32df694" translate="yes" xml:space="preserve">
          <source>An introduction to the btree index implementation can be found in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt;.</source>
          <target state="translated">btreeインデックス実装の &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; はsrc / backend / access / nbtree / READMEにあります。</target>
        </trans-unit>
        <trans-unit id="43d220b2360555baed12a7c95e72685b6f39b9dd" translate="yes" xml:space="preserve">
          <source>An n-dimensional cube represented by a pair of its diagonally opposite corners</source>
          <target state="translated">対角線上の対角線の対で表されるn次元立方体</target>
        </trans-unit>
        <trans-unit id="49b0e219e8853ca29533ecae37f9efd990522911" translate="yes" xml:space="preserve">
          <source>An object can be assigned to a new owner with an &lt;code&gt;ALTER&lt;/code&gt; command of the appropriate kind for the object, for example</source>
          <target state="translated">たとえば、オブジェクトに適切な種類の &lt;code&gt;ALTER&lt;/code&gt; コマンドを使用して、オブジェクトを新しい所有者に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="261a27538e7f1d6cc0124e706ea14d5684e6fe5c" translate="yes" xml:space="preserve">
          <source>An object's owner can choose to revoke their own ordinary privileges, for example to make a table read-only for themselves as well as others. But owners are always treated as holding all grant options, so they can always re-grant their own privileges.</source>
          <target state="translated">オブジェクトの所有者は、自分の通常の権限を取り消すことができます。例えば、テーブルを自分だけでなく他の人も読めるようにするなどです。しかし、所有者は常にすべてのグラントオプションを保持しているものとして扱われるので、所有者は常に自分の特権を再付与することができます。</target>
        </trans-unit>
        <trans-unit id="cd7347c4e72d5111690a2e6b553a4bb95eecefbe" translate="yes" xml:space="preserve">
          <source>An obsolete type name that formerly served many of the above purposes.</source>
          <target state="translated">以前は上記の目的の多くを果たしていた旧式のタイプ名。</target>
        </trans-unit>
        <trans-unit id="e67e0cc488404bddd9185d257d8376a78bb5f89d" translate="yes" xml:space="preserve">
          <source>An older syntax based on &quot;:=&quot; is supported for backward compatibility:</source>
          <target state="translated">下位互換性のために、「:=」に基づく古い構文がサポートされています。</target>
        </trans-unit>
        <trans-unit id="a2ec14d06c6e5e0d12a30237502776f169012b3d" translate="yes" xml:space="preserve">
          <source>An open cursor's name.</source>
          <target state="translated">開いているカーソルの名前。</target>
        </trans-unit>
        <trans-unit id="fdaf617bcf458038608559aa52135b2d0fb280c4" translate="yes" xml:space="preserve">
          <source>An operation and SQL keyword used in &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;queries&lt;/a&gt; for combining data from multiple &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt;.</source>
          <target state="translated">複数の&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;リレーション&lt;/a&gt;からのデータを組み合わせるための&lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;クエリ&lt;/a&gt;で使用される操作とSQLキーワード。</target>
        </trans-unit>
        <trans-unit id="907b1845a90ba08c2bd64d8aae44246179e07fc0" translate="yes" xml:space="preserve">
          <source>An operator class for BRIN can optionally specify the following method:</source>
          <target state="translated">BRINの演算子クラスは、オプションで以下のメソッドを指定することができます。</target>
        </trans-unit>
        <trans-unit id="a82dcbae2eb28872acc9a82bc62d7f28fc52dc06" translate="yes" xml:space="preserve">
          <source>An operator class for GIN can optionally supply the following methods:</source>
          <target state="translated">GIN の演算子クラスは、オプションで以下のメソッドを提供することができます。</target>
        </trans-unit>
        <trans-unit id="56d15480825e451d724a77515f8cbd596240aa64" translate="yes" xml:space="preserve">
          <source>An operator class for bloom indexes requires only a hash function for the indexed data type and an equality operator for searching. This example shows the operator class definition for the &lt;code&gt;text&lt;/code&gt; data type:</source>
          <target state="translated">ブルームインデックスの演算子クラスには、インデックス付きデータ型のハッシュ関数と検索用の等値演算子のみが必要です。この例は、 &lt;code&gt;text&lt;/code&gt; データタイプの演算子クラス定義を示しています。</target>
        </trans-unit>
        <trans-unit id="6eb7653b3723c58c344a731c25071cc3711f5e86" translate="yes" xml:space="preserve">
          <source>An operator class is actually just a subset of a larger structure called an &lt;em&gt;operator family&lt;/em&gt;. In cases where several data types have similar behaviors, it is frequently useful to define cross-data-type operators and allow these to work with indexes. To do this, the operator classes for each of the types must be grouped into the same operator family. The cross-type operators are members of the family, but are not associated with any single class within the family.</source>
          <target state="translated">演算子クラスは実際には、&lt;em&gt;演算子ファミリー&lt;/em&gt;と呼ばれるより大きな構造のサブセットにすぎません。複数のデータ型の動作が類似している場合、データ型間演算子を定義し、これらをインデックスで使用できるようにすることがしばしば役立ちます。これを行うには、各タイプの演算子クラスを同じ演算子ファミリーにグループ化する必要があります。クロスタイプ演算子はファミリーのメンバーですが、ファミリー内の単一のクラスには関連付けられていません。</target>
        </trans-unit>
        <trans-unit id="f7d235f30c792ff196a94c50c4549a98a2d7a764" translate="yes" xml:space="preserve">
          <source>An operator class must also provide a function to check if an indexed item matches the query. It comes in two flavors, a Boolean &lt;code&gt;consistent&lt;/code&gt; function, and a ternary &lt;code&gt;triConsistent&lt;/code&gt; function. &lt;code&gt;triConsistent&lt;/code&gt; covers the functionality of both, so providing &lt;code&gt;triConsistent&lt;/code&gt; alone is sufficient. However, if the Boolean variant is significantly cheaper to calculate, it can be advantageous to provide both. If only the Boolean variant is provided, some optimizations that depend on refuting index items before fetching all the keys are disabled.</source>
          <target state="translated">演算子クラスは、インデックス付きアイテムがクエリと一致するかどうかをチェックする関数も提供する必要があります。これには、ブール &lt;code&gt;consistent&lt;/code&gt; 関数と3項 &lt;code&gt;triConsistent&lt;/code&gt; 関数の2つのフレーバーがあります。 &lt;code&gt;triConsistent&lt;/code&gt; は両方の機能をカバーするので、 &lt;code&gt;triConsistent&lt;/code&gt; を提供するだけで十分です。ただし、ブールバリアントの計算の方が大幅に安価である場合は、両方を提供する方が有利です。ブールバリアントのみが提供されている場合、すべてのキーをフェッチする前のインデックスアイテムの変更に依存する一部の最適化は無効になります。</target>
        </trans-unit>
        <trans-unit id="6e523c5f9d2c574da0fb6483337cb467c258e68f" translate="yes" xml:space="preserve">
          <source>An operator class's &lt;code&gt;opcmethod&lt;/code&gt; must match the &lt;code&gt;opfmethod&lt;/code&gt; of its containing operator family. Also, there must be no more than one &lt;code&gt;pg_opclass&lt;/code&gt; row having &lt;code&gt;opcdefault&lt;/code&gt; true for any given combination of &lt;code&gt;opcmethod&lt;/code&gt; and &lt;code&gt;opcintype&lt;/code&gt;.</source>
          <target state="translated">演算子クラスの &lt;code&gt;opcmethod&lt;/code&gt; は、それを含む演算子ファミリの &lt;code&gt;opfmethod&lt;/code&gt; と一致する必要があります。また、 &lt;code&gt;opcmethod&lt;/code&gt; と &lt;code&gt;opcintype&lt;/code&gt; の特定の組み合わせに対して、 &lt;code&gt;opcdefault&lt;/code&gt; が trueである &lt;code&gt;pg_opclass&lt;/code&gt; 行は1つだけでなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a6550b54250a9ead01f2b3553646b2303a4a1ed" translate="yes" xml:space="preserve">
          <source>An operator invocation</source>
          <target state="translated">演算子呼び出し</target>
        </trans-unit>
        <trans-unit id="61b072351eb6c6fa27b9ae84a318cc236116df90" translate="yes" xml:space="preserve">
          <source>An operator name is a sequence of up to &lt;code&gt;NAMEDATALEN&lt;/code&gt;-1 (63 by default) characters from the following list:</source>
          <target state="translated">オペレーター名は、以下のリストの &lt;code&gt;NAMEDATALEN&lt;/code&gt; -1（デフォルトでは63）文字までのシーケンスです。</target>
        </trans-unit>
        <trans-unit id="d3a80b67bf09fd16cb2674622b6e5dcf9a0716b6" translate="yes" xml:space="preserve">
          <source>An operator used to derive the statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;. For example, a histogram slot would show the &lt;code&gt;&amp;lt;&lt;/code&gt; operator that defines the sort order of the data.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 番目の「スロット」に格納されている統計を導出するために使用される演算子。たとえば、ヒストグラムスロットには、データの並べ替え順序を定義する &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子が表示されます。</target>
        </trans-unit>
        <trans-unit id="36745dfcd4a31015998a201702d690d18fcba0c2" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;+&lt;/code&gt; produces more details.</source>
          <target state="translated">オプションの &lt;code&gt;+&lt;/code&gt; は、詳細を生成します。</target>
        </trans-unit>
        <trans-unit id="15280e346b927d3a2d54ca3d61b3ae948a862eb2" translate="yes" xml:space="preserve">
          <source>An optional collation for the domain. If no collation is specified, the underlying data type's default collation is used. The underlying type must be collatable if &lt;code&gt;COLLATE&lt;/code&gt; is specified.</source>
          <target state="translated">ドメインのオプションの照合。照合順序が指定されていない場合、基になるデータ型のデフォルトの照合順序が使用されます。 &lt;code&gt;COLLATE&lt;/code&gt; が指定されている場合、基になるタイプは照合可能でなければなりません。</target>
        </trans-unit>
        <trans-unit id="60e65907bee0f7f6070fd34b3f416cb8bb6f6e36" translate="yes" xml:space="preserve">
          <source>An optional comma-separated list of arguments to be provided to the function when the trigger is executed. The arguments are literal string constants. Simple names and numeric constants can be written here, too, but they will all be converted to strings. Please check the description of the implementation language of the trigger function to find out how these arguments can be accessed within the function; it might be different from normal function arguments.</source>
          <target state="translated">トリガが実行されたときに関数に提供される引数のオプションのカンマ区切りリスト。引数はリテラル文字列定数です。単純な名前や数値定数もここに書くことができますが、すべて文字列に変換されます。これらの引数が関数内でどのようにアクセスできるかについては、トリガー関数の実装言語の記述を確認してください;通常の関数の引数とは異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4ca636c20fca55bda068decba0ca12e4c60f9d3" translate="yes" xml:space="preserve">
          <source>An optional list of columns to be copied. If no column list is specified, all columns of the table except generated columns will be copied.</source>
          <target state="translated">コピーする列のオプションのリスト。カラムリストが指定されていない場合は、生成されたカラムを除くテーブルのすべてのカラムがコピーされます。</target>
        </trans-unit>
        <trans-unit id="f37b6dea6bba7854fbb2a25222ccbd3742c1fd86" translate="yes" xml:space="preserve">
          <source>An optional list of names to be used for columns of the view. If not given, the column names are deduced from the query.</source>
          <target state="translated">ビューのカラムに使用する名前のオプションのリスト。指定しない場合、カラム名はクエリから推測されます。</target>
        </trans-unit>
        <trans-unit id="a1745e8f3d8a818bb59434a30224b4bc70bd52ef" translate="yes" xml:space="preserve">
          <source>An optional name for a column or table constraint. If the constraint is violated, the constraint name is present in error messages, so constraint names like &lt;code&gt;col must be positive&lt;/code&gt; can be used to communicate helpful constraint information to client applications. (Double-quotes are needed to specify constraint names that contain spaces.) If a constraint name is not specified, the system generates a name.</source>
          <target state="translated">列またはテーブル制約のオプションの名前。制約に違反している場合、制約名がエラーメッセージに存在している、のようなので、制約名 &lt;code&gt;col must be positive&lt;/code&gt; クライアントアプリケーションに役立つ制約情報を通信するために使用することができます。（スペースを含む制約名を指定するには、二重引用符が必要です。）制約名が指定されていない場合、システムが名前を生成します。</target>
        </trans-unit>
        <trans-unit id="f3ae3fadcc76fcc5b9297de7bc96718990dc996d" translate="yes" xml:space="preserve">
          <source>An optional name for a constraint. If not specified, the system generates a name.</source>
          <target state="translated">制約のオプションの名前。指定しない場合は、システムが名前を生成します。</target>
        </trans-unit>
        <trans-unit id="bd6568613ce7c67d34419866e38138da4ce733d2" translate="yes" xml:space="preserve">
          <source>An output column's name can be used to refer to the column's value in &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt; clauses, but not in the &lt;code&gt;WHERE&lt;/code&gt; or &lt;code&gt;HAVING&lt;/code&gt; clauses; there you must write out the expression instead.</source>
          <target state="translated">出力列の名前を使用して、 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;GROUP BY&lt;/code&gt; 句とGROUP BY句で列の値を参照できますが、 &lt;code&gt;WHERE&lt;/code&gt; 句や &lt;code&gt;HAVING&lt;/code&gt; 句では使用できません。そこで、代わりに式を書き出す必要があります。</target>
        </trans-unit>
        <trans-unit id="b29ad290e8bd770fdebcb84bad7370f20ace4e23" translate="yes" xml:space="preserve">
          <source>Analogous statements with inverted conditions hold when &lt;code&gt;less&lt;/code&gt; = false.</source>
          <target state="translated">条件が反転した類似のステートメントは、 &lt;code&gt;less&lt;/code&gt; = falseの場合に成立します。</target>
        </trans-unit>
        <trans-unit id="602ef0777e13fcee9897969f97ef1e867cdf140e" translate="yes" xml:space="preserve">
          <source>Analogous to &lt;code&gt;ON DELETE&lt;/code&gt; there is also &lt;code&gt;ON UPDATE&lt;/code&gt; which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, &lt;code&gt;CASCADE&lt;/code&gt; means that the updated values of the referenced column(s) should be copied into the referencing row(s).</source>
          <target state="translated">類似 &lt;code&gt;ON DELETE&lt;/code&gt; もある &lt;code&gt;ON UPDATE&lt;/code&gt; 参照列が変更されたときに呼び出される（更新）。可能なアクションは同じです。この場合、 &lt;code&gt;CASCADE&lt;/code&gt; は、参照される列の更新された値を参照する行にコピーする必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="8e26143bf38a350af73fba34493a3e7479767511" translate="yes" xml:space="preserve">
          <source>Analytic function</source>
          <target state="translated">解析機能</target>
        </trans-unit>
        <trans-unit id="4f0e68d1e2fd04310f44d64aff40ca304bd44245" translate="yes" xml:space="preserve">
          <source>Analyze (operation)</source>
          <target state="translated">分析(操作</target>
        </trans-unit>
        <trans-unit id="5c83db21cadbb2756e96e53b9c14b7e7a2b514a6" translate="yes" xml:space="preserve">
          <source>Ancient distributions might not have the &lt;code&gt;sysctl&lt;/code&gt; program, but equivalent changes can be made by manipulating the &lt;code&gt;/proc&lt;/code&gt; file system:</source>
          <target state="translated">古代のディストリビューションには &lt;code&gt;sysctl&lt;/code&gt; プログラムがない場合がありますが、 &lt;code&gt;/proc&lt;/code&gt; ファイルシステムを操作することで同等の変更を行うことができます。</target>
        </trans-unit>
        <trans-unit id="0d93beb44d205136520d673b54b56936f6980aa2" translate="yes" xml:space="preserve">
          <source>And finally create the transform to connect them all together:</source>
          <target state="translated">そして最終的にはそれらを全て繋げるトランスフォームを作成します。</target>
        </trans-unit>
        <trans-unit id="43c2b85844ed32a3fb79c6e1b9f3ea8d1ebdd551" translate="yes" xml:space="preserve">
          <source>And finally, most disk drives have caches. Some are write-through while some are write-back, and the same concerns about data loss exist for write-back drive caches as for disk controller caches. Consumer-grade IDE and SATA drives are particularly likely to have write-back caches that will not survive a power failure. Many solid-state drives (SSD) also have volatile write-back caches.</source>
          <target state="translated">最後に、ほとんどのディスクドライブにはキャッシュがあります。ライトスルー型もあれば、ライトバック型もあり、ディスクコントローラのキャッシュと同様に、ライトバック型ドライブのキャッシュにもデータ損失に関する懸念が存在します。コンシューマグレードの IDE および SATA ドライブは、特に電源障害に耐えられないライトバックキャッシュを持つ可能性が高いです。多くのソリッドステートドライブ (SSD)にも、揮発性のライトバックキャッシュがあります。</target>
        </trans-unit>
        <trans-unit id="f5abe4b1cbcb838f669f793ea91def6b18bb7e30" translate="yes" xml:space="preserve">
          <source>And on the subscriber database:</source>
          <target state="translated">加入者データベースにも</target>
        </trans-unit>
        <trans-unit id="e24853104ecb700e47b83196c8cd650b56525c5b" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;.dict&lt;/code&gt; file has the following structure:</source>
          <target state="translated">また、 &lt;code&gt;.dict&lt;/code&gt; ファイルの構造は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="588ca16f318d70344d76b4537a5c7291a5cee916" translate="yes" xml:space="preserve">
          <source>And the matching code in the C module could then follow this skeleton:</source>
          <target state="translated">そして、Cモジュール内のマッチするコードは、このスケルトンに従うことができます。</target>
        </trans-unit>
        <trans-unit id="680044bb057f2caf79b08b39f3f6077a48b66315" translate="yes" xml:space="preserve">
          <source>And to get 2-D cubes ordered by the first coordinate of the upper right corner descending:</source>
          <target state="translated">そして、右上の角が下降する最初の座標から順に2次元立方体を取得する。</target>
        </trans-unit>
        <trans-unit id="6871b449d2c079d96e59fe6f124b014ba15535f8" translate="yes" xml:space="preserve">
          <source>And we can specify subfields as targets for &lt;code&gt;INSERT&lt;/code&gt;, too:</source>
          <target state="translated">また、サブフィールドを &lt;code&gt;INSERT&lt;/code&gt; のターゲットとして指定することもできます。</target>
        </trans-unit>
        <trans-unit id="a145997c5dd507c46627dcb8aa745e601bfd3eab" translate="yes" xml:space="preserve">
          <source>And, if the function is called with an argument of type &lt;code&gt;integer&lt;/code&gt;, the parser will try to convert that to &lt;code&gt;text&lt;/code&gt;:</source>
          <target state="translated">そして、関数が &lt;code&gt;integer&lt;/code&gt; 型の引数で呼び出された場合、パーサーはそれを &lt;code&gt;text&lt;/code&gt; に変換しようとします：</target>
        </trans-unit>
        <trans-unit id="7848b33d4bfc790590d465569216a9f6ae690895" translate="yes" xml:space="preserve">
          <source>Anonymous allocations are allocations that have been made with &lt;code&gt;ShmemAlloc()&lt;/code&gt; directly, rather than via &lt;code&gt;ShmemInitStruct()&lt;/code&gt; or &lt;code&gt;ShmemInitHash()&lt;/code&gt;.</source>
          <target state="translated">匿名割り当ては、 &lt;code&gt;ShmemInitStruct()&lt;/code&gt; または &lt;code&gt;ShmemInitHash()&lt;/code&gt; を介してではなく、 &lt;code&gt;ShmemAlloc()&lt;/code&gt; を使用して直接行われた割り当てです。</target>
        </trans-unit>
        <trans-unit id="20ab5b725ed73e7635d9823c37915d8903343a0f" translate="yes" xml:space="preserve">
          <source>Another alternative worth considering is to use &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers (see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;) in place of rules.</source>
          <target state="translated">検討する価値のある別の代替手段は、ルールの代わりに &lt;code&gt;INSTEAD OF&lt;/code&gt; トリガー（&lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGERを&lt;/a&gt;参照）を使用することです。</target>
        </trans-unit>
        <trans-unit id="e823a73742793d80b913d4d208ddb3ca9056df81" translate="yes" xml:space="preserve">
          <source>Another approach is to create a separate &lt;code&gt;tsvector&lt;/code&gt; column to hold the output of &lt;code&gt;to_tsvector&lt;/code&gt;. To keep this column automatically up to date with its source data, use a stored generated column. This example is a concatenation of &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;, using &lt;code&gt;coalesce&lt;/code&gt; to ensure that one field will still be indexed when the other is &lt;code&gt;NULL&lt;/code&gt;:</source>
          <target state="translated">別のアプローチは、 &lt;code&gt;to_tsvector&lt;/code&gt; の出力を保持する別の &lt;code&gt;tsvector&lt;/code&gt; 列を作成することです。この列をソースデータで自動的に最新に保つには、保存された生成列を使用します。この例は、 &lt;code&gt;title&lt;/code&gt; と &lt;code&gt;body&lt;/code&gt; を連結したもので、coalceceを使用 &lt;code&gt;coalesce&lt;/code&gt; て、他のフィールドが &lt;code&gt;NULL&lt;/code&gt; の場合でも1つのフィールドが引き続きインデックス付けされるようにします。</target>
        </trans-unit>
        <trans-unit id="c88aeeb193209d03f36ea4052749971eef461a5a" translate="yes" xml:space="preserve">
          <source>Another approach to querying is to exploit containment, for example:</source>
          <target state="translated">クエリへの別のアプローチとしては、例えば、封じ込めを利用することがあります。</target>
        </trans-unit>
        <trans-unit id="0f6657768acd9084b11e644584f044a4fc45d8af" translate="yes" xml:space="preserve">
          <source>Another approach, which can be used with or without altering &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, is to set the process-specific &lt;em&gt;OOM score adjustment&lt;/em&gt; value for the postmaster process to &lt;code&gt;-1000&lt;/code&gt;, thereby guaranteeing it will not be targeted by the OOM killer. The simplest way to do this is to execute</source>
          <target state="translated">&lt;code&gt;vm.overcommit_memory&lt;/code&gt; を変更してもしなくても使用できる別のアプローチは、postmasterプロセスのプロセス固有の&lt;em&gt;OOMスコア調整&lt;/em&gt;値を &lt;code&gt;-1000&lt;/code&gt; に設定することです。これにより、OOMキラーのターゲットにならないことが保証されます。これを行う最も簡単な方法は、実行することです</target>
        </trans-unit>
        <trans-unit id="0157777d67f21431cd43979bf17bb15a2c6fa069" translate="yes" xml:space="preserve">
          <source>Another caveat when building a unique index concurrently is that the uniqueness constraint is already being enforced against other transactions when the second table scan begins. This means that constraint violations could be reported in other queries prior to the index becoming available for use, or even in cases where the index build eventually fails. Also, if a failure does occur in the second scan, the &amp;ldquo;invalid&amp;rdquo; index continues to enforce its uniqueness constraint afterwards.</source>
          <target state="translated">一意のインデックスを同時に作成する際のもう1つの注意点は、2番目のテーブルスキャンの開始時に、一意性制約が他のトランザクションに対して既に適用されていることです。つまり、インデックスが使用可能になる前に、またはインデックスの構築が最終的に失敗した場合でも、他のクエリで制約違反が報告される可能性があります。また、2回目のスキャンで障害が発生した場合、「無効な」インデックスは一意性制約を後で強制し続けます。</target>
        </trans-unit>
        <trans-unit id="8366e5720bf81785c8af920367ca1956fa9f6126" translate="yes" xml:space="preserve">
          <source>Another common reason for copying &lt;code&gt;template0&lt;/code&gt; instead of &lt;code&gt;template1&lt;/code&gt; is that new encoding and locale settings can be specified when copying &lt;code&gt;template0&lt;/code&gt;, whereas a copy of &lt;code&gt;template1&lt;/code&gt; must use the same settings it does. This is because &lt;code&gt;template1&lt;/code&gt; might contain encoding-specific or locale-specific data, while &lt;code&gt;template0&lt;/code&gt; is known not to.</source>
          <target state="translated">コピーするためのもう一つの一般的な理由 &lt;code&gt;template0&lt;/code&gt; の代わり &lt;code&gt;template1&lt;/code&gt; コピーするときに新しいエンコーディングとロケール設定を指定することができるということである &lt;code&gt;template0&lt;/code&gt; コピーに対し、 &lt;code&gt;template1&lt;/code&gt; をはそれがないと同じ設定を使用する必要があります。これは、 &lt;code&gt;template1&lt;/code&gt; が認識されていないのに、 &lt;code&gt;template0&lt;/code&gt; がエンコード固有またはロケール固有のデータを含む可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="fbb209aa36c1a4990c8b7ddd6d829419598146fa" translate="yes" xml:space="preserve">
          <source>Another consideration is that a &lt;code&gt;setval&lt;/code&gt; executed on such a sequence will not be noticed by other sessions until they have used up any preallocated values they have cached.</source>
          <target state="translated">もう1つの考慮事項は、そのようなシーケンスで実行された &lt;code&gt;setval&lt;/code&gt; は、キャッシュされている事前割り当てされた値を使い切るまで、他のセッションによって通知されないことです。</target>
        </trans-unit>
        <trans-unit id="3dd197e47ceae278b1382e01aa4231fc834370d4" translate="yes" xml:space="preserve">
          <source>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</source>
          <target state="translated">ルールアプローチのもう一つの欠点は、ルールのセットが挿入日をカバーしていない場合、エラーを強制的に発生させる簡単な方法がないことです。</target>
        </trans-unit>
        <trans-unit id="b74b279225b01a4f9a49098a715c0c2cd2860bb8" translate="yes" xml:space="preserve">
          <source>Another effect of &lt;code&gt;RECURSIVE&lt;/code&gt; is that &lt;code&gt;WITH&lt;/code&gt; queries need not be ordered: a query can reference another one that is later in the list. (However, circular references, or mutual recursion, are not implemented.) Without &lt;code&gt;RECURSIVE&lt;/code&gt;, &lt;code&gt;WITH&lt;/code&gt; queries can only reference sibling &lt;code&gt;WITH&lt;/code&gt; queries that are earlier in the &lt;code&gt;WITH&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;RECURSIVE&lt;/code&gt; のもう1つの効果は、 &lt;code&gt;WITH&lt;/code&gt; クエリを並べ替える必要がないことです。クエリは、リストの後半にある別のクエリを参照できます。（ただし、循環参照、または相互再帰は実装されていません。） &lt;code&gt;RECURSIVE&lt;/code&gt; がない場合、 &lt;code&gt;WITH&lt;/code&gt; クエリは、 &lt;code&gt;WITH&lt;/code&gt; リストの前にある兄弟 &lt;code&gt;WITH&lt;/code&gt; クエリのみを参照できます。</target>
        </trans-unit>
        <trans-unit id="f949f8323c537df82042ad10748a3400dd5e3c94" translate="yes" xml:space="preserve">
          <source>Another example &amp;mdash; the PostgreSQL mailing list archives contained 910,989 unique words with 57,491,343 lexemes in 461,020 messages.</source>
          <target state="translated">別の例&amp;mdash; PostgreSQLメーリングリストアーカイブには、910,989個の一意の単語が含まれ、57,491,343個の語彙素が461,020個のメッセージに含まれていました。</target>
        </trans-unit>
        <trans-unit id="e840dc5efd9dcea852680d04861f5d19522482d9" translate="yes" xml:space="preserve">
          <source>Another example demonstrating these concepts is that all these queries mean the same thing:</source>
          <target state="translated">これらの概念を示すもう一つの例は、これらのクエリはすべて同じことを意味するということです。</target>
        </trans-unit>
        <trans-unit id="448793ead43f5a4696dde796c384f50ddecfec35" translate="yes" xml:space="preserve">
          <source>Another example with &lt;code&gt;--rate=100&lt;/code&gt; and &lt;code&gt;--latency-limit=5&lt;/code&gt; (note the additional &lt;code&gt;schedule_lag&lt;/code&gt; column):</source>
          <target state="translated">&lt;code&gt;--rate=100&lt;/code&gt; および &lt;code&gt;--latency-limit=5&lt;/code&gt; を使用した別の例（追加の &lt;code&gt;schedule_lag&lt;/code&gt; 列に注意してください）：</target>
        </trans-unit>
        <trans-unit id="1eb54ef0acd3e1a10201fcaabd71c9780026708a" translate="yes" xml:space="preserve">
          <source>Another form of table aliasing gives temporary names to the columns of the table, as well as the table itself:</source>
          <target state="translated">テーブルエイリアスのもう一つの形式は、テーブル自体と同様に、テーブルの列に一時的な名前を与えることです。</target>
        </trans-unit>
        <trans-unit id="52020177212290ca0e1ac022789f990b2cddb766" translate="yes" xml:space="preserve">
          <source>Another identifier type used by the system is &lt;code&gt;xid&lt;/code&gt;, or transaction (abbreviated</source>
          <target state="translated">システムが使用するもう1つの識別子タイプは、 &lt;code&gt;xid&lt;/code&gt; またはトランザクション（省略形）です。</target>
        </trans-unit>
        <trans-unit id="aed7ef2e15652a392b1a6ed9c8e4d99caec1a67e" translate="yes" xml:space="preserve">
          <source>Another important point is that when a server process is asked to display any of these statistics, it first fetches the most recent report emitted by the collector process and then continues to use this snapshot for all statistical views and functions until the end of its current transaction. So the statistics will show static information as long as you continue the current transaction. Similarly, information about the current queries of all sessions is collected when any such information is first requested within a transaction, and the same information will be displayed throughout the transaction. This is a feature, not a bug, because it allows you to perform several queries on the statistics and correlate the results without worrying that the numbers are changing underneath you. But if you want to see new results with each query, be sure to do the queries outside any transaction block. Alternatively, you can invoke &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt;(), which will discard the current transaction's statistics snapshot (if any). The next use of statistical information will cause a new snapshot to be fetched.</source>
          <target state="translated">別の重要なポイントは、サーバープロセスがこれらの統計のいずれかを表示するように要求された場合、最初にコレクタプロセスによって発行された最新のレポートをフェッチし、次に現在のトランザクションが終了するまで、すべての統計ビューおよび関数に対してこのスナップショットを使用し続けることです。 。したがって、現在のトランザクションを続行している限り、統計には静的な情報が表示されます。同様に、すべてのセッションの現在のクエリに関する情報は、そのような情報がトランザクション内で最初に要求されたときに収集され、同じ情報がトランザクション全体で表示されます。これはバグではなく機能です。統計情報に対していくつかのクエリを実行し、数値が自分の下で変化することを心配せずに結果を関連付けることができるためです。ただし、クエリごとに新しい結果を表示したい場合は、クエリはトランザクションブロックの外で実行してください。または、 &lt;code&gt;pg_stat_clear_snapshot&lt;/code&gt; （）、現在のトランザクションの統計スナップショット（存在する場合）を破棄します。次に統計情報を使用すると、新しいスナップショットがフェッチされます。</target>
        </trans-unit>
        <trans-unit id="b8503372565f5e8246e4f400f8ddf376d816116a" translate="yes" xml:space="preserve">
          <source>Another important property of transactional databases is closely related to the notion of atomic updates: when multiple transactions are running concurrently, each one should not be able to see the incomplete changes made by others. For example, if one transaction is busy totalling all the branch balances, it would not do for it to include the debit from Alice's branch but not the credit to Bob's branch, nor vice versa. So transactions must be all-or-nothing not only in terms of their permanent effect on the database, but also in terms of their visibility as they happen. The updates made so far by an open transaction are invisible to other transactions until the transaction completes, whereupon all the updates become visible simultaneously.</source>
          <target state="translated">トランザクションデータベースのもう一つの重要な特性は、アトミックアップデートの概念と密接に関連しています。複数のトランザクションが同時に実行されている場合、それぞれのトランザクションは他のトランザクションによる不完全な変更を見ることができないはずです。例えば、あるトランザクションがすべての支店の残高を合計するのに忙しい場合、アリスの支店からの引き落としは含まれていても、ボブの支店への引き落としは含まれていない、あるいはその逆は含まれていないということになります。つまり、トランザクションはデータベースへの永続的な影響だけでなく、発生時の可視性の観点からもオールオア・ナッシングでなければなりません。オープンなトランザクションによってこれまでに行われた更新は、トランザクションが完了するまで他のトランザクションからは見えません。</target>
        </trans-unit>
        <trans-unit id="23097e202fa3204d32b939bd963d1f1a19f9bc71" translate="yes" xml:space="preserve">
          <source>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple &lt;em&gt;must&lt;/em&gt; divide the set of leaf values into more than one node group. If the operator class's &lt;code&gt;picksplit&lt;/code&gt; function fails to do that, the SP-GiST core resorts to extraordinary measures described in &lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;Section 65.4.3&lt;/a&gt;.</source>
          <target state="translated">もう1つの制限は、内部タプルのノードがリーフタプルのセットを指す場合、それらのタプルはすべて同じインデックスページにある必要があることです。 （これは、そのようなタプルをつなぐリンクのシークを減らし、スペースを節約するための設計上の決定です。）リーフタプルのセットがページに対して大きくなりすぎると、分割が実行され、中間の内部タプルが挿入されます。これで問題を解決するには、新しい内部タプルがリーフ値のセットを複数のノードグループに分割する&lt;em&gt;必要があり&lt;/em&gt;ます。演算子クラスの &lt;code&gt;picksplit&lt;/code&gt; 関数がそれを実行できない場合、SP-GiSTコアは、&lt;a href=&quot;spgist-implementation#SPGIST-ALL-THE-SAME&quot;&gt;セクション65.4.3で&lt;/a&gt;説明されている異常な手段を使用します。</target>
        </trans-unit>
        <trans-unit id="3c5682b61a20f627d46e59c868bdcce430ea3716" translate="yes" xml:space="preserve">
          <source>Another limitation of the same kind is that a &lt;code&gt;CASE&lt;/code&gt; cannot prevent evaluation of an aggregate expression contained within it, because aggregate expressions are computed before other expressions in a &lt;code&gt;SELECT&lt;/code&gt; list or &lt;code&gt;HAVING&lt;/code&gt; clause are considered. For example, the following query can cause a division-by-zero error despite seemingly having protected against it:</source>
          <target state="translated">同じ種類のもう1つの制限は、 &lt;code&gt;CASE&lt;/code&gt; は &lt;code&gt;SELECT&lt;/code&gt; リストまたは &lt;code&gt;HAVING&lt;/code&gt; 句の他の式が考慮される前に集計式が計算されるため、その中に含まれる集計式の評価を防止できないことです。たとえば、次のクエリは、保護されているように見えても、ゼロ除算エラーを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e130eb29a636a2e4db63836c537e80b5eb47453" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension is that following the escape character with a letter or digit provides access to the escape sequences defined for POSIX regular expressions; see &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, &lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;, and &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt; below.</source>
          <target state="translated">もう1つの非標準の拡張機能は、エスケープ文字の後に文字または数字を続けると、POSIX正規表現用に定義されたエスケープシーケンスにアクセスできることです。以下の&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;表9.20&lt;/a&gt;、&lt;a href=&quot;functions-matching#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE&quot;&gt;表9.21&lt;/a&gt;、および&lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;表9.22を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7a59e6837fb64d2b0ae7bbcb08e5b72fd153fb2c" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 接続のもう1つのオプションは、クライアントが&lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt;を使用して、ソケットに接続されているサーバープロセスの必要な所有者を指定することです。</target>
        </trans-unit>
        <trans-unit id="306459cbdd31101692b05f06a566b18b0bdf0e20" translate="yes" xml:space="preserve">
          <source>Another option for &lt;code&gt;local&lt;/code&gt; connections is for clients to use &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt;&lt;code&gt;requirepeer&lt;/code&gt;&lt;/a&gt; to specify the required owner of the server process connected to the socket.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 接続のもう1つのオプションは、クライアントが&lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-CONNECT-REQUIREPEER&quot;&gt; &lt;code&gt;requirepeer&lt;/code&gt; &lt;/a&gt;を使用して、ソケットに接続されているサーバープロセスの必要な所有者を指定することです。</target>
        </trans-unit>
        <trans-unit id="cb5714af00c74e15b8a5da4136ed86aaafa447c5" translate="yes" xml:space="preserve">
          <source>Another option is to increase &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; on the primary server, so that dead rows will not be cleaned up as quickly as they normally would be. This will allow more time for queries to execute before they are canceled on the standby, without having to set a high &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. However it is difficult to guarantee any specific execution-time window with this approach, since &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; is measured in transactions executed on the primary server.</source>
          <target state="translated">もう1つのオプションは、プライマリサーバーの&lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt;を増やすことです。これにより、デッド行が通常よりも早くクリーンアップされなくなります。これにより、 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; を高く設定しなくても、クエリがスタンバイでキャンセルされる前に実行する時間が長くなります。ただし、 &lt;code&gt;vacuum_defer_cleanup_age&lt;/code&gt; はプライマリサーバーで実行されるトランザクションで測定されるため、このアプローチで特定の実行時間ウィンドウを保証することは困難です。</target>
        </trans-unit>
        <trans-unit id="7e21e953eee19c97f61f831dca8e524d5dd57839" translate="yes" xml:space="preserve">
          <source>Another option is to use rsync to perform a file system backup. This is done by first running rsync while the database server is running, then shutting down the database server long enough to do an &lt;code&gt;rsync --checksum&lt;/code&gt;. (&lt;code&gt;--checksum&lt;/code&gt; is necessary because &lt;code&gt;rsync&lt;/code&gt; only has file modification-time granularity of one second.) The second rsync will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime.</source>
          <target state="translated">別のオプションは、rsyncを使用してファイルシステムのバックアップを実行することです。これは、データベースサーバーの実行中に最初にrsyncを実行し、次に &lt;code&gt;rsync --checksum&lt;/code&gt; を実行するのに十分な時間データベースサーバーをシャットダウンすることによって行われます。 （ &lt;code&gt;--checksum&lt;/code&gt; が必要なのは、 &lt;code&gt;rsync&lt;/code&gt; のファイル変更時間の粒度が1秒しかないためです。）2番目のrsyncは、転送するデータが比較的少ないため、最初のrsyncよりも速くなり、サーバーがダウン。この方法では、最小限のダウンタイムでファイルシステムのバックアップを実行できます。</target>
        </trans-unit>
        <trans-unit id="7c34c9f74979196480818c068869e2f214816a27" translate="yes" xml:space="preserve">
          <source>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</source>
          <target state="translated">他にも、パーティショニングされたテーブルからパーティションを削除しても、それ自体はテーブルとしてアクセスできるようにしておくという方法が好ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="2a69438b1163aac867f43267272d34d1c58b2559" translate="yes" xml:space="preserve">
          <source>Another point to keep in mind is that by default, execute privilege is granted to &lt;code&gt;PUBLIC&lt;/code&gt; for newly created functions (see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information). Frequently you will wish to restrict use of a security definer function to only some users. To do that, you must revoke the default &lt;code&gt;PUBLIC&lt;/code&gt; privileges and then grant execute privilege selectively. To avoid having a window where the new function is accessible to all, create it and set the privileges within a single transaction. For example:</source>
          <target state="translated">留意すべきもう1つの点は、デフォルトでは、新しく作成された関数の実行権限が &lt;code&gt;PUBLIC&lt;/code&gt; に付与されることです（詳細は、&lt;a href=&quot;ddl-priv&quot;&gt;5.7項を&lt;/a&gt;参照）。多くの場合、セキュリティ定義機能の使用を一部のユーザーのみに制限する必要があります。そのためには、デフォルトの &lt;code&gt;PUBLIC&lt;/code&gt; 特権を取り消してから、実行特権を選択的に付与する必要があります。すべてのユーザーが新しい関数にアクセスできるウィンドウが表示されないようにするには、それを作成して、単一のトランザクション内で特権を設定します。例えば：</target>
        </trans-unit>
        <trans-unit id="c64ca403c18f38074dbf9506c7423e6c0d47b0ca" translate="yes" xml:space="preserve">
          <source>Another possibility is to create a configuration file directory and put this information into files there. For example, a &lt;code&gt;conf.d&lt;/code&gt; directory could be referenced at the end of &lt;code&gt;postgresql.conf&lt;/code&gt;:</source>
          <target state="translated">別の可能性は、設定ファイルのディレクトリを作成し、この情報をそこにあるファイルに入れることです。たとえば、 &lt;code&gt;conf.d&lt;/code&gt; ディレクトリは &lt;code&gt;postgresql.conf&lt;/code&gt; の末尾で参照できます。</target>
        </trans-unit>
        <trans-unit id="e15bc878f1b5a7c697e8423bcee242bc5167d6a2" translate="yes" xml:space="preserve">
          <source>Another possibility is to store the documents as simple text files in the file system. In this case, the database can be used to store the full text index and to execute searches, and some unique identifier can be used to retrieve the document from the file system. However, retrieving files from outside the database requires superuser permissions or special function support, so this is usually less convenient than keeping all the data inside PostgreSQL. Also, keeping everything inside the database allows easy access to document metadata to assist in indexing and display.</source>
          <target state="translated">別の可能性としては、文書をファイルシステム内の単純なテキストファイルとして格納することが考えられる。この場合、データベースを使用してフルテキストインデックスを格納したり、検索を実行したりすることができ、ファイルシステムから文書を取得するためにいくつかのユニークな識別子を使用することができます。しかし、データベースの外部からファイルを取得するには、スーパーユーザ権限や特別な関数のサポートが必要なため、通常はすべてのデータをPostgreSQLの内部に保持するよりも便利ではありません。また、すべてのデータをデータベース内に保持することで、文書のメタデータに簡単にアクセスしてインデックス作成や表示を支援することができます。</target>
        </trans-unit>
        <trans-unit id="8fbada3201971de13171c32bf7cda835bc3fd1af" translate="yes" xml:space="preserve">
          <source>Another possible type of join is a merge join, illustrated here:</source>
          <target state="translated">もう一つの可能性のある結合のタイプは、マージ結合です。</target>
        </trans-unit>
        <trans-unit id="19829ac1739436800f592d8b7c21c52fef4c33d8" translate="yes" xml:space="preserve">
          <source>Another possible use for a partial index is to exclude values from the index that the typical query workload is not interested in; this is shown in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;Example 11.2&lt;/a&gt;. This results in the same advantages as listed above, but it prevents the &amp;ldquo;uninteresting&amp;rdquo; values from being accessed via that index, even if an index scan might be profitable in that case. Obviously, setting up partial indexes for this kind of scenario will require a lot of care and experimentation.</source>
          <target state="translated">部分インデックスのもう1つの可能な使用法は、典型的なクエリのワークロードが関心のないインデックスから値を除外することです。これを&lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX2&quot;&gt;例11.2に&lt;/a&gt;示します。これにより、上記と同じ利点が得られますが、その場合、インデックススキャンが有益である場合でも、そのインデックスを介して「興味のない」値にアクセスできなくなります。明らかに、この種のシナリオで部分インデックスを設定するには、多くの注意と実験が必要になります。</target>
        </trans-unit>
        <trans-unit id="f28a354a8ba88184cb3beacb89675afbd6c03d21" translate="yes" xml:space="preserve">
          <source>Another production-grade approach to managing log output is to send it to syslog and let syslog deal with file rotation. To do this, set the configuration parameter &lt;code&gt;log_destination&lt;/code&gt; to &lt;code&gt;syslog&lt;/code&gt; (to log to syslog only) in &lt;code&gt;postgresql.conf&lt;/code&gt;. Then you can send a &lt;code&gt;SIGHUP&lt;/code&gt; signal to the syslog daemon whenever you want to force it to start writing a new log file. If you want to automate log rotation, the logrotate program can be configured to work with log files from syslog.</source>
          <target state="translated">ログ出力を管理するための別の本番環境レベルのアプローチは、ログをsyslogに送信し、syslogにファイルローテーションを処理させることです。これを行うには、 &lt;code&gt;postgresql.conf&lt;/code&gt; で構成パラメーター &lt;code&gt;log_destination&lt;/code&gt; を &lt;code&gt;syslog&lt;/code&gt; に設定します（syslogにのみログを記録するため）。その後、新しいログファイルの書き込みを強制的に開始したい場合はいつでも、syslogデーモンに &lt;code&gt;SIGHUP&lt;/code&gt; シグナルを送信できます。ログローテーションを自動化する場合は、syslogのログファイルを使用するようにlogrotateプログラムを構成できます。</target>
        </trans-unit>
        <trans-unit id="0d7e78b3e262e81affaac44d4c64dc15d4edfbba" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;FOR UPDATE&lt;/code&gt; is that without it, a subsequent &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; might fail if the cursor query does not meet the SQL standard's rules for being &amp;ldquo;simply updatable&amp;rdquo; (in particular, the cursor must reference just one table and not use grouping or &lt;code&gt;ORDER BY&lt;/code&gt;). Cursors that are not simply updatable might work, or might not, depending on plan choice details; so in the worst case, an application might work in testing and then fail in production. If &lt;code&gt;FOR UPDATE&lt;/code&gt; is specified, the cursor is guaranteed to be updatable.</source>
          <target state="translated">&lt;code&gt;FOR UPDATE&lt;/code&gt; を使用するもう1つの理由は、FOR UPDATEがないと、カーソルクエリがSQL規格の「単純に更新可能」であるという規則を満たさない場合、後続の &lt;code&gt;WHERE CURRENT OF&lt;/code&gt; が失敗する可能性があるためです（特に、カーソルは1つのテーブルのみを参照し、グループ化を使用しないでください）または &lt;code&gt;ORDER BY&lt;/code&gt; ）。単に更新可能ではないカーソルは、計画の選択の詳細によっては機能する場合と機能しない場合があります。したがって、最悪の場合、アプリケーションはテストで機能し、その後本番環境で失敗する可能性があります。場合は &lt;code&gt;FOR UPDATE&lt;/code&gt; が指定され、カーソルが更新可能であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="6f33d845713febc0898090d451e4ee3ef8ebffb5" translate="yes" xml:space="preserve">
          <source>Another requirement for a multiple-data-type family is that any implicit or binary-coercion casts that are defined between data types included in the operator family must not change the associated sort ordering.</source>
          <target state="translated">複数データ型ファミリのもう一つの要件は、演算子ファミリに含まれるデータ型間で定義される暗黙的またはバイナリ強制キャストは、関連するソート順序を変更してはならないということです。</target>
        </trans-unit>
        <trans-unit id="9114df95c9c9d6782e38dbaee1edab69dd63ee66" translate="yes" xml:space="preserve">
          <source>Another response could be this:</source>
          <target state="translated">もう一つの対応はこれかもしれません。</target>
        </trans-unit>
        <trans-unit id="67c38a78e448cde09317f71b64feae68f30e256d" translate="yes" xml:space="preserve">
          <source>Another risk of data loss is posed by the disk platter write operations themselves. Disk platters are divided into sectors, commonly 512 bytes each. Every physical read or write operation processes a whole sector. When a write request arrives at the drive, it might be for some multiple of 512 bytes (PostgreSQL typically writes 8192 bytes, or 16 sectors, at a time), and the process of writing could fail due to power loss at any time, meaning some of the 512-byte sectors were written while others were not. To guard against such failures, PostgreSQL periodically writes full page images to permanent WAL storage &lt;em&gt;before&lt;/em&gt; modifying the actual page on disk. By doing this, during crash recovery PostgreSQL can restore partially-written pages from WAL. If you have file-system software that prevents partial page writes (e.g., ZFS), you can turn off this page imaging by turning off the &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; parameter. Battery-Backed Unit (BBU) disk controllers do not prevent partial page writes unless they guarantee that data is written to the BBU as full (8kB) pages.</source>
          <target state="translated">データ損失の別のリスクは、ディスクプラッターの書き込み操作自体によってもたらされます。ディスクプラッターはセクターに分割され、通常はそれぞれ512バイトです。すべての物理的な読み取りまたは書き込み操作は、セクター全体を処理します。書き込み要求がドライブに到着すると、512バイトの倍数である可能性があり（PostgreSQLは通常、一度に8192バイト、つまり16セクターを書き込みます）、電力損失が原因で書き込み処理がいつでも失敗する可能性があります。 512バイトのセクターの一部は書き込まれましたが、書き込まれなかったセクターもあります。このような障害を防ぐために、PostgreSQLは定期的にフルページのイメージを永続的なWALストレージ&lt;em&gt;に&lt;/em&gt;定期的に書き込みます。&lt;em&gt;&lt;/em&gt;ディスク上の実際のページを変更します。これにより、クラッシュリカバリ中にPostgreSQLはWALから部分的に書き込まれたページを復元できます。部分的なページ書き込みを防止するファイルシステムソフトウェア（ZFSなど）がある場合は、&lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt;パラメーターをオフにすることで、このページイメージングをオフにできます。バッテリーバックアップユニット（BBU）ディスクコントローラーは、データが完全な（8kB）ページとしてBBUに書き込まれることを保証しない限り、部分的なページ書き込みを防止しません。</target>
        </trans-unit>
        <trans-unit id="a64140ba6c591322306ded2e563c831d5063eb12" translate="yes" xml:space="preserve">
          <source>Another special feature is that during input, you can write &lt;code&gt;?&lt;/code&gt; in place of the check digit, and the correct check digit will be inserted automatically.</source>
          <target state="translated">もう1つの特別な機能は、入力時に次のように記述できること &lt;code&gt;?&lt;/code&gt; チェックディジットの代わりに、正しいチェックディジットが自動的に挿入されます。</target>
        </trans-unit>
        <trans-unit id="d8a7029d22a4fea1aec3f6a0a7967d7366ab11c8" translate="yes" xml:space="preserve">
          <source>Another special syntactical behavior associated with composite values is that we can use &lt;em&gt;functional notation&lt;/em&gt; for extracting a field of a composite value. The simple way to explain this is that the notations &lt;code&gt;field(table)&lt;/code&gt; and &lt;code&gt;table.field&lt;/code&gt; are interchangeable. For example, these queries are equivalent:</source>
          <target state="translated">複合値に関連付けられているもう1つの特別な構文動作は、複合&lt;em&gt;表記&lt;/em&gt;のフィールドを抽出するために&lt;em&gt;関数表記&lt;/em&gt;を使用できることです。これを説明する簡単な方法は、 &lt;code&gt;field(table)&lt;/code&gt; と &lt;code&gt;table.field&lt;/code&gt; の表記が交換可能であることです。たとえば、これらのクエリは同等です。</target>
        </trans-unit>
        <trans-unit id="2d14ebbe44cc336bb06782ca5c2e2a5afdbf5d04" translate="yes" xml:space="preserve">
          <source>Another type of extra information is the number of rows removed by a filter condition:</source>
          <target state="translated">別のタイプの追加情報は、フィルタ条件によって削除された行の数です。</target>
        </trans-unit>
        <trans-unit id="de04ff7f29beb7d9f803262abe6fbc7f7a247ce7" translate="yes" xml:space="preserve">
          <source>Another type of statistics stored for each column are most-common value lists. This allows very accurate estimates for individual columns, but may result in significant misestimates for queries with conditions on multiple columns.</source>
          <target state="translated">各カラムに対して保存されるもう一つのタイプの統計量は、最も一般的な値のリストです。これにより、個々のカラムに対して非常に正確な推定値を得ることができますが、複数のカラムに条件があるクエリでは、大幅な誤推定値が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="aef386cf940d64dd2d0246974eb986d99db04233" translate="yes" xml:space="preserve">
          <source>Another useful tool for monitoring database activity is the &lt;code&gt;pg_locks&lt;/code&gt; system table. It allows the database administrator to view information about the outstanding locks in the lock manager. For example, this capability can be used to:</source>
          <target state="translated">データベースアクティビティを監視するためのもう1つの便利なツールは、 &lt;code&gt;pg_locks&lt;/code&gt; システムテーブルです。これにより、データベース管理者は、ロックマネージャの未処理のロックに関する情報を表示できます。たとえば、この機能は次の目的で使用できます。</target>
        </trans-unit>
        <trans-unit id="973de1b89f5a19d8493a281c676145e3c2762491" translate="yes" xml:space="preserve">
          <source>Another value expression in parentheses (used to group subexpressions and override precedence)</source>
          <target state="translated">括弧内の別の値式 (副式をグループ化して優先順位を上書きするために使用)</target>
        </trans-unit>
        <trans-unit id="6edaee98c73d284626179be9ad3ba0277589e38b" translate="yes" xml:space="preserve">
          <source>Another way to accomplish the same thing:</source>
          <target state="translated">同じことを達成するための別の方法。</target>
        </trans-unit>
        <trans-unit id="7a50bf5d6a0c79646db228f587b35fc8dbea931f" translate="yes" xml:space="preserve">
          <source>Another way to do it is:</source>
          <target state="translated">もう一つの方法としては</target>
        </trans-unit>
        <trans-unit id="09b69091260be1fa872b4a938337bcecea2b0096" translate="yes" xml:space="preserve">
          <source>Another way to get the same effect is to use the &lt;code&gt;regclass&lt;/code&gt; alias type, which will print the table OID symbolically:</source>
          <target state="translated">同じ効果を得る別の方法は、 &lt;code&gt;regclass&lt;/code&gt; エイリアスタイプを使用することです。これにより、テーブルのOIDがシンボリックに出力されます。</target>
        </trans-unit>
        <trans-unit id="77f482e38cebbd37d2bd4865436228573a9f332c" translate="yes" xml:space="preserve">
          <source>Another way to obtain the same result as &lt;code&gt;\copy ... to&lt;/code&gt; is to use the SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; command and terminate it with &lt;code&gt;\g filename&lt;/code&gt; or &lt;code&gt;\g |program&lt;/code&gt;. Unlike &lt;code&gt;\copy&lt;/code&gt;, this method allows the command to span multiple lines; also, variable interpolation and backquote expansion can be used.</source>
          <target state="translated">&lt;code&gt;\copy ... to&lt;/code&gt; と同じ結果を得る別の方法は、SQL &lt;code&gt;COPY ... TO STDOUT&lt;/code&gt; コマンドを使用して、 &lt;code&gt;\g filename&lt;/code&gt; または &lt;code&gt;\g |program&lt;/code&gt; 終了することです。 &lt;code&gt;\copy&lt;/code&gt; とは異なり、この方法ではコマンドが複数行にまたがることができます。また、変数補間とバッククォート拡張を使用できます。</target>
        </trans-unit>
        <trans-unit id="af0ee54bbb9066194d74463e9d95fe7b567d2abb" translate="yes" xml:space="preserve">
          <source>Another way to return multiple columns is to use a &lt;code&gt;TABLE&lt;/code&gt; function:</source>
          <target state="translated">複数の列を返す別の方法は、 &lt;code&gt;TABLE&lt;/code&gt; 関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="886fca6d2b20a157de482df72d3dea2c336eadc6" translate="yes" xml:space="preserve">
          <source>Another way to think about a discrete range type is that there is a clear idea of a &amp;ldquo;next&amp;rdquo; or &amp;ldquo;previous&amp;rdquo; value for each element value. Knowing that, it is possible to convert between inclusive and exclusive representations of a range's bounds, by choosing the next or previous element value instead of the one originally given. For example, in an integer range type &lt;code&gt;[4,8]&lt;/code&gt; and &lt;code&gt;(3,9)&lt;/code&gt; denote the same set of values; but this would not be so for a range over numeric.</source>
          <target state="translated">離散範囲タイプについて考えるもう1つの方法は、各要素の値に「次の」または「前の」値の明確なアイデアがあるということです。それを知って、最初に与えられたものの代わりに次または前の要素値を選択することによって、範囲の境界の包括的表現と排他的表現の間で変換することが可能です。たとえば、整数の範囲では、タイプ &lt;code&gt;[4,8]&lt;/code&gt; と &lt;code&gt;(3,9)&lt;/code&gt; は同じ値のセットを示します。しかし、これは数値を超える範囲には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="d84849349152ff8e618adbfaeb1704c4dc99ecf7" translate="yes" xml:space="preserve">
          <source>Another way to work with angles measured in degrees is to use the unit transformation functions &lt;code&gt;radians()&lt;/code&gt; and &lt;code&gt;degrees()&lt;/code&gt; shown earlier. However, using the degree-based trigonometric functions is preferred, as that way avoids round-off error for special cases such as &lt;code&gt;sind(30)&lt;/code&gt;.</source>
          <target state="translated">度で測定された角度を操作する別の方法は、前に示した単位変換関数 &lt;code&gt;radians()&lt;/code&gt; および &lt;code&gt;degrees()&lt;/code&gt; を使用することです。ただし、次数に基づく三角関数を使用することをお &lt;code&gt;sind(30)&lt;/code&gt; ます。これにより、sind（30）などの特殊な場合の丸め誤差が回避されます。</target>
        </trans-unit>
        <trans-unit id="efdd30de2aea5b5d5befd3533f098d92f63380ab" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;EXECUTE&lt;/code&gt;, &lt;code&gt;DECLARE&lt;/code&gt;, &lt;code&gt;CREATE TABLE AS&lt;/code&gt;, or &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; statement, whose execution plan you wish to see.</source>
          <target state="translated">任意の &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;VALUES&lt;/code&gt; 、 &lt;code&gt;EXECUTE&lt;/code&gt; 、 &lt;code&gt;DECLARE&lt;/code&gt; 、 &lt;code&gt;CREATE TABLE AS&lt;/code&gt; 、または &lt;code&gt;CREATE MATERIALIZED VIEW AS&lt;/code&gt; 実行計画あなたが見たい文を、。</target>
        </trans-unit>
        <trans-unit id="386ffc8dd49c3fb7f2ddd349b2b9b4201e8b40ad" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; statement.</source>
          <target state="translated">任意の &lt;code&gt;SELECT&lt;/code&gt; 、 &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、または &lt;code&gt;VALUES&lt;/code&gt; の声明。</target>
        </trans-unit>
        <trans-unit id="450e11982aec06ef4f3dbb171ba6a8eb1e20a7be" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly or explicitly; therefore, the functions shown above as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value. In addition, you can cast a text value to &lt;code&gt;inet&lt;/code&gt; or &lt;code&gt;cidr&lt;/code&gt; using normal casting syntax: for example, &lt;code&gt;inet(expression)&lt;/code&gt; or &lt;code&gt;colname::cidr&lt;/code&gt;.</source>
          <target state="translated">任意の &lt;code&gt;cidr&lt;/code&gt; 値を暗黙的または明示的に &lt;code&gt;inet&lt;/code&gt; にキャストできます。したがって、 &lt;code&gt;inet&lt;/code&gt; で動作する上記の関数は、 &lt;code&gt;cidr&lt;/code&gt; 値でも機能します。 （ &lt;code&gt;inet&lt;/code&gt; と &lt;code&gt;cidr&lt;/code&gt; に別個の関数がある場合、これは2つのケースで動作が異なるためです。）また、 &lt;code&gt;inet&lt;/code&gt; 値を &lt;code&gt;cidr&lt;/code&gt; にキャストすることもできます。これが行われると、ネットマスクの右側にあるビットはすべて、有効な &lt;code&gt;cidr&lt;/code&gt; 値を作成するために警告なしにゼロ化されます。さらに、通常のキャスト構文を使用して、テキスト値を &lt;code&gt;inet&lt;/code&gt; または &lt;code&gt;cidr&lt;/code&gt; にキャストできます。たとえば、 &lt;code&gt;inet(expression)&lt;/code&gt; または &lt;code&gt;colname::cidr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8208175702ffb5cdd4ede5051892cf19b0e69014" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;cidr&lt;/code&gt; value can be cast to &lt;code&gt;inet&lt;/code&gt; implicitly; therefore, the operators and functions shown below as operating on &lt;code&gt;inet&lt;/code&gt; also work on &lt;code&gt;cidr&lt;/code&gt; values. (Where there are separate functions for &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;cidr&lt;/code&gt;, it is because the behavior should be different for the two cases.) Also, it is permitted to cast an &lt;code&gt;inet&lt;/code&gt; value to &lt;code&gt;cidr&lt;/code&gt;. When this is done, any bits to the right of the netmask are silently zeroed to create a valid &lt;code&gt;cidr&lt;/code&gt; value.</source>
          <target state="translated">任意の &lt;code&gt;cidr&lt;/code&gt; 値を暗黙的に &lt;code&gt;inet&lt;/code&gt; にキャストできます。したがって、 &lt;code&gt;inet&lt;/code&gt; を操作するものとして以下に示す演算子と関数は、 &lt;code&gt;cidr&lt;/code&gt; 値でも機能します。（ &lt;code&gt;inet&lt;/code&gt; と &lt;code&gt;cidr&lt;/code&gt; に別々の関数がある場合、2つのケースで動作が異なる必要があるためです。）また、 &lt;code&gt;inet&lt;/code&gt; 値を &lt;code&gt;cidr&lt;/code&gt; にキャストすることもできます。これが行われると、ネットマスクの右側のビットがサイレントにゼロ化され、有効な &lt;code&gt;cidr&lt;/code&gt; 値が作成されます。</target>
        </trans-unit>
        <trans-unit id="97a5e9f25fdf2d6789317985300af494edaa42f6" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The condition expression cannot refer to any tables except &lt;code&gt;NEW&lt;/code&gt; and &lt;code&gt;OLD&lt;/code&gt;, and cannot contain aggregate functions.</source>
          <target state="translated">任意のSQL条件式（ &lt;code&gt;boolean&lt;/code&gt; 返します）。条件式は &lt;code&gt;NEW&lt;/code&gt; および &lt;code&gt;OLD&lt;/code&gt; 以外のテーブルを参照できません。また、集計関数を含めることもできません。</target>
        </trans-unit>
        <trans-unit id="7f04645af195b0769f156d1c9178d5413d13947d" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be added to queries that refer to the table if row level security is enabled. Rows for which the expression returns true will be visible. Any rows for which the expression returns false or null will not be visible to the user (in a &lt;code&gt;SELECT&lt;/code&gt;), and will not be available for modification (in an &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;). Such rows are silently suppressed; no error is reported.</source>
          <target state="translated">任意のSQL条件式（ &lt;code&gt;boolean&lt;/code&gt; 返します）。条件式に集計関数やウィンドウ関数を含めることはできません。行レベルのセキュリティが有効になっている場合、この式はテーブルを参照するクエリに追加されます。式がtrueを返す行が表示されます。式がfalseまたはnullを返す行は、ユーザーには表示されず（ &lt;code&gt;SELECT&lt;/code&gt; で）、変更できません（ &lt;code&gt;UPDATE&lt;/code&gt; または &lt;code&gt;DELETE&lt;/code&gt; で）。そのような行は黙って抑制されます。エラーは報告されません。</target>
        </trans-unit>
        <trans-unit id="9d0a8e5978d0613618d7d621bf1cd5c083979c7e" translate="yes" xml:space="preserve">
          <source>Any SQL conditional expression (returning &lt;code&gt;boolean&lt;/code&gt;). The conditional expression cannot contain any aggregate or window functions. This expression will be used in &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; queries against the table if row level security is enabled. Only rows for which the expression evaluates to true will be allowed. An error will be thrown if the expression evaluates to false or null for any of the records inserted or any of the records that result from the update. Note that the &lt;code&gt;check_expression&lt;/code&gt; is evaluated against the proposed new contents of the row, not the original contents.</source>
          <target state="translated">任意のSQL条件式（ &lt;code&gt;boolean&lt;/code&gt; 返します）。条件式に集計関数やウィンドウ関数を含めることはできません。この式は、行レベルのセキュリティが有効になっている場合、テーブルに対する &lt;code&gt;INSERT&lt;/code&gt; および &lt;code&gt;UPDATE&lt;/code&gt; クエリで使用されます。式がtrueと評価される行のみが許可されます。挿入されたいずれかのレコード、または更新の結果として生じたいずれかのレコードに対して式がfalseまたはnullと評価された場合、エラーがスローされます。 &lt;code&gt;check_expression&lt;/code&gt; は、元のコンテンツではなく、行の提案された新しいコンテンツに対して評価されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e356ac9cfe76e1d8f07ddb1a43d7eac6d271ea2" translate="yes" xml:space="preserve">
          <source>Any character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set is replaced by the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are removed.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;セットの&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;と一致する&lt;em&gt;string&lt;/em&gt;内の&lt;em&gt;文字&lt;/em&gt;は、&lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;セットの対応する文字に置き換えられます。場合&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;より長い&lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;、中に余分な文字の出現&lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt;削除されます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12f81b0886507c6c81c137ed43e36901064a888a" translate="yes" xml:space="preserve">
          <source>Any developer of a new &lt;code&gt;table access method&lt;/code&gt; can refer to the existing &lt;code&gt;heap&lt;/code&gt; implementation present in &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; for details of its implementation.</source>
          <target state="translated">新しい &lt;code&gt;table access method&lt;/code&gt; 開発者は、その実装の詳細について、 &lt;code&gt;src/backend/access/heap/heapam_handler.c&lt;/code&gt; にある既存の &lt;code&gt;heap&lt;/code&gt; 実装を参照できます。</target>
        </trans-unit>
        <trans-unit id="144550beabeed185659254b872d28c678638c93a" translate="yes" xml:space="preserve">
          <source>Any digest algorithm OpenSSL supports is automatically picked up. This is not possible with ciphers, which need to be supported explicitly.</source>
          <target state="translated">OpenSSL がサポートするすべてのダイジェストアルゴリズムは自動的にピックアップされます。これは、明示的にサポートされている必要がある暗号では不可能です。</target>
        </trans-unit>
        <trans-unit id="c4c8c401fe264a209ebccf99c5f886fc113da7d7" translate="yes" xml:space="preserve">
          <source>Any file or directory beginning with &lt;code&gt;pgsql_tmp&lt;/code&gt; can be omitted from the backup. These files are removed on postmaster start and the directories will be recreated as needed.</source>
          <target state="translated">&lt;code&gt;pgsql_tmp&lt;/code&gt; で始まるファイルまたはディレクトリは、バックアップから除外できます。これらのファイルはpostmasterの起動時に削除され、ディレクトリは必要に応じて再作成されます。</target>
        </trans-unit>
        <trans-unit id="a836141ba30a8aa1360f43439d3c24535024a80a" translate="yes" xml:space="preserve">
          <source>Any generation expressions of copied column definitions will be copied. By default, new columns will be regular base columns.</source>
          <target state="translated">コピーされた列定義の生成式はすべてコピーされます。デフォルトでは、新しいカラムは通常の基底カラムになります。</target>
        </trans-unit>
        <trans-unit id="5e18734ff6a37a9bb9fd3457eedcb31fb70163d6" translate="yes" xml:space="preserve">
          <source>Any identity specifications of copied column definitions will be copied. A new sequence is created for each identity column of the new table, separate from the sequences associated with the old table.</source>
          <target state="translated">コピーされた列定義のすべての同一性指定はコピーされます。新しいテーブルの各 ID 列に対して、古いテーブルに関連付けられたシーケンスとは別に、新しいシーケンスが作成されます。</target>
        </trans-unit>
        <trans-unit id="feba919d6ac95ebb1703749287894bc69e982374" translate="yes" xml:space="preserve">
          <source>Any memberships in the group role are automatically revoked (but the member roles are not otherwise affected).</source>
          <target state="translated">グループ・ロール内のすべてのメンバーシップは自動的に取り消されます(ただし、メンバー・ロールには他の影響はありません)。</target>
        </trans-unit>
        <trans-unit id="13a56d22fdbd5ea4aa4d99bf869d62836d2a9dbc" translate="yes" xml:space="preserve">
          <source>Any object that can be created with a &lt;code&gt;CREATE&lt;/code&gt; command. Most objects are specific to one database, and are commonly known as &lt;em&gt;local objects&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE&lt;/code&gt; コマンドで作成できるすべてのオブジェクト。ほとんどのオブジェクトは1つのデータベースに固有であり、一般に&lt;em&gt;ローカルオブジェクト&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="f42a74d5d4ceddfdc2731676cd56c9941e931e10" translate="yes" xml:space="preserve">
          <source>Any other backslashed character that is not mentioned in the above table will be taken to represent itself. However, beware of adding backslashes unnecessarily, since that might accidentally produce a string matching the end-of-data marker (&lt;code&gt;\.&lt;/code&gt;) or the null string (&lt;code&gt;\N&lt;/code&gt; by default). These strings will be recognized before any other backslash processing is done.</source>
          <target state="translated">上記の表に記載されていないその他の円記号は、それ自体を表すために使用されます。ただし、バックスラッシュを不必要に追加すると、データの終わりマーカー（ &lt;code&gt;\.&lt;/code&gt; ）またはnull文字列（デフォルトでは &lt;code&gt;\N&lt;/code&gt; ）に一致する文字列が誤って生成される可能性があるため、注意してください。これらの文字列は、他のバックスラッシュ処理が行われる前に認識されます。</target>
        </trans-unit>
        <trans-unit id="59556037a647190d9808748d3940223c9b60fa38" translate="yes" xml:space="preserve">
          <source>Any other character following a backslash is taken literally. Thus, to include a backslash character, write two backslashes (&lt;code&gt;\\&lt;/code&gt;). Also, a single quote can be included in an escape string by writing &lt;code&gt;\'&lt;/code&gt;, in addition to the normal way of &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">バックスラッシュに続く他の文字は文字通りに解釈されます。したがって、バックスラッシュ文字を含めるには、2つのバックスラッシュ（ &lt;code&gt;\\&lt;/code&gt; ）を記述します。また、 &lt;code&gt;''&lt;/code&gt; の通常の方法に加えて、 &lt;code&gt;\'&lt;/code&gt; と書くことにより、単一引用符をエスケープ文字列に含めることができます。</target>
        </trans-unit>
        <trans-unit id="deecfecd8837d0982d5dc84b37df7cbf1f0b77cf" translate="yes" xml:space="preserve">
          <source>Any process, possibly remote, that establishes a &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;session&lt;/a&gt; by &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connecting&lt;/a&gt; to an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to interact with a &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;データベース&lt;/a&gt;と対話するために&lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;インスタンス&lt;/a&gt;に&lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;接続&lt;/a&gt;することによって&lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;セッション&lt;/a&gt;を確立する、場合によってはリモートのプロセス。</target>
        </trans-unit>
        <trans-unit id="6176992a355fd17e3c78216ef8246e171f7a7f5d" translate="yes" xml:space="preserve">
          <source>Any rows whose updated values do not pass the &lt;code&gt;WITH CHECK&lt;/code&gt; expression will cause an error, and the entire command will be aborted. If only a &lt;code&gt;USING&lt;/code&gt; clause is specified, then that clause will be used for both &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;WITH CHECK&lt;/code&gt; cases.</source>
          <target state="translated">更新された値が &lt;code&gt;WITH CHECK&lt;/code&gt; 式を通過しない行があると、エラーが発生し、コマンド全体が中止されます。 &lt;code&gt;USING&lt;/code&gt; 句のみが指定されている場合、その句は &lt;code&gt;USING&lt;/code&gt; と &lt;code&gt;WITH CHECK&lt;/code&gt; の両方のケースで使用されます。</target>
        </trans-unit>
        <trans-unit id="e53b9947d34df736f27a314411d8d097ccb99c38" translate="yes" xml:space="preserve">
          <source>Any two opposite corners can be supplied on input, but the values will be reordered as needed to store the upper right and lower left corners, in that order.</source>
          <target state="translated">入力時に任意の2つの反対側の角を与えることができますが、値は必要に応じて、右上と左下の角を格納するために、その順番に並べ替えられます。</target>
        </trans-unit>
        <trans-unit id="9cd48f92d0048ad74a4b2a1c77759555487aa4a5" translate="yes" xml:space="preserve">
          <source>Any value of &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; greater than 0 selects the shortest-precise format.</source>
          <target state="translated">いずれかの値&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; 0選択最短正確な形式よりも大きいです。</target>
        </trans-unit>
        <trans-unit id="6e1092ad7e1aa0d329dcf1a1dc88a2fd1167428b" translate="yes" xml:space="preserve">
          <source>Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands.</source>
          <target state="translated">psqlに入力したもので、引用符なしのバックスラッシュで始まるものはすべてpsqlメタコマンドで、psql自身が処理します。これらのコマンドにより、psqlは管理やスクリプトをより便利にします。メタコマンドは、スラッシュコマンドやバックスラッシュコマンドと呼ばれることが多いです。</target>
        </trans-unit>
        <trans-unit id="ca34db883b90f5136d142c2d8962aac808f06344" translate="yes" xml:space="preserve">
          <source>Append the server log output to &lt;code&gt;filename&lt;/code&gt;. If the file does not exist, it is created. The umask is set to 077, so access to the log file is disallowed to other users by default.</source>
          <target state="translated">サーバーログ出力を &lt;code&gt;filename&lt;/code&gt; に追加します。ファイルが存在しない場合は作成されます。umaskは077に設定されているため、デフォルトでは、ログファイルへのアクセスは他のユーザーに許可されていません。</target>
        </trans-unit>
        <trans-unit id="8837d91fde54bfbd4c7276bc104dbd7eb57e326a" translate="yes" xml:space="preserve">
          <source>Appendix A. PostgreSQL Error Codes</source>
          <target state="translated">付録A.PostgreSQLエラーコード</target>
        </trans-unit>
        <trans-unit id="8f525f98762ab18cc61fb77a68f4661a9eaa0966" translate="yes" xml:space="preserve">
          <source>Appendix B. Date/Time Support</source>
          <target state="translated">付録B.日付/時間のサポート</target>
        </trans-unit>
        <trans-unit id="0a4fd0d75b5e8cb67c2577d915d2f158e36d619c" translate="yes" xml:space="preserve">
          <source>Appendix C. SQL Key Words</source>
          <target state="translated">付録 C.SQLのキーワード</target>
        </trans-unit>
        <trans-unit id="2d3d6ce5d75b048ec4b4bfd56085229d360ae080" translate="yes" xml:space="preserve">
          <source>Appendix D. SQL Conformance</source>
          <target state="translated">付録D.SQLの適合性</target>
        </trans-unit>
        <trans-unit id="1c760d4057771bdbd912b1a26d17b99309626b19" translate="yes" xml:space="preserve">
          <source>Appendix E. Release Notes</source>
          <target state="translated">付録 E.リリースノート</target>
        </trans-unit>
        <trans-unit id="3cc083a7e98cb9a510c3b8e9fe828f669dae8eb2" translate="yes" xml:space="preserve">
          <source>Appendix F. Additional Supplied Modules</source>
          <target state="translated">付録F.追加供給モジュール</target>
        </trans-unit>
        <trans-unit id="0a757b9f46902730f7dbc09c2b987bcc9b1402c2" translate="yes" xml:space="preserve">
          <source>Appendix G. Additional Supplied Programs</source>
          <target state="translated">付録G.追加供給されたプログラム</target>
        </trans-unit>
        <trans-unit id="f731ac7aad79287ad6a9d70b29b7d9f22f9d74ad" translate="yes" xml:space="preserve">
          <source>Appendix K. PostgreSQL Limits</source>
          <target state="translated">付録K.PostgreSQLの限界</target>
        </trans-unit>
        <trans-unit id="6b2f6b4afe56f03c3636cff98cc090e912a2978a" translate="yes" xml:space="preserve">
          <source>Appendix L. Acronyms</source>
          <target state="translated">付録L.略語</target>
        </trans-unit>
        <trans-unit id="f60b3f6b35cf4c13bfaa5fa9f25882503add453a" translate="yes" xml:space="preserve">
          <source>Appendix M. Glossary</source>
          <target state="translated">付録M.用語集</target>
        </trans-unit>
        <trans-unit id="ea37fd5c2add8dc11cd4eac4e99886acbe263edc" translate="yes" xml:space="preserve">
          <source>Appendix N. Color Support</source>
          <target state="translated">付録N.カラーサポート</target>
        </trans-unit>
        <trans-unit id="5e2daf479a3e3b6ca8645aabab30691c459271fc" translate="yes" xml:space="preserve">
          <source>Appendix: Additional Supplied Modules</source>
          <target state="translated">付録 追加供給モジュール</target>
        </trans-unit>
        <trans-unit id="212a37d7af38255a5010be41cf96e1919f1f65fe" translate="yes" xml:space="preserve">
          <source>Appendix: Color Support</source>
          <target state="translated">付録 カラーサポート</target>
        </trans-unit>
        <trans-unit id="5fe175a1da37b9c50cabd865124df334aa3597f0" translate="yes" xml:space="preserve">
          <source>Appendix: Date/Time Support</source>
          <target state="translated">付録です。日付・時間のサポート</target>
        </trans-unit>
        <trans-unit id="a8d8b25f2c37eff5457e8db6ccb6dece99f46eb0" translate="yes" xml:space="preserve">
          <source>Appendix: SQL Conformance</source>
          <target state="translated">付録:SQLの適合性</target>
        </trans-unit>
        <trans-unit id="1f6da0679b0bcee42966e5109a37944191c26ca8" translate="yes" xml:space="preserve">
          <source>Appendixes</source>
          <target state="translated">Appendixes</target>
        </trans-unit>
        <trans-unit id="2fc28e50f7d7e95a87ebbb410bfe469fb51248d4" translate="yes" xml:space="preserve">
          <source>Appends an element to the end of an array (same as the &lt;code&gt;anyarray&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;anyelement&lt;/code&gt; operator).</source>
          <target state="translated">配列の最後に要素を追加します（ &lt;code&gt;anyarray&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;anyelement&lt;/code&gt; 演算子と同じ）。</target>
        </trans-unit>
        <trans-unit id="99005fc867cd3e54c80bd91ee175bcce277708d9" translate="yes" xml:space="preserve">
          <source>Applicable Object Types</source>
          <target state="translated">適用オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="a63f73a380e6bb14bdd2ad6b10a8f68e5d42a5ad" translate="yes" xml:space="preserve">
          <source>Application Programming Interface</source>
          <target state="translated">アプリケーションプログラミングインタフェース</target>
        </trans-unit>
        <trans-unit id="2f16f8fd5e0553e004d0e86eda56a845aa102673" translate="yes" xml:space="preserve">
          <source>Application name</source>
          <target state="translated">アプリケーション名</target>
        </trans-unit>
        <trans-unit id="b03ebc2274f172652f6125e87dba0dd896ad4421" translate="yes" xml:space="preserve">
          <source>Application of Multiple Policies</source>
          <target state="translated">複数のポリシーの適用</target>
        </trans-unit>
        <trans-unit id="00135b8aa11b060725023cffb44e0b589a9f25a0" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with queries accessing the target page on the standby, whether or not the data to be removed is visible.</source>
          <target state="translated">WALからのバキュームクリーンアップレコードの適用は、削除対象のデータが表示されているかどうかに関わらず、待機中の対象ページにアクセスするクエリと競合します。</target>
        </trans-unit>
        <trans-unit id="3256ed72d4783ec493be93406d6bd97d0d7b90f1" translate="yes" xml:space="preserve">
          <source>Application of a vacuum cleanup record from WAL conflicts with standby transactions whose snapshots can still &amp;ldquo;see&amp;rdquo; any of the rows to be removed.</source>
          <target state="translated">WALからのバキュームクリーンアップレコードの適用は、削除する行をスナップショットがまだ「確認」できるスタンバイトランザクションと競合します。</target>
        </trans-unit>
        <trans-unit id="76c74bd071dd73f01696fddbbffc77712a479faf" translate="yes" xml:space="preserve">
          <source>Applications</source>
          <target state="translated">Applications</target>
        </trans-unit>
        <trans-unit id="6b5428213daf1d5aba6d1295a6bbb19c08864fc0" translate="yes" xml:space="preserve">
          <source>Applications that wanted precise values have historically had to set &lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt; to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.</source>
          <target state="translated">正確な値を必要とするアプリケーションは、これまで、それらを取得するために&lt;a href=&quot;runtime-config-client#GUC-EXTRA-FLOAT-DIGITS&quot;&gt;extra_float_digits&lt;/a&gt;を3に設定する必要がありました。バージョン間の最大の互換性のために、彼らはそうし続けるべきです。</target>
        </trans-unit>
        <trans-unit id="ed624d6999cad953cb5b1bedd94e985196972ebd" translate="yes" xml:space="preserve">
          <source>Applications that wish to use backslash as escape should be modified to use escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;), because the default behavior of ordinary strings is now to treat backslash as an ordinary character, per SQL standard. This variable can be enabled to help locate code that needs to be changed.</source>
          <target state="translated">バックスラッシュをエスケープとして使用するアプリケーションは、エスケープ文字列構文（ &lt;code&gt;E'...'&lt;/code&gt; ）を使用するように変更する必要があります。これは、通常の文字列のデフォルトの動作では、バックスラッシュがSQL標準に従って通常の文字として扱われるためです。この変数を有効にすると、変更が必要なコードを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="85980229b9ae48d13b46796fb33f530f87d73b8b" translate="yes" xml:space="preserve">
          <source>Applications using this level must be prepared to retry transactions due to serialization failures.</source>
          <target state="translated">このレベルを使用するアプリケーションは、シリアル化の失敗によるトランザクションの再試行に備える必要があります。</target>
        </trans-unit>
        <trans-unit id="55278f2bfbaabfad19c2fee75ec3133e8897d48a" translate="yes" xml:space="preserve">
          <source>Apply modifications to the page images obtained in the previous step.</source>
          <target state="translated">前のステップで取得したページ画像に修正を適用します。</target>
        </trans-unit>
        <trans-unit id="068d74cbbe7303d0ad643d8aa0d60cbff0956278" translate="yes" xml:space="preserve">
          <source>Apply the WAL from the source cluster, starting from the checkpoint created at failover. (Strictly speaking, pg_rewind doesn't apply the WAL, it just creates a backup label file that makes PostgreSQL start by replaying all WAL from that checkpoint forward.)</source>
          <target state="translated">フェイルオーバー時に作成されたチェックポイントから開始して、ソースクラスタからWALを適用します。(厳密に言えば、pg_rewindはWALを適用せず、単にバックアップラベルファイルを作成し、そのチェックポイントから先のすべてのWALを再生してPostgreSQLを起動させます。)</target>
        </trans-unit>
        <trans-unit id="e486b3d6c0bcfe71e975768cf7354a58fa17fa9a" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data for moving-aggregate mode, or zero to use a default estimate</source>
          <target state="translated">移動アグリゲート・モードの遷移状態データのおおよその平均サイズ(バイト単位)、またはデフォルトの推定値を使用するにはゼロ</target>
        </trans-unit>
        <trans-unit id="caafece427e1163ffa963b4dffa3cc2b00260a07" translate="yes" xml:space="preserve">
          <source>Approximate average size (in bytes) of the transition state data, or zero to use a default estimate</source>
          <target state="translated">遷移状態データのおおよその平均サイズ(バイト単位)、またはデフォルトの推定値を使用するにはゼロ</target>
        </trans-unit>
        <trans-unit id="753bf6e471b3480498401484488505d0888a0767" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from a JSON number or string</source>
          <target state="translated">JSONの数値または文字列から変換されたおおよその浮動小数点数</target>
        </trans-unit>
        <trans-unit id="d737059a7023272b67d00f7bdeb9dfcc94048eda" translate="yes" xml:space="preserve">
          <source>Approximate floating-point number converted from an SQL/JSON number or a string</source>
          <target state="translated">SQL/JSONの数値または文字列から変換されたおおよその浮動小数点数</target>
        </trans-unit>
        <trans-unit id="c0b0f0e736e61c866d8d2ac574b894e925e89613" translate="yes" xml:space="preserve">
          <source>Approximate value of &amp;pi;</source>
          <target state="translated">&amp;pi;のおおよその値</target>
        </trans-unit>
        <trans-unit id="befde54a108cb9dc6ad6e0ebd28720531a6855e6" translate="yes" xml:space="preserve">
          <source>Apr</source>
          <target state="translated">Apr</target>
        </trans-unit>
        <trans-unit id="a0393902db1f516ef5f95f6830938558a88fb23c" translate="yes" xml:space="preserve">
          <source>April</source>
          <target state="translated">April</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="2e6a8c2f54eea95c918815af873f318c8b75d1ee" translate="yes" xml:space="preserve">
          <source>Arbitrary text that serves as the description of this object</source>
          <target state="translated">このオブジェクトの説明となる任意のテキスト</target>
        </trans-unit>
        <trans-unit id="a4183b8dc44cf7f7f1da3bacb0f01f6cc6331a8b" translate="yes" xml:space="preserve">
          <source>Archaic term for a &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL record&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WALレコードの&lt;/a&gt;古風な用語。</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="c2745399d3dc1caef67349072200fb056fc4129e" translate="yes" xml:space="preserve">
          <source>Architecture: Initial Snapshot</source>
          <target state="translated">アーキテクチャ 初期スナップショット</target>
        </trans-unit>
        <trans-unit id="a57a286a92ae143de1dc965b902d9ecc2dfd66af" translate="yes" xml:space="preserve">
          <source>Are &lt;code&gt;aclitem&lt;/code&gt;s equal? (Notice that type &lt;code&gt;aclitem&lt;/code&gt; lacks the usual set of comparison operators; it has only equality. In turn, &lt;code&gt;aclitem&lt;/code&gt; arrays can only be compared for equality.)</source>
          <target state="translated">ある &lt;code&gt;aclitem&lt;/code&gt; sが等しいですか？（タイプ &lt;code&gt;aclitem&lt;/code&gt; には通常の比較演算子のセットがないことに注意してください。同等性しかありません。次に、 &lt;code&gt;aclitem&lt;/code&gt; 配列は同等性についてのみ比較できます。）</target>
        </trans-unit>
        <trans-unit id="67a9118149c6042fe6daa560647e16f79a2d3d97" translate="yes" xml:space="preserve">
          <source>Are horizontally aligned?</source>
          <target state="translated">横並びになっていますか?</target>
        </trans-unit>
        <trans-unit id="0277a553173b27be90f022d132a83d4b3aaf7ebc" translate="yes" xml:space="preserve">
          <source>Are lines parallel?</source>
          <target state="translated">線は平行なのか?</target>
        </trans-unit>
        <trans-unit id="ae62863d19a1f09ae83d96496ecb5be1da1e9570" translate="yes" xml:space="preserve">
          <source>Are lines perpendicular?</source>
          <target state="translated">直線は直角なのか?</target>
        </trans-unit>
        <trans-unit id="8897c493ba700783f2c64a4d0f20f14b01d7b1e3" translate="yes" xml:space="preserve">
          <source>Are parallel?</source>
          <target state="translated">パラレルですか?</target>
        </trans-unit>
        <trans-unit id="b0f274d71a2fb179ee895325d1f8e8eba6d7eaf4" translate="yes" xml:space="preserve">
          <source>Are points horizontally aligned (that is, have same y coordinate)?</source>
          <target state="translated">点は水平に並んでいますか?</target>
        </trans-unit>
        <trans-unit id="4fd10598c5b40d1cb91d9f056ebf89eb9d7aa121" translate="yes" xml:space="preserve">
          <source>Are points vertically aligned (that is, have same x coordinate)?</source>
          <target state="translated">点は垂直に並んでいますか?</target>
        </trans-unit>
        <trans-unit id="5cba229ff1c565c58441b7f5908ac5643aeb85b7" translate="yes" xml:space="preserve">
          <source>Are the left JSON path/value entries contained at the top level within the right JSON value?</source>
          <target state="translated">左のJSONパス/値のエントリは、右のJSON値の中にトップレベルで含まれていますか?</target>
        </trans-unit>
        <trans-unit id="7f5f796f9f81b0556b03d7a49d7711d325d01584" translate="yes" xml:space="preserve">
          <source>Are the ranges adjacent?</source>
          <target state="translated">範囲は隣接していますか?</target>
        </trans-unit>
        <trans-unit id="95ac96b9bb2b90c235c16c3c150acca2ceb1786a" translate="yes" xml:space="preserve">
          <source>Are the two &lt;code&gt;seg&lt;/code&gt;s equal?</source>
          <target state="translated">2つの &lt;code&gt;seg&lt;/code&gt; 等しいですか？</target>
        </trans-unit>
        <trans-unit id="fdbf4786edf9f977d2039f0d91270c27aa5a8043" translate="yes" xml:space="preserve">
          <source>Are these objects the same? Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">これらのオブジェクトは同じですか？以下のための利用可能な &lt;code&gt;point&lt;/code&gt; 、 &lt;code&gt;box&lt;/code&gt; 、 &lt;code&gt;polygon&lt;/code&gt; 、 &lt;code&gt;circle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ea55540eda7f3ae150bdf50ff88e357b0470bd4" translate="yes" xml:space="preserve">
          <source>Are vertically aligned?</source>
          <target state="translated">垂直に並んでいますか?</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">引数の種類</target>
        </trans-unit>
        <trans-unit id="227b299c7388311800207bda7f4dca4cbfe39510" translate="yes" xml:space="preserve">
          <source>Argument Type(s)</source>
          <target state="translated">引数タイプ</target>
        </trans-unit>
        <trans-unit id="a051df2e8379a7a94517621abf96e2d1c250d0c1" translate="yes" xml:space="preserve">
          <source>Argument strings to pass to trigger, each NULL-terminated</source>
          <target state="translated">トリガに渡す引数文字列、それぞれNULL終端</target>
        </trans-unit>
        <trans-unit id="3106eca9fcc5b17fbc0ab862b2b3e2e5d8ec1882" translate="yes" xml:space="preserve">
          <source>Arranges to save future query results to the file &lt;code&gt;filename&lt;/code&gt; or pipe future results to the shell command &lt;code&gt;command&lt;/code&gt;. If no argument is specified, the query output is reset to the standard output.</source>
          <target state="translated">将来のクエリ結果をファイル &lt;code&gt;filename&lt;/code&gt; に保存するか、将来の結果をシェルコマンド &lt;code&gt;command&lt;/code&gt; にパイプするように調整します。引数を指定しない場合、クエリ出力は標準出力にリセットされます。</target>
        </trans-unit>
        <trans-unit id="7a061ed91f80bf08d4b0e706de1a73a36b812215" translate="yes" xml:space="preserve">
          <source>Array Comparisons</source>
          <target state="translated">配列の比較</target>
        </trans-unit>
        <trans-unit id="2cce75772b9783560b7ecdf1a652525e088ff999" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ALL (array)</source>
          <target state="translated">配列の比較。ALL (配列)</target>
        </trans-unit>
        <trans-unit id="ebbce493c47b875446149a16fbeabd59af95b506" translate="yes" xml:space="preserve">
          <source>Array Comparisons: ANY/SOME (array)</source>
          <target state="translated">配列の比較。ANY/SOME (配列)</target>
        </trans-unit>
        <trans-unit id="266d7d8ad9ef21fb1cf43acafe88df1627794e31" translate="yes" xml:space="preserve">
          <source>Array Comparisons: IN</source>
          <target state="translated">配列比較。IN</target>
        </trans-unit>
        <trans-unit id="cb5525261d1827b03403d3e1f7d54e339ee3bdc7" translate="yes" xml:space="preserve">
          <source>Array Comparisons: NOT IN</source>
          <target state="translated">配列比較。ではありません。</target>
        </trans-unit>
        <trans-unit id="378bd5c012fe9a2d09b80c0502903a9f1a4e46ef" translate="yes" xml:space="preserve">
          <source>Array Functions and Operators</source>
          <target state="translated">配列関数と演算子</target>
        </trans-unit>
        <trans-unit id="1847f280fe6a7cfd6c208240da7d0ab7f1c91ffb" translate="yes" xml:space="preserve">
          <source>Array Types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="989d38553686cf9420b0efeacfb98e0cb0491104" translate="yes" xml:space="preserve">
          <source>Array element accessor. &lt;code&gt;subscript&lt;/code&gt; can be given in two forms: &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;start_index to end_index&lt;/code&gt;. The first form returns a single array element by its index. The second form returns an array slice by the range of indexes, including the elements that correspond to the provided &lt;code&gt;start_index&lt;/code&gt; and &lt;code&gt;end_index&lt;/code&gt;.</source>
          <target state="translated">配列要素アクセサー。 &lt;code&gt;subscript&lt;/code&gt; は、 &lt;code&gt;index&lt;/code&gt; または &lt;code&gt;start_index to end_index&lt;/code&gt; の 2つの形式で指定できます。最初の形式は、インデックスによって単一の配列要素を返します。2番目の形式は、指定された &lt;code&gt;start_index&lt;/code&gt; および &lt;code&gt;end_index&lt;/code&gt; に対応する要素を含む、インデックスの範囲によって配列スライスを返します。</target>
        </trans-unit>
        <trans-unit id="88048034955012a6a9f12b6c23a529e19a83c1b1" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;WHERE&lt;/code&gt;-clause filter conditions for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">拡張機能の構成テーブルの &lt;code&gt;WHERE&lt;/code&gt; 句フィルター条件の配列。存在しない場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01ffa4580cea8a6c482fb4eea9629be04c79e61e" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;regclass&lt;/code&gt; OIDs for the extension's configuration table(s), or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">拡張機能の構成テーブルの &lt;code&gt;regclass&lt;/code&gt; OIDの配列、ない場合は &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24c2e81a77c22cd6c4b27ed6a767d8a3da693d5f" translate="yes" xml:space="preserve">
          <source>Array of item identifiers pointing to the actual items. Each entry is an (offset,length) pair. 4 bytes per item.</source>
          <target state="translated">実際のアイテムを指すアイテム識別子の配列。各エントリは (offset,length)のペアです。1項目あたり4バイト。</target>
        </trans-unit>
        <trans-unit id="be15b795f8a08c896c323efe48ed797caf42d6d4" translate="yes" xml:space="preserve">
          <source>Array of subscribed publication names. These reference the publications on the publisher server. For more on publications see &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt;.</source>
          <target state="translated">サブスクライブされたパブリケーション名の配列。これらは、パブリッシャーサーバー上のパブリケーションを参照します。出版物の詳細については、&lt;a href=&quot;logical-replication-publication&quot;&gt;セクション30.1を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="31177effc11eb7035c25f786c3b9f262ea8dee25" translate="yes" xml:space="preserve">
          <source>Array: &amp;amp;&amp;amp;</source>
          <target state="translated">配列：&amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="24e29718edd609d75b45a77aa875138df131bbd7" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;</source>
          <target state="translated">配列：&amp;gt;</target>
        </trans-unit>
        <trans-unit id="811842a370e6ca7314ad3ee641887ae43eed6200" translate="yes" xml:space="preserve">
          <source>Array: &amp;gt;=</source>
          <target state="translated">配列：&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="736b98ce8f814e8462d7673c06a73e5d2921d61d" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;</source>
          <target state="translated">配列：&amp;lt;</target>
        </trans-unit>
        <trans-unit id="72683d381cd2860b3b1a8eab0a2c5eedfb795924" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;&amp;gt;</source>
          <target state="translated">配列：&amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="397f0e2a9b9f910336a8ea8c6c32ba6704d652eb" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;=</source>
          <target state="translated">配列：&amp;lt;=</target>
        </trans-unit>
        <trans-unit id="5df64d9374ce5e9d00462533f6beea8afb43679c" translate="yes" xml:space="preserve">
          <source>Array: &amp;lt;@</source>
          <target state="translated">配列：&amp;lt;@</target>
        </trans-unit>
        <trans-unit id="3fe38b2f63794530437e3485d0c38785ad75e487" translate="yes" xml:space="preserve">
          <source>Array: 1</source>
          <target state="translated">配列。1</target>
        </trans-unit>
        <trans-unit id="d7d17f1eb33a5388e6bfb317a245a8c37e5b460a" translate="yes" xml:space="preserve">
          <source>Array: =</source>
          <target state="translated">配列:==のようになります。</target>
        </trans-unit>
        <trans-unit id="db0f2c477d3b5e5a1ea32beab72408f0ff3b2f71" translate="yes" xml:space="preserve">
          <source>Array: @&amp;gt;</source>
          <target state="translated">配列：@&amp;gt;</target>
        </trans-unit>
        <trans-unit id="150a65359d97d4ee8b8c087554e227e4e463443a" translate="yes" xml:space="preserve">
          <source>Array: ARRAY</source>
          <target state="translated">配列です。配列</target>
        </trans-unit>
        <trans-unit id="4dcd3d1ce93d0ca2cb3e60332e931604f93cc026" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;amp;&amp;amp; ARRAY</source>
          <target state="translated">配列：ARRAY &amp;amp;&amp;amp; ARRAY</target>
        </trans-unit>
        <trans-unit id="64b37c182a6bd42ba7b5eb841ce25916a3a3c807" translate="yes" xml:space="preserve">
          <source>Array: ARRAY &amp;lt;@ ARRAY</source>
          <target state="translated">配列：ARRAY &amp;lt;@ ARRAY</target>
        </trans-unit>
        <trans-unit id="78d1bb5bc6001f266e8878cdac676402e49a8545" translate="yes" xml:space="preserve">
          <source>Array: ARRAY @&amp;gt; ARRAY</source>
          <target state="translated">配列：ARRAY @&amp;gt; ARRAY</target>
        </trans-unit>
        <trans-unit id="5c09f59eadf2bb3b4328b3f453d0a6c85ef136cb" translate="yes" xml:space="preserve">
          <source>Array: IS NOT DISTINCT FROM</source>
          <target state="translated">配列です。からの距離ではありません。</target>
        </trans-unit>
        <trans-unit id="4bc80d05bcc1cb0f4e5e941af2a29b9db0657f22" translate="yes" xml:space="preserve">
          <source>Array: NULL</source>
          <target state="translated">配列です。NULL</target>
        </trans-unit>
        <trans-unit id="d9bbda7ebf850fa729d9606dbdfd7d1f3599ec47" translate="yes" xml:space="preserve">
          <source>Array: array_append</source>
          <target state="translated">配列:array_append</target>
        </trans-unit>
        <trans-unit id="af82c1377e93f02d0993b9aadeb7d8e17521a1bc" translate="yes" xml:space="preserve">
          <source>Array: array_cat</source>
          <target state="translated">配列:array_cat</target>
        </trans-unit>
        <trans-unit id="243f29a4a2e10d2646f7903c1f4a2d39c2a3d0a4" translate="yes" xml:space="preserve">
          <source>Array: array_dims</source>
          <target state="translated">配列:array_dims</target>
        </trans-unit>
        <trans-unit id="5beacc0ab51ffbcd3c4683bef89fb252cd5ecd4f" translate="yes" xml:space="preserve">
          <source>Array: array_fill</source>
          <target state="translated">配列:array_fill</target>
        </trans-unit>
        <trans-unit id="0a700d1340312f7d432d241fb96c7d69e0d7cbc8" translate="yes" xml:space="preserve">
          <source>Array: array_length</source>
          <target state="translated">配列:array_length</target>
        </trans-unit>
        <trans-unit id="e39f07efeb19c70308a1b05104d42f13e6750589" translate="yes" xml:space="preserve">
          <source>Array: array_lower</source>
          <target state="translated">配列:array_lower</target>
        </trans-unit>
        <trans-unit id="55bec9b1ab2dd7b5615b888955aa1685d7d9176c" translate="yes" xml:space="preserve">
          <source>Array: array_ndims</source>
          <target state="translated">配列:array_ndims</target>
        </trans-unit>
        <trans-unit id="6abfbc8e90ab3825fd22a987883a8130d8647c22" translate="yes" xml:space="preserve">
          <source>Array: array_position</source>
          <target state="translated">配列:array_position</target>
        </trans-unit>
        <trans-unit id="dc8f46967ae5b46ce3023fe830845635cbddc3a2" translate="yes" xml:space="preserve">
          <source>Array: array_positions</source>
          <target state="translated">配列:array_positions</target>
        </trans-unit>
        <trans-unit id="170bb418b8b592fa19a657e9b3372281a737a509" translate="yes" xml:space="preserve">
          <source>Array: array_prepend</source>
          <target state="translated">配列:array_prepend</target>
        </trans-unit>
        <trans-unit id="23c081b8640d7683a9a9eb917682404db2a9d9cf" translate="yes" xml:space="preserve">
          <source>Array: array_remove</source>
          <target state="translated">配列:array_remove</target>
        </trans-unit>
        <trans-unit id="0bb70da04daab39f1a179be9e60eceee76a3242d" translate="yes" xml:space="preserve">
          <source>Array: array_replace</source>
          <target state="translated">配列:array_replace</target>
        </trans-unit>
        <trans-unit id="d1576bf750554857f928eff64376711410524f13" translate="yes" xml:space="preserve">
          <source>Array: array_to_string</source>
          <target state="translated">配列:array_to_string</target>
        </trans-unit>
        <trans-unit id="f1d1655c390920a19930233b2ba0cbcc608406ea" translate="yes" xml:space="preserve">
          <source>Array: array_upper</source>
          <target state="translated">配列:array_upper</target>
        </trans-unit>
        <trans-unit id="f07fdded6b4337ac290721bed8d559d25ce497d7" translate="yes" xml:space="preserve">
          <source>Array: cardinality</source>
          <target state="translated">配列:カーディナリティ</target>
        </trans-unit>
        <trans-unit id="4d56c61f6754af386d1ad55522ee718a6d173e5b" translate="yes" xml:space="preserve">
          <source>Array: select * from unnest as x</source>
          <target state="translated">配列:select*from unnest as x</target>
        </trans-unit>
        <trans-unit id="b45177789238b533ec64ce75c721f78be3e3490d" translate="yes" xml:space="preserve">
          <source>Array: string_to_array</source>
          <target state="translated">配列:string_to_array</target>
        </trans-unit>
        <trans-unit id="1b1aca770dcf002c23a04ca801aee9819ce75321" translate="yes" xml:space="preserve">
          <source>Array: unnest</source>
          <target state="translated">配列:アンネスト</target>
        </trans-unit>
        <trans-unit id="8cbda94f98fa6831a0fab631dfd36cfb855d6147" translate="yes" xml:space="preserve">
          <source>Array: ||</source>
          <target state="translated">配列です。||</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="7ff0d6e651880818d49ef5a4d284aa7441e9760b" translate="yes" xml:space="preserve">
          <source>Arrays are not sets; searching for specific array elements can be a sign of database misdesign. Consider using a separate table with a row for each item that would be an array element. This will be easier to search, and is likely to scale better for a large number of elements.</source>
          <target state="translated">配列は集合ではありません。特定の配列要素を検索することは、データベースの設計ミスの兆候である可能性があります。特定の配列要素を検索するには、データベースの設計ミスのサインになる可能性があります。配列要素となる各項目の行を持つ別のテーブルを使用することを検討してください。これは検索が容易になりますし、要素の数が多い場合のスケーリングも容易になります。</target>
        </trans-unit>
        <trans-unit id="86a798d810f86ee1f57761b0f4f378302a450ab0" translate="yes" xml:space="preserve">
          <source>As PostgreSQL stands, this doesn't occur. Large objects are treated as objects in their own right; a table entry can reference a large object by OID, but there can be multiple table entries referencing the same large object OID, so the system doesn't delete the large object just because you change or remove one such entry.</source>
          <target state="translated">PostgreSQLの現状では、このようなことは起こりません。ラージオブジェクトはそれ自体がオブジェクトとして扱われます。テーブルエントリはラージオブジェクトをOIDで参照することができますが、同じラージオブジェクトのOIDを参照しているテーブルエントリが複数存在する可能性があるため、1つのエントリを変更したり削除したりしたからといってシステムがラージオブジェクトを削除することはありません。</target>
        </trans-unit>
        <trans-unit id="96ee90014e2be91ae6a2c0ff19bfbdac86380915" translate="yes" xml:space="preserve">
          <source>As a consequence, it is unwise to use functions with side effects as part of complex expressions. It is particularly dangerous to rely on side effects or evaluation order in &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;HAVING&lt;/code&gt; clauses, since those clauses are extensively reprocessed as part of developing an execution plan. Boolean expressions (&lt;code&gt;AND&lt;/code&gt;/&lt;code&gt;OR&lt;/code&gt;/&lt;code&gt;NOT&lt;/code&gt; combinations) in those clauses can be reorganized in any manner allowed by the laws of Boolean algebra.</source>
          <target state="translated">結果として、副作用のある関数を複雑な式の一部として使用することは賢明ではありません。 &lt;code&gt;WHERE&lt;/code&gt; 句と &lt;code&gt;HAVING&lt;/code&gt; 句の副作用や評価順序に依存することは特に危険です。これらの句は、実行プランの開発の一環として広範囲にわたって再処理されるためです。これらの句のブール式（ &lt;code&gt;AND&lt;/code&gt; / &lt;code&gt;OR&lt;/code&gt; / &lt;code&gt;NOT&lt;/code&gt; の組み合わせ）は、ブール代数の法則で許可されている方法で再編成できます。</target>
        </trans-unit>
        <trans-unit id="c00aa4eef1a46e7541eb69499cd40ccfaa63754a" translate="yes" xml:space="preserve">
          <source>As a convenience, there is a program you can execute from the shell to create new databases, &lt;code&gt;createdb&lt;/code&gt;.</source>
          <target state="translated">便利なように、シェルから実行して新しいデータベース &lt;code&gt;createdb&lt;/code&gt; を作成できるプログラムがあります。</target>
        </trans-unit>
        <trans-unit id="d25ac520ed3e5e990af0f244faf971c940fd4e71" translate="yes" xml:space="preserve">
          <source>As a general rule, if you get spurious parser errors for commands that contain any of the listed key words as an identifier you should try to quote the identifier to see if the problem goes away.</source>
          <target state="translated">一般的なルールとして、リストされたキーワードを識別子として含むコマンドのパーサエラーが発生した場合、問題が解決するかどうかを確認するために識別子を引用してみてください。</target>
        </trans-unit>
        <trans-unit id="95a9f6ed53fa85650318ffc030c2493caa298423" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed.</source>
          <target state="translated">このタイプのエラーに対する部分的なガードとして、可変長またはNULL可能フィールドをCコンパイラーに直接表示しないでください。これは、それらを &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; （ &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; は定義されないシンボル）でラップすることによって実現されます。これにより、Cコードが、そこにない、または他のオフセットにある可能性のあるフィールドに不注意にアクセスしようとするのを防ぎます。誤った行を作成することに対する独立したガードとして、null許容でないはずのすべての列を &lt;code&gt;pg_attribute&lt;/code&gt; でそのようにマークする必要があります。ブートストラップコードは、カタログ列を &lt;code&gt;NOT NULL&lt;/code&gt; として自動的にマークしますそれらが固定幅であり、前にNULL可能列がない場合。このルールが不十分な場合は、必要に応じて &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; および &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; アノテーションを使用して、正しいマーキングを強制できます。</target>
        </trans-unit>
        <trans-unit id="2a80a71669f88eae465ab66545f1b21816ccdfcd" translate="yes" xml:space="preserve">
          <source>As a partial guard against this type of error, variable-length or nullable fields should not be made directly visible to the C compiler. This is accomplished by wrapping them in &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; (where &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; is a symbol that is never defined). This prevents C code from carelessly trying to access fields that might not be there or might be at some other offset. As an independent guard against creating incorrect rows, we require all columns that should be non-nullable to be marked so in &lt;code&gt;pg_attribute&lt;/code&gt;. The bootstrap code will automatically mark catalog columns as &lt;code&gt;NOT NULL&lt;/code&gt; if they are fixed-width and are not preceded by any nullable column. Where this rule is inadequate, you can force correct marking by using &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; and &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; annotations as needed. But note that &lt;code&gt;NOT NULL&lt;/code&gt; constraints are only enforced in the executor, not against tuples that are generated by random C code, so care is still needed when manually creating or updating catalog rows.</source>
          <target state="translated">このタイプのエラーに対する部分的な保護策として、可変長フィールドまたはNULL可能フィールドをCコンパイラに直接表示しないでください。これは、 &lt;code&gt;#ifdef CATALOG_VARLEN&lt;/code&gt; ... &lt;code&gt;#endif&lt;/code&gt; （ &lt;code&gt;CATALOG_VARLEN&lt;/code&gt; は定義されていないシンボル）でそれらをラップすることによって実現されます。これにより、Cコードが存在しないフィールドや他のオフセットにあるフィールドに不用意にアクセスするのを防ぎます。不正な行を作成しないようにするための独立したガードとして、nullにできないようにする必要があるすべての列を &lt;code&gt;pg_attribute&lt;/code&gt; でマークする必要があります。ブートストラップコードはカタログ列を自動的に &lt;code&gt;NOT NULL&lt;/code&gt; としてマークしますそれらが固定幅で、前にnull許容列がない場合。このルールが不適切な場合は、必要に応じて &lt;code&gt;BKI_FORCE_NOT_NULL&lt;/code&gt; および &lt;code&gt;BKI_FORCE_NULL&lt;/code&gt; アノテーションを使用して、正しいマーキングを強制できます。ただし、 &lt;code&gt;NOT NULL&lt;/code&gt; 制約は、executorでのみ適用され、ランダムなCコードによって生成されたタプルに対しては適用されないため、手動でカタログ行を作成または更新する場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="47b0b4c39b5ede77f7f7daa11745dc4255dd8757" translate="yes" xml:space="preserve">
          <source>As a partitioned table does not have any data directly, attempts to use &lt;code&gt;TRUNCATE&lt;/code&gt;&lt;code&gt;ONLY&lt;/code&gt; on a partitioned table will always return an error.</source>
          <target state="translated">分割テーブルには直接データがないため、分割テーブルで &lt;code&gt;TRUNCATE&lt;/code&gt; &lt;code&gt;ONLY&lt;/code&gt; を使用しようとすると、常にエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="ff2aae32fe6bdd83d73023e8256b2cd3508deffa" translate="yes" xml:space="preserve">
          <source>As a result, you cannot create additional indexes that exist solely on the standby, nor statistics that exist solely on the standby. If these administration commands are needed, they should be executed on the primary, and eventually those changes will propagate to the standby.</source>
          <target state="translated">その結果、スタンバイのみに存在する追加のインデックスや、スタンバイのみに存在する統計情報を作成することはできません。これらの管理コマンドが必要な場合は、プライマリ上で実行する必要があり、最終的にはそれらの変更がスタンバイに伝搬します。</target>
        </trans-unit>
        <trans-unit id="94f064aeef44b2237a7b84960c6af3e282dc0f3d" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, &lt;code&gt;queryid&lt;/code&gt; values can be assumed to be stable and comparable only so long as the underlying server version and catalog metadata details stay exactly the same. Two servers participating in replication based on physical WAL replay can be expected to have identical &lt;code&gt;queryid&lt;/code&gt; values for the same query. However, logical replication schemes do not promise to keep replicas identical in all relevant details, so &lt;code&gt;queryid&lt;/code&gt; will not be a useful identifier for accumulating costs across a set of logical replicas. If in doubt, direct testing is recommended.</source>
          <target state="translated">経験則として、基礎となるサーバーのバージョンとカタログのメタデータの詳細がまったく同じである限り、 &lt;code&gt;queryid&lt;/code&gt; 値は安定していて比較可能であると見なすことができます。物理WAL再生に基づくレプリケーションに参加している2台のサーバーは、同じクエリに対して同一の &lt;code&gt;queryid&lt;/code&gt; 値を持つことが期待できます。ただし、論理レプリケーションスキームは、すべての関連する詳細でレプリカを同一に保つことを約束しないため、 &lt;code&gt;queryid&lt;/code&gt; は、一連の論理レプリカにわたってコストを累積するための有用な識別子にはなりません。疑わしい場合は、直接テストをお勧めします。</target>
        </trans-unit>
        <trans-unit id="84cdd8b719c9d8f34c7f1d4c72b4f9ce0fe4768b" translate="yes" xml:space="preserve">
          <source>As a safety device, an aggressive vacuum scan will occur for any table whose multixact-age is greater than &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;. Aggressive vacuum scans will also occur progressively for all tables, starting with those that have the oldest multixact-age, if the amount of used member storage space exceeds the amount 50% of the addressable storage space. Both of these kinds of aggressive scans will occur even if autovacuum is nominally disabled.</source>
          <target state="translated">安全装置として、multixact-ageが&lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE&quot;&gt;autovacuum_multixact_freeze_max_age&lt;/a&gt;より大きいテーブルに対して積極的なバキュームスキャンが実行されます。使用されるメンバーストレージスペースの量がアドレス可能なストレージスペースの量の50％を超える場合、最も古いmultixact-ageを持つテーブルから始めて、すべてのテーブルに対して積極的なバキュームスキャンも徐々に行われます。自動バキュームが名目上無効になっている場合でも、これらの種類の積極的なスキャンは行われます。</target>
        </trans-unit>
        <trans-unit id="2b18e01bd003b97bb977c2d73b7cfc8923da784c" translate="yes" xml:space="preserve">
          <source>As a sanity check, &lt;code&gt;seg&lt;/code&gt; rejects intervals with the lower bound greater than the upper, for example &lt;code&gt;5 .. 2&lt;/code&gt;.</source>
          <target state="translated">健全性チェックとして、 &lt;code&gt;seg&lt;/code&gt; は上限が下限よりも大きい間隔を拒否します（例： &lt;code&gt;5 .. 2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e65f5f3343ba0b45af614f4022a156a7c42809b5" translate="yes" xml:space="preserve">
          <source>As a simple example, here is how to create a policy on the &lt;code&gt;account&lt;/code&gt; relation to allow only members of the &lt;code&gt;managers&lt;/code&gt; role to access rows, and only rows of their accounts:</source>
          <target state="translated">簡単な例として、 &lt;code&gt;managers&lt;/code&gt; ロールのメンバーのみに行へのアクセスを許可し、 &lt;code&gt;account&lt;/code&gt; 行のみにアクセスを許可するアカウント関係のポリシーを作成する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="05f66f343edd96e743819d53bcce1284f5be3d29" translate="yes" xml:space="preserve">
          <source>As a special exception to the general principle that the structures must match, an array may contain a primitive value:</source>
          <target state="translated">構造体が一致しなければならないという一般的な原則に対する特別な例外として、配列はプリミティブ値を含むことができます。</target>
        </trans-unit>
        <trans-unit id="4dafe6722800c895e7fb824e24cdc22785e38231" translate="yes" xml:space="preserve">
          <source>As a workaround to allow PostgreSQL to use indexes with &lt;code&gt;LIKE&lt;/code&gt; clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to &lt;a href=&quot;indexes-opclass&quot;&gt;Section 11.10&lt;/a&gt; for more information. Another approach is to create indexes using the &lt;code&gt;C&lt;/code&gt; collation, as discussed in &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.</source>
          <target state="translated">PostgreSQLがC以外のロケールで &lt;code&gt;LIKE&lt;/code&gt; 句を含むインデックスを使用できるようにするための回避策として、いくつかのカスタム演算子クラスが存在します。これらにより、ロケール比較ルールを無視して、厳密な文字ごとの比較を実行するインデックスを作成できます。詳細については、&lt;a href=&quot;indexes-opclass&quot;&gt;セクション11.10&lt;/a&gt;を参照してください。別のアプローチは、&lt;a href=&quot;collation&quot;&gt;セクション23.2で&lt;/a&gt;説明されているように、 &lt;code&gt;C&lt;/code&gt; 照合を使用してインデックスを作成することです。</target>
        </trans-unit>
        <trans-unit id="38727bf2878bdfdd88e444d27be405dc29a205b6" translate="yes" xml:space="preserve">
          <source>As above, but import only the two tables &lt;code&gt;actors&lt;/code&gt; and &lt;code&gt;directors&lt;/code&gt; (if they exist):</source>
          <target state="translated">上記と同じですが、 &lt;code&gt;actors&lt;/code&gt; と &lt;code&gt;directors&lt;/code&gt; （存在する場合）の2つのテーブルのみをインポートします。</target>
        </trans-unit>
        <trans-unit id="fc0ab2ce564629da1cade53f45b45700cfa6ba3f" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-D&lt;/code&gt; option, you can set the environment variable &lt;code&gt;PGDATA&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-D&lt;/code&gt; オプションの代わりに、環境変数 &lt;code&gt;PGDATA&lt;/code&gt; 設定できます。</target>
        </trans-unit>
        <trans-unit id="431e9cdc01712eabff181abecb6b83e3af47f9a9" translate="yes" xml:space="preserve">
          <source>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</source>
          <target state="translated">別の方法として、新しいテーブルをパーティション構造の外側に作成して、後で適切なパーティションにした方が便利な場合があります。これにより、データがパーティション化されたテーブルに現れる前に、データをロードし、チェックし、変換することができます。</target>
        </trans-unit>
        <trans-unit id="dbbe816df8235daf5a726cf6177c485cd14e8ef4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Example 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">これらの関数によって生成された出力を使用する例として、&lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;例9.1&lt;/a&gt;は、 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; の出力をテーブルデータの表形式の表現を含むHTMLドキュメントに変換するXSLTスタイルシートを示しています。同様の方法で、これらの関数の結果を他のXMLベースの形式に変換できます。</target>
        </trans-unit>
        <trans-unit id="d0e3b2ce01a4421ab4c72defc488724bdaa1c1a4" translate="yes" xml:space="preserve">
          <source>As an example of using the output produced by these functions, &lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;Figure 9.1&lt;/a&gt; shows an XSLT stylesheet that converts the output of &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; to an HTML document containing a tabular rendition of the table data. In a similar manner, the results from these functions can be converted into other XML-based formats.</source>
          <target state="translated">これらの関数によって生成された出力を使用する例として、&lt;a href=&quot;functions-xml#XSLT-XML-HTML&quot;&gt;図9.1&lt;/a&gt;は、 &lt;code&gt;table_to_xml_and_xmlschema&lt;/code&gt; の出力をテーブルデータの表形式のレンディションを含むHTMLドキュメントに変換するXSLTスタイルシートを示しています。同様に、これらの関数の結果を他のXMLベースの形式に変換できます。</target>
        </trans-unit>
        <trans-unit id="0d1f3783f0bee859f0f7fd07d8117b96c39c5dbf" translate="yes" xml:space="preserve">
          <source>As an example we will create a configuration &lt;code&gt;pg&lt;/code&gt;, starting by duplicating the built-in &lt;code&gt;english&lt;/code&gt; configuration:</source>
          <target state="translated">例として、組み込みの &lt;code&gt;english&lt;/code&gt; 構成を複製することから始まる構成 &lt;code&gt;pg&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="faf1ed368ea36c292232738719a6fc50ce56d002" translate="yes" xml:space="preserve">
          <source>As an example, &lt;code&gt;CET-1CEST,M3.5.0,M10.5.0/3&lt;/code&gt; describes current (as of 2020) timekeeping practice in Paris. This specification says that standard time has the abbreviation &lt;code&gt;CET&lt;/code&gt; and is one hour ahead (east) of UTC; daylight savings time has the abbreviation &lt;code&gt;CEST&lt;/code&gt; and is implicitly two hours ahead of UTC; daylight savings time begins on the last Sunday in March at 2AM CET and ends on the last Sunday in October at 3AM CEST.</source>
          <target state="translated">例として、 &lt;code&gt;CET-1CEST,M3.5.0,M10.5.0/3&lt;/code&gt; は、パリでの現在の（2020年現在の）計時方法を説明しています。この仕様では、標準時には &lt;code&gt;CET&lt;/code&gt; という略語があり、UTCより1時間進んでいます（東）。夏時間には &lt;code&gt;CEST&lt;/code&gt; という略語があり、UTCよりも暗黙的に2時間進んでいます。夏時間は、3月の最終日曜日の午前2時CETに始まり、10月の最終日曜日の午前3時CESTに終わります。</target>
        </trans-unit>
        <trans-unit id="75dd3c213ab262bc0285b838849480821b38de49" translate="yes" xml:space="preserve">
          <source>As an example, consider a table &lt;code&gt;mytab&lt;/code&gt;, initially containing:</source>
          <target state="translated">例として、最初に以下を含むテーブル &lt;code&gt;mytab&lt;/code&gt; を考えます。</target>
        </trans-unit>
        <trans-unit id="90c5a9e56ec693f6e6129ec5a5d9bccec6f61c69" translate="yes" xml:space="preserve">
          <source>As an example, if an &lt;code&gt;UPDATE&lt;/code&gt; is issued, then the &lt;code&gt;ALL&lt;/code&gt; policy will be applicable both to what the &lt;code&gt;UPDATE&lt;/code&gt; will be able to select as rows to be updated (applying the &lt;code&gt;USING&lt;/code&gt; expression), and to the resulting updated rows, to check if they are permitted to be added to the table (applying the &lt;code&gt;WITH CHECK&lt;/code&gt; expression, if defined, and the &lt;code&gt;USING&lt;/code&gt; expression otherwise). If an &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command attempts to add rows to the table that do not pass the &lt;code&gt;ALL&lt;/code&gt; policy's &lt;code&gt;WITH CHECK&lt;/code&gt; expression, the entire command will be aborted.</source>
          <target state="translated">例として、 &lt;code&gt;UPDATE&lt;/code&gt; が発行された場合、 &lt;code&gt;ALL&lt;/code&gt; ポリシーは、 &lt;code&gt;UPDATE&lt;/code&gt; が更新する行として選択できるもの（ &lt;code&gt;USING&lt;/code&gt; 式を適用）と、結果の更新された行の両方に適用され、それらがテーブルへの追加が許可されます（定義されている場合は &lt;code&gt;WITH CHECK&lt;/code&gt; 式を適用し、定義されていない場合は &lt;code&gt;USING&lt;/code&gt; 式を適用します）。場合は &lt;code&gt;INSERT&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; 通らないテーブルに行を追加するためのコマンドの試行 &lt;code&gt;ALL&lt;/code&gt; のポリシーの &lt;code&gt;WITH CHECK&lt;/code&gt; 式を、コマンド全体が中止されます。</target>
        </trans-unit>
        <trans-unit id="939804fcee1e20d77d25bd0bcffade6b732e6187" translate="yes" xml:space="preserve">
          <source>As an example, suppose that user &lt;code&gt;miriam&lt;/code&gt; creates table &lt;code&gt;mytable&lt;/code&gt; and does:</source>
          <target state="translated">例として、そのユーザーと仮定 &lt;code&gt;miriam&lt;/code&gt; テーブル作成 &lt;code&gt;mytable&lt;/code&gt; はをして行います。</target>
        </trans-unit>
        <trans-unit id="7dea5d7bb31aa71940b0966bc7e8fd7ee8f021dd" translate="yes" xml:space="preserve">
          <source>As an example, the full definition of the built-in TPC-B-like transaction is:</source>
          <target state="translated">一例として、組み込みのTPC-B的なトランザクションの完全な定義があります。</target>
        </trans-unit>
        <trans-unit id="cfc78f7c719c6f7419eadd4a007ca5004840837d" translate="yes" xml:space="preserve">
          <source>As an example, we can find the highest low-temperature reading anywhere with:</source>
          <target state="translated">例としては、どこにいても最高の低温読みを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">一例として。</target>
        </trans-unit>
        <trans-unit id="b50a75f7dfe3aa7965ef5d4e176cb3485c343ba0" translate="yes" xml:space="preserve">
          <source>As an extension to the SQL standard, PostgreSQL allows there to be just one escape-double-quote separator, in which case the third regular expression is taken as empty; or no separators, in which case the first and third regular expressions are taken as empty.</source>
          <target state="translated">標準SQLへの拡張として、PostgreSQLではエスケープダブルクォートセパレータを1つだけ持つことができます。</target>
        </trans-unit>
        <trans-unit id="fa9c14e462aa9732a24d51e00bd5d77bf7a81cc2" translate="yes" xml:space="preserve">
          <source>As another example, if one often does queries like:</source>
          <target state="translated">別の例として、1つが頻繁に次のようなクエリを実行する場合。</target>
        </trans-unit>
        <trans-unit id="a99c411c58f58d7e7474741b999e04e5e53fd82b" translate="yes" xml:space="preserve">
          <source>As before, however, PostgreSQL does not enforce the size restriction in any case.</source>
          <target state="translated">しかし、これまでと同様に、PostgreSQLはいかなる場合でもサイズ制限を実施しません。</target>
        </trans-unit>
        <trans-unit id="6c4c55629e9060b4cdfbd0fb1ea96b264210b4b6" translate="yes" xml:space="preserve">
          <source>As before, the estimated number of rows is just the product of this with the cardinality of &lt;code&gt;tenk1&lt;/code&gt;:</source>
          <target state="translated">前と同様に、推定される行数は、これとカーディナリティ &lt;code&gt;tenk1&lt;/code&gt; の積にすぎません。</target>
        </trans-unit>
        <trans-unit id="7a87fbf380bd12f56579ba8b09d2dfca1e87a7aa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;Section 4.2.14&lt;/a&gt;, there are various situations in which subexpressions of an expression are evaluated at different times, so that the principle that &amp;ldquo;&lt;code&gt;CASE&lt;/code&gt; evaluates only necessary subexpressions&amp;rdquo; is not ironclad. For example a constant &lt;code&gt;1/0&lt;/code&gt; subexpression will usually result in a division-by-zero failure at planning time, even if it's within a &lt;code&gt;CASE&lt;/code&gt; arm that would never be entered at run time.</source>
          <target state="translated">&lt;a href=&quot;sql-expressions#SYNTAX-EXPRESS-EVAL&quot;&gt;セクション4.2.14&lt;/a&gt;で説明されているように、式の部分式がさまざまなタイミングで評価されるさまざまな状況があるため、「 &lt;code&gt;CASE&lt;/code&gt; は必要な部分式のみを評価する」という原則は根拠のないものです。たとえば、定数の &lt;code&gt;1/0&lt;/code&gt; 部分式は、実行時に入力されない &lt;code&gt;CASE&lt;/code&gt; アーム内にある場合でも、通常、計画時にゼロ除算の失敗を引き起こします。</target>
        </trans-unit>
        <trans-unit id="518e3cc29b2ad22029595abb39bdf434ee471900" translate="yes" xml:space="preserve">
          <source>As described in the previous section, transaction commit is normally &lt;em&gt;synchronous&lt;/em&gt;: the server waits for the transaction's WAL records to be flushed to permanent storage before returning a success indication to the client. The client is therefore guaranteed that a transaction reported to be committed will be preserved, even in the event of a server crash immediately after. However, for short transactions this delay is a major component of the total transaction time. Selecting asynchronous commit mode means that the server returns success as soon as the transaction is logically completed, before the WAL records it generated have actually made their way to disk. This can provide a significant boost in throughput for small transactions.</source>
          <target state="translated">前のセクションで説明したように、トランザクションコミットは通常&lt;em&gt;同期し&lt;/em&gt;ています。サーバーは、トランザクションのWALレコードが永続的なストレージにフラッシュされるのを待ってから、クライアントに成功を返します。したがって、クライアントは、直後にサーバーがクラッシュした場合でも、コミットされたと報告されたトランザクションが保持されることを保証します。ただし、短いトランザクションの場合、この遅延は合計トランザクション時間の主要なコンポーネントです。非同期コミットモードを選択すると、サーバーは、トランザクションが論理的に完了するとすぐに、サーバーが生成したWALレコードが実際にディスクに移動する前に成功を返します。これにより、小規模なトランザクションのスループットが大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="64a53cc76e5b39051f25182477eec0422ea4a682" translate="yes" xml:space="preserve">
          <source>As explained above, it is possible to create indexes on partitioned tables and they are applied automatically to the entire hierarchy. This is very convenient, as not only the existing partitions will become indexed, but also any partitions that are created in the future will. One limitation is that it's not possible to use the &lt;code&gt;CONCURRENTLY&lt;/code&gt; qualifier when creating such a partitioned index. To overcome long lock times, it is possible to use &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; the partitioned table; such an index is marked invalid, and the partitions do not get the index applied automatically. The indexes on partitions can be created separately using &lt;code&gt;CONCURRENTLY&lt;/code&gt;, and later &lt;em&gt;attached&lt;/em&gt; to the index on the parent using &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt;. Once indexes for all partitions are attached to the parent index, the parent index is marked valid automatically. Example:</source>
          <target state="translated">上記で説明したように、パーティション化されたテーブルにインデックスを作成することが可能で、それらは階層全体に自動的に適用されます。これは非常に便利です。既存のパーティションだけでなく、将来作成されるパーティションにもインデックスが作成されるからです。 1つの制限は、そのようなパーティション化されたインデックスを作成するときに &lt;code&gt;CONCURRENTLY&lt;/code&gt; 修飾子を使用できないことです。長いロック時間を克服するために、パーティション化されたテーブル &lt;code&gt;CREATE INDEX ON ONLY&lt;/code&gt; を使用することが可能です。このようなインデックスは無効とマークされ、パーティションにはインデックスが自動的に適用されません。パーティションのインデックスは、 &lt;code&gt;CONCURRENTLY&lt;/code&gt; を使用して個別に作成し、後で親のインデックスに&lt;em&gt;アタッチ&lt;/em&gt;できます。 &lt;code&gt;ALTER INDEX .. ATTACH PARTITION&lt;/code&gt; 。すべてのパーティションのインデックスが親インデックスにアタッチされると、親インデックスは自動的に有効とマークされます。例：</target>
        </trans-unit>
        <trans-unit id="fb2dc582124a2fe2747429c6ba796f17d561c7c2" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt;, the default privileges for any object type normally grant all grantable permissions to the object owner, and may grant some privileges to &lt;code&gt;PUBLIC&lt;/code&gt; as well. However, this behavior can be changed by altering the global default privileges with &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;ddl-priv&quot;&gt;セクション5.7&lt;/a&gt;で説明したように、任意のオブジェクトタイプのデフォルトの権限は通常、付与可能なすべての権限をオブジェクトの所有者に付与し、一部の権限を &lt;code&gt;PUBLIC&lt;/code&gt; にも付与する場合があります。ただし、この動作は、 &lt;code&gt;ALTER DEFAULT PRIVILEGES&lt;/code&gt; を使用してグローバルデフォルト権限を変更することで変更できます。</target>
        </trans-unit>
        <trans-unit id="7cfc29a245774c7f93be3cd482cd2720e2efb253" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;Section 70.2.1&lt;/a&gt;, functional dependencies are very cheap and efficient type of statistics, but their main limitation is their global nature (only tracking dependencies at the column level, not between individual column values).</source>
          <target state="translated">&lt;a href=&quot;multivariate-statistics-examples#FUNCTIONAL-DEPENDENCIES&quot;&gt;70.2.1項で&lt;/a&gt;説明したように、機能依存性は非常に安価で効率的な統計タイプですが、主な制限はグローバルな性質です（個々の列値間ではなく、列レベルでのみ依存性を追跡します）。</target>
        </trans-unit>
        <trans-unit id="c5ba1476be535d17f697ff078bc8840ec5998688" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;planner-stats&quot;&gt;Section 14.2&lt;/a&gt;, the planner can determine cardinality of &lt;code&gt;t&lt;/code&gt; using the number of pages and rows obtained from &lt;code&gt;pg_class&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;planner-stats&quot;&gt;セクション14.2&lt;/a&gt;で説明したように、プランナは &lt;code&gt;pg_class&lt;/code&gt; から取得したページと行の数を使用して &lt;code&gt;t&lt;/code&gt; のカーディナリティを決定できます。</target>
        </trans-unit>
        <trans-unit id="39801241473f144107571af31829d77f27364c9d" translate="yes" xml:space="preserve">
          <source>As far as the operator class is concerned, returning &lt;code&gt;true&lt;/code&gt; indicates that deduplication is safe (or safe for the collation whose OID was passed to its &lt;code&gt;equalimage&lt;/code&gt; function). However, the core code will only deem deduplication safe for an index when &lt;em&gt;every&lt;/em&gt; indexed column uses an operator class that registers an &lt;code&gt;equalimage&lt;/code&gt; function, and each function actually returns &lt;code&gt;true&lt;/code&gt; when called.</source>
          <target state="translated">演算子クラスに関する限り、 &lt;code&gt;true&lt;/code&gt; を返すことは、重複排除が安全であることを示します（または、OIDが &lt;code&gt;equalimage&lt;/code&gt; 関数に渡された照合に対して安全です）。ただし、コアコードは、&lt;em&gt;すべての&lt;/em&gt;インデックス付き列が等 &lt;code&gt;equalimage&lt;/code&gt; 関数を登録する演算子クラスを使用する場合にのみ、インデックスの重複排除が安全であると見なし、各関数が呼び出されると実際に &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="149ce91ff7ffadae424c16cab2b4c0512100eae4" translate="yes" xml:space="preserve">
          <source>As in basic &lt;code&gt;tsquery&lt;/code&gt; input, weight(s) can be attached to each lexeme to restrict it to match only &lt;code&gt;tsvector&lt;/code&gt; lexemes of those weight(s). For example:</source>
          <target state="translated">基本的な &lt;code&gt;tsquery&lt;/code&gt; 入力と同様に、各語彙素に重みを付けて、それらの重みの &lt;code&gt;tsvector&lt;/code&gt; 語彙素のみに一致するように制限できます。例えば：</target>
        </trans-unit>
        <trans-unit id="1c139aca10977b17d5102cc7674b71010f5c568f" translate="yes" xml:space="preserve">
          <source>As is standard in SQL, all functions return NULL, if any of the arguments are NULL. This may create security risks on careless usage.</source>
          <target state="translated">SQLでは標準的に、引数のいずれかがNULLの場合、すべての関数はNULLを返します。これは、不注意な使い方をするとセキュリティ上のリスクを生む可能性があります。</target>
        </trans-unit>
        <trans-unit id="585d0521870959cf15a89091a2347acd4003a598" translate="yes" xml:space="preserve">
          <source>As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.</source>
          <target state="translated">クライアント/サーバアプリケーションの典型的な例として、クライアントとサーバは異なるホスト上に存在することがあります。その場合、TCP/IP ネットワーク接続を介して通信します。クライアントマシン上でアクセスできるファイルは、データベースサーバーマシン上ではアクセスできないかもしれない(あるいは別のファイル名でしかアクセスできないかもしれない)ので、このことを念頭に置いておく必要があります。</target>
        </trans-unit>
        <trans-unit id="29fce103d97e5fc966f97584895b606dc9b97769" translate="yes" xml:space="preserve">
          <source>As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. If this value is specified without units, it is taken as megabytes. The default is 80 MB. This parameter can only be set in the &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line.</source>
          <target state="translated">WALのディスク使用量がこの設定を下回っている限り、古いWALファイルは、削除されるのではなく、チェックポイントで将来使用するために常にリサイクルされます。これを使用して、たとえば大規模なバッチジョブを実行する場合など、WAL使用率の急上昇に対処するために十分なWALスペースを確保することができます。この値を単位なしで指定すると、メガバイトとして扱われます。デフォルトは80 MBです。このパラメーターは、 &lt;code&gt;postgresql.conf&lt;/code&gt; ファイルまたはサーバーのコマンドラインでのみ設定できます。</target>
        </trans-unit>
        <trans-unit id="935b68a13a63015aa5e693b61464b2a9c3100546" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, each (active) subscription receives changes from a replication slot on the remote (publishing) side. Normally, the remote replication slot is created automatically when the subscription is created using &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; and it is dropped automatically when the subscription is dropped using &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt;. In some situations, however, it can be useful or necessary to manipulate the subscription and the underlying replication slot separately. Here are some scenarios:</source>
          <target state="translated">前述のように、各（アクティブ）サブスクリプションは、リモート（パブリッシング）側のレプリケーションスロットから変更を受け取ります。通常、リモートレプリケーションスロットは、サブスクリプションが &lt;code&gt;CREATE SUBSCRIPTION&lt;/code&gt; を使用して作成されると自動的に作成され、サブスクリプションが &lt;code&gt;DROP SUBSCRIPTION&lt;/code&gt; を使用して削除されると自動的に削除されます。ただし、状況によっては、サブスクリプションと基になるレプリケーションスロットを個別に操作することが役立つ場合や必要な場合があります。ここにいくつかのシナリオがあります：</target>
        </trans-unit>
        <trans-unit id="6d35d01797be09599719c5fbe0e98e1d8b777874" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;, Serializable transactions are just Repeatable Read transactions which add nonblocking monitoring for dangerous patterns of read/write conflicts. When a pattern is detected which could cause a cycle in the apparent order of execution, one of the transactions involved is rolled back to break the cycle.</source>
          <target state="translated">&lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;セクション13.2.3&lt;/a&gt;で述べたように、シリアライズ可能なトランザクションは、読み取り/書き込みの競合の危険なパターンに対する非ブロッキング監視を追加する単なる反復可能な読み取りトランザクションです。見かけ上の実行順序でサイクルを引き起こす可能性のあるパターンが検出されると、関連するトランザクションの1つがロールバックされ、サイクルが中断されます。</target>
        </trans-unit>
        <trans-unit id="820f9f6df5cbde09a17525e7847d0d2dfe09b2c4" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/common/toast_internals.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">前述のように、TOASTポインタデータには複数のタイプがあります。最も古く、最も一般的なタイプは、TOASTポインターデータ自体を含む&lt;em&gt;テーブル&lt;/em&gt;とは別の、ただし関連付けられている&lt;em&gt;TOASTテーブルに&lt;/em&gt;格納されているアウトオブラインデータへのポインターです。これら&lt;em&gt;のディスク上の&lt;/em&gt;ポインタデータは、ディスクに保存するタプルが大きすぎてそのまま保存できない場合に、TOAST管理コード（ &lt;code&gt;access/common/toast_internals.c&lt;/code&gt; 内）によって作成されます。詳細は&lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;セクション68.2.1に記載されています。&lt;/a&gt;。あるいは、TOASTポインタデータに、メモリ内の他の場所に表示されるオフラインデータへのポインタを含めることができます。このようなデータは必然的に短命であり、ディスク上に表示されることはありませんが、大きなデータ値のコピーや冗長処理を回避するのに非常に役立ちます。詳細については、&lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;セクション68.2.2を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d7967f9ae1b2dfb5df2376dc5e14f007c840b5d2" translate="yes" xml:space="preserve">
          <source>As mentioned, there are multiple types of TOAST pointer datums. The oldest and most common type is a pointer to out-of-line data stored in a &lt;em&gt;TOAST table&lt;/em&gt; that is separate from, but associated with, the table containing the TOAST pointer datum itself. These &lt;em&gt;on-disk&lt;/em&gt; pointer datums are created by the TOAST management code (in &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt;) when a tuple to be stored on disk is too large to be stored as-is. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;Section 68.2.1&lt;/a&gt;. Alternatively, a TOAST pointer datum can contain a pointer to out-of-line data that appears elsewhere in memory. Such datums are necessarily short-lived, and will never appear on-disk, but they are very useful for avoiding copying and redundant processing of large data values. Further details appear in &lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;Section 68.2.2&lt;/a&gt;.</source>
          <target state="translated">前述のように、TOASTポインターデータムには複数のタイプがあります。最も古く最も一般的なタイプは、TOASTポインターデータ自体が含まれている&lt;em&gt;テーブル&lt;/em&gt;とは別の、関連付けられている&lt;em&gt;TOASTテーブルに&lt;/em&gt;格納されている&lt;em&gt;行外&lt;/em&gt;データへのポインターです。これら&lt;em&gt;のディスク上の&lt;/em&gt;ポインターデータは、ディスクに格納するタプルが大きすぎてそのまま格納できない場合に、TOAST管理コード（ &lt;code&gt;access/heap/tuptoaster.c&lt;/code&gt; 内）によって作成されます。詳細は&lt;a href=&quot;storage-toast#STORAGE-TOAST-ONDISK&quot;&gt;68.2.1項に記載されています&lt;/a&gt;。または、TOASTポインタデータムには、メモリ内の他の場所にある行外データへのポインタを含めることができます。このようなデータは有効期間が短く、ディスク上に表示されることはありませんが、大きなデータ値のコピーや冗長処理を回避するのに非常に役立ちます。詳細については、&lt;a href=&quot;storage-toast#STORAGE-TOAST-INMEMORY&quot;&gt;68.2.2項を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e83c3b33db2892f30f5c07aab1da708113577a83" translate="yes" xml:space="preserve">
          <source>As noted above, if the server crashes during the backup it may not be possible to restart until the &lt;code&gt;backup_label&lt;/code&gt; file has been manually deleted from the &lt;code&gt;PGDATA&lt;/code&gt; directory. Note that it is very important to never remove the &lt;code&gt;backup_label&lt;/code&gt; file when restoring a backup, because this will result in corruption. Confusion about when it is appropriate to remove this file is a common cause of data corruption when using this method; be very certain that you remove the file only on an existing master and never when building a standby or restoring a backup, even if you are building a standby that will subsequently be promoted to a new master.</source>
          <target state="translated">上記のように、バックアップ中にサーバーがクラッシュした場合、 &lt;code&gt;backup_label&lt;/code&gt; ファイルが &lt;code&gt;PGDATA&lt;/code&gt; ディレクトリから手動で削除されるまで再起動できない可能性があります。バックアップを復元するときは、 &lt;code&gt;backup_label&lt;/code&gt; する可能性があるため、決してbackup_labelファイルを削除しないことが非常に重要です。このファイルをいつ削除するのが適切かについての混乱は、この方法を使用する場合のデータ破損の一般的な原因です。後で新しいマスターに昇格するスタンバイを構築している場合でも、既存のマスターでのみファイルを削除し、スタンバイの構築時やバックアップの復元時には絶対に削除しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="b565015dcc8ef588510a75b03d00c798591daa60" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, &lt;code&gt;amvacuumcleanup&lt;/code&gt; will also be called at completion of an &lt;code&gt;ANALYZE&lt;/code&gt; operation. In this case &lt;code&gt;stats&lt;/code&gt; is always NULL and any return value will be ignored. This case can be distinguished by checking &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt;. It is recommended that the access method do nothing except post-insert cleanup in such a call, and that only in an autovacuum worker process.</source>
          <target state="translated">PostgreSQL 8.4以降、 &lt;code&gt;ANALYZE&lt;/code&gt; 操作の完了時に &lt;code&gt;amvacuumcleanup&lt;/code&gt; も呼び出されます。この場合、 &lt;code&gt;stats&lt;/code&gt; は常にNULLであり、戻り値は無視されます。このケースは、 &lt;code&gt;info-&amp;gt;analyze_only&lt;/code&gt; をチェックすることで区別できます。このような呼び出しでは、アクセス方法が挿入後のクリーンアップ以外に何も行わず、自動バキュームワーカープロセスでのみ行うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="41cf08ef1ae95fce9351d2775b5ca30eb5967a1b" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 8.4, this advice is less necessary since delayed indexing is used (see &lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;Section 66.4.1&lt;/a&gt; for details). But for very large updates it may still be best to drop and recreate the index.</source>
          <target state="translated">PostgreSQL 8.4以降では、遅延インデックスが使用されるため、このアドバイスはあまり必要ありません（詳細については&lt;a href=&quot;gin-implementation#GIN-FAST-UPDATE&quot;&gt;セクション66.4.1&lt;/a&gt;を参照）。ただし、非常に大きな更新の場合は、インデックスを削除して再作成するのが最善の方法です。</target>
        </trans-unit>
        <trans-unit id="fd60ea8bf7dbb2005dc3edad9e036817a4cf429d" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.0, &lt;code&gt;hstore&lt;/code&gt; uses a different internal representation than previous versions. This presents no obstacle for dump/restore upgrades since the text representation (used in the dump) is unchanged.</source>
          <target state="translated">PostgreSQL 9.0以降、 &lt;code&gt;hstore&lt;/code&gt; は以前のバージョンとは異なる内部表現を使用します。これは、ダンプで使用されるテキスト表現が変更されないため、ダンプ/復元アップグレードの障害にはなりません。</target>
        </trans-unit>
        <trans-unit id="280a05cda72f4f22e9db55fedf9a21987eec509c" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be installed with &lt;a href=&quot;sql-createextension&quot;&gt;CREATE EXTENSION&lt;/a&gt; not &lt;code&gt;CREATE LANGUAGE&lt;/code&gt;. Direct use of &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; should now be confined to extension installation scripts. If you have a &amp;ldquo;bare&amp;rdquo; language in your database, perhaps as a result of an upgrade, you can convert it to an extension using &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1では、ほとんどの手続き型言語は「拡張機能」になっているため、 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; ではなくCREATE &lt;a href=&quot;sql-createextension&quot;&gt;EXTENSION&lt;/a&gt;でインストールする必要があります。 &lt;code&gt;CREATE LANGUAGE&lt;/code&gt; の直接使用は、拡張機能のインストールスクリプトに限定されるようになりました。データベースに「ベア」言語がある場合、おそらくアップグレードの結果として、 &lt;code&gt;CREATE EXTENSION langname FROM unpackaged&lt;/code&gt; を使用して拡張に変換できます。</target>
        </trans-unit>
        <trans-unit id="ad6c1afacf960c00b0b43cc22652add17660a754" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, most procedural languages have been made into &amp;ldquo;extensions&amp;rdquo;, and should therefore be removed with &lt;a href=&quot;sql-dropextension&quot;&gt;DROP EXTENSION&lt;/a&gt; not &lt;code&gt;DROP LANGUAGE&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 9.1以降、ほとんどの手続き型言語は「拡張機能」になっているため、 &lt;code&gt;DROP LANGUAGE&lt;/code&gt; ではなくDROP &lt;a href=&quot;sql-dropextension&quot;&gt;EXTENSION&lt;/a&gt;で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="9efc7bda1a790af9716120cc8586743f8662e379" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, null key values can be included in the index. Also, placeholder nulls are included in the index for indexed items that are null or contain no keys according to &lt;code&gt;extractValue&lt;/code&gt;. This allows searches that should find empty items to do so.</source>
          <target state="translated">PostgreSQL 9.1では、nullキー値をインデックスに含めることができます。また、プレースホルダーnullは、nullであるか、または &lt;code&gt;extractValue&lt;/code&gt; に従ってキーを含まないインデックス付きアイテムのインデックスに含まれます。これにより、空のアイテムを検索する必要がある検索が可能になります。</target>
        </trans-unit>
        <trans-unit id="41a7562cb3e64fe55b5aa379cb00b42fdb0e1138" translate="yes" xml:space="preserve">
          <source>As of PostgreSQL 9.1, you can attach a &lt;code&gt;COLLATE&lt;/code&gt; specification to &lt;code&gt;citext&lt;/code&gt; columns or data values. Currently, &lt;code&gt;citext&lt;/code&gt; operators will honor a non-default &lt;code&gt;COLLATE&lt;/code&gt; specification while comparing case-folded strings, but the initial folding to lower case is always done according to the database's &lt;code&gt;LC_CTYPE&lt;/code&gt; setting (that is, as though &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; were given). This may be changed in a future release so that both steps follow the input &lt;code&gt;COLLATE&lt;/code&gt; specification.</source>
          <target state="translated">PostgreSQL 9.1以降では、 &lt;code&gt;COLLATE&lt;/code&gt; 仕様を &lt;code&gt;citext&lt;/code&gt; 列またはデータ値にアタッチできます。現在、 &lt;code&gt;citext&lt;/code&gt; 演算子は、大文字と小文字を区別した文字列を比較するときに、デフォルト以外の &lt;code&gt;COLLATE&lt;/code&gt; 仕様を受け入れますが、小文字への最初の折りたたみは、常にデータベースの &lt;code&gt;LC_CTYPE&lt;/code&gt; 設定に従って行われます（つまり、 &lt;code&gt;COLLATE &quot;default&quot;&lt;/code&gt; が指定されているかのように）。これは、両方のステップが入力 &lt;code&gt;COLLATE&lt;/code&gt; 仕様に従うように、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="9cdab33dd907fd023cacb62f21aa10cc62e305ca" translate="yes" xml:space="preserve">
          <source>As pg_rewind copies configuration files entirely from the source, it may be required to correct the configuration used for recovery before restarting the target server, especially if the target is reintroduced as a standby of the source. If you restart the server after the rewind operation has finished but without configuring recovery, the target may again diverge from the primary.</source>
          <target state="translated">pg_rewindは設定ファイルをソースから完全にコピーしますので、ターゲットサーバを再起動する前にリカバリに使用する設定を修正する必要があるかもしれません。巻き戻し操作が終了した後にリカバリの設定を行わずにサーバを再起動した場合、ターゲットが再びプライマリから乖離する可能性があります。</target>
        </trans-unit>
        <trans-unit id="df8c2a751dfbd5be0d7c157dabee58d14e6c8985" translate="yes" xml:space="preserve">
          <source>As previously stated, when a JSON value is input and then printed without any additional processing, &lt;code&gt;json&lt;/code&gt; outputs the same text that was input, while &lt;code&gt;jsonb&lt;/code&gt; does not preserve semantically-insignificant details such as whitespace. For example, note the differences here:</source>
          <target state="translated">前述のように、JSON値が入力され、追加の処理なしで印刷されると、 &lt;code&gt;json&lt;/code&gt; は入力されたものと同じテキストを出力しますが、 &lt;code&gt;jsonb&lt;/code&gt; は空白などの意味的に重要ではない詳細を保持しません。たとえば、ここの違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="1442483656b1d2da488c86cbbe647b9c3925f511" translate="yes" xml:space="preserve">
          <source>As seen in the second example, the element name can be omitted if the content value is a column reference, in which case the column name is used by default. Otherwise, a name must be specified.</source>
          <target state="translated">2番目の例で見られるように、コンテンツ値がカラム参照である場合は、要素名を省略することができ、その場合はデフォルトでカラム名が使用されます。それ以外の場合は、名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fbfde401bab7c53809229a3d8a380b7c73d7b56a" translate="yes" xml:space="preserve">
          <source>As seen in this example, when the query is an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command, the actual work of applying the table changes is done by a top-level Insert, Update, or Delete plan node. The plan nodes underneath this node perform the work of locating the old rows and/or computing the new data. So above, we see the same sort of bitmap table scan we've seen already, and its output is fed to an Update node that stores the updated rows. It's worth noting that although the data-modifying node can take a considerable amount of run time (here, it's consuming the lion's share of the time), the planner does not currently add anything to the cost estimates to account for that work. That's because the work to be done is the same for every correct query plan, so it doesn't affect planning decisions.</source>
          <target state="translated">この例でわかるように、クエリが &lt;code&gt;INSERT&lt;/code&gt; 、 &lt;code&gt;UPDATE&lt;/code&gt; 、または &lt;code&gt;DELETE&lt;/code&gt; の場合コマンド、テーブルの変更を適用する実際の作業は、トップレベルの挿入、更新、または削除の計画ノードによって行われます。このノードの下にある計画ノードは、古い行を見つけたり、新しいデータを計算したりする作業を実行します。上記のように、すでに見たのと同じ種類のビットマップテーブルスキャンがあり、その出力は更新された行を格納するUpdateノードに送られます。データ変更ノードはかなりの実行時間を要する可能性がありますが（ここでは、時間の大部分を消費しています）、プランナーは現在、その作業を説明するためにコスト見積もりに何も追加していません。これは、実行する作業がすべての正しいクエリプランで同じであるため、計画の決定に影響を与えないためです。</target>
        </trans-unit>
        <trans-unit id="c1072787f6d22b0aaf6039c0a8fa7f37aca0290a" translate="yes" xml:space="preserve">
          <source>As shown above, all comparison operators are binary operators that return values of type &lt;code&gt;boolean&lt;/code&gt;. Thus, expressions like &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; are not valid (because there is no &lt;code&gt;&amp;lt;&lt;/code&gt; operator to compare a Boolean value with &lt;code&gt;3&lt;/code&gt;). Use the &lt;code&gt;BETWEEN&lt;/code&gt; predicates shown below to perform range tests.</source>
          <target state="translated">上に示したように、すべての比較演算子は、 &lt;code&gt;boolean&lt;/code&gt; 型の値を返す2項演算子です。したがって、 &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt; ような式は無効です（ブール値を &lt;code&gt;3&lt;/code&gt; と比較する &lt;code&gt;&amp;lt;&lt;/code&gt; 演算子がないため）。以下に示す &lt;code&gt;BETWEEN&lt;/code&gt; 述部を使用して、範囲テストを実行します。</target>
        </trans-unit>
        <trans-unit id="299b9141677294c0e2aa3b93c3483b8a98e2f995" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;union&lt;/code&gt; function's first &lt;code&gt;internal&lt;/code&gt; argument is actually a &lt;code&gt;GistEntryVector&lt;/code&gt; pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the &lt;code&gt;union&lt;/code&gt; function store the size of its result value into that variable, but this is no longer necessary.)</source>
          <target state="translated">上記のように、 &lt;code&gt;union&lt;/code&gt; 関数の最初の &lt;code&gt;internal&lt;/code&gt; 引数は、実際には &lt;code&gt;GistEntryVector&lt;/code&gt; ポインターです。2番目の引数は整数変数へのポインターであり、無視できます。（以前は、 &lt;code&gt;union&lt;/code&gt; 関数がその結果値のサイズをその変数に格納する必要がありましたが、これはもう必要ありません。）</target>
        </trans-unit>
        <trans-unit id="e49718fcf44bf904fec83a97285f69086516abb8" translate="yes" xml:space="preserve">
          <source>As shown here, the &lt;code&gt;rank&lt;/code&gt; function produces a numerical rank for each distinct &lt;code&gt;ORDER BY&lt;/code&gt; value in the current row's partition, using the order defined by the &lt;code&gt;ORDER BY&lt;/code&gt; clause. &lt;code&gt;rank&lt;/code&gt; needs no explicit parameter, because its behavior is entirely determined by the &lt;code&gt;OVER&lt;/code&gt; clause.</source>
          <target state="translated">ここに示すように、 &lt;code&gt;rank&lt;/code&gt; 関数は、 &lt;code&gt;ORDER BY&lt;/code&gt; 句で定義された順序を使用して、現在の行のパーティション内の各 &lt;code&gt;ORDER BY&lt;/code&gt; 値の数値ランクを生成します。 &lt;code&gt;rank&lt;/code&gt; の動作は &lt;code&gt;OVER&lt;/code&gt; 句によって完全に決定されるため、rankには明示的なパラメータは必要ありません。</target>
        </trans-unit>
        <trans-unit id="7278da1d6766bb19352b261eabd292dd18fce4c5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.2&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;表37.2&lt;/a&gt;に示すように、btree演算子クラスは、5つの比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; を提供する必要があります。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; も演算子クラスの一部である必要があると思われるかもしれませんが、そうではありません。インデックス検索で &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE句を使用することはほとんど役に立ちません。 （いくつかの目的のために、プランナは &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; をbtree演算子クラスに関連付けられているものとして扱いますが、 &lt;code&gt;pg_amop&lt;/code&gt; からではなく &lt;code&gt;=&lt;/code&gt; 演算子の否定子リンクを介してその演算子を見つけます。）</target>
        </trans-unit>
        <trans-unit id="2b7658bd4634c80bfa02d903fd89d9f89cfdf0c3" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.8&lt;/a&gt;, btree defines one required and two optional support functions.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;表37.8&lt;/a&gt;に示すように、btreeは1つの必須サポート関数と2つのオプションサポート関数を定義します。</target>
        </trans-unit>
        <trans-unit id="e2e2d713a7e1c4b73e9dae4d9b294d20af0dfdbd" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;Table 37.3&lt;/a&gt;, a btree operator class must provide five comparison operators, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. One might expect that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; should also be part of the operator class, but it is not, because it would almost never be useful to use a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE clause in an index search. (For some purposes, the planner treats &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as associated with a btree operator class; but it finds that operator via the &lt;code&gt;=&lt;/code&gt; operator's negator link, rather than from &lt;code&gt;pg_amop&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-STRAT-TABLE&quot;&gt;表37.3&lt;/a&gt;に示すように、btree演算子クラスは、5つの比較演算子 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&lt;/code&gt; を提供する必要があります。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; も演算子クラスの一部であると予想されるかもしれませんが、そうではありません。インデックス検索で &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; WHERE句を使用することはほとんど役に立たないためです。 （一部の目的では、プランナーは &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; をbtree演算子クラスに関連付けられているものとして扱いますが、 &lt;code&gt;pg_amop&lt;/code&gt; からではなく、 &lt;code&gt;=&lt;/code&gt; 演算子のネゲーターリンクを介してその演算子を検出します。）</target>
        </trans-unit>
        <trans-unit id="fd9a67840a67dabf7761754a18fc846d1c2e26f5" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;Table 37.9&lt;/a&gt;, btree defines one required and four optional support functions. The five user-defined methods are:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-BTREE-SUPPORT-TABLE&quot;&gt;表37.9&lt;/a&gt;に示すように、btreeは、1つの必須サポート関数と4つのオプションのサポート関数を定義します。5つのユーザー定義メソッドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="01827ef18402ec5bd4e9a302a910b59d06b2ca2b" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, the table expression in the &lt;code&gt;SELECT&lt;/code&gt; command constructs an intermediate virtual table by possibly combining tables, views, eliminating rows, grouping, etc. This table is finally passed on to processing by the &lt;em&gt;select list&lt;/em&gt;. The select list determines which &lt;em&gt;columns&lt;/em&gt; of the intermediate table are actually output.</source>
          <target state="translated">前のセクションで示したように、 &lt;code&gt;SELECT&lt;/code&gt; コマンドのテーブル式は、テーブル、ビュー、行の削除、グループ化などを組み合わせて中間仮想テーブルを作成します。このテーブルは、最終的に&lt;em&gt;選択リスト&lt;/em&gt;による処理に渡され&lt;em&gt;ます&lt;/em&gt;。選択リストは、中間テーブルのどの&lt;em&gt;列&lt;/em&gt;が実際に出力されるかを決定し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a1a6ed6a1882593d5ac926bd03fffe04913abef7" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing a composite value you can write double quotes around any individual field value. You &lt;em&gt;must&lt;/em&gt; do so if the field value would otherwise confuse the composite-value parser. In particular, fields containing parentheses, commas, double quotes, or backslashes must be double-quoted. To put a double quote or backslash in a quoted composite field value, precede it with a backslash. (Also, a pair of double quotes within a double-quoted field value is taken to represent a double quote character, analogously to the rules for single quotes in SQL literal strings.) Alternatively, you can avoid quoting and use backslash-escaping to protect all data characters that would otherwise be taken as composite syntax.</source>
          <target state="translated">前に示したように、複合値を書き込むときは、個々のフィールド値を二重引用符で囲むことができます。フィールド値によって複合値パーサーが混乱する場合は、そうする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。特に、括弧、コンマ、二重引用符、またはバックスラッシュを含むフィールドは二重引用符で囲む必要があります。二重引用符またはバックスラッシュを引用符付きの複合フィールド値に含めるには、その前にバックスラッシュを付けます。 （また、二重引用符で囲まれたフィールド値内の二重引用符のペアは、SQLリテラル文字列の単一引用符のルールと同様に、二重引用符文字を表すために使用されます。）または、引用符を避け、バックスラッシュエスケープを使用して保護することもできますそうでなければ複合構文として解釈されるすべてのデータ文字。</target>
        </trans-unit>
        <trans-unit id="bf6c49e3bf726dc38d17652f47395db71e4e4fbd" translate="yes" xml:space="preserve">
          <source>As shown previously, when writing an array value you can use double quotes around any individual array element. You &lt;em&gt;must&lt;/em&gt; do so if the element value would otherwise confuse the array-value parser. For example, elements containing curly braces, commas (or the data type's delimiter character), double quotes, backslashes, or leading or trailing whitespace must be double-quoted. Empty strings and strings matching the word &lt;code&gt;NULL&lt;/code&gt; must be quoted, too. To put a double quote or backslash in a quoted array element value, precede it with a backslash. Alternatively, you can avoid quotes and use backslash-escaping to protect all data characters that would otherwise be taken as array syntax.</source>
          <target state="translated">前に示したように、配列値を書き込むときは、個々の配列要素を二重引用符で囲むことができます。要素値が配列値パーサーを混乱させる場合は、そうする&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。たとえば、中括弧、コンマ（またはデータ型の区切り文字）、二重引用符、バックスラッシュ、または先頭または末尾の空白を含む要素は、二重引用符で囲む必要があります。空の文字列および &lt;code&gt;NULL&lt;/code&gt; という単語に一致する文字列も引用符で囲む必要があります。引用符で囲まれた配列要素の値に二重引用符またはバックスラッシュを入れるには、その前にバックスラッシュを付けます。または、引用符を避け、バックスラッシュエスケープを使用して、配列構文として使用されるすべてのデータ文字を保護することもできます。</target>
        </trans-unit>
        <trans-unit id="8a1775eb12b1097993052bc9db7c32cd0419a0ce" translate="yes" xml:space="preserve">
          <source>As shown, an array data type is named by appending square brackets (&lt;code&gt;[]&lt;/code&gt;) to the data type name of the array elements. The above command will create a table named &lt;code&gt;sal_emp&lt;/code&gt; with a column of type &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;name&lt;/code&gt;), a one-dimensional array of type &lt;code&gt;integer&lt;/code&gt; (&lt;code&gt;pay_by_quarter&lt;/code&gt;), which represents the employee's salary by quarter, and a two-dimensional array of &lt;code&gt;text&lt;/code&gt; (&lt;code&gt;schedule&lt;/code&gt;), which represents the employee's weekly schedule.</source>
          <target state="translated">示されているように、配列データ型は、配列要素のデータ型名に角括弧（ &lt;code&gt;[]&lt;/code&gt; ）を追加することによって名前が付けられます。上記コマンドは、指定したテーブルが作成されます &lt;code&gt;sal_emp&lt;/code&gt; 型のカラムを持つ &lt;code&gt;text&lt;/code&gt; （ &lt;code&gt;name&lt;/code&gt; ）、型の一次元アレイ &lt;code&gt;integer&lt;/code&gt; （ &lt;code&gt;pay_by_quarter&lt;/code&gt; 四半期によって従業員の給与を表す）、及び二次元アレイ &lt;code&gt;text&lt;/code&gt; （ &lt;code&gt;schedule&lt;/code&gt; ） 、従業員の週次スケジュールを表します。</target>
        </trans-unit>
        <trans-unit id="e0b46ae37bd20da5e49ea599dd897a3ac9299776" translate="yes" xml:space="preserve">
          <source>As the above example suggests, a &lt;code&gt;tsquery&lt;/code&gt; is not just raw text, any more than a &lt;code&gt;tsvector&lt;/code&gt; is. A &lt;code&gt;tsquery&lt;/code&gt; contains search terms, which must be already-normalized lexemes, and may combine multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For syntax details see &lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;Section 8.11.2&lt;/a&gt;.) There are functions &lt;code&gt;to_tsquery&lt;/code&gt;, &lt;code&gt;plainto_tsquery&lt;/code&gt;, and &lt;code&gt;phraseto_tsquery&lt;/code&gt; that are helpful in converting user-written text into a proper &lt;code&gt;tsquery&lt;/code&gt;, primarily by normalizing words appearing in the text. Similarly, &lt;code&gt;to_tsvector&lt;/code&gt; is used to parse and normalize a document string. So in practice a text search match would look more like this:</source>
          <target state="translated">上記の例が示唆しているように、 &lt;code&gt;tsquery&lt;/code&gt; は &lt;code&gt;tsvector&lt;/code&gt; 以外の単なる生のテキストではありません。 &lt;code&gt;tsquery&lt;/code&gt; は既に正規化された語彙素でなければならない検索用語を、含まれており、使用して複数の条件を組み合わせることができるAND、OR、NOT、および演算子が続きます。（構文の詳細については、&lt;a href=&quot;datatype-textsearch#DATATYPE-TSQUERY&quot;&gt;セクション8.11.2を&lt;/a&gt;参照してください。）ユーザーが作成したテキストを適切な &lt;code&gt;tsquery&lt;/code&gt; に変換するのに役立つ関数 &lt;code&gt;to_tsquery&lt;/code&gt; 、 &lt;code&gt;plainto_tsquery&lt;/code&gt; 、および &lt;code&gt;phraseto_tsquery&lt;/code&gt; があります。同様に、 &lt;code&gt;to_tsvector&lt;/code&gt; ドキュメント文字列を解析して正規化するために使用されます。したがって、実際にはテキスト検索の一致は次のようになります。</target>
        </trans-unit>
        <trans-unit id="6b22935fd06acdc1c0f8d1431b124c6c0f7b088d" translate="yes" xml:space="preserve">
          <source>As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by &lt;code&gt;regexp_match&lt;/code&gt; and &lt;code&gt;regexp_matches&lt;/code&gt;, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions.</source>
          <target state="translated">最後の例が示すように、regexp分割関数は、文字列の先頭または末尾、または直前の一致の直後に発生する長さゼロの一致を無視します。これは、 &lt;code&gt;regexp_match&lt;/code&gt; および &lt;code&gt;regexp_matches&lt;/code&gt; によって実装されるregexpマッチングの厳密な定義とは逆ですが、通常、実際には最も便利な動作です。 Perlなどの他のソフトウェアシステムも同様の定義を使用します。</target>
        </trans-unit>
        <trans-unit id="0378825838c0e066e87e6d5b0be89bee2dd5620d" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;IN&lt;/code&gt; is null.</source>
          <target state="translated">通常どおり、行のnull値はSQLブール式の通常の規則に従って結合されます。 2つの行は、対応するすべてのメンバーがnullでなく等しい場合、等しいと見なされます。対応するメンバーがnullでなく、等しくない場合、行は等しくありません。そうでない場合、その行比較の結果は不明です（null）。すべての行ごとの結果が等しくないかnullであり、少なくとも1つのnullがある場合、 &lt;code&gt;IN&lt;/code&gt; の結果はnullになります。</target>
        </trans-unit>
        <trans-unit id="0b8508c03666af11ade2c1725a303ade508dcc57" translate="yes" xml:space="preserve">
          <source>As usual, null values in the rows are combined per the normal rules of SQL Boolean expressions. Two rows are considered equal if all their corresponding members are non-null and equal; the rows are unequal if any corresponding members are non-null and unequal; otherwise the result of that row comparison is unknown (null). If all the per-row results are either unequal or null, with at least one null, then the result of &lt;code&gt;NOT IN&lt;/code&gt; is null.</source>
          <target state="translated">通常どおり、行のnull値はSQLブール式の通常の規則に従って結合されます。2つの行は、対応するすべてのメンバーがnullでなく、等しい場合に等しいと見なされます。対応するメンバーがnullでなく、等しくない場合、行は等しくありません。そうでない場合、その行比較の結果は不明です（null）。すべての行ごとの結果が等しくないかnullであり、少なくとも1つのnullがある場合、 &lt;code&gt;NOT IN&lt;/code&gt; の結果はnullになります。</target>
        </trans-unit>
        <trans-unit id="00f8ed65d004834d267f75de424eb5e9aec68c8b" translate="yes" xml:space="preserve">
          <source>As visible here, JIT was used, but inlining and expensive optimization were not. If &lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt; or &lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_cost&lt;/a&gt; were also lowered, that would change.</source>
          <target state="translated">ここに示されているように、JITが使用されましたが、インライン化と高価な最適化は使用されませんでした。場合&lt;a href=&quot;runtime-config-query#GUC-JIT-INLINE-ABOVE-COST&quot;&gt;jit_inline_above_cost&lt;/a&gt;または&lt;a href=&quot;runtime-config-query#GUC-JIT-OPTIMIZE-ABOVE-COST&quot;&gt;jit_optimize_above_costを&lt;/a&gt;も低下させ、それが変化するであろう。</target>
        </trans-unit>
        <trans-unit id="e991d7170113bfec3a30551fcd7b4c1810192115" translate="yes" xml:space="preserve">
          <source>As we can see, a complex table hierarchy could require a substantial amount of DDL. In the above example we would be creating a new child table each month, so it might be wise to write a script that generates the required DDL automatically.</source>
          <target state="translated">ご覧のように、複雑なテーブル階層はかなりの量のDDLを必要とします。上記の例では、毎月新しい子テーブルを作成しているので、必要なDDLを自動的に生成するスクリプトを書くのが賢明かもしれません。</target>
        </trans-unit>
        <trans-unit id="13f137c0044f99ee6629a214a80858091639b3df" translate="yes" xml:space="preserve">
          <source>As we saw in the previous section, the query planner needs to estimate the number of rows retrieved by a query in order to make good choices of query plans. This section provides a quick look at the statistics that the system uses for these estimates.</source>
          <target state="translated">前のセクションで見たように、クエリプランナはクエリプランを適切に選択するために、クエリによって取得された行数を推定する必要があります。このセクションでは、システムがこれらの推定に使用する統計情報について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="6a378a5df8689a29e440cf7e593b2b7b017debb3" translate="yes" xml:space="preserve">
          <source>As well as tables, this option can be used to dump the definition of matching views, materialized views, foreign tables, and sequences. It will not dump the contents of views or materialized views, and the contents of foreign tables will only be dumped if the corresponding foreign server is specified with &lt;code&gt;--include-foreign-data&lt;/code&gt;.</source>
          <target state="translated">テーブルだけでなく、このオプションを使用して、一致するビュー、マテリアライズドビュー、外部テーブル、およびシーケンスの定義をダンプできます。ビューまたはマテリアライズドビューの内容はダンプされません。また、外部テーブルの内容は、対応する外部サーバーが &lt;code&gt;--include-foreign-data&lt;/code&gt; で指定されている場合にのみダンプされます。</target>
        </trans-unit>
        <trans-unit id="e28715fe2eadf5afacb168abae8c272e3eef5af1" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;EXISTS&lt;/code&gt;, it's unwise to assume that the subquery will be evaluated completely.</source>
          <target state="translated">&lt;code&gt;EXISTS&lt;/code&gt; と同様に、サブクエリが完全に評価されると想定することは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="22733a70e9587403334559bc9fffe583566e0a7a" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters. A different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;, or the escape capability can be disabled by writing &lt;code&gt;ESCAPE ''&lt;/code&gt;.</source>
          <target state="translated">同じように &lt;code&gt;LIKE&lt;/code&gt; 、バックスラッシュは、これらのメタ文字のいずれかの特別な意味を無効にします。 &lt;code&gt;ESCAPE&lt;/code&gt; で別のエスケープ文字を指定するか、 &lt;code&gt;ESCAPE ''&lt;/code&gt; を書き込むことでエスケープ機能を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="181bd891b583b10919f382d152707212af1347e4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;LIKE&lt;/code&gt;, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with &lt;code&gt;ESCAPE&lt;/code&gt;.</source>
          <target state="translated">同じように &lt;code&gt;LIKE&lt;/code&gt; 、バックスラッシュは、これらのメタ文字のいずれかの特別な意味を無効にします。または、別のエスケープ文字を &lt;code&gt;ESCAPE&lt;/code&gt; で指定できます。</target>
        </trans-unit>
        <trans-unit id="8c360e616acbe7a6ddce202d4edfd50d452f4ba5" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;SIMILAR TO&lt;/code&gt;, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern for which the matching data sub-string is of interest, the pattern should contain two occurrences of the escape character followed by a double quote (&lt;code&gt;&quot;&lt;/code&gt;). The text matching the portion of the pattern between these separators is returned when the match is successful.</source>
          <target state="translated">同様に &lt;code&gt;SIMILAR TO&lt;/code&gt; 、指定されたパターンがデータ文字列全体と一致している必要があり、さもなければ関数はnullを失敗し、返します。一致するデータのサブストリングが関係するパターンの部分を示すために、パターンにはエスケープ文字が2回出現し、その後に二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）が続く必要があります。これらの区切り文字の間のパターンの部分に一致するテキストは、マッチが成功したときに返されます。</target>
        </trans-unit>
        <trans-unit id="2f915404c792b4b375081401e8be4799b6fdf5c9" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;pgstattuple&lt;/code&gt;, the results are accumulated page-by-page, and should not be expected to represent an instantaneous snapshot of the whole index.</source>
          <target state="translated">&lt;code&gt;pgstattuple&lt;/code&gt; の場合と同様に、結果はページごとに蓄積され、インデックス全体の瞬間的なスナップショットを表すとは期待できません。</target>
        </trans-unit>
        <trans-unit id="fd70faee0fe9a1b62ee5a071b1f7e464081b1189" translate="yes" xml:space="preserve">
          <source>As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly.</source>
          <target state="translated">他のセキュリティ設定と同様に、システムが期待通りに動作していることをテストして確認することが重要です。上記の例を使用して、これはパーミッションシステムが正しく動作していることを示しています。</target>
        </trans-unit>
        <trans-unit id="f8169958f7a4429a1d75d6cb1d9f2e4af52ed1d2" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) In particular, it is advisable that this user account not own the PostgreSQL executable files, to ensure that a compromised server process could not modify those executables.</source>
          <target state="translated">外部からアクセスできる他のサーバーデーモンと同様に、PostgreSQLは別のユーザーアカウントで実行することをお勧めします。このユーザーアカウントは、サーバーによって管理されるデータのみを所有する必要があり、他のデーモンと共有しないでください。 （たとえば、ユーザー &lt;code&gt;nobody&lt;/code&gt; を使用することは悪い考えではありません。）特に、侵害されたサーバープロセスがこれらの実行可能ファイルを変更できないようにするために、このユーザーアカウントはPostgreSQL実行可能ファイルを所有しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5f9153f6ce7772c623a80d637e2a8064efd48ff4" translate="yes" xml:space="preserve">
          <source>As with any server daemon that is accessible to the outside world, it is advisable to run PostgreSQL under a separate user account. This user account should only own the data that is managed by the server, and should not be shared with other daemons. (For example, using the user &lt;code&gt;nobody&lt;/code&gt; is a bad idea.) It is not advisable to install executables owned by this user because compromised systems could then modify their own binaries.</source>
          <target state="translated">外部からアクセスできるサーバーデーモンと同様に、PostgreSQLは別のユーザーアカウントで実行することをお勧めします。このユーザーアカウントは、サーバーによって管理されるデータのみを所有する必要があり、他のデーモンと共有しないでください。（たとえば、ユーザー &lt;code&gt;nobody&lt;/code&gt; を使用することは悪い考えです。）侵害されたシステムが独自のバイナリを変更する可能性があるため、このユーザーが所有する実行可能ファイルをインストールすることはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="c718a2b52c9e3b6c8aed088c8f0e6614024fc446" translate="yes" xml:space="preserve">
          <source>As with base backups, the easiest way to produce a standalone hot backup is to use the &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt; tool. If you include the &lt;code&gt;-X&lt;/code&gt; parameter when calling it, all the write-ahead log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</source>
          <target state="translated">ベースバックアップと同様に、スタンドアロンのホットバックアップを作成する最も簡単な方法は、&lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;ツールを使用することです。呼び出し時に &lt;code&gt;-X&lt;/code&gt; パラメーターを含めると、バックアップを使用するために必要なすべての先行書き込みログが自動的にバックアップに含まれ、バックアップを復元するための特別なアクションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="478aba2ebcc8faa95902624459b6a85534e22480" translate="yes" xml:space="preserve">
          <source>As with dropping a column, you need to add &lt;code&gt;CASCADE&lt;/code&gt; if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s).</source>
          <target state="translated">列の削除と同様に、何かが依存している制約を削除する場合は、 &lt;code&gt;CASCADE&lt;/code&gt; を追加する必要があります。たとえば、外部キー制約は、参照される列の一意または主キー制約に依存します。</target>
        </trans-unit>
        <trans-unit id="f3f0c2f615e83e516256da21365a0381f69d219d" translate="yes" xml:space="preserve">
          <source>As with other PostgreSQL text search configuration files, the rules file must be stored in UTF-8 encoding. The data is automatically translated into the current database's encoding when loaded. Any lines containing untranslatable characters are silently ignored, so that rules files can contain rules that are not applicable in the current encoding.</source>
          <target state="translated">他のPostgreSQLテキスト検索設定ファイルと同様に、ルールファイルはUTF-8エンコーディングで格納されている必要があります。データはロード時に現在のデータベースのエンコーディングに自動的に翻訳されます。翻訳不可能な文字を含む行は静かに無視されますので、ルールファイルには現在のエンコーディングでは適用できないルールを含めることができます。</target>
        </trans-unit>
        <trans-unit id="10502eec64e33ad71eb02c8495b055a53abfa416" translate="yes" xml:space="preserve">
          <source>As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed.</source>
          <target state="translated">通常のファイルシステムバックアップ技術と同様に、この方法はデータベースクラスタ全体の復元のみをサポートし、サブセットはサポートしません。また、多くのアーカイブストレージを必要とします。ベースバックアップはかさばるかもしれませんし、忙しいシステムでは、アーカイブされなければならない多くのメガバイトのWALトラフィックが発生します。それでも、高い信頼性が必要とされる多くの状況では、これが好ましいバックアップ手法です。</target>
        </trans-unit>
        <trans-unit id="41912914d23f57d6b4964446c4839bcd6bf6e2ec" translate="yes" xml:space="preserve">
          <source>As with vacuuming for space recovery, frequent updates of statistics are more useful for heavily-updated tables than for seldom-updated ones. But even for a heavily-updated table, there might be no need for statistics updates if the statistical distribution of the data is not changing much. A simple rule of thumb is to think about how much the minimum and maximum values of the columns in the table change. For example, a &lt;code&gt;timestamp&lt;/code&gt; column that contains the time of row update will have a constantly-increasing maximum value as rows are added and updated; such a column will probably need more frequent statistics updates than, say, a column containing URLs for pages accessed on a website. The URL column might receive changes just as often, but the statistical distribution of its values probably changes relatively slowly.</source>
          <target state="translated">スペース回復のためのバキューム処理と同様に、統計の頻繁な更新は、頻繁に更新されるテーブルよりも、頻繁に更新されるテーブルの方が役立ちます。ただし、頻繁に更新されるテーブルであっても、データの統計的分布があまり変化しない場合は、統計を更新する必要がない場合があります。簡単な経験則は、テーブルの列の最小値と最大値がどれだけ変化するかを考えることです。たとえば、 &lt;code&gt;timestamp&lt;/code&gt; 行の更新時刻を含む列には、行が追加および更新されるにつれて、最大値が常に増加します。このような列は、たとえば、WebサイトでアクセスされたページのURLを含む列よりも頻繁に統計を更新する必要があります。URL列は同じくらい頻繁に変更を受け取る可能性がありますが、その値の統計的分布はおそらく比較的ゆっくりと変化します。</target>
        </trans-unit>
        <trans-unit id="25d8d489832d7110fbb67ed9e2a0a908cb5a5e5d" translate="yes" xml:space="preserve">
          <source>As you can see, in this skeleton we're dealing with a data type where &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt;. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</source>
          <target state="translated">ご覧のとおり、このスケルトンでは、 &lt;code&gt;union(X, Y, Z) = union(union(X, Y), Z)&lt;/code&gt; であるデータ型を扱っています。このGiSTサポートメソッドに適切なユニオンアルゴリズムを実装することで、そうでない場合でもデータ型をサポートするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="bf9aec8aa0de7661a07d98a75f47c3b69757e7a1" translate="yes" xml:space="preserve">
          <source>As you see, pg_dump writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, pg_dump can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</source>
          <target state="translated">ご覧のように、pg_dumpはその結果を標準出力に書き込みます。これがどのように有用であるかを後述します。上記のコマンドはテキストファイルを作成しますが、pg_dumpは他の形式でファイルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="21e1923806603d461ddac0e0413cc2a388550aac" translate="yes" xml:space="preserve">
          <source>As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word &lt;code&gt;CHECK&lt;/code&gt; followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense.</source>
          <target state="translated">ご覧のとおり、制約の定義は、デフォルト値の定義と同様に、データ型の後にあります。デフォルト値と制約は任意の順序でリストできます。チェック制約は、キーワード &lt;code&gt;CHECK&lt;/code&gt; とそれに続く括弧内の式で構成されます。チェック制約式は、このように制約された列を含む必要があります。そうでない場合、制約はあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="d1b9d2baec69327019075ccf63fb47f3a04b6635" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">ご覧のとおり、新しい値の式は行の既存の値を参照できます。 &lt;code&gt;WHERE&lt;/code&gt; 句も省略しました。省略した場合、テーブルのすべての行が更新されます。存在する場合、 &lt;code&gt;WHERE&lt;/code&gt; 条件に一致する行のみが更新されます。 &lt;code&gt;SET&lt;/code&gt; 句の等号は代入であり、 &lt;code&gt;WHERE&lt;/code&gt; 句の等号は比較ですが、これによって曖昧さが生じることはありません。もちろん、 &lt;code&gt;WHERE&lt;/code&gt; 条件は等価テストである必要はありません。他の多くの演算子が利用可能です（&lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;第9章を&lt;/a&gt;参照）。ただし、式はブール結果に評価される必要があります。</target>
        </trans-unit>
        <trans-unit id="439358cf5e5d4c690518e4e11abfb19b1e44a30e" translate="yes" xml:space="preserve">
          <source>As you see, the expression for the new value can refer to the existing value(s) in the row. We also left out the &lt;code&gt;WHERE&lt;/code&gt; clause. If it is omitted, it means that all rows in the table are updated. If it is present, only those rows that match the &lt;code&gt;WHERE&lt;/code&gt; condition are updated. Note that the equals sign in the &lt;code&gt;SET&lt;/code&gt; clause is an assignment while the one in the &lt;code&gt;WHERE&lt;/code&gt; clause is a comparison, but this does not create any ambiguity. Of course, the &lt;code&gt;WHERE&lt;/code&gt; condition does not have to be an equality test. Many other operators are available (see &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt;). But the expression needs to evaluate to a Boolean result.</source>
          <target state="translated">ご覧のとおり、新しい値の式は、行内の既存の値を参照できます。また、 &lt;code&gt;WHERE&lt;/code&gt; 句も省略しました。省略した場合は、テーブル内のすべての行が更新されることを意味します。存在する場合、 &lt;code&gt;WHERE&lt;/code&gt; 条件に一致する行のみが更新されます。 &lt;code&gt;SET&lt;/code&gt; 句の等号は割り当てであり、 &lt;code&gt;WHERE&lt;/code&gt; 句の等号は比較であることに注意してください。ただし、これによってあいまいさが生じることはありません。もちろん、 &lt;code&gt;WHERE&lt;/code&gt; 条件は同等性テストである必要はありません。他の多くの演算子を使用できます（&lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;第9章を&lt;/a&gt;参照）。ただし、式はブール結果に評価される必要があります。</target>
        </trans-unit>
        <trans-unit id="313a697ffb23a7210631919b2999246578e93b67" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they are designed not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt;. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.) This applies to the following commands:</source>
          <target state="translated">それらがあれば、すべてのWALを書き込みしないように設計されているので別にWALデータを処理するアーカイバまたはWAL送信者のための時間を避けてから、これを実行すると、実際に、より高速な特定のコマンドを行います &lt;code&gt;wal_level&lt;/code&gt; がある &lt;code&gt;minimal&lt;/code&gt; 。（WALを記述するよりも、最後に &lt;code&gt;fsync&lt;/code&gt; を実行する方が、より安全にクラッシュの安全性を保証できます。）これは、次のコマンドに適用されます。</target>
        </trans-unit>
        <trans-unit id="b1744fb0dcc66faea0f0e11e29ee96bb68e2530a" translate="yes" xml:space="preserve">
          <source>Aside from avoiding the time for the archiver or WAL sender to process the WAL data, doing this will actually make certain commands faster, because they do not to write WAL at all if &lt;code&gt;wal_level&lt;/code&gt; is &lt;code&gt;minimal&lt;/code&gt; and the current subtransaction (or top-level transaction) created or truncated the table or index they change. (They can guarantee crash safety more cheaply by doing an &lt;code&gt;fsync&lt;/code&gt; at the end than by writing WAL.)</source>
          <target state="translated">アーカイバまたはWAL送信者がWALデータを処理する時間を回避する以外に、これを行うと、実際には特定のコマンドが高速になります。これは、 &lt;code&gt;wal_level&lt;/code&gt; が &lt;code&gt;minimal&lt;/code&gt; で、現在のサブトランザクション（またはトップレベルトランザクション）の場合、WALをまったく書き込まないためです。変更するテーブルまたはインデックスを作成または切り捨てました。（WALを作成するよりも、最後に &lt;code&gt;fsync&lt;/code&gt; を実行する方が、クラッシュの安全性をより安価に保証できます。）</target>
        </trans-unit>
        <trans-unit id="ba62da50a0cd807fd06ac3427894951fdffc554f" translate="yes" xml:space="preserve">
          <source>Aside from preventing cycles, the array value is often useful in its own right as representing the &amp;ldquo;path&amp;rdquo; taken to reach any particular row.</source>
          <target state="translated">サイクルの防止とは別に、配列値は、特定の行に到達するために取られる「パス」を表すために、それ自体でしばしば有用です。</target>
        </trans-unit>
        <trans-unit id="f08bd4c872560fdf37016b1456326d2f1f83a30c" translate="yes" xml:space="preserve">
          <source>Aside from the index's own internal consistency requirements, concurrent updates create issues about consistency between the parent table (the &lt;em&gt;heap&lt;/em&gt;) and the index. Because PostgreSQL separates accesses and updates of the heap from those of the index, there are windows in which the index might be inconsistent with the heap. We handle this problem with the following rules:</source>
          <target state="translated">インデックス自体の内部整合性要件とは別に、同時更新では、親テーブル（&lt;em&gt;ヒープ&lt;/em&gt;）とインデックス間の整合性に関する問題が発生します。PostgreSQLはヒープのアクセスと更新をインデックスのアクセスと更新から分離しているため、インデックスがヒープと一致しない可能性があるウィンドウがあります。この問題は次のルールで処理します。</target>
        </trans-unit>
        <trans-unit id="66acedea6ec5e6c71ffc128f764e1116af5e0326" translate="yes" xml:space="preserve">
          <source>Assign a literal constant default value for the column &lt;code&gt;name&lt;/code&gt;, arrange for the default value of column &lt;code&gt;did&lt;/code&gt; to be generated by selecting the next value of a sequence object, and make the default value of &lt;code&gt;modtime&lt;/code&gt; be the time at which the row is inserted:</source>
          <target state="translated">列リテラル定数のデフォルト値割り当てる &lt;code&gt;name&lt;/code&gt; 、カラムのデフォルト値が手配 &lt;code&gt;did&lt;/code&gt; シーケンス・オブジェクトの次の値を選択することによって生成される、とのデフォルト値作る &lt;code&gt;modtime&lt;/code&gt; 行が挿入された時刻です。</target>
        </trans-unit>
        <trans-unit id="1bfbe2935df02c420c8e520ec3e42a7fba80f23c" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to each element of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">指定された&lt;em&gt; &lt;code&gt;weight&lt;/code&gt; &lt;/em&gt;を&lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt;各要素に割り当てます。</target>
        </trans-unit>
        <trans-unit id="75a4d3134c8b9723881f294a52dd576fc9852c4b" translate="yes" xml:space="preserve">
          <source>Assigns the specified &lt;em&gt;&lt;code&gt;weight&lt;/code&gt;&lt;/em&gt; to elements of the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt; that are listed in &lt;em&gt;&lt;code&gt;lexemes&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;lexemes&lt;/code&gt; &lt;/em&gt;リストされている&lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt;要素に指定された&lt;em&gt; &lt;code&gt;weight&lt;/code&gt; &lt;/em&gt;を&lt;em&gt;割り当て&lt;/em&gt;ます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f079970016568a6988faea4629841a26d4520b05" translate="yes" xml:space="preserve">
          <source>Associated sort operator (zero if none)</source>
          <target state="translated">関連ソート演算子(ない場合はゼロ</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="d530f867f7438d52f3d933c2185ee58e5795fb55" translate="yes" xml:space="preserve">
          <source>Assume a table like this:</source>
          <target state="translated">このようなテーブルを想定します。</target>
        </trans-unit>
        <trans-unit id="d62cfe7fee7bb0995d8fe897df02204b5ae94b18" translate="yes" xml:space="preserve">
          <source>Assume we have dumped a database called &lt;code&gt;mydb&lt;/code&gt; into a custom-format dump file:</source>
          <target state="translated">&lt;code&gt;mydb&lt;/code&gt; というデータベースをカスタム形式のダンプファイルにダンプしたとします。</target>
        </trans-unit>
        <trans-unit id="00714db2b04e92390b518c92e4ea170b71450adc" translate="yes" xml:space="preserve">
          <source>Assuming that there is a table called &lt;code&gt;table1&lt;/code&gt;, this command would retrieve all rows and all user-defined columns from &lt;code&gt;table1&lt;/code&gt;. (The method of retrieval depends on the client application. For example, the psql program will display an ASCII-art table on the screen, while client libraries will offer functions to extract individual values from the query result.) The select list specification &lt;code&gt;*&lt;/code&gt; means all columns that the table expression happens to provide. A select list can also select a subset of the available columns or make calculations using the columns. For example, if &lt;code&gt;table1&lt;/code&gt; has columns named &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; (and perhaps others) you can make the following query:</source>
          <target state="translated">&lt;code&gt;table1&lt;/code&gt; と呼ばれるテーブルがあると想定すると、このコマンドはtable1からすべての行とすべてのユーザー定義列を取得し &lt;code&gt;table1&lt;/code&gt; 。（取得方法はクライアントアプリケーションによって異なります。たとえば、psqlプログラムは画面にASCIIアートテーブルを表示しますが、クライアントライブラリはクエリ結果から個々の値を抽出する関数を提供します。）選択リストの指定 &lt;code&gt;*&lt;/code&gt; は、テーブル式がたまたま提供するすべての列。選択リストでは、使用可能な列のサブセットを選択したり、列を使用して計算を行ったりすることもできます。たとえば、 &lt;code&gt;table1&lt;/code&gt; に &lt;code&gt;b&lt;/code&gt; 、b、および &lt;code&gt;c&lt;/code&gt; という名前 &lt;code&gt;a&lt;/code&gt; 列がある場合 （およびおそらく他の）次のクエリを実行できます。</target>
        </trans-unit>
        <trans-unit id="89e7e252c06bfdf34cb9f5a168b455ee141acee7" translate="yes" xml:space="preserve">
          <source>Async. MM Repl.</source>
          <target state="translated">非同期です。MM Repl.</target>
        </trans-unit>
        <trans-unit id="a6a8e2732fbce126a0a797cdd1e90b4272d9f93c" translate="yes" xml:space="preserve">
          <source>Asynchronous Commit</source>
          <target state="translated">非同期コミット</target>
        </trans-unit>
        <trans-unit id="1d15a4a3147c0af21cd5fba27008e02e7487f287" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O depends on an effective &lt;code&gt;posix_fadvise&lt;/code&gt; function, which some operating systems lack. If the function is not present then setting this parameter to anything but zero will result in an error. On some operating systems (e.g., Solaris), the function is present but does not actually do anything.</source>
          <target state="translated">非同期I / Oは、一部のオペレーティングシステムにはない効果的な &lt;code&gt;posix_fadvise&lt;/code&gt; 関数に依存しています。関数が存在しない場合、このパラメーターをゼロ以外に設定すると、エラーが発生します。一部のオペレーティングシステム（Solarisなど）では、関数は存在しますが、実際には何も実行しません。</target>
        </trans-unit>
        <trans-unit id="abb97da8205f09a691f99d2fcdea6f23dc61d65e" translate="yes" xml:space="preserve">
          <source>Asynchronous Multimaster Replication</source>
          <target state="translated">非同期マルチマスターレプリケーション</target>
        </trans-unit>
        <trans-unit id="00b2ec7d525c7895ab7759ef95defc6c17d534cd" translate="yes" xml:space="preserve">
          <source>Asynchronous commit introduces the risk of data loss. There is a short time window between the report of transaction completion to the client and the time that the transaction is truly committed (that is, it is guaranteed not to be lost if the server crashes). Thus asynchronous commit should not be used if the client will take external actions relying on the assumption that the transaction will be remembered. As an example, a bank would certainly not use asynchronous commit for a transaction recording an ATM's dispensing of cash. But in many scenarios, such as event logging, there is no need for a strong guarantee of this kind.</source>
          <target state="translated">非同期コミットはデータ損失のリスクを伴います。クライアントにトランザクションの完了を報告してから、トランザクションが本当にコミットされるまでの間には短い時間があります(つまり、サーバがクラッシュしてもデータが失われないことが保証されています)。したがって、クライアントがトランザクションが記憶されることを前提とした外部のアクションを行う場合には、非同期コミットは使用すべきではありません。例えば、銀行がATMで現金を払い出したことを記録するトランザクションに非同期コミットを使うことはないでしょう。しかし、イベントロギングのような多くのシナリオでは、この種の強力な保証は必要ありません。</target>
        </trans-unit>
        <trans-unit id="d90c24d882782b103f7c8579885000885b06b013" translate="yes" xml:space="preserve">
          <source>Asynchronous commit provides behavior different from setting &lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = off. &lt;code&gt;fsync&lt;/code&gt; is a server-wide setting that will alter the behavior of all transactions. It disables all logic within PostgreSQL that attempts to synchronize writes to different portions of the database, and therefore a system crash (that is, a hardware or operating system crash, not a failure of PostgreSQL itself) could result in arbitrarily bad corruption of the database state. In many scenarios, asynchronous commit provides most of the performance improvement that could be obtained by turning off &lt;code&gt;fsync&lt;/code&gt;, but without the risk of data corruption.</source>
          <target state="translated">非同期コミットは、&lt;a href=&quot;runtime-config-wal#GUC-FSYNC&quot;&gt;fsync&lt;/a&gt; = offの設定とは異なる動作を提供します。 &lt;code&gt;fsync&lt;/code&gt; はサーバー全体の設定であり、すべてのトランザクションの動作を変更します。データベースの異なる部分への書き込みを同期しようとするPostgreSQL内のすべてのロジックを無効にするため、システムクラッシュ（つまり、ハードウェアまたはオペレーティングシステムのクラッシュであり、PostgreSQL自体の障害ではない）により、データベースの破損が任意に悪化する可能性があります。状態。多くのシナリオで、非同期コミットは &lt;code&gt;fsync&lt;/code&gt; をオフにすることで得られるパフォーマンスの改善のほとんどを提供しますが、データ破損のリスクはありません。</target>
        </trans-unit>
        <trans-unit id="38108f139265527283b18b5d33c78a6ddd380598" translate="yes" xml:space="preserve">
          <source>At a more basic level, it is not clear that solving query optimization with a GA algorithm designed for TSP is appropriate. In the TSP case, the cost associated with any substring (partial tour) is independent of the rest of the tour, but this is certainly not true for query optimization. Thus it is questionable whether edge recombination crossover is the most effective mutation procedure.</source>
          <target state="translated">より基本的なレベルでは、TSP用に設計されたGAアルゴリズムでクエリ最適化を解くことが適切であることは明らかではありません。TSPの場合、任意の部分文字列(部分巡回)に関連するコストは、残りの部分巡回とは独立していますが、これは確かに問い合わせ最適化には当てはまりません。したがって、エッジ組換えクロスオーバーが最も効果的な突然変異手順であるかどうかは疑問である。</target>
        </trans-unit>
        <trans-unit id="4d29cf5673a23d613acb6f0d1c22f5f4b6b78fcf" translate="yes" xml:space="preserve">
          <source>At all times, PostgreSQL maintains a &lt;em&gt;write ahead log&lt;/em&gt; (WAL) in the &lt;code&gt;pg_wal/&lt;/code&gt; subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by &amp;ldquo;replaying&amp;rdquo; the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits:</source>
          <target state="translated">PostgreSQL は &lt;code&gt;pg_wal/&lt;/code&gt; &lt;em&gt;先読みログ&lt;/em&gt;（WAL）を保持し&lt;em&gt;ています&lt;/em&gt;クラスターのデータディレクトリのサブディレクトリ。ログには、データベースのデータファイルに加えられたすべての変更が記録されます。このログは、主にクラッシュセーフの目的で存在します。システムがクラッシュした場合、最後のチェックポイント以降に作成されたログエントリを「再生」することにより、データベースを一貫性のある状態に復元できます。ただし、ログの存在により、データベースのバックアップに3番目の戦略を使用することが可能になります。ファイルシステムレベルのバックアップとWALファイルのバックアップを組み合わせることができます。リカバリが必要な場合は、ファイルシステムのバックアップを復元し、バックアップされたWALファイルから再生して、システムを現在の状態にします。このアプローチは、以前のいずれのアプローチよりも管理が複雑ですが、いくつかの重要な利点があります。</target>
        </trans-unit>
        <trans-unit id="d0aa9f0f7a8b54305272b705ab4c8ce4332faa1e" translate="yes" xml:space="preserve">
          <source>At compile time, &lt;code&gt;transaction__start&lt;/code&gt; is converted to a macro called &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; (notice the underscores are single here), which is available by including &lt;code&gt;pg_trace.h&lt;/code&gt;. Add the macro call to the appropriate location in the source code. In this case, it looks like the following:</source>
          <target state="translated">コンパイル時に、 &lt;code&gt;transaction__start&lt;/code&gt; は &lt;code&gt;TRACE_POSTGRESQL_TRANSACTION_START&lt;/code&gt; と呼ばれるマクロに変換されます（アンダースコアはここでは1つであることに注意してください）。これは &lt;code&gt;pg_trace.h&lt;/code&gt; をインクルードすることで利用できます。マクロ呼び出しをソースコードの適切な場所に追加します。この場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="1c05bc819458daf00162775e69bb6f11e3009ae1" translate="yes" xml:space="preserve">
          <source>At least as of version 5.1, it should not be necessary to do any special configuration for such parameters as &lt;code&gt;SHMMAX&lt;/code&gt;, as it appears this is configured to allow all memory to be used as shared memory. That is the sort of configuration commonly used for other databases such as DB/2.</source>
          <target state="translated">少なくともバージョン5.1以降では、 &lt;code&gt;SHMMAX&lt;/code&gt; などのパラメーターに対して特別な構成を行う必要はありません。これは、すべてのメモリを共有メモリとして使用できるように構成されているためです。これは、DB / 2などの他のデータベースで一般的に使用される種類の構成です。</target>
        </trans-unit>
        <trans-unit id="df036c0dc6f1685c583f36a683953e72b19d8691" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;LEFTARG&lt;/code&gt; and &lt;code&gt;RIGHTARG&lt;/code&gt; must be defined. For binary operators, both must be defined. For right unary operators, only &lt;code&gt;LEFTARG&lt;/code&gt; should be defined, while for left unary operators only &lt;code&gt;RIGHTARG&lt;/code&gt; should be defined.</source>
          <target state="translated">&lt;code&gt;LEFTARG&lt;/code&gt; および &lt;code&gt;RIGHTARG&lt;/code&gt; の少なくとも1つを定義する必要があります。 2項演算子の場合、両方を定義する必要があります。右単項演算子の場合は &lt;code&gt;LEFTARG&lt;/code&gt; のみを定義し、左単項演算子の場合は &lt;code&gt;RIGHTARG&lt;/code&gt; のみを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="81523154b2540393f2eb08b2e64447cb44f3b4fa" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified to select an action:</source>
          <target state="translated">アクションを選択するには、以下のオプションのうち少なくとも1つを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b72121826b7e4651c5d94f2436d0c7ffe3e3c260" translate="yes" xml:space="preserve">
          <source>At least one of these two things has to be ensured, or the PostgreSQL server will be very unreliable.</source>
          <target state="translated">この2つのうち少なくとも1つは確実にしないと、PostgreSQLサーバは非常に信頼性の低いものになってしまいます。</target>
        </trans-unit>
        <trans-unit id="1571c46302d3bf43b10096af00c294a218c61c85" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt;&lt;code&gt;pg_stat_subscription&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">サブスクリプションごとに少なくとも1つの行で、サブスクリプションワーカーに関する情報を示します。詳細については、&lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-SUBSCRIPTION&quot;&gt; &lt;code&gt;pg_stat_subscription&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d8eaf93cff7d6986839d33f973b6b2eb6f3e3612" translate="yes" xml:space="preserve">
          <source>At least one row per subscription, showing information about the subscription workers. See &lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt; for details.</source>
          <target state="translated">サブスクリプションごとに少なくとも1行。サブスクリプションワーカーに関する情報を示します。詳細は&lt;a href=&quot;monitoring-stats#PG-STAT-SUBSCRIPTION&quot;&gt;pg_stat_subscription&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7d5c8007175669495e5c5ec2b3f06db9f4615159" translate="yes" xml:space="preserve">
          <source>At present, any table used as the target of a data-modifying statement in &lt;code&gt;WITH&lt;/code&gt; must not have a conditional rule, nor an &lt;code&gt;ALSO&lt;/code&gt; rule, nor an &lt;code&gt;INSTEAD&lt;/code&gt; rule that expands to multiple statements.</source>
          <target state="translated">現在、 &lt;code&gt;WITH&lt;/code&gt; でデータ変更ステートメントのターゲットとして使用されるテーブルには、条件付きルール、 &lt;code&gt;ALSO&lt;/code&gt; ルール、または複数のステートメントに展開される &lt;code&gt;INSTEAD&lt;/code&gt; ルールがあってはなりません。</target>
        </trans-unit>
        <trans-unit id="ff0acb0e759b914c8ac0d92fbd4b06b6c52abe9f" translate="yes" xml:space="preserve">
          <source>At present, it's assumed that the sort order for an ordering operator is the default for the referenced operator family, i.e., &lt;code&gt;ASC NULLS LAST&lt;/code&gt;. This might someday be relaxed by adding additional columns to specify sort options explicitly.</source>
          <target state="translated">現在、順序付け演算子の並べ替え順序は、参照される演算子ファミリのデフォルト、つまり &lt;code&gt;ASC NULLS LAST&lt;/code&gt; であると想定されています。これは、列を追加してソートオプションを明示的に指定することにより、いつか緩和される可能性があります。</target>
        </trans-unit>
        <trans-unit id="0da87b74c1c3af23d284a826d817211a0d50dbca" translate="yes" xml:space="preserve">
          <source>At present, the &lt;code&gt;soundex&lt;/code&gt;, &lt;code&gt;metaphone&lt;/code&gt;, &lt;code&gt;dmetaphone&lt;/code&gt;, and &lt;code&gt;dmetaphone_alt&lt;/code&gt; functions do not work well with multibyte encodings (such as UTF-8).</source>
          <target state="translated">現在、 &lt;code&gt;soundex&lt;/code&gt; 、 &lt;code&gt;metaphone&lt;/code&gt; 、 &lt;code&gt;dmetaphone&lt;/code&gt; 、および &lt;code&gt;dmetaphone_alt&lt;/code&gt; 関数は、マルチバイトエンコーディング（UTF-8など）ではうまく機能しません。</target>
        </trans-unit>
        <trans-unit id="a78a49f80284f34a995726cc4689e41d04fb4798" translate="yes" xml:space="preserve">
          <source>At present, this setting is supported only on Linux and Windows. The setting is ignored on other systems when set to &lt;code&gt;try&lt;/code&gt;.</source>
          <target state="translated">現在、この設定はLinuxとWindowsでのみサポートされています。 &lt;code&gt;try&lt;/code&gt; に設定すると、他のシステムではこの設定は無視されます。</target>
        </trans-unit>
        <trans-unit id="965d1f5ec334a9d95d86fe2f92675d08806b41f2" translate="yes" xml:space="preserve">
          <source>At startup, the standby begins by restoring all WAL available in the archive location, calling &lt;code&gt;restore_command&lt;/code&gt;. Once it reaches the end of WAL available there and &lt;code&gt;restore_command&lt;/code&gt; fails, it tries to restore any WAL available in the &lt;code&gt;pg_wal&lt;/code&gt; directory. If that fails, and streaming replication has been configured, the standby tries to connect to the primary server and start streaming WAL from the last valid record found in archive or &lt;code&gt;pg_wal&lt;/code&gt;. If that fails or streaming replication is not configured, or if the connection is later disconnected, the standby goes back to step 1 and tries to restore the file from the archive again. This loop of retries from the archive, &lt;code&gt;pg_wal&lt;/code&gt;, and via streaming replication goes on until the server is stopped or failover is triggered by a trigger file.</source>
          <target state="translated">起動時に、スタンバイは、アーカイブの場所で利用可能なすべてのWALを復元し、 &lt;code&gt;restore_command&lt;/code&gt; を呼び出します。そこで利用可能なWALの最後に到達し、 &lt;code&gt;restore_command&lt;/code&gt; が失敗すると、 &lt;code&gt;pg_wal&lt;/code&gt; ディレクトリで利用可能なWALを復元しようとします。これが失敗し、ストリーミングレプリケーションが構成されている場合、スタンバイはプライマリサーバーに接続し、アーカイブまたは &lt;code&gt;pg_wal&lt;/code&gt; で見つかった最後の有効なレコードからストリーミングWALを開始しようとします。これが失敗した場合、またはストリーミングレプリケーションが構成されていない場合、または接続が後で切断された場合、スタンバイは手順1に戻り、アーカイブからファイルを再度復元しようとします。アーカイブ &lt;code&gt;pg_wal&lt;/code&gt; からのこの再試行ループ、およびストリーミングレプリケーションは、サーバーが停止するか、トリガーファイルによってフェイルオーバーがトリガーされるまで続きます。</target>
        </trans-unit>
        <trans-unit id="55d8465dd064f760adc6de27f3c71c491c82a460" translate="yes" xml:space="preserve">
          <source>At the &lt;code&gt;REPEATABLE READ&lt;/code&gt; or &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level this would cause a serialization failure (with a &lt;code&gt;SQLSTATE&lt;/code&gt; of &lt;code&gt;'40001'&lt;/code&gt;), so there is no possibility of receiving rows out of order under these isolation levels.</source>
          <target state="translated">で &lt;code&gt;REPEATABLE READ&lt;/code&gt; または &lt;code&gt;SERIALIZABLE&lt;/code&gt; トランザクション分離レベルこれは（とシリアライズ障害引き起こす &lt;code&gt;SQLSTATE&lt;/code&gt; の &lt;code&gt;'40001'&lt;/code&gt; ）ので、これらの分離レベルの下順不同行を受けることはありません。</target>
        </trans-unit>
        <trans-unit id="f4f71998c9c0aa9a84a8100c70ee8a9266c4e5a9" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be performed on the source server. This can take some time (especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used), during which pg_basebackup will appear to be idle.</source>
          <target state="translated">バックアップの開始時に、ソースサーバーでチェックポイントを実行する必要があります。これには時間がかかる場合があり（特にオプション &lt;code&gt;--checkpoint=fast&lt;/code&gt; が使用されていない場合）、その間pg_basebackupはアイドル状態のように見えます。</target>
        </trans-unit>
        <trans-unit id="d9934a1c03bcddc43aaddd8a50e8957f0b10bf33" translate="yes" xml:space="preserve">
          <source>At the beginning of the backup, a checkpoint needs to be written on the server the backup is taken from. Especially if the option &lt;code&gt;--checkpoint=fast&lt;/code&gt; is not used, this can take some time during which pg_basebackup will be appear to be idle.</source>
          <target state="translated">バックアップの開始時に、バックアップを取得するサーバーにチェックポイントを書き込む必要があります。特にオプション &lt;code&gt;--checkpoint=fast&lt;/code&gt; が使用されていない場合、pg_basebackupがアイドル状態のように見えるまでに時間がかかることがあります。</target>
        </trans-unit>
        <trans-unit id="0a42b715d6522241c83704ed30aede2b52fb0a06" translate="yes" xml:space="preserve">
          <source>At the default &amp;ldquo;scale factor&amp;rdquo; of 1, the tables initially contain this many rows:</source>
          <target state="translated">デフォルトの「スケール係数」が1の場合、テーブルには最初、これだけ多くの行が含まれています。</target>
        </trans-unit>
        <trans-unit id="1c903746f8f0e8094ed1c641f98efb9a635313ed" translate="yes" xml:space="preserve">
          <source>At the end of each session, &lt;code&gt;UNLISTEN *&lt;/code&gt; is automatically executed.</source>
          <target state="translated">各セッションの最後に、 &lt;code&gt;UNLISTEN *&lt;/code&gt; が自動的に実行されます。</target>
        </trans-unit>
        <trans-unit id="8cd262012c4caf6374bfb34cbb6a915df644c90b" translate="yes" xml:space="preserve">
          <source>At the end of recovery, &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; held by prepared transactions will require twice the normal number of lock table entries. If you plan on running either a large number of concurrent prepared transactions that normally take &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, or you plan on having one large transaction that takes many &lt;code&gt;AccessExclusiveLocks&lt;/code&gt;, you are advised to select a larger value of &lt;code&gt;max_locks_per_transaction&lt;/code&gt;, perhaps as much as twice the value of the parameter on the primary server. You need not consider this at all if your setting of &lt;code&gt;max_prepared_transactions&lt;/code&gt; is 0.</source>
          <target state="translated">リカバリの最後に、準備されたトランザクションによって保持されている &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; には、通常の2倍のロックテーブルエントリが必要になります。あなたが通常取る同時準備されたトランザクションの数が多いのいずれかで実行する予定の場合は &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; を多く取る一つの大きなトランザクションた上で、またはあなたが計画 &lt;code&gt;AccessExclusiveLocks&lt;/code&gt; を、あなたは、より大きな値を選択することをお勧めします &lt;code&gt;max_locks_per_transaction&lt;/code&gt; の値の2倍として、おそらく同じくらい、プライマリサーバーのパラメーター。 &lt;code&gt;max_prepared_transactions&lt;/code&gt; の設定が0の場合、これを考慮する必要はありません。</target>
        </trans-unit>
        <trans-unit id="14547baffec9c8ba5963d60806059645bd69fca9" translate="yes" xml:space="preserve">
          <source>At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen.</source>
          <target state="translated">プロンプトでは、ユーザーはSQLコマンドを入力することができます。通常、入力行は、コマンドで終了するセミコロンに達するとサーバーに送信されます。行末はコマンドを終了させません。そのため、コマンドはわかりやすくするために複数行に分けることができます。コマンドが送信され、エラーなく実行された場合は、コマンドの結果が画面に表示されます。</target>
        </trans-unit>
        <trans-unit id="a73b24b0f045657de48b1ab740f05e1e597825d0" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">同時に、 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; は、2番目の文字列内の単語の範囲を選択します。上記の例では、 &lt;code&gt;strict_word_similarity(text, text)&lt;/code&gt; は、トライグラムのセットが &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; である単一の単語 &lt;code&gt;'words'&lt;/code&gt; の範囲を選択します。 ds &quot;}。</target>
        </trans-unit>
        <trans-unit id="d1227060ad6250b9807827bf5fbb82f644935b87" translate="yes" xml:space="preserve">
          <source>At the same time, &lt;code&gt;strict_word_similarity&lt;/code&gt; selects an extent of words in the second string. In the example above, &lt;code&gt;strict_word_similarity&lt;/code&gt; would select the extent of a single word &lt;code&gt;'words'&lt;/code&gt;, whose set of trigrams is &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt;.</source>
          <target state="translated">同時に、 &lt;code&gt;strict_word_similarity&lt;/code&gt; は、2番目の文字列の単語の範囲を選択します。上記の例では、 &lt;code&gt;strict_word_similarity&lt;/code&gt; は、トリグラムのセットが &lt;code&gt;{&quot; w&quot;,&quot; wo&quot;,&quot;wor&quot;,&quot;ord&quot;,&quot;rds&quot;,&quot;ds &quot;}&lt;/code&gt; である単一の単語 &lt;code&gt;'words'&lt;/code&gt; の範囲を選択します。</target>
        </trans-unit>
        <trans-unit id="416a07de78793e22bb0ac6ecdc4a78f4b476ae54" translate="yes" xml:space="preserve">
          <source>At the time of creation, all existing heap pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; or &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; functions; automatically when &lt;code&gt;VACUUM&lt;/code&gt; processes the table; or by automatic summarization executed by autovacuum, as insertions occur. (This last trigger is disabled by default and can be enabled with the &lt;code&gt;autosummarize&lt;/code&gt; parameter.) Conversely, a range can be de-summarized using the &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; function, which is useful when the index tuple is no longer a very good representation because the existing values have changed.</source>
          <target state="translated">作成時に、既存のすべてのヒープページがスキャンされ、最後に不完全である可能性のある範囲を含め、各範囲に対してサマリーインデックスタプルが作成されます。新しいページがデータで満たされると、既に要約されているページ範囲により、要約情報が新しいタプルからのデータで更新されます。最後に要約された範囲に含まれない新しいページが作成された場合、その範囲は自動的に要約タプルを取得しません。これらのタプルは、後で要約の実行が呼び出されて初期の要約が作成されるまで、要約されません。このプロセスは、 &lt;code&gt;brin_summarize_range(regclass, bigint)&lt;/code&gt; または &lt;code&gt;brin_summarize_new_values(regclass)&lt;/code&gt; 関数を使用して手動で呼び出すことができます。 &lt;code&gt;VACUUM&lt;/code&gt; 時に自動的にテーブルを処理します。または、挿入が発生したときにautovacuumによって実行される自動要約。（この最後のトリガーはデフォルトで無効になっており、 &lt;code&gt;autosummarize&lt;/code&gt; パラメーターを使用して有効にできます。）逆に、範囲は &lt;code&gt;brin_desummarize_range(regclass, bigint)&lt;/code&gt; 関数を使用して逆要約できます。これは、インデックスタプルがあまり適切でない場合に役立ちます。既存の値が変更されたため、表現。</target>
        </trans-unit>
        <trans-unit id="570ab49c8c4979d8f2b45f71407d683f61c768c4" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;pg_proc.dat&lt;/code&gt; has all three columns, &lt;code&gt;prokind&lt;/code&gt;, &lt;code&gt;proisagg&lt;/code&gt;, and &lt;code&gt;proiswindow&lt;/code&gt;, though they will appear only in rows where they have non-default values.</source>
          <target state="translated">この時点で、 &lt;code&gt;pg_proc.dat&lt;/code&gt; には &lt;code&gt;prokind&lt;/code&gt; 、 &lt;code&gt;proisagg&lt;/code&gt; 、および &lt;code&gt;proiswindow&lt;/code&gt; の 3つの列がすべてありますが、デフォルト以外の値がある行にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="394da4678018ab888c36788be82e3560af3396a8" translate="yes" xml:space="preserve">
          <source>At this point, you will have an index on the &lt;code&gt;t&lt;/code&gt; column that you can use for similarity searching. A typical query is</source>
          <target state="translated">この時点で、 &lt;code&gt;t&lt;/code&gt; 列にインデックスがあり、類似性検索に使用できます。典型的なクエリは</target>
        </trans-unit>
        <trans-unit id="2a3a5c5f47d6770989533a4fd46849cfebf7e2e9" translate="yes" xml:space="preserve">
          <source>At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases:</source>
          <target state="translated">この記事を書いている時点では、継続的なアーカイブ技術にはいくつかの制限があります。これらはおそらく将来のリリースで修正されるでしょう。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="cfaa3dc03c49871e78cddda27fc42c3f092dc0c4" translate="yes" xml:space="preserve">
          <source>Attach a comment to the table &lt;code&gt;mytable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mytable&lt;/code&gt; テーブルにコメントを添付します。</target>
        </trans-unit>
        <trans-unit id="b30d15695b4486ee3edc48c2da787bd31caa82e5" translate="yes" xml:space="preserve">
          <source>Attaching a partition acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table, in addition to &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; locks on the table to be attached and on the default partition (if any).</source>
          <target state="translated">パーティションをアタッチすると、アタッチされるテーブルとデフォルトパーティション（存在する場合）の &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックに加えて、親テーブルの &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックが取得されます。</target>
        </trans-unit>
        <trans-unit id="d4f51e4421d7c33f901d2846a5f5963016f01207" translate="yes" xml:space="preserve">
          <source>Attempt to allow server crashes to produce core files, on platforms where this is possible, by lifting any soft resource limit placed on core files. This is useful in debugging or diagnosing problems by allowing a stack trace to be obtained from a failed server process.</source>
          <target state="translated">これが可能なプラットフォームでは、コアファイルにかけられたソフトリソースの制限を解除することで、サーバクラッシュがコアファイルを生成できるようにしようとします。これは、失敗したサーバプロセスからスタックトレースを取得できるようにすることで、 問題のデバッグや診断に役立ちます。</target>
        </trans-unit>
        <trans-unit id="22d313995c5aa4824bbbe6a43fa47548d5dd9981" translate="yes" xml:space="preserve">
          <source>Attempt to insert a new stock item along with the quantity of stock. If the item already exists, instead update the stock count of the existing item. To do this without failing the entire transaction, use savepoints:</source>
          <target state="translated">新しい在庫アイテムを在庫数と一緒に挿入しようとします。アイテムがすでに存在する場合は、代わりに既存のアイテムの在庫数を更新します。トランザクション全体を失敗させずにこれを行うには、savepointsを使用します。</target>
        </trans-unit>
        <trans-unit id="77a267ab017550f3c7b55ed8bceaa27e998a453f" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database before dropping it. See &lt;a href=&quot;sql-dropdatabase&quot;&gt;DROP DATABASE&lt;/a&gt; for more information on this option.</source>
          <target state="translated">ターゲットデータベースを削除する前に、ターゲットデータベースへの既存の接続をすべて終了してみてください。このオプションの詳細については、&lt;a href=&quot;sql-dropdatabase&quot;&gt;DROPDATABASE&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="918622fae6a483ce282b6f622cf8bcadbed1c7e1" translate="yes" xml:space="preserve">
          <source>Attempt to terminate all existing connections to the target database. It doesn't terminate if prepared transactions, active logical replication slots or subscriptions are present in the target database.</source>
          <target state="translated">ターゲット・データベースへの既存のすべての接続の終了を試みます。ターゲット・データベースに準備されたトランザクション、アクティブな論理レプリケーション・スロット、またはサブスクリプションが存在する場合は終了しません。</target>
        </trans-unit>
        <trans-unit id="76eb27398e988091546915b412edd431f3061249" translate="yes" xml:space="preserve">
          <source>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; variant to avoid the error messages, but this is not standard SQL.)</source>
          <target state="translated">存在しないテーブルを削除しようとするとエラーになります。それでも、SQLスクリプトファイルでは、テーブルを作成する前に無条件に各テーブルを削除しようとし、エラーメッセージを無視して、テーブルが存在するかどうかに関係なくスクリプトが機能するようにするのが一般的です。（必要に応じて、 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; バリアントを使用してエラーメッセージを回避できますが、これは標準SQLではありません。）</target>
        </trans-unit>
        <trans-unit id="a0d00292b426c90d6f3e1dbff7f81bbe2e552240" translate="yes" xml:space="preserve">
          <source>Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a &amp;ldquo;month&amp;rdquo; or &amp;ldquo;day of month&amp;rdquo; has no meaning. In the context of a Gregorian year, the ISO week has no meaning.</source>
          <target state="translated">ISO 8601の週番号フィールドとグレゴリオ暦の日付フィールドを組み合わせて日付を入力しようとしても無意味で、エラーが発生します。ISO 8601の週番号の年の文脈では、「月」または「月の日」の概念は意味を持ちません。グレゴリオ年の文脈では、ISO週は意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="c85e1c86ef58d9df3e2aa30f481d2a46d06ccc08" translate="yes" xml:space="preserve">
          <source>Attribute to match against the user name in the search when doing search+bind authentication. If no attribute is specified, the &lt;code&gt;uid&lt;/code&gt; attribute will be used.</source>
          <target state="translated">検索+バインド認証を行うときに、検索でユーザー名と照合する属性。属性が指定されていない場合、 &lt;code&gt;uid&lt;/code&gt; 属性が使用されます。</target>
        </trans-unit>
        <trans-unit id="666a0c222579ebcb139d2bf4bc0c9f0b94222439" translate="yes" xml:space="preserve">
          <source>Attribute-level foreign data wrapper options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての属性レベルの外部データラッパーオプション</target>
        </trans-unit>
        <trans-unit id="81543c9a145dd6869d89d4e634466bddb425f66f" translate="yes" xml:space="preserve">
          <source>Attribute-level options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">「keyword = value」文字列としての属性レベルのオプション</target>
        </trans-unit>
        <trans-unit id="75629af51d7c7f120dbb5b462013bfa48af33285" translate="yes" xml:space="preserve">
          <source>Aug</source>
          <target state="translated">Aug</target>
        </trans-unit>
        <trans-unit id="69d97c5797dc7d211aaa4e9229db5c8466d4edef" translate="yes" xml:space="preserve">
          <source>August</source>
          <target state="translated">August</target>
        </trans-unit>
        <trans-unit id="9ac07ce6cd52d678fbe1229a683f5eafa07e3b6a" translate="yes" xml:space="preserve">
          <source>Authenticate using SSL client certificates. See &lt;a href=&quot;auth-cert&quot;&gt;Section 20.12&lt;/a&gt; for details.</source>
          <target state="translated">SSLクライアント証明書を使用して認証します。詳細は&lt;a href=&quot;auth-cert&quot;&gt;項20.12&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b62091287fb724791ca34488a0ab2a9fac4a1e4d" translate="yes" xml:space="preserve">
          <source>Authenticate using a RADIUS server. See &lt;a href=&quot;auth-radius&quot;&gt;Section 20.11&lt;/a&gt; for details.</source>
          <target state="translated">RADIUSサーバーを使用して認証します。詳細は&lt;a href=&quot;auth-radius&quot;&gt;項20.11&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="82054cdf870e919ceb8345be400ef8ccd343353b" translate="yes" xml:space="preserve">
          <source>Authenticate using an LDAP server. See &lt;a href=&quot;auth-ldap&quot;&gt;Section 20.10&lt;/a&gt; for details.</source>
          <target state="translated">LDAPサーバーを使用して認証します。詳細は&lt;a href=&quot;auth-ldap&quot;&gt;項20.10&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="55d3191d61e9daf8a3de6d8c5454a6099b6e7e03" translate="yes" xml:space="preserve">
          <source>Authenticate using the BSD Authentication service provided by the operating system. See &lt;a href=&quot;auth-bsd&quot;&gt;Section 20.14&lt;/a&gt; for details.</source>
          <target state="translated">オペレーティングシステムが提供するBSD認証サービスを使用して認証します。詳細は&lt;a href=&quot;auth-bsd&quot;&gt;項20.14&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="99ad70b6f56fd0c0d9729bfab969bd959ae5fb53" translate="yes" xml:space="preserve">
          <source>Authenticate using the Pluggable Authentication Modules (PAM) service provided by the operating system. See &lt;a href=&quot;auth-pam&quot;&gt;Section 20.13&lt;/a&gt; for details.</source>
          <target state="translated">オペレーティングシステムが提供するPluggable Authentication Modules（PAM）サービスを使用して認証します。詳細は&lt;a href=&quot;auth-pam&quot;&gt;項20.13&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ad4053a30971cdd0eca5d90cab892f9f383ba3e" translate="yes" xml:space="preserve">
          <source>Authentication Methods</source>
          <target state="translated">認証方法</target>
        </trans-unit>
        <trans-unit id="98fb3925f64e0642987c3e7beb38bbfbcaa16576" translate="yes" xml:space="preserve">
          <source>Authentication Problems</source>
          <target state="translated">認証の問題</target>
        </trans-unit>
        <trans-unit id="bcf5b4f7c9dc716b472b6e8b3f05c043e93a5b63" translate="yes" xml:space="preserve">
          <source>Authentication failures and related problems generally manifest themselves through error messages like the following:</source>
          <target state="translated">認証の失敗とそれに関連する問題は、一般的に以下のようなエラーメッセージで表示されます。</target>
        </trans-unit>
        <trans-unit id="4a2641463bda57c970dcaba44cead46536e41155" translate="yes" xml:space="preserve">
          <source>Authentication method</source>
          <target state="translated">認証方法</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="ae017ff45a4a035cd29d47f616f68029f16fd0e1" translate="yes" xml:space="preserve">
          <source>Automatic Vacuuming</source>
          <target state="translated">自動バキューム</target>
        </trans-unit>
        <trans-unit id="7c977c91d67cb7d94506d78b8621aa22f728f9df" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">インデックスの構造的整合性の自動検証は、論理的な不整合が導入されることを合理的に許容する可能性のある、新しいまたは提案されたPostgreSQL機能の一般的なテストで役割を果たします。テーブル構造の検証、および関連する可視性とトランザクションステータス情報は、同様の役割を果たします。明らかなテスト戦略の1つは、標準の回帰テストを実行するときに &lt;code&gt;amcheck&lt;/code&gt; 関数を継続的に呼び出すことです。参照&lt;a href=&quot;https://www.postgresql.org/docs/12/regress-run.html&quot;&gt;セクション32.1を&lt;/a&gt;テストの実行の詳細については。</target>
        </trans-unit>
        <trans-unit id="dd9a137c5bedfde09ac590ac67aee8327d8ab3c7" translate="yes" xml:space="preserve">
          <source>Automatic verification of the structural integrity of indexes plays a role in the general testing of new or proposed PostgreSQL features that could plausibly allow a logical inconsistency to be introduced. Verification of table structure and associated visibility and transaction status information plays a similar role. One obvious testing strategy is to call &lt;code&gt;amcheck&lt;/code&gt; functions continuously when running the standard regression tests. See &lt;a href=&quot;https://www.postgresql.org/docs/13/regress-run.html&quot;&gt;Section 32.1&lt;/a&gt; for details on running the tests.</source>
          <target state="translated">インデックスの構造的整合性の自動検証は、論理的な不整合が発生する可能性のある新しいまたは提案されたPostgreSQL機能の一般的なテストで役割を果たします。テーブル構造と関連する可視性およびトランザクションステータス情報の検証も同様の役割を果たします。明らかなテスト戦略の1つは、標準の回帰テストを実行するときに &lt;code&gt;amcheck&lt;/code&gt; 関数を継続的に呼び出すことです。参照&lt;a href=&quot;https://www.postgresql.org/docs/13/regress-run.html&quot;&gt;セクション32.1を&lt;/a&gt;テストの実行の詳細については。</target>
        </trans-unit>
        <trans-unit id="820a99cec2958e050680c6f99db97b790304fa53" translate="yes" xml:space="preserve">
          <source>Automatically drop objects (tables, functions, etc.) that are contained in the schema, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">スキーマに含まれているオブジェクト（テーブル、関数など）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7996658087a343e0aa2b3cf4b1db038fe35de48f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the access method (such as operator classes, operator families, and indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">アクセス方法に依存するオブジェクト（演算子クラス、演算子ファミリ、インデックスなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="baccb8c23deca0c76a8a79a9c5f9953c38de8bc4" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the affected objects, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">影響を受けるオブジェクトに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="38e895c6814216f5b3e9484010061f8b91dc249f" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the aggregate function (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">集約関数に依存するオブジェクト（それを使用するビューなど）を自動的に削除し、次に、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="abc0b1d37273a9737a10dc3892acfa6c92fe5d93" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the collation, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">照合に依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="745a5a5b00e94aac1eab4bd026b0c3eb4c8c446e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the constraint, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">制約に依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e6ef4a74296e736f065e1732a22c73d138658014" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the domain (such as table columns), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">ドメインに依存するオブジェクト（テーブルの列など）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="660862c86777512d4fcfc8d0ae2ba2705d79fc1b" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the dropped column or constraint (for example, views referencing the column), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">削除された列または制約に依存するオブジェクト（たとえば、列を参照するビュー）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ce7ac7937862e4e4126fdf7e2c5724e3de1e23e6" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the extension, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">拡張子に依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6bd522b5b8653034eb0b6145f2ce2e5dacb2cba0" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">外部テーブルに依存しているオブジェクト（ビューなど）を自動的に削除し、それらのオブジェクトに依存しているすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a988e483f220bf7f0532dd68b502a2b7076edf0a" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the foreign-data wrapper (such as foreign tables and servers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">外部データラッパーに依存するオブジェクト（外部テーブルやサーバーなど）、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e27007381181e414122b1ae56cdfd1a6d1dab2ad" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the function (such as operators or triggers), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">関数に依存するオブジェクト（演算子やトリガーなど）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1b9c92f0f554dcfb206e40bfd135fab8fe00e7e2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the index, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">インデックスに依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bcb27d2712f35ddb733c1f98ff51f21d7d424aaa" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the language (such as functions in the language), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">言語に依存するオブジェクト（言語の関数など）を自動的に削除し、次に、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2f6d0323ae070e0fb6a9170cf88c29d107b33c44" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the materialized view (such as other materialized views, or regular views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">マテリアライズドビューに依存するオブジェクト（他のマテリアライズドビューや通常のビューなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bf9e6848c526fa45713feaa1a3f98743157a4884" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator (such as views using it), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">演算子に依存するオブジェクト（演算子を使用するビューなど）を自動的に削除し、次に、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cbbaf53e6f678b4c8cf5eec8a71b6a7c2ee4f9ea" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator class (such as indexes), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">演算子クラスに依存するオブジェクト（インデックスなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="eb5de09991d91e56b807fa44deb753015952ad1e" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the operator family, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">演算子族に依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="e459a28af6e31c3e35e65f3a6c2487c577b6fa29" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the procedure, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">プロシージャに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14項を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b0c32bf11160fbc2a809f14fb04d0b4471ad9003" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the rule, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">ルールに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="de054c43bd92a23004c72d1888e8a17d538b0b78" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the sequence, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">シーケンスに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bb69e1d5d516109b91608eb01c14e7c1738edbdf" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the server (such as user mappings), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">サーバーに依存するオブジェクト（ユーザーマッピングなど）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="40e6c61745089f774dd3e41d1dc840b568fe3b30" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the table (such as views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テーブルなどに依存するオブジェクト（ビューなど）を自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="53f104557d2e3eaa82997c5ded39fd7f6ba0b2a2" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search configuration, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索構成に依存するオブジェクトを自動的にドロップし、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c790e11a342e191d26db4cfa94c2202262cf7507" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search dictionary, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索ディクショナリに依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5ce0aa99a0b061d5935384944655cf0dc2b98983" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search parser, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索パーサーに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="24a3aa8af1a85db5b902e0817649894b200120f5" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the text search template, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">テキスト検索テンプレートに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="52e34eb24e551596b0414271aef19a7a92f41187" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the transform, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">トランスフォームに依存するオブジェクトを自動的に削除し、それらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5430ece32ada38350ecf74986f0bbc942e6e3cfc" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the trigger, and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">トリガーに依存するオブジェクト、およびそれらのオブジェクトに依存するすべてのオブジェクトを自動的に削除します（&lt;a href=&quot;ddl-depend&quot;&gt;セクション5.14を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="946c18a9096115a846e5ed6451faa1e38fe8c835" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the type (such as table columns, functions, and operators), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">型に依存するオブジェクト（テーブルの列、関数、演算子など）を自動的に削除し、次にそれらのオブジェクトに依存するすべてのオブジェクトを削除します（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3d1c86e5f361718e066619a34ceb6e0c61659055" translate="yes" xml:space="preserve">
          <source>Automatically drop objects that depend on the view (such as other views), and in turn all objects that depend on those objects (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">ビューに依存するオブジェクト（他のビューなど）を自動的にドロップし、それらのオブジェクトに依存するすべてのオブジェクトを自動的にドロップします（&lt;a href=&quot;ddl-depend&quot;&gt;5.14節を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="3b54adcbf7578fd1e32a97c6d995480099f4e4ee" translate="yes" xml:space="preserve">
          <source>Automatically generate certain C code from SQL code. Currently, this works for &lt;code&gt;EXEC SQL TYPE&lt;/code&gt;.</source>
          <target state="translated">SQLコードから特定のCコードを自動的に生成します。現在、これは &lt;code&gt;EXEC SQL TYPE&lt;/code&gt; で機能します。</target>
        </trans-unit>
        <trans-unit id="02a28684ac310395befcd622074bd92c8287b214" translate="yes" xml:space="preserve">
          <source>Automatically install any extensions that this extension depends on that are not already installed. Their dependencies are likewise automatically installed, recursively. The &lt;code&gt;SCHEMA&lt;/code&gt; clause, if given, applies to all extensions that get installed this way. Other options of the statement are not applied to automatically-installed extensions; in particular, their default versions are always selected.</source>
          <target state="translated">この拡張機能が依存する拡張機能のうち、まだインストールされていないものを自動的にインストールします。それらの依存関係も同様に、再帰的に自動的にインストールされます。 &lt;code&gt;SCHEMA&lt;/code&gt; の句は、与えられた場合は、getがこのようにインストールされていることをすべての拡張機能に適用されます。ステートメントの他のオプションは、自動インストールされる拡張機能には適用されません。特に、デフォルトのバージョンが常に選択されています。</target>
        </trans-unit>
        <trans-unit id="82114421ee75a29b216b45460b9e22d194a04f14" translate="yes" xml:space="preserve">
          <source>Automatically propagate the operation to typed tables of the type being altered, and their descendants.</source>
          <target state="translated">変更される型の型付きテーブルとその子孫に操作を自動的に伝搬させます。</target>
        </trans-unit>
        <trans-unit id="8cbbea802a2969bf6986433c47646c8510fbfd3b" translate="yes" xml:space="preserve">
          <source>Automatically restart sequences owned by columns of the truncated table(s).</source>
          <target state="translated">切り捨てられたテーブルの列が所有するシーケンスを自動的に再起動します。</target>
        </trans-unit>
        <trans-unit id="5642bfdf85a2050b70397bd1e7d1e3fa447f8560" translate="yes" xml:space="preserve">
          <source>Automatically stop replication and exit with normal exit status 0 when receiving reaches the specified LSN.</source>
          <target state="translated">受信が指定したLSNに到達すると自動的にレプリケーションを停止し、通常の終了ステータス0で終了します。</target>
        </trans-unit>
        <trans-unit id="39275b6e09e38bef3ed571db2ef1da8d2f155a4e" translate="yes" xml:space="preserve">
          <source>Automatically truncate all tables that have foreign-key references to any of the named tables, or to any tables added to the group due to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">名前付きテーブルのいずれか、または &lt;code&gt;CASCADE&lt;/code&gt; によりグループに追加されたテーブルへの外部キー参照を持つすべてのテーブルを自動的に切り捨てます。</target>
        </trans-unit>
        <trans-unit id="1e085180a439697544c8e28954b594a79f078a9d" translate="yes" xml:space="preserve">
          <source>Autovacuum (process)</source>
          <target state="translated">自動バキューム</target>
        </trans-unit>
        <trans-unit id="63b02d90144047f7b0ae09ab6bb39285e944deab" translate="yes" xml:space="preserve">
          <source>Autovacuum is not active during recovery. It will start normally at the end of recovery.</source>
          <target state="translated">リカバリー中は自動バキュームは作動しません。リカバリーの終了時には正常に起動します。</target>
        </trans-unit>
        <trans-unit id="d7773c835487baf5b5c0ec83d176517e017c8f8a" translate="yes" xml:space="preserve">
          <source>Autovacuum worker or launcher waiting to update or read the current state of autovacuum workers.</source>
          <target state="translated">自動バキュームワーカーまたはランチャーは、自動バキュームワーカーの現在の状態の更新または読み込みを待っています。</target>
        </trans-unit>
        <trans-unit id="4aa1cd4d844c5afaaef04eccf35c0da21524cd29" translate="yes" xml:space="preserve">
          <source>Autovacuum workers generally don't block other commands. If a process attempts to acquire a lock that conflicts with the &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock held by autovacuum, lock acquisition will interrupt the autovacuum. For conflicting lock modes, see &lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;Table 13.2&lt;/a&gt;. However, if the autovacuum is running to prevent transaction ID wraparound (i.e., the autovacuum query name in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view ends with &lt;code&gt;(to prevent wraparound)&lt;/code&gt;), the autovacuum is not automatically interrupted.</source>
          <target state="translated">自動バキュームワーカーは通常、他のコマンドをブロックしません。プロセスがautovacuumによって保持されている &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックと競合するロックを取得しようとすると、ロックの取得によってautovacuumが中断されます。競合するロックモードについては、&lt;a href=&quot;explicit-locking#TABLE-LOCK-COMPATIBILITY&quot;&gt;表13.2を&lt;/a&gt;参照してください。ただし、autovacuumが実行されてトランザクションIDのラップアラウンドを防止している場合（つまり、 &lt;code&gt;pg_stat_activity&lt;/code&gt; ビューのautovacuumクエリ名が &lt;code&gt;(to prevent wraparound)&lt;/code&gt; ）で終わっている場合）、自動バキュームは自動的に中断されません。</target>
        </trans-unit>
        <trans-unit id="0edc11f659c78d515f96650dad0f6708f4c07fcc" translate="yes" xml:space="preserve">
          <source>Availability of WAL files claimed by this slot. Possible values are:</source>
          <target state="translated">このスロットが主張するWALファイルの利用可能性。可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="df5a7bec123e69676856b9a816b4c6aef10e3a78" translate="yes" xml:space="preserve">
          <source>Available Client Character Sets</source>
          <target state="translated">利用可能なクライアント文字セット</target>
        </trans-unit>
        <trans-unit id="820b74a0a5297b8b6e88df74e84d5e81e977acf2" translate="yes" xml:space="preserve">
          <source>Available cipher suite details will vary across OpenSSL versions. Use the command &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; to see actual details for the currently installed OpenSSL version. Note that this list is filtered at run time based on the server key type.</source>
          <target state="translated">利用可能な暗号スイートの詳細は、OpenSSLのバージョンによって異なります。 &lt;code&gt;openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'&lt;/code&gt; コマンドを使用して、現在インストールされているOpenSSLバージョンの実際の詳細を確認します。このリストは、サーバーのキータイプに基づいて実行時にフィルタリングされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ba149cade6a0a4e50af1ecb3e25946c72c71094e" translate="yes" xml:space="preserve">
          <source>Average density of leaf pages</source>
          <target state="translated">葉っぱページの平均密度</target>
        </trans-unit>
        <trans-unit id="f099162f6d15d176bb9a41f82a80ea2cb1d18cf4" translate="yes" xml:space="preserve">
          <source>Average number of transactions that are executed per second, totaled across all sessions active for a measured run. This is used as a measure of the performance characteristics of an instance.</source>
          <target state="translated">測定された実行でアクティブなすべてのセッションを合計した、1 秒あたりに実行されるトランザクションの平均数。これは、インスタンスのパフォーマンス特性の指標として使用されます。</target>
        </trans-unit>
        <trans-unit id="4903dacf2f00d069a2643728e3f02486ff810d77" translate="yes" xml:space="preserve">
          <source>Average width in bytes of column's entries</source>
          <target state="translated">列のエントリの平均幅をバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="3e9553fca4b719e6a36df1dda8f90b143771ffd9" translate="yes" xml:space="preserve">
          <source>B-Tree Indexes</source>
          <target state="translated">B-Treeインデックス</target>
        </trans-unit>
        <trans-unit id="68486e8aa60ef6bf0ca374b07c2662a92ae24f27" translate="yes" xml:space="preserve">
          <source>B-Tree Support Functions</source>
          <target state="translated">B-Treeサポート機能</target>
        </trans-unit>
        <trans-unit id="717b6f33b42cc7559340881ecec59b687e47a41c" translate="yes" xml:space="preserve">
          <source>B-Tree deduplication is just as effective with &amp;ldquo;duplicates&amp;rdquo; that contain a NULL value, even though NULL values are never equal to each other according to the &lt;code&gt;=&lt;/code&gt; member of any B-Tree operator class. As far as any part of the implementation that understands the on-disk B-Tree structure is concerned, NULL is just another value from the domain of indexed values.</source>
          <target state="translated">Bツリーの重複排除は、任意のBツリー演算子クラスの &lt;code&gt;=&lt;/code&gt; メンバーによると、NULL値が互いに等しくなることはありませんが、NULL値を含む「複製」でも同様に効果的です。ディスク上のBツリー構造を理解する実装の任意の部分に関する限り、NULLはインデックス値のドメインからの単なる別の値です。</target>
        </trans-unit>
        <trans-unit id="1bea9fad8fb62f91da10ba766f66a246a745ab74" translate="yes" xml:space="preserve">
          <source>B-Tree indexes are not directly aware that under MVCC, there might be multiple extant versions of the same logical table row; to an index, each tuple is an independent object that needs its own index entry. &amp;ldquo;Version duplicates&amp;rdquo; may sometimes accumulate and adversely affect query latency and throughput. This typically occurs with &lt;code&gt;UPDATE&lt;/code&gt;-heavy workloads where most individual updates cannot apply the HOT optimization (often because at least one indexed column gets modified, necessitating a new set of index tuple versions &amp;mdash; one new tuple for &lt;em&gt;each and every&lt;/em&gt; index). In effect, B-Tree deduplication ameliorates index bloat caused by version churn. Note that even the tuples from a unique index are not necessarily &lt;em&gt;physically&lt;/em&gt; unique when stored on disk due to version churn. The deduplication optimization is selectively applied within unique indexes. It targets those pages that appear to have version duplicates. The high level goal is to give &lt;code&gt;VACUUM&lt;/code&gt; more time to run before an &amp;ldquo;unnecessary&amp;rdquo; page split caused by version churn can take place.</source>
          <target state="translated">Bツリーインデックスは、MVCCの下で、同じ論理テーブル行の複数の現存するバージョンが存在する可能性があることを直接認識していません。インデックスに対して、各タプルは独自のインデックスエントリを必要とする独立したオブジェクトです。 「バージョンの重複」が蓄積され、クエリの待ち時間とスループットに悪影響を与える場合があります。これは通常、ほとんどの個別の更新でHOT最適化を適用できない &lt;code&gt;UPDATE&lt;/code&gt; の多いワークロードで発生します（多くの場合、少なくとも1つのインデックス付き列が変更され、新しいインデックスタプルバージョンのセットが必要に&lt;em&gt;なります（&lt;/em&gt;インデックス&lt;em&gt;ごとに&lt;/em&gt;1つの新しいタプル）。事実上、Bツリー重複排除はバージョンチャーンによって引き起こされるインデックスの肥大化を改善します。一意のインデックスのタプルでさえ、必ずしも&lt;em&gt;物理的であると&lt;/em&gt;は限らないことに注意してください&lt;em&gt;&lt;/em&gt;バージョンチャーンのためにディスクに保存されたときに一意。重複排除の最適化は、一意のインデックス内で選択的に適用されます。バージョンが重複しているように見えるページを対象としています。高レベルの目標は、バージョンチャーンによって引き起こされる「不要な」ページ分割が発生する前に、 &lt;code&gt;VACUUM&lt;/code&gt; の実行時間を長くすることです。</target>
        </trans-unit>
        <trans-unit id="9504ad9e3e7718bba2e8ff2d49bd5578d047ea98" translate="yes" xml:space="preserve">
          <source>B-tree equivalent functionality for several data types</source>
          <target state="translated">いくつかのデータ型でB-treeと同等の機能</target>
        </trans-unit>
        <trans-unit id="905661856e09f20be385c26d6a37cee5d0959557" translate="yes" xml:space="preserve">
          <source>B-tree index over &lt;code&gt;ltree&lt;/code&gt;: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 上のBツリーインデックス： &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdeef32a168111374c1be4cd04224fef89dc4b4b" translate="yes" xml:space="preserve">
          <source>B-tree index pages that have become completely empty are reclaimed for re-use. However, there is still a possibility of inefficient use of space: if all but a few index keys on a page have been deleted, the page remains allocated. Therefore, a usage pattern in which most, but not all, keys in each range are eventually deleted will see poor use of space. For such usage patterns, periodic reindexing is recommended.</source>
          <target state="translated">完全に空になったB-treeインデックスページは、再利用のために再利用されます。しかし、スペースの非効率的な使用の可能性もあります。あるページのインデックスキーが少数のキーを除いてすべて削除された場合、そのページは割り当てられたままになります。したがって、各範囲のキーのうち、すべてではないがほとんどのキーが最終的に削除されてしまうような利用パターンでは、スペースの使用効率が悪くなります。このような使用パターンでは、定期的なインデックスの再作成が推奨されます。</target>
        </trans-unit>
        <trans-unit id="065de2528617033a42220233cd1c35a251757908" translate="yes" xml:space="preserve">
          <source>B-tree indexes additionally accept this parameter:</source>
          <target state="translated">B-tree インデックスは、このパラメータも受け付けます。</target>
        </trans-unit>
        <trans-unit id="4e65573a03a3b33fe194962539e298b25562884c" translate="yes" xml:space="preserve">
          <source>B-tree indexes also accept these parameters:</source>
          <target state="translated">B-tree インデックスは、これらのパラメータも受け付けます。</target>
        </trans-unit>
        <trans-unit id="b33f3c038c507d02cde94014e083413eba3062f2" translate="yes" xml:space="preserve">
          <source>B-tree indexes can also be used to retrieve data in sorted order. This is not always faster than a simple scan and sort, but it is often helpful.</source>
          <target state="translated">B-treeインデックスは、ソートされた順序でデータを取得するために使用することもできます。これは、単純なスキャンやソートよりも常に速くなるわけではありませんが、しばしば役立ちます。</target>
        </trans-unit>
        <trans-unit id="c1aa64fe8a588b4b8c3bb44a5ae5f195209958ec" translate="yes" xml:space="preserve">
          <source>B-tree version number</source>
          <target state="translated">B-treeのバージョン番号</target>
        </trans-unit>
        <trans-unit id="ee82358aad15ad2f88908ab7225b36322cd1065a" translate="yes" xml:space="preserve">
          <source>B-tree, GiST and SP-GiST indexes</source>
          <target state="translated">B-tree、GiST、SP-GiSTインデックス</target>
        </trans-unit>
        <trans-unit id="16921be12274c9c7c84517bda5d89a5ff3df5941" translate="yes" xml:space="preserve">
          <source>B-trees can handle equality and range queries on data that can be sorted into some ordering. In particular, the PostgreSQL query planner will consider using a B-tree index whenever an indexed column is involved in a comparison using one of these operators:</source>
          <target state="translated">B-木は、何らかの順序に並べ替えることができるデータの等値性問い合わせや範囲問い合わせを扱うことができます。特に、PostgreSQLの問い合わせプランナは、これらの演算子の1つを使用した比較にインデックス付きの列が関与している場合、B-treeインデックスを使用することを検討します。</target>
        </trans-unit>
        <trans-unit id="90fe59b25bb93f64682a57a1af270b45d31afdca" translate="yes" xml:space="preserve">
          <source>B.1. Date/Time Input Interpretation</source>
          <target state="translated">B.1.日付/時間入力の解釈</target>
        </trans-unit>
        <trans-unit id="9899d2230f4a93f14e01b57b593ac9983fb8a83d" translate="yes" xml:space="preserve">
          <source>B.2. Handling of Invalid or Ambiguous Timestamps</source>
          <target state="translated">B.2.無効または曖昧なタイムスタンプの処理</target>
        </trans-unit>
        <trans-unit id="3840db4e415d986c6609f0316669636755ab2262" translate="yes" xml:space="preserve">
          <source>B.3. Date/Time Key Words</source>
          <target state="translated">B.3.日付・時間キーワード</target>
        </trans-unit>
        <trans-unit id="922ab4c02bf090b11d909a4d188dbe702c610716" translate="yes" xml:space="preserve">
          <source>B.4. Date/Time Configuration Files</source>
          <target state="translated">B.4.日付/時刻設定ファイル</target>
        </trans-unit>
        <trans-unit id="58922b284be009208c01702b42070c1a181d5b29" translate="yes" xml:space="preserve">
          <source>B.5. History of Units</source>
          <target state="translated">B.5.単位の歴史</target>
        </trans-unit>
        <trans-unit id="9355cc4eed5770d5dfbba1271ff86061632e7258" translate="yes" xml:space="preserve">
          <source>B.5. POSIX Time Zone Specifications</source>
          <target state="translated">B.5.POSIX タイムゾーンの仕様</target>
        </trans-unit>
        <trans-unit id="ebc2d5b79639788bc98e2a3a622f6560e3933f91" translate="yes" xml:space="preserve">
          <source>B.6. History of Units</source>
          <target state="translated">B.6.単位の歴史</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="e87cf2c2aaae478fefafcf671d30d2bd91ab190c" translate="yes" xml:space="preserve">
          <source>BEGIN &amp;mdash; start a transaction block</source>
          <target state="translated">BEGIN &amp;mdash;トランザクションブロックを開始する</target>
        </trans-unit>
        <trans-unit id="e3b1705472dc241e491b245a0698901129b83705" translate="yes" xml:space="preserve">
          <source>BIGNUM math</source>
          <target state="translated">BIGNUM math</target>
        </trans-unit>
        <trans-unit id="c7854587bf0a26f0dd0236c46e64d140a0d9aa2a" translate="yes" xml:space="preserve">
          <source>BKI</source>
          <target state="translated">BKI</target>
        </trans-unit>
        <trans-unit id="a8e02c60c1fbe70ac08216f4d50adb47cd1b1f47" translate="yes" xml:space="preserve">
          <source>BREs differ from EREs in several respects. In BREs, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are &lt;code&gt;\{&lt;/code&gt; and &lt;code&gt;\}&lt;/code&gt;, with &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; by themselves ordinary characters. The parentheses for nested subexpressions are &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt;, with &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; by themselves ordinary characters. &lt;code&gt;^&lt;/code&gt; is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, &lt;code&gt;$&lt;/code&gt; is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and &lt;code&gt;*&lt;/code&gt; is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading &lt;code&gt;^&lt;/code&gt;). Finally, single-digit back references are available, and &lt;code&gt;\&amp;lt;&lt;/code&gt; and &lt;code&gt;\&amp;gt;&lt;/code&gt; are synonyms for &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; respectively; no other escapes are available in BREs.</source>
          <target state="translated">BREはEREといくつかの点で異なります。 BREでは、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;+&lt;/code&gt; 、および &lt;code&gt;?&lt;/code&gt; 通常の文字であり、それらの機能に相当するものはありません。境界の区切り文字は &lt;code&gt;\{&lt;/code&gt; および &lt;code&gt;\}&lt;/code&gt; で、 &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; 自体は通常の文字です。ネストされた部分式の括弧は &lt;code&gt;\(&lt;/code&gt; と &lt;code&gt;\)&lt;/code&gt; で、 &lt;code&gt;(&lt;/code&gt; と &lt;code&gt;)&lt;/code&gt; 自体は通常の文字です。 &lt;code&gt;^&lt;/code&gt; は、REの先頭または括弧で囲まれた部分式の先頭を除いて、通常の文字です &lt;code&gt;$&lt;/code&gt; REの終わりまたはかっこで囲まれた部分式の終わりを除いて通常の文字です。 &lt;code&gt;*&lt;/code&gt; がREの始めまたはかっこで囲まれた部分式の始まり（先頭の &lt;code&gt;^&lt;/code&gt; の後にある可能性があります）にある場合、通常の文字です。最後に、1桁の後方参照が利用可能で、 &lt;code&gt;\&amp;lt;&lt;/code&gt; と &lt;code&gt;\&amp;gt;&lt;/code&gt; はそれぞれ &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; と &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; の同義語です。 BREでは他のエスケープは使用できません。</target>
        </trans-unit>
        <trans-unit id="b45363f80402fee41de7af6a2bc3803bd8fcc804" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Built-in Operator Classes</source>
          <target state="translated">BRINインデックス。組込み演算子クラス</target>
        </trans-unit>
        <trans-unit id="610805949da9a921d5d35ddef0174271633dc849" translate="yes" xml:space="preserve">
          <source>BRIN Indexes: Extensibility</source>
          <target state="translated">BRINインデックス。拡張性</target>
        </trans-unit>
        <trans-unit id="e9ea37807ed02774eb4219265e764033548569ae" translate="yes" xml:space="preserve">
          <source>BRIN indexes (a shorthand for Block Range INdexes) store summaries about the values stored in consecutive physical block ranges of a table. Like GiST, SP-GiST and GIN, BRIN can support many different indexing strategies, and the particular operators with which a BRIN index can be used vary depending on the indexing strategy. For data types that have a linear sort order, the indexed data corresponds to the minimum and maximum values of the values in the column for each block range. This supports indexed queries using these operators:</source>
          <target state="translated">BRINインデックス(Block Range INdexesの略語)は、テーブルの連続する物理ブロック範囲に格納された値のサマリーを格納します。GiST、SP-GIST、GINと同様に、BRINは多くの異なるインデックス化戦略をサポートすることができ、BRINインデックスが使用できる特定の演算子はインデックス化戦略に応じて異なります。線形ソート順を持つデータ型の場合、インデックス化されたデータは、各ブロック範囲の列内の値の最小値と最大値に対応します。これは、これらの演算子を使用してインデックス化されたクエリをサポートしています。</target>
        </trans-unit>
        <trans-unit id="192104c1f501554301510ea5a728a13a08ab43a4" translate="yes" xml:space="preserve">
          <source>BRIN indexes accept different parameters:</source>
          <target state="translated">BRINインデックスは異なるパラメータを受け入れます。</target>
        </trans-unit>
        <trans-unit id="b838c564f224f8b8543683d11eed0d0437e44e11" translate="yes" xml:space="preserve">
          <source>BRIN indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is &lt;em&gt;consistent&lt;/em&gt; with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions &amp;mdash; in other words, these indexes are lossy. Because a BRIN index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples.</source>
          <target state="translated">BRINインデックスは、通常のビットマップインデックススキャンを介してクエリを満たすことができ、インデックスによって保存された要約情報がクエリ条件と&lt;em&gt;一致&lt;/em&gt;している場合、各範囲内のすべてのページのすべてのタプルを返します。クエリエグゼキュータは、これらのタプルの再チェックとクエリ条件に一致しないタプルの破棄を担当します。つまり、これらのインデックスは損失を伴います。 BRINインデックスは非常に小さいため、インデックスをスキャンしても、シーケンシャルスキャンに比べてオーバーヘッドはほとんど追加されませんが、一致するタプルが含まれていないことがわかっているテーブルの大部分をスキャンしないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="55b3c9c4efac0d4d71eaa3d4c8cc93a475582a37" translate="yes" xml:space="preserve">
          <source>BRIN stands for Block Range Index. BRIN is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A &lt;em&gt;block range&lt;/em&gt; is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally.</source>
          <target state="translated">BRINはBlock Range Indexの略です。 BRINは、特定の列がテーブル内の物理的な位置と自然に相関している非常に大きなテーブルを処理するために設計されています。&lt;em&gt;ブロック範囲は、&lt;/em&gt;テーブル内の物理的に隣接しているページのグループです。各ブロック範囲について、いくつかの要約情報がインデックスによって保存されます。たとえば、ストアの販売注文を格納するテーブルには、各注文が行われた日付列があり、ほとんどの場合、以前の注文のエントリもテーブルの前に表示されます。郵便番号列を格納するテーブルには、都市のすべてのコードが自然にグループ化されている場合があります。</target>
        </trans-unit>
        <trans-unit id="c5bca0a807cb4e3535b6c51a06c3bccf47631d7c" translate="yes" xml:space="preserve">
          <source>BSD Authentication</source>
          <target state="translated">BSD 認証</target>
        </trans-unit>
        <trans-unit id="f1a97c299183923139e5920b8bda3da33aa50cdf" translate="yes" xml:space="preserve">
          <source>BSD Authentication in PostgreSQL uses the &lt;code&gt;auth-postgresql&lt;/code&gt; login type and authenticates with the &lt;code&gt;postgresql&lt;/code&gt; login class if that's defined in &lt;code&gt;login.conf&lt;/code&gt;. By default that login class does not exist, and PostgreSQL will use the default login class.</source>
          <target state="translated">PostgreSQLのBSD認証は、 &lt;code&gt;auth-postgresql&lt;/code&gt; ログインタイプを使用し、 &lt;code&gt;login.conf&lt;/code&gt; で定義されている場合、 &lt;code&gt;postgresql&lt;/code&gt; ログインクラスで認証します。デフォルトでは、そのログインクラスは存在せず、PostgreSQLはデフォルトのログインクラスを使用します。</target>
        </trans-unit>
        <trans-unit id="eebf5442eb861b0130ab1dbae1411845a2d52d61" translate="yes" xml:space="preserve">
          <source>Backend (process)</source>
          <target state="translated">バックエンド(プロセス</target>
        </trans-unit>
        <trans-unit id="99affebb8bc98ca77c8c04882ebec0dea90a3114" translate="yes" xml:space="preserve">
          <source>Backend Interface</source>
          <target state="translated">バックエンドインタフェース</target>
        </trans-unit>
        <trans-unit id="328769872d8232ec584540b9757369093134e160" translate="yes" xml:space="preserve">
          <source>Backend type</source>
          <target state="translated">バックエンドタイプ</target>
        </trans-unit>
        <trans-unit id="dc32da7c82d0789e65952daa2c9def14b3058549" translate="yes" xml:space="preserve">
          <source>Background worker (process)</source>
          <target state="translated">バックグラウンドワーカー(プロセス</target>
        </trans-unit>
        <trans-unit id="b848315d26f8ea5458744e8623f2ff6b2080f8c1" translate="yes" xml:space="preserve">
          <source>Background writer (process)</source>
          <target state="translated">バックグラウンドライター(プロセス</target>
        </trans-unit>
        <trans-unit id="60f8490b7625580e80d17d5a1df23b1d4de6ebc4" translate="yes" xml:space="preserve">
          <source>Backslash &lt;code&gt;x&lt;/code&gt; followed by one or two hex digits specifies the character with that numeric code</source>
          <target state="translated">バックスラッシュ &lt;code&gt;x&lt;/code&gt; の後に1桁または2桁の16進数が続き、その数値コードの文字を指定します</target>
        </trans-unit>
        <trans-unit id="f71436b4e34992baf3c146d9f7bcd610fe7bd64e" translate="yes" xml:space="preserve">
          <source>Backslash Escape Sequence</source>
          <target state="translated">バックスラッシュエスケープシーケンス</target>
        </trans-unit>
        <trans-unit id="08da95faebff9b822ea5284de54543cc7bd092f0" translate="yes" xml:space="preserve">
          <source>Backslash characters (&lt;code&gt;\&lt;/code&gt;) can be used in the &lt;code&gt;COPY&lt;/code&gt; data to quote data characters that might otherwise be taken as row or column delimiters. In particular, the following characters &lt;em&gt;must&lt;/em&gt; be preceded by a backslash if they appear as part of a column value: backslash itself, newline, carriage return, and the current delimiter character.</source>
          <target state="translated">バックスラッシュ文字（ &lt;code&gt;\&lt;/code&gt; ）を &lt;code&gt;COPY&lt;/code&gt; データで使用して、行または列の区切り文字として使用される可能性のあるデータ文字を引用できます。特に、列の値の一部として表示される場合、バックスラッシュ自体、改行、復帰、および現在の区切り文字の前にバックスラッシュを付ける&lt;em&gt;必要&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="79f7f8eb79d3eb20be7d5f2fdb2c6cb1e00c749f" translate="yes" xml:space="preserve">
          <source>Backslash followed by one to three octal digits specifies the character with that numeric code</source>
          <target state="translated">バックスラッシュの後に1~3桁の8進数が続く場合は、その数値コードを持つ文字を指定します。</target>
        </trans-unit>
        <trans-unit id="7b77925a9192b55418069493a221c26ff154c448" translate="yes" xml:space="preserve">
          <source>Backslash-semicolon is not a meta-command in the same way as the preceding commands; rather, it simply causes a semicolon to be added to the query buffer without any further processing.</source>
          <target state="translated">Backslash-semicolonは、前述のコマンドと同じようにメタコマンドではなく、単にセミコロンをクエリバッファに追加するだけです。</target>
        </trans-unit>
        <trans-unit id="3415ee42fbdf165d3ab63673dafeffa9121924ae" translate="yes" xml:space="preserve">
          <source>Backspace (ASCII 8)</source>
          <target state="translated">バックスペース(ASCII 8</target>
        </trans-unit>
        <trans-unit id="ee100250b3b61b298848fb969f8f888fd07a7761" translate="yes" xml:space="preserve">
          <source>Backtrace support is not available on all platforms, and the quality of the backtraces depends on compilation options.</source>
          <target state="translated">バックトレースのサポートはすべてのプラットフォームで利用できるわけではなく、バックトレースの品質はコンパイルオプションに依存します。</target>
        </trans-unit>
        <trans-unit id="d331ac3f1a6cac9c6991fe1fa25efc25e1bcefe8" translate="yes" xml:space="preserve">
          <source>Backup Manifest File Object</source>
          <target state="translated">バックアップマニフェストファイルオブジェクト</target>
        </trans-unit>
        <trans-unit id="379196baf790f4b6fa0825b0de670c43e08df23a" translate="yes" xml:space="preserve">
          <source>Backup Manifest Format</source>
          <target state="translated">バックアップマニフェスト形式</target>
        </trans-unit>
        <trans-unit id="22c6cad75143d38691a0caaf6de1d84dce170459" translate="yes" xml:space="preserve">
          <source>Backup Manifest Top-level Object</source>
          <target state="translated">バックアップマニフェストトップレベルオブジェクト</target>
        </trans-unit>
        <trans-unit id="e141d2d8691eaa6fba3c4489c0fc0d8b0d463b66" translate="yes" xml:space="preserve">
          <source>Backup Manifest WAL Range Object</source>
          <target state="translated">バックアップマニフェストWALレンジオブジェクト</target>
        </trans-unit>
        <trans-unit id="a5932464fe7ee7685cdde1f28a54e89455da1784" translate="yes" xml:space="preserve">
          <source>Backup and Restore</source>
          <target state="translated">バックアップとリストア</target>
        </trans-unit>
        <trans-unit id="171ec47bee8f29611873a226142872b637cc0954" translate="yes" xml:space="preserve">
          <source>Backup verification proceeds in four stages. First, &lt;code&gt;pg_verifybackup&lt;/code&gt; reads the &lt;code&gt;backup_manifest&lt;/code&gt; file. If that file does not exist, cannot be read, is malformed, or fails verification against its own internal checksum, &lt;code&gt;pg_verifybackup&lt;/code&gt; will terminate with a fatal error.</source>
          <target state="translated">バックアップの検証は4段階で進行します。まず、 &lt;code&gt;pg_verifybackup&lt;/code&gt; が &lt;code&gt;backup_manifest&lt;/code&gt; ファイルを読み取ります。そのファイルが存在しない、読み取ることができない、形式が正しくない、または自身の内部チェックサムに対する検証に失敗した場合、 &lt;code&gt;pg_verifybackup&lt;/code&gt; は致命的なエラーで終了します。</target>
        </trans-unit>
        <trans-unit id="86e2f1a9ee8c86cb8243f522b50b65e6423c34d6" translate="yes" xml:space="preserve">
          <source>Backward compatibility syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; システム列を削除するための下位互換性構文。以下のよう &lt;code&gt;oid&lt;/code&gt; システム列はもう追加することはできません、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="3ea614d7d0d66375e7b59ad1603ddbf9c6954a56" translate="yes" xml:space="preserve">
          <source>Backward fetches are also disallowed when the query includes &lt;code&gt;FOR UPDATE&lt;/code&gt; or &lt;code&gt;FOR SHARE&lt;/code&gt;; therefore &lt;code&gt;SCROLL&lt;/code&gt; may not be specified in this case.</source>
          <target state="translated">クエリに &lt;code&gt;FOR UPDATE&lt;/code&gt; または &lt;code&gt;FOR SHARE&lt;/code&gt; が含まれている場合も、後方フェッチは許可されません。したがって、この場合、 &lt;code&gt;SCROLL&lt;/code&gt; は指定できません。</target>
        </trans-unit>
        <trans-unit id="92077d51292270928790f0d07fb2a1301d60ee31" translate="yes" xml:space="preserve">
          <source>Backward-compatible syntax for removing the &lt;code&gt;oid&lt;/code&gt; system column. As &lt;code&gt;oid&lt;/code&gt; system columns cannot be added anymore, this never has an effect.</source>
          <target state="translated">&lt;code&gt;oid&lt;/code&gt; システム列を削除するための下位互換性のある構文。以下のよう &lt;code&gt;oid&lt;/code&gt; システム列はもう追加することはできません、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="044409ea2cd85fda028f96eed9a84a9fcc920931" translate="yes" xml:space="preserve">
          <source>Baltic</source>
          <target state="translated">Baltic</target>
        </trans-unit>
        <trans-unit id="485c014f257e394c215c16b50018b7e0c80f4130" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm</source>
          <target state="translated">ベース10対数</target>
        </trans-unit>
        <trans-unit id="3b9f28dd05a6a2df955f43acccdc39e58fea4d0c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm (same as &lt;code&gt;log&lt;/code&gt;)</source>
          <target state="translated">常用対数（ &lt;code&gt;log&lt;/code&gt; と同じ）</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">ベースタイプ</target>
        </trans-unit>
        <trans-unit id="7d67a1e0565652b8a1f39922bf439ec06adfe28a" translate="yes" xml:space="preserve">
          <source>Basically a thesaurus dictionary replaces all non-preferred terms by one preferred term and, optionally, preserves the original terms for indexing as well. PostgreSQL's current implementation of the thesaurus dictionary is an extension of the synonym dictionary with added &lt;em&gt;phrase&lt;/em&gt; support. A thesaurus dictionary requires a configuration file of the following format:</source>
          <target state="translated">基本的に、シソーラス辞書は、すべての非優先用語を1つの優先用語で置き換え、オプションで、索引付けのために元の用語も保持します。PostgreSQLのシソーラスディクショナリの現在の実装は、同義語ディクショナリの拡張で、&lt;em&gt;フレーズの&lt;/em&gt;サポートが追加されています。シソーラス辞書には、次の形式の構成ファイルが必要です。</target>
        </trans-unit>
        <trans-unit id="e1ddc988e6d784f9a638904386d7cd96020404d0" translate="yes" xml:space="preserve">
          <source>Batching WAL files so that they are transferred every three hours, rather than one at a time</source>
          <target state="translated">WALファイルを一度に1つではなく、3時間ごとに転送するようにバッチ処理する</target>
        </trans-unit>
        <trans-unit id="56ac908a2429c8b6f57e6b53eb261c2b37853b9f" translate="yes" xml:space="preserve">
          <source>Be aware however that such a query will be very inefficient.</source>
          <target state="translated">ただし、このようなクエリは非常に効率が悪いので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="dd8576c5e404ad1333289b223aeb849843ea4d63" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;COPY&lt;/code&gt; ignores rules. If you want to use &lt;code&gt;COPY&lt;/code&gt; to insert data, you'll need to copy into the correct child table rather than directly into the master. &lt;code&gt;COPY&lt;/code&gt; does fire triggers, so you can use it normally if you use the trigger approach.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; はルールを無視することに注意してください。 &lt;code&gt;COPY&lt;/code&gt; を使用してデータを挿入する場合は、マスターに直接コピーするのではなく、正しい子テーブルにコピーする必要があります。 &lt;code&gt;COPY&lt;/code&gt; はトリガーを起動するので、トリガーアプローチを使用すれば通常どおり使用できます。</target>
        </trans-unit>
        <trans-unit id="3ec6516cf2acdacef6ec02909f23a042de655757" translate="yes" xml:space="preserve">
          <source>Be careful that the names and types of the view's columns will be assigned the way you want. For example:</source>
          <target state="translated">ビューのカラムの名前とタイプが希望通りに割り当てられるように注意してください。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2ecd0bd78d58da0c631755bb828f27e267549d1c" translate="yes" xml:space="preserve">
          <source>Be careful to specify the schema in which you installed the existing &lt;code&gt;hstore&lt;/code&gt; objects.</source>
          <target state="translated">既存の &lt;code&gt;hstore&lt;/code&gt; オブジェクトをインストールしたスキーマを指定するように注意してください。</target>
        </trans-unit>
        <trans-unit id="3286148c08a1b92253bcb1e687624659972203da" translate="yes" xml:space="preserve">
          <source>Be careful with the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege. There is no concept of inheritance for the privileges of a &lt;code&gt;CREATEROLE&lt;/code&gt;-role. That means that even if a role does not have a certain privilege but is allowed to create other roles, it can easily create another role with different privileges than its own (except for creating roles with superuser privileges). For example, if the role &amp;ldquo;user&amp;rdquo; has the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege but not the &lt;code&gt;CREATEDB&lt;/code&gt; privilege, nonetheless it can create a new role with the &lt;code&gt;CREATEDB&lt;/code&gt; privilege. Therefore, regard roles that have the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege as almost-superuser-roles.</source>
          <target state="translated">&lt;code&gt;CREATEROLE&lt;/code&gt; 特権に注意してください。 &lt;code&gt;CREATEROLE&lt;/code&gt; -ロールの特権の継承の概念はありません。つまり、特定の権限がなくても他のロールの作成が許可されている場合でも、自分のロールとは異なる権限を持つ別のロールを簡単に作成できます（スーパーユーザー権限を持つロールの作成を除く）。役割「ユーザが」持っている場合たとえば、 &lt;code&gt;CREATEROLE&lt;/code&gt; の特権ではなく、 &lt;code&gt;CREATEDB&lt;/code&gt; の権限を、それにもかかわらず、それが持つ新しい役割を作成することができます &lt;code&gt;CREATEDB&lt;/code&gt; の権限を。したがって、 &lt;code&gt;CREATEROLE&lt;/code&gt; 特権を持つロールは、ほぼスーパーユーザーのロールと見なしてください。</target>
        </trans-unit>
        <trans-unit id="e9a084e06d49f90e432ff228c5d493ff5d910d84" translate="yes" xml:space="preserve">
          <source>Be certain that your backup includes all of the files under the database cluster directory (e.g., &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt;). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup archives symbolic links as links, otherwise the restore will corrupt your tablespaces).</source>
          <target state="translated">バックアップには、データベースクラスターディレクトリ（たとえば、 &lt;code&gt;/usr/local/pgsql/data&lt;/code&gt; ）の下のすべてのファイルが含まれていることを確認してください。このディレクトリの下にないテーブルスペースを使用している場合は、それらも含めるように注意してください（バックアップがシンボリックリンクをリンクとしてアーカイブすることを確認してください。そうしないと、復元によってテーブルスペースが破損します）。</target>
        </trans-unit>
        <trans-unit id="1cca2cb275ffb0ac1d90a9275a182dd9576c7cb7" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null values&lt;/a&gt; are not considered equal to each other, multiple rows with null values are allowed to exist without violating the unique constraint.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null値&lt;/a&gt;は互いに等しいとは見なされないため、null値を持つ複数の行は、一意の制約に違反することなく存在できます。</target>
        </trans-unit>
        <trans-unit id="8050bf055d69a2c17aebfa6f23142af8cc972e31" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;...&lt;/code&gt; is widely used in data sources, it is allowed as an alternative spelling of &lt;code&gt;..&lt;/code&gt;. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; はデータソースで広く使用されているため、..。の代替スペルとして使用でき &lt;code&gt;..&lt;/code&gt; 。残念ながら、これにより解析のあいまいさが生じます &lt;code&gt;0...23&lt;/code&gt; 上限が &lt;code&gt;23&lt;/code&gt; であるのか、 &lt;code&gt;0.23&lt;/code&gt; であるのかが明確ではありません。これは、 &lt;code&gt;seg&lt;/code&gt; 入力のすべての数値で、小数点の前に少なくとも1桁を必要とすることで解決されます。</target>
        </trans-unit>
        <trans-unit id="786d48aa791887748b32e63ec202e2ae60a5fb6e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;CLUSTER&lt;/code&gt; remembers which indexes are clustered, one can cluster the tables one wants clustered manually the first time, then set up a periodic maintenance script that executes &lt;code&gt;CLUSTER&lt;/code&gt; without any parameters, so that the desired tables are periodically reclustered.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; はクラスター化されたインデックスを記憶しているため、最初に手動でクラスター化したいテーブルをクラスター化し、パラメーターなしで &lt;code&gt;CLUSTER&lt;/code&gt; を実行する定期的なメンテナンススクリプトを設定して、目的のテーブルを定期的に再クラスター化できます。</target>
        </trans-unit>
        <trans-unit id="483573a468db7932cd30d693208c560bce934759" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;float8&lt;/code&gt; has no meaningful &amp;ldquo;step&amp;rdquo;, we do not define a canonicalization function in this example.</source>
          <target state="translated">ので &lt;code&gt;float8&lt;/code&gt; 型は、意味のある「ステップ」を持っていない、我々は、この例では、正規化関数を定義していません。</target>
        </trans-unit>
        <trans-unit id="8c58240b228b0ae5aff4efd20c01cc67a3bd5a52" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;nextval&lt;/code&gt; and &lt;code&gt;setval&lt;/code&gt; calls are never rolled back, sequence objects cannot be used if &amp;ldquo;gapless&amp;rdquo; assignment of sequence numbers is needed. It is possible to build gapless assignment by using exclusive locking of a table containing a counter; but this solution is much more expensive than sequence objects, especially if many transactions need sequence numbers concurrently.</source>
          <target state="translated">ので &lt;code&gt;nextval&lt;/code&gt; と &lt;code&gt;setval&lt;/code&gt; のコールがロールバックされることはありませんシーケンス番号の「ギャップレス」の割り当てが必要な場合は、シーケンス・オブジェクトを使用することはできません。カウンタを含むテーブルの排他的ロックを使用することにより、ギャップのない割り当てを構築できます。しかし、このソリューションは、特に多くのトランザクションがシーケンス番号を同時に必要とする場合、シーケンスオブジェクトよりもはるかに高価です。</target>
        </trans-unit>
        <trans-unit id="57fa06eff5bff23d9975c881fe012eee591895a8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;smallserial&lt;/code&gt; 、 &lt;code&gt;serial&lt;/code&gt; 、および &lt;code&gt;bigserial&lt;/code&gt; はシーケンスを使用して実装されているため、行が削除されていなくても、列に表示される値のシーケンスに「穴」またはギャップがある場合があります。シーケンスから割り当てられた値は、その値を含む行がテーブル列に正常に挿入されなかった場合でも、「使い果たされ」ます。これは、たとえば、挿入トランザクションがロールバックした場合に発生する可能性があります。詳細は、&lt;a href=&quot;functions-sequence&quot;&gt;9.16&lt;/a&gt;項の &lt;code&gt;nextval()&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3bffe320d485976bda24d70a1ca1896c9923ad97" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;serial&lt;/code&gt; and &lt;code&gt;bigserial&lt;/code&gt; are implemented using sequences, there may be &quot;holes&quot; or gaps in the sequence of values which appears in the column, even if no rows are ever deleted. A value allocated from the sequence is still &quot;used up&quot; even if a row containing that value is never successfully inserted into the table column. This may happen, for example, if the inserting transaction rolls back. See &lt;code&gt;nextval()&lt;/code&gt; in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt; for details.</source>
          <target state="translated">ため &lt;code&gt;smallserial&lt;/code&gt; 、 &lt;code&gt;serial&lt;/code&gt; および &lt;code&gt;bigserial&lt;/code&gt; 配列を使用して実装され、どの行がこれまでに削除されていない場合であっても、列に表示される値のシーケンスにおける「穴」又は隙間が存在してもよいです。シーケンスから割り当てられた値は、その値を含む行がテーブルの列に正常に挿入されなかった場合でも、「使い果たされた」ままです。これは、たとえば、挿入トランザクションがロールバックした場合に発生する可能性があります。詳細については、&lt;a href=&quot;functions-sequence&quot;&gt;セクション9.17の&lt;/a&gt; &lt;code&gt;nextval()&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="2055271ae8273a98d1c3120c9ad69e5bbb4dabd7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;to_tsvector&lt;/code&gt;(&lt;code&gt;NULL&lt;/code&gt;) will return &lt;code&gt;NULL&lt;/code&gt;, it is recommended to use &lt;code&gt;coalesce&lt;/code&gt; whenever a field might be null. Here is the recommended method for creating a &lt;code&gt;tsvector&lt;/code&gt; from a structured document:</source>
          <target state="translated">ので &lt;code&gt;to_tsvector&lt;/code&gt; （ &lt;code&gt;NULL&lt;/code&gt; が）を返します &lt;code&gt;NULL&lt;/code&gt; を、使用することをお勧めします &lt;code&gt;coalesce&lt;/code&gt; フィールドがヌルであるかもしれない時はいつでも。次に、構造化ドキュメントから &lt;code&gt;tsvector&lt;/code&gt; を作成するための推奨方法を示します。</target>
        </trans-unit>
        <trans-unit id="e67190c3b34212fbd9608f10ce1643e97f3b598d" translate="yes" xml:space="preserve">
          <source>Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a &lt;code&gt;doc&lt;/code&gt; column containing objects at the top level, with most objects containing &lt;code&gt;tags&lt;/code&gt; fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; and &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; appear, while ignoring any such keys outside the &lt;code&gt;tags&lt;/code&gt; array:</source>
          <target state="translated">JSON包含はネストされているため、適切なクエリはサブオブジェクトの明示的な選択をスキップできます。例として、最上位のオブジェクトを含む &lt;code&gt;doc&lt;/code&gt; 列があり、サブオブジェクトの配列を含む &lt;code&gt;tags&lt;/code&gt; フィールドを含むほとんどのオブジェクトがあるとします。このクエリは、 &lt;code&gt;&quot;term&quot;:&quot;paris&quot;&lt;/code&gt; と &lt;code&gt;&quot;term&quot;:&quot;food&quot;&lt;/code&gt; の両方を含むサブオブジェクトが表示されるエントリを検索しますが、 &lt;code&gt;tags&lt;/code&gt; 配列の外部にあるそのようなキーは無視します。</target>
        </trans-unit>
        <trans-unit id="9a6a9b9301894dfb915e7f65b2cfd52739126757" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL does not require constraint names to be unique within a schema (but only per-table), it is possible that there is more than one match for a specified constraint name. In this case &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; will act on all matches. For a non-schema-qualified name, once a match or matches have been found in some schema in the search path, schemas appearing later in the path are not searched.</source>
          <target state="translated">PostgreSQLは制約名がスキーマ内で一意である必要はないが（テーブルごとだけである）、指定された制約名に複数の一致がある可能性があります。この場合、 &lt;code&gt;SET CONSTRAINTS&lt;/code&gt; はすべての一致に作用します。スキーマ修飾されていない名前の場合、検索パスの一部のスキーマで1つ以上の一致が見つかると、パスの後ろにあるスキーマは検索されません。</target>
        </trans-unit>
        <trans-unit id="1054531abd84ea6ab456598b0cbf13df62bd8f3f" translate="yes" xml:space="preserve">
          <source>Because PostgreSQL is open source and easily extended, a number of companies have taken PostgreSQL and created commercial closed-source solutions with unique failover, replication, and load balancing capabilities.</source>
          <target state="translated">PostgreSQLはオープンソースで拡張が容易なため、多くの企業がPostgreSQLを採用し、独自のフェイルオーバー、レプリケーション、ロードバランシング機能を備えた商用のクローズドソースソリューションを作成しています。</target>
        </trans-unit>
        <trans-unit id="7c927394e6733d9a2cd5092ccd59b8f1d233eaee" translate="yes" xml:space="preserve">
          <source>Because Read Committed mode starts each command with a new snapshot that includes all transactions committed up to that instant, subsequent commands in the same transaction will see the effects of the committed concurrent transaction in any case. The point at issue above is whether or not a &lt;em&gt;single&lt;/em&gt; command sees an absolutely consistent view of the database.</source>
          <target state="translated">コミット読み取りモードは、その瞬間までにコミットされたすべてのトランザクションを含む新しいスナップショットで各コマンドを開始するため、同じトランザクション内の後続のコマンドは、いずれの場合でも、コミットされた同時トランザクションの影響を確認します。上記の問題点は、&lt;em&gt;単一の&lt;/em&gt;コマンドがデータベースの完全に一貫したビューを見るかどうかです。</target>
        </trans-unit>
        <trans-unit id="cb5cad886e41acd11550eebbf5881fb1ea7474ee" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g. &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">WALはクラッシュ後にデータベースファイルの内容を復元するため、ジャーナルファイルシステムは、データファイルまたはWALファイルの信頼性の高いストレージには必要ありません。実際、ジャーナリングによってファイルシステム&lt;em&gt;データ&lt;/em&gt;がディスクにフラッシュされる場合は特に、ジャーナリングのオーバーヘッドによってパフォーマンスが低下する可能性があります。幸い、ジャーナリング中のデータのフラッシュは、ファイルシステムのマウントオプションで無効にできることがよくあります（例：Linux ext3ファイルシステムの &lt;code&gt;data=writeback&lt;/code&gt; ）。ジャーナルファイルシステムは、クラッシュ後の起動速度を向上させます。</target>
        </trans-unit>
        <trans-unit id="8e8b8c9914b76b9dd74e86a1ad52e4f86cc8bc3d" translate="yes" xml:space="preserve">
          <source>Because WAL restores database file contents after a crash, journaled file systems are not necessary for reliable storage of the data files or WAL files. In fact, journaling overhead can reduce performance, especially if journaling causes file system &lt;em&gt;data&lt;/em&gt; to be flushed to disk. Fortunately, data flushing during journaling can often be disabled with a file system mount option, e.g., &lt;code&gt;data=writeback&lt;/code&gt; on a Linux ext3 file system. Journaled file systems do improve boot speed after a crash.</source>
          <target state="translated">WALはクラッシュ後にデータベースファイルの内容を復元するため、データファイルまたはWALファイルを確実に保存するためにジャーナルファイルシステムは必要ありません。実際、ジャーナリングのオーバーヘッドにより、特にジャーナリングによってファイルシステム&lt;em&gt;データ&lt;/em&gt;がディスクにフラッシュされる場合、パフォーマンスが低下する可能性があります。幸い、ジャーナリング中のデータフラッシュは、ファイルシステムのマウントオプションを使用して無効にできることがよくあります。たとえば、Linuxext3ファイルシステムでは &lt;code&gt;data=writeback&lt;/code&gt; です。ジャーナリングファイルシステムは、クラッシュ後の起動速度を向上させます。</target>
        </trans-unit>
        <trans-unit id="af002f2ced30c87d8ca2cfc786b9d6c148a8b054" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;SECURITY DEFINER&lt;/code&gt; function is executed with the privileges of the user that owns it, care is needed to ensure that the function cannot be misused. For security, &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; should be set to exclude any schemas writable by untrusted users. This prevents malicious users from creating objects (e.g., tables, functions, and operators) that mask objects intended to be used by the function. Particularly important in this regard is the temporary-table schema, which is searched first by default, and is normally writable by anyone. A secure arrangement can be obtained by forcing the temporary schema to be searched last. To do this, write &lt;code&gt;pg_temp&lt;/code&gt; as the last entry in &lt;code&gt;search_path&lt;/code&gt;. This function illustrates safe usage:</source>
          <target state="translated">ので &lt;code&gt;SECURITY DEFINER&lt;/code&gt; の機能は、それを所有するユーザの権限で実行され、注意が機能が悪用されることができないことを保証するために必要とされます。セキュリティを確保するために、信頼できないユーザーが書き込み可能なスキーマを除外するように&lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt;を設定する必要があります。これにより、悪意のあるユーザーが、関数での使用を目的としたオブジェクトをマスクするオブジェクト（テーブル、関数、演算子など）を作成することを防ぎます。この点で特に重要なのは、デフォルトで最初に検索され、通常誰でも書き込み可能な一時テーブルスキーマです。一時スキーマを最後に検索するように強制することにより、安全な配置を得ることができます。これを行うには、 &lt;code&gt;search_path&lt;/code&gt; の最後のエントリとして &lt;code&gt;pg_temp&lt;/code&gt; を記述します。この関数は、安全な使用法を示しています。</target>
        </trans-unit>
        <trans-unit id="7ccf103cb4c217d06785a0ccdc57267c861dec31" translate="yes" xml:space="preserve">
          <source>Because backslash is not a special character in the &lt;code&gt;CSV&lt;/code&gt; format, &lt;code&gt;\.&lt;/code&gt;, the end-of-data marker, could also appear as a data value. To avoid any misinterpretation, a &lt;code&gt;\.&lt;/code&gt; data value appearing as a lone entry on a line is automatically quoted on output, and on input, if quoted, is not interpreted as the end-of-data marker. If you are loading a file created by another application that has a single unquoted column and might have a value of &lt;code&gt;\.&lt;/code&gt;, you might need to quote that value in the input file.</source>
          <target state="translated">バックスラッシュは &lt;code&gt;CSV&lt;/code&gt; 形式の特殊文字ではないため、 &lt;code&gt;\.&lt;/code&gt; データ終了マーカーであるは、データ値としても表示されます。誤解を避けるために、 &lt;code&gt;\.&lt;/code&gt; 行の唯一のエントリとして表示されるデータ値は、出力時に自動的に引用され、入力時に引用された場合、データの終わりマーカーとして解釈されません。引用符で囲まれていない単一の列を持ち、 &lt;code&gt;\.&lt;/code&gt; 値を持つ可能性がある別のアプリケーションによって作成されたファイルをロードする場合。、入力ファイルでその値を引用する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="8837df7b2c1fb8da3ce2a114226b6b81d22d5575" translate="yes" xml:space="preserve">
          <source>Because column &lt;code&gt;y&lt;/code&gt; is not part of the index's search key, it does not have to be of a data type that the index can handle; it's merely stored in the index and is not interpreted by the index machinery. Also, if the index is a unique index, that is</source>
          <target state="translated">列 &lt;code&gt;y&lt;/code&gt; はインデックスの検索キーの一部ではないため、インデックスが処理できるデータ型である必要はありません。それは単にインデックスに格納され、インデックス機構によって解釈されません。また、インデックスが一意のインデックスである場合、つまり</target>
        </trans-unit>
        <trans-unit id="3d96d2addf447433c224777bf906ab67b3fda87a" translate="yes" xml:space="preserve">
          <source>Because custom options may need to be set in processes that have not loaded the relevant extension module, PostgreSQL will accept a setting for any two-part parameter name. Such variables are treated as placeholders and have no function until the module that defines them is loaded. When an extension module is loaded, it will add its variable definitions, convert any placeholder values according to those definitions, and issue warnings for any unrecognized placeholders that begin with its extension name.</source>
          <target state="translated">カスタムオプションは、関連する拡張モジュールをロードしていないプロセスで設定する必要があるかもしれません。このような変数はプレースホルダとして扱われ、それらを定義するモジュールがロードされるまでは何の機能も持ちません。拡張モジュールがロードされると、その変数の定義を追加し、それらの定義に従ってプレースホルダの値を変換し、その拡張名で始まる認識されないプレースホルダに対して警告を発行します。</target>
        </trans-unit>
        <trans-unit id="501d8e61189d0ec14bdd409d7b3e2083ee96580b" translate="yes" xml:space="preserve">
          <source>Because each btree operator class imposes a sort order on its data type, btree operator classes (or, really, operator families) have come to be used as PostgreSQL's general representation and understanding of sorting semantics. Therefore, they've acquired some features that go beyond what would be needed just to support btree indexes, and parts of the system that are quite distant from the btree AM make use of them.</source>
          <target state="translated">各btree演算子クラスはそのデータ型にソート順を課しているため、btree演算子クラス(実際には演算子ファミリ)はPostgreSQLのソートセマンティクスの一般的な表現と理解として使用されるようになりました。そのため、単にbtreeインデックスをサポートするだけで必要とされる機能を超えたいくつかの機能を獲得しており、btree AMからかなり離れたシステムの一部ではそれを利用しています。</target>
        </trans-unit>
        <trans-unit id="1cf84fc42fc11690b4a8d7c72f78d6f59379bbaa" translate="yes" xml:space="preserve">
          <source>Because each worker executes the parallel portion of the plan to completion, it is not possible to simply take an ordinary query plan and run it using multiple workers. Each worker would produce a full copy of the output result set, so the query would not run any faster than normal but would produce incorrect results. Instead, the parallel portion of the plan must be what is known internally to the query optimizer as a &lt;em&gt;partial plan&lt;/em&gt;; that is, it must be constructed so that each process which executes the plan will generate only a subset of the output rows in such a way that each required output row is guaranteed to be generated by exactly one of the cooperating processes. Generally, this means that the scan on the driving table of the query must be a parallel-aware scan.</source>
          <target state="translated">各ワーカーはプランの並列部分を実行して完了するため、通常のクエリプランを単純に取得して、複数のワーカーを使用して実行することはできません。各ワーカーは出力結果セットの完全なコピーを生成するため、クエリは通常よりも速く実行されませんが、誤った結果が生成されます。代わりに、プランの並列部分は、クエリオプティマイザが内部&lt;em&gt;的に部分プラン&lt;/em&gt;として認識しているものでなければなりません。つまり、計画を実行する各プロセスが出力行のサブセットのみを生成し、必要な各出力行が協調プロセスの1つだけで生成されることが保証されるように構成する必要があります。通常、これは、クエリの駆動テーブルでのスキャンが並列対応スキャンでなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f7c3975c53757320af8c077a7aa386b120a149d9" translate="yes" xml:space="preserve">
          <source>Because logical replication is based on a similar architecture as &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;physical streaming replication&lt;/a&gt;, the monitoring on a publication node is similar to monitoring of a physical replication master (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;Section 26.2.5.2&lt;/a&gt;).</source>
          <target state="translated">論理レプリケーションは&lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;物理ストリーミングレプリケーション&lt;/a&gt;と同様のアーキテクチャに基づいているため、パブリケーションノードでの監視は物理レプリケーションマスターの監視と同様です（&lt;a href=&quot;warm-standby#STREAMING-REPLICATION-MONITORING&quot;&gt;セクション26.2.5.2を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a2196adb2d7ec23f760e34a49d8237be649fa41e" translate="yes" xml:space="preserve">
          <source>Because of MVCC, it is always necessary to allow duplicate entries to exist physically in an index: the entries might refer to successive versions of a single logical row. The behavior we actually want to enforce is that no MVCC snapshot could include two rows with equal index keys. This breaks down into the following cases that must be checked when inserting a new row into a unique index:</source>
          <target state="translated">MVCCのため、インデックス内に物理的に重複したエントリが存在することを常に許容する必要があります。実際に強制したい動作は、MVCCスナップショットでは、同じインデックスキーを持つ2つの行を含むことができないということです。これは、一意のインデックスに新しい行を挿入する際にチェックしなければならない以下のケースに分けられます。</target>
        </trans-unit>
        <trans-unit id="92df70087fcf249f647fdf27a084f1becf03071e" translate="yes" xml:space="preserve">
          <source>Because of limited &lt;code&gt;maintenance_work_mem&lt;/code&gt;, &lt;code&gt;ambulkdelete&lt;/code&gt; might need to be called more than once when many tuples are to be deleted. The &lt;code&gt;stats&lt;/code&gt; argument is the result of the previous call for this index (it is NULL for the first call within a &lt;code&gt;VACUUM&lt;/code&gt; operation). This allows the AM to accumulate statistics across the whole operation. Typically, &lt;code&gt;ambulkdelete&lt;/code&gt; will modify and return the same struct if the passed &lt;code&gt;stats&lt;/code&gt; is not null.</source>
          <target state="translated">制限された &lt;code&gt;maintenance_work_mem&lt;/code&gt; のため、多くのタプルを削除する場合、 &lt;code&gt;ambulkdelete&lt;/code&gt; を複数回呼び出す必要がある場合があります。 &lt;code&gt;stats&lt;/code&gt; 引数がこのインデックスの前の呼び出しの結果である（それは内の最初の呼び出しのためにNULLである &lt;code&gt;VACUUM&lt;/code&gt; の動作）。これにより、AMは操作全体の統計を蓄積できます。通常、 &lt;code&gt;ambulkdelete&lt;/code&gt; は、渡された &lt;code&gt;stats&lt;/code&gt; がnullでない場合、同じ構造体を変更して返します。</target>
        </trans-unit>
        <trans-unit id="af06227e43627d5f9e3c80ba9b58e41dee4f1bd3" translate="yes" xml:space="preserve">
          <source>Because of the above rules, it is possible for an updating command to see an inconsistent snapshot: it can see the effects of concurrent updating commands on the same rows it is trying to update, but it does not see effects of those commands on other rows in the database. This behavior makes Read Committed mode unsuitable for commands that involve complex search conditions; however, it is just right for simpler cases. For example, consider updating bank balances with transactions like:</source>
          <target state="translated">上記のルールのため、更新コマンドは、更新しようとしている同じ行に対しては同時更新コマンドの効果を見ることができますが、データベース内の他の行に対してはそれらのコマンドの効果を見ることができません。この動作により、Read Committedモードは複雑な検索条件を含むコマンドには適していません。例えば、以下のようなトランザクションで銀行残高を更新することを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="094a085e303baa417739feb6622a057e4139e4ba" translate="yes" xml:space="preserve">
          <source>Because of this behavior, it's unwise to give a function that takes a single composite-type argument the same name as any of the fields of that composite type. If there is ambiguity, the field-name interpretation will be chosen if field-name syntax is used, while the function will be chosen if function-call syntax is used. However, PostgreSQL versions before 11 always chose the field-name interpretation, unless the syntax of the call required it to be a function call. One way to force the function interpretation in older versions is to schema-qualify the function name, that is, write &lt;code&gt;schema.func(compositevalue)&lt;/code&gt;.</source>
          <target state="translated">この動作のため、単一の複合型引数を取る関数に、その複合型のフィールドのいずれかと同じ名前を付けることは賢明ではありません。あいまいな場合は、フィールド名の構文が使用されている場合はフィールド名の解釈が選択され、関数呼び出しの構文が使用されている場合は関数が選択されます。ただし、呼び出しの構文で関数呼び出しである必要がある場合を除いて、11より前のバージョンのPostgreSQLでは、常にフィールド名の解釈が選択されていました。古いバージョンでは機能の解釈を強制する一つの方法は、スキーマ修飾する関数名、書き込みにある &lt;code&gt;schema.func(compositevalue)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6916a8fbcc68029c3a341e8400e967ac545c917" translate="yes" xml:space="preserve">
          <source>Because of this behavior, putting more than one SQL command in a single &lt;code&gt;-c&lt;/code&gt; string often has unexpected results. It's better to use repeated &lt;code&gt;-c&lt;/code&gt; commands or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:</source>
          <target state="translated">この動作のため、1つの &lt;code&gt;-c&lt;/code&gt; 文字列に複数のSQLコマンドを入れると、予期しない結果になることがよくあります。上記のエコーを使用するか、シェルのヒアドキュメントを介して、 &lt;code&gt;-c&lt;/code&gt; コマンドを繰り返し使用するか、複数のコマンドをpsqlの標準入力にフィードすることをお勧めします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="1e30503a8aa4dc4dd17e2394f194dfc73877aea7" translate="yes" xml:space="preserve">
          <source>Because of this convention of possibly renumbering OIDs assigned by patches, the OIDs assigned by a patch should not be considered stable until the patch has been included in an official release. We do not change manually-assigned object OIDs once released, however, as that would create assorted compatibility problems.</source>
          <target state="translated">パッチによって割り当てられた OID の番号が変更される可能性があるため、パッチによって割り当てられた OID は、そのパッチが公式リリースに含まれるまでは安定しているとは考えられません。しかし、一度リリースされたオブジェクトの OID を手動で変更することは、様々な互換性の問題を引き起こすことになるので、私たちは変更しません。</target>
        </trans-unit>
        <trans-unit id="167e13b17a2cb4d9e247d60e890e572062fe98da" translate="yes" xml:space="preserve">
          <source>Because of this indeterminacy, referencing other tables only within sub-selects is safer, though often harder to read and slower than using a join.</source>
          <target state="translated">このように不確定性があるため、サブセレクト内でのみ他のテーブルを参照する方が安全ですが、ジョインを使用するよりも読みにくく、時間がかかることがよくあります。</target>
        </trans-unit>
        <trans-unit id="71a8fc6262b2555f78a8d5aeb3468844fc9b3fb8" translate="yes" xml:space="preserve">
          <source>Because optimizer statistics are not transferred by &lt;code&gt;pg_upgrade&lt;/code&gt;, you will be instructed to run a command to regenerate that information at the end of the upgrade. You might need to set connection parameters to match your new cluster.</source>
          <target state="translated">オプティマイザ統計は &lt;code&gt;pg_upgrade&lt;/code&gt; によって転送されないため、アップグレードの最後にその情報を再生成するコマンドを実行するように指示されます。新しいクラスターに一致するように接続パラメーターを設定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c35cef2d44681e7faa9cdda9938f800f990d4dc8" translate="yes" xml:space="preserve">
          <source>Because pg_dump is used to transfer data to newer versions of PostgreSQL, the output of pg_dump can be expected to load into PostgreSQL server versions newer than pg_dump's version. pg_dump can also dump from PostgreSQL servers older than its own version. (Currently, servers back to version 8.0 are supported.) However, pg_dump cannot dump from PostgreSQL servers newer than its own major version; it will refuse to even try, rather than risk making an invalid dump. Also, it is not guaranteed that pg_dump's output can be loaded into a server of an older major version &amp;mdash; not even if the dump was taken from a server of that version. Loading a dump file into an older server may require manual editing of the dump file to remove syntax not understood by the older server. Use of the &lt;code&gt;--quote-all-identifiers&lt;/code&gt; option is recommended in cross-version cases, as it can prevent problems arising from varying reserved-word lists in different PostgreSQL versions.</source>
          <target state="translated">pg_dumpは新しいバージョンのPostgreSQLにデータを転送するために使用されるため、pg_dumpの出力は、pg_dumpのバージョンより新しいPostgreSQLサーバーのバージョンにロードされることが期待できます。 pg_dumpは、自身のバージョンより古いPostgreSQLサーバーからダンプすることもできます。 （現在、バージョン8.0に戻るサーバーがサポートされています。）ただし、pg_dumpは、それ自体のメジャーバージョンより新しいPostgreSQLサーバーからダンプできません。無効なダンプを作成するリスクを負うのではなく、試行を拒否します。また、pg_dumpの出力が古いメジャーバージョンのサーバーに読み込まれることは保証されていません。そのバージョンのサーバーからダンプが取得された場合でも同様です。古いサーバーにダンプファイルをロードするには、古いサーバーで理解されていない構文を削除するために、ダンプファイルを手動で編集する必要がある場合があります。使用 &lt;code&gt;--quote-all-identifiers&lt;/code&gt; このオプションは、異なるバージョンのPostgreSQLで予約語リストを変更することによって発生する問題を防ぐことができるため、クロスバージョンの場合に推奨されます。</target>
        </trans-unit>
        <trans-unit id="74ecae8ce7298adddc06312de549cde5a1f05bfd" translate="yes" xml:space="preserve">
          <source>Because roles can own database objects and can hold privileges to access other objects, dropping a role is often not just a matter of a quick &lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLE&lt;/a&gt;. Any objects owned by the role must first be dropped or reassigned to other owners; and any permissions granted to the role must be revoked.</source>
          <target state="translated">ロールはデータベースオブジェクトを所有し、他のオブジェクトにアクセスする権限を保持できるため、ロールの削除は、簡単な&lt;a href=&quot;sql-droprole&quot;&gt;DROP ROLEの&lt;/a&gt;問題だけではありません。ロールが所有するオブジェクトは、最初に削除するか、他の所有者に再割り当てする必要があります。また、ロールに付与されているすべての権限を取り消す必要があります。</target>
        </trans-unit>
        <trans-unit id="3c6bd276df7f7795dcf1ec012b5fa318dae1fa92" translate="yes" xml:space="preserve">
          <source>Because sequences are non-transactional, changes made by &lt;code&gt;setval&lt;/code&gt; are not undone if the transaction rolls back.</source>
          <target state="translated">シーケンスは非トランザクションであるため、トランザクションがロールバックしても、 &lt;code&gt;setval&lt;/code&gt; による変更は取り消されません。</target>
        </trans-unit>
        <trans-unit id="045cb510a11b664aff1ae0f9d4a4e6bf852e98a6" translate="yes" xml:space="preserve">
          <source>Because that day was a spring-forward transition date in that time zone, there was no civil time instant 2:30AM; clocks jumped forward from 2AM EST to 3AM EDT. PostgreSQL interprets the given time as if it were standard time (UTC-5), which then renders as 3:30AM EDT (UTC-4).</source>
          <target state="translated">その日はそのタイムゾーンでは春分移行日だったため、午前2時30分には市民時間は存在しませんでした。PostgreSQLは、与えられた時刻を標準時(UTC-5)であるかのように解釈し、3:30AM EDT(UTC-4)として表示します。</target>
        </trans-unit>
        <trans-unit id="f0a1c41a7fd794b4e227af5602d5ab126f9a65b2" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;...&lt;/code&gt; operator is widely used in data sources, it is allowed as an alternative spelling of the &lt;code&gt;..&lt;/code&gt; operator. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in &lt;code&gt;0...23&lt;/code&gt; is meant to be &lt;code&gt;23&lt;/code&gt; or &lt;code&gt;0.23&lt;/code&gt;. This is resolved by requiring at least one digit before the decimal point in all numbers in &lt;code&gt;seg&lt;/code&gt; input.</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 演算子はデータソースで広く使用されているため、 &lt;code&gt;..&lt;/code&gt; 演算子の代替スペルとして使用できます。残念ながら、これにより構文解析のあいまいさが生じます &lt;code&gt;0...23&lt;/code&gt; 上限が &lt;code&gt;23&lt;/code&gt; であるか &lt;code&gt;0.23&lt;/code&gt; であるかは明確ではありません。これは、 &lt;code&gt;seg&lt;/code&gt; 入力のすべての数値で小数点の前に少なくとも1桁を必要とすることで解決されます。</target>
        </trans-unit>
        <trans-unit id="a4c15eb3326253a984503903ababbb5a012e0e63" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node runs on the leader process, queries which produce a relatively large number of groups in comparison to the number of input rows will appear less favorable to the query planner. For example, in the worst-case scenario the number of groups seen by the &lt;code&gt;Finalize Aggregate&lt;/code&gt; node could be as many as the number of input rows which were seen by all worker processes in the &lt;code&gt;Partial Aggregate&lt;/code&gt; stage. For such cases, there is clearly going to be no performance benefit to using parallel aggregation. The query planner takes this into account during the planning process and is unlikely to choose parallel aggregate in this scenario.</source>
          <target state="translated">ので &lt;code&gt;Finalize Aggregate&lt;/code&gt; ノードがリーダープロセス上で実行され、入力された行の数と比較してグループの比較的大きな数を生成クエリは、クエリプランナに不利表示されます。たとえば、最悪のシナリオでは、 &lt;code&gt;Finalize Aggregate&lt;/code&gt; ノードで表示されるグループの数は、 &lt;code&gt;Partial Aggregate&lt;/code&gt; ステージのすべてのワーカープロセスで表示される入力行の数と同じになります。このような場合、並列集計を使用してもパフォーマンス上のメリットは明らかにありません。クエリプランナーは、計画プロセス中にこれを考慮し、このシナリオでは並列集計を選択することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="c37bfc8193816ef9726582311c95eb690d59a5d3" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;json&lt;/code&gt; type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, &lt;code&gt;jsonb&lt;/code&gt; does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept.</source>
          <target state="translated">&lt;code&gt;json&lt;/code&gt; タイプは入力テキストの正確なコピーを格納するため、トークン間の意味的に重要ではない空白と、JSONオブジェクト内のキーの順序が保持されます。また、値内のJSONオブジェクトに同じキーが複数含まれている場合、すべてのキーと値のペアが保持されます。 （処理関数は最後の値を有効な値と見なします。）対照的に、 &lt;code&gt;jsonb&lt;/code&gt; は空白を保持せず、オブジェクトキーの順序を保持せず、重複したオブジェクトキーを保持しません。入力で重複するキーが指定されている場合、最後の値のみが保持されます。</target>
        </trans-unit>
        <trans-unit id="a2b58f4e608829c960ebd5345ab5c69ff0a6f48c" translate="yes" xml:space="preserve">
          <source>Because the cache is shared by all the databases, there will normally be pages from relations not belonging to the current database. This means that there may not be matching join rows in &lt;code&gt;pg_class&lt;/code&gt; for some rows, or that there could even be incorrect joins. If you are trying to join against &lt;code&gt;pg_class&lt;/code&gt;, it's a good idea to restrict the join to rows having &lt;code&gt;reldatabase&lt;/code&gt; equal to the current database's OID or zero.</source>
          <target state="translated">キャッシュはすべてのデータベースで共有されるため、通常、現在のデータベースに属していないリレーションのページが存在します。これは、一部の行の &lt;code&gt;pg_class&lt;/code&gt; に一致する結合行がない可能性があること、または不正な結合でさえある可能性があることを意味します。 &lt;code&gt;pg_class&lt;/code&gt; に対して結合しようとしている場合は、現在のデータベースのOIDまたはゼロに等しい &lt;code&gt;reldatabase&lt;/code&gt; を持つ行に結合を制限することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="db3d427c20974c56be935e79b307fe146f033de0" translate="yes" xml:space="preserve">
          <source>Because the data directory contains all the data stored in the database, it is essential that it be secured from unauthorized access. &lt;code&gt;initdb&lt;/code&gt; therefore revokes access permissions from everyone but the PostgreSQL user, and optionally, group. Group access, when enabled, is read-only. This allows an unprivileged user in the same group as the cluster owner to take a backup of the cluster data or perform other operations that only require read access.</source>
          <target state="translated">データディレクトリにはデータベースに保存されているすべてのデータが含まれるため、不正アクセスから保護することが重要です。したがって、 &lt;code&gt;initdb&lt;/code&gt; は、PostgreSQLユーザー、およびオプションでグループ以外のすべてのユーザーからアクセス許可を取り消します。グループアクセスは、有効になっている場合、読み取り専用です。これにより、クラスター所有者と同じグループ内の非特権ユーザーは、クラスターデータのバックアップを取るか、読み取りアクセスのみを必要とする他の操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="1b1433bfc602856fd35d38e930969e2b25fd0ae1" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator class is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator class.</source>
          <target state="translated">インデックス機構は関数を使用する前に関数のアクセス許可をチェックしないので、関数や演算子を演算子クラスに含めることは、その関数や演算子に公開実行許可を与えることと同じことになります。これは通常、演算子クラスで有用な種類の関数については問題ではありません。</target>
        </trans-unit>
        <trans-unit id="12e05e286bda0df5f833a009aa68ad96a2c3e153" translate="yes" xml:space="preserve">
          <source>Because the index machinery does not check access permissions on functions before using them, including a function or operator in an operator family is tantamount to granting public execute permission on it. This is usually not an issue for the sorts of functions that are useful in an operator family.</source>
          <target state="translated">インデックス機構は、関数を使用する前に関数のアクセス許可をチェックしないので、関数や演算子を演算子ファミリに含めることは、その関数や演算子に公開実行許可を与えることに等しいです。これは通常、演算子ファミリの中で有用な種類の関数については問題になりません。</target>
        </trans-unit>
        <trans-unit id="05ce34a0d540aca4ce52a5f0344a9da290661688" translate="yes" xml:space="preserve">
          <source>Because the number of possible column combinations is very large, it's impractical to compute multivariate statistics automatically. Instead, &lt;em&gt;extended statistics objects&lt;/em&gt;, more often called just &lt;em&gt;statistics objects&lt;/em&gt;, can be created to instruct the server to obtain statistics across interesting sets of columns.</source>
          <target state="translated">可能な列の組み合わせの数は非常に多いため、多変量統計を自動的に計算することは現実的ではありません。代わりに、より多くの場合、単に&lt;em&gt;統計オブジェクト&lt;/em&gt;と呼ばれる&lt;em&gt;拡張統計オブジェクトを&lt;/em&gt;作成して、&lt;em&gt;対象&lt;/em&gt;の列のセット全体で統計を取得するようにサーバーに指示できます。</target>
        </trans-unit>
        <trans-unit id="4d0acad31e5ac16c376a00a683ae533e823a54c5" translate="yes" xml:space="preserve">
          <source>Because the planner records statistics about the ordering of tables, it is advisable to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on the newly clustered table. Otherwise, the planner might make poor choices of query plans.</source>
          <target state="translated">プランナーはテーブルの順序に関する統計を記録するため、新しくクラスター化されたテーブルで&lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行することをお勧めします。そうしないと、プランナがクエリプランを適切に選択できない可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d35897de153aa519a54a8b8fb6f5606c68e7ee1" translate="yes" xml:space="preserve">
          <source>Because the two-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; was used in the index above, only a query reference that uses the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; with the same configuration name will use that index. That is, &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; can use the index, but &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; cannot. This ensures that an index will be used only with the same configuration used to create the index entries.</source>
          <target state="translated">上記のインデックスでは2引数バージョンの &lt;code&gt;to_tsvector&lt;/code&gt; が使用されたため、同じ構成名で2引数バージョンの &lt;code&gt;to_tsvector&lt;/code&gt; を使用するクエリ参照のみがそのインデックスを使用します。つまり、 &lt;code&gt;WHERE to_tsvector('english', body) @@ 'a &amp;amp; b'&lt;/code&gt; はインデックスを使用できますが、 &lt;code&gt;WHERE to_tsvector(body) @@ 'a &amp;amp; b'&lt;/code&gt; は使用できません。これにより、インデックスエントリの作成に使用したのと同じ構成でのみインデックスが使用されるようになります。</target>
        </trans-unit>
        <trans-unit id="3db556aa68ed6f557f519e10166a776c7f49e136" translate="yes" xml:space="preserve">
          <source>Because there are no restrictions on use of a data type once it's been created, creating a base type or range type is tantamount to granting public execute permission on the functions mentioned in the type definition. This is usually not an issue for the sorts of functions that are useful in a type definition. But you might want to think twice before designing a type in a way that would require &amp;ldquo;secret&amp;rdquo; information to be used while converting it to or from external form.</source>
          <target state="translated">一度作成されたデータ型の使用に制限はないため、基本型または範囲型を作成することは、型定義で言及されている関数にパブリック実行権限を付与することと同じです。これは通常、型定義で役立つ種類の関数の問題ではありません。しかし、タイプを設計する前に、「秘密」の情報を外部フォームに変換したり、外部フォームから変換したりするために、その情報を使用する必要があるように考える必要があります。</target>
        </trans-unit>
        <trans-unit id="21ceed46db3017cd5cd38ced3fddd77a8ce650db" translate="yes" xml:space="preserve">
          <source>Because these functions return detailed page-level information, access is restricted by default. By default, only the role &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; has &lt;code&gt;EXECUTE&lt;/code&gt; privilege. Superusers of course bypass this restriction. After the extension has been installed, users may issue &lt;code&gt;GRANT&lt;/code&gt; commands to change the privileges on the functions to allow others to execute them. However, it might be preferable to add those users to the &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; role instead.</source>
          <target state="translated">これらの関数は詳細なページレベルの情報を返すため、デフォルトではアクセスが制限されています。デフォルトでは、ロール &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; のみが &lt;code&gt;EXECUTE&lt;/code&gt; 権限を持っています。スーパーユーザーはもちろんこの制限を回避します。拡張機能がインストールされた後、ユーザーは &lt;code&gt;GRANT&lt;/code&gt; コマンドを発行して、関数の権限を変更し、他のユーザーがそれらを実行できるようにすることができます。ただし、代わりにそれらのユーザーを &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; ロールに追加することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cab3b5bbab6ef84f87ff0c28b63da48ab8adbf53" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_auth_members&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_auth_members&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ユーザーIDはクラスター全体にわたるため、 &lt;code&gt;pg_auth_members&lt;/code&gt; はクラスターのすべてのデータベースで共有されます &lt;code&gt;pg_auth_members&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つはありません。</target>
        </trans-unit>
        <trans-unit id="0a9b4bf1d549fcf042c9f5eb8f3493cb9cfe27e7" translate="yes" xml:space="preserve">
          <source>Because user identities are cluster-wide, &lt;code&gt;pg_authid&lt;/code&gt; is shared across all databases of a cluster: there is only one copy of &lt;code&gt;pg_authid&lt;/code&gt; per cluster, not one per database.</source>
          <target state="translated">ユーザーIDはクラスター全体にわたるため、 &lt;code&gt;pg_authid&lt;/code&gt; はクラスターのすべてのデータベース間で共有されます &lt;code&gt;pg_authid&lt;/code&gt; コピーはクラスターごとに1 つだけで、データベースごとに1つではありません。</target>
        </trans-unit>
        <trans-unit id="b7824c0664ad3fb70745076ae899f66946c9584d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.1, the arguments of the sequence functions were of type &lt;code&gt;text&lt;/code&gt;, not &lt;code&gt;regclass&lt;/code&gt;, and the above-described conversion from a text string to an OID value would happen at run time during each call. For backward compatibility, this facility still exists, but internally it is now handled as an implicit coercion from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;regclass&lt;/code&gt; before the function is invoked.</source>
          <target state="translated">PostgreSQL 8.1より前のバージョンでは、シーケンス関数の引数は &lt;code&gt;regclass&lt;/code&gt; ではなく &lt;code&gt;text&lt;/code&gt; 型であり、上記のテキスト文字列からOID値への変換は、各呼び出しの実行時に実行されていました。下位互換性のために、この機能はまだ存在していますが、関数が呼び出される前に、内部的に &lt;code&gt;text&lt;/code&gt; から &lt;code&gt;regclass&lt;/code&gt; への暗黙の強制として処理されます。</target>
        </trans-unit>
        <trans-unit id="5fe2f878504da2e1db73277f0e33ea8b96b5ad9c" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the &lt;code&gt;.*&lt;/code&gt; syntax was not expanded in row constructors, so that writing &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; created a two-field row whose first field was another row value. The new behavior is usually more useful. If you need the old behavior of nested row values, write the inner row value without &lt;code&gt;.*&lt;/code&gt;, for instance &lt;code&gt;ROW(t, 42)&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL 8.2より前は、行コンストラクターで &lt;code&gt;.*&lt;/code&gt; 構文が拡張されていなかったため、 &lt;code&gt;ROW(t.*, 42)&lt;/code&gt; を書き込むと、最初のフィールドが別の行値である2フィールド行が作成されました。通常、新しい動作の方が便利です。ネストされた行の値の古い動作が必要な場合は、 &lt;code&gt;.*&lt;/code&gt; なしで内部行の値を記述します &lt;code&gt;ROW(t, 42)&lt;/code&gt; 例：ROW（t、42））。</target>
        </trans-unit>
        <trans-unit id="e8d01c186f775230385d810745e30ede0c0292d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.2, the containment operators &lt;code&gt;@&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;@&lt;/code&gt; were respectively called &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;. These names are still available, but are deprecated and will eventually be removed.</source>
          <target state="translated">PostgreSQL 8.2以前は、包含演算子 &lt;code&gt;@&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;@&lt;/code&gt; はそれぞれ &lt;code&gt;~&lt;/code&gt; と &lt;code&gt;@&lt;/code&gt; と呼ばれていました。これらの名前は引き続き使用できますが、廃止され、最終的には削除されます。</target>
        </trans-unit>
        <trans-unit id="c036ccc0fef09aace79d8f72b4bc4956e2e6b969" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to &lt;code&gt;text&lt;/code&gt;. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator (&lt;code&gt;||&lt;/code&gt;) still accepts non-string input, so long as at least one input is of a string type, as shown in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. For other cases, insert an explicit coercion to &lt;code&gt;text&lt;/code&gt; if you need to duplicate the previous behavior.</source>
          <target state="translated">PostgreSQL 8.3より前のバージョンでは、これらの関数は文字列以外のいくつかのデータ型の値も暗黙的に受け入れて &lt;code&gt;text&lt;/code&gt; 。これは、これらのデータ型からテキストへの暗黙的な強制型変換が存在するためです。これらの強制は、驚くべき行動を頻繁に引き起こしたため、削除されました。ただし、&lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;表9.9に&lt;/a&gt;示すように、少なくとも1つの入力が文字列型である限り、文字列連結演算子（ &lt;code&gt;||&lt;/code&gt; ）は文字列以外の入力を受け入れます。その他の場合、以前の動作を複製する必要がある場合は、明示的な強制型変換を &lt;code&gt;text&lt;/code&gt; 挿入します。</target>
        </trans-unit>
        <trans-unit id="3b8019c3d24fcdf13fb68d8305a1528d20dff010" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. Now, some whitespace is required.</source>
          <target state="translated">PostgreSQL 8.4以前では、psqlは1文字のバックスラッシュコマンドの第1引数を、空白を介さずにコマンドの直後に開始することができました。現在では、多少の空白が必要になりました。</target>
        </trans-unit>
        <trans-unit id="95fbf31e963d4b484912ba157149b28d1649f2d4" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 8.4, the &lt;code&gt;OPERATOR&lt;/code&gt; clause could include a &lt;code&gt;RECHECK&lt;/code&gt; option. This is no longer supported because whether an index operator is &amp;ldquo;lossy&amp;rdquo; is now determined on-the-fly at run time. This allows efficient handling of cases where an operator might or might not be lossy.</source>
          <target state="translated">PostgreSQL 8.4より前のバージョンでは、 &lt;code&gt;OPERATOR&lt;/code&gt; 句に &lt;code&gt;RECHECK&lt;/code&gt; オプションを含めることができました。これはサポートされなくなりました。これは、インデックス演算子が「損失がある」かどうかが実行時にオンザフライで決定されるようになったためです。これにより、オペレーターが損失を伴う場合とそうでない場合を効率的に処理できます。</target>
        </trans-unit>
        <trans-unit id="5824a92b6b2740af57b007a3a86225a310d091b7" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, &lt;code&gt;pg_am&lt;/code&gt; contained many additional columns representing properties of index access methods. That data is now only directly visible at the C code level. However, &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; and related functions have been added to allow SQL queries to inspect index access method properties; see &lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;Table 9.68&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 9.6より前の &lt;code&gt;pg_am&lt;/code&gt; は、pg_amにはインデックスアクセスメソッドのプロパティを表す多くの列が含まれていました。このデータは、Cコードレベルでのみ直接表示されるようになりました。ただし、 &lt;code&gt;pg_index_column_has_property()&lt;/code&gt; および関連関数が追加され、SQLクエリがインデックスアクセスメソッドのプロパティを検査できるようになりました。&lt;a href=&quot;functions-info#FUNCTIONS-INFO-CATALOG-TABLE&quot;&gt;表9.68を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a4765a073d10eb89d73b00161ddb8dddb0be1ef8" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, SQL commands in script files were terminated by newlines, and so they could not be continued across lines. Now a semicolon is &lt;em&gt;required&lt;/em&gt; to separate consecutive SQL commands (though a SQL command does not need one if it is followed by a meta command). If you need to create a script file that works with both old and new versions of pgbench, be sure to write each SQL command on a single line ending with a semicolon.</source>
          <target state="translated">PostgreSQL 9.6より前のバージョンでは、スクリプトファイル内のSQLコマンドは改行で終了していたため、行をまたいで継続することはできませんでした。セミコロンは、連続するSQLコマンドを区切る&lt;em&gt;ために必要です&lt;/em&gt;（SQLコマンドの後にメタコマンドが続く場合は、セミコロンは&lt;em&gt;必要&lt;/em&gt;ありません）。pgbenchの古いバージョンと新しいバージョンの両方で動作するスクリプトファイルを作成する必要がある場合は、セミコロンで終わる1行に各SQLコマンドを記述してください。</target>
        </trans-unit>
        <trans-unit id="25a91312b02bab209e6a6f9a691f6a084f05d75d" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL 9.6, the &lt;code&gt;-c&lt;/code&gt; option implied &lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--no-psqlrc&lt;/code&gt;); this is no longer the case.</source>
          <target state="translated">PostgreSQL 9.6より前の &lt;code&gt;--no-psqlrc&lt;/code&gt; では、 &lt;code&gt;-c&lt;/code&gt; オプションは &lt;code&gt;-X&lt;/code&gt; （--no-psqlrc）を意味していました。これはもう当てはまりません。</target>
        </trans-unit>
        <trans-unit id="e88cb3afc9e7c5edbb82c8ba3662818b28a3aaef" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL had the &lt;code&gt;INCLUDE&lt;/code&gt; feature, people sometimes made covering indexes by writing the payload columns as ordinary index columns, that is writing</source>
          <target state="translated">PostgreSQLに &lt;code&gt;INCLUDE&lt;/code&gt; 機能が導入される前は、ペイロード列を通常のインデックス列として書き込むことでインデックスをカバーすることがありました。</target>
        </trans-unit>
        <trans-unit id="b6ecfe47fb55ef8a0352cf146e2122df69c11049" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.2, the shell-type creation syntax &lt;code&gt;CREATE TYPE name&lt;/code&gt; did not exist. The way to create a new base type was to create its input function first. In this approach, PostgreSQL will first see the name of the new data type as the return type of the input function. The shell type is implicitly created in this situation, and then it can be referenced in the definitions of the remaining I/O functions. This approach still works, but is deprecated and might be disallowed in some future release. Also, to avoid accidentally cluttering the catalogs with shell types as a result of simple typos in function definitions, a shell type will only be made this way when the input function is written in C.</source>
          <target state="translated">PostgreSQLバージョン8.2より前は、シェルタイプ作成構文 &lt;code&gt;CREATE TYPE name&lt;/code&gt; は存在しませんでした。新しい基本型を作成する方法は、最初に入力関数を作成することでした。このアプローチでは、PostgreSQLは最初に新しいデータ型の名前を入力関数の戻り型として認識します。この場合、シェルタイプは暗黙的に作成され、残りのI / O関数の定義で参照できます。このアプローチは引き続き機能しますが、推奨されておらず、将来のリリースで許可されなくなる可能性があります。また、関数定義での単純なタイプミスの結果として、誤ってカタログがシェルタイプで乱雑にならないようにするために、シェルタイプは、入力関数がCで記述されている場合にのみこの方法で作成されます。</target>
        </trans-unit>
        <trans-unit id="133cff6a54d531aaca5754e3dd9245f0764b14c3" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the &lt;code&gt;SET&lt;/code&gt; clause was not available, and so older functions may contain rather complicated logic to save, set, and restore &lt;code&gt;search_path&lt;/code&gt;. The &lt;code&gt;SET&lt;/code&gt; clause is far easier to use for this purpose.</source>
          <target state="translated">PostgreSQLバージョン8.3より前は、 &lt;code&gt;SET&lt;/code&gt; 句は使用できなかったため、古い関数には &lt;code&gt;search_path&lt;/code&gt; を保存、設定、および復元するためのかなり複雑なロジックが含まれている可能性があります。 &lt;code&gt;SET&lt;/code&gt; の句は、この目的のために使用する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="d40dc4e81bdd5f6ad72cddc10364e0a47323f2d2" translate="yes" xml:space="preserve">
          <source>Before PostgreSQL version 8.3, the name of a generated array type was always exactly the element type's name with one underscore character (&lt;code&gt;_&lt;/code&gt;) prepended. (Type names were therefore restricted in length to one less character than other names.) While this is still usually the case, the array type name may vary from this in case of maximum-length names or collisions with user type names that begin with underscore. Writing code that depends on this convention is therefore deprecated. Instead, use &lt;code&gt;pg_type&lt;/code&gt;.&lt;code&gt;typarray&lt;/code&gt; to locate the array type associated with a given type.</source>
          <target state="translated">PostgreSQLバージョン8.3より前のバージョンでは、生成された配列型の名前は常に1つのアンダースコア文字（ &lt;code&gt;_&lt;/code&gt; ）が前に付加された要素型の名前でした。 （したがって、タイプ名は他の名前よりも1文字少ない長さに制限されていました。）これは通常のケースですが、最大長の名前またはアンダースコアで始まるユーザータイプ名との衝突の場合、配列タイプ名はこれとは異なる場合があります。 。したがって、この規則に依存するコードの作成は非推奨です。代わりに、 &lt;code&gt;pg_type&lt;/code&gt; を使用してください。 &lt;code&gt;typarray&lt;/code&gt; は、特定の型に関連付けられている配列型を見つけます。</target>
        </trans-unit>
        <trans-unit id="6cde500737c3794e75266509d120c3f451ce96fd" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">誰もがデータベースにアクセスする前に、データベースサーバーを起動する必要があります。データベースサーバープログラムは &lt;code&gt;postgres&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="96a33375376d06d4d560a6a1c1041e7d31e19935" translate="yes" xml:space="preserve">
          <source>Before anyone can access the database, you must start the database server. The database server program is called &lt;code&gt;postgres&lt;/code&gt;. The &lt;code&gt;postgres&lt;/code&gt; program must know where to find the data it is supposed to use. This is done with the &lt;code&gt;-D&lt;/code&gt; option. Thus, the simplest way to start the server is:</source>
          <target state="translated">だれでもデータベースにアクセスできるようにするには、データベースサーバーを起動する必要があります。データベースサーバープログラムは &lt;code&gt;postgres&lt;/code&gt; と呼ばれます。 &lt;code&gt;postgres&lt;/code&gt; プログラムはどこ使用することになっているデータを見つけるために知っている必要があります。これは &lt;code&gt;-D&lt;/code&gt; オプションで行われます。したがって、サーバーを起動する最も簡単な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="222bfa6cd0afdad9a2e9f50eb2cacfa866429974" translate="yes" xml:space="preserve">
          <source>Before doing so, the function should check the sign of &lt;code&gt;offset&lt;/code&gt;: if it is less than zero, raise error &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; (22013) with error text like &amp;ldquo;invalid preceding or following size in window function&amp;rdquo;. (This is required by the SQL standard, although nonstandard operator families might perhaps choose to ignore this restriction, since there seems to be little semantic necessity for it.) This requirement is delegated to the &lt;code&gt;in_range&lt;/code&gt; function so that the core code needn't understand what &amp;ldquo;less than zero&amp;rdquo; means for a particular data type.</source>
          <target state="translated">そうする前に、関数は &lt;code&gt;offset&lt;/code&gt; の符号をチェックする必要があります。ゼロ未満の場合は、「ウィンドウ関数の無効な先行または後続のサイズ」などのエラーテキストを含むエラー &lt;code&gt;ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE&lt;/code&gt; （22013）を発生させます。 （これはSQL標準で必須ですが、非標準の演算子ファミリはこの制限を無視することを選択する可能性があります。意味上の必要性はほとんどないようです。）この要件は &lt;code&gt;in_range&lt;/code&gt; 関数に委任されているため、コアコードは理解する必要がありません。特定のデータ型の「ゼロ未満」の意味。</target>
        </trans-unit>
        <trans-unit id="9433a751fdf2c9c611a9f86077418abf326bf14a" translate="yes" xml:space="preserve">
          <source>Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)</source>
          <target state="translated">SQL ダンプをリストアする前に、ダンプされたデータベース内のオブジェクトを所有している、またはオブジェクトに権限を付与されているすべてのユーザーがすでに存在している必要があります。存在しない場合、リストアは元の所有権および/または権限を持つオブジェクトの再作成に失敗します(これは望むことではありませんが、通常はそうではありません)。(これが必要な場合もありますが、通常はそうではありません。)</target>
        </trans-unit>
        <trans-unit id="5350218eee7862579014da56e03f9c4a8c7df37f" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">&lt;code&gt;ATTACH PARTITION&lt;/code&gt; コマンドを実行する前に、目的のパーティション制約に一致するように、アタッチするテーブルに &lt;code&gt;CHECK&lt;/code&gt; 制約を作成することをお勧めします。これにより、システムはスキャンをスキップして、暗黙のパーティション制約を検証できます。 &lt;code&gt;CHECK&lt;/code&gt; 制約がない場合、そのパーティションに対する &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; ロックと親テーブルに対する &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; ロックを保持しながら、テーブルがスキャンされてパーティション制約が検証されます。 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; が終了した後、冗長な &lt;code&gt;CHECK&lt;/code&gt; 制約を削除することが望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="0534112e08b3f377dcff7dae34fa42dedf03836d" translate="yes" xml:space="preserve">
          <source>Before running the &lt;code&gt;ATTACH PARTITION&lt;/code&gt; command, it is recommended to create a &lt;code&gt;CHECK&lt;/code&gt; constraint on the table to be attached matching the desired partition constraint. That way, the system will be able to skip the scan which is otherwise needed to validate the implicit partition constraint. Without the &lt;code&gt;CHECK&lt;/code&gt; constraint, the table will be scanned to validate the partition constraint while holding an &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; lock on that partition and a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the parent table. It may be desired to drop the redundant &lt;code&gt;CHECK&lt;/code&gt; constraint after &lt;code&gt;ATTACH PARTITION&lt;/code&gt; is finished.</source>
          <target state="translated">&lt;code&gt;ATTACH PARTITION&lt;/code&gt; コマンドを実行する前に、アタッチするテーブルに目的のパーティション制約に一致する &lt;code&gt;CHECK&lt;/code&gt; 制約を作成することをお勧めします。そうすれば、システムは、暗黙のパーティション制約を検証するために必要なスキャンをスキップできます。なし &lt;code&gt;CHECK&lt;/code&gt; 制約、テーブルを保持したまま、パーティション制約を検証するために走査される &lt;code&gt;ACCESS EXCLUSIVE&lt;/code&gt; のそのパーティション上のロックと &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; の親表のロックを。 &lt;code&gt;ATTACH PARTITION&lt;/code&gt; が終了した後、冗長な &lt;code&gt;CHECK&lt;/code&gt; 制約を削除したい場合があります。</target>
        </trans-unit>
        <trans-unit id="6cd8ecaf3b3090d8469e126e6ec0aadfd531ece9" translate="yes" xml:space="preserve">
          <source>Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.</source>
          <target state="translated">先に進む前に、PostgreSQLの基本的なシステムアーキテクチャを理解しておく必要があります。PostgreSQLの各部分がどのように相互作用するかを理解することで、この章が多少明確になります。</target>
        </trans-unit>
        <trans-unit id="2bd6b34f5ab63eba4552e311eedb5465ee67a88a" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">何かを行う前に、ディスク上のデータベースストレージ領域を初期化する必要があります。これを&lt;em&gt;データベースクラスタ&lt;/em&gt;と呼び&lt;em&gt;ます&lt;/em&gt;。 （SQL標準では、カタログクラスターという用語を使用しています。）データベースクラスターは、実行中のデータベースサーバーの単一のインスタンスによって管理されるデータベースのコレクションです。初期化後、データベースクラスターには &lt;code&gt;postgres&lt;/code&gt; という名前のデータベースが含まれます。これは、ユーティリティ、ユーザー、およびサードパーティのアプリケーションが使用するデフォルトのデータベースです。データベースサーバー自体は &lt;code&gt;postgres&lt;/code&gt; データベースが存在する必要はありませんが、多くの外部ユーティリティプログラムはそれが存在すると想定しています。初期化中に各クラスター内に作成された別のデータベースは、 &lt;code&gt;template1&lt;/code&gt; と呼ばれます。名前が示すように、これは後で作成されるデータベースのテンプレートとして使用されます。実際の作業には使用しないでください。（クラスター内での新しいデータベースの作成については、&lt;a href=&quot;https://www.postgresql.org/docs/12/managing-databases.html&quot;&gt;第22章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="80b6d48dacb8cea98d5f49fb8a5fb0ff5e17a88f" translate="yes" xml:space="preserve">
          <source>Before you can do anything, you must initialize a database storage area on disk. We call this a &lt;em&gt;database cluster&lt;/em&gt;. (The SQL standard uses the term catalog cluster.) A database cluster is a collection of databases that is managed by a single instance of a running database server. After initialization, a database cluster will contain a database named &lt;code&gt;postgres&lt;/code&gt;, which is meant as a default database for use by utilities, users and third party applications. The database server itself does not require the &lt;code&gt;postgres&lt;/code&gt; database to exist, but many external utility programs assume it exists. Another database created within each cluster during initialization is called &lt;code&gt;template1&lt;/code&gt;. As the name suggests, this will be used as a template for subsequently created databases; it should not be used for actual work. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;Chapter 22&lt;/a&gt; for information about creating new databases within a cluster.)</source>
          <target state="translated">何かを行う前に、ディスク上のデータベースストレージ領域を初期化する必要があります。これを&lt;em&gt;データベースクラスター&lt;/em&gt;と呼び&lt;em&gt;ます&lt;/em&gt;。 （SQL標準ではカタログクラスターという用語を使用しています。）データベースクラスターは、実行中のデータベースサーバーの単一インスタンスによって管理されるデータベースのコレクションです。初期化後、データベースクラスターには &lt;code&gt;postgres&lt;/code&gt; という名前のデータベースが含まれます。これは、ユーティリティ、ユーザー、およびサードパーティアプリケーションが使用するデフォルトのデータベースとして使用されます。データベースサーバー自体は &lt;code&gt;postgres&lt;/code&gt; データベースが存在する必要はありませんが、多くの外部ユーティリティプログラムはそれが存在することを前提としています。初期化中に各クラスター内に作成される別のデータベースは、 &lt;code&gt;template1&lt;/code&gt; と呼ばれます。。名前が示すように、これは後で作成されるデータベースのテンプレートとして使用されます。実際の作業には使用しないでください。（クラスター内での新しいデータベースの作成については、&lt;a href=&quot;https://www.postgresql.org/docs/13/managing-databases.html&quot;&gt;第22章を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="c5021e6ec2c149bc593346cdbced55fdf083dae8" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE EXTENSION&lt;/code&gt; を使用して拡張機能をデータベースにロードする前に、拡張機能のサポートファイルをインストールする必要があります。PostgreSQLで提供される拡張機能のインストールに関する情報は、&lt;a href=&quot;https://www.postgresql.org/docs/12/contrib.html&quot;&gt;追加のモジュールにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="083511ee8f3db20d9fdeeef0f34879a74ab033ad" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;CREATE EXTENSION&lt;/code&gt; to load an extension into a database, the extension's supporting files must be installed. Information about installing the extensions supplied with PostgreSQL can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;Additional Supplied Modules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE EXTENSION&lt;/code&gt; を使用して拡張機能をデータベースにロードする前に、拡張機能のサポートファイルをインストールする必要があります。PostgreSQLで提供される拡張機能のインストールに関する情報は、&lt;a href=&quot;https://www.postgresql.org/docs/13/contrib.html&quot;&gt;追加の提供モジュールにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b42b034c7e4f7289aaf07ce4a58233afbf01dc95" translate="yes" xml:space="preserve">
          <source>Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.</source>
          <target state="translated">PostgreSQLを使用する前に、もちろんインストールする必要があります。オペレーティングシステムの配布物に含まれていたか、システム管理者が既にインストールしていたために、PostgreSQLが既にインストールされている可能性があります。その場合、PostgreSQLへのアクセス方法について、オペレーティングシステムのドキュメントやシステム管理者から情報を得る必要があります。</target>
        </trans-unit>
        <trans-unit id="b26dbac1aa32ad5c0e931ef76f5f13b493f4cca5" translate="yes" xml:space="preserve">
          <source>Begin recovery on the standby server from the local WAL archive, using &lt;code&gt;restore_command&lt;/code&gt; that waits as described previously (see &lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;Section 25.3.4&lt;/a&gt;).</source>
          <target state="translated">前述のように待機する &lt;code&gt;restore_command&lt;/code&gt; を使用して、ローカルWALアーカイブからスタンバイサーバーでリカバリを開始します（&lt;a href=&quot;continuous-archiving#BACKUP-PITR-RECOVERY&quot;&gt;セクション25.3.4を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b089abb1b8e490f01578f107a306004e919d4fa6" translate="yes" xml:space="preserve">
          <source>Begin streaming changes from the logical replication slot specified by &lt;code&gt;--slot&lt;/code&gt;, continuing until terminated by a signal. If the server side change stream ends with a server shutdown or disconnect, retry in a loop unless &lt;code&gt;--no-loop&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--slot&lt;/code&gt; で指定された論理複製スロットから変更のストリーミングを開始し、シグナルで終了するまで続行します。サーバー側の変更ストリームがサーバーのシャットダウンまたは切断で終了する場合、 &lt;code&gt;--no-loop&lt;/code&gt; が指定されていない限り、ループで再試行します。</target>
        </trans-unit>
        <trans-unit id="5723f3fda46717e1c7feda49b72b28e567ff2c36" translate="yes" xml:space="preserve">
          <source>Begin the output with a command to create the database itself and reconnect to the created database. (With a script of this form, it doesn't matter which database in the destination installation you connect to before running the script.) If &lt;code&gt;--clean&lt;/code&gt; is also specified, the script drops and recreates the target database before reconnecting to it.</source>
          <target state="translated">データベース自体を作成し、作成したデータベースに再接続するコマンドで出力を開始します。（この形式のスクリプトでは、スクリプトを実行する前に接続先インストールのどのデータベースに接続するかは関係ありません。）-- &lt;code&gt;--clean&lt;/code&gt; も指定されている場合、スクリプトはターゲットデータベースを削除して再作成してから、データベースに再接続します。</target>
        </trans-unit>
        <trans-unit id="039cd3e67eb5290833876444452a3461967b021e" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.1, these index types also support index searches for &lt;code&gt;LIKE&lt;/code&gt; and &lt;code&gt;ILIKE&lt;/code&gt;, for example</source>
          <target state="translated">PostgreSQL 9.1以降、これらのインデックスタイプは &lt;code&gt;LIKE&lt;/code&gt; および &lt;code&gt;ILIKE&lt;/code&gt; のインデックス検索もサポートします。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="50f6ae535e6d21e272577a4aeb90ccdf9bd1fc99" translate="yes" xml:space="preserve">
          <source>Beginning in PostgreSQL 9.3, these index types also support index searches for regular-expression matches (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~*&lt;/code&gt; operators), for example</source>
          <target state="translated">PostgreSQL 9.3以降、これらのインデックスタイプは、正規表現の一致（ &lt;code&gt;~&lt;/code&gt; および &lt;code&gt;~*&lt;/code&gt; 演算子）のインデックス検索もサポートしています。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="e18ae86eb6dacc56f3e992def21c4e72f662c365" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">&lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 関数と同じように動作しますが、変更は消費されません。つまり、それらは将来の呼び出しで再び返されます。</target>
        </trans-unit>
        <trans-unit id="2cc29d4604bab2d23897cf42e9aa658714f98b76" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt; and that changes are not consumed; that is, they will be returned again on future calls.</source>
          <target state="translated">変更が &lt;code&gt;bytea&lt;/code&gt; として返され、変更が消費されないことを除いて、 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 関数と同じように動作します。つまり、それらは将来の呼び出しで再び返されます。</target>
        </trans-unit>
        <trans-unit id="0d8b3d76c539629fdd464e88d07fda0a141c2719" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">変更が &lt;code&gt;bytea&lt;/code&gt; として返されることを除いて、 &lt;code&gt;pg_logical_slot_get_changes()&lt;/code&gt; 関数と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="52757979ec3d8a6995e55b22d0069c2c9da4e33a" translate="yes" xml:space="preserve">
          <source>Behaves just like the &lt;code&gt;pg_logical_slot_peek_changes()&lt;/code&gt; function, except that changes are returned as &lt;code&gt;bytea&lt;/code&gt;.</source>
          <target state="translated">変更が &lt;code&gt;bytea&lt;/code&gt; として返されることを除いて、 &lt;code&gt;pg_logical_slot_peek_changes()&lt;/code&gt; 関数と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="10e28951f118886fb1db9aad1518cc8230f657d1" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt;, except that it acquires a shared lock rather than exclusive lock on each retrieved row. A shared lock blocks other transactions from performing &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; or &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; on these rows, but it does not prevent them from performing &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">検索された各行に対して排他ロックではなく共有ロックを取得することを除いて、 &lt;code&gt;FOR NO KEY UPDATE&lt;/code&gt; と同様に動作します。共有ロックは、他のトランザクションがこれらの行に対して &lt;code&gt;UPDATE&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; または &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; を実行するのをブロックしますが、 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; または &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; の実行を妨げません。</target>
        </trans-unit>
        <trans-unit id="4166e40468956f25d587c502c88de582346f3e60" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR SHARE&lt;/code&gt;, except that the lock is weaker: &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; is blocked, but not &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;. A key-shared lock blocks other transactions from performing &lt;code&gt;DELETE&lt;/code&gt; or any &lt;code&gt;UPDATE&lt;/code&gt; that changes the key values, but not other &lt;code&gt;UPDATE&lt;/code&gt;, and neither does it prevent &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt;, &lt;code&gt;SELECT FOR SHARE&lt;/code&gt;, or &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt;.</source>
          <target state="translated">ロックが弱いことを除いて、 &lt;code&gt;FOR SHARE&lt;/code&gt; と同様に動作します &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; はブロックされますが、 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; はブロックされません。キー共有ロックは、他のトランザクションがキー値を変更する &lt;code&gt;DELETE&lt;/code&gt; または &lt;code&gt;UPDATE&lt;/code&gt; を実行することをブロックしますが、他の &lt;code&gt;UPDATE&lt;/code&gt; はブロックしません。また、 &lt;code&gt;SELECT FOR NO KEY UPDATE&lt;/code&gt; 、 &lt;code&gt;SELECT FOR SHARE&lt;/code&gt; 、または &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; もブロックしません。</target>
        </trans-unit>
        <trans-unit id="b3975839e55e061601c3038a505012e75c26cc40" translate="yes" xml:space="preserve">
          <source>Behaves similarly to &lt;code&gt;FOR UPDATE&lt;/code&gt;, except that the lock acquired is weaker: this lock will not block &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; commands that attempt to acquire a lock on the same rows. This lock mode is also acquired by any &lt;code&gt;UPDATE&lt;/code&gt; that does not acquire a &lt;code&gt;FOR UPDATE&lt;/code&gt; lock.</source>
          <target state="translated">取得したロックが弱いことを除いて、 &lt;code&gt;FOR UPDATE&lt;/code&gt; と同様に動作します。このロックは、同じ行でロックを取得しようとする &lt;code&gt;SELECT FOR KEY SHARE&lt;/code&gt; コマンドをブロックしません。このロックモードは、 &lt;code&gt;FOR UPDATE&lt;/code&gt; ロックを取得しない &lt;code&gt;UPDATE&lt;/code&gt; によっても取得されます。</target>
        </trans-unit>
        <trans-unit id="bfbd41304878c2d772d5d897e0245d1caed66504" translate="yes" xml:space="preserve">
          <source>Behavior of B-Tree Operator Classes</source>
          <target state="translated">B-Treeオペレータクラスの挙動</target>
        </trans-unit>
        <trans-unit id="126af5216968b8a395d1e58cbc6d82b4d656f6fb" translate="yes" xml:space="preserve">
          <source>Below is a larger example of how this feature can be used in production environments. The table &lt;code&gt;passwd&lt;/code&gt; emulates a Unix password file:</source>
          <target state="translated">以下は、この機能を運用環境で使用する方法のより大きな例です。テーブル &lt;code&gt;passwd&lt;/code&gt; は、Unixパスワードファイルをエミュレートします。</target>
        </trans-unit>
        <trans-unit id="7fca4fa390ed5f3e5c9eff1ebae50bc1ae5a07f1" translate="yes" xml:space="preserve">
          <source>Below we create a dictionary and bind some token types to an astronomical thesaurus and English stemmer:</source>
          <target state="translated">以下では、辞書を作成し、いくつかのトークンタイプを天文学的シソーラスと英語ステムラーにバインドします。</target>
        </trans-unit>
        <trans-unit id="870f5d9661b7407b932b1598182f5f2d810cf9fe" translate="yes" xml:space="preserve">
          <source>Benchmarking Options</source>
          <target state="translated">ベンチマークオプション</target>
        </trans-unit>
        <trans-unit id="2fb7c98fc75cb4f79b347af89afb1652e417df34" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;第19章に&lt;/a&gt;記載されている構成パラメータの他に、 &lt;code&gt;SET&lt;/code&gt; コマンドを使用してのみ調整できるものや、特別な構文を持つものがあります。</target>
        </trans-unit>
        <trans-unit id="ef6d7a0bd27a4a7a7898b15686b3e50c0c08dc1a" translate="yes" xml:space="preserve">
          <source>Besides the configuration parameters documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;, there are a few that can only be adjusted using the &lt;code&gt;SET&lt;/code&gt; command or that have a special syntax:</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;第19章に&lt;/a&gt;記載されている構成パラメーターの他に、 &lt;code&gt;SET&lt;/code&gt; コマンドを使用してのみ調整できるもの、または特別な構文を持つものがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="dcdcdb56c299825a17bc63b94d508dafd4fc2a95" translate="yes" xml:space="preserve">
          <source>Between (inclusive of the range endpoints).</source>
          <target state="translated">Between(範囲のエンドポイントを含む)。</target>
        </trans-unit>
        <trans-unit id="e6c66d70ecd66ce14264e1d077f56c53c9c3ae8a" translate="yes" xml:space="preserve">
          <source>Between, after sorting the two endpoint values.</source>
          <target state="translated">2つのエンドポイントの値をソートした後、Between。</target>
        </trans-unit>
        <trans-unit id="60abe3d5ae299760f0dd57db1ab7b6b69b7cc66b" translate="yes" xml:space="preserve">
          <source>Beware that recent releases of macOS ignore attempts to set &lt;code&gt;SHMMAX&lt;/code&gt; to a value that isn't an exact multiple of 4096.</source>
          <target state="translated">macOSの最近のリリースでは、 &lt;code&gt;SHMMAX&lt;/code&gt; を4096の正確な倍数ではない値に設定しようとする試みを無視していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b80b5f7ca59611a24bc9604afc3876b56110cee0" translate="yes" xml:space="preserve">
          <source>Beware that the &lt;code&gt;ROWS&lt;/code&gt; mode can produce unpredictable results if the &lt;code&gt;ORDER BY&lt;/code&gt; ordering does not order the rows uniquely. The &lt;code&gt;RANGE&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; modes are designed to ensure that rows that are peers in the &lt;code&gt;ORDER BY&lt;/code&gt; ordering are treated alike: all rows of a given peer group will be in the frame or excluded from it.</source>
          <target state="translated">&lt;code&gt;ORDER BY&lt;/code&gt; の順序付けが行を一意に順序付けしない場合、 &lt;code&gt;ROWS&lt;/code&gt; モードは予期しない結果をもたらす可能性があることに注意してください。 &lt;code&gt;RANGE&lt;/code&gt; と &lt;code&gt;GROUPS&lt;/code&gt; モードは、ピアにある行ことを保証するために設計されている &lt;code&gt;ORDER BY&lt;/code&gt; 所与のピアグループのすべての行がフレームにあるか、またはそれから除外されます順序が同様に扱われます。</target>
        </trans-unit>
        <trans-unit id="774be1cf4f3a522f1a25f2b6316b0d501136298e" translate="yes" xml:space="preserve">
          <source>Beware that this approach can fail if the outer query level contains additional processing, such as a join, because that might cause the subquery's output to be reordered before the aggregate is computed.</source>
          <target state="translated">外部クエリレベルに結合などの追加処理が含まれている場合、このアプローチは失敗する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="4afac498b0186c05ae272a50fdfb777d86f83f5a" translate="yes" xml:space="preserve">
          <source>Big Five</source>
          <target state="translated">ビッグファイブ</target>
        </trans-unit>
        <trans-unit id="05792c2e47b633979450a4d3fdc731bebb67e917" translate="yes" xml:space="preserve">
          <source>Binary Data Types</source>
          <target state="translated">バイナリデータ型</target>
        </trans-unit>
        <trans-unit id="d978fc265919867464402ead8b5aa5056e5fbd19" translate="yes" xml:space="preserve">
          <source>Binary Data Types: bytea</source>
          <target state="translated">バイナリデータ型:bytea</target>
        </trans-unit>
        <trans-unit id="be10328dd5eb2024df80c19f0915f781f57e2ed4" translate="yes" xml:space="preserve">
          <source>Binary Format</source>
          <target state="translated">バイナリフォーマット</target>
        </trans-unit>
        <trans-unit id="eea185b10ff34a7d0730fbc39d8d1573222be81b" translate="yes" xml:space="preserve">
          <source>Binary String Functions and Operators</source>
          <target state="translated">バイナリ文字列関数と演算子</target>
        </trans-unit>
        <trans-unit id="cbcfd399e3b6e28f48b32806c48d9294b5084ef2" translate="yes" xml:space="preserve">
          <source>Binary String: bit_length</source>
          <target state="translated">バイナリ文字列:bit_length</target>
        </trans-unit>
        <trans-unit id="b8dff4368de0e3c40124e448acd2ca6783cd44df" translate="yes" xml:space="preserve">
          <source>Binary String: btrim</source>
          <target state="translated">バイナリ文字列:btrim</target>
        </trans-unit>
        <trans-unit id="3d3110a88c097ff95d0ceb59cb2d12b59b1aeb9f" translate="yes" xml:space="preserve">
          <source>Binary String: convert</source>
          <target state="translated">バイナリ文字列:変換</target>
        </trans-unit>
        <trans-unit id="af8938914c9b70ca934924b934ba9839025c7024" translate="yes" xml:space="preserve">
          <source>Binary String: convert_from</source>
          <target state="translated">バイナリ文字列:convert_from</target>
        </trans-unit>
        <trans-unit id="e921f5d76c05cb18ae66971b494afa6830c1fe08" translate="yes" xml:space="preserve">
          <source>Binary String: convert_to</source>
          <target state="translated">バイナリ文字列:convert_to</target>
        </trans-unit>
        <trans-unit id="dab4683aaea619005a4200cd9a5215872f4f193a" translate="yes" xml:space="preserve">
          <source>Binary String: decode</source>
          <target state="translated">バイナリ文字列:デコード</target>
        </trans-unit>
        <trans-unit id="1bb599e86584900c656608c4be089126932fb4ca" translate="yes" xml:space="preserve">
          <source>Binary String: encode</source>
          <target state="translated">バイナリ文字列:エンコード</target>
        </trans-unit>
        <trans-unit id="ed9e62f8973e5d6bffd91187c9e478de6423b5ec" translate="yes" xml:space="preserve">
          <source>Binary String: get_bit</source>
          <target state="translated">バイナリ文字列:get_bit</target>
        </trans-unit>
        <trans-unit id="a7dc78314758d39820bb026c008feb884ce531ff" translate="yes" xml:space="preserve">
          <source>Binary String: get_byte</source>
          <target state="translated">バイナリ文字列:get_byte</target>
        </trans-unit>
        <trans-unit id="3b3dfd58346ed838c2d28b9b46ab8febf746666b" translate="yes" xml:space="preserve">
          <source>Binary String: length</source>
          <target state="translated">バイナリ文字列:長さ</target>
        </trans-unit>
        <trans-unit id="3d6bb6f2a913f2fe4e19cd19b79eb492e8027877" translate="yes" xml:space="preserve">
          <source>Binary String: md5</source>
          <target state="translated">バイナリ文字列:md5</target>
        </trans-unit>
        <trans-unit id="2b6e00319f3a8699a801221f672b9e6fae165f94" translate="yes" xml:space="preserve">
          <source>Binary String: octet_length</source>
          <target state="translated">バイナリ文字列:オクテット長</target>
        </trans-unit>
        <trans-unit id="549d7f8bb245593c2f0ec51b5eecfcb99bfc4c36" translate="yes" xml:space="preserve">
          <source>Binary String: overlay</source>
          <target state="translated">バイナリ文字列:オーバーレイ</target>
        </trans-unit>
        <trans-unit id="317470b7465e50bb01ea0ed9d647db9aa1569cbc" translate="yes" xml:space="preserve">
          <source>Binary String: position</source>
          <target state="translated">バイナリ文字列:位置</target>
        </trans-unit>
        <trans-unit id="9434d0dc118c447e4ee164199720303685e8f31a" translate="yes" xml:space="preserve">
          <source>Binary String: set_bit</source>
          <target state="translated">バイナリ文字列:set_bit</target>
        </trans-unit>
        <trans-unit id="f39a20b22ec73f10ccf2ff12ede513b3bf197e16" translate="yes" xml:space="preserve">
          <source>Binary String: set_byte</source>
          <target state="translated">バイナリ文字列:set_byte</target>
        </trans-unit>
        <trans-unit id="edd1f7f5db831e55c4404df9e415cec21d97ca8d" translate="yes" xml:space="preserve">
          <source>Binary String: sha224</source>
          <target state="translated">バイナリ文字列:sha224</target>
        </trans-unit>
        <trans-unit id="a4e5fd05bd7c2057fbb588451d73bc8e364bcd00" translate="yes" xml:space="preserve">
          <source>Binary String: sha256</source>
          <target state="translated">バイナリ文字列:sha256</target>
        </trans-unit>
        <trans-unit id="199ba90dac671366fc2d30018bc9cc60da6d8112" translate="yes" xml:space="preserve">
          <source>Binary String: sha384</source>
          <target state="translated">バイナリ文字列:sha384</target>
        </trans-unit>
        <trans-unit id="b17b7742692d6cc8900d5a09fbba1ba2dcf79e2d" translate="yes" xml:space="preserve">
          <source>Binary String: sha512</source>
          <target state="translated">バイナリ文字列:sha512</target>
        </trans-unit>
        <trans-unit id="138398c9ed1548fd9d09e373d02441ec780c3dba" translate="yes" xml:space="preserve">
          <source>Binary String: substr</source>
          <target state="translated">バイナリ文字列:substr</target>
        </trans-unit>
        <trans-unit id="eb754287eb3b8d22b0752ef54dea23d275538097" translate="yes" xml:space="preserve">
          <source>Binary String: substring</source>
          <target state="translated">バイナリ文字列:部分文字列</target>
        </trans-unit>
        <trans-unit id="0880194133ad39b402dac81c879f4881bf8922df" translate="yes" xml:space="preserve">
          <source>Binary String: trim</source>
          <target state="translated">バイナリ文字列:トリム</target>
        </trans-unit>
        <trans-unit id="4b19a17003e3a215c61a3139f7843b960e175e71" translate="yes" xml:space="preserve">
          <source>Binary String: ||</source>
          <target state="translated">バイナリ文字列。||</target>
        </trans-unit>
        <trans-unit id="c41bc309d8cd529592e339f0c36e8e967a2fed13" translate="yes" xml:space="preserve">
          <source>Binary cursors are a PostgreSQL extension.</source>
          <target state="translated">バイナリカーソルはPostgreSQLの拡張機能です。</target>
        </trans-unit>
        <trans-unit id="6b44f09a82f5b765933694a9db3f15e511f15291" translate="yes" xml:space="preserve">
          <source>Binary cursors should be used carefully. Many applications, including psql, are not prepared to handle binary cursors and expect data to come back in the text format.</source>
          <target state="translated">バイナリカーソルは慎重に使用する必要があります。psqlを含む多くのアプリケーションは、バイナリカーソルを扱う準備ができておらず、データがテキスト形式で返ってくることを期待しています。</target>
        </trans-unit>
        <trans-unit id="253c59e522f194890c38a49fa034c56d5597e5ce" translate="yes" xml:space="preserve">
          <source>Bit 16</source>
          <target state="translated">ビット16</target>
        </trans-unit>
        <trans-unit id="b304e502a60fe2721a2acc2ea86477e058a5fc18" translate="yes" xml:space="preserve">
          <source>Bit String Functions and Operators</source>
          <target state="translated">ビット文字列の関数と演算子</target>
        </trans-unit>
        <trans-unit id="e1ec8af5ed0ac3706706e7ca0257fb8472997bd9" translate="yes" xml:space="preserve">
          <source>Bit String Types</source>
          <target state="translated">ビット文字列の種類</target>
        </trans-unit>
        <trans-unit id="26d5338edfde42da5636b07f3a1f7b3b99348954" translate="yes" xml:space="preserve">
          <source>Bit String: #</source>
          <target state="translated">ビット文字列 #</target>
        </trans-unit>
        <trans-unit id="54a89e1d14e86ab43af7735b61c206ac06fd6632" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;amp;</source>
          <target state="translated">ビット文字列：＆</target>
        </trans-unit>
        <trans-unit id="25bf3896db23b3430dc3419d701ee4519f795bf6" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;gt;&amp;gt;</source>
          <target state="translated">ビット文字列：&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d52a6739aec041222c397e3ab3508452bbdace4c" translate="yes" xml:space="preserve">
          <source>Bit String: &amp;lt;&amp;lt;</source>
          <target state="translated">ビット文字列：&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="698c5053f7fb4235a075904b83c81d0e7f75e767" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; # B&amp;#x27;01101&amp;#x27;</source>
          <target state="translated">ビット文字列：B'10001 '＃B'01101'</target>
        </trans-unit>
        <trans-unit id="4fec3321c838e2393b12b6d782dae5847bd67b84" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;amp; B&amp;#x27;01101&amp;#x27;</source>
          <target state="translated">ビット文字列：B'10001 '＆B'01101'</target>
        </trans-unit>
        <trans-unit id="f80854d98441f5f666a756550418ab3915bb0869" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;gt;&amp;gt; 2</source>
          <target state="translated">ビット文字列：B '10001' &amp;gt;&amp;gt; 2</target>
        </trans-unit>
        <trans-unit id="020f62b450e6a960545b1de75bca157ae03bc7a2" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; &amp;lt;&amp;lt; 3</source>
          <target state="translated">ビット文字列：B '10001' &amp;lt;&amp;lt; 3</target>
        </trans-unit>
        <trans-unit id="edcb968f9fd9173bd5d0d4f8617eb3f6d27f69c3" translate="yes" xml:space="preserve">
          <source>Bit String: B&amp;#x27;10001&amp;#x27; | B&amp;#x27;01101&amp;#x27;</source>
          <target state="translated">ビット文字列：B '10001' | B'01101 '</target>
        </trans-unit>
        <trans-unit id="292bdc723b3de75f45f35aaf3b8989a7fc5eb2b2" translate="yes" xml:space="preserve">
          <source>Bit String: bit_length</source>
          <target state="translated">ビット文字列:bit_length</target>
        </trans-unit>
        <trans-unit id="918db4fa99e0649c8060902f9a3e94ba75c279e0" translate="yes" xml:space="preserve">
          <source>Bit String: get_bit</source>
          <target state="translated">ビット文字列:get_bit</target>
        </trans-unit>
        <trans-unit id="6891e5dceae12938ae30b567970719872fccde2c" translate="yes" xml:space="preserve">
          <source>Bit String: length</source>
          <target state="translated">ビット文字列:長さ</target>
        </trans-unit>
        <trans-unit id="4f5f6f7cb2e1bc80a507138569c25bed2001e0f1" translate="yes" xml:space="preserve">
          <source>Bit String: octet_length</source>
          <target state="translated">ビット文字列:オクテット長</target>
        </trans-unit>
        <trans-unit id="00634ec6386463ae42b1b7bb26891e1338c4b35c" translate="yes" xml:space="preserve">
          <source>Bit String: overlay</source>
          <target state="translated">ビット文字列:オーバーレイ</target>
        </trans-unit>
        <trans-unit id="1a0d8c1cd0116787005f4bee7aff429712b20961" translate="yes" xml:space="preserve">
          <source>Bit String: position</source>
          <target state="translated">ビット文字列:位置</target>
        </trans-unit>
        <trans-unit id="38f3120e8f7e91a683313ad8017d180967d09509" translate="yes" xml:space="preserve">
          <source>Bit String: set_bit</source>
          <target state="translated">ビット文字列:set_bit</target>
        </trans-unit>
        <trans-unit id="eb70e33ea681844ee935ae674a0a87b670e898dd" translate="yes" xml:space="preserve">
          <source>Bit String: substring</source>
          <target state="translated">ビット文字列:部分文字列</target>
        </trans-unit>
        <trans-unit id="4e47fbeeacb2ccb2058a0e13885d27607dc2ff89" translate="yes" xml:space="preserve">
          <source>Bit String: |</source>
          <target state="translated">ビット文字列。|</target>
        </trans-unit>
        <trans-unit id="a9f58217517f242096405bc47fb766301ddb90d4" translate="yes" xml:space="preserve">
          <source>Bit String: ||</source>
          <target state="translated">ビット文字列。||</target>
        </trans-unit>
        <trans-unit id="fb535d3c1297857f6c6638c764b59c16782c04dd" translate="yes" xml:space="preserve">
          <source>Bit String: ~</source>
          <target state="translated">ビット文字列 ~</target>
        </trans-unit>
        <trans-unit id="91c158702eba7e22d8c0b8480c6181f06bc8d6e5" translate="yes" xml:space="preserve">
          <source>Bit String: ~ B&amp;#x27;10001&amp;#x27;</source>
          <target state="translated">ビット文字列：〜B '10001'</target>
        </trans-unit>
        <trans-unit id="2efae331bc5aa821406a784a6e78c0b9daf6c7df" translate="yes" xml:space="preserve">
          <source>Bit mask identifying trigger firing conditions</source>
          <target state="translated">トリガ発射条件を識別するビットマスク</target>
        </trans-unit>
        <trans-unit id="35edcdbad2868d30fa30834e2406d3005ac8363c" translate="yes" xml:space="preserve">
          <source>Bit strings are strings of 1's and 0's. They can be used to store or visualize bit masks. There are two SQL bit types: &lt;code&gt;bit(n)&lt;/code&gt; and &lt;code&gt;bit varying(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer.</source>
          <target state="translated">ビット文字列は、1と0の文字列です。それらは、ビットマスクを格納または視覚化するために使用できます。2つのSQLビット種類があり &lt;code&gt;bit(n)&lt;/code&gt; と &lt;code&gt;bit varying(n)&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; は正の整数であるが。</target>
        </trans-unit>
        <trans-unit id="440588c03e76a6dbf3a0dad3d94ffb56eaf0107d" translate="yes" xml:space="preserve">
          <source>Bit-string constants look like regular string constants with a &lt;code&gt;B&lt;/code&gt; (upper or lower case) immediately before the opening quote (no intervening whitespace), e.g., &lt;code&gt;B'1001'&lt;/code&gt;. The only characters allowed within bit-string constants are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ビット文字列定数は、 &lt;code&gt;B'1001'&lt;/code&gt; に、開始引用符の直前に &lt;code&gt;B&lt;/code&gt; （大文字または小文字）が付いた通常の文字列定数のように見えます（間に空白はありません）。ビット文字列定数内で使用できる文字は &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="ef8b2561e514bdc32792b41e10c969f64c960716" translate="yes" xml:space="preserve">
          <source>Bit-string types</source>
          <target state="translated">ビット文字列型</target>
        </trans-unit>
        <trans-unit id="3119bee988c6c128ef1a7a4d003a2772fc4ae36a" translate="yes" xml:space="preserve">
          <source>BitmapAnd and BitmapOr nodes always report their actual row counts as zero, due to implementation limitations.</source>
          <target state="translated">BitmapAndノードとBitmapOrノードは、実装の制限により、常に実際の行数をゼロとして報告します。</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">ビットごとのAND</target>
        </trans-unit>
        <trans-unit id="2461564dd1b0dd1dfe10a6e27226bb4f00cb800c" translate="yes" xml:space="preserve">
          <source>Bitwise AND (inputs must be of equal length)</source>
          <target state="translated">ビットごとのAND(入力は同じ長さでなければなりません</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">ビット単位ではありません。</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">ビットごとのOR</target>
        </trans-unit>
        <trans-unit id="b3a7a98dcaae40a13757076e24af311dfee77860" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inputs must be of equal length)</source>
          <target state="translated">ビットごとのOR(入力は同じ長さでなければなりません</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">ビットごとのXOR</target>
        </trans-unit>
        <trans-unit id="3ba80ac4bf1c4bbad0f4a7d6ddfd25841835e177" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR</source>
          <target state="translated">ビット単位の排他的論理和</target>
        </trans-unit>
        <trans-unit id="d16eb5b05790cd70e7dd8947da148a14b1c3b585" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive OR (inputs must be of equal length)</source>
          <target state="translated">ビット単位の排他的OR(入力は同じ長さでなければなりません</target>
        </trans-unit>
        <trans-unit id="c8659c0b8789aa4ee715f09528a9e4eecaaa826e" translate="yes" xml:space="preserve">
          <source>Bitwise shift left</source>
          <target state="translated">ビット単位で左シフト</target>
        </trans-unit>
        <trans-unit id="5b90f67d593a4af9275c5c94d26eb0e231cb737a" translate="yes" xml:space="preserve">
          <source>Bitwise shift left (string length is preserved)</source>
          <target state="translated">ビット単位で左にシフト(文字列の長さは保持されます</target>
        </trans-unit>
        <trans-unit id="50231ce6a71d579851db8fdf27b3184364b82e41" translate="yes" xml:space="preserve">
          <source>Bitwise shift right</source>
          <target state="translated">ビット単位で右シフト</target>
        </trans-unit>
        <trans-unit id="2b8813dffcb464fd01e7635b2efefa7c701a1bc5" translate="yes" xml:space="preserve">
          <source>Bitwise shift right (string length is preserved)</source>
          <target state="translated">ビット単位で右シフト(文字列の長さは保持されます</target>
        </trans-unit>
        <trans-unit id="8bfd5b423062918623ca47aa91c65abf2e858720" translate="yes" xml:space="preserve">
          <source>Bloat</source>
          <target state="translated">Bloat</target>
        </trans-unit>
        <trans-unit id="6f50e3e14cce1a8627751575e909b4caa4d3a6a3" translate="yes" xml:space="preserve">
          <source>Bloom is better than btree in handling this type of search:</source>
          <target state="translated">このタイプの検索を扱うには、btreeよりもBloomの方が優れている。</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="92c882ac33d0ee2cd51460d3e115370fb18b7f64" translate="yes" xml:space="preserve">
          <source>Blowfish cipher</source>
          <target state="translated">Blowfish cipher</target>
        </trans-unit>
        <trans-unit id="38d26af6e5082bc6e784c3815947a0f5acecada7" translate="yes" xml:space="preserve">
          <source>Blowfish crypt</source>
          <target state="translated">Blowfish crypt</target>
        </trans-unit>
        <trans-unit id="17d54f2a65a51558dd8c1f3e789157750ff7d6f8" translate="yes" xml:space="preserve">
          <source>Blowfish-based, variant 2a</source>
          <target state="translated">Blowfish-based, variant 2a</target>
        </trans-unit>
        <trans-unit id="58299c5eb711f9a461ff1240fa8b1c0679ab5056" translate="yes" xml:space="preserve">
          <source>Boolean AND</source>
          <target state="translated">ブールアンド</target>
        </trans-unit>
        <trans-unit id="c69f2185492e832f7277d3fff7b42d01f558fb61" translate="yes" xml:space="preserve">
          <source>Boolean NOT</source>
          <target state="translated">ブールひてい</target>
        </trans-unit>
        <trans-unit id="2c320907721a13b5dd2b75f194044bf4fb118e32" translate="yes" xml:space="preserve">
          <source>Boolean OR</source>
          <target state="translated">ブールオア</target>
        </trans-unit>
        <trans-unit id="54bd3ce38554ce1715613858323d1049c39c0685" translate="yes" xml:space="preserve">
          <source>Boolean Type</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="9656fd514386a9028815794334d9467f9f5a0c5e" translate="yes" xml:space="preserve">
          <source>Boolean Type: boolean</source>
          <target state="translated">ブール型:ブール</target>
        </trans-unit>
        <trans-unit id="d602b755186d61e697c04da0a7d821ff7d4efa39" translate="yes" xml:space="preserve">
          <source>Boolean aggregates &lt;code&gt;bool_and&lt;/code&gt; and &lt;code&gt;bool_or&lt;/code&gt; correspond to standard SQL aggregates &lt;code&gt;every&lt;/code&gt; and &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;some&lt;/code&gt;. As for &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;some&lt;/code&gt;, it seems that there is an ambiguity built into the standard syntax:</source>
          <target state="translated">ブール集合体 &lt;code&gt;bool_and&lt;/code&gt; と &lt;code&gt;bool_or&lt;/code&gt; 標準SQLの集合体に対応し &lt;code&gt;every&lt;/code&gt; および &lt;code&gt;any&lt;/code&gt; または &lt;code&gt;some&lt;/code&gt; 。用として &lt;code&gt;any&lt;/code&gt; および &lt;code&gt;some&lt;/code&gt; 、標準の構文には曖昧さがあるようです。</target>
        </trans-unit>
        <trans-unit id="e7e48e64bd944bf0341a3c4f226c0c85bf62984d" translate="yes" xml:space="preserve">
          <source>Boolean constants can be represented in SQL queries by the SQL key words &lt;code&gt;TRUE&lt;/code&gt;, &lt;code&gt;FALSE&lt;/code&gt;, and &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">ブール定数はSQLクエリでSQLキーワード &lt;code&gt;TRUE&lt;/code&gt; 、 &lt;code&gt;FALSE&lt;/code&gt; 、および &lt;code&gt;NULL&lt;/code&gt; で表すことができます。</target>
        </trans-unit>
        <trans-unit id="52e1ee47a7ff1168010b326824ee21ddfeae28c3" translate="yes" xml:space="preserve">
          <source>Boolean types</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="fa793a8aacedef81b06cc550c19f522284580fd4" translate="yes" xml:space="preserve">
          <source>Boolean value tests</source>
          <target state="translated">ブール値テスト</target>
        </trans-unit>
        <trans-unit id="ec240e7050d6f871548eb16c80190949f2f4c3c5" translate="yes" xml:space="preserve">
          <source>Boolean values can also be tested using the predicates</source>
          <target state="translated">ブール値は、述語を使ってテストすることもできます。</target>
        </trans-unit>
        <trans-unit id="61e93ae531636a2f7c54ab2267a73987c4067669" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;NOT NULL&lt;/code&gt; constraints of a partitioned table are always inherited by all its partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints that are marked &lt;code&gt;NO INHERIT&lt;/code&gt; are not allowed to be created on partitioned tables.</source>
          <target state="translated">パーティションテーブルの &lt;code&gt;CHECK&lt;/code&gt; 制約と &lt;code&gt;NOT NULL&lt;/code&gt; 制約の両方は、常にすべてのパーティションに継承されます。 &lt;code&gt;NO INHERIT&lt;/code&gt; とマークされている &lt;code&gt;CHECK&lt;/code&gt; 制約は、パーティション化されたテーブルで作成することはできません。</target>
        </trans-unit>
        <trans-unit id="b889ca8993198c7004a576b1cf90c434b540954c" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; can be any non-null string, with a maximum of 255 characters. The cost parameters specify how much to charge for a character insertion, deletion, or substitution, respectively. You can omit the cost parameters, as in the second version of the function; in that case they all default to 1.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; と &lt;code&gt;target&lt;/code&gt; はどちらも、最大255文字のnull以外の文字列にすることができます。コストパラメータは、文字の挿入、削除、または置換にそれぞれいくら課金するかを指定します。関数の2番目のバージョンのように、コストパラメータを省略できます。その場合、デフォルトはすべて1です。</target>
        </trans-unit>
        <trans-unit id="5ea32d54e6cfd34abb39f16058fc4fd6f2961804" translate="yes" xml:space="preserve">
          <source>Both advisory locks and regular locks are stored in a shared memory pool whose size is defined by the configuration variables &lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;. Care must be taken not to exhaust this memory or the server will be unable to grant any locks at all. This imposes an upper limit on the number of advisory locks grantable by the server, typically in the tens to hundreds of thousands depending on how the server is configured.</source>
          <target state="translated">勧告的ロックと通常のロックの両方は、構成変数&lt;a href=&quot;runtime-config-locks#GUC-MAX-LOCKS-PER-TRANSACTION&quot;&gt;max_locks_per_transaction&lt;/a&gt;および&lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt;によってサイズが定義される共有メモリプールに格納されます。このメモリを使い果たしないように注意する必要があります。そうしないと、サーバーはロックをまったく付与できなくなります。これにより、サーバーによって許可されるアドバイザリロックの数に上限が課せられます。通常、サーバーの構成に応じて数万から数十万になります。</target>
        </trans-unit>
        <trans-unit id="64fe65c7e1e3e888472be5adaa2902cc6b0a1a3b" translate="yes" xml:space="preserve">
          <source>Both forms of bit-string constant can be continued across lines in the same way as regular string constants. Dollar quoting cannot be used in a bit-string constant.</source>
          <target state="translated">どちらの形式のビット文字列定数も、通常の文字列定数と同じ方法で行をまたいで続けることができます。ドルのクォートはビット文字列定数では使用できません。</target>
        </trans-unit>
        <trans-unit id="2b41d8e55f4edf059d0388795bf4f266c2e06c3f" translate="yes" xml:space="preserve">
          <source>Both minmax and inclusion operator classes support cross-data-type operators, though with these the dependencies become more complicated. The minmax operator class requires a full set of operators to be defined with both arguments having the same data type. It allows additional data types to be supported by defining extra sets of operators. Inclusion operator class operator strategies are dependent on another operator strategy as shown in &lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;Table 67.3&lt;/a&gt;, or the same operator strategy as themselves. They require the dependency operator to be defined with the &lt;code&gt;STORAGE&lt;/code&gt; data type as the left-hand-side argument and the other supported data type to be the right-hand-side argument of the supported operator. See &lt;code&gt;float4_minmax_ops&lt;/code&gt; as an example of minmax, and &lt;code&gt;box_inclusion_ops&lt;/code&gt; as an example of inclusion.</source>
          <target state="translated">minmax演算子クラスと包含演算子クラスはどちらもクロスデータ型演算子をサポートしていますが、これらの依存関係はさらに複雑になります。 minmax演算子クラスでは、両方の引数が同じデータ型を持つように定義された演算子の完全なセットが必要です。追加の演算子のセットを定義することにより、追加のデータ型をサポートできます。包含演算子クラスの演算子戦略は、&lt;a href=&quot;brin-extensibility#BRIN-EXTENSIBILITY-INCLUSION-TABLE&quot;&gt;表67.3&lt;/a&gt;に示す別の演算子戦略、またはそれ自体と同じ演算子戦略に依存しています。依存関係演算子は、 &lt;code&gt;STORAGE&lt;/code&gt; データ型を左側の引数として定義し、サポートされる他のデータ型をサポートされる演算子の右側の引数として定義する必要があります。 &lt;code&gt;float4_minmax_ops&lt;/code&gt; の例としてfloat4_minmax_opsを参照してください。 &lt;code&gt;box_inclusion_ops&lt;/code&gt; 包含の例としてのbox_inclusion_ops。</target>
        </trans-unit>
        <trans-unit id="d935d6e4440b7d13db8dea9774a168802ac598e0" translate="yes" xml:space="preserve">
          <source>Both star symbols and simple words can be quantified to restrict how many labels they can match:</source>
          <target state="translated">星形記号も単純な単語も数値化して、一致するラベルの数を制限することができます。</target>
        </trans-unit>
        <trans-unit id="7b6bb44fe8014c95fc406791cc963af10b33bb29" translate="yes" xml:space="preserve">
          <source>Both the maximum precision and the maximum scale of a &lt;code&gt;numeric&lt;/code&gt; column can be configured. To declare a column of type &lt;code&gt;numeric&lt;/code&gt; use the syntax:</source>
          <target state="translated">&lt;code&gt;numeric&lt;/code&gt; 列の最大精度と最大スケールの両方を構成できます。 &lt;code&gt;numeric&lt;/code&gt; 型の列を宣言するには、次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="ea3fb61640ce7586a68af124013d79c4c57b81a1" translate="yes" xml:space="preserve">
          <source>Both the scan position and the mark position (if any) must be maintained consistently in the face of concurrent insertions or deletions in the index. It is OK if a freshly-inserted entry is not returned by a scan that would have found the entry if it had existed when the scan started, or for the scan to return such an entry upon rescanning or backing up even though it had not been returned the first time through. Similarly, a concurrent delete might or might not be reflected in the results of a scan. What is important is that insertions or deletions not cause the scan to miss or multiply return entries that were not themselves being inserted or deleted.</source>
          <target state="translated">スキャン位置とマーク位置(ある場合)は、インデックス内で同時挿入又は削除があっても一貫して維持されなければならない。スキャンが開始されたときにエントリが存在していれば、そのエントリが見つかっていたはずのスキャンで、挿入されたばかりのエントリが返されなかったり、最初に返されなかったにもかかわらず、再スキャンやバックアップの際にそのようなエントリがスキャンによって返されたりしても構いません。同様に、同時削除は、スキャンの結果に反映されるかもしれないし、反映されないかもしれません。重要なのは、挿入や削除によって、スキャンが挿入や削除されていないエントリを見逃したり、複数のエントリを返したりしないようにすることです。</target>
        </trans-unit>
        <trans-unit id="3bce0a8d20dfad3adb1a5af3b099eec9aec7a17c" translate="yes" xml:space="preserve">
          <source>Both the system-wide startup file and the user's personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; or &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt;. The most specific version-matching file will be read in preference to a non-version-specific file.</source>
          <target state="translated">システム全体のスタートアップファイルとユーザーの個人用スタートアップファイルの両方に、ダッシュとPostgreSQLのメジャーリリース番号またはマイナーリリース番号をファイル名に追加することで、psqlバージョン固有にすることができます（例： &lt;code&gt;~/.psqlrc-9.2&lt;/code&gt; または &lt;code&gt;~/.psqlrc-9.2.5&lt;/code&gt; 。最もバージョンが一致するファイルは、バージョンが固有でないファイルよりも優先して読み取られます。</target>
        </trans-unit>
        <trans-unit id="a9f1bcbf395b360aecae5c7aad8432687c5d0c98" translate="yes" xml:space="preserve">
          <source>Boxes are output using the second syntax.</source>
          <target state="translated">ボックスは、2 番目の構文を使用して出力されます。</target>
        </trans-unit>
        <trans-unit id="3b7172d9675205f8063e821e7bb335558a00ea56" translate="yes" xml:space="preserve">
          <source>Boxes are represented by pairs of points that are opposite corners of the box. Values of type &lt;code&gt;box&lt;/code&gt; are specified using any of the following syntaxes:</source>
          <target state="translated">ボックスは、ボックスの対角にあるポイントのペアで表されます。タイプ &lt;code&gt;box&lt;/code&gt; 値は、次の構文のいずれかを使用して指定されます。</target>
        </trans-unit>
        <trans-unit id="80edaabf28ae789b6d2df8969096454a0d5adc8a" translate="yes" xml:space="preserve">
          <source>Brackets (&lt;code&gt;[]&lt;/code&gt;) are used to select the elements of an array. See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more information on arrays.</source>
          <target state="translated">大括弧（ &lt;code&gt;[]&lt;/code&gt; ）は、配列のエレメントを選択するために使用されます。配列の詳細については、&lt;a href=&quot;arrays&quot;&gt;セクション8.15&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a42247eae020c4a6a90987074cedeaeafefcb933" translate="yes" xml:space="preserve">
          <source>Break the input string into tokens and categorize each token as a string, time, time zone, or number.</source>
          <target state="translated">入力文字列をトークンに分割し、各トークンを文字列、時間、タイムゾーン、または数字に分類します。</target>
        </trans-unit>
        <trans-unit id="7f060d64f6791f16fa5efaff60c076733c80c6cc" translate="yes" xml:space="preserve">
          <source>Brian Gladman</source>
          <target state="translated">ブライアン・グラッドマン</target>
        </trans-unit>
        <trans-unit id="ffa9096408246acd9955cddd88051877608e02b2" translate="yes" xml:space="preserve">
          <source>Bucardo</source>
          <target state="translated">Bucardo</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="8d8140d7cfbb395763a377b0065a8f622c660961" translate="yes" xml:space="preserve">
          <source>Build a new index. The index relation has been physically created, but is empty. It must be filled in with whatever fixed data the access method requires, plus entries for all tuples already existing in the table. Ordinarily the &lt;code&gt;ambuild&lt;/code&gt; function will call &lt;code&gt;table_index_build_scan()&lt;/code&gt; to scan the table for existing tuples and compute the keys that need to be inserted into the index. The function must return a palloc'd struct containing statistics about the new index.</source>
          <target state="translated">新しいインデックスを作成します。インデックスリレーションシップは物理的に作成されていますが、空です。アクセス方法に必要な固定データと、テーブルにすでに存在するすべてのタプルのエントリを入力する必要があります。通常、 &lt;code&gt;ambuild&lt;/code&gt; 関数は &lt;code&gt;table_index_build_scan()&lt;/code&gt; を呼び出して既存のタプルのテーブルをスキャンし、インデックスに挿入する必要があるキーを計算します。関数は、新しいインデックスに関する統計を含むpallocされた構造体を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="5ab5f75a4f668c4f5eba6aa186b68fe6555350c4" translate="yes" xml:space="preserve">
          <source>Build an empty index, and write it to the initialization fork (&lt;code&gt;INIT_FORKNUM&lt;/code&gt;) of the given relation. This method is called only for unlogged indexes; the empty index written to the initialization fork will be copied over the main relation fork on each server restart.</source>
          <target state="translated">空のインデックスを作成し、指定されたリレーションの初期化フォーク（ &lt;code&gt;INIT_FORKNUM&lt;/code&gt; ）に書き込みます。このメソッドは、ログに記録されていないインデックスに対してのみ呼び出されます。初期化フォークに書き込まれた空のインデックスは、サーバーを再起動するたびにメインリレーションフォークにコピーされます。</target>
        </trans-unit>
        <trans-unit id="59b2f3dbb6bd6f1f5bde23a4b9bc5f2c1659dd06" translate="yes" xml:space="preserve">
          <source>Build the new PostgreSQL source with &lt;code&gt;configure&lt;/code&gt; flags that are compatible with the old cluster. pg_upgrade will check &lt;code&gt;pg_controldata&lt;/code&gt; to make sure all settings are compatible before starting the upgrade.</source>
          <target state="translated">古いクラスターと互換性のある &lt;code&gt;configure&lt;/code&gt; フラグを使用して、新しいPostgreSQLソースをビルドします。pg_upgradeのが確認されます &lt;code&gt;pg_controldata&lt;/code&gt; を確認すべての設定がアップグレードを開始する前に、互換性があります作成します。</target>
        </trans-unit>
        <trans-unit id="b0efda5eef1ba866b7542374c8ece9a4b87bf621" translate="yes" xml:space="preserve">
          <source>Build time for a GIN index is very sensitive to the &lt;code&gt;maintenance_work_mem&lt;/code&gt; setting; it doesn't pay to skimp on work memory during index creation.</source>
          <target state="translated">GINインデックスのビルド時間は、 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 設定に非常に敏感です。インデックスの作成時に作業メモリを節約することはできません。</target>
        </trans-unit>
        <trans-unit id="33f8808cf736a2f0f4fe91a19f0db395826f76fd" translate="yes" xml:space="preserve">
          <source>Building Indexes Concurrently</source>
          <target state="translated">インデックスの同時構築</target>
        </trans-unit>
        <trans-unit id="39c26d35b65d38341a1a91676925e41df6b2055c" translate="yes" xml:space="preserve">
          <source>Building an index type that supports concurrent updates usually requires extensive and subtle analysis of the required behavior. For the b-tree and hash index types, you can read about the design decisions involved in &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; and &lt;code&gt;src/backend/access/hash/README&lt;/code&gt;.</source>
          <target state="translated">同時更新をサポートするインデックスタイプを構築するには、通常、必要な動作の広範囲で微妙な分析が必要です。b-treeおよびハッシュインデックスタイプについては、 &lt;code&gt;src/backend/access/nbtree/README&lt;/code&gt; および &lt;code&gt;src/backend/access/hash/README&lt;/code&gt; に関連する設計上の決定について読むことができます。</target>
        </trans-unit>
        <trans-unit id="47e5cdcd370dad05acde9abb1ab525b1924edb0a" translate="yes" xml:space="preserve">
          <source>Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not.</source>
          <target state="translated">単純にすべてのタプルを挿入して大規模なGiSTインデックスを構築すると、インデックスタプルがインデックス全体に散らばっていて、インデックスがキャッシュに収まらないほど大きい場合、挿入では多くのランダムI/Oを実行する必要があるため、時間がかかる傾向があります。バージョン9.2以降、PostgreSQLはバッファリングに基づいてGiSTインデックスを構築するより効率的な方法をサポートしています。なぜなら、一度に新しいタプルを受け取るのは少数のページのみであり、インデックス全体がそうでなくても、それらのページはキャッシュに収まるからです。</target>
        </trans-unit>
        <trans-unit id="802f99132933c7e50ae4b1dc60414e1dd9622319" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair.</source>
          <target state="translated">テキスト配列から JSON オブジェクトを作成します。配列は、偶数のメンバを持つ正確に 1 次元でなければなりません。この場合、それらのメンバは交互にキーと値のペアとして扱われます。</target>
        </trans-unit>
        <trans-unit id="12655969a97b05cc10e81a0f90560ca3e925543c" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.</source>
          <target state="translated">テキスト配列から JSON オブジェクトを作成します。この場合は、キーと値のペアとして扱われます。 あるいは、各配列の内部に 2 つの要素があるような 2 次元の配列で、キーと値のペアとして扱われます。すべての値はJSON文字列に変換されます。</target>
        </trans-unit>
        <trans-unit id="f2aecbff08d9f05062e48cef54ff41a7deab5245" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values.</source>
          <target state="translated">可変引数リストからJSONオブジェクトを構築します。規約では、引数リストはキーと値を交互に並べたもので構成されます。</target>
        </trans-unit>
        <trans-unit id="3f46fcc8bccbe3831f46147a1da2fc888d15802b" translate="yes" xml:space="preserve">
          <source>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="translated">可変個引数リストからJSONオブジェクトを作成します。慣例により、引数リストは交互のキーと値で構成されます。重要な議論はテキストに強制されます。値引数は、 &lt;code&gt;to_json&lt;/code&gt; または &lt;code&gt;to_jsonb&lt;/code&gt; に従って変換されます。</target>
        </trans-unit>
        <trans-unit id="ad91ede47a5280dfb0e7c89b0ab06f2bb7e0630d" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list.</source>
          <target state="translated">可変引数リストから、異質な型を持つ可能性のあるJSON配列を構築します。</target>
        </trans-unit>
        <trans-unit id="fc07e20c2337d94398080bc4db916907237b8429" translate="yes" xml:space="preserve">
          <source>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per &lt;code&gt;to_json&lt;/code&gt; or &lt;code&gt;to_jsonb&lt;/code&gt;.</source>
          <target state="translated">可変引数リストから、おそらく異種型のJSON配列を構築します。各引数は、 &lt;code&gt;to_json&lt;/code&gt; または &lt;code&gt;to_jsonb&lt;/code&gt; に従って変換されます。</target>
        </trans-unit>
        <trans-unit id="6b5998f67810590d9a53e6c46c1e94143e2a8d11" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary record from a JSON object (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">JSONオブジェクトから任意のレコードを作成します（下記の注を参照）。 &lt;code&gt;record&lt;/code&gt; を返すすべての関数と同様に、呼び出し元は、 &lt;code&gt;AS&lt;/code&gt; 句を使用してレコードの構造を明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="08637f34c0762d04a0506b89a280023ac2d9b88b" translate="yes" xml:space="preserve">
          <source>Builds an arbitrary set of records from a JSON array of objects (see note below). As with all functions returning &lt;code&gt;record&lt;/code&gt;, the caller must explicitly define the structure of the record with an &lt;code&gt;AS&lt;/code&gt; clause.</source>
          <target state="translated">オブジェクトのJSON配列からレコードの任意のセットを作成します（下記の注を参照）。 &lt;code&gt;record&lt;/code&gt; を返すすべての関数と同様に、呼び出し元は、 &lt;code&gt;AS&lt;/code&gt; 句を使用してレコードの構造を明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="5cd7d28e330cbb1847ac7f97e57334ab1657662f" translate="yes" xml:space="preserve">
          <source>Built-In Functions</source>
          <target state="translated">内蔵機能</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
